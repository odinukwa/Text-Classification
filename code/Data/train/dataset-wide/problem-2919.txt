This assignment is not terribly necessary. Your algorithm can be simplified considerably. I think this should be left as an exercise, but here are some things you shouldn't have to do in the new algorithm: 

Inside the function. Function naming should be renamed to . Better algorithm is unneeded and limits your algorithm significantly. I would over the of your string: 

Why not something like and ? and are used so often I would certainly forget (even with the comment) that this referred to falling objects in particular. 

Although you should comment your work, some of your comments seem unecessary. Let's look at some lines to see why: 

At a quick glance, you do most (if not all of these tests). So in some sense the coverage is good. The amount of testing may be overkill. You have to realize you can't test every possible thing. With that in mind your tests should: 

are you sure this is correct? Concatenating a column name to the other like that? Are you assuming the column name will be passed in followed by a comma? And anyway, isn't it going to blow up with a syntax error when you do the `UPDATE`? Or will the column name get passed as an empty string? Might be a good idea to check what garbage you are receiving through your parameters, assuming said checks aren't already in place at an upper layer. How can you be sure all callers will remember to pass your arguments exactly the way you expect them? Plus, just my two cents, but if my assumptions are correct, this is not a very fun API to work with. 

For one thing, the domain being global is not very good: what if two users have email addresses on different domains? Are you going to set it to different values in between user creation? Just let the user have its own email address. Globals in general are frowned upon for many reasons, so when you catch yourself thinking "yes, I'll make this a global", please count to ten and then don't do it. To answer your question in the comments, where you assume you have an internal mail server only: a good rule of thumb is to keep outside of your program everything that can conveniently kept out. In this case, the domain is configuration, and as such it should be kept in a configuration file. Your program does not and should not know what the specific domain is. It just needs to know how to read it from an external configuration file/database/what-have-you. Modifying software is not a lot of fun, so if you can make a program whose behavior you can modify without even touching the source, it's way better. What if your domain changes? As it stands, you have to change your program, and possibly even test it again. What if the domain sits in a config file? You change it in there and you're golden. If you think hard enough, you will find that a lot of configuration can be kept outside of the program, even down to the choice of different algorithms to accomplish the same task. Personally, I try to make everything I make as configurable as possible, because recompiling and testing and deploying is boring. Finally, globals are bad because they're hard to keep track of, and it's difficult to know what parts of the code read from and write to them, which makes the whole thing horribly coupled. Do try to avoid them as much as possible. 

Prelude Firstly, you might want to ask on Math Stack Exchange if there is any analysis. This game looks a lot like Nim and a variant of the subtraction game (mentioned later in the article). The subtraction game in particular has a really nice and cheesy solution. The major difference is that you prevent taking any number away twice. On to the code! Default values When you start a game, the first player to go is, well, the first player. I don't think a user really wants to waste their time typing it. A similar argument goes for . You shouldn't really need to specify it. Hide it make the default value . so: 

Organization As Simon points out, you shouldn't put the list of functions inside of . It doesn't make much sense. Move them out into the class. Use in python is equivalent to in C# and many other languages. This: 

Code like this is bound to be a bit hairy. However You aren't using parameters This is a big security vulnerability. What's that method doing? Is it doing everything by the book? Does it handle every possible obscure corner case? Let ADO the MySQL connector manipulate your query, especially if there's a chance you're handling values supplied by the user. MySQL can perform the so-called MERGE (also called UPSERT) You can do it via INSERT ... ON DUPLICATE KEY UPDATE statement. In case you are not aware what that is, it's basically a way to either insert or update in case the fails because of a duplicate key error. It's for sure faster than making a separate query to retrieve the records that are currently present. By the way, code like this leaves your code open to race conditions in case another user inserts a record exactly between when you read the current records and the moment you execute your . This is bad, and you're not currently guarding against it. MySQL can do it for you, take advantage of it. EDIT Also 

A couple of the things they mention are only a concern for Python 3+ like . Also, it seems is a grammar rule introduced in Python 3+. (However, you may want to account for this in the future.) You seem to be also removing docstrings from , I am not one hundred percent sure, but you may also want to add as well. There is also a . However, I find it rather weird stylistically compared to your current method of looping. So... I'm not confident in making any comments about whether you should be using it or not. Nevertheless, I'm putting it out there so you are aware in case you weren't. 

Python naming conventions PEP 8 says that functions and variables should use so should be . Naming issues is the best score that you have for all the generations, name it instead. Similarly: . I think is ok. I would have used or but then again it's not really a genetic algorithm so there isn't really evolution so one could argue is better than ... 

Bearing in mind that a linter can only look at how the code is written and not at what it's actually doing, statements (or the equivalent as with Ruby) that don't do much are completely fine. A switch that tests many conditions is bound to be long-ish, there's not much you can do there. Every one of the warnings you get is a direct consequence of the fact that you're testing 8 values. I would say this is one prime example of a situation in which you just don't waste your time in an attempt to make the linter happy. Extracting methods is going to clutter things up and look dumb. The only viable option that I can think of right now is sticking those ranges along with their readable description in some kind of hash, and retrieving the value from there. But it's a compromise, really: if this method gets called often, you could be instantiating yet another object at each call. I say you just ignore what the linter says in situations like this, or adjust its default settings to make it less bitchy. Your method is fine, the intent is very clear to me, and it's not doing anything complicated. Don't get all caught up in an attempt to please a tool that doesn't understand your code to begin with. 

is the name of the Garbage Collection interface module. It shouldn't matter too much, but, when reading your code, it feels like that you are asking the garbage collector to find books and then I remind myself that it isn't actually the garbage collector. 

Take in a divisor count. Index through each triangular number and check if it satisfies the condition. If it doesn't increment and repeat. Once it does print out the results. 

There actually may be is a better way to represent this with JSON. I'm not a JSON expert. The point I'm trying to make is this will help clean up a lot monster creation code, and room creation that looks like this: 

This code is also pretty self explanatory. If you did have a comment you should be explaining why you do this. However, bubblesort is pretty well known so you probably don't even need a comment on this.