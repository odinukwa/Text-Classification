The first parameter indicates the starting address of the memory block you want to assign values to. The second parameter indicates the value each byte of the memory block will be filled with. The third parameter indicates the number of bytes forward of the starting address to affect. For example, if then all your s will be thanks to twos-complement. Beyond there are functions that allow values longer than one byte to be assigned to each index of an array, as other answers have mentioned. Copy-Pasta Bugs Copy-paste is a useful tool for repeated segments of code. However, I always ask myself if the code I'm about to copy-paste would be better off in its own function. One of the goals of writing efficient code is to reduce the amount of repeated code. The copy operation in : 

To solve the excessive collision issue just ensure is always a power of two by using the bitshift-left bitwise operator and bitshift-right bitwise operator : 

In a project I'm working on, the data access layer has evolved to something that somewhat resembles the Unit Of Work and Repository patterns, at least they started with those names, I'm not entirely sure with how far they've drifted, if they can still be called that. For classes data access, an implementation is passed as a constructor parameter from the IoC container. This is a rather simple interface: 

I've benchmarked my program, and have discovered that the single function taking the most time is the one that does the following. 

So, is a list of objects, which contain the additional data I need. I figure this is worst case is about O(n^2)-ish. Once this function was identified as a bottleneck, I made a first attempt at optimizing this function. First, I ensured the split list of statements, and the known list of statements were both sorted, and then implemented this: 

My implementation for NHibernate basically just creates an NHibernate session, and passes it to the NHibernate implementation of , which is just a rather thin wrapper around the NHibernate session, which starts a transaction in its constructor, and rolls it back in the implementation unless the method is called. Then, anywhere data access happens, it follows this pattern: 

Don't modify your state directly In general, it's considered bad practice to directly modify your state object. According to the react docs: 

Note that this does still use an arrow function and not a bound method. I think that this lets to code be much more readable, and the possible performance loss wouldn't be realized until you have components that implement deeper in the call chain receiving this function (currently it goes directly to an . 

Heck, it's so small that I would probably even put it inline, but different people might disagree on that. Revised Version Here's what my revised version of the code would look like: 

With this you can see exactly what is getting passed to your , and you can use this to wrap other components too. 

Stop using like that Using in your loops introduces another variable you don't need, and actually makes things slightly less correct. Don't use for prop The prop should be a unique key to identify that element. The most unique things we have about each of these checkboxes is the name that goes with them. If we rearranged this list, we would want the same names to stay checked, not the same indexes in the list. Don't use as an At least not directly. You want your ids to be unique on the page, and using the ids , , , etc. seems like not a good way to be unique. It would be better to use something like so we get , , etc. It also used to be the case that ids needed to start with a letter and not a number, but I believe this is no longer the case. You don't need an extra layer in your state It just adds needless comlexity. Just put the checkbox values right in your state, and only move them when you need to do more complex things with your state. 

I cannot change the input data, since it comes from several different systems, and the closest thing we can get to something in common is a delimited list of strings. So, enough background, the first implementation of this was a naive set of LINQ statements: 

I have some entities in use in my project, and to make things easier, I would like to have the type of the key for that entity defined via a generic. E.g.: 

Essentially, I loop through the statements I need to look up, and start working through the library of statements, remembering where the last statement was found, so I can exclude all statements in the library that are before the last one found. This did result in a speedup, but not as much as I would hope, hence me throwing this out here to see if I can get another perspective. 

This way, I can pull the Id field into the base entity and not have to define it every time (There's a few other fields on Entity in the real system, so there is other utility to doing this) Then, since I'm using Fluent NHibernate, I make a generic mapping class to go along with this generic entity: 

This heap will be used for A* search pathfinding in my 2D isometric game engine. It uses lambda functions (instead of or ) to allow me to dictate min-heap or max-heap more dynamically. It also uses lambda functions for , , and so that the search key can differ from the compare key (for example: sorting by priority, but searching by name). Typical use: 

Be sure to assign after everything is done copying, otherwise indexing through the changed will be troublesome, and won't actually grow the array the second time its called. Re-inventing the wheel If your variable is one-byte in length (EG: or ), then the loop where the array of integers is set to a specific value: 

The one defined at or the one defined just before the ? The quick-fix is to rename one of the variables, however another thing I ask myself when I'm about to copy-paste is if there are variables I'd have to hunt down and rename like that. If so the code is better off typed from scratch, plus you get to think about your logic a bit more as you type it out. Indexing The difference between and is significant, but the data in that gap is not. Also, going past will give an index-out-of-bounds/read-access error on , so: 

I agree with what Dan Bovey says, and I would go one step further to make it more explicit and make take a render prop: 

Ok, I had quite a few thoughts on this. State Your state seems more complex than it needs to be, and some of it is hiding outside of the variable. I think all you really need to keep track of are: - What order the images are in - Which images are currently selected - Which images have been guessed correctly I don't really understand what is, how it's different from , or why it's an instance variable. Extract stuff I think you have too much stuff crammed into one component. I think you need to extract pieces of logic that can be self contained. Prime example: Why is declared inside ? This is creating a new function every time is mounted. I think should at least be outside of this component, and really should be in a some sort of file. Card component I would also extract out a Card component that renders a card. It should know: - What image to display - Whether or not it's selected - Whether or not it's been guessed correctly This way you can keep your MemoryGame component about managing the state of the game while the Card component focuses on presentation. Other Thoughts 

Made me wonder if your function could be called instead of copy-pasting its loop. In this case you made the right choice to just inline the loop, but it's something to keep in mind. 

Its easier to review code if its complete, so please include the class declaration and full definition. However, working from the top I'll make some suggestions. Parameter lists If your declaration (header file) has a data member , then member functions don't need it passed in as a parameter, namely 

That will result in undefined behavior once is accessed again, and it also leaks the original 's memory. So just switch it around: 

This works because is already scoped to so every member function already has access to . Then there's the bonus of not having to make a copy of the array pointer each time, which speeds up your code a bit. Variable Names More of an aesthetic point than a functional one, but would be easier for user's of your to understand if it were or the like. Two reasons for this: 1) The name is typically used as for template parameter types, and 2) itself doesn't really express what the variable is used for. This means well named variables add the benefit of making your code self-documenting. Storage Space Only one decimal place precision is checked for in , so a is more storage space than is necessary. would work just as well and saves some memory (on most machines). Memory Management Your code s the block of memory it intends to use for after its been assigned to , namely: 

Any feedback on better naming for these things, or better methods? This has served me rather well, with the only thing I don't really like is creating the repository instances like that, But I can't think of a way to handle transactions and keep the somewhat lower level data access code away from higher level business logic. 

Next up are the classes. These don't have any common inheritance or interface implementations, they just follow a few conventions, the main one being taking an in its constructor. These classes contain the interaction with the for operations like , , , , etc, and are responsible for small bits of logic (the method updates the field on the entity, determines what fields to search based on its parameters, etc). So, for example, a Repository for the User entity might look something like this: 

And starting here is when I wonder if there's a better way of handling this. C# doesn't seem to infer the type parameter from the definition, and having to add to all of my mapping classes the key parameter for the entity they map seems redundant, all the more so since it also extends to some of the higher generic data access classes, e.g.: 

The primary data structure is a c-style array because I wanted the practice, so the heap arrangement only works on contiguous memory blocks. Dynamic memory allocation for the array occurs in block sizes given by the as seen in to reduce allocation overhead. The allocated memory is only freed on , , or if the is called. I've unit-tested this with POD types, , and and it executes all functions without issue. Question: Are there any memory leak/corruption issues I'm not seeing? 

so it must be freed as an array with (not ) otherwise will also be a memory leak because only its first element would have actually been deallocated. 

The dark side of copy-paste is the potential bugs it introduces. The variable gets redefined halfway into your copy operation. That will confuse the compiler and throws a monkey wrench into your copy-probing. Namely, which should the compiler use use here? 

This prevents the indexing from going beyond automatically (no bounds checking required). The downside is it will cause more collisions on average compared to , but its something to think about given that you're already handling collisions.