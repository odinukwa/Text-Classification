This is a substantial improvement over the previous version. The code is consistent, I do not see any bugs, it's generally good. There are two further opportunities for improvement that I can see. 

SortedStack This class has some simpler problems - naming, and style. It also has some algorithmic problems that may be improved. and are horrible, horrible names. and would be better. But, really, there's no reason to have at all, you can create it for the duration of the push method only - it does not need to hang around when empty. You also have the following, very baffling method. This is a "WTF" thing: 

by doing this, you can allow the user to catch just the database exception, or more-specific database exception sub-types if needed.... The 'user experience' will look like: 

Now your search arrays contain the forward, and if the word is not a palindrome, it also contains the backward versions of the search list. Now you can remove half the directions to check, and you can remove your post-search palindrome removal logic. 

General Your code formatting is all over the place. You should use consistent and structured indentation. See the Java Code-Style guide for, well, guidance. if I take your code, and re-format it (Eclipse, CtrlA and CtrlshiftF), it looks like: 

These two clues are begging you to implement a recursive post-order traversal of a fixed depth tree. If you know a node is missing from the flux chain, then you know that your traversal "up" from that node in a correct tree, will take you to the parent. A complication in this problem is that you don't know the order of the disconnected flux chain nodes in the input, so you have to "search" for them in the output, but.... with a small trick, you can turn the whole problem in to a single (post-order) traversal of the ideal (correct) flux chain, and a small lookup table for the answer indices. The above solution would be an \$O(n)\$ time complexity solution, and would use a small amount of memory proportional to the count of values in . Now, that's the solution I think they would expect in a good case.... but I suspect that there's a mathematical solution that is much faster.... I am still figuring it out... but, in the mean time, consider this code that does a post-order traversal, and identifies key nodes in the flux chain. It then uses a trick in the return value of the recursive function (negative values for missing links) and a to identify the keys, and their respective indices in the answer array. This is not my most pretty code, but it serves to show you the post-order traversal with the index lookup: 

I would always put the notifyAll() after the size++. This does not make a functional difference to the program, but it makes the logic more apparent (that will happen before any other thread can read the value): 

But, in reality, there is no need for the StringBuilder if you use plain String Constants, and also use else-statements, and also use (which is and ). 

This program finds all combinations of numbers that add up to a specified number (). There are a number of things that I dislike about it. 

I don't like either solution (or the currently suggested answers). In any application where you run a ServerSocket, I believe that the socket management should be done on the Main thread. This would avoid the exact situation where you have a . The basic pattern for a server application is: 

Code style: Seriously, you manually create the blank ? Wasn't that sore on the wrists? Lazy programmers are a good thing, consider the following: 

It is 'standard' to have at the beginning of the 'alphabet' for numbers.... I would have suggested that you use the native functionality in BigInteger to convert the value to a String in any given radix, but unfortunately, it does not support more than radix 36. Still, you should follow that standard and start with instead of ending with it. I would also suggest two things: 

That gets the number, if the is not null. Now, using that function, we can create a reusable comparator instance using the tricks that Java 8 introduces. Consider these chained comparators: 

Now, as a looping system, that's how you should have presented your solution. Note that your logic is clear enough, your variables are well named, and the logic looks sound enough. On the whole, your answer is good, and just needed some tweaks. ... but... is there a better solution that does not use looping? Consider the pattern in the rooms/floors... Odd floors have 5 rooms, even floors have 10 rooms. Can we exploit this better? Well, yes, we can treat the floors in pairs and have 15 rooms per pair... and then figure out whether it's in the first of the pair, or the second. Note that using division and remainder operations works best as a 0-based system, not a 1-based system like the input values are in, so we "map" each room to be 1 less, and each floor too, so we treat room 1 as if it was room 0, and floor 1 as if it was floor 0, and then shift the results back afterwards too. I have named zero-based variables with the prefix 

There are still issues, like what happens if the length or height are less than 2? That would be a problem. Consider ways to avoid that, or handle that. 

The above function takes the data, and scans through it just once. As it goes, it keeps track of the highest 'n' numbers, where 'n' is the nth largest number you want to get. The overall complexity for this function is something like O(n log m) where is the number of elements in the input data, and is the input value nth (if you want to get the third-largest value, then ). 

take a copy of your system properties using the snapshot take another copy, each time you dump an item though, use the Exchanger as an interlock, and randomly change something in the Map. ensure the original copy, and the concurrently modified copy are the same. ensure that the modifications made during the second snapshot are now shown in the third. 

Using multiple calls for each star is very inefficient. Print is a slow command, and it also makes what is a relatively simple process (printing a line of stars) become a more complicated loop. A more efficient way to output the triangle would be to use one per line. An even better way would be for one println for the whole puzzle, but that has a potential issue of the value is large. A real trick here would be to build up one String value for the longest line, and then just print substrings for the shorter ones. Note, using is a clever way to manipulate the substring, but combining it with a loop from to makes it even easier to understand. Additionally, putting the code in to its own method, instead of the main method, makes the code more reusable. 

In general, you should use one, and only one synchronization strategy in any class. You have synchronization, and are contemplating volatiles too. The best-practice mechanism for now in Java is using the classes from to manage locking, and memory synchronization. The benefit from there that will help you most, is the Condition concept, as well as the fine-grained management of locks. Your locking at the moment relies on a 'global' lock that all events use, thus if you have many collections of events running, each collection uses the same lock. Thus, if some other Events are happening in some other code block somewhere, we will still be notified or each of those 'remote' event completions, and our completions will notify their awaits.... Additionally, I did not like the way you manage the await-any concept. You literally scan the Events for changes, and check for one to complete. In essence, I dislike: 

Lots to think about, this is not a comprehensive evaluation Use Java7 your code style indicates you are using Java6 (you are not using the diamond operator ...). Java 7 and it's recent updates are faster than Java6. Extract the comparator: 

I don't like the public method. This is not 'symmetrical'. Only the toString(UUID) should be public. The code appears to be designed to satisfy many different radices (radixes, what's the plural?). This makes it a little bulky for this special case. There are too many levels of method calls. It can be much shallower. 

So, you are creating a future that will result in a ChannelDecoderEvent output (that is what the ExecutorService.submit(...) does). But, when you pull values from the queue with: 

That method would be reusable, and general, and it exposes the right amount of functionality without exposing the inner workings of the class. In your main method, if you would call: 

This query is horribly over-working. I can only believe that the query has been 'simplified' to put here on CR. Otherwise, as far as I can tell, the query can be rewritten as: 

They are limited in size (to 231 - 1 members) once initialized, they cannot be expanded, only replaced. Replacing an array requires having both the old, and new array in memory at once, and all the data needs to be copied from the old to new location. they require consecutive spans of memory to be stored in. 

About the complexity you ask if worst case is \$O(n^2)\$ ... no, it is not. Worst case is \$O(n \log(n))\$. This is my reasoning: 

The Code for the Branch class will need to allow you to track the branch weight, and to add Items to the branch. Then, at the end, return the Items too. 

That line takes a number, converts it to a string, and then reverses the string, and then converts the string back to a number. Note that in each conversion, you need to convert between base-2 and base-10 number systems, and that you need to allocate space for the String, etc. While the following takes more code, it actually does less work: 

This function should have some appropriate error handling too. Then, your code can become simplified like: 

Sometimes a 'guard condition' is needed to ensure that input parameters create a valid condition that can be processed. Other times, you need a condition to handle special cases in special ways. In your case, however, there is a simple solution which you can affect by changing the limit of your for-loop. Currently, you have: 

The urge to use Java8 features is strong, but, you need to look at the patterns of the problem, and not try to force the lambda to fit, rather, use the lambda to express the problem. In this case, you have a stream of values that represent a Collatz sequence, but, that's not true. A Collatz sequence is terminated when the value is 1, but your initial Stream does not have a terminal condition: 

and then the function returns the largest value. Now, about the algorithm, this is more complicated. There is a way to do it in \$O(n)\$ time complexity. You can scan all the data just once, with a zero-counter, and multiplication and division. 

There's still an issue with the points, which should start at 0, and you may want to revise the system. Note that the outer loop is a true infinite loop (using ), but the inner loop is essentially a do-while loop. Looping until the right number is guessed. note the change to the print statements, which makes the output more readable on my computer too. 

Note, the Node is private, and not visible outside the KDTree class. It is possible that you need some other form of data structure to represent the actual data in the Node, like a class, and, your Node could have a reference to a instance. Point strikes me as being a data structure you need anyway, and probably already have. Note that your x and y values are doubles, and any time I see comparisons with doubles, I caution people that it is not as reliable as you would expect: 

To solve things my way, you have to be assertive about your conditions. Here's the code I would use (using names maaartinus suggests): 

The method does nothing of the sort though... it takes one variable, and there's no indication the values repeat, and it returns missing values, not repeats. Additionally, the method name is but there's nothing in the implementation that suggests that the values have to be consecutive at all... Also you suggest the array is sorted, but not whether it is unique... for example, your code may break on (missing is 3 and 5): 

Having stewed over this code for a few days, I have decided there are three things I did not like that are significant. 

Note that the method is now static, and it does not need the section to clean up. You can see this running in ideone: $URL$ 

So, I looked through your code, and, it took me a moment, but I found all of those processes in your solution. So, you have solved this the same way I would have tackled it. The algorithm is 'good', and all that is then left, is to look at how you have implemented it... 

That is OK, but it would be better to implement it using the range operator (semi-inclusive instead of inclusive ) and a for-loop: 

Code Review is not the place for debugging code as it is run on remote systems, so I am not going to go looking for the problem there on CodEval. On the other hand, the basic algorithm you use appears logical, even though it is a pretty slow one, and the implementation uses some pretty dubious practices. As a general rule, if there is a special case in a program (like the first line of the file being special), then you should code that case in a special way. You should not make the normal process do something special each time. Additionally, while Object Orientation is a good thing when the objects match "something", if the Object is a kludge of unrelated, or not even real stuff, then the Object is not helpful. In your case the Object is . What is a - you have an object that represents a method? Or, is it an object that represents a boolean state (we are line 1 or not), or is it a String containing the current line? In other words, your is a poor Object to model. As it happens, there's a good algorithm that's pretty fast, and really simple, that "just works"..... Instead of reading all the lines and sorting them, you just need to keep the number of lines that you need to report, and if you get a new line that's longer, you insert it in to the result, and throw out the shortest.... basically, just keep an array of the longest lines, and maintain it as you read data. Note, here I set the Object to be the "Top results", and call it "TopX" (where X represents the number), so would report the 10 longest lines...