Background I'm writing code for an 8-bit MCU with very limited RAM (1KiB) and program flash space (64KiB). I have a C++14 capable compiler with no standard library implementation available. This is a good enough excuse for me to do some recreational template programming. :) In the project where I intend to use this I need to be able to create a densely packed, complex, configurable tuple of varying types and values. And I need this data structure to be stored in program space, so I need it to be usable as . About the code In the code below I have used for the size type because the MCU has 8-bit words and an (which has to be 16 bits to be standard compliant) thus is "extended precision" for my MCU and incurs speed and program size overhead. And frankly, with 1K of ram I'm not expecting to make tuples with more than 255 elements. The code is put into a single file for your reviewing pleasure and uses which is technically not available on my target, but I intend to re-implement it as the next step. This code is written for PC first to be able to debug and test it. I'm happy for any comments on suggestions on the code, but please bear in mind the target architecture. tuple_test.cpp 

is incremented once per explored node and then used as base cost for the search node. This is incorrect. You must use the number of moves taken to reach that particular position + heuristic value. This means that you must store the number of moves used to reach a particular in the . In other words, you should do this instead : 

The above implementation has \$\mathcal{O}(n\log k + k\log k)\$ time complexity where \$n\$ is the number of points and \$k\$ is the number of walls. The implementation also has high data locality. 

Style I understand that this is a quick and dirty piece of code to earn some points on some code-challenge website. I will still offer some comments on style. 

You should ideally prefix the include guard by something that is unlikely to cause a collision with any one using your library. As it stands now it is at risk of collision if some one else unluckily choose to use as their include guard. Hide implementation details To me it looks like the class is not directly intended to be used by the user. In that case you should wrap it in an internal namespace so that the primary namespace that the user sees isn't cluttered with internal functions. Naming I think that the name is kind of mixing two different case standards. To my knowledge there are kind of two major standards emerging, one is to use CameCase in which you would name your class and the other one is to use inderscore instead of space and all lower case so you would have . If you're going to allow upper case in names, then I would at least suggest that you use leading upper case like so . Any of the above are easier on my eyes than the current name. Also I think that the functions would be better named : 

Your benchmarking code is inaccurate as it does not include a warmup phase to let the JIT compiler optimize the code prior to the benchmark. You should use a benchmarking tool like Âµbench or at least abide by the guide lines in this question. Also because your algorithm uses random numbers you need to multiple trials with different seeds to get a better idea of the average behaviour. And also look at the standard deviation of the timings. I'll get back to the rest of the code later when I'm not dead tired. :) 

The result is the same because you're truncating anyway. Model View Controller (non-)separation Your class mixes all three of model, view and controller. It is very desirable to keep these separate. What I would do is to separate everything that has to do with the game simulation: , , the etc and put into a new class . Next I would separate the UI design from the class and put it into an FXML document that describes the UI. Then I would have a separate controller class for the FXML document and leave the application class just as a pretty basic launcher. If what I just said sounds like gibberish, have a look here: Model View Controller. Using FXML would allow you to create your event handlers as member functions in the controller instead. So you would have: 

you allocate space for the whole triangle but you only ever use the last two rows. So you only need to store two rows and alternate between them. This has the added benefit that both rows will be hot in cache all the time, avoiding cache misses as you go from line to line. It will also avoid some extra indirections in your inner most loop. Better algorithm The first thing we need to realize is that the problem is kind of recursive (I can't remember the proper term off the top of my head). What I mean by that is that if a base for crumbles, then the all bases for any will also crumble. This means that by solving the easier problem we get information about a lot of combinations for that will crumble. (1) The second thing to realize about this problem is that if crumbles, then will also crumble. And if doesn't crumble and has top value then will also not crumble and have the same top value . (2) The third thing is that for the base the top value will be strictly larger than . This is a useful stopping condition. (3) Knowing the above, you have to unrestrainedly search for the combination of base elements that produces the smallest top value as result. Use a greedy search for the smallest top value and terminate when all the nodes remaining fulfil (3). The difficult part is to generate the nodes to be searched. This can be done effectively by starting with small and then combinatorially incrementing the base elements and adding an additional base element to create triangles with base for any triangle that doesn't crumble. This exploits (1) to prune large sets of crumbling triangles from the start. One should also take care to not generate symmetry pairs to triangles that have already been tried to exploit (2). It is useful to store the base and right edge of the triangle in addition to a of all the values in the triangle. I.e. for the triangle: 

I believe that you are expending way too much energy trying to solve something that should be a non-problem. Simply always let your containers be zero based, if you have for example 1-based indexes as input, simply subtract 1 from them as soon as you get the input and convert back right before output. Always use zero-based indexes internally and only convert as close to input/output as possible. (too large for comment really) 

This will construct the pair in place and avoid the copy constructor (the compiler might have optimized this for you already). While we're at it, we can realize that will not be used after this statement until it is ed. So we can steal the memory and avoid another two /s (unless your STL has SSO and your strings are small, in which case this is moot) just activate the move construction of the like this: