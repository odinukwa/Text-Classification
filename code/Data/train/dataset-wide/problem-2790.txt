It's usually recommended to prefer the primitive type over its wrapper class, unless you have a clear intention to return values for indicating the absence of a value. Interfaces over implementations 

Bonus: Oh yeah, is it the largest or longest palindrome you are looking for? Since you are dealing with s, my suggestion is to be consistent and stick with permutations of 'longest palindrome'. :) 

Variables naming , , are poor names for variables, as they give no context as to what they are. It is easier to read them as , and . Sometimes, if you do not need to refer to a UI element beyond the initial assignment, e.g. for those labels, you can even combine the usage of a utility method and method-call-inlining to simplify the declaration. For example: 

I suppose this works currently because you only get a single result row, but please be aware that if you have multiple rows, you will simply be re-referencing until the last row of your . Getting dates All you need is a nice method that converts to : 

You should choose whether you want to 'describe' such comparisons as 'not either the following', or 'not this and not that'. When you stick to one description, you don't have to context-switch between the various logical operators... just one common understanding will do. :) For illustration, here is the same comparison with the latter: 

Have you tried ? This method is available since Java 1.4. BTW, a is recommended over a if you do not require the synchronization offered by the latter. This class is available since Java 1.5. edit: also exists, this should be preferred for literal replacements and is available since Java 1.5. 

It may not be applicable for since it does not have fields that needs to be set upon object instantiation, but flipping the constructor-chaining lets you centralize all the fields to set in one single constructor, eliminating compiler errors that tell you about fields not being set. 

seem unused, is that expected? The palindromic check looks ok to me, but whether you want to inline it altogether is up to you :) 

These two fields can be better placed as fields, instead of inside the method. On a related note, you may also want to consider turning this into an "utility class" and have the method as too: 

Hypothetically, if you really need a marginally higher-performance method call on the basis of number of steps involved... 

Unless you are constructing s from / arrays, with an optional , you should (almost) never need to instantiate a by doing . Then, using the and methods... 

is just a simple wrapper for a that checks for the incoming length first before calling the methods on the instance. Like I said earlier, I'm not sure at the moment whether there is a more concise way of doing this or not. I also had to rely on a boolean value to ensure we have at least the first word as the output. The test for it: 

The problem here is that you will simply have a cascading chain of calling on the method call stack, which may result in if it gets too deep. You should consider doing the retrying within itself as such: 

A step further is to combine it with , I'll leave that as an exercise for the reader. Finally, a small nitpick: is spelled wrongly... it should be . edit Further review on and the actual 'program'... The other weird things about are that you are repeating your decoding across two different loops, and carefully interpreting and handling for when (which isn't 'documented'). Also, since you mentioned that you prefer a more -like solution, perhaps you can consider the following too so that you can even not depend on and : 

Typos should be . :) Braces and whitespacing Please be consistent in your braces style, even for one-liners. As such, 

Since this is done regardless of , you can perform it outside of the -block (illustrating only for ): 

You can string commands together: as shown above. will do the equivalent of your . If it's the latter, i.e. same as what you have presented here, then you can leave the first loop aside, but build up your list of files to be copied first: 

Methods You should significantly cut down on code repetition in order to standardize most of the logic in your game. The main benefit of using more methods is that any bugs can be fixed within one method, instead of having to manually copy-and-paste the fixes throughout the codebase. For example, the following code block is repeated: 

One loop, once you encounter a digit, you should sum it up already. :) This answers your third question. Adding the digit character to a , then having to parse each digit afterwards, is redundant. 

is a public method that returns only an unmodifiable view of the underlying to prevent accidental changes, which is a good practice especially in this case. Conversely, is a private method which will be used in the block below to add values at initialization. It conveniently s itself for method chaining. Finally, the method is just used to defend against accidental repetition of values. :) The block to initialize both the and the values can be done in the following manner: 

You can also consider removing the temporary variable inside , since the repeated method call is likely to be optimal enough. There's also another approach you may want to consider, which is to pre-shuffle your first (using Fisher-Yates perhaps, or one of the two available method?), and then simply take from either the head or tail of your . This would be more optimal in cases where you use an implementation that lets you perform an item removal without having to resize/shift its internal state, but then this is a minor point to consider for a simple 40-element . 

Rationale: Avoid code repetition and makes the one-time cast clearer to understand Grouping the search results into a usable Instead of traversing your for each product, consider generating an intermediary that gives you the list of grouped by the product ID: 

Instead of writing in full, you can simply write . class You can consider having a method that helps you create a new and add the number of hours worked. This eliminates the code repetition you have currently. For example: 

According to your implementation, you want to compare first, so you have to reverse the , then comparing on the name. Immutable classes and getters As hinted above, providing getter methods lets you use method references for your class, and you can make it immutable too by -ing the fields. Deprecated constructor 

@Mat's Mug has a pretty good answer, and I'll like to go one step further with a couple more questions: 

It then becomes the duty of to validate its argument, and you can also eliminate the check on the caller's side in this context. I propose tweaking it slightly further (if you have no wish or intention to accidentally reassign later): 

For the condition, you can join that with the inner : There's a bug here all right... The should only be done on the original outer condition, so if the inner conditions fail it shouldn't reach there. Slightly edited the code block so as not to invalidate the comments on this part. :) 

I think it may be better to do a check before you construct your array. Also, I am using the utility class instead of to copy part of the array. Extracting the from a MIME message You can make use of for both your and instances, and I suppose this is where we can employ a bit of Stream trickery... 

Formatting Your statement block should use braces to better identify the scope of each clause as a good practice. Also, you can consider renaming to respectively. 

Variable naming is not only a mouthful, but anyone will also start to wonder about that weird spelling choice of combining a zero with a capital together. is much easier to follow. handling Erm, consider how you want to handle potential values safely. Biggest difference Test case: In the first method, it immediately replaces the s with s, so the second substitution to is effectively a no-op. You end up with . In the second method, there's only one substitution being performed, due to how works. Not only that, it's indeterministic which substitution will happen due to how has no predictable iteration order. Interfaces over implementations declaration This is the least of your concern here given the biggest difference above, but you are highly recommended to declare as a instead of because where it's used, it does not need to be known about its actual implementation.