Putting It All Together With all of this, we end up with the following. Notice that we've reduced the size of the class by almost half and made it a lot more readable. CodeBehind 

Two items I would have a look at in terms of the actual calculations. Use Full Names in Methods For clarity, and because the few characters are inconsequential, I'd prefer to see the full names of the units being used in the method names. This will improve readability and understandability of the code. 

Only Handle Answer Checking on Next Click There's no good reason to check anything about the selected option when it's checked; we really only care when the user clicks next. This greatly simplifies the logic, as we can remove all of those methods, and implement all of the logic in the next button click method. For example: 

Factor Out Constants Several of the numbers used are constants which could be factored out, such as the difference between Kelvin and Celsius (273.15). This will prevent typos from causing calculation errors. Something like the following: 

Lines of code is at the most an indicator of less code quality. Do not ask for lines, do ask for responsibilities. Hypothetically a method/a class can have thousands lines of code and it will not produce any problem if it has only one responsibility. But I'll give you that it becomes more and more probable to violate the SRP (single responsible principle) the more code is available in the scope. And of course you may have other problems can be derived from many lines of code available. But code of lines alone will say you less to nothing. 

The best "comment" for a "procedure", "function", "method" is a set of tests that show the usage of it so other developers can see, how your code will work in different situations. Instead of testing your object in a main-scope I suggest to make ... Unit Tests Following the suggestions you can do expressive unit tests: 

To Option B Yes you can do so. But the achieve the same with the correct hashcode equals implementation on immutable datastructures with less overhead. Logical path 

Maybe you should. A little known fact is that a does not take a as an argument but a . And implements that interface. Since you are dealing with large text files, well, I have just the library for you: largetext. It implements over a large text file, which means a instance is directly usable with a : 

If you are intent on using a builder, then I'd suggest either making it an inner static class to the main class or a different class in the same package. If the first solution, then the constructor for the built class can be made ; if the second, it can be made package local. First scenario: 

One advantage is that if two instances created for are equal (ie, the same and parameters), computation for happens only once! 

First and most important: you are using Java 1.7 (as the try-with-resource statement proves), so do yourself a favor: use ! The API should have been marked as deprecated ever since this new API was here. In most situations, the class itself is all you need: 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

Then have a in which you would pair keys with implementations of . If no entry exists, of course, the method call is wrong. While this is easy, however, it is not practical. Many frameworks, including light ones, include annotation systems which will do the job automatically for you -- you should try and find one, and use it. There is also another solution -- since this is JDK 7 you are using, you'll have it: . It also requires that you implement an interface, but using this, you can load your method implementations easily. This is what I use in one of my projects, and it works quite well; the only trouble with it is you need to create a file in , but it's a trouble you only have to do once for each method you create; or if you use Maven, there is a plugin to generate it for you. 

I use this pattern a lot; I find it useful. Do you? What would be your gripes against it? Sample implementation of a simple pair: 

We can also store the entire current question in the ViewState to avoid having to store individual properties of it, such as the answer index. We can do this by adding the attribute to the QuestionModel class. Note that if we do use the ViewState, we should also encrypt it to avoid disclosing the answers and other internal information. To do this, we can add to the Page directive on the .aspx file. Also note that we'll need to find a way to provide access to the correct count to Results.aspx. For simplicity, we can use session data for this specific case: 

I've got a couple quick notes. Overall it looks like this method will work. Validating args[0] The only validation that you do on args[0] is to check if there are any images in that directory, but you don't check other possible failure conditions, such as if the directory provided doesn't exist. For a user, no images being found and the directory itself not being found would have different actions required to fix the problem. It would be helpful to perform better validation here and providing meaningful feedback, and perhaps a different return code. Duplicate Calls to Get Path There are a couple instances that call . This could be factored out to a variable. Use TimeSpan Formatting TimeSpan provides functionality for converting to a string in a particular format (see $URL$ In this case, I think you'd want the "g" format. Return Codes You return -1 in the event of no files being found, but you don't handle returning a different value if fails. If this was being called from a script, I'd expect any failure to return a failed return code. Catching Exceptions While the exceptions thrown by are likely all IO related, it would be helpful to catch at least some of the individual errors and displaying helpful information where possible. For example, if an exception was thrown because of a write permission issue, it would be helpful to let the user know that they need to correct their permissions, as opposed to hoping that the library you use provides a helpful description. There are also some instances that I bet could throw an exception that you don't handle. For example, I would expect to throw an exception in some circumstances. If some exceptions are handles and displayed in a user-friendly way, I'd expect all of them to. Commenting Some of the comments are helpful, such as the reference to documentation for a method from StackOverflow. However, there are also some trivial comments ( is pretty clearly going to get the elapsed time). But there are also instances where comments would be helpful, such as what the values you set on the MagickImage are (what does do?) 

2. Create components After you identified strong cohesional code fragments through create-methods and lazy init-methods you should extract logical UI components. The most obvious component is the JFrame. You should derive a class from it and build up the UI within this new XJframe. You already have a class named MainView that can be extended from JFrame. Maybe you can reuse it so the inner JFrame-object becomes obsolete. I recommend to at least do that: 

To make my point I have to reach back a little bit. I suggest to read this all or nothing. I currently came from a project where they used an "event bus"-like mechanism. It was used in the context of the web ui framework Wicket. Wicket itself provides an event handling. In the special case of Wicket they had to solve some problems. The Wicket internal event handling was based on defining an event and provide it to an event sink. This sink was an ui component in the wicket ui component tree and there was no need to use the root. Furthermore you have to define in which direction the event should be sent: upwards the hierarchy or downwards. So with this mechanism some parts of the hierarchy may not be reachable with only ONE event. So often there were more than two events involved to achieve the wished goal (in their case to update the ui component). In one case they had defined a cycle by making two receivers also senders passing event to each other forever. Then they came up with the idea of a central instance responsible for registering as an event sender and registering as an event receiver. This is nearly exactly the szenario you have. Honestly, this is a much better approach than the original wicket event handling. And many sites write recommendations on that and all in different contexts. But there are also some problems remaining. For example if an object registers as a sender of an event that already was registered you have to decide wether to allow it or not. Will a change of a sender or an additional sender affect the receivers? One other thing is you have to keep your events semantically unique. How do you ensure not to have two events (accidentially differently named or typed) that mean the same. Or vice versa: One event triggers receivers that accidentially listen to this event? This nearly always happens if you have abstract/generic algorithms that fire events like "Update". You have to ensure that your events remain semantically concrete. And because you can only identify an event by its type the information who sends the event cannot be evaluated usefully by the receiver even the event contains the sender. The receiver cannot distinguish between different senders of the same event. This information cannot be reconstructed. Here is the thing: An event bus should replace the observer-pattern but it doesn't. An observer-pattern decouples two objects in one direction. The receivers were nearby when they registered themselves to the sender. An event bus decouples two objects bidirectional. The receiver is now coupled to the event type. Because of that and event types should be semantically unique the receiver is implicitly coupled to the type of the sender. So the receiver is not able to distinguish between different senders of the same type anymore not as the observer-pattern. And if abstraction and inheritence is involved you can easily crash your event bus. I don't say: Do not use an event bus. But I strongly recommend to prefer the standard observer pattern. Everything else will lead to things you have to memorize additionally in every day you use this. You always have to be aware of the restrictions of such an event bus. The observer-pattern really has no disadvantages in its concept. Maybe you have ONE disadvantage within concrete programming languages: effort to write "a lot of" code. Some mainstream developers also address that you have to think about how to reach the sender within the object structure to register as a receiver. Yes, you have addtional effort to think about the composition of your objects. But that you always should do. Why are you thinking about clean architecture? By using the observer pattern you maybe have to write more code but it is not producing ANY PROBLEMS or has ANY RESTRCICTIONS you have to be aware of when apllying it correctly. In implementation deviations from this concept you may write less code but you definitly produce problems. This has something to do with irreducable complexity. No I am not a creationist. You have to think about it like a compression algorithm. An observer pattern is a lossless compression of a modelling problem. An event bus is a lossy compression of the same modelling problem (at least in OO). And because it is a lossy compression must be aware of the errors. The rethorical question is: If you bring up clean architecture as the base and the effort of design why then using a "lazy" implementation of the observer pattern? 

Delegate the computation of and to a method, say, . Since we want to spy this method's execution, we will suppose that we have Guava and its useful annotation, and make the method : 

You may want a static method in your class, named, for instance, taking a as an argument and returning an : 

Note: the way your class is currently written, it is NOT thread safe. The quick, coarse way to fix it is to make . EDIT Discussion on a different design to get the value of This requires a creation of a new factory class for instances of class ; it would have the responsibility to create new instances and compute : 

I'd just say to go with your implementation; just because it is easier to read! Also, you only from the list once, whereas the proposed solution does it twice. Shorter is not a synonym for better! However, the generics are not good; you should at least use . Not sure why the proposed solution uses as a lower bound... 

StateStopped As the state pattern has a context object (here LogService) this context object will be used as the monitor (synchronized(LogService.this)). My implementation accepts log messages put it will not notify any consumer. Calling stop() will be a NOOP. If your flavour is to throw an exception do that. Calling start() will instantiate a new thread and start it. After that the internal state is changed to be "StateRunning". 

The main problem of your solution is that your methods have temporal dependencies. Your are manipulating the "purchase" variable on in total different states of the object without checking if it is allowed. What if someone calls the method to calculate the tax twice beforw you even have a purchase? My suggestion without providing code but providing a strategy: Try to keep your object inner state consistent whatever the call order is.... OR If your structure may be inconsistent do not encapsulate behaviour on it. Let it be a simple Value object. This will be a more functional approach. 

LogSource, LogTarget These are not neccessary but they show the inherent abstraction the thread makes use of. So A LogService is of course a LogSource but it can also be a LogTarget. 

There is no need for the else at all since you don't do anything if is not odd. Also, there is no need at all for two lists. Just one is enough: 

For more complex cases, I generally create both classes in the same package and make instance variables for both package visible (this leaves of course the responsibility on me that what I inject into the frozen part is actually immutable, but I deal with it ;) EDIT Right now the methods are called and , to reflect the pattern's intents; do you think of better names? EDIT 2 Objections from @bowmore: the SRP (Single Responsibility Principle) is violated; this is true: the frozen instance has the added responsibility that it must generate a pre-filled thawed instance. The suggestion here is to create an additional constructor/static factory method/method (pick your poison) on the builder class so that it be able to "swallow" the contents of the frozen instance. 

Then you use can use . Note however that since this is an enum you can always access this via . And NEVER do that: