So approximately 1/600 of the time. Or, since I didn't do proper benchmarking, say between 2 and 3 orders of magnitude quicker. 

Your approach seems reasonable, but there are some simplifications you can make. First, your construction of is needlessly complex. This works just as well: 

I'm not clear what you are asking about combing function; you can add an additional argument which is a character vector which then the code just has a series of if/elseif's checking that parameter to see which algorithm to use, if that is what you mean. 

Finally you can eliminate some single use intermediate variables. This may not appreciably speed up the function, but it does make for cleaner code. 

Second, you can call on each element of at the outset which eliminates the need to specify an value to (and thus reducing all the calculations by one call to ). It also shortens the arguments to since duplicates have already been eliminated. 

I make a vector of all the indexes higher than , and use that most functions are vectorized. For example, with equal to 1, (and picking equal to 2) working the statements from inside out: 

This last is important; if you don't know where the code is slow, you don't know where to apply effort to speed it up. My comments are that, if you have a function that is doing some work, all the information that it needs should generally be passed in as arguments. It took me a bit to figure out what and (after I overcame the cognitive dissonance of thinking was itself an error). 

Here is another way to structure the inner loop. It builds off of @djhurio's solution but is slower. However, I think it is conceptually clearer. Also, global assignment is removed to instead return a vector of results. 

As you did not provide example data, I was not able to benchmark these alternatives (nor, for that matter, even run them). 

Your interpretation of the code is correct, but I think that it could be written more idiomatically. But before getting into that, the textual description of the output and the example output don't agree 

The comments are good; I copy them here so this question has a "proper" answer, and add some my own: 

If a streak must have at least one , how can you have a streak of 0? The example here (and the following example) are consistent with a definiton of streak of "the number of consecutive 's preceding each ." I'll continue with this interpretation so that it matches the existing code. Now to improvements to the code. The initialization of can be simplified because is the default numeric value, so the first line can be re-written as 

You can avoid appending to vectors (which can cause re-allocation of space and can considerably slow things down in principle; though in your case of only a length 10 vector that shouldn't be noticeable) if you allocate them to the needed size initially and then assign within them. 

If you really want to eliminate more duplicate calculations, you can assign outside both loops and outside the outer loop. 

The first two lines together create a 0/1 vector corresponding to whether the value in was (1) or (0) (and uses the fact that it must be one or the other of those values). This can be done as one statement, using the fact that and become and when converted to numbers. 

Then determine what the algorithm is that you are trying to do: Looping over each element of the first column of z, skipping any missing values, compare that value to every other value to the end of column. If the current value and some subsequent value differ by more than some threshold (in absolute difference), set that subsequent value to NA. R is a vectorized language, so explicit loops are often not the most efficient way to perform an operation. Let's vectorize that inner while loop. 

Second, you replace with , and then test against . That means you are replacing both 's and any 's in the data. If you only want to replace 's, just replace those without recoding them. 

That is, generate all the answers and guesses, check for each one (vectorized) which (staying or switching) would be a win, and then accumulate those results. The rest is just to put the data in the same format that your function already had. 

In your code, is not defined. Presumably it is some threshold value, since it is used in a comparison of absolute differences. First, reformat your code so that I can better determine what it is supposed to do: 

Further elimination of duplicate work would involve recognizing that higher order interactions, as you are determining them now, are repeating the intersections of the lower orders (that is first intersects and and then intersects that with , but the intersection of and was already determined). And "first" order interactions are just the arguments passed through (as they were simplified in the previous iteration). 

The last simplification uses the fact that a function returns the last evaluated expression by default. I don't necessarily recommend doing that because with compactness comes a loss in being able to see what the computations are/mean. (To understand it, you must essentially reverse the steps and break out each transformation separately to see what it does and to figure out why.) Looking at it again, the conversion to numeric is not a necessary step to determine ; you can operate from directly: 

I am assuming that the call to is not what is taking most of the time, so I'm not including that in my analysis. One thing that is slowing down your code is that you are assigning to every iteration of the loop (well, every iteration that is 0). That could be pulled out of the loop since it only needs to be done once. 

Another technique that we can use to make code more readable and easier to write (once you get used to it) is by using classes. Consider this partial example of what your code could look like 

} Now I'm sure someone who know a lot more about or could give some basic examples of how to implement those, but lets look at how it could be instantiated. 

thanks for sharing your code! I want to start by saying that I think this looks pretty good for someone only having been coding for around a month, but I think you're getting some concepts mixed up or not quite sure how/where/why to use them. The other comments and answers have already pointed out flaws with the class, so I won't repeat those 

There are already some good answers here, but I want to provide another method for reducing some of the duplication in your code, specifically the fact that you have 1 method per player turn. and . As Austin pointed out, these can be turned into just one method and you pass in the player who's turn it is. But you can also remove some of your statements to make it even simpler. your current board is 3 separate rows, , and . If we make this a dict, we can cut out some duplication. 

I would like to point out some things that I would watch out for, these may not be directly related to your question, but hopefully they are useful to you. Alot of your comments are completely redundant and actually add clutter to your code. some particularly bad examples are the comment for the variable . Your comments should say why you're doing something not what you're doing. The code itself should say what you're doing. Avoid returning references to the underlying mutable objects directly, in this case, your . Instead you should return a defensive copy. 

It's a good sign that this jumped out as not being the best idea! There are a few problems with your design here, let's have a look. Your class contains these instance variables 

Now here, we're still using the same number of lines (1), but this gives more meaning to the code. Code can now look like this 

This is looking very good for just one week of learning Python, good job! Comments When writing comments, you should aim to document why you're doing something, not what you're doing. Through using clear and meaningful variable and function/method names, it should be obvious what you're doing. The ideal situation is that you don't need any comments at all because your code is self documenting. This isn't always the case however. for example this line 

Hi thanks for sharing your code, You should stick to Python naming conventions, check out the PEP8 style guide. $URL$ Based off of this, your rod class should be and should be For your global variables, you could fix this by having a or class. 

At the moment this code will mutate the existing array, so you may want to create a copy instead. Hopefully you found some of this useful! 

This way you don't need to worry about either, not that that would really be a problem here anyway. This while loop could be a lot simpler. Try breaking it down into multiple well named boolean values instead. 

where is a function that starts the execution of your program. A pattern you use in your code is relying on a string value ("yes" or "no") to determine which function executes. This is standard enough and nothing really wrong with it, but I would recommend instead of checking for this string literals, to use boolean values instead which are taken from shorter helper functions. A quick example. You offer the ability to save and load game state, this is a good thing. However, you save the state in a Human readable fashion - i.e. "Bob's Balance: 24". Unless you're relying on this format somewhere else or even just displaying it, you could just save a single number in a file. No need to record a name. The main code does a lot, you could break this up into helper functions. Some possible function names that jump out are. , , , A pattern you use in your code is relying on a string value ("yes" or "no") to determine which function executes. This is standard enough and nothing really wrong with it, but I would recommend instead of checking for this string literals, to use boolean values instead which are taken from shorter helper functions. A quick example. Your current code for prompting for saving the game 

so we don't need to do any if-else checks here. Now I haven't added in any checks to make sure the user enters a valid value. This is a problem that was pointed out in the other answers. I would like to also add that I don't think recursion is necessary and only adds complexity that we don't need. A simple loop to keep prompting the user to enter a valid turn would be better I think. I don't like and 0 and 1 are magic numbers here and should be avoided. this would be a lot more readable if we have a meaningful names instead. 

So there's something to do with some sort of iterator, but doesn't tell me a whole lot about it. It's also just giving back Strings. So far everything is dealing with Strings, it becomes hard to keep track of. Instead, to make it more readable and easier to follow, I'd like to see something like this. 

Then in the method, the Items from the can be added to the . Similarly to the Chest method, this method 

An important distinction between these two methods, is that the .sort method is a list method that sorts the list in place while sorted returns a new list and leaves the original unaltered. Hopefully this review was useful!