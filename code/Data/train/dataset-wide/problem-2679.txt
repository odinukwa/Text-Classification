may return a larger (for decoding) or smaller (for encoding) than the amount that was base64 encoded because of the padding; it's arguably better to create two methods rather than to determine the length, one for encoding and one for decoding, similarly for - there is hardly any code reuse anyway. : the looks like a bad way to fix the code and it is not specified why it is used (OK, after reading the code you'll find that it is because of the null-terminator, but still). making the number of iterations and including it into the result would be a good idea; another would be to include a protocol version instead (do please create a protocol description, even if just in MarkDown or similar) - note that 32Ki iterations is already on the low side. you could directly encrypt to , having an additional buffer / copy seems wasteful (see also the next point). instead of you should simply use pointer arithmetic to set the location of the salt, nonce and ciphertext. you do not need a nonce if your key always changes: and the salt will make sure of that. Just use an all zero nonce (but document why it isn't required in case somebody "fixes" your code and uses a static salt or similar). after use you may want to zero out the password and key so they won't remain in memory. 

First of all: your coding style seems good to me. I presume that you didn't include all comments as more comments are of course necessary. But the code itself looks OK to me; it is easy to read. Design issues: 

Good, you made it this far. If you're anything like me you should be almost translucently red with anger by now. Please understand that I was in the same place as you are now - probably worse, as I didn't know much about NaCl or authenticated ciphertext. Unfortunately I don't think your code has any value. You should see it as a good learning experience and a reminder not to write wrapper classes. And you should not do this even if you're going to be an absolute expert in crypto. Otherwise you are going to spend a significant amount of time in the future trying to remove your wrapper class from the code base. Been there, done that. 

The salt size is 32 bytes, which is fine if you can spare that amount of bytes. However, a size of 16 bytes is more than plenty for PBKDF2. The salt is only required to avoid collisions, and I presume you're not going to reuse the password more than 2^64 times. If you generate a random key then you don't need a random IV, not even for CBC mode. Not all ciphers are created equal; you might as well standardize on one, e.g. AES-GCM which adds authentication (AES-CTR is unfortunately not available by default). However, that uses an IV of 12 bytes and adds a tag. CBC is vulnerable to plaintext / padding oracle attacks, so don't use this for transport mode security. is incorrect, it should be called . You should define your protocol and add a protocol version, so you can change your protocol later on. For instance, you may want to re-encrypt using a different hash or iteration count in the future. This can be represented using the protocol version. You may want to validate that the derived key is correct before decryption. Note that CBC doesn't add integrity protection. This also means that the decryption may not fail even if you supply the wrong key (resulting in garbage plaintext). You extract 256 bits from PBKDF2 which defaults to SHA-1 with an output size of 160 bits. That means that the entire function is repeated for the last 256 - 160 = 96 bits. This will double the amount of work on your server. Better specify SHA-256 or SHA-512 as hash. Why not use instead of ? Then you can use hardware acceleration in native code when available. Also see this question. Note that I haven't tried the speed of either of the mentioned classes, but you may want to give it a try for large files. 

In general you should try and avoid floating point operations for any cryptographically specific code. Floating points have issues with regards to precision, and even I don't see any issue for this specific code, they always require special attention, e.g. during reviewing of the code. Similarly, using recursive code is strongly discouraged for cryptographic algorithms. If your code can be coded using loops and only local variables you should really do so. I imagine that goes against the idea of Rust (and is thus up for debate), but crypto code generally requires special attention. If you keep to recursive calls make sure you document them as such, both inline and in the function description. Although you nicely implemented the destructor it makes more sense to create either a class with just a (now called I presume) or simply keep all the data in parameters / local variables. The idea of just keeping the is that you may reuse the object to derive other keys using the function but with different salt / info. In that case you obviously need to retrain the to clear the input key material. Note that the internal key handling (padding, initial hashing) of HMAC is always the same. So a sneaky speed up is to perform pre-calculation on the salt which acts as the HMAC key (mainly useful if there is a lot of output expected, this speedup matters more for e.g. PBKDF2). 

The idea that you need to pad keys supplied by the users is very dangerous. It lets users believe that their key is secure, while it should be either 16, 24 or 32 bytes for AES. There is a reason why PHP / mcrypt is being deprecated, and this is one big reason why this is the case. 

Otherwise the crypto seems fine and the constants make sense. I don't see too much other things wrong with it. 

You are allowing direct access to the elements rather than just the content. This allows the user to create any kind of structure, including lists that keep going round. Instead of going through the elements by exposing them, I think you should create an iterator that allows you to go through the elements and then retrieve the contents. If you remove the first element with a specific content then you should probably call that function . Note that you are combining two things here: searching for an element and removing that element. Although a linked list is generally not fast when it comes to indexing elements, you could still implement indexing. Keeping the size is definitely a good idea. This is obviously a bit of problem if you allow direct access to the elements. Functions like are dangerous as you don't know the size of the list or its elements (besides that, how do you know that T enables this function, am I missing something?). If you allow direct access to the elements then you may be able to delete the element while an outside user still holds onto a reference to it. 

A different idea of handling this (for you to ponder over). Define your protocol somewhere and store a protocol version in your hash string. You could even use that to replace the salt size, iterations, hash type etc.. Then if you choose a higher iteration count you could just update your protocol version. 

The header doesn't seem to be authenticated or encrypted, leaking info and allowing alteration. should be using a password hash such as PBKDF2, scrypt or a secure variant of Argon2. It doesn't make too much sense to pass a specific and ; better just use a protocol version and use a specific cipher / parameters. parameter should just be . There doesn't seem to be any integrity protection (although using GCM as cipher may be possible). Each block should use a different IV, so using a statically set IV will break the confidentiality of your plaintext message (i.e. the stored files). The cipher class should always be local to a method; you don't want to share the cipher state over different public methods. 

The class has too many fields; either split it up into multiple classes or you should keep your variables local. Decide how much state your class really requires and keep the number of fields to a minimum. The class has too many imports, which means you should split up your class, e.g. using implementation classes for specific functionality. The header part could be factored out into a class. Cancelation is allowed for the header and before writing the blocks, but the operation that takes most of the time / resources apparently cannot be cancelled. Calling the add method with as parameter requires you to check all the properties within the method; it should be given e.g. an interface with getters instead. It seems that too many parameters simply contain of strictly formatted strings, do not use code: convert to a parameter class or simply use multiple parameters. If you use a string parameter with structured content, then at least create a method to validate it rather than validating it inline. The method doesn't actually add anything; it just creates a block it seems. The only side effect is that to , and that's one that should not be altered. Your class doesn't seem re-entrant. Having a single object be able to be used by multiple threads seems a good idea. Exposing the internals through getters is a very bad idea; implementation specific details should be hidden. Methods such as are specific to class and should therefore not be in a class (do not create circular dependencies!). Similarly, contains code that is package specific and should therefore probably be in another class / location. Don't overuse a class like ; just use private (static) methods instead if it is specific to a class. 

This lets you easily create a parser that returns an implementation of the interface. But if you just need to test your code you can simply create a direct implementation of the interface, if required using an internal or anonymous class. 

Disclaimer: I'm focusing here on the things that can be improved. There are certainly good things about your code, e.g. the naming of identifiers is generally good. Design: 

As for handling large amounts of data: implement streaming using calls to update. I presume that this is for relatively small strings, but you may want to document that. 

You're creating a CBC wrapper, but your wrapper uses HMAC for authentication. This is great, but you would not expect HMAC for a CBC class. Even worse, you're making the mode of operation part of the interface. This is the wrong way around: a mode of operation uses a block cipher to be implemented. And a block cipher certainly doesn't include HMAC. Furthermore, you're also adding HMAC for CTR mode, which has many uses for specialized encryption constructs, which would not be available for your class. I don't think you should do this, but if you do you should do this by creating a separate class that performs the calculation of the authentication tag. Inexplicably, you're not adding HMAC for the old CFB mode that nobody uses anymore. That means that your code is not symmetric. Fortunately you do use encrypt-then-MAC. So your complete design is off, to the point that it should not be used. 

The order of your calls is a bit weird, you can create salt and key outside the code block. is a magic string - it is probably better. Your encrypt and decrypt functions aren't symmetric, even though they seem to be. They should be byte array to file, then file to byte array. 

Running your class through a static code analyzer or two (CheckStyle & FindBugs, to name just two) seems to be a great idea, just like using a code beautifier.