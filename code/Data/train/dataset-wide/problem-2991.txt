I see that there already is an accepted answer, before I got around to writing this answer. That is a little discouraging for me as a reviewer, but I've written a code alternative and have some thoughts regarding your code. Code review 

I'm sorry that the environment I tested this in doesn't support doctests, but this does output the correct list of . 

This allowed me to have a slightly simpler structure to work with, and I can display the matrix whenever I feel like it. On a square image of 3x3 I got the following output: 

And then there is that really long text at the beginning. Having that long text is not a good option, and given the right output settings you'll have a bit of a problem reading that. A little based on my own attempts, and some based upon reading "Proper indentation for Python multiline strings", here are some alternatives which tries to print a text with multiple lines (and at the same time making it look nice in code). Two exceptions to expected output: 1) The first multiline which has erroneous indentation (it's correct but not the intended output), and 2) where the doesn't seem to do it's job: 

Example of class The following example is a simplistic implementation of part of the class. class MakeKing(Creation): """Wrapper class for the makeking command, starlab v 4.4.1. 

Instead of doing this all in code behind, a different alternative is to use MVC (Model, View and Controller pattern), and let the table be generated by providing a partial view, and then propagate the directly to the partial view. But it could be that using MVC is not available to (or not wanted by) you. Related to the click event, I'm assuming that all of the buttons are executing the same action, and as such you could use one general save method, which picks up the id from the row where you clicked the button. See following html code example: 

No need to use list comprehensions and boolean double-checking in , just write it as a filter on the range. 

I wouldn't say there's anything like a proscription against doing so, but as a non-user of I can't say it helps me understand what's going on. I'm also not sure that your data structure is complex enough to warrant using in this case, functions out of tend to produce a pretty concise solution on their own when properly deployed. I haven't tested this, but I think it's equivalent. 

This isn't a valid reason not to use type signatures. If you want to save yourself some keystrokes on type signatures when you change a representation, then you should be using a type alias instead. 

Update Having slept on it and cleared my head, I think your code would be much improved by leveraging ADTs and a serialization typeclass. As it stands your solution feels very C-like, and your data types are used like structs, arrays and low-level machine ints instead of rich data. I'll sketch an outline of what I would do here, please feel welcome to interrogate me in the comments if the full picture doesn't come through for you. 

I'd also be sure to strap a comment to the top with the pseudo-code or algorithm you're trying to implement. It aids understanding and error recognition far easier. 

We can use this property ourselves in an interactive session, but that gets tedious fast. Instead, call with the property and it will generate arbitrary data to test it with. 

Now more general advice, you should include a type signature for all of your top-level definitions. This is important for a few reasons. One, it acts as a check on your understanding of what your functions are doing, the compiler will complain if your signature doesn't match what your function really does. Two, it serves as a surprisingly powerful form of documentation for readers of your code. And three, it can help the compiler infer more of the types you use within functions without needing annotations. As an example of that last point, look at how you had to annotate the line with . If you had given the compiler enough information to go on elsewhere in your program, it would have been able to deduce that on its own. Here's how. 

I'm in doubt if your code actually works as you instantiate using , but your class is named . This kind of indicates that either you've left out code, or you have broken code. Anyway, here are some pointers for you: 

Notice how the two first files would have gotten a wrongly rename use your original code. Code refactor (added) To accomodate for your question regarding building this into a larger script, and to give example of error handling, I've refactor your code into the following (using the tip from Janne Karila on using ): 

You are specifically asking about how to reduce the number of return statements, where one answer suggest a total rewrite, which most likely is a good option. However to tackle the general question of reducing the number of the return statements here are some ideas to play with: 

If modifiying to include the opacity suggested by Gabor, one can use the concept of a base color, and with some slight justification to the base rotation, and implementation of the down-and-up scheme, one gets the following snippet: 

Using a table here is the right choice, however I would put the total into a group where you can address its formatting needs specifically. In addition do use to collapse columns in the total, as well. 

Best practice in Python, seems to use the timeit module for timing executions. This module can setup your runs, and execute them multiple times and eliminate some of these caveats. Although you really gotta keep your head straight even when using this module, as timing execution depends on a lot of sub parameters like: operating system, python interpreter, other load on testing platform, memory issues, code issues, sub effects of memoisations or other programming paradigm, and list goes on. 

I then proceeded to changed your algorithm using the helper method (and added some space to align swap coordinates), this gave this code: 

This way the code is concise and precise. The error handling is close to the actual input, and the "business logic" is tightly coupled in the switch, before a final presentation statement at the end. 

Appendix † An inefficient but important implementation. Note that performance is O(n²) (consider e.g., ). 

Your normalization function is more complex than it needs to be, but consider what having to normalize says about the representation you picked. Here's one version that doesn't change anything about your data types. 

From the Typeclass Down This all depends on which tools you're most familiar with. If you're a fan and used to relying on newtypes you may recognize the pattern of condensing a list of values as . Then you just need to write or choose an appropriate instance, and of course if you're really on top of the ball you'll know that one already exists. 

You have some unnecessary pattern match cases, such as in the instance declaration. There's nothing wrong operationally with that case of course, but it's superfluous and the beauty of the inductive construction of the integers encourages me at least to be ruthless with flensing redundant code. 

On this line I would change to . That's the only value will ever be, so it's better to be explicit than to be clever. You have far too many comments that have little to no value. For instance, you can assume that unless you're writing an "Intro to Haskell" book your readers will know what pattern guards are and so you don't need to explain what they are or why you used them. And finally in my version below I've cleaned up the alignment with liberal use of whitespace. This is mostly an aesthetic effect but I find beautiful code easier to read than otherwise, and this is not an uncommon style in Haskell code. 

It also shows that might not be the correct name, because the function doesn't actually return a but instead the application of the set of system rules (or the identity production if the is a terminal). I think makes sense here. The remaining set of changes I have are all function implementation related. You can leverage functions to achieve a lot in Haskell, doing so often makes your code more readable as common patterns get expressed by familiar names. For instance, looks a lot like finding an element in an association list, which in the is provided by . Digging a little further into we can also deal with that using . 

You don't present the entire code for the class here, but the usage of and the doctests within the docstring indicates that you are actually using a class. As such my first order would be that in the initialisation of the class you always create the list, which would remove the need to check whether there are elements or not when adding elements. To use to terminate the loop is a hackish solution. It would be better to use instead. But and (and actually ) allows for the usage of which can help out in this particular case. In short, if the loop terminates ordinarily, the part is executed, if you out of it, it'll not be executed. In stead of doing the loop, which requires calculating the length multiple times, and doesn't look to Pythonic, I would suggest using . This loop construct loops over all the elements (if any) and gives the index of the current element (due to the use of ). Lastly, naming the method when you only add one element is misleading and not following standards. A better name would be . This leads to the following code: 

To center text you'll use , but note that this centers the text within whatever block it is set into. That is, if the block isn't wider than the text, you'll see no effect. Centering vertically is troublesome, a random article is Vertical Centering in CSS. Newer browsers support , which I've used in code below. See A guide to Flexbox. (and 4.) To allow the navigation menu to both flow, and be aligned with the top line, I used . I shifted it over to the right, as this kind of floating menu, especially when the text is supposed to expand into the margins, are more commonly done on the righthand side. 

Style review of current code Reading up on PEP8 is never a bad thing. Mostly your code is clean, but there are several enhancements which can be made.