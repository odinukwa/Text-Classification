So those are just examples. It's not a hard and fast rule that you can't have a class called something like that doesn't have a useful, sensible function in wrapping a collection, but it's a good starting point. So in this case, let's go through what the does and see if it adds value: 

Naming Some of your names don't mean much. What's "" or ""? These should be replaced with clear, descriptive names. Similarly, don't abbreviate names. There's no reason to write instead of . 

It's potentially annoying to have an extension method like that turn up on almost every type. With just a single one, it's probably a minor irritation at most, but in the future you may find yourself coming up with more or extension methods, and either you'll start to get a very clogged up Intellisense. So think about whether this is really something that you want frequently enough to justify it. If you're working on code that may be maintained by colleagues, check their opinions. Note also that actually has fewer characters than . Which is more readable and clear in stating what it is doing is arguable, but at least the array is instantly universally recognisable. So while it would be harsh to say that it's "bad practice", on balance I would probably advise slightly against it. If the benefits seem to outweigh the costs to you, though, then go for it. As a side-note, you don't need your condition, either. It's the array that you're creating a new instance of, not the itself. 

Do you need at all? already has useful methods for working with paramterized times. The disadvantage that using a raw has is that you have no compile-time guarantee that you won't get an invalid (e.g. one with a component above 0). However, you can get the best of both worlds by having your class wrap a : 

Is any of this necessary? You don't need to say it's a string, it's right there in the signature. And everyone knows what a string is so linking to it is useless. The name 'getMessage' already says that you're getting a message, so writing that again in the comment is pointless. I suppose you've added the information that this is the message "to be displayed", but that's rather vague, coming to this code for the first time it wouldn't tell me anything unless I then went and read the rest of the class. If you really think it's important to communicate the information that the message is being displayed, you could rename the variable and the corresponding method instead. And finally, the overall summary and the part again say exactly the same thing. This is a trap I fell into a lot myself. You think "Well, I have to write something for the Javadoc." But you really don't! If you have nothing to say there, say nothing. Use of static This is where we get into "difficult to review because it's such a simple application" territory. Because you're basically done now, you're not going to extend this or use it in a larger application or anything, there's nothing really wrong with using a static message as you have. So I'll try to talk about why, in a more general situation, it might not be a good idea. Essentially I don't really know why you'd make the message static and everything else instance. Why not get rid of your static message field altogether and just have: 

Introduction First of all: well done you for writing your own framework! (Just don't forget to throw it away once you feel you've learned enough). Configuration is, architecturally speaking, much more solid than relying on convention, so you score points there to! Some minor issues 

Answers to your questions 1. I find it hard to judge either "Sane" or "Decent". I think "Clean" is more important: single responsibility, clear separation of concerns, no side-effects, etc. Reading Clean Code by Robert C. Martin can be invaluable there. 2. If the set method actually set anything this would be less clean as it causes side-effects. Since it is really only another getter, there's no real problem. 3. Yes. This can become problematic. The best thing for it is simply to learn how to write unit tests (it honestly isn't all that difficult) and having tests with your code will teach you how to create code that is easy to test. 4. Yes, the array in setConfigData() is set again every time data is requested by . This is because it is being used from local scope and not from the class scope since it does not have a in front of the variable name. You don't need to make the array an object to resolve this, just load it from class scope using . 5. OK or not is mostly a point of view. Most folks will probably think it is fine. In my personal taste the conditions could be cleaner/less muddled. 6. Yes, MAJOR issues. Configuration should live outside of the class. It can be injected into an object at the point where it is being instantiated. You really don't want for me to edit the framework code when I want an application I build on top of it to alter its behaviour! 7. Personally I would not put all of that functionality into one method. I'd create separate methods for separate scenarios to keep the class signature (or interface) simple and easy to understand. In closing If you feel inclined to look at this from other angles, you should probably also take a look at other data structures that can/could be used for configuration other than an array. For instance, the ARC config component uses a tree structure. If any of my comments seem unclear or need more elaboration, don't hesitate to ask. I will update my answer as needed. Furthermore, as you stated that building a framework was mostly about the educational values, I think you will agree that something as essential as configuration has a lot of lessons in it. You seem to be learning them quite well. Keep it up! 

Something as simple as for your method might be more appropriate. Going by LINQ conventions, is also a more idiomatic name than . 

Structural At the moment, a lot of the details you would in the future want to abstract away (for your idea of multiple item types and goals) are sprayed all over your code. For example, look at how many places you have variables with names like . While this could be avoided with data structures like arrays, you'd fast get into a situation of further complicating already quite complicated code. This is likely to lead to brittle code, where if you find yourself asking a question like "What if I want to also include upgrading to a lower level then selling in the profitability calculations?" you'll have difficulty getting an answer. For this reason, I'd suggest a more object-oriented approach. Start by thinking about how to structure your data and functionality, and then go from there. I'd suggest that your basic class at this point is . I'm calling it that to separate it from the more general concept of just an Item, where you might think of the current level as just one particular field. Most of the important information about an item is specific per level, so it would have fields for: 

OrderBy over sort You can save yourself a lot of code here by using LINQ's and . These allow you to use a lambda to pull out a part of the object to order by, and the default for the type returned by the lambda is used. So for example: 

Repeat this for the rest of them and you'll probably find you'll have some repeated behaviour which you can pull out into one or more base classes. There's definitely additional rejigging that can be done after that. For example, consider should the fields you currently have on your class be on the same interface, or elsewhere? But this would be a very good start, which would allow you to massively cut down on the logic in that method. 

I have a relatively simple problem: I have an , which takes considerable time to yield each term. This is then used by another piece of code, which takes considerable (but not identical) time to process each term. As I understand it, this is a classic producer-consumer scenario, so I'm choosing to use a so that I can produce and consume concurrently. To support this, I have a simple wrapper: 

The timer/half-open logic would go inside , and hopefully the rest is clear just from the code. I'm not suggesting this is exactly how you'd write it, just giving an outline. This would be a very simple implementation, it would only require this one public method, the enum and the two private methods. So, quickly running through programming principles, is there any where this falls down compared to the larger implementation? Going with SOLID, it conforms to the Single Responsibility Principle. Liskov Substitution, Interface Segregation and Dependency Inversion are irrelevant. But there is one problem point: the Open/Closed principle. Clearly, most changes would require going in and modifying existing code, probably really getting our hands dirty mucking around with that logic. But now that we've identified that, there's two follow-up questions: