Here you can find a test script for the different pattern sets, (you can also pass a callable to the constructor instead of an associative array of pattern/replacements) and useful functions: $URL$ About ReDoS attacks: Except if you finally choose a pathological pattern and doesn't limit the size of posted data, I don't think it's possible to crash your script with your patterns set. It isn't so expensive to run, no more than any other script that filters and validates form data. Other thing, when a pattern is badly written it reaches quickly the backtracking limit, the script doesn't crash and a warning is emitted. You can even retrieve the error using . If you want to increase the security against DoS, start at the server level, with the apache settings. 

The second approach is totally different and uses a regex approach. If it uses more memory (~3X) and is a little slower when you try it only one time with a little string (less than 10 characters), it becomes faster when you use it several times (whatever the size of the string) and is more efficient than the other way with long strings whatever the number of attempts. In other words, you need to pay the cost of the regex engine, but only one time. 

About special characters: , and are not special characters and don't need to be escaped. Note that is read as a literal character too, but only if it isn't the start of a quantifier , , . Except for these special situations, you don't need to escape it when you write a pattern by hand, but here it's easier to escape it systematically instead of testing if it is or not the start of a quantifier. (if the escape is useless, it will be ignored) Since you will use the RegExp constructor with a string as first parameter (Since ECMAScript 6, this parameter can also be in literal notation), you no longer need to escape the delimiter that is only used in the literal notation. You can remove it too: 

(Note that when you pass a string to the RegExp constructor, you need to escape the backslashes, since to figure a literal backslash in a string you need to escape it.) ( is a method, not a method: ) 

it states the purpose of the condition more clearly "is the queen's position outside of the board" what if, for some reason, queen position is advanced two places beyond the board's Size? 

Here are my comments in order of severity: 1) Bugs 1.1) resource handling in you handled IO resources correctly with try-with-resources. You forgot to do it in . 1.2) parsing You split the line according to single comma. There are two problems with that: First, you do not accept cell values containing comma. Imagine the following line 

naming convention for Java variables is camel-case, meaning they should start with lowercase letter (I am referring to the argument) 

Basically, its good. Here are my (small) comments 1) in you can replace the loop with 2) I would make an enum. This has two benefits: 

define the test data define all possible validators and initialize all of them upfront. validate the input by applying validators it knows when a validator should be applied somewhere inside the validation code block, the method decides that it is now time to do the calculation the method is also responsible for producing all the output (from validation as well as from calculation) 

I am not sure how many lines of code can be reduced but one thing is for sure: whenever you encounter a resource that can be closed, you should use Java try-with-resources feature (since java 7). Not only this feature saves you the operation (one line less!) but also ensures that the resource is properly closed by the end of the try block no matter if it ended successfully or not (the compiler adds a clause). in the current code, if an exception is thrown, the resource is not closed properly. I looked at the thrift javadoc and indeed from version 0.10.0, is auto-closeable. So the code on both methods should be 

If we go along with your solution: the whole class tree seems redundat to me. It is just a wrappper over throwing a user defined . It doesn't provide extra capabilities beyond translate an enum into an (considering that exceptions can also have String message). So I believe a design where throws an provides the same functionality. If you don't want to throw the super class, you can create a super class and have all your custom exceptions extend it (much like Java's ) Your design determines that for a given type, there can only be one . This may be fine for user-defined types like but it may be too restrictive for JDK types like . I imagine that you want to validate that is a valid date, and perhaps validate against predefined list of airports (perhaps an SQL query) and so on. You should assocaite a with a String name (perhaps an enum). lastly, regartding the validation of the attributes, I believe you can write it like this: 

Note also that the escape sequence isn't a character nor a character class but an alias for or (depending on the mode). In other word is an hidden alternation. I build a set of patterns/replacements that fits your requirements to illustrate these techniques: 

Whatever the result, it's better to begin with that before trying anything else, particularly to avoid spending time with a set of complicated patterns that, in fine, might be slower. This is essential for future comparisons and provides quickly a working solution. A mix with classic functions is also possible: 

Your code works well for all the cases. After many tries and tests, I obtain two different ways to write the function. The first comes from your approach with several changes. I have, in particular, removed the test for foreign characters from the main loop: 

The main problem of your code is that you performs two replacements for each strings. Indeed when you pass arrays as pattern and replacement parameters to , the whole string is parsed once per item. These two replacements are not needed. You can avoid them if you replace all groups of characters that are not letters or digits with an underscore: 

First step, start with a simple solution: divide all in simple tasks, keep the patterns short and easily understandable. 

First, is the literal notation of a RegExp object and not a string, is a string and nothing more. If you want to concatenate several strings to build your pattern and then to obtain a RegExp object, you need to use the constructor: 

About the readability, no need to make things more complicated than they are, a simple comment before the line should suffice. Since escaping special regex characters is a basic task, and if you project to use it several times, you can build a function: 

About pattern performances: Remove all that is useless, don't capture when you don't need to capture, try to limit the number of groups, branches in alternations. Be careful with subpatterns references : even if the pattern looks shorter, it has a cost (the creation of a capture group, the call to the subpattern). Also, rewriting the subpattern is better than adding a quantifier to it: (one call per repetition). One of the main cost in a pattern are the alternations in particular when they are at start the pattern. The reason is easy to understand: in the worst case, each branch is tested for a position in the string that doesn't match. Obviously the best cure is to avoid them, but unfortunately it isn't always possible. You can also try to reduce the number of branches. However, several tricks exist to reduce this cost: 

I'm a mechanical engineer/amateur programmer trying to learn modern C++. I'm working on a personal project where I'm building a library that uses PortAudio to abstract some basic audio processing, specifically pitch and volume extraction from microphone input as a way to facilitate that learning. I'm as interested in the overall design of a library structure (with the goals of being maintainable, extensible, and easy to use and understand) as I am with the specifics of what the code is doing. The overall idea of the library (PitchHound) is that the client code will: 

Create a configuration object that specifies various sampling parameters, and contains a smart pointer to a subclass of a processing object that will implement one of many different algorithms for extracting pitch from a sound wave (FFT, autocorrelation, cepstral, etc...) Instantiate a PitchHound object passing the configuration object to the constructor. The PitchHound object spawns a background thread that reads from a PortAudio stream, uses the processing object to extract the dominant pitch(es), and then store them in a std::vector protected by a mutex. The client code will have to periodically call an update() method on the PitchHound object that allows it to check if there is data ready from the background thread. If there is, the PitchHound object will call a callback function, or series of callback functions, that effectively pass data back to client code. 

Here are some of my main questions: Using callbacks instead of directly passing back the data The intended use of the library is for games and game-like research tools that extract pitch and volume information from microphones. One of the things I'd like to be able to do is to allow the client code to configure the PitchHound object to behave in different ways. For example, maybe the client code simply wants an event to be triggered when a particular pitch is detected, or when the overall volume of a frame is above a certain threshold. Or maybe the client wants two or more of these things. It seemed easier and cleaner to allow the main object to pass the thread of execution back to one or several different points in client code from a single update() method than to force the client to call and check the results of several different methods. Does that make sense? Are there any serious disadvantages to that decision? Configuration object and PitchHound constructor The configuration object has a smart pointer to a processing object for the PitchHound object to use to extract the pitch. In the constructor of the PitchHound object, the configuration object specified by the pointer gets copied into an internal field of the class for the background thread to access. I have a couple of questions about this. Does it make sense? Should I be passing and storing the object, or should I be passing and storing a pointer to the config object? I assume that as its written the PitchHound object is making a copy of the config object, because using a unique_ptr instead of a shared_ptr fails to compile. Is there a best practice for a situation like this? PitchHound destructor closes thread The destructor for the PitchHound object is where I attempt to shut down and join the background thread. Is that a good idea? Should it be done in a different place, or a different way? Additionally, the rule of three (or five) suggests that in overriding the constructor and destructor I should be writing assignment operators. Is that applicable here because of the thread? What would an assignment operator need to look like for this object? Use of processing abstract class and implementation specific subclasses Using the abstract class thing with different subclasses for different pitch detection algorithms is similar to what I would do in C# with an interface. Does this make sense in C++? Is this overkill, would I be better off using a function pointer or some sort of enum and conditional branching? Assuming that I wanted to make it easy to add new methods of pitch detection, and potentially even have the client be able to write their own pitch detection algorithm external to the library, is this a good way to do it? Ok, that's all I can think of for now. Any and all criticism and coaching is extremely welcome and appreciated. Thanks in advance. Header file: 

I know the compiler accepts this definition, but it makes no sense. What type do you want for the items in the list? If you want it to accept any type use the wildcard (not ) Also, instance variable has no generic type. 2.2) unsued imports you have unsued imports. clean code helps maintainability. 3) Design 3.1) I have several comments regarding the class: 

Here are my comments in order of severity 1) Bugs 1.1) Split into words in you split the line by a single space character. That has two problems: first, it will split two consecutive spaces, adding an "empty" String to the output array (try it), and second, it ignores all other words delimiters (like tab and new line characters). luckily for you, regex has a predefined character classes that defines all white space characters. this regex will split theline by one or more white space characters. It will correctly split into two words (you can try this on single space regex and see the difference). However, it will not split or so you may need to further enhance the regex pattern (depending on specifications) 1.2) resource leak You get a plus for using try-with-resources when reading from files. However, why did you not use the same construct when reading from the console? you should know that opening multiple readers from the console costs OS resources. While we are discussing , you should be aware that Java 7 gives you a method that allows you to read whole files in one line of code: 2) Performance 2.1) Greedy load of files You first read all the files into memory. That may pose a problem in memory consumption if you are given many files and/or big ones. The processing doesn't require loading all files upfront. A better design would be to read the input line-by-line and do the counting on this line. This way there is only one line in memory at any given time. 3) Design 3.1) Modularity You should follow the design rule of "Code to the Interface". Almost all of your methods break this rule. Instead of specifying concrete implementations as arguments and/or return value: 

it assigns a value to the String . now, I assume that the logic was meant that should be assigned the name of either or but the code actually allows for both statements to be false and the value will then be an empty String. You can fix that by changing the flow to an one