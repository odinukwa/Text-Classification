(Yes, I know technically that's wrong from a consistency standpoint, but it's what would be desired in the situation.) Edit: Small updated, I did change the structure of the table, and drop the column from it, and replace it with (which is now renamed to , and all relative Foreign-Keys and and relationships updated). From a technical standpoint, this is a more appropriate setup in my opinion due to the fact that the table is limited to ISO 639-1 codes, which are unique to begin with. Tl;dr So: the question, how could I modify this query to return everything from and then return either for that , combination, or the if it did NOT exist? My initial thought, is that I could somehow cast the current query to another temporary type as another subquery, and wrap this query in yet another statement and select the two fields I want ( and ). If I don't find anything, I'll just do the standard method I typically use which is to load all the into my C# project, and then with it run the query I have above manually against each . Thanks for any and all suggestions/comments/critique. Also, I apologize for it being absurdly long, I just don't want any ambiguity. I'm often on StackOverflow and see questions that lack substance, didn't wish to make that mistake here. 

The master server is version 5.5.33 The slave server is version 5.6.13 The master server is using old_passwords=1 The slave server is using old_passwords=0 

which seems to relate to the authentication protocol. Do I need to completely restart the MySQL master server, with old_passwords=0 in the my.cnf file? 

If you're just going to delete this extra data manually on the odd occasion, you can simply turn off the binary logging for the current session. On the MySQL prompt run the following: 

From my Googling on the subject matter, I'm led to believe this is a network/firewall problem. I've checked that my RDS has a security group allowing all network traffic with the source machine (both private IP and Elastic IP) and the source machine has a security group allowing all network traffic with the RDS instance IP address. The master server has a user set up with replication privileges. I'm sure there must be something easy I'm missing here. I've tried running on the master server. How do I get the replication to proceed successfully? Some additional information: 

All relationships described in the image are complete in the database - the and constraints are all setup and operating. None of the columns described are able. All the tables have the schema . Now, I have a query which almost does what I want: that is, given ANY Id of and ANY Id of , it will return either: If there is a right-proper translation for that language for that string (I.e. -> exists, and in , , and combination exists, then it loads for that . If the , , and combination did NOT exist, then it loads the value. The is a given . My query, be it a mess, is as follows: 

You can alter some values in your /etc/my.cnf file. Some important ones are innodb_buffer_pool_size (assuming you are using InnoDB) and also query_cache_size. You should try to set the innodb_buffer_pool_size to 10% larger than the size of your data if you can. The default of 8MB really is woeful for performance. 

I am migrating my company's database from an EC2 instance to an RDS instance. I have already migrated a snapshot of data and am now trying to set up replication to get the data that has been added since the snapshot. I am following the instructions at this link: $URL$ When I call , shows the following: 

Additional Desired Output Given the example above, the following output would be desired (updated with French example): 

Typically you would design the database such that someone coming into the database alone could get a handle on how the application worked. Had they seen such a foreign key they may not be aware of it's implications. You could approach this in two ways: First, you could do as you mentioned. Create two separate tables and handle them there. Second, and the way I would recommend, you would create a table to handle all the common fields between the two, and then two other tables, one for internal-specific data, and one for external-specific data. Each of those tables would have a primary-foreign key to the common table. I.e. a Guid or ID. The downfall of the second method is the application would be required to be aware of the two different tables, and depending on the method you are using to implement it (.NET, PHP, Python, etc) you may find one method easier than the other. I personally use .NET and C# or VB, depending on the project, and in this situation I would go with the three-table design, as I would create an abstract class ("Event") and then two classes to inherit it and all the common properties ("ExternalEvent", "InternalEvent"). The Event class would handle the interaction of the shared properties, and the InternalEvent and ExternalEvent would handle the logic specific to them. The upside to this approach is the polymorphism of it. If you add a common field to the two in the future (for whatever unprecedented reason) you only have to add/change it in one location. 

Firstly increase the default InnoDB Buffer Pool Size in my.cnf (I believe it default to 8MB) You should probably set this to 75% of your RAM size (in general) 

Then any query you enter won't be sent to the binary log, and thus won't be sent across to the slaves. Once you're finished, re-activate binary logging with 

I've tried setting on the master, creating a new replication user with a new, long hash format, but still can't get replication to start. The error I get is: 

Yes, I believe this is the cause of your errors. Your method for introducing the new slave seems to be correct. It is quite strange in my opinion to define a table with a DATETIME field as the Primary Key. As you've quite rightly pointed out, the slave gets the replicated queries from the master and they will use the now() keyword in the queries, which will grab the timestamp from the local server. Really, the table should be defined with some other data type for the PK (such as INT or BIGINT) which can be guaranteed to be unique, unlike a timestamp inserted with now(). 

The problem is that it is not capable of providing me ALL of the and their respective if it exists, OR their if it didn't exist. It is perfect at providing any one of them, but not at all. Basically, it's to enforce that if a language does not have a translation for a specific key, then the default is to use which is of translation. (Ideally, it would not even do that, but instead load the translation for , which I can do myself if pointed in the right direction for the rest of the query.) I've spent a LOT of time on this, and I know if I were to just write it in C# (like I usually do) it would be done by now. I want to do this in SQL, and I'm having trouble getting the output I like. The only caveat, is I want to limit the number of actual queries applied. All columns are indexed and such as I like them for now, and without real stress-testing I cannot index them further. Edit: Another note, I'm trying to keep the database as normalized as possible, so I don't want to duplicate things if I can avoid it. Example Data Source dbo.SupportCategories (Entirety):