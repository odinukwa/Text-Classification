Now, regarding your animation smoothness/stuttering problem. The following while loop is a bit weird: 

The same happens in your where you create a temporary and then push them on . Why not add them directly to ? You know the size beforehand, so you can call on and acces the elements using the operator. (This way, the vector has to reallocate only once) Use namespaces You have some places with generic names, such as , which might collide later on when you include some math library. Use namespaces from the beginning to prevent issues later on. Prefer the compiler over the preprocessor If you can, prefer a const variable over a preprocessor define. 

Work directly on an object instead of a temporary in you use two temporary variables and just to copy them over into . You can the following code and work on directly: 

If you don't, the destructor of the subclass may not get executed if you're working on the interface. Be consistent in naming conventions It seems that you use the prefix for members and prefix for parameters. That's probably a good idea but be consistent 

First suggestion: clean up your code. There are a ton of inconsistencies in variable names, indentation, brackets, defines ... Variables I was confused when seeing variables in your file, suggesting that these were global variables yet they are declared as member variables. My guess is that you moved away from global variables (which is a good idea) but forgot to fix the naming. I know it's annoying to change all those names now, but it'll save you a lot of time in the long run and many modern IDE's offer refactoring tools. Keep in mind that full-caps member names (such as ) are used to indicate constants or defines. In another file, , you use as prefix. Be consistent, either use the and or and prefixes everywhere. Moving away from global variables is a good idea because they are often quick hacks but often they can do more bad than good in the long run. Imagine declaring as a global variable, and using that in every manager. But when we want a single manager to update at half speed to mimic slow motion, we'll have to do nasty things. So in my opinion it's better just to give the time as a parameter to every manager. Defines Header guards should be the first thing in a header file. In this is not the case, so move those ifdef's up to save some compile time and potential compile errors. Const correctness If I call a function such as 

: There is no reason to use dynamic allocation, and are constant expressions!. Just use or better . That said you usually want to have dynamic sizes or your matrix may be larger than the stack limit. Then you should use . C-style arrays and dynamic allocation should always be limited as much as possible. Using proper class objects wrapping them is much safer. will take care of all memory management for you. If you are concerned that will layout rows non-continuously, then use instead and properly access the elements by . Also, in C++, you do not use and . Instead you use and . The difference is that not only allocates memory but also constructs the object in that memory. In most cases you would need to manually construct the object in the allocated space (although for double it is technically ok here). You should not declare a method, but rather everything freeing memory belongs in the destructor, which is automatically called as soon as the object itself goes out of scope or is destroyed: 

and should be . You need to to use . You are defaulting the copy constructor and assignment operator, but not the move constructor and move assigment operator. That's fine because the defaults are generated anyway, but it is inconsistent, I think. What is the point of ? should be . You don't want to have users create s. does not actually own the pointer it holds. It is copyable and will just copy the pointer it holds. It also does not create anything or delete anything in the constructor/destructor. Nontheless you provide a member. That seems very wrong to me. You don't know how the memory you point to was aquired, it could be with static storage or an array. In both cases calling would cause undefined behavior. The object creating the pointer with should also be responsible for ing it. Calling on two copies of also causes undefined behavior. The fact that the pointer is not owned seems to be a major flaw here anyway. Currently the user of your class needs to gurantee that the object pointed to keeps in scope until all 's holding it are destroyed and then it has to take care of proper deletion. Using it outside of is not allowed. So why not move the responsibility of managing the pointer to ? The same holds true for the lock. Currently the user needs to provide a suitable lock and keep it live until no references it anymore. Why not create the lock/mutex inside the constructor from pointer? Though I realize if you do it like this you need to manage references to the lock and you end up with fully reimplementing . Therefore I will just assume that this wrapper is explicitly only about locking and not managing ressource lifetime and that the user is required to run the destructors properly. is fine if copy elision is performed (not required in C++11, but in C++17), but is not either way. The object you create in is destroyed before the function returns. That means that is called before the caller expression using the pointer ends. currently returns a copy. It should return a reference. At least that is the usual way this operator is interpreted. In general the approach with and has some limitations. You may not call either twice in one expression or you have deadlock. But you are also not allowed to save the pointer returned by or a pointer/reference to the object referred because these are not guarded any more by the lock. I guess it would be much better to let the caller call a which returns a . Access to the holding pointer is then only allowed via and of this . As soon as goes out of scope its destructor releases the lock, similar to . This still allows the user to misuse a saved reference/pointer to the raw object, but at least more than one usage can me made in the same lock aquisition. An implementation via C++11 standard library would be similar to this (not tested): 

Another tip is to use lowerCamelCase for variable names. Try to avoid useless comments Comments such as inside of a constructor don't say much - the syntax of the language and/or name of the function should be good enough to describe simple actions. Comments are very valuable, so feel free them on places where they are useful (in complex methods), but don't add any that add nothing. Use nullptr over NULL NULL is defined as a zero, which can also be considered as an integer by the compiler. This can get some weird issues when you have a pointer and integer overloaded function. Pass arguments by const reference where possible If an argument has a complicated copy constructor (e.g. if it has to copy memory (such as ) or has to do atomic operations (such as increasing a refcount)) 

The comments from the other answers are valid as well - try to avoid copy pasting. If you ever have to copy paste something try to think if it can't be made into a function, macro, class, ... 

The compiler can complain if you double declare, is strongly typed, ... Cache sizes of containers while iterating Depending on the container, calling GetSize() and operator[] can be expensive. Cache the size up front or use a range based for. 

Remove unused headers For example, in you include but it's not used. If you would only use it in your cpp, move the include there to save some compile time. If compile time is really important you can even predeclare in your header. Use initializer lists for all constructors For example, your zero-argument constructor in the class (the one defined in the .cpp) doesn't initialize it's arguments, and you might up reading garbage memory. Mark const methods as such For example all getters can be marked as const, as well as all other functions that do not logically alter the state of the object. 

I want to be sure my parameters and base object will not be modified. (If calculating if two rectangles intersect requires non-const parameters (so possibly changing that rectangle), something fishy is going on). The general rule should be to mark everything as const unless it is inpossible: 

180 is an integer, not a float. So you'll get a whole devision instead of a floating point devision if is an integer as well. This is not the case, but it is dangerous so I recommend you change it to Clean up a little Remove empty functions, don't pollute your main function. So either remove or transfer some of the logic that's currently in . Polling versus events In your function you're polling the state. This means that every single frame, you're requesting state. In this case, it's about a few keys but if you have support for multiple players and controllers, this method is going to get computationally expensive. Responding on events is a little more complex, but worth considering for larger projects. Have a look at events in sfml. Use parenthesis They're free, so why not use a few extra. Take a look at this piece of code: