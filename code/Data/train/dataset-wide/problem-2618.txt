I'm not a fan of having property on my views. One of the advantages of MVVM is that it allows you to have your view and viewmodel loosely coupled. By declaring a strongly typed property on view you lose this advantage. I mean can't you just store the viewmodel reference as a field in your presenter? 

Some white spaces between operators and braces would be nice. A minor thing, but it really helps reading the code. 

This interface is a bit confusing. It implies that and are properties of , while in fact those are essentially return values of method (in other words they are properties of validation result). I think you would be better off returning a complex object: 

Then you should probably cancel incomplete processing when input changes. If you are going to discard the result anyway, then there is no reason to wait for completion. 3s is a lot of time. I don't have a clear understanding on how recursion works with . It can behave differently. Maybe you should take extra precautions to make sure that stack can not overflow. I'm not a fan of prefixes. But that's a personal preference. name is a bit confusing. I think something like would do a better job at explaining what this flag is for. Also postfix is unnecessary, prefix already hints, that it is a field. 

and then create a vector with Points as items. It's much easier to read and maintain. Secondly: your function InArea(x, y) calculates the bounding box xmax, ymax, xmin, ymin for every point you check - that is inefficient. Instead I would create a field/proterty (maybe you need to create a struct called Rectangle?) in your Area-class holding that information as it is stable as long as the vertices don't change. Thirdly: A way to determine if a point lies inside a boundary is the ray-method. To test a point you select another point far away from the boundary and then find the intersections between the line between the two points and each side in the boundary. If there are no or an even number of intersections, the point is outside the boundary and if there are and odd number of intersections, the point is inside the boundary. (see the image below for enlightenment). I won't argue that it is the most efficient method, but it is fairly simple. 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

Then you can remove , bind your grid to property instead and call when filters change to update the view. 

Well, in my opinion transaction should definitely NOT be responsible for getting a list of itself... Not only it makes little sense from domain perspective but it also violates SRP. Another major concern is that this design clearly encourages having classes with lots of hidden static dependencies. This problem alone is good enough reason to avoid it. 

The rest you can do with regular LINQ operations. Want to get a Fibonacci sequence for ? Just call : 

Your hierarchy presumes that every descendant class will call setter. That's wishful thinking. :) You will get away with it in this small exercise, but you wont in more complex projects. You should make abstract. 

Your implementation looks really complicated and (more importantly) error-prone. To be honest: i stared at your code for ten minutes and i still failed to follow the workflow. And it should not be that way. I mean, parsing a csv file in simple case is a three liner: 

Your class looks fine to me. I think every project have a variation of it. A few minor issues i see: 

The calls to CheckForDuplicate(...) seems to be on the same level of concern so maybe make a combined handler for that: 

Your handling of state is nice and clean and easily maintained in that you always create a new instance when ever Buffer or Cursor changes. But it requires objects. Cursor is not : 

It is IMO easier to understand because the index is incremented in a more "natural" place, and the Write...() functions knows where they are. If you insists on _index as a class field, you could do it like this: 

In this way you - as a client of LuaHandle - don't have to deal with the extern api's at all and no invalid IntPtr can be past as argument to 

As the image shows checks against two different generations because the board cells are successively updated through the calls to in resulting in a false new state. The solution is to create a new board per generation and recursively check those while creating the next generation board: 

then it would not be found as a change. If you're going to use the class with lists of reference types you need to track the state of each item between calls to - which could be a hash or something like that. 

Maybe would be a better name for the first method (since it is similar to ). 2) There are some magic numbers here and there, for example: 

- i think you should either change this property name, or change type to . Semantically cell being a winner doesnt make much sense. In general i am not sure i can follow how will you derive from . implementation for small board doesnt make sense (shouldn't you check for winner instead?). Same goes for for large board. I have no idea how is going to be used for either boards, and what means (not very descriptive). Etc. As for i have a few minor concerns. a) I hate s, s, etc. with all my heart and soul. :) THey have this ability to turn even simple code into a mess. This is probably a matter of taste, but i think a simple arrays would be much more readable. b) I do not like multiple , it makes code hard to follow. A simple would be better. 

In order to do a proper refactoring, you should move your classes somewhere, where you can calculate data. If you cannot do so, then you'll be better off with your original version. The second version is completely counterintuitive. Without digging into implementation details it is impossible to guess, that you need to set property for method to work. Also returning from factory (unless it is a valid value) is bad code style. You should throw instead 

Naming: is not an index, but the actual value in the valid sequence (from min to max). I would call it or or something like that. I don't like the name either, because the target is actually the sequence of numbers from to . would be better IMO. 

With only a couple of hours ahead of you in my experience with F#, I find the essence of your code fairly functional, although the graphic output is hard to grasp as it has a lot of flicker. Below find a gentle review of your code with improvements (or at least another way to do the things) and inline comments. I've tried to improve the graphic output by using colors and a distinct update of the cells only when they change. 

Note: If you try PrimesBySieveAndLinq.GetPrimes(int.MaxValue) it is very slow at the beginning, but speeds up after some 1000 of primes. 

But this will halt the calling thread while HSecondCounter ticking every second infinitely with no way to stop it. So this is not useful. 

In the way you show that you create each Skill instance, you really have anything than the Description to distinguish them from each other. I read your Skill class as merely an advanced flag that defines a small set of properties. In the below I further anticipate, that each skill type doesn't change throughout the game. If that is correct, then I would make the Skill class as a "singleton" per Skill type (onehanded, twohanded etc.) and let a static Factory method create/return the right Skill according to a Skill Type enum: 

I have a personal vendetta against , so I can't judge it objectively and I won't. :) What bothers me though, is your use of reflection. Why do you even need it? All DI containers I've worked with (Autofac is not one of those) had a way to do both: specify a default implementation of an interface and register a wrapper that would resolve a collection. So you should be able to register: 

Mainly because it is impossible to tell at first glace where statement ends and loop body begins. Use offsets to separate them: 

It also feels like you are overusing keyword. Why is static? Why are timers static? Why is list of processes static? Can they be made non-static, without modifying the rest of the code? If they can, then you should do so, it will greatly increase reusability and testability of your code. If they can't - then this is clearly a design issue. You should not rely on some global state in your code. The rule of a thumb is: 

Your code can use stricter access modifiers. For example, some of your properties look like they are not supposed to have public set accessor, yet they do. Commands can also be refactored to auto-properties. Apart from that your code looks pretty clean in my opinion. implementation should be moved to base class, unless that is the only view model you are going to have in your application. As I am not very familiar with windows phone frameworks, I do not know what is, but i assume that it is some kind of events aggregator. If it is the case, then it is probably a good idea to unregister your delegate at some point, to unsubscribe from events as you navigate to different view. 

(The meat of the extension methods can surely be done more sophisticated than the above.) is an with a rudimentary definition like: 

I'm not sure if the objective was insertion sort or tail recusion? In any case the performance is rather bad for larger data sets. If insertion sort was the focus the following approach is maybe somewhat more straightforward: 

If changing to the below you can avoid the IsNumeric check and you can specify a format string for all property types: 

on the view (form) maybe should be an interface which HomeScreenPresenter implements. Further: Instead of the presenter reacts on events on the view the view should call "passive" methods on the presenter - but it's a matter of taste maybe. 

Sometimes extra parenthesis can make an expression clearer for the human eye, but here the computation is more or less incomprehensible for non-experts, so they really make no sense. Whether or not you should have spaces between operands and operators is a matter of taste - I prefer the spaces. 

As stated in a comment the above solution does not handle accented letters so a better solution may be: 

I think you show a good understanding of F# as a language and functional programming in general as far as I can see. A couple of things though: You use as variable name on multiple levels of function definitions. It makes it hard to read. IMO is a very readable construct for more than two matches. But for only two I prefer if-statements. The function/sequence is a kind of double sequence. I would do it this way: 

Alright. This is how your code can be improved in my opinion: 1) You do not need observable collections for itemsources. It is used to support changes to collection, and you have none. In your case, a simple array or will do. 2) You should try to avoid using string arrays for storing entities which are not exactly strings. You should avoid hardcoding 70 string values as well. If you need to populate such array - this is the first sign that you need a database. You will be able to add new Products without recompiling your code, populating arrays will require a single query, you will operate using Product ID's or some complex object, etc, etc. There are many advantages. can be made a and can be populated in a simple loop (you can implement to add an empty row, if you need one). should be a list of some objects, representing volume. 3) As for UI, you can improve your code using standart MVVM practices. Instead of setting up bindings in code behind, set your to some viewmodel and use data binding. ViewModel example (i left strings intact for simplicity): 

I don't see the benefits of having both static and non-static API: and . It does not bring any new possibilities, but it does cause inconsistencies in usage (personally I hate it when there are multiple ways of doing exactly the same thing) and additional unit testing. I would remove static version completely and keep only non-static one. However I think that creating an external static class, similar to , and moving any complex math there from class - is a good strategy too. 

As others have pointed out you only have to check the number of distinct characters in the sentence. A one liner doing that using linq could be: 

In general it looks OK to me, but you could maybe consider the following: 1) Return a instead of and then yield the positive results when found: 

The function can't handle values lesser than 2, and it shouldn't as it has no meaning. But instead of returning properly it ends in a long while loop. Instead of int you could use ulong because it signals the domain of the function. There is no need to return anything from the prfact() because the nums argument holds the result. You can optimize the algorithm in that the curr argument is unnecessary as shown below. 

A slightly different approach is to avoid the sublclassing and instead feed the generic DelaySequence class with a generator function. It makes it more flexible. 

Although I strongly agree with tinstaafl in that the use of ToString() is not very beautiful from a mathematical point of view the solution he provides is rather unstable due the first if-clause (). On my computer the following errors are found: x = 0.000000000345; Wrong result x = 13 or 0.000054635 or 54.635 Stack overflow I haven't (had the time to) found a reliable solution, so it seems that ToString() is the best choice of stop-condition. sqroot() is missing one important input check: x >= 0 :