A relational database would typically contain several related tables. The relationships between tables use what is called a foreign key column which is basically the primary key of a parent table placed in a child table's list of columns (with other rules not listed here). For simplicity, you can say that relationships in a database depend on Primary keys very very much. Now if a value is changed, the system has to perform so many changes to coupe with this change. As an example, say you have a Social Security Number of a person and you keep track about this person's properties, cars, jobs, wive(s), kids and let's say you change the SSN value. The system will have to change the corresponding value in each of those related (child) tables. This process is not always good to perform on-line. Another reason is business related. Say you are issuing an EmployeeID Cards, if the number on the card changes, then the card is no longer usable and you have to print another one, not only that, but this means that the salary information has to change, the insurance information has to change as well as other information related to the EmployeeID. In business, sometimes not all this information is integrated or even automated, so this change leads to a lot of work and possible inconsistency of information in manual systems. Such changes may not only be localized to one organization and may have to affect other external organizations or systems, which would make life very difficult, because you have to ask your business partners to carry such changes on their end too. Yet, another reason for not changing key values is that when you do so, history tracking becomes difficult. All history logs and documents will not reflect the current value making it difficult to interpret or even find data in manual systems. 

There are 2 scenarios to consider. The first is when you have the user take 1 or more questions without a meaningful context such an exam or formal quiz. In which case you solution works. However, the second scenario is about when the user takes a question as part of a formal session. In this case you have the following rules: 

Here the query fails because you are trying to compare a numeric value to an empty string. The data types is not the same. You need to compare values of compatible data types to ensure correct result. I don't fully understand what you mean by Q3, so I will not be able to help with that. Be very careful with Nulls they are tricky. 

I suggest you follow normalization rules. This will minimize the write and update processing (and errors) and simplifies coding of the logic of write and update routines. You can tune reads in many ways. You could use materialized views or indexed views to keep track of counts without queering the records one by one. Don't sacrifice normalization for no obvious reasons. 

The process step is not meaningful in your case unless a process version is defined. So you could say that process 1 has its steps executed in this order (a, b , d, c) when the process was in version 1, but in version 2 the step execution order changed to be (a,b,c). So I think that a process version is important. The diagram below represents my suggestion. The silly thing about this is that if you change the order of a step, you have to insert all steps again in the new order, but in this case, it won't matter either in space or time. 

Since NULL value is not the same as empty string in SQL, then the result you obtained is correct and makes sense in SQL terms. Think of NULL as "Not Defined Value" and as such it is not same as an empty string (or any non-null value for that mater) which is a defined value. From an English standpoint, null is the same as nothing but this is not the same in SQL. Now what do you expect this to return? 

Without knowing the business rules it is generally hard to judge if a model is valid or not. However, here are some quick points: 1-Address relationship to employee should be reversed. An employee could have several addresses. Your address modeling may be valid if you are referring here to work address where multiple employees work at the same location. Similarly, there is an issue with the phone to employee relationship. 2-Self reference relationship in Employee must not be mandatory on the many side. 3-Relationship between employee and leave balance is awkward. An employee should have 1 leave balance per year but your columns don't show that clearly. 4-Phone table, should separate area code from actual number for land-line phone numbers. 5-Naming: DOB Date is a bad name. DOB means Date of Birth, so the word date is redundant. 6-Salary is not related to Promotion from a business sense as you have it. Salary is related to grade, level, etc. 7-Some relationships are mandatory in the model where they should not be, I have already pointed out the self-referencing one but you also have the Employee-Dependant relationship. It should not be mandatory. The same is true for leave taken. From a professional stand point, I think you should not use this mode for a production application as is or even with the remarks I mentioned here because I did not provide a full list. Make sure you consult with a more experienced professional before implementing such a model in production. 

I would not use GetDate() for this fixed-period scenario as the end date for queries, because the reports are only meningful for specific periods. A better approach is to use a specific run-date for each reporting period. That run-date is not the current date. For example, let's say one of your KPIs is the sales amount for the first 6 months of 2013. Your system should use end of June as the end date not the current run-date regardless of when the report is run. If you do this, you'd not have to touch the data. 

Typically you'd have an Invoice table that contains 1 or more sold line items (as a child of Invoice) and each line item's price (as well as possibly other details) would be looked up from a lookup table (that would act as a parent for the line item and would contain the price of each item). A line item in this case has many parents. The price table plays the role of a reference or lookup table. 

In many applications, it is common to use a db-automatically generated number like a sequence number as PK. If the table does not have a naturally key and you don't want to use an artificial key (as I suggested), and the table is not a parent table, you don't have to create a PK at all (you can still create non-unique indexes on any combination of columns you want). 

You should start by writing all the relationships between those tables. From your description, I could not find out how Partner would be related to Client, Program or User. However, the diagram below is a start based on the information provided. Note that you can't use 1 Link table to link all table from what I understand in this case. EDIT - New ERD based on new requirements 

For the database to be able to guarantee uniqueness of a row, it needs to search the table to make sure that the new incoming row has a unique key. This can only be practical and efficient, in large tables at least, when there is a structure called an index defined on that table that can be searched quicker than searching each row of the table in question. The same index could be used to locate rows by user queries. The index can be built on 1 or more columns of your choice, even on non-key columns to speed the search or to prevent duplicate rows. Sometimes designers would use artificial keys such as auto-incremented keys of data type int for example, instead of long composite keys containing long strings of data. This increases the search speed but still adds an extra index that could affect the insert/update slightly. The shorter the key, the more keys could be loaded and searched in memory, hence improving the overall response time. In your case, you could, use such an artificial key to enhance performance. To guarantee uniqueness, you will still need a unique index defined on your composite key.