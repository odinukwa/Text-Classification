You should avoid all of these like the plague! Now, I know your specification says "use recursion". So what a professional would do first of all, is to question if the specification makes sense. In this case it doesn't - there is absolutely no need to use recursion here. Others have given you diverse ways of solving this with recursion. Here is an alternative approach which is efficient, instead of needlessly inefficient. 

And now you'll say "this is not exception handling!". Who cares. If you look at the generated machine code, this will generate exactly the same code as a C++ exception handling program. It will contain the same direct branches. The only difference is that the above program might contain less overhead and therefore execute quicker, with less memory usage. 

There exists no reason why you need to use pointer-to-pointer here. It is slow and needlessly complex - a complexity that caused a memory leak bug. Simply do . Alternatively use a variable length array (VLA). If you for reasons unknown must use dynamic memory allocation, then do so on a proper 2D array and not some fragmented look-up table. See Correctly allocating multi-dimensional arrays for examples of how to do this - it is likely that your book or teacher is teaching you bad habits here. 

Program design The main issues with your program is the overall design. I would recommend to study object-oriented programming on beginner level before even picking up C++, or any other programming language. 

General advise Never write the whole big program at once. Write a litte bit at a time, compile it, test it, if there is anything wrong with it, fix it. Develop the program a tiny bit at a time. 

The tests should be easy to maintain and understand. That is the tool that drives development. Sometimes it may contradict with the widely known rules you mentioned, but it does not mean we should be fanatic about that (as soon as the tests drive the development and work as the safety net). 

Does it make sense in declaring 'Add' methods as and 'Remove' methods returning ? (similar to .NET collections). Does it make sense in adding other collection-specific methods like or ? 

Rule 1. When I add the same identifier twice, does it may sense to throw an exception saying that the cannot be added? Is there any harm in 'doing nothing' here? Rule 2. Trying to add a list id to the included lists throws an error if it's already belongs to the excluded. Does it make sense to introduce some helping methods like or ? Does it make sense to throw an if an empty is provided? 

That's totally fine and even more - introducing 'common' initialization logic increases coupling of your unit tests. Imagine you need to add a new 'common' line to setup things common for a few tests. You never know for sure if there are any other tests impacted; you may make your tests false positive. It's more safe to modify your test 1 by 1 as necessary. Tests like have about 6-7 arrange lines and 2 assertions. IMO, it is easier to read, understand and (!) maintain this single test than splitting it into two (or more) just because of the 'one assertion per test' rule. That looks like Facade tests. That might be fine to have them at some level, but it's important to understand that tests like that may be a bit more hard to maintain since there are more parts that might be broken during refactoring. Don't have any oppinion on that... Looks fine to me. 

It seems that the variable can be replaced with a boolean(?), which in that case would make the function clearer. You could then have each function returning a bool and make the caller even smaller: Given , the caller can be reduced to this: 

Now you can define a look-up table of functions corresponding to the logic table above. Do this by declaring an array of function pointers: 

To set the bit flags in , you'll have to use bitwise operators like shown above, instead of /. Then make a function corresponding to every case and define a common function type. (Since you understand the algorithm, you can probably come up with better function names than me) Write the functions so that they only contain the actual action to take, and not the boolean checks, which we are optimizing away: 

I am writing a portable library function, which is a generic "remove characters" function. Language standards used are C11 and MISRA-C:2012. TL;DR: it should either remove all occurrences of a specific character in the beginning of a string, or it should remove all occurrences of the specific character no matter where they are in the string. The detailed specification: 

EDIT Also, consider adding new line characters after each print, for readable output. Code with the above suggestions: 

Additionally, and this is important, I wish to be able to use the function "in place". That is, is potentially pointing at the very same address as . 

The multiple if statements based on booleans can be optimized in the same way that you optimize digital logic in electronics. Make a logic table like this: 

No, that is very good practice and a good habit. Particularly, there are many dangerous, implicit type promotions going on in C, that explicit type casts can prevent. However, if you want to be explicit, you must actually have quite a deep understanding of what's going on between the C lines. Until you do, you will end up causing more problems than you solve with this coding practice. Also, you do a couple of pointless things that only clutter down the code.