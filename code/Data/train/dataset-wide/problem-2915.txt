A further vulnerability is that you leak the lock's monitor. Using synchronized methods is a problem, because someone can simply synchronize on your whole class, and deadlock the entire system.... Consider a thread that maliciously does: 

Don't print each character - build a block of text up, and print the block (note that adding a newline to the string works as well as a ) You can input the text to repeat as a parameter to the function... It is common practice to have loops from 0 to 1-less-than-the-limit like and not from 1 to the limit . Your loop is not wrong.... but it is unconventional. 

The TreeSet is a problem because it has a significant time-complexity (and storage size). Adds to the TreeSet are \$O(\log{n})\$. As the dataset grows, it gets noticeably slower. You can be sure that the test software will do something like: as input, and that will take a long time, and a lot of space, in your TreeSet. Your solution, because of the TreeSet, essentially becomes one of time complexity \$O(n \log{n})\$, and space complexity \$O(n)\$ The solution is much simpler than what you have done... consider a simple function: 

The benefit there is that the variable is limited in scope to just the loop (and is not in scope afterwards). Note the 'empty' third-clause of the for loop. 

So, here's the thing, what you have is not a generic method. What you have is a generic class. Now, it's a clearly defined generic class, but, it is not what the question asked for. (as a generic class it has a number of issues too, but let's get the method/class issue resolved first). Generic methods A generic method is just that, a method, except the parameters (or return value) are of a generic type. A generic method always has a structure before the return-type declaration. A normal method is: 

Now, the bulk of the hard logging work is not even on the threads that are doing the real work. You also have a multi-threaded environment and thread-safe logging. If logging starts backing up, you throttle the application at 100 events in the queue. Basically, you have a better solution. 

The math behind combinations is relatively simple. There are \$n\$ members in an input set, each member is either in the output set, or not in the output set. Now, because there is a 'binary' condition (either in, or out), you can think of the problem as follows: If there is just one input member, then that member is either in the set, or not. There are 2 combinations, the empty set, and the set with that one member. If we add a second input member, then we can have the same two combinations of the first member, but then we can also add the second member to the output, and get another two combinations. As follows (for the input data {a, b}): 

if your number of digits is always going to be less than about 10, then you can use a single random operation and a string format, to do all the work without the loop. Consider a method like: 

What an interesting challenge. Learning Java8 is on my list, so here's some suggestions I have, but bear in mind that I am learning too.... First up, lets use functions for the functions we have. Starting with the safe function: 

The nice thing is that you can then run it with much larger counts, like 1,000,000 I ave put it all in an ideone here... enjoy!. This is what the results look like: 

Now, that code can be made asynchronous relatively easy by using the native Java tools. I will use a Java 8 function expression to create a Daemon thread for the background execution... and also the functional interface. 

OK, that's enough about the general issues.... The better way. Storing your Rational numbers is an important part of many programs. The underlying problem with your class is that it is Mutable. .... you can change the value of a Rational. This is unfortunate for a few reasons: 

Running the on your code also made a difference - mostly in the spaces/tabs situation - go uses tabs.... for better or worse, always. Naming One item that had me confused for a bit, is this code: 

The and fields in the should also be final, and instead of being public, should rather have 'getters' for them. Sorting You have special handling for the buckets and the ranges, depending on negative values. This special handling has also resulted in a lot of code duplication. You essentially have two complete method duplicates, one for sorting the high-byte (with negative values), and the other for sorting the remaining low bytes. Your code 'buckets' the data (or a data subset) in to buckets based on a significant byte. The challenge here is that the most significant byte has a different sort order than other bytes. The trick to solving this is to flip the most significant bit, and the resulting order is now accurate as if the long was unsigned..... Your code would boil down to something like: 

The 'input' in the last column has because otherwise it is too small. The input area unfortunately extends past the border though, so I have had to add a manual padding of 7 px to the right side of the td to make it work. This seems counter-intuitive the use of read-only input members allows the data to be shown, and scrolled-through, if needed, but is it the 'right way'? 

What were the results? Comparing the above single-monitor synchronization with your double-locked implementation, using 20-capacity queues, and passing 12,000 values through, the results are: 

Also, what if the invoked method throws an exception... do you propagate that? Why do you feel it is necessary to have . The reflection you are doing should not be exposed.... 

I am generally impressed with the consistency of the implementations, neatness, etc. I have a comment about the basic premise. The should not be an abstract class, but an interface. It has no concrete implementations for any methods, and making it an abstract class makes it hard to inherit from other places too. Consider this instead: 

The boolean should be the negated value of . A second bug, in , you have the option of as the region. From what I can see, that option does nothing. It sets the values of the and variables, but then does nothing with those values. What is the point? Style 1-liners (even simple ones) should have braces: 

A standard way to do this is through break-processing, where you track one value, and when it changes, you do something special.... but you may find it easier to do a more unstructured system: 

General This is a nice challenge. Your algorithm/approach to the solution is a good one in general (it can be tweaked a bit), but your implementation is a little ... spoiled... by using the static variable space for storing state. Your mixed-up use of naming conventions for variables does not help either. Some of the content belongs in the static space, like , , and , but the other static variables are not statics, or should not be. You should consider creating an instance of your class for the problem, and then using that instance to manage state, instead of keeping things static. For example, if your main method was: 

Breathing space Your code is suffocating since it has little breathing space. Many of your statements are compressed around the operators and other symbols. Consider lines like: 

Note, doing things this way means that a lot of the hard work is only done if the message is actually going to be printed. IO operations @Tim indicates that re-reading your config file each time is slow. He's right. Reopening your log file each time is also a problem. A better way to do it would be to open the log file just once, and then to flush it after each write to it. That way, if your application dies, it has already flushed all of it's logs. Low-Latency The process of actually printing and writing out to file is really slow, especially in code that is otherwise performance sensitive. A good solution to this is to use multi-threaded logging.... Have one thread that listens for events on a queue, and your application just dumps stuff on the queue when a log is required. The cost of dumping an event is much less than the cost of actually writing and flushing the IO. An is a good option. You have a thread that simply does: 

This question was mentioned in The 2nd Monitor as one which could use some more input. I looked at it, and decided that the Android aspects are not where my expertise lies, but then, when I looked further, I found there are other things to consider too. First up, I am going to assume that the android and classes can be loosely represented with the AWT and classes too. This is a stretch, I know, and it is something you need to take in to consideration when you read my answer. But, I assume the similarities are close enough for "engineering purposes". Now, I took your code, and "redid" it in AWT constructs. It looks something like: