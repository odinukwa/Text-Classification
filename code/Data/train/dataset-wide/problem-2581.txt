How can I clean up the process for formatting the arguments string? It seems pretty ugly at the moment, and if I have to add any more parameters, it's just going to get uglier. Is there an easy way to convert a list of parameters to a string that's suitable for invoking another function? Note: Simply passing in the parameters as a single string (e.g. ) doesn't really solve my issue, it just moves it back one step. I'd like to create the string within itself. 

Any other exceptions it throws indicate a invalid parameter or bad program state. You probably don't want to just ignore these errors and move on as though nothing has happened. I recommend you just do this: 

I honestly don't see anything particularly wrong with that Linq query, but there are a number of other things you should consider: 

If you've setup a proper navigation property you could write your query a bit more cleanly, although I doubt this would run any faster, since this will still translate to an in SQL: 

Now you get more type checking and have less repetitive typing to do ( instead of ). I did not capitalize because it is not a macro-ish constant anymore. A side effect of this is that you cannot do anymore because does not decay into an like does. Instead you can define addition and subtraction operations such as this: 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

You really need to use arrays for this. and are identical so I don't see any need for the condition. Use methods instead of , as they've been deprecated. Use prepared statements to guard against sql injection. 

You can also use a binary search (since this data is sorted) to speed up the search. My PHP is a bit rusty, so some one else might be able to improve this further, but I think it would look like this: 

It's actually a bit faster, since sorting the inner list takes longer than just getting the minimum value. 

For something this simple, I think using the is fine, however, if you need to use the list of acceptable integers more generally or avoid hard-coding the set in a single expression1, you can use something like this: 

Well there's not much code to review here, but for what's here, I'd say it looks okay. I would only make one suggestion. If all you're going to do in your controller action is return single string wrapped up in a JSON object, why not dispose of the JSON and just return the HTML as content? Ajax call: 

After having criticized a lot let me say this: I would probably hire you. You show a good understanding of C++ and should be easy to shape into a good software developer. Good luck! 

That last line should not compile, but it does. Blame the that should not be there. Unfortunately you need to write 2 classes to get this right in C++, typically and . Looking at the list of things required to make a bidirectional iterator it seems like you are missing some, for example everything around std::iterator_traits which also explains 

I dislike that your class mixes functionality (a mathematical vector) with memory management. A class should only do one of those. If I prefer I have to rewrite your whole class. There is actually a thing in C++ that is better than smart pointers, which is value semantics. People rarely screw up the lifetime management of an , it just works naturally. When you do tricky lifetime management try to mimic the way does it. The should be (as well as , and ). It should also work on s and not only on pointers. The standard way to add s is this: 

I'd recommend against using 'catch-all' blocks unless absolutely necessary. always throws a by design (like it or not), unless you pass in the for the second parameter. 

If you want to reduce the lines of code (with a slight negative impact to performance if this function gets called a lot), you could do this: 

My PowerShell scripting skills are pretty poor, but I've managed to hobble together got this script: 

I need to get the nested type name of without the namespace, i.e. in a generic method. Unfortunately, will just return and will give me the namespace as well. Right now I'm using this: 

1: Of course, in these examples, the values are still hard coded in one place, but precisely how you generate the list is unimportant. 

You can use or to exclude the empty string in the results. If you write your own function using 's, like this: 

The last argument inside is too far away down, making the code hard to read. It is better to define your function separately, and use it a short line inside . Also executing your function inside is a recipe for errors and hard reading. 

Your code is sensitive to how behaves. You seem to expect error if it fails but what if silently returns or without failing? It would go through another loop and overwrite the previous setting. I would also encapsulate the loop inside a function that I can both test and debug. Also I would make sure that function returns a unique failure result, not dependent on the browser. 

This property is either being created when it is defined, or else, the calls like will still fail. You may want to check for existence of that property instead when calling it. 

Also it does not feel right to do DOM manipulation with jQuery-style, maybe use dynamic property instead. If having additional elements in DOM is really a concern, there are also and . Though I personally prefer exactly because this way I don't have to rebuild the DOM. To put this into perspective, I have tried using on my site 33hotels.com, which does rebuild the view every time the route is changed. That felt in considerable delay. Instead I have all my Views inside my DOM at all times and only them depending on the route. The performance difference is dramatic - it now feels instant. Finally, both templates have common fragment, which does not make code feel DRY. Upon any change you'll have to edit each of them. I would simply keep the common part outside any directive, and put the dynamic part inside whatever. Also note that the HTML tag has semantic meaning, not presentational. That is, it marks your main header. Any presentation adjustment should be done via CSS. 

There are good reasons why existing binary trees are so complicated. If you want lots of performance with lots of flexibility in lots of cases it costs you a lot of effort implementing the tree. Or you just use and don't worry about it. 

If your constructor initializes members the class initialization is treated as not existing (so no loss in performance for double-initializing), but if you forget or leave it out you get sane defaults. I would like to see and in the part of for encapsulation. If you let users access those types they will use them which I think is not intended. 

Note that this is a free function, not a member function of . Prefer free functions, because they work in more cases (like multiplying an to a ) and are thus more consistent. This allows you to do this: 

Was it a requirement to not use the standard library? It saves you from some of the pain of implementing boring, difficult and error-prone things such as sorting-algorithms. My solution The problem with squaring the array is that negative numbers become positive, making the array not sorted anymore. My idea is to find the index of the first non-negative number and then squaring the whole array. The partial list is sorted in reverse order and the partial list is already correctly sorted. Two sorted lists can be efficiently d into a sorted list. The reverse ordering of the first list can be compensated by using a . 

However, it's not clear that you need to be creating the in the first place. You can just use Linq to generate your from scratch: 

The one thing that really stands out to me: you don't need to convert the boolean result of to a human-readable string, then test the string. Just test the result directly, then convert it to a human-readable string. 

This is exactly how I would write it if I had to use C# (with the exception of the in-line if / else), but after I wrote it F#, it seems clumsy and a little messy. I suspect there is a much more elegant, idiomatic way of writing this in F#. Perhaps using a match expression? 

NOTE: as far as I can tell, there's nothing limiting (or ) to be the same in all grouped dramas; each drama could have a different . Here's an alternative that includes the teacher in the grouping: