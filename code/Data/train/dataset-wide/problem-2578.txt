Until you call , is null, so is going to crash... Naming Think about what variables you're declaring at a class level and what their purpose is, then give them names that reflect that. It will be a lot easier to follow your code and identify bugs. In this instance, it seems like perhaps is actually supposed to pointing at the tail/end of the list, rather than the head. Consider what you're supposed to do to any class variables (such as ) when you delete items from the list. 

class or enum This may be out of scope of you're assignment, however it's worth considering using an enum rather than a class to represent the different coins. Currency As it stands, you're representing coins from different currencies, however the coin only has a value, it doesn't have a currency associated with it. Similarly the cashregister doesn't take the currency of the coins into account. Naming Naming often suprisingly hard. It is however also important for making your code easier to read. Generally, try to name things for what they represent, not what you're interested in about them. Consider this code: 

So, you're accessing as . X is typically the horizontal axis, which I'd associate with width, as opposed to the vertical axis, which I'd associate with height and is usually represented by Y. Again, how much of this is because it's an academic example is unclear. There's no way to test option 2? If you can't test behaviour through the public interface of your class, then it is a good sign that you need to consider refactoring the structure. Is there a reason why you want to allow the clients of the class to explicitly set the value of a given cell, but not retrieve the value? This seems like an artificial constraint, again possibly a side-effect of using academic code. Without the entire code, it's hard to know for sure, but it seems like you should be able to construct a test like this: 

You can then open/read and close the file as appropriate (again, and property isn't required so would be removed). Either approach can work successfully, really it comes down to how the rest of your application hangs together and your philosophy of testing (which is quite subjective). 

If you can't get a socket, your application is in trouble. Don't just write to the log, throw an exception so that the caller is aware that there has been a problem and they can stop processing. Callbacks It's often useful to pass an additional piece of data into a callback method (for example a pointer to an instance of a collection to add the new socket to). With that in mind, I'd consider adding an extra parameter (usually a void*) to the callback. You also might want to consider typedefing the callback to make it easier to update in one place (if you decide to in the future). Something like: 

I've only glanced at your code, however it looks like your connection retry (in ) has a scoping issue. In your block: 

Test Cases The test really odd. You've basically saying, make sure that when I put 453234 into the array twice, my code doesn't tell me that the duplicate is 25. This might make some sense if your other test used the value 25, but it doesn't so 25 just comes from nowhere. You haven't posted the code for , however I did look at it in your gist and it's creating an array, then putting the duplicate in a random position within the array. Generally speaking, try to avoid in your tests because it can result in non-deterministic tests (tests that fail sometimes and pass other times with no changes to code). Some better edge case tests might be: 

From your comments, it seems that draws Pacman. If this is the case, then I'd still say that you don't want to be calling it from within your method. You want to try to decouple your game mechanics + movement/collision logic from your drawing/rendering logic, they are different concerns and may well move at different speeds. One of the things you've said that you are looking for is to improve the speed that your code runs at. If you think about running games on different hardware, one of the things to consider is that you need to start thinking about using that hardware effectively. To give a concrete example, if your current computer processes your method 10 times a second, that's going to move your Pacman 50 units. Another computer may only run it 5 (moving 25 units) or may run it 50 (moving 250 units) that's a lot of variability that's usually ironed by linking the distance moved to the amount of elapsed time, which may be detached from the render time. I haven't read the whole thing (and it seems to be aimed at the mobile market), but this seems like a fairly good introduction to game loop mechanics. 

You don't seem to need the handle after you've performed the marshalling, so it could be as simple as updating the function to: 

Think about making your variable names indicate what it is they represent. Instead of having , how about calling it something like . Try to be consistent with the way you set the variable. Either do this: 

A couple of things that jump out... Constructors I'm not a huge fan of passing Node's into linked lists. Besides exposing the list implementation it opens you up to confusion. Consider these two methods: 

I've been looking at some async comms in C#. As a proof of concept, I've written a simple multi-client echo server. The server allows multiple TCP clients to connect and listens for input from the clients. When it receives a complete line, it forwards the completed line to any other connected clients. For testing, I used multiple telnet clients to connect and monitor messages, as well as a simple client for sending test messages: TestClient 

You don't need to do this, it's handled automatically for you. By calling loop yourself you're recursing, if you do it enough times, you're going to end up with a stack overflow. My guess is that the Arduino would just reset in this situation and then call again. Since you're not playing, you might not even notice it happen. Your contains . This is also the first line of your method. Setup doesn't seem to actually be using the randomiser, so I suspect you don't need to call it from , simply call it from . Ternary Operator I've got nothing against the ternary operator, however some of your choices do nothing but make your code harder to follow. Nested s should be avoided. Creating a null function so that you can use the ternary operator is unnecessarily complex. The method would be easier to follow if you used constants and spread out the logic a bit. 

The caller is then responsible for supplying the (including cleaning up after it if it's a file. The class has given up responsibility for opening / closing the reader. and aren't required so would be removed. Approach two: Create one or more test files that are used for testing and change the interface to supply the path: 

@I'll add comments tomorrow has covered most of the main points, but I'd also suggest that you consider error scenarios. With most programming challenges, you can rely on good input however outside of the challenges you need to start thinking about what happens if the input isn't what's expected. Consider this function: 

Class Naming is a terrible name for a class. The class name should express what it is you expect the class to be responsible for. suggests a class that has no actual responsibility but is simply a bucket for functionality. User Input You have several places where you're getting input from the user, with y/n questions. If you encapsulate this in a single method you'll be able to reuse the functionality whenever you need it. So for example, you might end up with a class like this (based on your Functions class):