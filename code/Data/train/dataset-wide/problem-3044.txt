You could opt for implementing instead of , or even for making the member variable public (because it's final, and is immutable). [Some Random Thoughts] Try to simplify logical expressions as much as possible: 

To your second question: I assume you want to traverse the tree in-order, and that the nodes have no link to the parent, only to the children. Then you need a node list from the root node to the current node, which can store if a node was already visited or not, too. Then you go left as deep as possible, storing the path in the node list. This is your first current node. When you need the next one, take its parent (from the node list). Next would be the right children of that node (if there are any) or its own parent. The best way to understand this is to take a sheet of paper, draw different trees, and look how the traversal must work. 

returns a new collection, you need here Your attempt looks fine to me. Maybe you should additionally implement the trait or so, and delegate the calls to in order to make things a little bit more convenient. 

So all operation specific information is captured in the Op enums. If you want to add other operations like min, max, and, or, xor or mod, you don't have to introduce new if-blocks, just new enums. 

Usually only a few cells of a spreadsheed are actually filled, so I'd suggest to use e.g. a to save memeory and to allow to use bigger spreadsheets. 

There are a few things, I'll expand on this over time. First, always write method and variable names in lowerCamelCase. Everything starting with an uppercase letter wil be considered a class or a constant by other programmers. Then, don't use mechanically getters and setters. E.g. consider 

The code looks way to complicated to me, in fact this isn't even the kind of merge sort I'm used to, which is "split the list in two parts, sort the parts, merge them back to one list". Here is a short implementation: 

As Daniel Fisher already mentioned, you're using a Stack. The most basic implementation of this is a single linked list. The down side is that it consumes more memory than an array based implementation. The up side is that it is much easier to implement: You don't have to juggle with indexes, you don't have to copy the array content etc. 

The smallest divisor of a number (greater than 1) is always prime. The algorithm in pseudocode looks like (untested): 

Even ignoring the overhead of the class the code seems to be way too verbose, and even worse, constantly jumping back and forth between imperative and functional style. I'm still using a lot of for loops. Especially I couldn't find a good replacement for . Further, I found no good way to utilize , as its or methods seemed just too inconvenient. I'm looking for hints how to improve my code in a functional way without straying too far from the original snippets. [Update] Thanks to both answers and some API diving I came up with the following, which is IMHO a good compromise between conciseness and readability: 

This might be a little bit over-the-top, but how about a more object oriented approach? Assume this little helper enum: 

As the majority already pointed out, your method is fine concerning the coding standards. However it has an asymptotic complexity of O(nÂ²). For very long arrays you may consider a more performant approach having O(n * log n) [...I think]. The code is very easy to understand: Sort the array and search from both ends. The only difficulty is that you need to keep track of the indexes as well, which requires to copy the whole array. 

Remember that is just for lists. So this code prepends every in the list with a space, concats it and than throws the very first character (the leading space) away using . 

Note that I need to know nothing about ASCII encoding using that approach, so supporting other chars is a no-brainer. 

First, your method violates the Single Responsibility Principle: It calculates something, and it prints it out. Such coupling makes it inflexible. It's better to return a String, and letting the caller decide what to do with it. Second, you're code is way too complicated, handling all the different cases which are very dependent on the ASCII layout. Imagine next you want to support digits as well - oh my... I would suggest to do something along the lines... 

Refactor's answer is excellent and captures most points. One thing in your code which sticks out is the overuse of . E.g. consider 

Additionally to the excellent answer from ratchet freak: Always encode data according to their meaning, don't use another type just because it seems more "convenient". E.g. variables like represent "yes/no" choices, so an appropriate type would be - even if you "get" them as numbers: 

Sometimes they are hard to avoid, as in your example. I would consider it bad practice only in cases where the exception is easy to avoid (e.g. by testing the sign before calculating the square root). 

Additionally to the other suggestions: Write utility functions like , which could be used in several places. 

There is a serious flaw in your handling of the empty list. A user would expect that these definitions are equivalent, but they ain't: 

Now you could use a loop instead of the helper function (see TopinFrassi's solution), but I don't think there are big differences. Of course recursive code can lead to stack overflows, but this is no problem here, because Fibonacci numbers grow so fast that they reach long before that happens. If you decide to use s instead, it would be a completely different story. In that case you should use the following much faster formulas: (from $URL$ ) 

I don't think you can do anything about this. You have to cast here, and in the process you lose all information about the type parameter: The compiler can't know that if you have a , it's always a , and "thanks" to type erasure it can't check the runtime type. 

The main problem is that Scala's is just too dumb: You can't do much with it except pattern matching, there is no or method etc. The -based sorting isn't nice, but I don't know a better way. I wouldn't sweat too much about performance. Often you have to make a choice between fast and pretty, and in this context I would choose "pretty". 

Of course this might be suboptimal depending on the intended use, but I think you get the general idea. [Update] After some meditation I came to the conclusion that I thought way too complicated. Try the following version: 

I don't really understand why you use tuples when you have already a class for doing exactly such kind of math, namely . The code could be more functional by using immutable case classes for s (but it depends on the problem if this is the right thing to do): 

Then you can use your solution for Q1 without much changes (I took the freedom to kill some parens etc): 

In my opinion should contain a , not extend one. Another possible design would be to use a single call with varargs: 

I'm trying to get a better grip on the new functional possibilities of Java 8. As an example, I took this very elegant Haskell snippet: 

The question was, which is the biggest product you can make from the digits of 1 to 9 (which is 9642*87531, BTW). It is pretty clear that one number starts with 9 and the other with 8, and that you need to append the remaining digits in descending order to one or the other number. 

I strongly recommend to have an explicit subclass for the empty list (possibly a singleton) and to prohibit null for _cdr. 

Even if this solution isn't appropriate in your setting, it's useful to know this "search from both ends" technique. Obviously this approach would be much simpler if you can assume an already sorted array. 

Do you ever change the name of a afterwards? No? Is it okay to have a without name? No? Then a correct implementation is: 

I would go with the first alternative and use . If you need this pattern more often, how about an object oriented solution: 

Could you please review the following code, and point out how I can make it cleaner, more idiomatic and easier to understand? 

However, all versions so far are in the same ballpark and won't change something substantial, because dominates the performance. [Edit 2] The algorithm really doesn't matter much, the impact is too heavy. Collection everything in a and calling doesn't help either. However, quite surprisingly my profiler tells me that this simple recursive version performs best: 

The operation would be slightly faster using instead of and . Other than that I don't see obvious problems (which doesn't mean much). I guess other data structures could help a lot (e.g. I think some vector implementation would be much faster as board representation). The biggest problem is the algorithm: You definitely want to fill the fields with the least possibilities first. So the best way would be to calculate all candidates for the open fields in the beginning, start backtracking from a field with just a few possibilities (often the choice will be unique) and update the candidates in the same row, column and square accordingly. 

Then you can write things like . Note that you don't need the getter methods, as you can write , and no setter methods, as you can write and . The isn't required any longer: . How to proceed with the refactoring would depend on your decision if you keep as it is, or if you want to go with immutable s. [Edit] Here is how I would refactor it: Run.scala: 

[Edit] I did some profiling, and my version seems slightly better, and the following version is even a little bit faster: 

You should have a look at Guava, especially at CharMatcher and Splitter. While both "manual" splitting and regexes certainly work, there is no need to make your life more complicated if there is already an easy and safe solution available. 

Avoid dealing with BigDecimals at all costs - they are slow. I changed the formula to work with "twice the number", so my is actually 2*s. Further keep the numbers in the loop small by "modding" the intermediate results, too. Finally I tried to simplify the syntax and the initial conditions for a little bit. 

After finding myself sometimes needing a map of maps, and as I couldn't find one in existing libs (like Guava), I wrote my own implementation. Do you think this version is okay? Specifically: Is it acceptable that I don't permit empty "inner" maps as content for my "outer" map, hence probably breaking the contract of ? Do I miss useful methods, are some methods superfluous? Should my class implement the interface at all, as some methods work counter-intuitive when using this abstraction? Are the names of the additional methods too subtle? 

Your version is fine. As bisserlis mentioned, guards would probably look nicer. I find the following more readable, but of course it has worse performance: 

But this pattern is brittle, and the Java runtime is pretty good in dealing with object creation these days, so if you don't write a graphic or math lib or so, you shouldn't care about. 

You should honour the "separation of concerns" principle, e.g. not printing something to the console and then returning another value. I think it is better to return the String of the longest sequence (as finding out the length is easy). I tried my best to use the new Stream API, but here it feels quite awkward (suggestions are welcome): 

The company I work for is stuck with Java 8, and the Streams implementation in Java 8 is nice but somewhat rough around the edges. Here is a helper class I cobbled together, using various snippets from the interwebs. But this worries me a bit, because I don't understand some of the magic, and don't have the time to dive deeper into it. Of course I wrote tests, but it would be still reassuring to get some feedback. 

Using varargs instead of an array for the argument makes it more flexible, e.g. better testable. In case you really want to copy the array, use , which is much faster than looping through.