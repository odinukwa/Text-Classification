instead of - that way, Python will try (the equivalent of) and only give if that is also . means "I know that these two are not equal"; means "I don't know how to compare them". 

You can check that this list comprehension will give you all the True/False results of that in that loop: 

This can be simplified a little using Python's operator chaining: . But why is this method changing , when it doesn't change or ? Make into a property, and into a static method. 

I wrote this code for an assignment. It was originally meant to be written in Maple, but got very frustrated with some of Maple's idiosyncrasies that I decided to play around with Pandas instead. This is a very trivial multi-linear regression model, which calculates variable weights using least-squares optimisation, and also allows for basic forward selection and backward elimination for model refinement (both without any form of backtracking). All suggestions welcome. 

Separation of concerns. You're mingling code to parse your data with code to process it once it is parsed. Instead, parse everything into the appropriate data structures first, and then do the processing. Use appropriate libraries and data structures. When you're doing linear algebra, that means numpy. Numpy is a dedicated, LA library that has heavily optimised routines for things like various matrix products, so you don't need to roll your own. Numpy arrays will also use quite a bit less memory than Python lists. However, what you're working with is labelled data (and some of it is labelled in two dimensions), which means the best data structure is probably a pandas dataframe - it's basically like your dict of strings to lists in , but much more optimised, and fully compatible with numpy's matrix manipulations. 

You can also eliminate that : Python allows negative indices to all builtin sequences, which are defined to count from the back. So the above line is just: 

And then adjust your conditional to either have a (and a short comment pointing to the assertion) in that branch, or omit that branch entirely. This makes it abundantly explicit to anyone reading your code that that is an 'impossible' situation, and means the invariants of this class have been broken (and that it isn't that client code has passed in bad data - for that, use a normal exception rather than an assertion). A more minor quibble is that you don't need to pass into the helper function as an arguments. You can use closures: 

You have an awful lot of excess whitespace. Use one or two blank lines between functions, and one blank line to break up different parts of each function (especially, just below the end of a loop or block). Don't put blank lines immediately between a line ending in and the start of the indented block beneath it. The while loop in uses a class attribute as a loop counter, which actually seems to cause a potential bug here: the counter persists, so on subsequent calls you will skip the loop, never append to the outer list, and it will be returned empty. If is a local variable instead, and it will work fine no matter how many calls you make. Instead of keeping a loop counter like this, and incrementing it manually, preferred Python style is to use a loop. The equivalent for loop to your current while loop would be: 

looks unneeded and possibly buggy. If the conjecture is true, you will find a pair, return it, and this will not be tested again. If you find a counter-example disproving the conjecture, then this would just do the whole search again giving you an infinite loop instead of fame and fortune. If you change it to each pair instead of returning the first one, this will repeat the full sequence indefinitely unless the very last pair tested happens to work. I would just drop it. 

The updating version really does need to do some extra stuff after it the files get closed. So it does need to be it's own context manager. But instead of writing it as a class, it's a little easier to use the stdlib to write it as a coroutine: 

nb. It would be nice if we just return like in the other cases, but the decorator considers it an error if the generator doesn't yield exactly once. As it is, this is a little bit cumbersome to use effectively - you need to open the file for input separately (the tempfile is returned empty), and then it's probably a good idea to be careful to close them in the right order. It also loses, eg, file permissions, which isn't ideal. You might want to copy the original file (and metadata) into the temp file, and then it back when you're done. 

These three classes differ only by one hard-coded string argument. I'm assuming these are going to be expanded a bit later, but even so - consider consolidating them. 

All the files you're dealing with are already context managers, including and . Delegating to them instead of reinventing the wheel, your class becomes a trivial function: 

It can be run as, eg: . Ignoring the complete lack of error handling, is there any obvious way to make this clearer, or at least more succinct? I am thinking about, eg, using s in , but is there also any way to implement in terms of a generator expression? (I'm thinking probably not without having two calls to , but I'd love to be proven wrong :-) 

You have a variable to capture the links on each iteration of the loop, and to accumulate them across all the pages you parse (which is only one at the moment anyway, but I'm assuming that could change later). Those names are quite confusing; it would be good to differentiate better - call them for the one that gathers all the links, and for the one that gets the links for just this page. Your function parses what I would call your 'main' data structure. Since that is a lot more than just email-related information, isn't the best name for it. The data structure that creates seems awkward for your data. If you think of people as 'records', and the information you capture about them to be 'fields', then it would make more sense to have it as a list of namedtuples, or or even a pandas dataframe if you're working with a lot of data. That way, your code to parse it is a little bit simpler: 

Should be docstrings - basically, make it an unassigned string literal, and put it directly inside the function definition. The first argument to is another string-as-flag. Use a bool instead, and all it . But even better, split this into two functions. The one that does it automatically could actually be a method of called , and document it as placing them randomly. The one that places them manually does belong out in the main flow of your program, since it continually does IO. This will simplify your code greatly. The second argument is called but actually expects a Grid instance. Just call it . could just be called . If you want to document its structure (which isn't a bad idea), you can do better than giving it a clunky name that only documents some of it's structure - in your docstring, do this: 

Which should be quite a lot faster than trying to do it by list comprehensions, and may use multithreading depending on how numpy is compiled. 

Although it would be good to store the maximum page in a variable. But in light of your clarification in the comments that this would normally be a loop, which only breaks once it hits a page with no interesting links, then the equivalent is to use from the stdlib: 

Note that I have modified your conditions a little, since yours seemed slightly off. The branch of your condition effectively says "if the zeroth column is "name" or the first column isn't a match, it must be a header" - I've changed it so that instead, an appropriate value in the zeroth column is a header, and a non-matching first column on is ignored. I've maintained a temporary 'headers' list, because your code is currently robust against those appearing anywhere in the file. A better way to maintain that robustness would be if you know - or, preferably, can parse from your file before now - how many variables you have data for. Then you could do away with that list and do this: 

isn't actually doing what you want. It looks like you mean , otherwise is full of single-length lists whose only item is a collection of some kind whereas it would make more sense for those collections to be in directly. You would then make a corresponding change down in so that the test there reads: 

Note that the first condition changed from testing a length to testing a position, and that the helper function works completely in-place. This makes one copy, in the outer function. You can also change it back to an in-place sort like your original code by deleting two lines, and it will make zero copies. This is probably the best a recursive insertion sort can be. 

Put a blank line below your last . Also, where are , and from? They sound like your own support modules rather than part of a third-party package, in which case the imports should go after pymongo, rather than before, per PEP 8. 

Going down, is a .. very strange name for a list. It seems to contain solutions, although you put two numbers in it each success, which seems odd; but I'll assume that that makes sense, and say call it . You don't need the number at all - the way you use it, it will always just be . The two statements could be combined, as in: 

is always a number - why are you calling it a 'name'? Also, there's no need to take it as an argument, since you never use its initial value in your function. 

Some general style suggestions; incomplete due to lack of time, but they should give you some things to think about. Upgrade to Python 3 if possible. You appear to only be using stdlib code, so this should be reasonable painless. You have a lot of java-esque naming conventions. Python style (see especially PEP 8) prefers methods and variables to be named rather than . Names of classes should be capitalised, so instead of . You have some of your methods named according to this style already - you should generally try to pick one style and stick with it; preferably follow the conventions in PEP 8 unless there's a compelling reason not to. You use strings as flags a lot - eg, 

An arguably better option is to put it up front with an explicit test, even if that means duplicating some of your logic: 

I said before that copying is potentially bad for performance (each copy takes time). And we're doing a lot of it. This line: 

To optimise this type of problem, the best way is usually to rethink your strategy. You currently generate most of the possible pairs of numbers of the appropriate length, calculate their difference, and then check if the equation satisfies your constraints. As you note, that is a massive search space. Consider the following type of strategy instead: 

This will reduce your search space, and also allow you to use ints everywhere, and not parse them into strings. 

You've passed a long list as the first argument to , and then a single string value as a second - but the way you've set it out, it could be mistaken as sending many arguments to . Better to do it this way: 

Assigning a string to something that's otherwise always a number is odd, and this value is never used anyway. Nix this line. 

Python provides extensive operator overloading capabilities. Use them. For example, could be called , which allows you to then check a condition like . You can then drop the line of the docstring about what the return value is - it is implied by using that operator. Even if you decide to leave it as a normal method, isn't the best name - it sounds like it should return some kind of index, rather than True or False. The reason for the argument to is that a Trie behaves like a Python dict - the strings that you store efficiently are keys, and each one has an associated value. So, you could call instead , and you can do things like . If that is useful to you, you should also implement appropriately. If it isn't, drop that argument. is also a strange name. It sounds like it should return some kind of metadata, but instead it prints some stuff to STDOUT. Printing from support classes like this is usually worth avoiding anyway - build the full string and return it instead, and rename it to , and then to print it you just have to . The docstring for it seems to be lying when it says "equivalent representations are randomly chosen from" - you have no randomness here, the closest thing is that you use dicts (whose order is arbitrary but consistent, not random); it says it isn't testable, but you do test it in your doctests for another method. 

Consider moving this function up to module level and passing the colours into it (or, if you really feel like it, use a class for the squares and make this a method on it; but that probably isn't overly worthwhile). 

Your problem essentially boils down to repeatedly finding the (global) maximum of some (local) values. Python for "the maximum of some values" is , and Python for "do this iteratively on this sequence of things" is a for loop (or, in this case, a list comprehension). You want the indexes of maxima, rather than the values, but takes a argument so you can do: 

For reposts, you gradually build a string message to send to someone. It would be better (and probably a little faster) to build a list of the pertinent information: 

That would mean the total number of solutions would be , and the unique solutions would be (which is slightly unfortunate, but not too bad). In the loop, comparing against is always odd, and with these changes you don't need to anymore - you can now do: 

Only reason to initialise these to 0 is to pass them into , but, as I said above, it never uses the zero values. So, you don't need this. 

If you prefer to instead ignore any surplus values, use instead of - they take the same arguments, but will just return one result instead of a list of them. 

But that gets a lot of spurious "maxima" in flat sections. So, I thought, let's coalesce equal values into their left-most index when looking at them from the right, or their left-most when looking at them from the left. from is good for that: 

That is a lovely abomination. It.. looks like you're trying to handle the page being in an arbitrary encoding, and standardise it to UTF8? If that's the case, do this: 

is discouraged in most languages, because it spreads details about what is really one logical operation across your code. The preferred Python for this is: