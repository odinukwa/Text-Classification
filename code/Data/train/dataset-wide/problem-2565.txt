While these examples are pretty far out there, consider if your Queue class were complex enough that I might want to add an extension method to it and need access to internal variables in the method to do some algorithm in a way much better than possible with the available public interface. 

Finally, I dislike the fact you are initializing these variables as function expressions (statements) and don't end them with semicolons (either add the semis or make them function declarations). I would also rename things to be more consistent and in line with my preferred naming conventions for javascript: 

This is essentially right. I have had issues with not being able to read the entire stream (many streams I have worked with only return chunks of data for whatever reason so I've learned to not trust or related functions without checking the results) in one go so I would suggest something like this: 

not caching the inner jQuery object checking the state of each dialog by checking its implementation when we already have a structure modeling it 

I can see the following problems with the above block: Redundant comment, redundant brackets, using a while loop and throwing an exception to control program flow, converting the input into an integer (you're not doing any math, so there's actually no need to convert it into an integer) and assignment with an unused variable (). I'd do something like this instead: 

Several issues with your code which is causing you issues (this won't give you the final code but it will help you get there). Firstly, never hide issues by modifying the stack recursion, and never wrap operations in . The errors are there because you are doing operations the computer does not like (and you shouldn't be doing). As an analogy, you could drive sometimes on the wrong side of the road to get places faster - but you don't because it breaks convention. Next, update your code to be more python'ish. For example: 

When the program runs, it will load the player data and location data (knowing x and y from each section definition) and start the game. Finally, it sounds like you might want a decent IDE, I'd recommend starting with the community version of PyCharm from JetBrains. Hope this helps with your design and code. Good luck! 

and changed accordingly (and remove ). Instead of and , out the smallest element I have no idea how big of an affect this will have (if any), but I think it would be faster to just splice out the smallest element rather than sort every time (again depends on size of your map). In the meantime there is no benefit to having at the end of the loop rather than right after the sort and caching the lookup into a local variable: 

Wrap the code in an IIFE (and add ) On top of other things this allows you to use a for here and not worry about messing with any conflict issues. There is no reason to name the init function that you are just passing to ; inline it. Cache the jQuery elements. Pass in global variables used to the IIFE (, , , ). has too many I'd rewrite it as after caching the element. Better still: 

Reviewing your design, you mention , however you have: - "name": "none", - "health": 100 These lend themselves to player actions and multiple players in a game. The health, for instance, where do you manage the "drink potion" and "being attacked" functionality? It seems like you need a class for the player and two methods, and - which means we also need a property for when (not real code): 

Admittedly I actually wouldn't do the last line, purely because it's not clear coding, but it demonstrates the ternary and that you can utilise functions in such a fashion. The while loop is removed, the exception is removed, and the input isn't converted. An extra line is printed explaining what happens if any other key is pressed (you should trust your users will know if they hit the right key - don't over engineer it - plus also as they have to hit [ENTER] to complete the input, they have a chance to fix it, if they do actually press something other than intended). Hope this helps, Good Luck! * code is wrong: Not wrong per-say - but a failure to express the instructions in an easy to comprehend fashion. If I cannot read your code and understand what you're trying to do - then you've wasted time writing the code (obviously there are always exceptions to the rule and there are times when a comment is necessary). 

As this same if statement is used twice (with different values) I would prefer to pull it out into a function: 

(after substituting or writing the code that I didn't provide; you can probably do better than the error message I added as well) CodeIgnitor does have built in CSRF protection (scroll to bottom), but I don't know how to use it (I've never written any significant php before and have never used this project) and the documentation is lacking (as evident by the comment in the source of that page). 

(but you probably already have a method like this in your code where these things would belong) A better question: Why do you need this property anyway? It looks like it is just holding private data for the route. Why not make it private to the route then? 

1. The tests are poorly covering the functionality (willing to bet there are significant issues in various places) and it is sorely missing even half decent documentation. 

because is the same as etc. When I run your code after making those changes, I do want to ask why you have the file "split" happening. When you perform that, (if I use the smaller example data on pastebin you linked to) I get the following structure as : 

I would narrow down your try:except to only the statement(s) which could throw the error. Having such a large chunk of code in a try:except block could result in many exceptions thrown, none of which would be caught as you're only looking for IOError. Also, for performance, you should build the statement and the data set from the loop, then throw the statement against as a single database call instead. Regarding construction, your code is just one huge blob. It's important that you refactor each operation into its own function, this saves on tracking down errors, and if you make changes in the future, your changes only affect one function. If the change is not liked by the rest of your code, it's easy to back out. Can you imagine if you made 5 or 10 changes in your program as it is right now, and then it stops working? Which change was the breaking change? How would you find out? Why did it break? etc. Also, I'm not talking just simple syntax errors, I'm also talking about logic errors or data errors. These can be hard to track down if you don't have any tests validating your code. Good luck! 

Back on topic: In my opinion, it is a bad practice to force the Javascript engine to go looking for your globals when you are not in global scope due to leaving off the window qualifier. Thus everywhere you reference without calling it (and the same goes for ) or caching it in a local variable is wrong. In the event where you run this script outside of a browser that implements you will get an exception. is slightly less of an issue because it is a reasonably safe assumption that you will not run this from a browser that doesn't supply a global namespace. For this reason I always pass the globals that I am going to use into my IIFE: 

Before I do anything else I feel compelled to clean up your spacing convert " to ' to consistantly use only one type of strings 

instead of use instead of searching the entire DOM for you should constrain it to the children of instead of use you should set the container height to the maximum height of all child elements, not just the height of the current visible one 

having them all send a sql string into a single function. That way, you separate the database functionality from the business logic of each activity. For and , three things. Personally, I don't use double underscores for functions, a single one is sufficient to advise other developers that the function is intended for private use. Secondly, the string building process, you should attempt to use list comprehension to build the strings rather than a loop, this will result in much simpler code (and no "last param won't have..."). Thirdly, both these functions are the same, and only differ in their use of a or . You should have both refer their details to another function with a parameter. Something like (not functional code, just a typed up demo for the concept): 

which is easier to work with. Anyway, hope these code suggestions help you to write better code and update the design of your code to make the solution work for all data sets. Good luck!