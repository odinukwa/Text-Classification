First, I don't know if you are open to moving away from stored procedures. I really don't see a reason for it here, as all you are doing with the stored procedure is dynamically building a query. Could you not just do this in PHP so your application logic is not split across two areas? To me, the only cases where I would want to consider stored procedures are: 

As you can see that is a lot of unnecessary complexity (and memory consumption). You should be able to build your matrix in a single pass. 

Is guaranteed to have a value at this key? Do you need to do any validation that this configuration value is set properly before completing the constructor (vs. throwing exception)? Also variable name and config name do not seem to match. Is the variable being set here a service ID or a locale setting? 

Regardless of approach here, you need to understand if at some percentage of full result set, it might be faster to retrieve full array, shuffle and slice to get the desired result vs. random row retrieval. A few other thoughts in looking at your code: 

I am not seeing great utility in separate map and reduce steps. This causes you to iterate your input options an extra time that could be considered removed if you wanted to simply consolidate all this logic into the reduce step. If the use cases are for small lists, maybe this performance isn't important and the added "clarity" of having two separate steps is acceptable. 

Why are you loading two versions of jQuery? If this is absolutely unavoidable, you should be aliasing these versions appropriately (i.e. to something other than ) so that you can write code against whichever version is pertinent to that section of code. 

The whole thing needs restructuring if you are worried about performance. First, you probably shouldn't be using an array for your haystack. Considering that you will know with certainty what you are looking for in the haystack, it should not be an array which must be iterated in \$O(n)\$ to determine presence of an item. An associative array with haystack values as keys or even a item with haystack values as properties would allow for \$O(1)\$ lookup to determine if a value is present. That might look something like this (perhaps you have more meaningful full data that to put at each key): 

Since you have cleaned things up so much, we can now start getting into the finer points and actually perform a more proper code review. My notes are with multi-line comments that are left-justified so hopefully easier to read. I am not covering doc blocks. PhishingController::sendEmail 

I think you might want to reconsider your overall interface and class design here. While I appreciate that you are trying to work with interfaces, I don't think that the interface may be the best way to do what you are wanting to do here. You should always think about the real-world aspects of what you are trying to model. Here, your question and answer classes are not really represent questions and answers at all. Rather, they seemingly are really just two different types of votes you have in your application. Why is this important? Because if you just have two different types of the same object, then you might think towards inheritance as part of your solution as opposed to interfaces which are typically used to describe two objects of different types that exhibit similar behavior. Do you notice that your implementations of the common interface methods across the two classes are almost exactly the same (with DB table you are acting against being the main difference)? This should be a red flag that perhaps this should refactored such that you don't need to re-implement all this functionality in every class that needs voting capability. There are a couple of ways you might approach refactoring this. If the questions and answers were truly meaningful objects of their own, (with question/answer text, relations between questions and answers, accepted answers, etc.) rather than just vote objects, you might consider adding a trait to provide voting functionality (including implementation) to each such class that needs this functionality. Since that is not the case here, I would suggest using a base class (possibly abstract) where you can provide common implementations for most of your methods. This functionality could be inherited by and (or similar) classes and overridden as needed for each type of vote. 

I am not sure why you are using multibyte function in your random string generation function when you are not working with a multibyte "keyspace". 

Your method seem asymmetric in it's input. Why only pass the password (again this is likely tied to the odd calling of this function from form validation)? Consider passing this method a user object and the password from input, or the username from input and password from input. So it is not getting passed some information and having to gather the rest itself. I would prefer workflow like: 

Since your code is incomplete for this class, it is hard to say if there is something else this class should be doing. To me at this point it is not really clear what this controller really does other than hold a DB connection. Perhaps you might consider implementing abstract methods here if the intent is to have inheriting classes provide implementation, though I see no signs of this from your code. 

As I mentioned earlier accumulating these session files is like accumulating attack vectors, as you increase the opportunity for someone to execute a session hijacking or session fixation attack against your application. This coupled with the fact that you open the application to using session cookies over non-secure (HTTP) connection, means it would be trivial for a packet sniffer or man in the middle to grab a session ID from a legitimate user's request and use it FOREVER. And while destroying/regenerating session id's across IP change boundaries is a reasonable security measure, it is by no means enough. That attacker could be sitting in a Starbucks along with the legitimate user using a wifi network which has the same exact IP address. A sophisticated attacker can also easily spoof their IP address. Also, keep in mind that there are some legitimate use cases where a user might change IP address during a session (a user on a mobile device for example), so while, IP address can be used as one of the triggers for session invalidation, if you use some of the other takeaways about handling session securely, you might decide that it's importance as a criteria for session invalidation might not be worth a potentially bad user experiences if you had a high number of mobile users. 

Both of these seem horribly inefficient, but I guess that is what you get if you are forced to use recursion to solve this problem. In either case you don't validate input. What if you don't get an integer value passed in the first place? Your solution doesn't handle negative integers correctly - why would this always return false? Your solution is really odd in that it unnecessarily uses recursion. If you are going to use modulus, you have no need to recurse at all. You know true or false directly after this operation and decrementing two from the number and recursing isn't going to change the outcome. It's just going to take more time until you finally get to value < 0. I might have something more like the suggested solution, but with some input validation added: 

My primary feedback is that this is very hard-coded and inflexible. I don't think you are going to want to have to change class code every time you want to make a change the end user messaging or HTML messaging format. You have several concerns you are trying to address all within this single class: 

Your method would probably be best broken up to several and similar methods. You can easily eliminate your switch statement here, and when you think about it, it doesn't make logical sense to have this sort of dynamic branching at run time, as you will always exactly only one of these methods for any given connection. You could still perhaps have a general auth method that takes authentication type parameter, but this method would then just hand off to the selected method for performing authentication. 

There are some major concerns with this approach. First, why rebuild all the DOM elements every time there is a change? Your universe of different countries, provinces, districts, etc. is static right? You could either render all DOM elements needed for the page up front (probably the simplest approach), or if you find this is too much bandwidth to download on initial page load, lazily load different options on the tree as the user's selections warrant. But in any case, once the element is added to the DOM, there really is no reason to ever overwrite the DOM element. You should then just be working with DOM manipulation (hiding and showing to filter options, setting/unsetting which options are selected at each level, etc.). Second, you have added a lot of complexity by having the entire selection tree handled in a single event handler. What you really have here is a recursion problem. The central action that is taking place when a selection is made at any level in the tree, is that all descendant nodes in the tree need to recalculate. Let's think about how we might be able to solve this problem using recursion. Finally, you really should take advantage of caching your jQuery collections, so you don't have to traverse the DOM using selectors every time the change event handler is fired. I will show an example of how this might all fit together. Note that this example assumes all DOM elements are loaded up front (and probably all but root elements are hidden). Here I am keeping it simple and just using order of elements on the page to determine tree hierarchy. You could decouple the parent-child behavior from HTML structure using data attributes, but I won't do that here for simplicity sake. Instead, I will only focus on using data attributes to relate options to their parent option within "parent" select. Let's assume simple HTML structure like this: 

This class is outputting directly to standard out on error conditions. Leave end user messaging to logic further up the call that that is better positioned to message the end user in a meaningful way. You should be concerned only about logging errors and/or throwing exceptions from this class, not with outputting to user. 

Do you need a class? A can't heal himself can he? Alternatively, you could consider a method that could take a or or any other item that can performing according to some interface) 

Now you may say that "Hey, I don't like having cases mixed in there with ." To which, I would say "Exactly! Why not group your assertions together make them more readable." 

Your custom exception seems to have a very limited use case. It really only exists to format the message string from a passed array, functionality that might rightfully live in the code where the exception is thrown not within the logic of the exception. Is this message even meaningful to caller as is? You can't tell what kind of relationship exists amongst the types provided, nor the specific ID's of the relationships that exist, so there is questionable value in preparing this specific message string vs. just a simple 'Cannot delete because this post has relations' message in the exception. You could easily provide this message in context of where the exception is thrown totally eliminating the need to override the constructor (or maybe even this class altogether). Is this class going to be used elsewhere in your application? If not, should it even exist (vs. using other exception types)? If so, are you always going to want to pass this class an array of relation types as parameter to format into message string? I actually question whether you should even be throwing an exception here at all if a relationship exists. Since you are specifically building this functionality, my guess is that you are expecting the application to handle deletion requests against posts that have relationships as part of normal operation of the application. If so, should this really be an exception or just an alternate code path that needs to be followed to handle this condition? Only if you truly never expect the application to be put into this state would it make sense to have this code throw an exception. 

Here you can leverage an index on batch_date for WHERE clause and ordering. You can also totally eliminate having multiple queries as you are getting records for the entire range of dates at once. If you wanted to go with the suggestion from other answer and aggregate information for each date with concatenated results, you could add GROUP BY and GROUP CONCAT to this query like follows: