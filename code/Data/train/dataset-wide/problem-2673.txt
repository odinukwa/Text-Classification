You can now create an upgradable attribute but have your consuming code agnostic of its base type. Then, you have scope for some other changes: 

The above isn't perfect yb any means but it seperates concerns relaevant to the current VM vs relevant to all system VMs. It makes new instances composible without a huge constructor collection by just swapping the config object, and finally if the factory is backed by an interface contract you can inject the factory directly and the consuming classes are only directly dependent on a factory NOT all the sub elements. AND that factory can be mocked, as can each config object passed in to a concrete factory to test THOSE! 

So in summary i am not saying it isn't pretty cool, I can't really fault it as is designed, but as this is a code review, traditionally defined as an evaluation I have to evaluate the actual pragmatic value. and I don't see it. you can go fluent....er than code without architecting an entire supporting structure and creating a number of dangling hard to ducky-problem solve/ducky debug classes like _is. 

ok, silly example but effectively you have a single IAttribute, consumable by anything expecting a IAttribute only it is not simple, it is a crazy amalgamation of sub attributes, which in fact could each have their own modifiers! In that example your base T in the Abstract class is not being used. it is redundant. or another example, 

Well, The GridView is an implementation, Down the line if you decide to swap the GridView for a listview or something it should have no bearing on the data. Exactly how to go about sharing the information is subjective. there is no right way. My personal preference is a super contracted approach via interfaces. e.g: 

nullable bools give me a weird twitchy feeling behind my eyeballs. If you need three states you should really wrap it in something like a Enum. EDIT: somebody already said that. oops. 

this will still show up in the inspector, you can also use [HideInInspector] where needed So with that in mind a few small changes: 

the golden rule of unit testing is never test an interface. test an implementation. I'd add a second rule personally, don't test module interaction. If you have 

The code is really well written but that is a LOT of power to give one class. It has essentially created a dependency bottleneck. Most of the advantages of factories is the ability to swap/change/update implementations without extraneous recompiling or changing. Although here you are calling the Universal Factory (which as an implementation can't be changed without recompiling every class using it) Second, you are calling the direct implementation in the call itself. this means that you are also dependent on that. You correctly asserted the correct approach is probably a DI system. Alternatively you could stick with the factory and go with something like 

As a general rule, a switch statement is a code smell. You are saying that a series of alternate steps need to be done, The only time you should use a Switch is when those steps are always the same. for example, switching on days of the week is fine. there will never be the need to add one. In your case, you might want to add additional products, so looping through a collection of actions is better. Then, in the case you need a new product option you add it to the list. e.g: (now this is a simplified pseudocode mish mash version guys, not meant to be code reviewed :P) 

The above kind of thinking would also remove some of the bad practices of magic strings and hardcoded knowledge, like the honestly baffling random "xmas2012" in the middle of a vague method called "GetList". Next up we have: 

MachineGun is next.... privatize fields as before. variablize the magic strings, either make them passable parameters or constants. (will you ALWAYS have "FirePoint" in your scene and will it always be called that?) as for unity specific, is SLOWWWWWWWWW. and a bad idea to traverse the whole tree to find something. Id made the poolManager a singleton, have it set itself on the Awake() function, 

if A fires when called correctly ...good. if B activates (regardless of who called it) ... good; if B returns an expected IC ...good. does it MATTER if A->b->c evaluates properly? 

Take linq as an example. it takes a small bit more time to get used to than a system like this which has a more Sentence.Styled.Structure but it is a nice hybrid of english and code. any time i see a fluent system with an Is or a Has, I have to wonder who the target audience is/ what is the objective your team? they understand code syntax, they don't need so much of a hand that it needs to be near english. business users to them code is code, they will be scared of a.sentence.like.this just as much as standard code. the team taking over? would you find it easy to add a feature to a system that is composed of a deeply nested structure of sub classes to enforce a sentence shape or to add an additional extension method and get 75% there? Yourself? well, having written the code base you presumably know it, often times a fluent interface is more verbose and so takes you longer, does it add enough value to yourself to warrant the additional workload? 

I like it, especially the enums. Although the Tuple evaluator is super hard to parse. Definitely think it would be better to wrap that in a interface or something which contains the relevant enum flag. besides if memory serves you can perform flag concatenation for a cleaner compare. 

Well Firstly that constructor is a bit of a worry. Anything more than 3 (at most!) arguments is normally a bad idea. Now that you have so many it would be a good idea to make yourself a : 

then in your add and insert can both use it. Why bother? Well say you want to add a setting to each and every one of them later, or you change the way you construct one e.g change out the resource file call. it should be abstracted. In the interest of saving you having a lot of messy constructors also using the Property initializer syntax might be cleaner. 

In short the prospect of setting the highlight colour should not really be dependent on the raw values, and if indeed it has to be it should be done in a safe manner. as it is there are a number of way's to break your application some accidentally while developing others while using the application by passing invalid data. 

This is just a primer, allows the separation of rule creation from the actual parsing code. Does allow the extensibility of making smaller rules that you could combine to make aggregate rules etc... Finally it means you can make rules sets by instantiating different rule managers depending on situations. 

Also have a think about your viemodels goals. It is effectively providing data to the view and allowing a select, right? In the interest of only exposing the abilities I want i prefer to make an interface for my ViewModel 

Sure, it may not be that relevant in this case but it is good practice to take anything that can change...out, such as your prefabs. Next up. magic strings are scary. again, knowing unity and what you are doing means its not a big deal but again...it is better practice to avoid doing it all together. finally Repetition leads to more places to change and is messy in general remove the little bits of code repetition where you can, the component decoration and composition unity does can look a little bit hard on the eyes when stacked. so move some of that into helper methods where appropriate as for unity SPECIFIC things, the way to avoid the distasteful pattern of publicly allowing access to fields is: 

TL;DR when approaching designing a fluent interface I would err on the side of simplicity, having more tailored and specific functions like 

and whats cool if you find yourself doing the same few configurations all the time you can instantiate multiple reporters super quickly. 

There is one problem you may face with that code, I did a lot of input work with XNA and you may find that getting the "down" keys is not actually what you want. it is not the same thing as the pressed keys, that will fire constantly as you hold the key, triggering a new event each time.E.g if you press a to open a chat dialog and a again to close it, just pressing the button once may trigger like 6 actual presses and flicker the popup. For getting the PRESSED buttons you would actually need to store the prior state of the gamepad and assert if it was not pressed last frame e.g 

Encapsulates the basic functionality of a transaction and now in specific cases you can do something like: 

Firstly, should not be in this code, in-fact calling the Create function on the QuestRepository should compose a quest and hand it the timestamp. it should not be the job of the quest to decide when he is created, what if you are trying to test that? how can you hand it a testable time? Even worse is which is a magic function that goes somewhere using a utility and does something. Your entity should be an entity. a data transfer object, if you have commands to perform on it, then leave that job to classes that use the quest, like say, the handler. Singletons used in this way will only cause you problems. Lastly we come full circle: More Separation of Concerns! 

If I ask you what this class does and your answer contains a string of ands,... it is doing too much. In this case I see about 4-5 tasks. Try looking at the SOLID principles and giving another go and dividing up your units of work. 

and have compile time addition of the notifyProperties. Although if you do want more manual control that is fine too. Also, Xaml grows fast. Try to remove any extraneous properties. Do you NEED names for each row/column? P.s Also a pet peeve of mine, HUGE METHODS, especially switch case. I try to avoid them as much as possible. If i have to use them as a golden rule I only ever have one line after the actual Case so: 

Don't forget, code you wrote 6 months ago is indistinguishable from strangers code. If you saw this code and had never seen it before you would think it is clear and makes sense? to be polite that method is mostly gibberish. You are trying to define relevance in your story entities, I get it, but a hard coded nest of grouping ids is scary to read and very easy to mess up. you are basically talking about a rule engine, Given a name and a gamestate, find the right StoryEntities. A level down from that is, if the current gamestate and name match a certain condition, filter the returned Entities. then you are, based on conditions grouping those entities by relevance. you method is doing a search, a filtering and a conditional grouping, these are different tasks and need to at least be method separate, certainly not be all on one or two lines. what if you decide to swap return order? 

equally as bad as the resource load line above, take both. make yourself some extension methods ro a helper class or something. For the non unity-ers you may be wondering why so extreme for one line, well, because once you create a gameObject in unity there is a 90% chance you will add or get a component. making an easier method to create a configured gameObject in a well phrased single function is a good idea. as for error checking...... you are able to call "" and if you didn't call , the list would be null and throw an exception, lazy load your list. 

Well it seems to me you have a key and a chunk of code that returns a colour based on some boolean check. I would probably suggest a Function collection. e.g 

and had a number of calculation classes that implement it such as or or something (*cough better named) you could create a modifier Enumeration just like before with a small factory method with simple functions that just add the appropriate classes to the Modifier Collection then on calculation order by weight and apply. a snapshot of it might look like: 

You know, code wise there is not really much to do. The other comments covered the few ways to improve things. I would though suggest a look at your goals architecturally. Aside from the semantically different meaning of an upgradable vs downgradable attribute both being under the same umbrella being a problem, in theory I don't see why an upgradable attribute is a subset of attribute. In theory any location you want to use an attribute it should also be swappable by an modified attribute right? Also Upgrading and Downgrading are two specific use cases.at some stage you may want to freeze an attributes values, or make a combined attribute or have a modifier only available if a condition is met. All of that would require some level of a redesign. If you instead looked at an attribute as a base component: 

then in this script you basically say , no searching, no problem, everything that needs pooling can access it. Rapid fire seems fine, although unnecessary comments are....unnecessary. code should speak for itself, if it doesn't..rename it. Comments are reserved to complex things that cannot be distilled further or domain specific logic like explaining maths functions in code etc, RapidFire....rapidFires? huh, who knew :P as for unity specific, you never put a constraint or a check to ensure that the gameObjects in the Bullets pool have a bullet script. yet in fireBullet you make that assumption...code could break. ESPECIALLY if you are loading from a resource and not managing the scripts additions personally.... 

Is that not a little easier to understand? Hopefully as an added bonus seeing how little the differences are in creating multiple pools, you might want to even go so far as to make a pool manager that takes in a custom struct of the data and manage tonnes of pools e.g: 

In short, when architecting things, try to distill to the lowest base type and establish what consuming code really needs to know, absolute minimum, to avail of it's functionality. Any additional functionality can always be passed in through constructor arguments or public properties on an implementation. 

Okay...so later on you have some more to do, swap em again? not only does this litter the code but it is something easy to forget to change it. Next, you have to make the task asyncronous...oops. no joy, people keep switching the flag on you! Any properties like this should be constructor based. In fact my personal favourite solution is to package such things either in an entirely different class or to at least pass in a parameterCollection so in short something like: 

And you can do that across the board. Any where a method overload is super hard to read, encapsulate it in an object that makes sense. 

Here be dragons :P This is a conceptual minefield. I have done this exact thing and can relate, you instinctively want to test a lifecycle. a start-to-finish stub implementation..... but don't. 

now with this base object you can write the rest of your code doing calculations based on your skills value. As for the modifying, well nothing else needs to know if a Skill is modified to use it. To handle that I would make a ModifiedSkill agnostic from everything else: 

This same separation of concerns can now be applied directly to the modifiers. Picture adding a conditional modifier, that only applies if the player has certain buffs or attributes, such as 

in your method, a small thing, you have a Player entity called session, that is a confusing standard, why not just call it player? a bigger issue is the switch statement. firstly there is a lot of duplication. you are rewriting the same return statements repeatedly. in future have a look at switch case fall through, though in this case I would say switch case is the wrong thing to use. a switch implies a finite state of cases. usually internal states, that is why they are usually used with enums. enums likewise are a finite state, I would caution against using them for anything likely to change. Fine for days of the week, bad for types of entities. A better example of solving that problem might be something like a chain of responsibility , something like 

having a public set exposed the possibility of the View completely changing the Observable collection or setting it null. should that ever happen? Also using ICommand instead of calling methods directly is the MVVM way, you can then bind it directly to things like buttons