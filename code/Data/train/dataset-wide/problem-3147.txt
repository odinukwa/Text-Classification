It's not idiomatic, and definitely not good style. C++ has evolved along the years, and C++11 brought along a swath of new facilities that good C++ style should now use: they help cut down the number of bugs. Let's start from the bottom up, with : 

Let's now move on to more interesting stuff. Dynamic Memory Allocation For production code, using or is forbidden1. You should be using , , or one of the many Standard Library containers. Since you do not appear to be familiar with , I advise you to add them to your reading list and will use naked pointers for the rest of this answer. 1 Unless you are an experienced developer, and no other language facility or library allows you to write this code, and your colleagues have extensively reviewed your code. Initialize your values Whenever you build a , you have to explicitly remember to initialize the member to and the member to , lest they have garbage values. Instead, use automatic initialization and constructors: 

Clearly lay out requirements Code answers a requirement. It may be clear in your head, but it is not clear to us. It may be clear now, but it will not be months from now. Therefore, before coding, you need to define requirements, and then use these requirements to inform your choices. In this case, there are two sets of requirements: 

Note: in C++17, where throws can actually be tested with the trait, which can be used to SFINAE those methods or with a . This is an exercise left to the reader ^^. 

13. Beware typeless interfaces. The US format for dates is MM/DD/YYYY, the ISO format is YYYY/MM/DD. When you present a constructor , it's very easy for a client to accidentally pass the arguments in the wrong order. In this sense, is a step up, since Americans cannot accidentally use their weird format, however it's still possible to accidentally use ISO instead of DD/MM/YYYY as you intend. There are 2 possibilities out of there: 

You intend to create a copy with twice the capacity, but instead modify the and leave empty. It should be: 

Your remove method does not provide the Strong Exception Guarantee, if the assignment of throws you are in trouble. It's also slightly weird that it does not mirror (which does not let one specify the index). I would simplify it: 

This pollutes the current namespace with all symbols. If new symbols are introduced, they might clash with existing ones, silently switch the methods being called, ... it's better to be explicit, really. 

If you can easily obtain both streams in sorted order, it would probably wins hands down. If you have to prepare a dataset (sorting it), then it is still advantageous for very large datasets (that barely fit in memory). If both datasets easily fit in memory and one is not sorted, then use another solution (pull the smaller one in a hash-map and look-up into it while iterating over the larger one). 

1. Header Names I recommend using for purely C++ header files, and reserving to C-compatible header files. 2. Header Guards As mentioned, you should rather than . If you really wish to use the error prone header guards; then I recommend following the Boost convention for naming: which helps prevent clashes in header guard names. It's significantly more work, of course... 3. Namespace By defining symbols in the global namespace, you open your code up to conflicts with C libraries, or other uncouth C++ libraries. Instead, decide on a namespace, generally the project name, and wrap any single item you define in this namespace. 4. Use , and pick an underlying type. Any new should really be , which introduces a scope for the enumerators rather than injecting them in the surrounding scope. Since you are no longer polluting the surrounding namespace, you can without fear pull out at namespace level, making it easier for people to name the type. I also encourage you to pick a type. By default the compiler will use , which is... 3 bytes too wide in your case. You can easily use instead, it is large enough. Also, you might as well dispense with pointless abbreviations. This gives: 

For simplicity's sake, I will only demonstrate operations at the head of the list; the tail is symmetric. 

So, when used on a stream, it does an operation on said stream and returns it (to allow further chaining). Specifically, is equivalent to: 

The design is sound. Despite what naysayers may express, there are a few overwhelming advantages that your solution based on venerable and C-variadics arguments has over and C++ variadics: 

So, not only should you generally avoid , is a mouthful. Just write to get an end-of-line character and be done with it. Thus, we rewrite : 

The outer loop we cannot do anything about, but what of the insertion? In your code, the insertion is done by: 

Where makes sure that the data is not buffered in the process but fully sent to the Operating System (it does not guarantee that the data is on disk, sent over the network, or anything else). There is very little reason to call in general: 

We place at the end of the array, then have it "bubble down" (as in the bubble sort algorithm) using swaps until it's in place and we've shifted all the elements after it one step to the right. The same can be done, but bubbling the element to be removed up, with : 

I will not lie, exception safety can be hard in vectors. Inserting a range of elements in the middle of the vector is a nightmare when the move constructor/move assignment operator may throw. 

That is, the value is bubbling up toward the front until it finds its spot. This is suboptimal in terms of comparisons: the optimal algorithm to find the position to insert is using a binary search rather than a linear search, for O(log N) complexity rather than O(N) one. In terms of number of moves, well, you may have to move all elements, so it could only be improved by a constant factor anyway. Standing on the shoulders of giants, we can improve the code by separating the search and the move, and use pre-existing algorithms to do so: 

Note that by default a does not allocate memory for the previous and next nodes. That's because the previous and next fields are supposed to refer to existing nodes, not new ones! Moving on: we need to be able to set the previous/next fields! We do so by passing around: 

It would also be more resilient to consider the edge case of starting at 0. It would also make sense to either have a parameter (specifying by how much to resize), or change its name to (resize could be either way, but this is only ever growing). 

A galloping search to locate the two powers of 2 between which logk(N) would be if N was a power of 2. A binary search between the last smaller power of 2 and its successor to locate the exact exponent. 

In the case of /, this may occur only in the destructor of . In this case, the element to be destroyed is no longer visible (the size is reduced before), and in the garbage zone. Interestingly, this means that even if or throw, they have already succeeded. This is an edge case of the Strong Exception Guarantee, the "transaction" is committed but an error is still signaled. You could conceivably swallow the exception here, however I would let it bubble up because the user decided to throw so they must have a good reason for it. 

If you wish to add or remove elements at a specific index, it is easy enough to add dedicated methods. However, adding an element at a specified index whilst still offering the Strong Exception Guarantee is inefficient without further guarantees: it requires making a full copy each time in the worst case. You can special case adding/removing from the last position, but still... ... it is much easier to place as a requirement to the Strong Exception Guarantee that the swap method of offer the No Exception Guarantee. It is generally an easy guarantee to provide, so this should not cause your users much trouble. This is the assumption I will take here. 

It is interesting to discuss what happens in the case throws an exception when adding or removing an element. In the case of /, this may occur either: 

Note: ideally, a variant or would be the most expressive return, in a pinch just mimicks your current interface, and if not including boost matters, just returning an empty on failure should work just fine... also then you lose the distinction between empty and failure. Note: the type-freak in me would like to point out that using a different type for a raw buffer and the validated buffer would not be amiss either; a simple wrapper containing a for a result would help here. It would ensure that business logic supposed to be executed on a validated file cannot accidentally take a raw one instead.