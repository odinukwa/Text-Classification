You print out "Start" to the standard output. This basically restrict any usage of this class to have access to a console. What if it is used in a GUI application? What if this is used in a server application? Also, "Start" what? Whoever read the console will have no clue what is started? The object is constructed as a static field, and Java did not guarantee when these static constructor are run (they only guarantee it is run before the class methods is run, so it is basically you have a console print that is shown in non-deterministic time. This is not great too. 

Coupling seems to be yet another repeating issue in your code - it limits the reusability. Your code made a lot of assumptions on how it is going to be used. For example: You seems to believe that's the code will only be executed in a context where you do have a Console? What if you don't? Like when it is ported to become a service, or a GUI application? Environment.Exit() is another. Why don't you let your caller to choose what to do when the file is invalid/not found? The path is yet another. What if it is used in another environment without that particular path? The general principle is as follow. The less policy you put in your code, the more reusable it would be. Of course, more effort on the caller side to specify them. For a utility class like this, it would worth the effort to make it reusable. 

. Acts as a public interface for parts of the page that doesn't open any popups, but need to know how popup affects the page. Like footer, which is to be stuck to the bottom of the page. Responsible for: 

. It coordinates things regarding window event. On receiving the event, it notifies (if in mode (2)), then (calls 's and 's method). . Updates page wrapper's extents. . It "listens" for other two "events". It calls its method when showing popup, after images has been loaded. And after textarea resize. method notifies if in mode (2), or updates popup position (, , properties) if in mode (1). . In mode (2) popup updates vertical position on receiving the event. Horizontal position is handled automatically, since wrapper is basically a table. 

Popup is simply put on top of the page. If it fits the viewport, it has (fixed position relative to the viewport), if not, (fixed position relative to the pge). With the latter being its drawback. Ability to scroll the page while popup is shown (with popup, that is) doesn't look good. Improved implementation. Page is enclosed in a wrapper. When popup is shown, wrapper shrinks to fit the viewport and its content (the page) is positioned (relative to the wrapper) in a way that it seems like nothing happened (page retains its visual appearance). But as a result, viewport scrollbars disappear. On top of that popup is put. In a wrapper, that fits the viewport. If popup doesn't fit the viewport, wrapper's scrollbars appear. 

Congratulations to the completion of your substantial project. It is really smart and brave for you to ask for feedback. I am going to tell you what is not so perfect about your code, after all, that's the whole point, right? But don't be discouraged, for you have done a decent job! Let's begin with the high level algorithm: The first thing I would like to point out is the usage on memory, in various places you make deep copies of all the cells. This is pretty convenient to do, but it also take up a lot of space. For the unique/elim/subset functions, you can simply return a flag if the board is changed, and save a copy in the solve function. It might be difficult to remove the deepcopy in the guess function, and that's probably fine, as you might be making a lot of changes. Try save some space, you should notice a performance change. Then let's talk about the code: The checkpuzzle function and the backgroundcheckpuzzle is almost identical, why don't you just parameterize it just like you did in unique? A lot of the code have the structure of going through each of the row/column/squares. It looks like a lot of duplication to me. What if you abstract them into a concept called block, and just iterate through all blocks? Last, and probably least, you made a few typos, 'recieve', 'posslibles' 'indicies', and I highly doubt the word 'possibles', although Wikipedia say it is a plural of an adjective. 

Builder Method Names It's probably a matter of taste, but and the other two overloaded calls looks a bit redundant. It would look better as , wouldn't it? Constants It's very nice that the three fields are final, but method performs calculations on each invocation of the method (plus if is called!), to produce the same result repetitively. There should be a field, calculated in the constructor (I wouldn't recommend to use lazy patterns here). contains(Object) What will happen if it was called with arg? A . Since the is caught, I'd vote to add the NullPointer there also. However, there is an alternative for the block in this case: 

Put constant parts inside the pattern, leave formatters only for variables, e.g. . Args in are usually used for variables. Use a to build. 

Separate Model from Rendering The class contains at least two semantically distinct groups of fields: 

The code is OK, it looks quite readable, but still some things may be cleaned a bit. Encapsulation Members are public by default, so some of them should be hidden, since they do not seem (and do not need) to be used from outside: , . Don't Use Mutable Collections Scala favors immutability and using things from should be justified. There is a simple way here to bypass the mutability by concatenation of two maps: 

may now return directly Java API We are now in the era of , so I'd recommend to avoid by all means. Just forget that the old objects exist, they are evil! 

manager Manager handles 2 keys: 1. Escape. Closes the popup. 2. Enter. Closes the popup, unless popup decides to handle the key. has method. It's used to prevent manager from handling Enter key press. For instance, consider popup with a list of items with corresponding delete buttons. User tabs to delete button and presses Enter. Item is supposed to be deleted in this case, but manager should not close the popup. popup Popup is shown by creating instance of subclass (or class itself in simple cases). In constructor class notifies about the former being created. In response to which hides scrollbars if in mode (2), stores a reference to , and passes some info to it: 

. Responsible for hiding page's scrollbars. Is not created in mode (1). . Basically an abstract class, that is to be inherited to make use of. Popups are shown by instantiating subclass. It has the following components: 

I'm developing a site where I need to display popups. For now they're a popup with basket contents and a popup to display item's photos. But I might need more down the road. I've come with a class hierarchy, but I wonder if there're any better ways to split the code into classes. It might make sense to mention, that one of the design goals was to keep things from moving unnecessarily. For instance, when popup is shown, page behind it must not change. You close the popup, you get to where you were. That might be obvious, but it took more effort than it might seem to be needed at first sight. And let me make it clear, the code was only tested in Chrome. I've prepared a test page, where you can get a basic idea of what I'm talking about, experiment with the popups. You can use textareas to change popup's extents. The extents are retained across page reloads. Also, you can leave comments in the PR I created. And apparently, you can inspect the code here. Now then, let me introduce you to the thing a bit. There are two modes the popups can operate in (basically, two implementations): 

It looks very ugly and should be extracted. It will be a bit difficult to implement it by using a hierarchy similar to the Panes, because of chained method calls. But this can also be done by implementing a single builder for all your Panes, where there will be a way to set the type of the pane to build. After all these refactorings, you'll see that the total number of lines of code will be reduced at least by half. 

I totally agree with Vogel612's observations. Since there is a lot of code for this review, I'd like to add a couple of items. DatabaseAdapter Class In method, there are three issues, two of them are quite serious: 

The Consumer The nested try-catch blocks look weird and useless. Since and throw exceptions, they may be caught in the outer catch block. 

Bug or Feature? is created with a , which makes the pane almost identical with . However, the aim of is to receive only 'Yes' or 'No' from the user and the text input field will disturb its user. How could it appear there? It looks like there was some copy-pasting! Duplicate Code Many, many items are present in more than one class: most of constants, and and objects initialization. Since they are common for the three classes, they may be easily extracted into something like . The constants will be moved there directly. instances may be created with its dedicated method: 

Naming and Initialization It's very hard to read when many variables are initialized on a single line. naming pattern is also confusing. Since they correspond to coordinates, why not name them like this? 

footer Footer is to be stuck to the bottom of the page. That is done by setting for everything but footer: . If there's little to no content on the page, 's "moves" the footer to the bottom of the page. In mode (2), when popup is shown, footer can't just take viewport's client height (), since it might have changed when showing popup (scrollbar might got hidden). So, it asks , which in its turn asks about client height viewport had before popup was shown. Another issue you might encounter with footer in mode (2) reveals itself when you scroll down to the bottom of the page, open popup, then enlarge window vertically. Footer is supposed to follow page's bottom edge. And in this case, the abovementioned formula doesn't work. You've got to add for it to work as just described. Also, after having closed the popup, you have to set according to the first formula (without ). In mode (1), you don't add to when popup is shown. In this case the formula takes the following form: . Additionally, consider a page having . When popup is shown, it might cross right boundary, if not taken care of. In this case, you generally want to increase page's : . Manager class 

. Semitransparent layer that fits the viewport, and on top of which popup is displayed. . In mode (2) it's the block that fits the viewport, and it's the wrapper's scrollbars that appear if popup doesn't fit the viewport. In mode (1) it has no presence on the page, just appends popup to the body. . Title plus close button at the top of the popup. . Block with buttons at the bottom of the popup. 

I think that the approach of the question lacks only a better usage of the API of . Using the old seems very ugly nowadays, when we have , where all the stuff like file separators is supported much better. 

The principle is: when the first element is found that contains the specified , it redirects to the overloaded function with this element; otherwise it does nothing. Please note that the equality is checked with , which is equivalent to Java's . The same kind of changes can also be done with function, but it doesn't seem to be used throughout the code. The function is not necessary at all. It looks like a sort of Java's residue; already has public access and the reference is immutable. Generally, I'm not sure about the validity of the choice to use and the exposed for field in class. This sort of mutability is somewhat against Scala's principles, but I don't see yet how to work it around. 

If you want to avoid the creation of the on each call of method, one of solutions would be as follows. Change class to implement interface. This will allow to put its instances into a block. The created inside the original method will become constants in the changed class and they will be closed inside the method when the routine exits from the block (normally or with an exception): 

Beans Bean objects like and contain private fields that use property wrappers from package. This creates a tight coupling with the package for such simple data structures, without any particular need and adds unnecessary complexity. They should be replaced with basic types ( -> , -> etc).