doesn't seem to serve any purpose at all. It just mirrors and is a potential source of bugs. Why should subclasses be able to access the setters of and ? I think they should be private. 

Is this supposed to be a fluent method which modifies and returns it? That would be the obvious reason for having this signature, but it isn't what the method actually does. Better javadoc required. 

Negative-index Fibonacci numbers are perfectly well defined, so this error message is misleading. You could change the error message to something like , but you might as well change the code to support them. It's just a case of negating and using initial matrix . 

Again, Java naming convention is that (a) camel-case should be used ( instead of ); (b) Boolean-valued properties should generally have names beginning ( instead of ). In this case reads quite naturally in context (e.g. ). 

You're making the backup directly available in your web root. For temporary files you should normally use . NB I'm assuming that is not directly mapped to a : if it is visible, that's even worse. 

It's a shame that you have to use such a complicated mechanism because the language doesn't support strong enough type constraints. Given the limitations of the language, this looks like an elegant solution. 

This is just wrong. The specification calls for you to find the most common minor axis (presumably with some margin of error, although that's not stunningly clear) and to take just the points which correspond to that minor axis as the points on the ellipse. The details are a bit tricky. You're casting to when producing the output of the parameters, so do you assume that all minor axes should be integers? If so, that makes the grouping relatively easy. Otherwise the easiest implementation would be to add a parameter , sort the values of and scan to find the value of which has most points in the range . Then if that cluster has points, you take the points in the cluster, average their parameters to get the values for , and add their values to . 

Yakym's proposed code change was buggy (although it's now fixed), but the point about avoiding creating new lists is a good one. An alternative way of fixing Yakym's code which takes into account the goal of avoiding list creation and is further adapted to correspond to my point about using indices as arguments to is 

I don't see why it's desirable to populate the pool here. In addition to VisualMelon's observations, by populating the pool before reaching the end you lose the guarantee not to play the same track twice. 

This should be unreachable, so why not throw an exception to alert you to the fact that if it's reached you have a bug? 

Why call ? I can think of very few situations in which an exe should take its own name as a command-line argument. 

Beyond that, you need to look at different algorithms. The binary quadratic form doesn't seem to be a common one in prime sieving. You could see how it compares with Sundaram's sieve (BQF ) or failing that, if you're working with large enough ranges, Atkin-Bernstein (e.g. a combination of , , , , and for different totients of 60). 

Both of those approaches are extension methods which operate on an . Why does the final code not do the same? In addition, you state that MoreLINQ doesn't meet your requirements because it requires loading all the results into memory, but the code you posted also requires loading all the results into memory. On the other hand, selects a single element rather than a configurable number of them. I'm left with a strong feeling that the overall design is completely wrong, and I'm not sure you've accurately explained your requirements. On the basis of the requirements stated, I think you should be looking to implement the method signature 

You're using the same password for the database login and the contents. You shouldn't reuse passwords, because it increases the risk of leakage. AES has two parameters: the key and the initialisation vector (IV). Even when you use the same key, you should really be using a different IV to avoid correlation. (E.g. the same @Type value encrypted under the same key with the same IV will be the same; if you use a different IV, you can avoid an attacker being able to match them up). It would be better to get a random IV (using a secure RNG) and store that in another column. You're using AES to conceal the password. With very few exceptions, you should hash passwords rather than encrypt them. The standard recommendation is to use bcrypt. 

is better still, because you can use it to find power sets of any set. 3. Generics remove the necessity to do most casts 

That's an important check, but not a sufficient one. If I pass then and will be the same set, but it's not a valid permutation. 

Yes-ish. The main loop takes into account collinear points: it wouldn't be too hard to do so here as well. 

This will work, but it launches all of the downloads simultaneously. You'll probably find (and I speak from experience here) that you get better performance by running no more than simultanous downloads for some value of between and . Writing a method which uses to launch a new task when one completes is a good exercise in / programming. Note that the has to be lazy for it to actually work as intended. 

What's wrong with an empty array? Typically a collection has a no-args constructor which initialises it to empty. 

Look at how much work you're doing per message. If you reuse the client, you save setup and teardown time on every message after the first one. If you reuse the client then you'll need to handle errors and be prepared to close it, open a new one, and continue where you left off; so there is a speed-complexity trade-off. 

Similarly, the use of namespaces is inconsistent. Most of the vectors are , but there's the odd floating about. Not that is the clearest way of doing things. It would increase readability (and maybe even performance) to define a struct for the intervals. It would also reduce the potential for confusion of the name : when comparing two vectors by length I generally expect the code to look at the length of the vectors, not the difference between their first two values. 

You should never iterate through a map's and look up the keys inside the loop. Use . That's even more important with , which doesn't even have average-case constant time lookup. So 

depends on three things: , , and . Therefore it's not necessary to cache more than one row at a time. With that insight you should be able to refactor it to not need at all. I actually prefer to solve this problem by going down rather than up. That is to say, I define my intermediate result as . Then the double-array of can be processed in order using a simple loop, as opposed to in reverse using a slightly more complicated loop. 

You should always ask what the corner cases are. What would you expect to return? Your code is buggy. You have but isn't assigned anywhere. If you changed it to as suggested in comments, it would still be buggy: would return . 

The is hard-coded to . It would be nice to make this configurable, preferably via an enum rather than raw strings, in particular because using opens up the possibility of optimising the images to use transparency on areas which don't change. (And on the subject of exposing nice types rather than cryptic raw data, Java 8 provides Duration, which is nicer than raw centiseconds). 

I think we've found the reason for the slowness. If you find yourself reaching for permutations in a coding challenge you've probably missed an opportunity to decompose the problem. It's often useful to think about small values of the parameters first. 

There's one trick which you can use to get a reduction in memory usage which is very worthwhile if the strings are long. returns a new object but wrapping the same underlying as the original. So your code: 

Your implementation (with bugs fixed as per the other answer) is very efficient for small Hamming distances, but the cost scales as the Hamming distance. To make it more efficient you should make it independent of the Hamming distance by parallelising it. I'm not sure how best to adjust this for JavaScript's weird type system: are you assuming that the input values are 32-bit integers or 52-bit integers? For 32-bit integers the given code can be directly ported: