I will try to add to the already existing answers. I think that if you are up to coming to CR you won't badmouth PEP-8. If you do not know what it is, read it. Imports should be on separated lines. Two empty lines before a function declaration (one if it is inside a class). 

Major Overall, it seems good. I would not check for a base case as your code can deal with empty strings. It adds complexity and clutter. Additionally, 

Before asking that ask if there is any need to improve the efficiency and shorten it. Readability nowadays adds much more value than performance tweaks. Writing code that your peers don't understand is a much bigger problem than doing inefficient loops. 

to improve code readability and make your intentions clearer. Lastly, makes your intention slightly less clear than . In Python striving for English-like semantics whenever performance isn't critical is considered a common practice. 

Good, this way when the user sees 0x001 in the screen he/she e-mails you asking what the error is and then you either tell them how to edit the file or read it for them. Short Python programs usually are "doable" without even a single global variable. Try it. Someone above suggested classes. Don't go that way. Python classes are slow and fat and you just want to roll a dice, it is not really necessary to have classes here. Last but not least, try to name functions with verbs or verbal phrases. It makes more sense to than . 

Good. But this should be production code, removing debugging code (not just by commenting out). Any serious development (you called this a program) should be done under VCS, in such environments you just delete code, don't comment it out. 

is repeated for each closing option. This violates the Don't Repeat Yourself principle strongly. Encapsulating it into a function would be a great idea. The same goes to the opening values, they are always handled the same way, why not check if the input is one of them and give that the same treatment. You would only simplify code and ease future maintenance this way. Be aware that I am not really a fan of switches anywhere, except for enumerated types. But my advice is unbiased, as far as I feel it. You'd be better without a switch here, in my opinion. Minor You have a comment. It is quite pointless but it is too small to be an issue. Lastly, it seems that the inline comment before the loop is misaligned. It would be nice to fix that. Algorithm-wise Your algorithm only fails on the end. So if I start with and follow it by repeated a million times it will take a reasonable amount of time to terminate even though the string cannot possibly be valid. 

Short answer Use a state machine. Longer answer I haven't read your code in detail, but I already worked with the Java's non-blocking sockets. So I can say it's pretty difficult to get it right. I once inherited a codebase that was similar to your code. My task was to write unit tests, in order to be close to 100% branches coverage. I tried to write tests without touching the code, but there are so much states to track (the selector, the buffers, the socket's state) that I was not able to reliably test the code. So, I re-wrote the code, using a state-machine to encapsulate these states. I ended up with 7 small classes, each one representing the state of the sockets, or the state of the request processing. The resulting code was more robust (many missing edge-cases became obvious), easier to understand and to maintain. Writing the tests was easier, then. If I had to do it again, I'd try to use Netty (as Ihor suggested). Netty encapsulates the states too, and manages the connection errors in a more unified way. 

And then you can use to find the content of the groups. There is still one thing missing : the fact that the numbering of the original pattern is lost. For that, you can parse the original pattern string to extract those numbers, to create a mapping table. When you convert your pattern string into a Pattern, be careful to escape the substrings between the using . I don't know if this solution would be an improvement of yours, but it's an alternative to consider. Edit The implementation of my solution : 

The biggest subset is (3 4 5 8), and its size is 4. Complexity The sorts can be done with O(n log n) The creation of the third array is O(n²) To find the subset, I think we can do that with O(n²) (I'm not sure about that) So, the whole thing should be O(n²). The algorithm for finding the ascending subsets is not trivial. I'm sure it will be fun to implement ! 

You can replace by For the rest of the code, it would help if you explain the algorithm you are implementing, or if you name it (if it's a known hash algorithm)