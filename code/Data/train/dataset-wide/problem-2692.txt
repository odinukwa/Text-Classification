With that in mind, I didn't read your code too carefully but just looked for the obvious problem sites. For example I see this bit of code: 

First you check if you're inside the node, then you repeat the same check for each of the children, this is a lot of branching. Unnecessary branching. Assume for a second that the root contains the point (check this only once for each point) then one of the children must contain the point. The distinction is instead of asking: 

You claim that your is faster than I do not believe this claim. Please post your benchmark code. often has Small String Optimisation to avoid dynamic memory allocation when used on small strings which is fairly common. Your code is not const correct. For example: 

Which is much easier to write than your code, it's thread safe and fixes the issues with allowing to be instantiated. The properties of magic statics guarantee that will be initialised exactly once the first time the function body is entered by any thread, even in the presence of multiple threads that might otherwise cause a data-race. The instance will be deconstructed when your function returns (in the static destruction stage) which makes the whole thing unnecessary. 

This results in a rounding error on each channel. Also this forces the compiler to perform two divisions per channel, as it cannot combine the divisions due to truncation rules of integer types. For example: 

This converts your putput vector from "A vector of pointers to fixed size dynamic elements" (note the oxymoron, fixed size dynamic elements, there's your problem) to "A vector of fixed size elements". Not only will you be avoiding lots and lots of memory allocations but you will also improve your cache performance by miles because your entire output vector is now contiguous and cache friendly. Then change: 

In addition to the two excellent answers you have already received I would like to point out another way of simplifying : 

The time complexity of is linear in the number of elements. As the test progresses you'll end up with at least quadratic time. You need to swap your s for something with a quicker . I would suggest which has amortized constant time in look-up. 

The keyword is usually a sign of bad inheritance (Liskov's substitution principle) and I do not recommend to use that. Beside that, I do not understand that data structure of your stock information. Why not something like this? 

I also prefer a verb in my method names (they should have, actally, but in that case I think it's okayish), that's why I use 'with' as prefix; And I explicitly do not use not 'set' as prefix, to distinguish it from the setter of the User type. If you do it like that, the 'actual building' of the user is within the builder and not in the User - and the User type is kept quite stupid. It might seem a bit strange, that the 'build' method doesn't actually build, but non-persistent built types are often only used for unit testing. The sweet part about builders, you can expand them to persist your built types or other fancy requirements. 

In general, I really don't like the naming "two", in "two first picked cards" and "third", in "third picked card". But since it's the essential of the game, I'm very fine with that. Code Flow Always try to tell the summary of the story in one method. What I've seen in is, that the main flow will be "moved" to subroutines: When you are in , the main flow moves to : This method now checks, if the user has won and deposits/withdraws money. This is bad, because you have - or at least I have - a hard time to understand what the method does "in general", because I have jump around methods. The less code you need, to tell the reader what the method/type does, the faster one can understand. So I'd move the "win" check and the withdrawing to the start method. code duplication The printing of the cards can be simplified. The pattern is "Card " + cardNumber, so maybe add a to the method. SRP The validation in the : This belongs to the "domain logic". If you switch the , this validation will be duplicated and has to be pulled out. Exception handling In the constructor for instance, you throw an exception and catch it directly. That's not how it's supposed be done. First of all, you just print the exception, but the game flow continues. The caller of the method does not know, if somethings wrong. In general, what I would suggest, you validate the before you instantiate the Player. If there's still a wrong value passed, you throw a RuntimeException "upwards". If that happens, you introduced a bug somewhere, and the game itself is not runnable anyway. Other 

and you would have all the private members from your class as globals in the file. This is the exactly the same thing as what you're doing. You're abusing a as a . While I do not condone this particular design for the problem at hand, the namespace approach would have placed you a bit higher up in the pile of applicants, because at least you're not abusing object orientation and I can accept the namespace approach as a convenient design decision. Had you instead properly used the singleton pattern where it is suitable, like this: 

TaskQueue I'm not particularly fond of the name . I would prefer it semantically inverted and called . Also it looks like is never set from inside of the queue and you could use for it and avoid a bunch of locking when you query the queue. It seems you already handle it changing dynamically and mid processing. This: 

White spaces are free, use them Your code is hard to read as all operators are cramped together. Avoid branches A missed branch prediction can force your CPU to discard all speculative execution it has done. Although modern CPU's are pretty good at branch prediction, it's a good practice to avoid branches when possible. And in your case it will reduce iterations in the loop. 

Use of white space You have a lot of randomly added line breaks, this makes your code difficult to read because I have to scroll a lot. Please keep your code tidy. Don't do unnecessary work For example in your destructor you do this: 

This is usable in a constant (TMP) context thanks to the qualifier and At -O2 the call will be expanded to a constant. 

Time complexity Let's have a look at the time complexity of your algorithm. The bound is: \$N<2\cdot 10^6\$ and we want to compute: \$\left(\sum_{i=1}^N i^i\right)\mod(10^{10})\$. Naively computing \$i^i\$ like you are doing will require \$\mathcal{O}(i)\$ operations. Computing the sum \$\sum_{i=1}^N i^i\$ will cost you \$\sum_{i=1}^N \mathcal{O}(i) = \mathcal{O}(N^2)\$ operations. Or in other words you're looking at the order of \$N^2 = 10^{12}\$ iterations of your inner loop. Or if every iteration of your inner loop take 10 ns (i.e. about 10 clock cycles on a 1GHz CPU), you're looking at \$10\cdot 10^{-9}\cdot 10^{12}=10^4\$ (\$10\$ cycles, \$10^{-9}\$ seconds per cycle) seconds which is about 3 hours. However by using Exponentiation by Squaring you can reduce the time to calculate \$i^i\$ from \$\mathcal{O}(i)\$ to roughly \$\mathcal{O}(\log_2(i))\$ meaning that your expected complexity to calculate the sum: \$\sum_{i=1}^N i^i\$ is \$\mathcal{O}(N\log_2(N))\$. For \$N=10^6\$ you're looking at about \$2\cdot 10^7\$ iterations (\$\log_2(10^6)\approx 20\$) which should take our hypothetical computer about \$2\cdot 10^7\cdot 10\cdot 10^{-9}=0.2\$ seconds to compute. So to fix your performance you need to use a better exponential computation, there are plenty of examples on the web. Your code Now to look at your loop: 

My understanding from a builder is a bit different. In my opinition, the User should not have a dependency to the Builder (you have a bidirectional dependency which is usually bad anyway). With that said, use the User as member variable within your builder: 

basemoveRate is never used again. Beside that, it should be a constant: private static final BASE_MOVE_RATE = 10.0; 

Liar. The setup() method does the cleanup. At least the cleanup of the agents. agentGoals() Use try-with-resource block. 

We have an app with few entities, which are passed through a workflow. The entities have different workflow states. The main issue is, that the change from one state to another often leads to other executions, such as updating other records or sending emails. The actual code is a bit of a mess right now, very long methods with lots of if elses. I'm trying to implement some sort of an entity state machine with the main goal, to reduce the code mess. The code does not respect assertions, such as null checks, exceptions, etc. I'd like some advice, if I'm heading in the right direction, if there's some simpler methods, if I will have some sort of problems with this solution - or any advice in general. Well, if you see something that annoys you, I'd like to hear that, too =) I like the most about this code, that we can isolate necessary code for switching from a specific state to another specific state, as in . But I'm still not really convinced. The 'assignment' of the posted code would be "If I finish a Task, the task is persisted and a mail has been sent to the user". 

I really like the small test methods. But without seeing the actual implementation, it is very hard to tell, if a test case makes sense or does what it should do. Small improvements: 

The is a plain static Factory which actually creates 's and 's which use 's and 's - pretty straight forward. You can call it overkill. I call it super sexy! :P Hope this helps... 

Represent 2D matrix with one vector Conventional wisdom is that 2D and 3D (or nD for the matter) volumes should be linearised to 1D arrays by computing a 1D index from nD coordinates. I.e. replace: 

This efficiently make the solution's partial value your lower bound. The lower and upper bounds should as tightly as possible bound the best achievable value in that branch. Taking the partial value in the branch this far, grossly underestimates the lower bound. Making your search space larger. Remember, your search space grows with your bounds. You set the lower bound here (similarly for the left case): 

In the code below you must realise that is a variable that is shared between the threads. Which means that it requires synchronization, as you have omitted this synchornisation you will have undefined behaviour (incorrect result most likely). 

Your principal algorithm is a correctly implemented BSP, so yes. You are creating a Binary Space Partitioning tree. Also, FWIW: You only need two points on opposing corners to define an axis aligned rectangle which you seem to be using here. So you could simplify. Edit: Just noticed your question about connectivity: Just checking the immediate parent will give you a subset of the possible connection information. Since your BSP is axis aligned and 2 dimensional each node can have 1 to 4 neighboring nodes (depending on if it's positioned along the edges or not) or 0 for the root but lets ignore the root because it's not interesting. If you're interested in the full connectivity you can either traverse the tree top down and keep track of all edges and in that way find which rooms are neighboring. Or you can keep track of north,west,east,south neighbor of a node during tree generation and use this information to determine connectivity. If you only look at the immediate parent, you only get one connecting node (out of possibly 4). I do not know how you intend to use this connectivity information so this may be enough for you. 

In addition to the other answers: Be more direct towards the user The template parameter is not very explanatory, pieces of what? In your case I can deduce it to be number of that should back the array. As a user I don't care how many s are backing the array, in fact it's also a portability issue as an int can be anything from 16 bits and up. So to be sure I can get the number of bits I need, I need to figure out how big an is on my platform. All I really care about is: 

Not writing a test case is a huge part. Because, as a software developer, I say, that test code is as valuable and as important as production code. The other stuff can mean, that you're very inexperienced, never worked with other people on a project, or never did a code review. And you do not know the basics of the SDK. Other tips: 

I think it's too much to ask, to point everything out or give more or less exact statements about what you may need to refactor to what and why, since with some reading about the presentation patterns, you should come up with your own pattern decisions which you then will implement. I think that needs a few iterations ;-) (Check Passive View, MVP, MVVM/Presentation Model, that's the most common used, imo, or check for open source projects). Comments 99% percent of your comments are obsolete. First, they explain what the code is doing - don't comment what you are doing. They will lie one day, for instances the comment. One day it will be 30, or dynamic, or whatever. If you comment, comment why you are doing something. But in general, even that is often not necessary. In enterprise applications, it's usual because of "business illogic" / absurd requirements. Naming Try to be as clear as possible when it comes to naming. For instance, in , you declare g, d and dt, I see from the constructor, what those are. But when I have for instance a bug to fix and I know it's in , I read the following line: . I have only a clue about what dt, g and d would be. If you'd name it better, it could read which is much more clear. Also be consistent. In the name of the parameter is , which will be assigned to . So you have three different names for the same thing which makes it much harder to read. double precision I recommend to use instead of doubles, because of the preciscion problem, I think that could be a problem in the future. See wiki's "Floating Point" page, why I mention that. direction / position You might want to wrap direction and position into vectors. The main benefit would be, that you have a lot less parameters to pass and set, and it's usually quite clear, what a Vector is. Also not really sure if the calculation of the positions should be within the Projectile, since those are very common calculations - you might want to calculate those in a separate "MyMaths" type, or even in a Vector itself, maybe. The "maybe 3d in the future" problem should then be easier to implement (I have to admit, I suck at maths, so not quite sure if that would really help) Other