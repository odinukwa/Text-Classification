Again, that’s odd… why do you explicitly cast the value to a different type before giving it to the constructor? I would expect 

The four nested loops seem awkward and a lot of text for what it does. But, hiding that would not be easy without sacrificing precious speed. To make it faster: First, sort the vector of available terms. This way, once your sum exceeds you can quit and not try the rest of the terms at that level of the loop! Instead of looking up all four terms and summing them in the very center of the inner loop, keep track of partial progress. 

In the constructor, use the initialization list, not assignment in the body! You are letting default initialize, and then changing it with the assignment. 

Another thought — if you want to avoid accidentally providing names that the derived class will inherit and step on something, you can make the accessor a free function template instead of a member function. But what about the static counter itself? It still has a name. Is there a way to put that outside but still distinct for each instantiation? There is indeed an easy way to do that. Make a variable template! 

Re-declarations The code inside the loop contains variable declarations for variables declared outside the loop: 

Specify context I support Blindman67's answer. If arrow functions were not supported by all browsers used (e.g. IE - but then again there is little support for Angular in IE anyway) then you could also utilize Function.bind(): 

There is no need to add an extra anonymous function just to call that method. Bind the method directly, like below: 

For the most part I would say Yes. It caches DOM references in variables, though those could be stored in constants: 

Event delegate An event delegate could be used instead of adding a click handler to each button element. That way additional elements could be added without needing to add event listeners to each one- this becomes especially advantageous if elements are added and removed from the DOM throughout the event lifecycle of the page (otherwise memory issues could result if event listeners aren't removed from elements after they are removed from the DOM). 

This identical line is present in many of the functions. Take a look via Compiler Explorer or your debug asm window: the generates a lot of code. Contrast that to the main path you want inlined, which is a simple deref and assignment. So, make a separate member, and make it not-inline. Call that from the inlined functions. Also can use compiler-specific features to mark the test as expected vs unexpected. (Microsoft's distribution of the GSL includes a macro for cross-platform) 

You put a lot of work into writing the iterator from scratch. Use Boost.Iterator to do most of the work for you, instead. This can be a façade around the pointer type, and you change only the category (to bidirectional) and write simple and functions, and how to unbox the data from the node. All the various members and variations will be done for you automatically. 

I agree with everything in Guy Incognito's answer. I also see another possible improvement: DocumentFragment One possible optimization is adding the child elements to a DocumentFragment to avoid reflows after each element is added. 

And could also be used when setting up the Google Map instance, since presumably that is the same element used for the map. Using parseInt() without a radix If you are going to use parseInt(), it is wise to specify the radix using the second parameter - unless you are using a unique number system like hexidecimal, octal, etc. then specify 10 for decimal numbers. 

And in order for the closure to reference of the component properly in the interval callback, it can be bound using Function.bind()- use that when calling : 

Scope of Variables Unless is used outside of the code in your post (which would be grounds for making it off-topic), then you should declare it as local to the function using (or if you want it to have block scope. The same is true for and . That way those variables won't be global, which could cause confusion if you did use to declare a variable inside a function but not before that. For more information on that topic, see the section Keep your scopes close and your scope even closer on this page. Accessing DOM elements multiple times via DOM lookups are slow. It is wise to cache them once in a variable and then refer to the variable when needed. This is also mentioned in the aforementioned article under the section Cache DOM Lookups Those lookups could be added above the function (possibly assigned in a DOM ready function like jQuery's , though it is argued that isn't necessary with modern browsers): 

In fact, since you are just using iterators to look through the input, you can use the new and support and low-level string literals with the same function without having to convert. In the above line, you should be using . 

Let me be the first to say: Don't say You use of specific numbers in the array sizes gets my attention. Then, 

What is , ? That is not C++. Your top function uses exceptions for normal flow control, and is completely unnecessary. 

A pre-allocated fixed capacity can be achieved by using an underlying collection with that behavior. 

The trouble is that I had to cram the range checking in there before doing the allocation. But, writing a separate function is general purpose and reusable! 

(not ) and now the default will serve its purpose. Meanwhile, exception specifications have gone away! But, with an empty param list will continue to be accepted as a synonym for for a few years. That is for ease in upgrading the compiler in old codebases, not for writing new code. Your base class already declares a function for . You probably mean to override this, and maybe you are. Maybe you’re not, if the signature is not exactly the same! That is an insidious bug to have, so be glad that we now have the keyword which makes your intention clear. If you botch the signature, the compiler will tell you that it doesn’t match. 

Feedback Your code is really solid. It makes great use of async functions, arrow functions, transitions, etc. Suggestions The only things I could think of that could be changed are: 

After reading over the code snippets you included, it looks pretty simple. The only concern I have is that if the switch statement reaches the default case, then is called , and then just after the switch statement, is called... If a status is sent, then it doesn't seem appropriate to send the response data (even though wouldn't be assigned in the default case. One other improvement I see is that the response could be made consistent by moving that into a function and calling it in the two places where a response is sent. So in the example below, that is defined as the function inside the callback to , or that could be moved outside the callback and would then likely need to accept the response object as a parameter. 

I’m making a “counting iterator” which emulates a constant container of consecutive values of some integral type. It is mostly boilerplate, going through the list of requirements for different iterator types and making sure all the functions are there to be a bidirectional random-access iterator. That is why all the functions have explicit return types declared even though they are trivial — to make sure it matches what the docs state. Everything is because they are only simple integer operations. If someone instantiates it with a bignum class, that will not necessarily be right, but I don’t expect that at a use case. I’ll just document it as not supporting exceptions in the simple arithmetic primitives, and IAC never tested for weird classes. 

That might be how you are used to doing things in other languages, and it works as you expect for values. But that’s not the normal way to use the container. On the other hand, pre-allocating it like that makes it simpler to do without the hand-written loop: 

One could reduce the redundancy a bit (and adhere to the Don't Repeat Yourself principle). The only real difference in the two arrays is the value at key . That change can be pulled out into a conditional block. That way if more data needs to change (e.g. add more data to the sent array), it only needs to be added in one spot instead of multiple. 

The styles have good separation - e.g. header, footer, etc. The selectors also make good use of ids and class names, where appropriate. Also, the media queries make the layout responsive, which is great. 

With this approach, there is no need to keep track of counter variables (e.g. , ), use those to index into the array, nor increment those until certain conditions change. It also makes the following line superfluous (so it can be removed): 

Here you are assuming you know how many elements there are, and repeating the "magic number" rather than at least using a named constant. But, to zero out a primitive C-style array you don't write a legacy loop anyway. Use 

I don’t think this is what you are looking for, though, since you want to prevent other code from manipulating the counter. So make the template variable a class. Actually, the template variable is just a shortcut for a static data member of a template, and now it moves inside a class like you are used to: 

Hmm, that’s not an assignment operator at all. It assigns a common value to all elements. Just use . 

since that is what the program is for, essentially, I don't see what's wrong with making that a virtual function. Note that you can define them in different CPP files so the header doesn't need to know about the details of processing. But this is just a toy example, and I know from my own work that we do indeed get different things we want to do and isolate the different systems from each other. So, as your original question indicated, you want to use the Visitor pattern. Let’s start with how you want to use it, then go back and make it work. As explained before, you define your "overloaded" function for each type you want to handle. The details of what you want to do go in the function bodies, not shown. Each body gets the parameter of the correct type. 

Which would come before the HTML content... is that just left in for debugging purposes? It would be advisable not to echo content before the start of the HTML content. 

In that code Array.indexOf() is used but one could also use Array.contains() though it isn't supported by as many (mostly older) browsers (e.g. IE). Then to get the equivalent of ucwords(), a solution like from this answer can be used: 

While it only saves about 2 keystrokes, it is essentially like removing an clause from an statement. Variable declaration The declaration of the timer variable is within the true block of the statement. While hoisting allows the variable to exist throughout the function, "it is recommended to always declare variables at the top of their scope"2 and then assign the value later (e.g.. 

Don’t make this a , since it can be implemented using only the public functions. Write it outside of the class, making it a template function. 

Make this a non-member free function. It can be written without any private knowledge of the class. In fact, it is so simple to write that I wonder why it needs to be specific to this list class at all, rather than working with any kind of collection or range! 

Calling on every element to copy the results — Copy the elements in the order in which they appear in the row, and use an iterator to place them efficiently. 

First of all, why are you passing them by value? Do you really need to copy them into the function? I don’t think so. Since you use that type a few times, make a handy name for it.