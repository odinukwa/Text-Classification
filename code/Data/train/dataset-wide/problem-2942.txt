Personally I would wrap this up in a class where the user never sees a object. Code Re-Use You have repeated chunks of code that do the same things. 

This is a well know problem: Open up one of Knuths book (I hope you have the set lying around). Anyway a string is a set of char. char only has 256 values (assuming 8 bits). So you set up an array of 256 counters (set to zero). Then you just start counting how many of each letter there is. The first element that exceeds 1 means you have duplicates: 

Both of these allocators will finish in the blink of an eye. You want a test that last a couple of seconds to get real information. You are not running the constructor. 

Prefer to use the standard library which does all that memory management for you. It does it correctly no matter what people do in the code so it is hard to break. 

The visitor pattern and open closed principle. There is a mild conflict here. The visitor pattern is very good when you have a static class hierarchy and just want different ways to traverse the nodes in some collection. In these situations the visitor pattern behaves very well. BUT If the class hierarchy is not stable and you are adding new types of nodes then it does not behave very well. This is because every new class that you add to the hierarchy will require a new method in the visitor object (unless you want to default them using some template method to handle the new nodes). Design Not sure I agree with your design at all. This is what a standard visitor pattern looks like. 

You can get the same expressive power with functions. Also functions are part of the language so are more strictly checked for correctness. 

But in the general case where the return value can be any type. This is not an exception safe method. This is why in standard containers simply removes the top item, and there is another method for getting a copy of the top element. You may want to copy this pattern to be consistent with standard types. Don't use 

Mixing operator >> and getline() makes the code hard to read. Either use all operator >> or use getline() to get a line at a time then parse the line internally. Note:: operator>> will ignore the '\n' at the end of the line and work. So if your file is a list of words one per line there is no need to use getline(). If on the other hand your file is a lot of text and you only want the first word on each line then you need to use getline(). Method 1: Use operator>> 

WOW that's a lot of code to implement Dijkstra (is my first thought). Maybe you want to use C++? Prefer not to include header files in header files unless you need to. 

Again the pop_back() has the inefficiency of forcing a check that is not needed. Also causes branch predication problems. 

A bad comment is worse than no comment. This is because you need to maintain the comment to make sure it stays the same as the code while it is being updated. Significant time can be wasted when code is updates and a comment is not (thus confusing a subsequent maintainer). Comments should be reserved for WHAT you are trying to do. The code should be self documenting and describe HOW. If the algorithm you are using is particularly difficult or you need to document WHY you used a particular technique then those are also good comments. Please avoid prefix underscore 

Its probably not doing any harm here. But its a bad habit. The difference between and is that also flushes the buffer. Manually forcing a buffer flush is usually incorrect. The buffers will auto flush at the optimal time. Program inserted flushing is usually wrong and is a major cause of eniffciency in C++ code. I would refactor the inner loop like this: 

If things are turned on/off by Debug it should be done inside the file. As a user of the file I should not need to remember that I conditionally include it. Don't put variables inside conditional blocks. You put the values that can be defined in the platform specific part but the variable declaration then use the definitions you use. and you should always put a check for untested platforms so that when it is ported it is easy to find the places that need to be ported. 

Expanding on comments: I would reverse the splitting. I would split the writable memory across the threads so each thread wrote to a unique section of memory (it would be good if this were divided by page size as it may help performance). We will call the section of memory that a thread writes to a page. Then each thread will loop over all the primes and remove them from the page associated with the thread. Using the original code as a starting point it would look like this: 

Don't use underscore as a prefix. In most situations this is a reserved identifier. Defiantly never use double underscore in an identifier. This is reserved in all situations. 

Are you really returning an integer from the function? By your use case above you assign the result to a double. But if you return an int you will truncate the value. ie. you will get 2 rather than 2.5 etc. Here you assign to double. So I suspect you want to actually return a double. 

If returns then we add 1 to it and now it is no longer and your next test will always work. Even if it is not supposed too. Are you sure the second test id correct? 

That's absolutely ridiculous. The code is now already not maintainable. Immediately throw away that script and solve the main problem. Why is your header file so complicated. 

This is wrong in every language. You attempt to read and see if it worked. EOF is not set till you try and read past the EOF. The last succesful read will read up to (but not past the eof). So the next read will fail, but is still false. 

Exposing them tightly binds your object to anything that uses them. As far as I can tell the only thing that will ever need it to know the maze position is a Maze. Thus you should Make 'Maze' a friend of 'MazePosition' and remove the getters (if you are going to tightly bind stuff together make the number of bindings as small as possible. As pointed out elsewhere: you only need to use if you have unvalidated input and are using it to index the array. Your code is using validated input (as you are looping from start to end), unfortunately you make the mistake of using capacity() rather than size() which is why it was throwing. 

With the whole rule of 3/5 they sort of logically group together for construction (with the swap method). Getters are horrible things that break encapsulation. 

If there are multiple threads that could enter this function then between the signal from the producer thread and this thread waking up from the wait another thread could have stolen the object. Thus you need to recheck the state you were waiting for and go back to sleep if it was stolen. This would have been fixed by the MutexLocker above. But the code as it stands leaves the lock locked. 

So this page is 200K bytes long. I don't think its a good idea to load the whole page into memory then parse the page. 

Prefer nullptr In C++11 we introduced to replace . This is because is the integer zero and can accidentally be converted to an integer type without any warning. on the other hand has a type of and can only be converted to pointer types (not integers). Design. When building linked lists I prefer to use a object. This removes the need for checking for in your list and thus makes the code easier to write and understand. There are a lot of C++ code reviews on linked lists where I explain the principle. Node should be private You declare publicly. There is no reason for people to know the implementation details of your linked list. Make this a private member of so show that this is an implementation detail. Prefer to use initializer list: 

Also declare variables as close to the point of first use as you can there is no point in declaring them all at the top. This has a couple of advantages. 1) You can see the type. 2) There constructors are not called if you never get to the point of declaration. 3) It makes the code more logical and less cluttered (PO). Prefer look back Not sure I like your look forward approach. 

All your functions can be written much more succinctly and easier to read if you follow those rules. 

But in the long run makes your code more brittle and harder to update. Pass things as parameters to make it easier to maintain and extend your code (or create an object that wraps the information). Also it looks like some of these properties would be better held in arrays rather than individual variables. Edit base on comments: This only detects a collision if the top right corner hits a wall.