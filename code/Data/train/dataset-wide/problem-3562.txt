Prolexic is a Denial of Service (DoS) mitigation service that I've had pleasant experience with but it isn't low cost. Otherwise, it's going to be circumstantial. Without huge pipes, expensive networking equipment, and strong technical knowledge these situations are difficult to deal with. Some ISPs are more helpful than others. 

If your server is able to access DNS via the Internet and is properly configured, it should automatically. The blackhole servers are registered in the DNS directory for the RFC1918 address revisions, which eliminates the DNS timeout as they should not resolve. Being as that you are receiving a NXDOMAIN result, it leads me to believe things are operating as expected. Edit It looks like you have a PTR (reverse) zone for the subnet specified on your DNS. Remove the zone and it will go to the root. 

Let me start with giving you the details of my setup: I am running Fedora 13 on an x86_64 arch. I have mounted a remote directory using sshfs: 

does not show the group information. I know how to do this using a script which lists all groups and subsequently lists all the packages per group and greps the package of interest out of it. I'd like to know if it is possible to do this an easier way using an existing tool. 

Seeing that root cannot access the remotemount directory is rather odd. Is this expected behavior? If so, why? If not, any lead on how to go about fixing it will be helpful. Thanks. 

You could store the database on a RAM disk, such as . This could potentially risk the data, depending on the implementation, so you would need to design to compensate for this. One potential solution would be to have a readonly slave replicating to a RAM disk and the data there could be disposable. MySQL Clustering (NDB engine) is designed to store data in memory. However, MySQL clustering is best suited for small datasets accessed with simple queries. A favorite solution is memcached these days but this requires application architecture to support the technology. This is a fairly big question. High Performance MySQL is a fantastic book that covers high level MySQL implementations. 

In Fedora 13 distribution, how can one find what an install group a package belongs to? As an example, I would like to know what install group the package inkscape belongs to. Using: 

As I understand IPv6 fragmentation, the routers do not perform fragmentation, only the end-to-end nodes do. And when any router along the path receives a packet larger than the MTU of the link to its next hop, it'll discard it and reply to the source IP with an ICMPv6 "Packet too big". Following is what I observe in my setup: Initially after my local ethernet link is up, I visit an HTTP page with a request that causes a large (1965 bytes) packet to be sent out. My router replies with ICMPv6 saying the packet's too big and my MTU is 1492 (that of the ADSL ATM link). My machine then splits the TCP packet into two each smaller ones (1492 and 545 bytes) and tries again (instead of adding extension headers to IPv6 for fragmentation which is what I expected should happen). So far so good. What puzzles me is that from then on, the router no longer sends back "Packet too big" responses despite some outgoing packets being larger than 2K (e.g. 2399 bytes) in size and everything seems to be fine (ie no retransmission using smaller packets). Any idea what's happening here? I'm on Linux 3.14.23 and my router's Tomato based. I don't have packet monitoring on my router at the moment. 

You shouldn't ever be restarting a database to terminate a query. In MySQL, you can view the running queries with and terminate the process with . You could write a script to perform this function. 

Nevertheless, if located in the United States, you will likely be subject to state and federal laws by storing the social security number and I would suggest you treat it as PCI scope data. If you are not PCI compliant, I would seek the particular laws applicable and treat it as sensitive as possible within your environment. A good idea would be to consult a lawyer. From a professional perspective, I like to treat data like this as carefully as possible. I often consider how the public would react to my actions if it were to be unintentionally disclosed and act as responsibly as possible. 

Is it acceptable to run a website which only serves on HTTPS and not HTTP. Consider situations where plain domain names are typed in address bar. Usually websites redirect the user to the HTTPS version. There is a good reason for wanting to only provide HTTPS. Consider this scenario: 

I'd like to know if there is a way to force a block device to bypass the linux buffer cache (ie direct IO) and pass the requests directly to the underlying layer. I know one can open a file using O_DIRECT flag to achieve this, but my program is not the user of the block device, a file system is. And so far, I have not had any luck telling various FSes to use direct IO. In summary, I want the raw device functionality without using raw devices (since they're deprecated in my distro, Fedora). If this is of any importance, my block device is a Network Block Device. Any help would be appreciated. 

You might consider the SUID bit. Certain programs require root privileges and use the SUID bit, such as . If sudo is the better choice for you, you could use: 

You can use mod_alias and Redirect based on directory. The linked document identifies additional details. 

For locating vulnerabilities, I tend to prefer the more classic approach by default. Bugtraq and announcement lists for the particular software. Change logs, et cetera. Scanners such as OpenVAS can be used for automated verification and testing. With verifying the scope of impact, it depends on the vulnerability. When attempting to verify scope of impact, often I seek out the initial release and any vendor specific releases for the vulnerability in question. At that point, depending upon the nature of the vulnerability, I would be able to verify by manual action or writing my own script. If full disclosure, sometimes proof of concept code is provided with the initial report. If not, I would search the Internet and common resources such as Bugtraq and Packet Storm Security. You are going to find it difficult to find professionals to walk you through exploiting a vulnerability due to the dubious nature of the request. Most vulnerabilities do not require a high level of technical skill to take advantage of. 

Here's the problem. I tried this with a file as block device (using loop) and it worked fine (at least for touching two files in each). However, after installing a complete system, putting the root in one subvolume, and the home directory in another, mounting both at boot, I got an error telling me that the underlying device was "write protected" and at first attempt to read the home directory content led to a kernel crash. I'd like to know if what I want to do (mounting a single block device more than once with different mount options) is actually allowed by btrfs or in general by the os. 

prevents iptables from resolving ips, which produces faster output. The default table is the table, which is what is used to apply basic firewall rules to the three chains. The three default chains in the table are , , and . The chains are largely self explanatory. The INPUT chain affects packets coming in, the OUTPUT chain affects locally generated packets, and finally FORWARD for any packets that route through the system. Among the targets you can specify, you can packets, meaning simply ignore and not respond. You can packets, where an icmp response would be sent to the source of the denial. Finally, you can them, which allows the packets to continue routing. Often with an external facing firewall the default choice will be as opposed to , as it reduces the visible footprint of your network on the Internet. For example, an IP that otherwise limits services to a specific host would have less visibility with . Note, means append to the end of the chain. If you wish to insert to the top, you can use . All rules are processed from the top down. for deletion. To an incoming packet coming from the :