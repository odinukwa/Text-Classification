You do this check 3 times, I have no problem with that. But what if your maxUsageCount is 0 ? I think this is an unwanted situation so better to do : 

The else counts on what if? Mine intendation clearly says the first if, will the compiler see that also like this? If I change mine intendation, the compiler shall still give the same result, but I clearly mean something else at that point. Putting braces is a small effort to do, you lose a lot more time searching a fault like that. 

Personally I wouldn't do this. The reason why is when your field change name, your test fails because the field is hardcoded there and with refactoring this isn't persisted to the test. What should I do? Normally your is in the same package as your . When this is correct you could use a protected method. Example : 

After seen this question, I had the feeling it could be better with more OO programming. So I started to create mine own way, with more OO, less code and easier to read. I was happy with mine result until I did benchmark it with your code. Result of 1000000 iterations : 

Let's talk about improvement of your code. You know even numbers are never primes. So a first step is to raise the for loop to Second, This is correct but make 1 if before you do this : The if should check if the square root of trial is lower then the prime number. If that is the case, you can abort your for loop cause no more matching results will be found. 

Opening and closing resources As last in this class is for me the absence of closing your resources. This is just a nice example to create memoryleaks. Summary You see you have good experience in programming, it's a nice and readable code with really tiny things I could point out. I hope this review could help you in one or more points. 

Or something like that. Let the method return the actionlistener, but in the creation of your actionlistener use also at least 2-3 methods. Edit : Your problem : Use instead of with your eventlistener. looks for multiple button clicks, so it will merge some events. 

Summary: While I'm no c++ coder, it looks for the rest good. If you really want to score high you could use recursion for the for-loop. 

for the same result. Naming : While you have not many var's to call => I like that you already point to the bottle. Still I'm thinking could be a better var name. While loop : Well it doesn't make a big difference but for your own sake, use a for-loop. You don't forget to substract one then. 

And change the building from hostNames to a set. You have the advantage with set that no duplicated entry's can be set. The other 3 additional methods can be refactored as well with the use of a set. Problem again : Now that (not so) great idea I can put away. The set itself is NOT and so there are questions about being thread safe. So to the creator of the class, great idea to take the in stead of a . So I'm starting all over. Solution : The is in mine opinion not necessary. However, your setting and remove a entry of the is NOT thread safe. I should use the witch is an atomic operation. The is a operation so I suggest you refactor the also to that method. 

This is just one bad piece. You catch an exception, doesn't do a thing with it and creates a new exception to be trown. First of all, try to catch the detailed exception if possible. Secondly, If you need to throw the exception back you could use : 

Also with this method you could move the method to the factory. Footnote : I did check your github and was happy to see the refactored enum. It's more logic in that way with separating the concerns. 

Welcome to Code Review. You have posted an very good quality post and that's why it takes so long to get an answer. I have 2 minor remarks to make. First : 

Scoping : In your controllers are all your services default scoped. In mine humble oppinion make them private, if you wish to have the default scope make getters and setters default scope. Why: You easily can forget the private before a global variable but getters/setters are mostly autogenerated public so normally when these are not public it's ment to be. Final's : What is looking odd is that in you don't have the marked as final as you do that in your other controllers. Error handling : 

I find this a nice piece of code. Still I found 1 minor and 1 bigger issue. Bigger issue : You say in the javadoc that if more then 1 bassin is found the biggest must be returned. You implement nice testing but this I don't find back in the testings. All your testings have 1 lowest bassin. I should add this to the test : 

All over : Nice readable code, as an outstander, who doesn't know the things the other classes need to do I still understand what this class has to do. 

When I looked first I was thinking you don't need it cause has operations. But when I read your full I see that you create a map where the key is the same as your value. Next thinking of me : Isn't that a little overkill? Why don't you just put a in your ? The isn't so then you shall need the again. Then you could refactor to this : 

So override the finalize of the class and close the connection there. This is called when the class is destroyd. I prefer the second one cause the finalize has issues that it could be that it is never called. As it seems in the comment a nice discussion on this issue :). Second : Open and close your connection before you do an action to the DB. Do a try-with-resource or close the connection in the finally block of the try-catch. Edit : added sample code. 

It's hard to say but if I get this with an interview, you will not pass. On the other hand, I'll find it good you come to here to learn. Number 1 is really red flags. Let's start with the review. 1. No with logic. I removed the comment lines to point it out. 

I was working on refactoring your code. When I was finished I saw that @tim already posted an answer. He address the most what I also wanted to point out, but in mine opinion he forget 1 thing. 

and the sample method just return piece. This saves already a lot of lines code and does the same thing as your code. Now there is 1 big issue with your and mine refactored code. An Enum should be a constant, but the sample can change. For example take this code : 

Code should be self explaining, so if you need to put comment behind a variable name to explain it, there is something wrong. Mine suggestion is : 

It's clear that this String need's to hold todays day formatted. The thing what you could improve is making the static. Like this you don't have an instantiation each time you create an instantiation of the 

Known memory leak Your code has a memory leak, not by you but by Apache. There is a tracker for it but it isn't resolved because Apache would not see it as a leak. I came upon this because I'm the OP and the server died after approximate 250 pdf's done. I rewrote the replace function to a simpler search, this means no looking in header and footer, and just returns the first Node what match the text to search : 

Public class, private Interface? I'm pretty confused by this setup. The meaning is always trying working towards the most highest object( this case interface) possible. I'm thinking that you created this setup so having the keys as constants. But there is nothing wrong to have those keys as in your class self. Java singleton. I can't repeat it enough but if you want a singleton, please think in stead of private constructor. Your singleton isn't thread safe or in this case, while if you use it is, and it's even easier to created it. Abstract class root of all evil? While I do use abstract classes, I'm always thinking also about putting the abstract methods in an interface and use that interface in the constructor. This has multiple advantages of the abstract class. First of all, you can create the base class final so no unexpected behavior could be implemented later on. Then the interface you can swap at runtime (don't forget a check on ) and your class behave different but still in the correct way. As I don't see the whole picture here I can't say it's good or not in this case. But still, think about it, see the advantages/disadvantages and make your conclusion if it's good in this case or not. 

A good usage of the final word and array but you create this array for each instantiation of the class. Better could make that field also so you have instantiated this variable once for all the different instantiations of . Final keyword in other situations 

Default values This is a part I have to say. It's educated to me so I educate further but I'm not a fan of it. 

With this implementation you could ask an id for each class. This is because the is also thread safe for some methods. Important note : Your generator will reset himself after server restart so usage for generating an id for storing in database is a bad idea. You could also just return the . It doesn't matter if you are using a lot of threads and every thread knows that instance of the . The will stay threadsafe. Footnote : Wrote in java 6, with higher java you could refactor the instantiation of the . 

Of course I don't know if there is a setter provided for the char, but it works with every setter. At this moment you change the object in the and next time you ask a sample you get the altered version. If you want to proceed this way I suggest returning a new Piece with could be the best way. The cleanest way is to change the to a more factory based system like who extends a factory that implements method. Like this you don't need to override the sample method in the enum but it can change to this : 

Execution is almost the same. But now we are sure when is changed magically the next step it will correct itself. Further, this could be refactorred a ternary operator : 

You are declaring this synchronised. So if 2 threads are calling this method, the second one has to wait until the first one is finished. Because you don't have an input variable, the output will always be the same, setting false. In this case there are no race conditions what could affect the outcome of this method, so I wouldn't make it synchronised. private static final : You are making a great use of the fields. What I'm not liking is the next step : 

The next class is the calculations itself. Because the UC is so little it stands open for interpretation like what do I have to do with all negatifs? In mine solution, an array of all negatifs shall work and spit out an array with 1 number. There is also no details to do when more subArrays are found with the same highest sum so I just return 1 of them. 

edit : This last one is wrong cause doesn't implement . Or from java 7 you can use try-with-resource When you extend and implement the you can do the following : 

Memory building up The method design isn't good Why do you need to hold all those and return it later for saving? What if your holds more then 30k entries? Note : This is real the real situation It's stacking up memory waiting to go out of memory. Change the method to or if you want to return the size for a report and save every x entries. (x could also be 1). You have the in the class who provides the save so use it. 

6.Remove commentlines with code. When you have to give code for an interview, do not let commented code standing. 7.Java Doc Write java doc for each public method. 8.Mine solution I have created 2 classes, where one is just a data class. This will show that you are aware of OO programming and you can use it. 

As I'm a more java programmer than C# but I try to answer you as good as I can. The decorater pattern should be able to decorate multiple times. Example : I must be able to decorate with cream and cherry and cream again. In your implementation you can only decorate once. Your decoration class have to implement the interface to so that your test should be : 

Why do you do it right for Connection, Statement an Resultset and don't set a modifier before all the strings? The best practice is make them all private and if you need them outside the class make an getter/setter for it. Third : 

In the javaDoc you tell exactly that the key for is and so on. This is then clear for every programmer that will use that method. You see that I cut the sorting to from that method. I prefer a new method for sorting the 2 arrays : 

Why don't you put the also in the ? It's the only place where you use this field so it could be easily in the . Comments : While I'm not the first to say you have to document your code, the following case is for me strange : 

Naming of methods, variables and classes Well, it's sample code and I hope it's because of that, but some of your naming is realy awfull. , and shall never speak to me that I know what kind of service it is. on the other hand is well chosen. The same as for names of the DAO's => cDao ... Use constants for (recurring) "magic" String's. 

I never like to see this hack. It's a infinitive loop with no possibility to stop it. Why not make it a variable and give the user a possibility to stop loop? UIOperations.java Constants 

Duplicated code You have indeed some duplicated code, sometimes just a little off. You can make abstract class for and and move the duplicated code to there. I should move to an private method of the abstract class. 

This could be better set as java doc in stead of normal comments. Like this if you generate the javadoc, people who read that will also see your comment. same or not the same 

Logging multiple languages While you do make usage of logging, you write them in sometimes in Dutch and sometimes in English. Please try to hold to 1 language, preferable English for the logging. Static or not? 

This can be done easily by creating the Node in method. With me I added the creation even in the Queue class, so I could return the exact from the Also, throw an error if some people come with because you do not shelter this type of creature. Also with returning this is mine code : 

You can do it a little more generic but I'm afraid you still have to test each. I don't know if your case is always changing to green or not. If not I suggest the following enum : 

Helper classes You have a nice helper class, all the public methods are static, what is good. There are 2 things I miss. First of all, your class should be declared as . The reason why is so nobody could extends your class and implement other behaviour. Second one is a private constructor, because no constructor means 1 public constructor with no arguments. You don't want people to make instances of your class and hold them somewhere. You are smart enough not to do so, but is your (future) colleague that also? Private static variable While it's not wrong you declare the variable like ,,... in the methods. Why not make a global Like this it's only instanciated once and you could reuse this value in multiple methods (if your class grows in the future). Summary For the rest I can't see directly any issues, but of course I'm also a human being with faults. I really should ask to that programmer who created me why he added so many faults ;) 

We all know what you are trying to do. But what happens if is magically turned 10? You have a bug that will not correct by himself. Let's say we do the following : 

Third, in this case the whole try catch you can remove cause you trows through the method the exception to higher place. Use braces for if