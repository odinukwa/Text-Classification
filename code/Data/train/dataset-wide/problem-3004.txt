Congrats of making your own sorting algorithm! Speed/Efficiency There are plenty of sorts on Wikipedia that are more efficient, if you want to take a look at them. I added rough speed (given random data) and difficulty estimates: 

Repeated calls to main can eventually overflow the stack trace (heh, stackoverflow). Try making a Boolean that keeps track of the user has inputed a correct value, and put the entire input sequence in a while loop. Why do you have an empty input? Why does the main method return ? If anything (which it shouldn't, having a name like ), it should return the translated list. gets translated to (not actual piglatin) You don't have to enter an if statement to set a Boolean variable; just set it to the thing in the if. 

By looking at documentation, I found another method that is faster at drawing many circles. I replaced last 2 lines in with: 

Output Typically it is bad practice to put a print statement inside a function, because you don't want your console flooded with text if you are calling that function a bunch of times. Instead, you can do inside your function and outside. Naming Now, I'm sure you will also get answers pertaining to variable names, but I'm not a stickler for that, plus your variables and functions seem good already. Happy coding! 

I am working with Cassandra and using datastax java driver so I have to re-use prepared statements and that's why I am caching it here. Prepared Statement and BoundStatement. Is there any better way of making my method thread safe instead of using synchronized block like that? Any other data structure which might be thread safe for these kind of operations? I am working with Java 7. 

Now in my class in the method, I am using passed from both the consumer to extract all these variables which have been set, do some processing by using those variables. And later on we will get some new variables which I am setting it by cloning the old builder. 

I am using here instead of standard because if for whatever reason, I cannot send data on a socket (let's say socket is bad or dead) then I don't want my cache to keep growing and ultimately run out of memory so that is why I am using guava cache which can start dropping records if it reaches the limit and my application will keep running. Any better way to implement what I am doing or get rid of synchronization altogether? And maybe we can create an interface for this class? 

isn't a very good name. Try making it Speaking of , it doesn't look like you need it. You only use question once. Just put it inside the call to input on the next line. Change to . That sounds more natural. The main method should be in something like this: (more pythonic) 

Based on your (vague) description of the exercise, it seems like the user should keep the number in their head until the very end, and each time the computer guesses a number the user tells the computer if the number is higher or lower. That's the exact reverse of the usual programming exercise. In that case, what you could do is: 

That is the standard for main methods, so if you, at a later date, decide to import you code from another file, the main method will not run and you can still use the translation functions. Code logic 

First of all, I personally would avoid hard-coding all the directions and if-statements to check for them. Instead, what is more efficient is to use just 2 variables, x-velocity and y-velocity. This makes collisions much easier: 

Naming You did a good job with most your variable names, but not so much with your class name. Typically, you would not want ANY class name to start with a lowercase letter. The class name is also not too descriptive (what is balanced, again?). I recommend changing to or if you don't heed the second part (don't forget to change the file name as well). Secondly, what is up with haTab? Everything else was so well named, this just seems out of place. Changing it to would be more descriptive. Permissions What I learned is that if you don't have a modifier on your functions, and no other class is using them, add . That's just standard Java. On the same line, if another class does need to access something, make it . You seem to be missing a lot of those. Constructors There is only one constructor for . That is not very helpful if you want to set the left and right children or parent at construction time, or you don't want to set a value. New code 

In the function, don't use in your call to . You've already 'd the string, so you're just wasting cycles by doing a text comparison. 

A big problem I see is that you join some tables and subqueries too early. For example, and appear to be necessary only for information and don't actually affect any calculations. Furthermore, and only depend on the . Since that's the case, instead of joining them in the inner-most subquery, join them as part of the outer query. This will shorten up the clauses. The steps I would take to write this query: 

Write a query which calculates the distance by team. The only output columns should be and . Write a query which calculates the total Member bonus by team. The only output columns should be and . Write a query which calculates the total team bonus by team. The only output columns should be and . Join the first three queries on , along with any other information tables like and . Note that all the aggregation was done in the subqueries, so this final query should not need a clause. 

(You would have to split up the ascending and descending sort options like that) One issue with that approach, though, is that in your original statement, I count four places where the statement occurs. That would mean repeating the long statement a lot. I think we can fix that, though. First off, sorting in a subquery usually doesn't make much sense. I don't see any reason to have and sorted, so let's remove those statements. Now we're left with two s: the one used in the function and the final sort. No matter what, you need to include the in the function to make sure your paging works correctly, but here's the thing: now you can use that row number to sort the final result (i.e., change the final to ). Now there's only one place where you need the dynamic clause, which is a lot better than four! Disclaimer: I haven't tested these ideas; just brainstorming. 

Are there any potential issues or any race conditions in my above code? Is there any better or efficient way to do the same thing? 

So the only difference between those two above methods is - For async case, I need to retry at all cost if acknowledgement is not received but for sync I don't need to retry at all and that's why I am storing more state in a class. is a class which receives the acknowledgement for the data that was sent to our messaging queue and then calls method below to remove the address so that we don't retry after receiving the acknowledgement. 

My question is - Do I need this at all when I already have , class? class just contains all the variables combine from both the validator class and I am using builder class just to set data in both the consumers and then use it in execute method of , and then clone the old builder to make a new builder object again by setting some new variables. Is there any better way to do this thing? Looks like I can get rid of but not sure how.