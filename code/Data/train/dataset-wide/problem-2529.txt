Sorting Your algorithm looks sane, but the interface is ... cumbersome. You have a , and declared as members of the class. Now, the rules of object orientation indicate that the data should be encapsulated. There are two logical ways to implement the sort that I can see. The one is to have a static method that takes a Stack as input, and sorts it in place (creating a temporary, and method-private auxStack to sort with). The other solution adds the sort method to the Stack class itself (and also has an internal auxStack). The second route is the better one. 

This type of question is always interesting, because I always feel there is the easiest, and the best way to do things. Easiest often relies on using native mechanisms for the work. The best, I feel, is often to use primitives and to do as few object creations as possible. Here are the two candidate solutions I can suggest for the easiest/best. The Easiest uses the method, but unlike other solutions suggested here, it is purely 'additive'. No inderting things in the middle, and no inserting extra stuff which gets deleted. It also does some input validation. 'Trimming' the value before the split is important.... The 'best' option is plain O(n) performance ( used in some solutions is not going to produce an overall O(n) solution). This suggested solution does not create all the intermediate String objects that the other solutions create, and it uses O(1) extra memory space. 

You add the result in to the mix too. Since that method produces almost certainly unique values, even if you create two 'identical' points, say, and , they will Still be different hashCodes even though they are at the exact same cartesian coordinate. Drop the 

You have tagged this question with algorithm, and I like algorithm problems. In the spirit of the original question, the solution should not be using any additional space, which means your char vector suggestion at the end is not really relevant. I would agree with your analysis, that the problem is reduced to \$O(n)\$ by storing the vowels and consonants in different vectors, and then merging them again... but that relies on an \$O(n)\$ space complexity too. I think the solution that the original problem (with no additional storage) is looking for, is a three-pointer option.... a 3-point turn, to make a bad pun. Consider the following algorithm, which contains three pointers. Each pointer advances sequentially from the beginning to the end of the char array. There is a 'rotate' operation that makes a temp copy of the last char in an array slice, it then shifts all previous chars forward one, and then inserts what was the last char, at the front. The three pointers consitute an \$O(n)\$ sequence through the data, and the rotate is another \$O(n)\$ operation, but worst-case is n/2, and the worst case will reduce significantly as the pointers advance, and the gap tightens up.... Technically, though, the time complexity combined worst case is \$O(n^2)\$ though. So, in pseudocode: 

The above will work because regex will favour matching the full before it starts on the . If you want to make it explicit (and I would, for the record), you can force a zero-width word-break anchor () in there, and write the pattern as: 

in the above system, the first thread to 'set' the cached value will have it's instance used by every other thread. It is possible that multiple threads may be initializing their values at the same time, but they will all defer back to the winning-thread instance if they don't win. Once the instance is set, all threads will use that instance and there will be only fast atomic locking. 

Those variable names.... ouch. and make it hard to separate from the and too.... and they mean nothing otherwise. Why not use meaningful names like and ? Then, when I ran the code, I got a lot of funny results.... like: 

Note, taking the pointer at the initialization of the and brings those in to pointer-space as well. You are missing a bunch of documentation on the exported methods, types and constants ;-) All told, I would expect your program to look like: 

The concurrency looks complete to me in the sense that I cannot see any places it can fail, or block significantly. The static and make sense. The itself is technically correct in the sense that it returns the right results, without logic problems. There is no need for the double-check locking though. It saves nothing, and solves nothing, other than creating two separate lock points. Additionally, methods should not return concrete-types when interface-types would be available. Your method (and Future should be of type and not Your code pulls the from the , and locks on that. There are only two places where you use (one in the , the other in the ). Neither of them need a sub-lock of the , they can both operate on the itself. Your code would be simpler, and slightly faster, as simply: 

XML based configuration structures often tend to change during the development-cycle of the product. It is good to plan ahead, but you should also expect to run in to something that needs a format change. First though, the structure you have for your XML appears clean, and good. The presentation you have is good and neat. That makes it nice to review. There are some suggestions I have that will help you though. 

In addition to handling the exceptions from invalid input numbers, you should also handle requests to/from invalid bases as well (like negative or bases > 10). 

In other words, you will have int values filled with either 0's or 1's... and no variations. Also, if the "step" for the nano-second clock happens to be an even number, it is possible that the low-order bit for your computer will always be the same value.... and all your seeds will be identical. While the class in Java may be slower than you want, you can at least use it to seed the faster ISAAC algorithm. I would simply use the following to seed your class: 

For any robust application I recommend using an uncaught-exception handler. This handler should log the uncaught exception to a logical place, and it should (or some other exit code). This may complicate things with threads that do not trap their exceptions, but that is bad pracitce as well.... See the documentation for the uncaught exception handler, and some tutorials. 

build an interface of the add/take methods on your queue called build a tight-loop putter-thread, and a tight-loop taker thread. They look like: 

That will set a buffer that can read all, or big chunks of the file. If you do it that way, you can also remove the code path for files that are smaller than the buffer, they become irrelevant. Byte[] method: This method is horrible overkill. Since you have to return all the bytes anyway, you may as well just allocate a single large buffer for the file size, populate it, and return it. 

Note, I would normally recommend the Map should be a HashMap, but, read the next section... Class Choices and bugs Your class choice of Hashtable is wrong, it should be HashMap. This will lead to Iterator instead of Enumeration as well. Also, you are making big assumptions about since you use it as the key to the table/map. This is a problem because the keys need to be immutable. I would recommend using an instead. Conclusion... There are a lot of things which can be done differently. The code has a lot of work to do still