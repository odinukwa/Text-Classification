Brief summary: The vanilla GoF visitor is great for altering items within a tree of elements, but when the visitor visits an element it can only change the children of that element not the element itself. For example, a visitor altering the DOM of a webpage could search for everything that contains an image and replace it with an ascii art version of that image. However, s can contains images, s can contain images, paragraphs () can contain images. When the visitor is visiting the node for tag itself it cannot change the type of the image node, though you could change the content of the image node - this is just how visitors work. Instead you would have to find everything that could conceivably contain an image and then visit that - and on top of that anytime W3C added another item that could contain an image you would have to update your visitor. This isn't a perfect example - there a lots of tools for altering webpage DOMs - but hopefully it is an intuitive one. Sorry - there is a wall of text in the more complete description below. I'm trying to walk the line between brevity and fully explaining everything, but it looks like this post same out quite wordy. What I have: I have a class hierarchy that can be represented by the simplified classes below: 

So, did you actually have a question? Yes, I did. Firstly, is there a name for this variant of the visitor pattern? I assume that I will not be the first person in the whole world to think of or implement this. And I assume that with the collective wisdom of all those who have gone before that this class can be done better. Secondly, if this is not the case, then is there a way I can do this better? Doubling up the visit methods seems wasteful, but I always get stack overflow exceptions when I try an implementation without it. Thirdly, I am concerned about type safety. In the toy example all the composites contain base . In the real-life code most that contain another hold a derived type. Is there a way of making the visitor type safe so that no upcasting is needed? I couldn't find one - but that does not mean that it doesn't exists. And if not, is there a way to make it easier for a developer to write correct code. This looks like a powerful pattern and as Uncle Ben* said: "With great power comes great responsibility". If it is not possible to make it provably typesafe according to the compiler, then the code should not get in the way of writing correct code. 

You have data sets within code. Code should ideally be independent from the data. We can see that target_meter, update_timestamp_col, data_lifespan, move_back_amount, secs_in_res all correlate. I would extract the data from the functions: 

Here I would establish something that I call context state. Your functions and daemon run in a certain context that is established. 

You added the cast likely because the compiler complained. But the problem was not the missing cast, but that you converted an integer to a pointer, instead of an integer pointer to a void pointer, which can be done without cast. When you store a correct pointer, you can then display it correctly with: 

This is a mixture of storing the value and storing the operation. When you need to print a value, you look up the range and print the value. As you see, we need less than 64 bytes for this simple example to store the information how the 7.4 GB data is compromised of, yet we can print the value for each and every array position. Even if we have reduced the data, we still need to optimize the remaining data. We can't just dump it into a linked list - as stated, we can end up with Q+1 entries (200001), we can't afford to search the entries with an effort of O(n), let alone (r-l) * O(n). But if we put the data into a binary search tree, we can find the correct array entry in 18 steps within the 200000 entries. This costs us some more memory, not only due to the overhead, but as we need the array index as key, we can't group all identical values together, just as long as they are one range. So the example above will need 4 nodes in the binary search tree, to separate the value 0 twice. So, when you combine these two approaches, you should be able to get a decent memory and processor time consumption. 

The context is passed (as pointer) to each function so it knows the circumstances it operates under. This also groups relevant data together. The second context you operate under is a specific meter. 

Document your function and use the correct type Your function returns both lists and boolean. Maybe it's be clearer to make it return a list (when a list is found) and otherwise. This can be documented accordingly in a docstring. 

Writing pythonic code Python has a coding guideline called PEP 8. It contains a lot of relevant information about how to write your code. You'll find various tools to check your code againt PEP 8 to ensure you follow it properly. Among other things : 

Because of points above, this is easy to change because we have references to BeautifulSoup in a single place. 

Many variables are defined but not used : just get rid of them! The same comment applies to unused parameters. 

In your case, there is not much to be changed except for the function names which do not follow the naming convention. For instance, should be named . Also, another (recent) part of PEP 8 is not followed by your code: 

DarinDouglas's comment is right. However, it forgets to point out that your code actually does not work (or at least it will not always work). Before going any further, it might be interesting to write a few unit tests. Here's what I have so far (the names suck). One you have this, you can see that something is not quite right if you run the tests () enough times. 

Couldn't send this answer yesterday because the site was down for some reason. First thing you can fix is to add a guard before calling . This is the usual way to do things in Python so that you can import you files without running the code corresponding to : 

Because you don't really care about the order of the letters in the word, you could perform some simple preprocessing in order to deal with fewer words : 

Iterator Instead of dealing with indices explicitly, you could use iterators and just decide which iterator you "advance" on (I am not 100% convinced it makes things better in your case but it is always a good technique to know): 

This way changes of the data do not change the executing code, also the data is actually grouped together - you have a chance to spot erroneous data just by pattern recognition (or rather that something disturbs the pattern). Then we see that the data also correlates with the input parameter. We can include this, too: 

For N = 109 you have to store about 7.4 GB data, if you merely use longs with a size of 4 bytes. This is not feasible, which, I assume, is the whole point of the problem. You have 200000 Qs - storing the Qs instead takes up only 11 bytes per Q - one byte to determine the operation, 8 bytes for the two values which can go up to 109and 2 bytes for c, which fits into 16 bits, as it's not higher than 10000. If you store Q, you end up with around 2 MB of data. You could apply the Q operations at runtime to a single long (long) and then print each value individually. This algorithm will be memory-efficient, but very very slow. Looking at the problem, we will have a lot of array members having the same value. There are only 200000 operations but 1000000000 array entries - we can change 200000 different values - if we do this, we still have (109 - 200000) array entries with the very same value. Even if we modify 200000 ranges, this doesn't change the fact, merely the distribution of distinct values. So it's much more efficient to store a value and then for which array range this value is valid. In example: 

a) There is one conceptional behavior I personally don't like: The code will leave a partially written file behind in case of an error, instead of removing it. b) 

With this change it's a breeze to adapt data and also to add new resolutions without accidently messing up code that worked before. 

The first question I would have is: What head are you talking about, there is and ? Does the function modify a global variable called head? Not even your unit test creates a variable called head as head of the list ;) Your data is a void pointer and then you use , that's not legal, because the size of a void pointer can be different from the size of an int. It's already strange that you don't store a pointer to an int in data, but the int itself. Is this really what you want? Didn't you want to store the pointer to the int? I assume you actually wanted: