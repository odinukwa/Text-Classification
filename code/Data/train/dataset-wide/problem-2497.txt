An important feature of the algorithm is that the scores are kept in a min-priority-queue. Keeping the scores in a vector requires O(n) cost at every step. Also note that having using a priority queue API would simplify the , as the operations on a vector are somewhat low-level wrt the task (remove the minimal value from the queue, if it exists). The explored nodes form a set, to it'd be indeed more appropriate to use or . Whenever you use with , it's a sign to think of a better data structure (unless you know the list length is bounded by some small constant). Regarding the results, we know we add each node only once, so seems to be OK. Adding is then O(1) and whatever manipulation we want to do at the end can be deferred until then. I don't think there is anything wrong with your approach to keeping the state. While you could use the monad (or perhaps where the reader part would be the graph, the writer part the results and the state the scores), it'd force (as any monad) more imperative, sequential style. And it'd cloud which part of the code needs what information. And having the value that's being modified as the last argument (like ) allows to use point-free style where appropriate. You might want to check if your is tail-recursive. Perhaps one way how to make have less imperative feel would be to check for the termination condition first (which isn't such a bad idea, if the input is an empty graph or so). Something like: 

All the basic parts are here, but there's still room for improvement. First of all, I wouldn't have the constructor call and then call because it makes the second method less discoverable when the code is being read. Contrast this with: 

This implementation has a cache that never expires, but you can modify (or override in a derived class) to tweak this behavior to taste. It also has no thread safety, but that's as easy to add as 

But why also rename to and add the "action" prefix to method names? Consider also your dispatch code: 

We would like a review to make our F# more canonical. That is, we would like to adjust our code to be in keeping with common F# styles and techniques. Alternatively, we would like a reviewer to show alternative techniques (if not better ones) for implementing Algorithm A in F#. 

I am new to F#. Is the following code, which represents about three hours of work, a canonical way to achieve its goals. If not, how can it be improved? For instance, can we provide a default value of zero for the parameter? Also, how do we handle a search for a term that does not exist? Could we use something similar to instead of matching against ? It looks more verbose that it needs to be. 

In your shoes I would totally scrap using (IMHO it's useless in practice). If you want to go the extra mile and auto-detect the user's locale, use an IP database (I have used MaxMind GeoIP in the past myself) or the upcoming W3C geolocation spec. 

Here it is much more obvious what you method you should be looking for. It's true that you, as creator of the code, do not need this -- but others might, and it's a totally free lunch. Second: this line bakes an application configuration decision inside the router. You don't want to do this, as it's totally reasonable to want to change this configuration most of the time while the router would stay mostly untouched. 

How can we make this code more readable? How can we make this code a better match of canonical F# style? Should we be using instead of ? Should we be using more explanatory variables? 

Sorting algorithms involve swapping element positions in an array. This is my implementation of swap: 

We would like a review to make our F# more canonical. That is, we would like to adjust our code to be in keeping with common F# styles and techniques. Alternatively, we would like a reviewer to show alternative techniques (if not better ones) for implementing Algorithm B in F#. 

On principle the code is sound except for one issue: you do not check if the language is "valid". This raises some questions: 

If were then the could be reduced to protecting just the statement, but as it stands it must protect everything inside . 

You do not have to go to all this trouble to implement a caching wrapper. It can be done much more simply: 

In both cases, the sane outcome would be to default to your "main" language, which would probably be hardcoded in your application. Another issue you may want to consider is that nobody knows that there is an Accept-Language header and how to use it, so using that as a source of the user's preferred locale is not recommended: 

The above functions allow creating modules and combining them together in various ways. Now one of the main functions is to step a module with no input/output, producing its next state: 

There is no reason against using in this case. Some people actually prefer it over so that the code can be read top down. I'd like to point out that the time complexity of your algorithm is O(n^2). There are two reasons: 

Also note that you can declare this function as a composition of functions, in so-called point-free style. 

It's much better to make the default controller name part of the application configuration and have the router take it from there, because it's reasonable to want your "home" page to be equivalent to the "/something" url instead of "/index". The same goes for 

This check with would allow any url that maps to a function to be successfully dispatched, even if that function does not map to a "real" action (it can simply be a helper method). That's not really a security issue (you can easily make sensitive functions ) but it's not very consistent: targeting will get you to the index page, while targeting e.g. will show a blank page as most likely does not directly produce content. By demanding that actions are implemented in functions with names starting with "action" you can make sure that this never happens. The default action is a special exception to this rule, as it allows the controller writer to effectively specify which url routes to the default action and what the default action should do at the same time. Third: It's not consistent to show a 404 for a missing controller but not do that for a missing action and use the default one instead. You should do the same in both cases, and the right choice would be the 404. Fourth: Parameter handling needs immediate attention. To begin with, you are sanitizing parameters to an unreasonably restricted set. What if there's a search action somewhere and the user wants to type in a character like or a non-alphanum string? Clearly parameter sanitization needs to simply be removed. Apart from that, you are passing GET parameters to the controller action positionally. The positional part is not a dealbreaker by itself (although it would be a dealbreaker in a framework, or if the URL format were configurable), but the GET restriction is a bit ugly. However, this cannot be fixed easily because there's no good way to know where parameters from $_POST should be inserted, or what their order relative to one another should be. To address this, you need to make the code reflect into the controller method and look for argument names and default values, pull these out from your list of GET parameters and $_POST, place them in an array ordered by the position of each named parameter in the function signature and call the function with that. You should also probably return an HTTP 400 if the action turns out to have a non-optional parameter the value of which was not provided. All in all not the end of the world, but a speed bump and a non-trivial amount of code. 

(Again compiled but untested.) Note that in we change the order of elements. This shouldn't be a problem, as we need to try out all before we fail anyway, but if you don't like it, you can use instead of and maintain sequential order. Or you could also replace it with , but only if the total number of elements is moderate, otherwise you could start having problems with its O(n) complexity. 

Your code is correct, fast, and I'd like to emphasize that you thoroughly include types for your functions, which greatly helps readability. While arrays offer fast performance, I'd say that in this case operations with indexes and bounds of the arrays cloud the main idea considerably. Therefore I'd offer to use lists and functions native to lists that avoid indexing (the same could be also achieved with arrays, by writing similar functions for them). The main idea, computing the maximum path lengths for one row, can be then nicely described by zipping: