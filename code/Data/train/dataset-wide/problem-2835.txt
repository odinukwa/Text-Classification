Note that for the implementation of the implementation of (without title) makes things a bit tricky. For that reason I would add a relation in the document space, either with a or a pair. This would result in to be a map . As a result it would remove the call in which could then be renamed to allowing you to remove the comment. The two most common errors by Scala developers are the usage of on options and on futures. The only place these methods are allowed to be used is in test code. If have (to date) not found a valid usecase for either one in production code. There is a small problem in your method: is an integer and thus could result in . In the (and to some extend in the ) you have mixed statements in your code. As a separation of concerns those should be moved out of the code performing the operations. The functional programming paradigm is really strict in this sense and some of their patterns can help you to do that. The book Functional programming in Scala contains a section about this exact problem. Note that I would personally keep the statements in the app constructor and only remove the ones from the document loader (which I would place in a different class). As with all things, always search for a balance between effort and 'ideal world perfection'. 

It's clear that you took some time to polish your code, good job on that. I like how used method names like , the allow for very readable code. My suggestions (note that none of the code was tested or compiled): It's 'weird' to combine a class and a . A case class gives you a few things for free: 

It seems there is a clear relation between a and a , it seems reasonable to expect a factory method. 

The class contains quite a lot of public members that are not really suited for public use. It's a good practice to mark methods as private that are only for internal use. This has (at least) two upsides: 

To me it's unclear why the method contains the code it does. It seems the code could also be in the class. Or, the other way around, the code for analysis could be in the factory (or another class). I would not use mutable structures to split the document space and documents containing a word, this is more sensitive to programming mistakes. On top of that it disconnects two pieces of code that are connected, forcing our brains to do more work. A simplified example using option: 

I'm not really sure why you have both a perm_nfbm_disabled and nfbm_enabled flag. Try to use only one. Or if they don't mean the same thing, give them names that make that fact clear. 

If the sender doesn't have permission we send a message and return quickly. We don't have to worry about permission for the rest of the method! Let's do the rest too. It looks something like this: 

The most important thing we've done is create a seperate method that will check whether a block is minable. By using a seperate method, we can focus the onBlockBreak method on 'what to do' instead of deciding 'when to do it'. The rest of the method now looks like this: 

By breaking down the nested if-statement it becomes much easier to think about. Now we can add new stuff and fix broken stuff much faster. onGetLLCommand This one is a bit easier. 

Something I didn't fix, but you definitely should, is the use of a single list as both a black- and white-list. It is much easier to create two different lists, and check each of them seperately. because now you have to keep thinking 'is this list a white-list or a black-list?'. Conclusion Methods should focus on one thing as much as possible. By seperating code into methods we reduce duplication and increase clarity. Lastly, by preferring early returns we prevent deep nested if-statements, again reducing duplication and increasing clarity. 

Just printing the string returns the morse, but asString returns the normal text? This is pretty confusing and someone will have to dig into the code to see what prints which version. I don't think someone will have to use both the toString and asString methods, since they already have access to the original string/morse. So why not make the whole thing static and have two public utility methods: 

Notice how all it is doing is passing the call on the the other methods when it is appropriate. onNfbmCommand Let's look at the onNfbmCommand Method. This part is difficult because it contains a very large nested if statement. This makes it hard to think about, so let's see what we can simplify. It seems both branches are actually almost the same, except for the specific message they are sending. In other words, it doesn't matter whether the sender is a player or not. We can use that to our advantage! First lets create a method that sends a message to the sender with a color if it's a Player and without a color if it's not: 

I would also change to a normal class without title and a lazy field. About the and the , they seem to be the very related. It seems you can construct an instance from an , this would make the an ideal candidate for the factory of . Such a factory is commonly at the companion object. Note that I would personally introduce a case class for document. 

The type is now modelled as a tuple. I would recommend a case class for it. That allows you have the code in search be more readable. 

With a case class you say: this class is defined by it's values. With a Traversable you say: this class is defined by it's contents. To me that is a bit confusing, is it about the parameters passed in, or about the contents? 

You don't bother users of your class (yourself) with the internal details It allows you to easily identify which members can be safely refactored 

A few general notes I recommend you to reverse the general order of your code. Most important (or less detailed stuff) at the top. It's easier for readers to zoom in and see the important (public facing) bits. So if you have a program in a single file, put the App on top. Within the app, put the stuff that actually does something at the top of the file. I now have to scroll down and skip a lot of noise before I get to the actual stuff that is being done. 

The method has a comment, requiring the user to do something before it can be used. Most programmers will not read a lot of documentation (apart from Ikea manuals) before using a library. In this case it might be best to help users of the method with an explicit type. 

I recommend the same structure for classes: public (and most important) members at the top. Then (in usage order) the other members. This is ofcourse personal preference. In some cases it's not needed to specify a type. For public facing members it's good practice to write down the full type. For private (and function local) members it's not needed and might actually introduce noise that harms readability. I noticed you are using and a lot. I try to not use them as they require the reader to backtrack to find the type of the tuple that contains them. There are a few techniques you can use to avoid their usage. 

This comment doesn't add much and can be removed (after all the code says the same thing). Perhaps it is worth mentioning why you are saving the configuration when the plugin gets enabled. loadConfig 

Again, we're determining whether a block is minable as early as possible. This prevent deep nesting if-statements and prevents repetition. This is the list of checks: 

Defining them early and making them static gives you less stuff to think about, which is always nice (especially when you're reading this code in six months). The next piece of code is too long and contains too much stuff so lets start breaking it up. First let's create separate methods for both of the commands you're accepting. 

Notice how it doesn't have to care anymore about whether the block is blacklisted, or the current lightlevel, or any of that stuff, we moved all that to the isMinable method. This allows the onBlockBreak method to focus on one thing, and makes it much easier to read! The isMinable method looks like this: 

But honestly, using stream/filter doesn't make it much clearer. Why not stick with the standard approach? 

These strings are all constants and should be defined at the beginning of your class. They should look like this: 

Overriding the incorrect configuration with the default value would save you from having to keep track of the temp_disabled flag. onCommand 

But we're still stuck with quite a big nested if-statement. To get rid of this nesting we can use something called a guard clause. Which basically means we're checking things as early as possible so we can return quickly. So in this case we can do this: 

The implementation seems fine. I would change the return type of the method to be a bit more general. Callers don't care about whether the duplicates are stored in a Set or not. 

Here you are giving a warning that the configuration is wrong, but are still continuing with the invalid value. Why not set the value to its default value? 

It seems all these variables are only used in this class, in which case they should be made private. You are also mixing naming conventions. Pick one and stick to it. The regular Java convention for variables is camelCase, so I suggest using that one. onEnable 

is undoing the work did for you (which is the entire reason for using ). Instead, you should do this: 

When the data doesn't have any values, my algorithm appears to be about 15% faster. When the data has lots of values, there is not an appreciable difference. This makes sense, because most of the time, every set of {a, b, c, d} statistically should contain two values. This shortcuts the differences between our algorithms, leaving only (in those cases), just checking for . 

This cleanly separates the business logic of the game from the mechanics of running the game multiple times. Also, it frees up to return the number the number of guesses the user took, so that (or other calling code, in the future) can collect statistics about gameplay. 

provide the same logical information as calling as you originally posted it like: . But with this suggestion, the following information is available: 

Edit: Original code masked with , which was erroneous. Mask (corrected above) should be . Note: I have use casts because per the C11 standard, ยง6.5, para. 4 (emphasis mine): 

All of the masking with individual bits and logically comparing values really eats up your performance on the randomized data. For the ordered permutation runs, it's likely that some compiler optimizations in conjunction with branch prediction helped out your times (because every group of 16 calls to had a, b, and c identical, varying d. This is evident because for the randomized data runs, your original algorithm suffers a 3x performance penalty compared to my implementation. The Takeaway This is probably one of those cases where, if performance is really important because you're operating on a lot of data, or you need hard real-time performance, that it pays to take a step back, and reconsider the data flow. If at all possible, removing the cases where you're checking the inputs {, , , } for will yield 2x-3x improvement in the algorithm computations. Alternately, if there's another way to handle those cases (mathematically, instead of conditional-logically), then you can just operate around the issue. 

Thus, for ultimate portability, and to satisfy pedantic compilers / analyzers, use types/casts with bitwise operators. Providing more information (return value) If you have the leeway to change the specification, you could make a couple changes to the function to increase the information it provides to the caller: