There are too many blank lines inside methods, in my opinion(it is conventional to separate methods from each other with an empty line, but it is not common to insert random blank lines inside a method's body). 

and then use it for the conversion between different units of speed. Empty blocks are redundant. Just get rid of them. 

I'd recommend to move declare store in a final variable with a meaningful name. It's not clear what it stands for right now. It's the number of buckets, isn't it? You can improve the readability by calling or . The hash table actually stores numbers. There's no need to convert them to strings. It works slower and makes no sense. The meaning of the constant is also unclear (Why not ? The clearly stands for no value). But again, it doesn't matter if you fix it and start treating integers as integers. Converting everything to a is a bad practice (unless the data is actually a string). The name of the function is also meaningless. It doesn't compute any hash. The name doesn't reflect what it actually does. It should be something like or . I'd also create a separate hash table class and move this there (and make it non-static). That would reflect its actual purpose: adding an element to the hash table. Having a fixed size 10 for your hash table makes its next to useless in practice (what if you want to add more elements?). The function can be iterative (you can just loop until you find a free cell). It would save a lot of stack space if you decide to make the table bigger in the future. 

Now it returns in both of these cases instead of throwing an exception. But it is not the only method of this class which works improperly. An attempt to create any instance ends up with: . It the result of an incorrect implementation of the method(which always returns ). A fixed version: 

The comments inside the method (like ) are an indicator that a piece of code this comments corresponds to should be probably factored out to a separate method (of course, it's not always the case. It is the case here, though). Once or code calls the method, there is no need for such comments anymore. The code becomes self-documented, which is a great thing as comments can become obsolete if you change the code in the future. There's no way to ensure that the piece of code followed by the comment actually swaps anything after changes are made (again, it's not a big deal for a such a small program, but it can become a serious issue if you implement a larger program using the same practices). You can get rid of magic constants (like 3 and 2) in your code by creating a constant variable for them (for instance, you can set and use it everywhere in your code. It communicates the intent more clearly and makes possible future changes easier (you need to change just one constant instead of looking for all 3's and 2's around your code). Keeping the scope of each variable as small as possible is a good practice. The declaration of loop counters outside the loop is not just unnecessary, it's also sort of misleading (as it's normally done only when the value of the counter is used outside the loop, which is not the case here). That is, the only variable you need to declare in the begging of the method is the array to hold the matrix. The loops are usually implemented this way: 

A lot of variables have extremely weird names (like . What does that even mean? "at or operator()", seriously?). You define to be a vector of vectors and then create a bunch of huge unreadable functions to work with it (including initialization). The is really huge. I have no idea what's going on in there (and what's the point of creating a lot of lambda functions inside it? It seems to me that it only increases the confusion). Everything related to looks like a bunch of mess to me. I'd strongly recommend to create a properly documented class with a meaningful name that implements your cache with short, readable, properly named methods inside it. Another argument for making it a separate class is that it's not really a vector of vectors: it's some kind of data structure (I can't figure out what's going on exactly in your code) that uses a vector of vectors internally. Adding the comments doesn't magically make your code more readable. Ideally, the code should be self-documenting. It's definitely not the case here. As I have said before, I have no idea what the cache does. I don't see that point of having the struct and doing all that complicated IO stuff. The problem statement guarantees that the input is correct. It could be just something like: 

This way the meaning of the indices is clear. It's also clear why should move right while is moving left. There's no need to handle any corner cases. I also suggest returning an empty list or if the target sum is not found. I don't think that throwing exception is reasonable. Not finding the sum is a normal, not an exceptional situation. 

It is a good practice to keep a scope of a variable as narrow as possible. There are a lot of comments in your code that tell what the code does. Instead, you should try to write a self-documenting code. You can increase modularity and clarity of your code by using separate methods for separate tasks. For instance, 

Writing useless comments is definitely a bad practice. For instance, doesn't make much sense: it is absolutely clear that it is a without any comments. I'd recommend simply deleting comments like this one. Comments inside a function that tell what a block of code does, like here: 

variable sized arrays are not a part of the standard C++. Don't use them. If you need it, you should allocate it dynamically. If you use the as I said above, it'll be even simpler as has a proper copy constructor. Index It's conventional to use , not as an index type (at least that's how an works). 

It might look the memory management works properly in your code. Well, not exactly. Your code is not exception-safe. A node is allocated with a call in the member-function. A pointer to it is added to a vector using . If fails with an exception, the memory leaks. The pointer isn't stored anywhere, so it'll never get deleted. There's no such problem if you use smart pointers. Setting the of the to a negative number is confusing. Moreover, isn't guaranteed to be signed. An overflow of a signed value is well-defined, but it can break if the string has non-ascii characters. How to fix it? Firstly, Let's do a simple thing and add a flag to indicate if some word ends in the (it shouldn't be called a leaf because it may not be a leaf). I'd call it or something like this. It's makes more sense than storing a negative value. I think that keeping the in a is quite confusing. There's no value for the root, is there? In fact, the letter marks an edge from to another. That's why I'd rather store a or an from a character to a pointer to a . It has a clear meaning: an edge marked by a specific letter. This design is closer to what a trie is from a theoretical point of view. There's no reason to use raw pointers. You can use . It'll take care of memory clean up. It'll simplify your code and make it less error prone. So the can look like this: 

There is too much stuff going on here. And the fact that you need to write comments to explain what the code does is a smell. How to improve it? Well, you can make it much more readable by decomposing it into several smaller methods: 

In fact, it can be a good idea to go even further and split your code into multiple classes (a class should also do one focused thing). A reasonable way to do it would be to, make the following classes: 

Assuming that the function comes from the itertools library, the list should be sorted before this function is called. For instance, should be . It doesn't work properly if the input is not sorted according to the documentation. After you make the split, you compute exactly the same function for the and the part. It might be a good idea to create a separate function for it (something like , that takes a list of labels and return the gini index). . This one looks sort of weird to me. I'd recommend to figure out whether it's actually a special case. If it is, it should be handled properly (namely, this split should be ignored). If it's possible to prove that it's not a special case, this comment needs to be removed to prevent confusion. I would agree that sometimes 's can be left in the code, but in this case it looks important and easy to fix.