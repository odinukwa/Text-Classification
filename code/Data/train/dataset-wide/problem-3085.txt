Apart from this PEP rule, IMO function names should reflect what is being done, i.e. an action. Thus not but rather , not but . Comments 

All in all I really like your code. It's good and easy to read, and there's nothing really wrong with it AFAICS. In the following I'm writing down whatever's coming to my mind what could theoretically be improved/changed. Therefore don't take that as a list of things to change, but rather as points to think about. 

Public interface I wouldn't expose the argument to the public. It is simply not meant for the user of the function to be used in any way. Thus, I'd use to define an "inner" function inside of . Don't . and then When you to a list, then that list needs to be fully traversed. Moreover, creates a new list, creating significant garbage since you don't need the lists passed to it anymore after the call. Same structure of return value When I run your split with 

Note that this is not (entirely) "your fault" ... Probably the one writing the specification didn't even think about negative numbers here. Which is why you should always make sure there's no ambiguity in a specification / task statement handed to you. If you can't "re-negotiate" like in this case of some online coding task, then at least check that the assumptions you made hold up, e.g. by checking whether all (or just the smallest) numbers are actually positive. 

One thing that I think is very important but not yet addressed in the other answers is: naming and abstraction. Albeit your code is short, I have to look at it and think about what these loops are doing to understand what your code is supposed to do. It's much better if that's directly apparent from the identifiers (variable and function names). Speaking of functions, there's at least one functionality that I'd put into a separate function: printing a substring. 

For further information on why you want this see this SO question as well as the top answer to this one (but don't get confused about it's incorrect references to the points in the question). Going further, the best approach is to use as deduplicator suggested. The standard describes its effects as "" (where and are the parameters of ) and further imposes the "swappable" requirements, which state: 

You use blank lines to separate parts of . I wouldn't here, because it hurts readability IMO too much. Function names 

What if is read as ? If you have a fixed size buffer, then at least protect against overflow! Also use the instead of a magic number! Tests Add unit tests to ensure functions you wrote (the search function, the substring test, ...) work the way you intended. Use golden files ("golden tests") to ensure your input / output works as expected. Minor flushes the stream Using means: Write a and flush the stream. The later is a potentially costly operation. So when writing text(*) to a stream, use literal for all newlines except the last. (*) Unless you write lots of text and need it to be refreshed on "screen" repeatedly. Think of "following" logging output. 

You do not check whether allocation succeeded. Thus the next line will probably result in a crash in case returned . But it could also continue to seem to be working, failing at a potentially completely unrelated point in your program. That's the problem with undefined behavior. Thus, if you want an allocation failure to be a fatal failure, then you have to actually code such a failure mode: 

But if you're using such a macro, better keep it "behind closed doors", e.g. only in the implementation file. Since these operators are probably the only ones in this specific code base it's very debatable whether it's worth the effort, though. 

BAAM! Undefined behavior due to signed integer overflow: After assigning the largest representable power of two, you do another which causes said overflow. lambdas ... Perhaps you don't want the "raw, unhidden" lambda there, but instead have names () for everything. Then, instead of writing structure templates ... how about this: 

Why? As you already noticed, this is a lot of boilerplate code ... but for what improvement? Further, why do you need a type inferring and a non-inferring version of each of your function objects? and lambdas Do you know ? Basically it does what you want: Assign the results of successive function calls (which potentially mutate the function object) to the elements of some range. So, if you want it dead simple, consider this: 

The fact that this set contains "tickables" is encoded twice in the line above: The type of that contains the type and the name (informally) tells us the same. While accessing this set as is a good and very readable option, this does not lend itself to template programming that much, because the compiler doesn't understand "tickables". It's just another identifier, the meaning (that we humans are able to understand) is lost. Thus I suggest accessing your sets like . This is still readable to us, but also provides information for the compiler about the content of the set. To be able to pull this off I wrap the sets in a helper struct: 

is absolutely not ok! If your header needs some other (standard or non standard) header, then include it. Same for the implementation files: include all headers from which you reference something. Including the same header multiple times is not an issue if all headers have include guards. Call functions with their qualified name to avoid ADL surprises 

Separate logic from IO Don't put any or calls inside of "business logic" functions (like when you "calculate" the winner). Separating these two concerns allows for easy adaption to other IO situations (web app, GUI) and makes it (better) possible to test the business logic. TEST Your code should have tests. Look also into TDD (test driven development), where you write your tests before you write any code. 

Don't. Of what use is ? This class is just a collection of functions. It serves no real purpose: It doesn't really bring any data and logic together. All it does is needlessly limit the access to the data structure with your records. In other words: It doesn't protect any(*) invariants. Why hide the in it? (*): Actually it does, of course, but I'm relatively sure that's not needed: You cannot add, sort, remove, ... any records. I'd guess this is what your instructor meant with the Java-ish comment. (Because in Java, everything needs to be inside some class). My suggestion; implement the following "interface" (as free functions): 

...? DRY All these , etc can be implemented using the corresponding "self-assign" operator. This could be automated with a macro. Just as an example: 

This constructor rings alarm bells, though. Here you accept a pointer to (probably) an array of s, but you have no idea how many you'll get neither give the caller any chance to tell you how many objects live behind that pointer. Sure we can expect people to be able to infer from the name that there are 16 s required, but it's a dangerous practice / API design nonetheless. You could also provide a constructor accepting a . Or an ( please) constructor accepting a . Don't break encapsulation in your factory functions In your factory () functions you (IMO) break encapsulation by directly accessing the underlying array. Better let the constructor do the work: 

Oh, and I like indexing with as that's what's returned from the various member functions and may protect you from fallacies with the "usual arithmetic conversions" between unsigned and signed integer types. And of course when dealing with large amounts of data, might be too narrow to hold possible indices. But of course, this doesn't apply here. can be dangerous, better avoid it Instead of you could use the C++ (almost) equivalent . is a bad idea when using anything but plain old data types, and even then I'm not sure whether aliasing (and in the future also "laundering" or lack thereof) could still cause undefined behavior. Thus I recommend to avoid it. DRY using the evil preprocessor The definitions of , and the two are almost identical. You can use a macro to save you from that repetition: 

Of course this fails spectacularly, but is easily fixed with some "domain knowledge" (namely that in a leap year February is a day longer): 

Do you hear the evil laughter? "active" vs the lifetime of an object What happened? When you the vector from its initial size 0 to some larger size in the constructor, then the vector will be filled with default-inserted objects. So directly after construction of your object pool, it is already completely filled with alive objects. These objects stay alive all the time (unless you ). Your notion of an "active" object basically just revolves around whether one can access (through ) that object. "deleting" just moves one object out of the "active" (accessible) region of your pool. "adding" enlarges this "active" region. This is very confusing and not what one does expect from an "object pool"! Further, it puts up some requirements to that type, namely that it must be default-insertable. With the standard allocator (which you use) this means that has to be constructible through value initialization. That's a pretty tough requirement, as it basically means that needs to have a zero argument constructor. Now, if is a bit more than a simple value / data aggregation type, then its objects will probably depend on some objects of other types. To follow the SRP one wouldn't let an construct the other objects then, but rather pass it the requirements upon its own construction (dependency injection). Your object pool design does not allow this, though. In short: You sign yourself up for lots of future trouble. To fix this, use for your vector in the constructor, and actually construct new objects when adding (make of the vector accessible) and destruct (terminology is important!) them when you want to get rid of them. To keep that later operation fast, swap the last element and the one you want to get rid of and then the last. (Of course this only works when order doesn't matter. Moreover, it invalidates possibly obtained references to the last element.) Swapping done right Calling directly is almost always wrong. Bring it into scope with , and then just do an unqualified call: . This allows ADL to kick in and find potentially useful user-defined functions. Provide a complete interface provides , which - like yours - does bounds checking. It also provides which does not. Thus, I'd hope for (expect) your class to provide this feature, too. Furthermore, I'd follow the terminology used by the standard for adding / removing elements here: (or ) and . Expose the allocator allows to use a different allocator than the standard one. You should expose this with your pool, too. That allows for object pools whose objects have automatic storage duration ("are on the stack") when used with such an allocator. 

You could make your code more general (as in usable for more than one single list instance) if you pass (a pointer to) such a head pointer in to your functions. Use blocks 

gives you a , then. Calculating a winner Instead of winding yourself up in some s I'd suggest a more data-driven approach: 

(No tests?) Try to test your code as early as possible. Even more, at least according to TDD, you should write your tests first. I'm still looking for the object orientation I was promised ... Sorry to be the elephant in the room, but I don't see much of an object oriented design here. It's more like wrapping all the code in methods of some arbitrary classes. Let me try to explain: