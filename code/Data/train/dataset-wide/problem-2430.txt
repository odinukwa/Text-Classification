As was , we can see already at , that this is not possible because . Doing this for your example of : 

Naming conventions Classes start with an uppercase letter, methods start with lowercase letters. would be slightly better, but would be even better, although describing what the class is used for is often best. That's hard to apply on homework though. Following the conventions, is a better name on the method, or even better: . Right aligning code does not feel right. I do not often see code like this in Java. 

That is, four spaces being added to each of the selected lines. This is just my preference though, but either way, I believe that the actual result below was not part of the plan: 

The only difference being that you switch to and vice-versa on some of the calls. I would create a method for this, 

could be named with what the means, to make your logic flow more self-documenting. How about ? Coffee, Coffee, Coffee, Sugar, Cream This code is very tedious to write and I bet you used Ctrl + C and Ctrl + V when writing it! 

Although perhaps not a great speed optimization, this removes the need for temporarily adding and removing with , and . I think the major thing you should change is to switch from to . Just remember that when using , you need to take a look at your implementation of and . Probably you don't want a to be equal to another considering it should be possible for both 2s to be within the same move. It is possible that the default implementation from the class is enough for your purpose. But either way, make sure that it obeys the rule "If two objects are equal they should have the same hashCode. If two objects have the same hashCode, they do not need to be equal. 

I think that you are over-using your own and other validations. You can remove them in the below cases (and probably some others too) to let the default exception be thrown (which will be very similar to the own you throw manually). Removing these additional checks you have added also can remove the need for overriding the method entirely, which will reduce some clutter. 

What you need is a . A map is a collection of key --> value combinations. There can not be two equal keys pointing to different values. There are a few ways to organize this map. The simplest is to make , but that would make it possible for collisions if two albums had the same album name. Another alternative is for fixing the problem with albums having the same name. There are more alternatives but they can get quite complex so I think this is enough for now. Then when you loop through your songs, for each song: 

ViolÃ . An entirely different approach As mentioned in the comments to your question, you can also use Regular Expressions to verify input and parse it. Here is a brief example of how to use Regular Expressions to input this. I will let you work on the details for it (such as making sure and are in the proper ranges). And you probably also want it inside some kind of loop (either or ) to make sure that the user enters acceptable values. 

To get an array of all the muppet enums, use . If you want the possibility to add muppets dynamically at run-time, I would make a and get the position of an item using . 

Now, what if we transform the way we look for neighbors? To what I call "Chess style" (based on how a Knight moves in Chess). 

Why not use an right from the start? There's not really a need to convert the array to a list every single time (although that operation is fast). 

Or at least, if you don't like the conditional operator (), use the for but do before or after the if/else. 

Your indentation is severely off, this might not be something that Code Hunt give score for, but it is what humans pay attention to. Also, don't write the statement for when if is true on the same line, and preferably use braces (I know, I know, I don't like that advice myself when it's only one line but I'm starting to get used to the convention by now). Here is how I would have written your original code, stylistically: 

What you need is to extract some values into variables. First of all, you are always using for both X and Y so those can be extracted into or . Next, you are either doing or which can be changed into using a that is either \$1\$ or \$-1\$. And as a last step, the can be set using the conditional ternary operator. Then what you end up with is this: 

As they have visibility though, it is okay to use them as , just make sure that your code doesn't change any index of them. 

Technically, there is no such thing as if-loops. Your code is just a bunch of if-else statements (sorry, this was the language police speaking) What your code actually needs, is actually a real loop. Use an array or a list of a record, and loop through it. Your current approach allows a maximum of six products in one loan, it involves a lot of code duplication which in itself is a code smell, and it could be a bit weird if the values for Product 3 were set but not Product 1. My Delphi skills are a bit rusty, but consider changing into an or a instead of a pure . That way you could have the method as part of the object/class. This is some code for how I think it should look. It's been a long while since I worked with Delphi so this might not be 100% correct code, but it should get you started in the right direction. 

Update, your for-loop can be written as only one loop (even though it's quite many variables and this code possibly needs it's own review...) 

A tiny extra thing that is often forgotten is to pass an argument to the , by default it is initialized with a capacity of 16 characters. If we look at a little example, we see that that's 20 characters. So the internal array in will need to be resized once. We could create the StringBuilder with a capacity of 24 to reduce the need for the resize. 

See those parameter names? and . They represent completely different things, they should have been named and . Item(id)s in one array, and amount in another. What if each item would have enchantments? (which, for the sake of simplicity, also is an int for now) Would you add ? Then what if you would add damage for items? Or other properties? It's a bad bad idea to store it like this. It's not all about performance, it's also about extensibility. 

The only way to do what you are trying to do, and remove the duplication, is really to cast. What I would do is to use this kind of map: 

Regarding your current code: Public or private You have three variables, but your method is . It would be better having it the other way around. You wouldn't want outside code to modify your static variables, those are meant to be used only by your method. The method that you provide is meant to be a method that provides some calculations, it should be able to be called from other classes - hence it should be . Naming It's a boolean, of course it's a flag! What is the flag used for? Reading this variable name now doesn't help me understand the variable's purpose at all. It should describe why it is being used. Static variables 

Iterating instead of continuously copying and modifying. Why on earth did I not think of this before? This means that doing this big analyze on The super board of death is now done in about 3.5 minutes instead of 35 minutes!! 

There is no need to use a HashMap, because you already know the number of doors from the start you can use: 

Making them private will let the compiler tell you if any of them are not used, and making them final will ensure you that once initialized in the constructor, their value / object-reference cannot change. Naming Using class names with in Java is unusual and not convention, would be a better name. Also, class names should start with an upper-case letter and use CamelCasing, making --> . Overall though, I get the impression that you seem to know what you are doing coding-wise, good work :) 

janos recommended the Spring and Apache DbUtils frameworks, I can highly recommend using Hibernate. Hibernate is a very commonly used ORM framework (Object-Relational-Mapping). By using Hibernate and the proper entity classes, you can do all this with only these lines: 

Your constructor and your main method is doing way too many things, break up the code into additional methods. Some methods can include: 

This constructor should also be Constructor calls constructor As your constructor is essentially initializing it with specific values you can call one constructor from another 

Ain't it lovely with enums? :) Now, back to your method: You have a whole bunch of duplicated code there indeed. It would be handy if you could get a of some kind (or an array), add some elements to it and check: Is there a winner given by these values? This is just one version of doing it, it's not the optimal one but it should get you started. This code will add a bunch of objects to a list and then we check if those objects match to find if there's a winner. 

I have a feeling that using some interval for your actions will be very common, so you can abstract that functionality into a with the constructor . In the method, you would then only check for the interval stuff and call the other action method: 

Naming, naming, naming. OK, naming things totally correct is one of the hardest things in programming. But then there's also... bad naming. Instead of naming a variable something and explaining it with a comment like this: 

Version 3 is using and mixed in the same condition which makes it a lot harder to understand. Try to avoid mixing those two together, instead extract conditions into variables, as palacsint has done with . 

Technically, those tasks don't need an active Activity. They need a . However, "acquiring" an activity should not be that much of a problem. See below. 

An important trick here is that you can calculate the and positions of your buttons with a bit of math. By using and . Your method (which should be named ) is a bit ugly. It can be improved like this: 

Mapping int to int... You have used to suppress a warning. However, you should know that there is some performance benefit in using a rather than a . You create a mapping from integer to integer, by using your own keys. I don't see the need of this, honestly. Instead you can declare the and similar as constants, such as: 

This will provide the possibility to have multiple problems in the same class, which IMO provides a nice overview of the problems: 

Technically, you're off by one here. You're missing the case when , which is also a three-digit number (the same goes for btw). Correct would be (also with improved spacing) 

However, I suspect you are also interested in who wins, in which case you could have both and return a instead of a . And by the way, I'd prefer to use an for the possible values of each tile. A can have the value of , but I don't believe you want to place a tile in your game. Using an reduces the eliminates any possible risk of invalid characters. 

What has to be the step before ? Which number was added to which? Was it or was it ? would be nuts as 15 is less than 19. Therefore, we know that it was . And x must be 4, as 15 + 4 = 19. By continuing to subtract the biggest number with the lowest number, we can find out all the possible inputs that can produce these two numbers. 

The construct in BF means "while the current cell is not zero", this is the only conditional and looping construct that BF supports, and in reality it is the only thing you actually need. You just need to know how to use it. As we already start on cell , we can write our construct like this: 

Catching all s is a very bad ideaTM, as there are plenty of throwables that are not meant to be caught. This includes OutOfMemoryError and StackOverflowError which are among the worst, but then also some s which indicate a logic error in your code, including: 

As your is instantiated as an , the lookup time for is constant time, \$O(1)\$. There is however, somethings that I can point out. Final Whenever possible, add the keyword to member fields of your class. This keyword should be used for values/references that never change. Your and variables can be marked with . Why ? You seem to only use your as a lookup for to . You never increase/decrease your value. Then why do you use ? I think you can get rid of your list entirely and use Rewritten code according to what I have mentioned above: 

Now, because it's using a static variable, will be . "Do I really need to learn factories and dependency injections?" Yes, please, learn Dependency injection! You won't regret it! I don't think for this particular case you need a Factory pattern, but it never hurts to learn that too. Dependency Injection is not that hard actually, the golden rule is: Whenever an object needs your , give them a reference to your . Don't use something like . Tell objects about the ProductsCache you want them to use, don't let them ask a singleton about it. Very easy rule to remember: Tell, don't ask. 

You could make be a function on the that modifies the value and , then you could do . (Then again, you just move the two lines from one place to another). Other than that, there it is not possible to my knowledge. You can't change a property on the object and return the object at the same line. 

Overall, I disagree. This approach is actually very limiting as I can not create a new enum at runtime. What if I wanted to create a dynamic format? I might want to let the user specify how he or she wants to see the output. They can't create an enum at runtime. All possible formats must be specified at compile-time. Modern? Sure, enums are nice. But enums should not be used for this. Readable? Sure, it is quite readable. Maintainable? No. Disagree. Sure, it's easy to create a new enum if I want a new format, but it is quite a lot of boilerplate code needed. 

String literals vs. constants vs. enums I think that the biggest terrible thing that you are doing here is 1) using magic string literals that are not defined as constants. 2) using a string when you can use an instead. 

Let's say that you have the ability skills 4, 3, 5. The sum is 12 which means that an integer from 0 to 11 (inclusive) is generated. 

Do I even have to comment anything about what I think about this implementation? You use Objects.equals above, you can use here. It is preferred if and use the same fields for their operations. Set or List? Whenever you use a in a program, ask yourself the question: Does the order of the elements matter? In this case, they don't. Use the interface and create as for your variable. 

Speed Unable to reproduce / Unclear what the issues are. It seems to me that your code is quite fast. Even the input calculated with reasonable speed IMO. Extensibility For testing purposes, to ensure both correct results and fast enough results, it would be useful to extract a method to do the actual calculations, and then your outermost loop could be: 

Another option is to use an additional column in your database that specifies whether or not it is a like. So instead of running on your existing row, you can just run and set the flag to false (to say "don't count this"). Using this option allows you to run an INSERT ... ON DUPLICATE KEY UPDATE statement that can handle both cases. I agree that catching an exception and deleting the row in that case is not a good way to handle. You shouldn't use as normal program flow. Exceptions are meant to be exceptions, not normal behavior. 

This can be solved by wrapping a inside Use the interface, Luke! Your and methods does not need to reveal the implementation, use as the return-type instead. The same goes for your unit test, declare as: 

I should add however, that there is a difference between an unmodifiable list and what I understood about your approach. An unmodifiable list in Java does not allow any change to the list at all, such as list.set(index, obj). 

No, it is no need to use in this case. Rewriting with You currently check the first item in the list twice. If your code would accept an , you would support even more data types (You still support ArrayList also). The only thing you need is the from the iterable. When you have that, you can first see if it contains at least one item. If it doesn't, return 0. Otherwise, you do similar to what you are already doing, but with different code.