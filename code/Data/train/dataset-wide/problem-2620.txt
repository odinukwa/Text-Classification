If you come from C and you start using C++, you might be use to have pointers whenever you want a function to be able to update one of its parameter. In C++, if you want to do so, you can use references which gives you a clearer and slightly safer result. Please refer to the wiki page for more details. However, I'd like to point out that whenever you compute the lowest common multiple of the two integers, you probably don't want to change the value of this integers. Thus, I'd expect the following code to do what you are trying to achieve (not tested, not even compiled): 

Better algorithms At the moment, is already very slow, there is no way you'll get to the extreme values in a correct time. You'll have to improve algorithms. Better check for primeness At the moment, when checking whether is prime, you consider all potential divisors up to . It is not worth the pain at least one divisor would be smaller or equal to the square root of n. Also, it might be worth extracting the corresponding logic in a function on its own for clarity purposes (it took me a while to understand that was a premature optimisation). Once it is done, you can realise that you can do even better than this by considering only odd numbers if the number is not divisible by 2 but I won't care about this yet. The code is already much faster and looks like : 

Now, the main issue in your code is that we are performing complicated (dirty?) string logic and checking many times if some letter is in a list. The real solution is to count letters in both string. Each letter will count for n points where n is the minimum between the number of times it appears in string 1 and the number of times it appears in string 2. Using , you can write this : from collections import Counter 

Please have a look at PEP 8 giving the Style Guide for Python Code. Now, in (or ), it seems like you assume that A and B have the same size. You could achieve the same result with . 

Performance Your solution will be slow for any big (or even medium) inputs. You can easily see add a print statement at the beginning of the function to see how many times it gets called and you'll see that we compute the same things many times. When n is 15, the function gets called that many times with the different inputs : 

Now, different great things are easily doable : - you can your call to behind an guard to have reusable code on one hand (you could need the function to solve other problems) and code actually doing something on the other hand. - you can write tests to check your code automatically. The great thing is that the problem description gives you a few examples. 

Class names and and docstrings are still to be fixed bu I'll leave that to you. Logic If you check that the 2 inputs have the same length first, you don't have to check that they are both non-empty. Also, because an empty list of fraction would lead to a sum of 0, this error would be properly caught and signalled to the user so this check might not be useful. Once your object is properly created, we always have , thus, there is probably no need to store it in the object. Your code then becomes : 

Maybe you could define a constant like (corresponding to your actual dictionnary) and use it where you are using the list of the planets ( for instance). Do not perform more operations than required is computed for every planet in the list. It would be better from a performance point of view to feed the function a number of days. Useless list (or useless test) You are creating a list with values divisible by 4. Then you iterate over it and check if the value is divisible by 4. It seems like a waste of effort. Let's get rid of the list creation. Code is based on the initial version of your code. 

You are retrieving various elements to be able to loop over parameters without default values then over the parameters with default values. You could loop over parameters and defaults values and fill with None for the parameters without. Because you want to fill from the beginning, you could simply reverse both input lists. Duplicated logic Expressions such as are repeated in multiple places. This is easy to get rid of because you have stored it in already. At this stage, the code looks like: 

An example of dynamic programming approach (but I do think it will be better for you if you try to rewrite your solution with tests first, at least you'll be able to compare results and performance): asuming you have a string s "dddddD1D2" (a string composed of any digits then digit D1 then digit D2) and you know the number of combinations for all strings "" (empty string), "d", "dd", "ddd", ..., "ddddddD1", how to you know the number of combinations for string s ? You have two different options : 

It is relevant in your case because you have an array of elements so the last index you should access is . The usual way to write the corresponding loop is with (instead of the equivalent ). The stays the same, I'll let you understand why on your own. The code is now : 

Your code looks nice. Here are a few detais: In The name suggests an positive integer value corresponding to a length. We actually use it for a string, which may be slightly confusing. At every iteration, you compute the length of 2 strings which is probably more than required for an optimal strategy. You are lucky because the problem you are trying to solve has a generic solution : which in your case gives (I've kept as a default value as it corresponds to the current behavior but maybe an exception is a more desirable way to handle an empty list). In The docstring says "alphanumeric" but the regexp does not include numbers. Also, if your pont is just to make an URL from a string, you may find better option in the module. In You could write: . In Instead of using lists, you could use sets which is a data type more relevant to what you are trying to achieve. Also, you may want to replace the code with a dictionnary structure: 

then, you can use the fact that non-zero numbers evaluates to True in a boolean context (and zero evaluates to False) : 

Tested on both and , it seems like it returns the same thing but my implementation is much faster and much easier to understand. A possible improvement would be : 

Details : Idiom It seems like is a more common name than . It might be a good option to use the usual vocabulary. Reversed loop Probably a personal preference but I find pretty hard to understand at first and I'd rather read . 

Disclaimer: None of this review has been tested. I've just applied some manipulation of your original code. Making thing more simple Your dictionnaries are constant and always used with literal strings. From my point of view, it'd be much clearer to use constants to achieve the same thing: 

As resolved will be False if and only if an element verifies the property . Also, this can be rewritten using builtin all/any : 

Final point : I had trouble understanding your list slicing stuff but as I was messing a bit with it, I obtained a result different from yours ('rate' appears in the final result so it might actually be a good thing) : 

Hidden recursion Your game loop relies on a hidden recursion: calls which calls . This makes things heard to follow but also will add another level of function calls in the stack. This can be an issue if you need a backtrace because you'll get something like: 

Enumerate As pointed out in comments, you could (and should) use enumerate to keep track of the current index during an iteration. In your case, because it makes sense to start from index 1, you can use the parameter. 

Now, you could make your function a bit more powerful (and a bit slower) by returning all common chunks and not just one. This could be easily done using the buillt-in operations on set (). A final thing (a few other things could be said but I am running out of time and it might be too much for the time being) : if you want to pretend you are a cool kid, you can use set comprehension in your function. Then it becomes the concise : 

We can see that the functions return 0 in 1 case out of 2. This corresponds to the fact that we cannot partition an odd sum. This can be taken into account to avoid computing combinations when this happens: 

Also, I thought I'd take this chance to test and it seems like it always returns . Shouldn't you handle perfect tie situation in a different way ? 

Then I do not understand enough what your code is trying to achieve to try to be able to help more. For the time being, the code looks like: 

Shouldn't you replace the whole code with ? Let's assumme that this is just a placeholder for actual code. If you handle your different cases in order and if is an , then you can make the logic a bit easier to follow : 

It seems like I dove into the code before turning my brain on. You can use math.ceil and everything will go fine : 

Style Python has a style guide called PEP 8 which is definitly worth reading. Your code does not quite respect it on a few aspects (spacing, parenthesis, etc). If you are interested, you'll find various tools to check your code compliancy to PEP 8. 

Names Python names are usually . Also, would be a better name that which sounds like a class name. could be renamed , , etc. could be renamed 

There are various way to define who wins in a game of player/scissors/rock. You could define a dictionnary mapping the different combinations possible to the winner. I quite like using modulo arithmetic to find the result. Final code looks like: 

Just like in other quite similar question, I find the already existing code slightly weird but I'll comment only on the code you have written. find_closest_state 

Your code looks nice, seems to follow PEP 8 and has docstrings. I don't have much to say about it but here are a few changes to make it look more pythonic. The loop can be rewritten using a loop with (or ). 

Improving The first main improvement is to reduce the amount of duplicated logic. Your function performs a lot of boundary checking. You could reorganise your code to remove a lot of it: 

seems to imply that could be a float. As far as I can tell, this value corresponds to a number of page and an would be more appropriate. Also, to be sure, I've tried giving a value and the code is stuck in a loop. Code organisation Your code is the perfect example of a piece of code that could have been written as a clear function: input and output are both well-defined. Once you're done, you can even write unit-tests for it. Then, the code calling your function could be behind an guard. You'd get something like: