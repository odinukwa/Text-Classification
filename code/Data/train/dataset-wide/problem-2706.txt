You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

Note that takes so you can write instead of (you also want instead). Furthermore, is quadratic in length of the input string - it can be made linear instead. is a usually used as a prefix for iteration macros. Also, you call in twice; you can use to remove one call. Your line breaks in are very confusing. You can use instead of in because returns a fresh list. Summary I think your code is overkill. 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

Yes, that is necessary and another indication of the complexity of the code. You actually don't know if an instance variable is reinitialized while a method within the class is running... 

It is only possible to validate the query, not the result. Of course, it is possible to overwrite the query's method, and extend the API, but that is far away from being a simple usage. 

The view model seems to be used as universal container with high coupling. In the medium term, I would try to move the logic of each method to a single class that is independent of the view model. 

That code fulfills the open/closed principle because you can add new request handlers without modified existing logic. 

So you have to initialize a list of abstract operations first. The main code can work with that abstractions and must not be modified if an operation changed or if operations were added or removed: 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

This has the added benefit that the return value increases in (i.e., it returns the of your function). Alternatively, you can actually avoid constants: 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

2) You could improve performance of your seconds code with "client side indexing" (using a dictionary): 

It is possible to use a linked list of chars and navigate with the linked list nodes. That should be fast and uses minimal memory consumption. 

First of all, I think the code is well written and the algorithms are implemented pragmatically and simple. Performace SplitWordWithArray 

You could encapsulate the variable parts in a separated class. The solution has more lines, but it complies with the open/closed principle. Therefore the logic can be simply extended without changing a switch statement. 

d) Maybe a question of philosophy, but I don't like properties of type in view models. A boolean property is more appropriated to represent the logical state of something in the view model. The transformation from the logical state to it's visual state should be part of the view / XAML (using a BoolToVisibility converter). But that is probably just a matter if taste... 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

The documentation of FluentValidation says, that the methods and are different ways to use the validator. Therefore it is not required to use both. Something like the following should work just fine: 

I am interested in general code improvements (e.g. naming, simplifications, bugs, ...) and alternative approaches to address that kind of problem. However, any constructive feedback is welcome of course :) 

Local functions and delegates (without recreation) are almost as fast as the static version while recreating the delegate each time is ~40% slower. Note that the performance difference is not noticeable for common programming tasks - so don't care about it. 

The last case of the function should be instead of because the value is not used ('_' expresses exactly that) 

IMHO ref for reference types should be avoided if possible. If a method create a new object based on another one, it should be named in a propper way (e.g. ) and return the new instance. E.g. the following code is much better readable (even if the method name is may not the best one ;)). 

Implementations The first (HOF) version can be much more efficiently rewritten in using (provided returns fresh lists): 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

The second (recursive) version can be made tail recursive using an accumulator. This would help some compilers produce better code. 

(Bug) Edit: It seems that your incoming data are sorted. If so, this 'bug' is not valid of course Your traversing algorithm works fine as long as the s have the correct order - parents must be positioned before children. If you add a node that's parent is not already part of the tree, it will never be added. To fix that bug, you need at least another reprocessing step that sorts your items... Naming 

You don't have to use a because a is not equivalent to a . It is a more abstract kind of "working item" that will be spreaded to real threads by the TPL. If you start 1000 tasks it does not mean that you create 1000 threads. When starting a task like you did (without option TaskCreationOptions.LongRunning), it will be executed on threads from the TreadPool. Therfore, the Threadpool is managing the number of threads for you and you can just start 17.901 tasks at once. 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

Stack overflow is tail-recursive, so if you compile it, it should become a simple loop and there should be no stack issues. However, do not rush with it yet. Algorithm Number of iterations Let us use to see the problems: 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using