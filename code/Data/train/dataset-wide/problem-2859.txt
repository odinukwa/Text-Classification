(Refactor that into a separate method and you can re-use it for your balls generation as well.) When and are both arrays, the comparison could also be simplified to: 

Custom exception? Or return a default empty JSON object? Whether you throw an exception, return or return an "empty" object is to some extent a matter of style. In your case I'd probably go without an exception as the method name ("") suggests that reading may fail (thus making it a non-exceptional case). And since I can't think of any general use for a default object, would be fine as well. If you decide to throw an exception, I'd prefer a custom one to a) make your api consistent and b) abstract from implementation details (e.g. reading JSON from a won't throw an ). 

General observations "I find your lack of javadoc disturbing". Especially when writing code for others, your class should describe what it does. In detail. See it as a contract: Your javadoc describes what behaviour a caller can (and cannot) expect. Oracles document on javadoc has a lot more details on that. A library which handles URL -> JSON seamlessly The default implementation, see above ;-) 

This means that your code doesn't cover all of the possible cases. Append to your question an updated version of which doesn't produce any warnings, and then I might have some further comments about it. (Please append to your question instead of modifying it so it doesn't invalidate any existing comments.) Let me know if you are not seeing this warning from ghc / ghci so we can figure out what's going on with your environment. filterEmpty I don't think the logic is right here. What if you have this message: 

The other thing which will help is to keep in mind that the type represents a a combinator which is able to memoize a function whose argument type is . So: 

parseMessage The main problem here is that you are calling on the result of , and this doesn't preserve the original whitespace. For instance, the last case should just be: 

Background/Intro: I've been using (and refining) this setup for all of my MVC applications I've been doing at work and now that I think I've worked out all the kinks I see in the 'architecture' I was wondering if there was anything anyone else saw that could be improved. I have a few concerns but I'm generally open to any/all suggestions. Concerns 

Sometimes it seems unnecessary when you're doing OOP in a scenario in which you could easily do it all in one function but it helps significantly when debugging, reading, or maintaining (or in this case when other's are reviewing your code :D). 

Always use brackets. Even if the statement afterward is a one-liner just use them, it'll prevent a rookie mistake in the future. Secondly, if you insist on not using brackets, be consistent. You have an if-statement with brackets and the else-statement doesn't. Curley bracket placement. The standard for C# is placing brackets on their own line. You have spots where you do this, but you also have spots where you place the opening curley bracket on the same line as the if-statement. 

Note that always assumes that is defined, and it doesn't have to return it since all invocations modify the same object. 

stream->list Avoid on large lists. In your function it will create a (large) list before passing it on to . There is a stream version of - namedly , and this will process the stream lazily - i.e. it will only generate as many elements of the stream which are needed. next-prime Another way to eliminate the recursion here is to combine with and with your predicate, e.g.: 

A clique is just a set of Ints. You could use a linked list, or a bit set, or whatever you want. Here is part of a Haskell solution which might help you structure the problem in C++: 

where is the (infinite) list of primes and returns all of primes less than which can be combined with . 

Each of these steps can be put into their own helper function which are also called "subroutines". The will make the body of the while loop a lot more readable. Here is an example of a subroutine to get a valid number from the player (again, pseudo-code): 

Modularity I'm seeing one major problem with your code. It's not very readable. Sure you can add comments in there and read those, but that just adds to the clutter. I think that your code's clutter and low readability is causing your grief (and those trying to review it). For instance, it might seem a bit easier to incorporate SirPython's answer into your code if it were a bit more modular. Each section below is a step-by-step attempt to show how you could approach this problem in a more modular-ready fashion. It may not be a perfect or exact solution for you, but my goal is to help you break your code into more fine-grain reusable pieces. Wrapper Functions Sometimes these can seem pointless but I find them quite helpful for scripts/plugins whose code base is trending toward clutter. 

This system allows the user to define property mappings between two objects and a filter. Then the user may call to get an . Example Setup 

It all depends on how many configs you have. For a large number using a sqlite database could be a win. 

I think you really should look at this guy's solution which employs numpy: $URL$ The advantages are: 

Given these observations, why not just pass the first and last characters of the alphabet to , i.e.: 

It only reads once It's a lot safer It's easier to express more complex logic You have more versatile data structures available to you - e.g. real arrays and hash maps. 

This whole approach is completely bogus and not worth your time. A "pattern" is simply an array of percentage changes. For simplicity let's use a pattern size of 5. So a pattern might look like: 

meaning that the price difference (from the price at time 0) at time 1 was 1%, at time 2 was 3%, at time 3 was -2%, etc. Given another pattern we want to compute how "similar" they are. This is done componentwise using a similarity function for percentages whose definition is: 

I'm going to assume that you already know about HashSet and ISet in the following review and are just missing the reinventing-the-wheel tag. ICollection You've got Add, Remove, Clear, Count, and Contains. If you add a and to your implementation then you can implement ICollection. Why Dictionary? Perhaps you'd be better suited with a implementation? Correct me if I'm wrong but it doesn't appear you're actually using the boolean value of the dictionary, so you'd be better suited with a . Generics You could create a generic implementation fairly easily. And if you wanted to still allow your existing functionality then you'd use . Set Operations Perhaps consider having your operator functions return the new set from their actions? For example, 

Updating a Single Liberty You need a function that does the / update that you do 8 times in your function. Something like so you don't need to copy/paste the if-statement for checking a single liberty when you have 4. 

The prediction algorithm then boils down to a nearest neighbor search in a high number of dimensions (e.g. the length of the pattern array.) 

The idea is to keep track of the last node in the chain so you can update its field when you create a new node. 

which helps to describe better what it is doing. Anywhere you can use the alias instead of will help the reader. In fact, I would even write the signature this way: 

The method is relative slow but indexing using is very quick. Instead of appending each wanted pattern and then calling to find it again, just append the index to : 

Nothing really wrong here, but I have a suggestion... it is customary to repeat the key if it isn't long enough for the entire message. I.e., if the key was and the message was , you would repeat the key as many times as was needed to cover every letter of the message. The key used to encode the message in this case would be . You can use the function to repeat a list forever: