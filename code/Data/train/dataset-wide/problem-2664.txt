returns the price plus the tax. If it's going to do that, I would name it . There's also a lot of repetition in the method. Find out the part that's not repetitive, and do that first: 

I changed the logic a little, because seems to neglect to grab the item to the left of the current item. Also, in the for loop skips the entire row above the current item. I would add the enumerable in the traverse method into the for loop: 

Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

Another shameless linq answer that doesn't require reversing or creating a new enumeration and only goes as far as it needs to: 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

I'm almost alright with not declaring local variables though. The function names are descriptive enough, especially knowing we're traversing a tree: 

I removed because I don't think it's necessary. I would also check for malformed input, as can fail with an error, and can be something other than , , and . Before I got into the industry, I had flaky UIs that worked if you used it how I, the programmer, intended. There were quite a few ways to misuse it and break the program. One of the first things I learned on the job was that that was not going to fly. Ewan's answer is great for the OO principles, so I'll neglect to cover that. 

In , the return type is , but you return and . Just return a and return or . You also never use the variable. Also, comes before , and you probably meant to surround the response checks with parentheses: 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

You could take a page out of functional programming and shorten the visitors for the multiply, divide, subtract, and add: 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

The algorithm you used is the way I've always seen it - flooding the matrix. I think my sister had this question at her first interview, and I think she did it the same way as well. 

In , you do a lot of the same as in the else. Also, has an overload for a format string. Use that one instead of concatenating a bunch of strings and variables together. Also, it's hard to read when it's all on one line: 

Since there are only three valid key sizes for AES, it makes sense to not even let the AES class be instantiated with any value. I would introduce an enum similar to this: 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: 

It's also a little confusing that you return from to indicate that you want to keep running the program. I would probably change the name to and return to indicate that you want to continue. Float literals have an on the end of them: 

Sure, they could still pass bad values, but they have to try harder by explicitly creating an invalid enum value. Also, making it a scoped enum provides extra type-safety and prevents naming clashes. Either way, I think it makes sense to throw out of the constructor immediately if the key length is wrong instead of waiting until the function. If you want to enforce a valid value at compile-time, you can use a , or you can use a smart-enum pattern. This is an example hacked together real quick: 

Just pick one. Here I just return void, keeping with the semantics of the rest of the parameters (pass by non-const reference): 

Instead of putting the logic in the method, we can change the header of the method and let it populate a list of items visited by that cluster: 

As you can see this is already a lit clearder of what it does. You put yourself a white space just before the for loop. You seperate 2 different actions there so refactor this method further so it will look somthing like this in the end : 

Time to review, while I think your second line just have a typ fault I will not consider that. Implement abstract method with use of generics. All your Service extends . I see the method for AService. I see the method for BService. I see the method for CService.(I asume typo?) You can put this abstract method to the BaseService if you use generics. So it could look like this for BaseService : 

First of all you make 1 big fault by saying that your classes inside are private. They aren't, they are , more info on site of oracle. Then, let's start with the enum. Your is also package private. => change them to private. Your getter for the code is also a little off the normalisation, let's try to call it . Final result could be : 

Atomic Integer is thread safe. Put private constructor so no instances can be made. Only static methods means helper class => make class final. Edit : While @bowmore is correct you could want more generators for each class, you could do the following : 

So the result in the abstract class could be (You know what exactly the code does so make the names better for your cause): 

We start with that tab disabled. As the subscriber is created you can set the disabled to false and set the source of the include, so the tab will unlock. Another option, what I use in mine application is using the "visible" attribute. 

You put the space because you know you are doing 2 different things, just do that extra step to refactor to 2 methods. 

I saw your comment about the question wasn't relevant anymore, but still wanted to answer this one. I have a deep love for Java enums and this I couldn't resist to answer. Your trying to create a factory pattern inside an enum. I do think this isn't the way to go, but I want to point out some issues so leaving this construction working as it is. You work with the static variable to return them in the implemented method . You could refactor it to : 

Same for this but I should make an abstract method and make the implementation later cause it's for the 2 classes a little different : 

Default value of a is . Default value of a is . Take care, default of and is . Defensive programming 

The is for a testing purpose and to show your code works. A JUnit should be better but oke I can live with that for an test. You init the object like this : . This is actually a good start, but then you go so off. You need to implement a . The class should return you an array with the maximum sum, and this you could print out in the main. 2.Sum of int's is should never be an int. When you are counting int's together you have to take care with the max and min value of int. If your array has 2 values but both max int value, you will have an overflow. So it's better if you declare as long. 3.Scoping variables 

You are in a while loop so your loop will continue as long is bigger then 0. So I'm guessing you inserted that code for the last bottle. You just have to change : 

Implement more methods to reduce method complexity Like I already showed you with the switch case, make methods what do less things. This reduce the complexity of your method. Readability of the code comes higher and troubleshooting goes easier. 

Your list will be empty and your will have incorrect value according this new list. Program defensive and return an unmodifiable list back so no one can change it with the getter. 

As you can see now, I can easily refactor the code. Let's say you class grows and we need to change the to For me it's one little change and it's completly done. Your old class, you have already to change it 3 places, possible fault's .(forgetting one to change) waiting to happen when your class grows. 

I seen a lot of things what can better so I'm glad you came here to learn. First : Your is a normal class. The extends that class and do just calling the super constructor without anything else. Here is a problem : Or you set your first class abstract if you know you are going to have other implementations (preferable with more code) or your first class should be an interface. Second : 

So I'm really not going to speak that way, you are coding smart with primitives, what's also the reason of the benchmark result explains. There are a few points what could be improved. At first sight, I didn't understand why you create arrays of 256 size. After a better look, I understand it but please use a constant for this and name it like MAX_ASCII_VALUE_CHARACTER. While they do not speak over what characters the could contain, I'm tending more to go to the original ASCII table and not the extended, so I would change it to 123(z) or 128(full). Your naming of variable is pretty good, but sometimes you still name them bad. Example : or . While the min is already slightly better chosen, you could still name it like and the other one, you actually don't need it. You can assign the result directly to , check min for and read and from min pair. The reason is that you don't use further in your code. So final conclusion for me : Pretty good and smart code, with some (very minor) points to improve.