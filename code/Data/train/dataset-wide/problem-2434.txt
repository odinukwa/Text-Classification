Note the ? This is required for it to be valid JavaDoc. In more complicated functions where the parameters aren't clear or the return value isn't clear, you can include something like this in your JavaDoc: 

I don't believe that this is exactly what you were looking for in a review, but I thought I'd point it out: In the class's method, it looks like you are starting to create a switch statement which will check each possible numerical value of the enum property and, depending on the number, log out what the card is. However, I think a better way to do this would be to, in the enum, set a string property that contains the name of the suit. Then, your enum would become this: 

In JavaScript, bracket notation is usually only used for arrays or for objects when the key is in a variable. Since most of the time you are just putting an immediate string literal in the brackets, there is no point and you should use dot notation. That would look like this, for example: 

All of your functions (except ) are very cluttered up with comments. I recommend that you add JavaDoc to all these functions and include as much explanation as you need up there. That way, if there any confusions about something in a function, the answer can be found above the function, rather than in the function. 

Why are you creating a variable with an extremely simplistic value, and then having it returned from the function in the very next line? Wouldn't it make a lot more sense to just do: 

Maybe, but first you should be finding the min of three numbers because right now, that's not what is happening. This is what your current assembly code looks like translated to a pseudo-code: 

Don't speak of one I know it is against what the problem expects, but an improvement in your compression algorithm would be to not print any number if there is only one occurrence of the letter. This way, it would impossible to encounter that first bug mentioned in ChrisWue's answer. And, in files that don't have that many consecutive letters, they will have less added bytes from the compression. However, as noted in two comments, if the digits are numbers, you can run into some issues. However, after reading the next section, you can see that, if you have consecutive numbers, they will be ASCII numbers, where the values accompanying the characters will not be ASCII. 

To make this thing "more object oriented", I recommend that you put all of this into a class. Right now, you have variables spread out, and you have functions with names that make them sound like they are methods for a class (), even though they aren't. You should make a classes like and where has a few s that have methods. 

And now there is no confusion about where that number came from and you can remove that comment from above this line. You should see if you can create macros for this bit pattern like I showed you, and for the memory segment addresses. 

These ID's aren't descriptive at all of what the slides are. Here are some possible things you can do: 

Now, you can delete those other 3 functions: all you have to use is this now! However, there are still a few things I'd like to point out. 

It is a good idea to put all your s together, as you did under your section. However, there are two problems: 

The only downside is the fact that this enum now takes up more space - if that bothers you. Combining lines This isn't entirely necessary either, but it takes away a line from your funtion. This: 

Making the code portable again You did a fine job cleaning up last code's bugs. My answer will be fairly short this time. 

That is a good idea to store the time it took the user, then to show it to the user. However, for some reason, you don't do that in . Why not? I don't know about you, but I'd want to see how long it took me even if I won the game. 

Always prefer local variables over global ones in C; it is much better practice as it is less error-prone and more maintainable. I'm not going to go into how you can refactor some of these global variables, but take a look at the ones you have and see if there is a way you can make them local. For example, that compiling function declares a few at the start. Instead, you might be able to return that information as a struct like (or something like that) and have it accept a compilation data struct as an argument. This could also allow for some interesting future features. 

To me, this sounds like "get the amount of mines on the board". I think you should change the name to something that expresses neighboring. Here is what I came up with: 

I personally would choose the first one, because if you were to string the error catching and returns from all these functions, you would literally be left with a single line. 

Note: I chose to name the identifiers using for the object name and for the property names because most enumerated types are named like this. Now, you can easily access a type like this: 

I did something a little different in this function than what you did that allowed me to reduce this function to one line. You were checking if the square was equal to it's default value ("[1]", "[3]", etc) and I checked that the square was not X and was not O. Now, let's go back to . Let's re-write it using : def compturn(): 

Unnecessary comments Don't repeat your comments; especially when the original comment is very near. In this part of your code: 

Generally, in JavaScript, the singular version of the object being looped through is used as the indexing variable: 

You don't need to over-complicate things. The part will always come at the end of the string, after if it's there. All you need is this: 

Now, instead of having three functions, you can just have this one function and call it with different values. BUT WAIT!! You can make your program even more flexible now! Rather than having the user enter the "type" of exponent series thing they want, have them input these three things: 

* or [] There isn't really a definitive time when you should and shouldn't use pointers or arrays (at least not that I know of). However, I generally only use arrays for: 

The variable is equal to the attribute of . And, the calling on returns the attribute of so of course they are going to be equal. I may be missing something here, but I think this is unnecessary. 

Put these two lines at the top of your function, just before statement and then remove them from the rest of your function. 

The name "tag" is extremely general and gives little aid in defining the use of the variable. Since in the next line you give it a script source, I recommend calling it something that defines the script source. Here is what I came up with 

Use a boolean state Right now, to determine if you set the element's display to or not, you do a string comparison with the element's current display value. A faster solution would be to have a single boolean variable that tells the state of the element. For example, you could call it this: 

You do this in a few other spots, along with the above recommendation. You should fix those spots too. 

Design Your design is a little awkward. You have a function that will return one of three string values: "Arithematic series", "Geometric series", or "neither arithmetic nor geometric". That looks a little awkward for whatever is using this: 

There are many things to be said about your style, so I'm just going to brush through them very quickly. 

Your two methods look very, very similar. The only difference? Which element it is that you are using. Therefore, you should create a single, separate function that takes the element(s) that need to be changed. Then, you can just set the two methods to calls of this separate function. Here is what I wrote for that function: 

Note that this will require you to compute the rule somehow, which are technically already doing in the earlier part of the function: 

Move variables out of All the variables you are storing are sitting in the method of the respective component. This means that the variables are constantly created and destroyed. It would be better to either: 

Try following this through with some example numbers. Still don't understand where you are going wrong? Look at this example again with some mo 

Functions At the very last line of your code, you call a function. Since there are no conditionals surround that call, why do you have it out there? There is really a point in putting all of your code into a function if you are just going to call the function on the next line. And, since this function is the only part of the code (at least that's my impression of it), you can just remove it and when your code runs, it will run as if it will run the same way. 

Note: I changed the function name to because the function is no longer specific to a . Now, instead of using the string "snake", we can use the parameter that was passed in to the function. 

Now to talk about your HTML. The tags inside the tags should be indented. Some are, some aren't, and that is even worse than not having them indented at all. You should try running your code through an HTML validator. 

In fact, there is another problem this: you are repeating the same attribute for each and every . I recommend creating a CSS file and creating a rule for all buttons that sets these properties: 

and the Windows code in the respective pre-processor statements. As for what actually goes inside the Windows code sections, I am unsure. Through some quick searching, I came across in the API index. However, I have not tested it out. If that does not work, feel free to explore the API for other possibilities. 

That big chunk of code where you set up the buttons is very unappealing. I came up with this way to handle the numbers: 

Functional components Your and components don't actually hold a state (basically, they aren't using ); they are simply presentational components (they display state). So, rather than using to create these components, you should use a simple function that returns what would normally return. Here's an example: 

I threw in an extra method to format the object's properties in a way that made sense to output. This is not coding related, but I believe the correct word would be "content" rather than "context". 

There isn't much more to say about your code, but I have an idea for future improvement: right now, your code will say even if the element is partially hidden on the screen. How do you plan on handling this? 

Now, let's simplify the conditions. All the ones with arrows next to them can be removed either entirely or partially because, if the conditionals are checked in this order top-to-bottom, then they are redundant and unnecessary. 

Notice how the second copy doesn't have in the last argument. With it like this, you do not have to manually copy the character over afterwards as it will use the character from . Note that you can not do this as easily with as this function will copy the entire string, including the character. 

This will not work if you can't set a boolean value to . However, I don't remember if you can (I could not test it at the moment) 

That's a little gross looking, right? It would look a lot more clean if you just setup the property as soon as the object was created, like this: 

You have some awkward-feeling repeated code in here (the prompt for input). This can be refactored into a cleaner, more natural feeling loop: 

Add some documentation to function. While the name is pretty descriptive in itself, you should still add documentation to at least explain the argument and the return value. For example, I was a little confused when I saw because I thought it should've taken another argument that was the delimiter.