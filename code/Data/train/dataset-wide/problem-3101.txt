Does it actually work as designed? It seems to work but I'm not sure if there are any "edge cases" I am not accounting for. Is there a better way to do it? The inner function way seems a bit odd, as I don't like how I the works. 

This would allow me to create a map of objects and their classes, and if I set to true it would allow me to have a non-overwritable map of objects and their classes. The primary use of this is in an Entity Component System, where I can keep a map of classes and their corresponding components (as you can only have a single component of each type). I have one main "gripes" with my current code, albeit not that large, but I'd like to see what others think. I think that the documentation could be better - in it's current state most of the documentation is rather pointless, as it doesn't really tell you much about most of the methods. I'm not sure if this is a good thing or not, as we are pretty much re-implementing for the most part (excluding one or two methods). 

Gripes One thing I have considered doing is putting the , , and methods into a function which accepts the object. This would mean I wouldn't "pollute" the function signatures with an argument never seen by anything outside of the events module. Is this something worth doing? Also, should I expose the method to things outside the events module? I can't really think of a case where it is needed. 

Maybe only pad individual columns instead of the whole table, as if one column is really wide we currently end up with them all being really wide. I don't know how I feel about the large in the constructor, it looks like a bit of a mess but I don't know what I can do to remedy it. The method looks like a bit of a mess too but I don't know what I can do to fix it. One thing I don't like is how I've extracted so I can access it from the . I could bind the method but I don't really like having to do that if there's another way around it. 

There's one main issue I currently see with your code and that is that if the admin does not have a home configuration directory () then it will be created asynchronously. The issue with this it that your second call won't wait for this, leading to a race condition where you're trying to make (and write to) a path that might not exist yet. One solution for this is to have a function inside your function that handles the "second half" of your creation (i.e. the config location creation and file writing). 

I have written a simple JS module "loader" (loader is in quotes because it doesn't actually load the files) that is designed to resolve simple dependencies between modules. It is heavily inspired by module.js and takes some of it's design from it. Here is the code itself: 

The main issue I have with my code is that I feel it's a bit long and complex for what it is accomplishing; is there a simpler way to do it? I'm not sure how relevant this is but this code is part of a Dockerfile parser. You can find the Go implementation here. I know the Go implementation is much shorter, however I tried implementing their design and it ended up rather large and "non-pythonic". I am actually using the original logic from the Go parser but with a custom state enum and parser state object. 

It is designed for use in the browser, hence being passed as the argument ( is in the browser). Here's an example of how I use it: 

I have written a wrapper for my code that allows basic namespacing and I'd like some feedback on how it can be improved. It is designed so that a module can define it's namespace and get access to all of the parent namespaces. These are spread in reverse order across the arguments of the module (i.e. is passed as ). Here is the code itself: 

I don't like how the variable works â€” it seems a bit of a hack and there's most likely a more mathematical way of working it out. Are there more "ES6-y" ways of doing what I've done? For example using or similar functions. 

I've got the following code that I use to output a list of all (public) fields in an object in an easy(ish) to read way. The issue with it is that the code is not easy to look at, and I'm not sure what I could do to improve it. I'm not too fond of all of the StringBuilders, the calls are ugly and chaining them does not help the situation however I can't see a better way of doing it. 

The white node is the one we are starting the traversal at. The JS representation of this graph would look like this: 

I have written a simple wrapper for and that allows me to build and run my image without having to use the command directly. Here's the layout of my code: 

I don't really have any "burning questions" about my code; I'd just like some feedback on what people think of it and whether anyone can see any improvements. 

I'm not to sure on as it's not that obvious that it is a class, however I don't know whether or is better, as they're both just as clear as one another. 

Replaced with so I don't need an array to store the namespace values in. Now uses a ternary conditional instead of a full conditional to replace a value if it is not an object. 

I'm rather new to shell scripting, however I'd like to ensure my scripts are as robust as possible, is there anything I can do to improve their robustness? 

I have written a simple system to load plugins from files in Python 2.7, and I'd like to see if any of it can be improved upon. vedo.py 

The input string is split by spaces, counting any text between quotes (either single or double) as a single "unit" of text (i.e. not split by spaces). Any text wrapped in double quotes can be escaped using a backslash. For example: becomes . Any trailing backslashes are stripped. 

Instead of having an argument, should I rename to ? The main issue I see with my current method can be seen in my example above, makes it look like you're setting the value of to when in fact you're setting the next value to "id" and disabling escaping for it. Is my character escaping code enough to prevent injection? I found the list of characters in the mysql_real_escape_string documentation. What do you think of my commenting? Is there enough and does it make sense? 

I have written a class that is designed to be an automatically keyed in Java. Here is my implementation: 

I'm not entirely sure why I separated into it's own method, however it might be better to move it back into . 

I have written some code to find the longest line of empty space in a grid and I'd like to know if it can be simplified or shortened at all. Here is an example of the input and output of the program: Input 

I have written a simple prepared statement factory in Java and would like some feedback on how "secure" it is. By "secure" I mean that I can pass any old garbage in as a string and it should not allow any form of SQL injection or modification of the query in an undesirable way. Here is the code for the factory: 

Is there anything I can improve on here? I'm not all that fond of 's implementation but I don't know what I can do to improve it. 

I have written a simple wrapper for a 2D grid in JavaScript that allows me to resize the grid dynamically and I'd like to know if there's any way I can improve on my code. Here is the code itself: 

I have written a function that fills in the values between points and creates one continuous path (essentially walks between the points) and I'd like some feedback on it's implementation. If two points are provided that are not "in line" with one another then an error is thrown, as I do not want to support diagonal movement. Here is an example of the code's input and output: The route to walk 

I have written some simple code to detect cyclic dependencies for a module loading system and I'd like some feedback on how I can go about improving it. The code itself finds the first cycle in the dependency graph that starts at the provided node and returns a list of all of the nodes traversed along the way. Here's an example: 

Is there a real reason I should use instead of ? I'm not really sure why I started using it, I think I saw someone else using it and just picked it up. Is there any way to shorten it? I know it's only ~400 bytes but it would still be nice to simplify it further. I could use instead of but I tried it and it only saved on one line and partially sacrificed readability and simplicity. 

This image is primarily designed for development and ease of use, which is why I have created these shell scripts. Here's some examples of how to use the scripts: 

I have written a wrapper for Java's class using Java 7, which is designed to only iterate items that match a certain filter. When the filter is null, all items should be iterated. 

I have written a simple C header for converting the endianness of integers and integers. It uses the GCC macro to check the system's byte order and define the macros based on that. The header creates the macros , , , which convert the value from host endianness to the endianness specified. Here is the source for : 

I have recently updated my JavaScript Module "Loader" to ES6 and would like some feedback on the code and how "ES6-y" it is. I previously asked about the ES5 version of my code here and I have implemented the feedback from @janos (thank you!) in the ES6 version. 

Is it a good idea to just test the methods that have the "complex" logic? Am I testing everything I should here? How is my test documentation / commenting? Is it explicit enough (or even too explicit)? Does it tell you everything you need to know about the test? Is my constant alright as it is or should I directly inline the values? e.g this: 

I have written a basic event emitter in JavaScript and I'd like some feedback on my design. I tried to make it as simple and minimalist as possible, as I'd like it to be understandable by anyone. I have wrapped the code itself in a top-level "module" that adds it to the global namespace under the name . I have also attempted to document it to the best of my ability using JSDoc. The code 

I have written this "Polyfill" for Chrome's object and I have some concerns about the implementation; 

A while ago I asked for a code review of my automatically keyed map and I have recently had the time to get around to writing some unit tests for it using JUnit4. The test ensures that all of the "primary" functionality works, i.e. the things that could actually go wrong. The reason I don't test every method is that half of them forward their implementation to the map being wrapped. Here is my current code (thanks to @Tunaki and @h.j.k. for their help in improving my old code): AutoKeyedMap.java 

I am primarily looking for feedback on my testing code, however feedback on the map implementation itself is also very welcome. A few questions I have about my tests: 

I'm not all that bothered about the quality of the test code as it's mainly for demonstration purposes to show my function works. One thing I'm not sure about with my code (that I'm not even sure is in the scope of Code Review): Is there any case where is but the stack doesn't contain (i.e. ? I'm wondering if I need to check whether or not is in the stack before trying to remove it, as trying to remove something not present ends up with the last element being removed erroneously ( returns and removes the last element from the array). 

So I managed to make a few improvements using instead of , but I'm sure there's still something I can improve. 

The output from my function is , which is a list of the nodes traversed before finding a cycle. Here is the code I have written to generate the array: 

As you can see, the program found the longest line to be near the top in the middle. The program is only looking for a 1 block wide line, which is by design. It also supports looking for the longest horizontal line too, which is not shown above. Code