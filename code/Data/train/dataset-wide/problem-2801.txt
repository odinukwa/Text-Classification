versus A few times in your code you move the value into a register. A more efficient way to do this is to the register with itself. 

Let's take the last tip to the next level. This time, let's create a map of names of the keys of the object, and then the type of HTML element to instantiate. Here is what I mean: 

To be safe, you should check that the return of is not . Also to be safe, you should make sure that there is even a to begin with. 

You do not need to declare the iterator variable outside of the loop. This can and should be turned in to: 

You are re-inventing the wheel here. Form fields already have a property called . As the name suggests, it forces a field to be properly filled out before the form can be submitted. You can use it simply like this: 

It's poor design that this function is returning a string to symbolize a result. Usually strings are returned and the string itself is used for displaying to an interface. In this case, the string is treated as a value that needs to be checked against. And, to add, string comparison can be fairly slow. I recommend that you split up this into two functions/methods that like and . Perhaps you could contain these new code snippets in an object like . That might look like this: 

Now your code is more OO and cleaner. Note that with this new class, you now need to pass instances of it to the functions defined in the so they can access and modify the data. This also allows for easier unit testing. 

More refactoring and simplification Your three functions are all very similar except for a single line. These lines: 

Versatility It is very, very uncommon for an HTML tag to just be a tag along with inner content; there are almost always attributes. Right now, your code can only generate something like this: 

Load register A with 3 Load register B with 5 Subtract 1 from A Subtract 1 from B If , increment the total by the iterator. Load A with 3 and go to step 3. If , increment the total by the iterator. Load B with 5 and go to step 5. 

Sometime in the future, you may try and add more functions to this calculator. Depending on how many more functions you add, this statement can get quite lengthy. And, some operations won't just be a single character like "+" or "/". I recommend creating a dictionary/map where you map the name of an operation to a function. Then, in this function, all you have to do is call the function associated with the operation. Here is what I mean: 

Global variables Avoid global variables when you can. in this case is okay, but in the future, it may be better inside an object (as would all these other functions). However, is really bad. You should just have the function return the value that tells which player's turn it is, rather than setting the global variable. And, on that note, you should specify which player and correspond to in some documentation: 

Do this for the other elements that you grab more than once, too. If you are in control of the and functions, change them so they can accept the element itself through parameters. This will make your function more flexible, and also allows you to just continue to use this variable you have. 

I added a statement into your code because the original code uses , so if a conditional were to pass, the rest would not be checked. 

Now where have I seen that before... oh right! It looks exactly like ! I don't really see the point of writing that code again exactly in this method. I think it'd be a lot easier to just use the method that you already wrote. 

Which looks almost exactly like your function, except for the . If you have the function , you might as well use it when you need it: 

Please, please go through your code and fix the indentation. I'm sure there is plenty more to review in this post. Once you fix your code, post a follow up question and leave a comment to this answer; I will review the new one also. 

You should create "constants" for these places so they are more clear. A constant would look something like this: 

A simpler, maybe faster way of getting the string before the would be to just the String by the . Then, you'd be left with an array containing the String before the . Now, getting the name would be this: 

This looks better because then someone is just quickly looking over your code won't get tripped up and think that is actually an object (yeah, everything is an object in JavaScript; I know. You get the point right?) 

You should move outside of the statement because you don't need to redefine the timeout time every loop. There are two kinds of errors that could happen here: a timeout error, and an from . 

It's really as simple as that: using that "TidyUp" button will fully and properly indent your code. However, don't get too used to this: you want to be able to tell right from wrong without having to consult something else. Study the changes that that button made to your code. You may want to go back and forth a couple of times. And, read other JavaScript code that has proper indentation. Over time, you should be able to develop a strong sense of what is right, and what is wrong. Note: I actually had to use this tool in order to review your code; I couldn't read it otherwise! 

Simplification with variables There are quite a few places where you could both simplify and speed up your code if you used variables to access repeated data. For example, in: 

Look into the rest of your constructor: you have quite a lot of lines that are almost exactly the same, except for one thing. You should fix these as I have shown you. 

Well, that doesn't make much sense; if there's an error, the code needs to return a non-zero number to indicate failure. Other than that, the environment in which this program was run will not be able to tell that there was an error. 

What? That doesn't make any sense. There should not be any change in speed based on whether or not something is an if or something is a ternary. Even if there was, the difference would not be that great. Now, for the most part, you are doing okay with the ternaries that you are using. However, for the most of your ternaries, I think you should switch the order. For example, right now you are doing this: 

Again, this may not be more efficient, but it is more idiomatic in that is uses the right built-in JavaScript methods for the job. Note: it may be more efficient to sort both arrays for faster computing overall: 

I don't know the rest of your code, but I believe that it is fine keeping this as its own function; it is good to separate logic in code. You will not have much of a performance impact with function calls, and it's okay to use as many as you need as long as you are following good practices (and you are for this, as far as I can tell). 

Misc. Write some JavaDoc. You wrote a lot of code, and that code could get really hard to look back on unless you have documentation describing each and every method. And, by having JavaDoc, it will be easier for other people to review your code. 

I disagree with Tiago Marinho's point about ternary operators, however. I don't believe that it will have any negative impact on your code. With good formatting, this can actually make your code look rather nice, in my opinion: 

There is no point in having a loop where the condition being checked is ; if it were just a normal loop, it would run atleast once anyway. I recommend that you change your to just a as loops are much more common. 

Conditionals 2 In the conditional statements in both of your examples, you check that the return value of is not "". You don't have to specifically specify that. You can just remove the part and it would work the same way. The further reduce the size of your conditional, you can have your function actually return the value ( would be better, however) instead of it returning a string of the word "undefined". Then, you could reduce your conditional to: 

New solution In case you were not aware, JavaScript has a built-in function for sorting lists: Array.prototype.sort. This function, basically, is used to take a list of data and sort it based on either it's built-in function, or a simple function you provide. This function takes two items from the array and returns either 1, 0, or -1 to tell how to place them in the array (the original array is mutated). So, that being said, a much simpler way to sort these elements would be to do this: 

I'm not sure how much performance is to be gained from this (not much, I don't think, but I'm not sure), but yes; this can be simplified. Both of the functions that you have presented share the same scope, so there is no need for an animation parameter since you are always passing in that variable. Basically, all you need to do is remove that parameter. 

has a very un-descriptive name. I would call it something more like (or something along those lines). By the way, this was a very nice method that was easy to follow even with the lack of comments. 

Nice code! In this review, I'll focus on simplification, refactoring, emphasizing OOP, and overall making your code easier to unit test. 

Simply move that code (with slight adjustments) into a method like the one above; it is good to split your code into as many different (and logical) methods as you can so that everything follows the single responsibility principle, overall making your code more maintainable. You could also do the same thing for your struct regarding here: 

Well, I have some good news and some bad news. Bad News The bad news is that I'm pretty sure the only way you aren't going to get that bug where you substitute the file for is if you continue reading from . After all, you can't possibly read from STDIN because that's where the file is. 

Your function is just a function returning a class except for this one constant variable you define at the very top: 

Then, all you need to do is iterate through this map with a loop, checking with the key and returning the object if is /: 

The CoffeeScript compiler treats parameters with a before them as a name of a property to set to the parameter. For example, will become: 

George Mauer already provided a wonderful answer I totally agree with him. I have only one focus in this review and that is speed. 

Unix words in a dictionary that comes with Unix and Unix-like operating systems. Pro: It's just a file on the computer that has a single word per line, making it very easy to read. Con: Your user may not be using Unix or a Unix-like operating system. 

to have a at the beginning? This just makes things more difficult because (1) this function has to worry about substrings when building the element, and (2) if the code using this library is copying some elements from another element, they are forced to manually add the to the beginning of some properties (which makes it harder to loop through properties and copy them, and also slows down the code with unnecessary string concatenation). It would be a lot easier to use this part of the library (and the code would be slightly faster) if you didn't force a to be there, and instead just let the property name sit as it. 

Note that became . It must be written this way. increments by 1 and returns the value of before it was incremented. increments by 1 and returns the new value of . For example, 

(I believe) This works because, by removing the numbers from the array list, you are making sure that that number is not repeated again in that row, which would make a row invalid if it contained 2+ of the same number. Here is my implementation in Java: 

Two variables, same exact content but with different names and in different scopes. That's a little confusing. You should define the variable above the first conditional so both parts of the function can use it, since they both need to use it anyway. 

Right the elements of the array in reverse order to a blank string, putting a space between each word: 

If you continue to work on this code, you are going to build up quite a big statement in your function. As an easier way to solve this problem, create a dictionary containing the name of the command and the function to call for that command. Here is what I mean: 

I've searched everywhere in the Java API documentation and I haven't seen anywhere a class called . However, from how you are using this so-called , it seems to me that this is just like a . To reduce confusion, I recommend that you use a instead (probably an ) rather than this thing. 

This is much simpler now, and is a bit faster now that there is no recursion because there is only two places where the call stack is touched, rather than two places for every item in the list. 

Where the functions , , , and arithmetic functions that will take two numerical parameters. Now, your function becomes this: