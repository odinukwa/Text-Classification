Again, add one, subtract two? Wouldn't it be simpler to just subtract one? But if this subtraction runs on Sunday, you'd end up on a Saturday, right? Should you something after the final ? Now it only returns anything if the test for 1 or 7 matches. algorithm Actually, I can't understand your algorithm from this code, so I can't say if it's correct. Mostly because of the confusing conditionals. I would approach something like this by writing the logic down, in some human language if necessary, and then implement that. (Actually, skipping a fixed number of days is almost painfully simple, since it'll always go from a known weekday to another known weekday. Mon->Tue, Tue->Wed, Wed->Thu, Thu->Fri, Fri,Sat or Sun->Mon, so 8,8,8,8,10,9 or 8 days ahead, depending on the starting weekday.) structure I think this could be condensed to a single function. Preferably one that would take the starting date and number of days to skip. Even if you need a larger class around it, it would be easy to just drop the function in as a utility. 

Doing extra work in printList The thing that most catches my eye, is that in , you first get the length of the list, then iterate over it, calling on every iteration: 

Put the circle drawing in a function, and make , etc. locals to it. As for , you might want to scale it based on the circle's radius. Or make it a parameter to the function. I think you have a sort of an off-by-one error here, as (1) on the first iteration of the loop, you draw starting from (old_x, old_y), but and aren't set yet. And (2) when the loop ends, you probably want to draw a line from the last point (at angle 49/50*2*pi) to the very first point (at angle 0) to complete the circle. Also, decide if you're writing C or C++. You can't define a as just in C, and in C++, you should make the class have a proper constructor. 

Separate your classes into different files, and keep the HTML out of the PHP. Mixing the two makings things a hell-of a lot harder to read! 

I'll skip MVC for now, as I see a whole review for formatting and the such. Perhaps someone else could break down the pattern for you. Right now, let's focus on each individual class. Model 

Having a log for a production application is an excellent idea. Some quick notes on logging web applications in general: 

I can't comment on performance, as I'm not very familiar with the cURL library and web scraping techniques. However, I'd be happy to comment on other points! I'll point things out in the order the script is ran. 

This results in your and then is ounces, optionally roundable. If keeps drams in your output is necessary, simply repeat the above code but in respect to ounces. What's let over is drams! I hope you're alright with receiving this alternative, instead of heavy review of what you have. But in my opinion, type cast can cause you to lose some of the precision that is lost when moving to integers. 

In example (1), if you needed to handle several different array inputs, then you would be able to differentiate them in . Whereas example (2) would be better if you knew you would only be checking against a single array. It's easier to expand code that's written like example (1). 

Certainly something to think about. With a "find and replace all" command (using a regex perhaps in your IDE) though, much of the hassle could easily be taken care of. 

Very interesting concept, I could see this turning into a "Pimp my Ride" game. A few things before this is sent off to gamers: OOP It seems like you've kind of misunderstood what OOP is about. As it is, you have a lot of variables (not objects) which then are smushed together into a final concept (the car). If you want this to be more OOP oriented, here's some things I suggest: Get rid of all the variables, except . Keep this, as it will represent your "object". Instead of the manufacturer having his own variable (who knows, maybe some car will be custom built or have various manufacturers), use getters and setters to define a property of car. Picture it this way: 

Also, if this is supposed to skip to the start of the week in case the starting day falls on Sat or Sun, I think you should skip ahead either 1 or 2 days depending on which one it is, instead of always skipping 2. 

Though if you really want to be smart, you only need four conversion functions: Celsius to/from Kelvin, and Fahrenheit to/from Kelvin. (or with Celsius on the middle.) Doesn't matter much here, but if you wanted to convert between angstroms, mils, inches, feet, yards, meters, chains, furlongs, miles, light-years and parsecs, you'd appreciate a common "standard" unit to convert from and to. As for the function names, I wouldn't find it sinful to use even something like here, in the case of local helper functions that will not be called from the outside and since the units are so few that there's no place for confusion. (Of course with more units, like the 11 I listed, the latter point would not apply.) 

Also, I'd separate the functions of creating a node, and inserting a node at a given point, since there might well be cases where you just want to move a given node from one list to another, and doing a malloc/free pair at that point is a waste. What if the list is empty The funny thing is, that having a pointer that is when the list is empty, seems natural, but it requires always checking if the list is empty. You can see this in that the insertion functions specifically test for , and you have to assign to in the main program after calling them. It also makes adding in the middle a bit difficult, since if the list is empty, you'd need to change the pointer (to point to the newly added item), but if it isn't empty, you don't want to touch at all, for efficiency's sake. A bit of a conundrum, I'd say. One solution would be to make a separate structure for the list in general, which would contain a pointer to the first item, and possibly some metadata about the list. (e.g. it could cache the list size if that is often needed, and a pointer to the last item to make it faster to add at the end.) That has the downside that all additions would require handing out a pointer to the main structure, and the node being operated on. Having no actual nodes would still be a special case, too. Another way is to just demand that the list never be empty(!). This is easiest to do by having a node that contains some invalid value (a sentinel node), something that is skipped by all functions actually handling the data. Sounds like a bit of a waste, though it's just a trivial version of a separate main structure, with the advantage that this time all the structs and pointers would be the same type. (Or rather, build the list functions such that they don't handle empty lists. The application program could of course have a pointer to a list node, that happens to be .) 

Now when we do the 50k calls, we learn that now the average function time is about 2.6226 E-10 seconds. However, there is a little overhead due to the user function applied over top of the built-in function. By just calling without the function does reduce the processing time, but by an amount so small it's hard to even say it's an amount! Just for the sake of cleanliness, I'd remove the user function anyways. Don't tell me that's not an improvement! However, without this function, I was unable to get a faster execution. I tried , , and . Using for the closure, as that proved faster than 's third parameter. 

Option 2 Have a type searching function to automatically determine the type and assign it. This could be a simple helper function with a few conditionals, each with one of the variable functions. You would want to call the function as a parameter of . Pros 

A lot is repeated. In an attempt to cut back on emit code, I made . It works great. Any ideas on how I could do something similar to clean up the many methods? Because almost every function requires the database, I had a lot of s at one point. I've cleaned them up mostly, but I'm wondering if I'm handling this connection correctly. I was forced to take out the method on . Will this hurt me? (This is what makes the title relevant!) Everything is in the global scope, should I change this? If so, in what way? 

I'm having a hard time deciding what you mean in your question. It's hard to understand... As of now, your class seems to be indescribably complex for such little functionality. You constructor is doing way to much work. It should really only be setting up the class that's being called! Login and authentication should either happen in separate methods, or even separate classes. Have you not tested your class to see if works as it should? To the best of my knowledge, it shouldn't. And it seems unnecessary since you already made your variables public. Which they shouldn't be. I'd also avoid throwing an exception from the constructor. It's uncommon and wouldn't really be expected. 

This means that you're iterating starting from the beginning again and again for every node in the list, i.e. doing \$O(n^2)\$ work, instead of \$O(n)\$ which would be enough for simply iterating over the list. The point of a linked list is that you don't need to know where the end is when you start walking it, and that you can hold valid pointers to the nodes in the middle and do something useful with them. Here, every operation starts from instead. For printing, I'd rather make a loop similar to when you count the nodes: 

As for the code itself, I won't repeat what @Loki stated. But, you're not handling errors fully, a memory allocation error will leave the file opened: 

Straightforward, though a bit repetitive. From a UI point it might be useful to just show all (both) conversion results for the given input value, so the user. i.e. if the user gives Celsius, give them both Fahrenheit and Kelvin. 

Do not put functions in header files. Headers are the public interface to your module, so they should contain the declarations of the public functions and (possible) variables. The C source file is the private part of the module that actually contains the implementation. So, 

That's not bad. I like that the input functions actually check the entered input matches the wanted type. Though in some cases a user might like to be able to abort some action at the prompt, so returning or some default value for an empty input might be one choice. The one thing where I succeeded in breaking it was by entering a divisor of zero. 

I might rename this variable. The code just skipped eight days, it might end up on an , or something like that? (Might want to comment that its eight because there must be a weekend within those six days. This is still pretty clear, but it will get less straightforward if you ever allow for variable skips.) 

Is there any way to refactor out the repetitive and parameters, and the call to ? There are two obstacles to refactoring I can think of: 

this I don't think you need to use the keyword in front of everything. Namespace - Utilities is not a good name space, nor is or or anything else vague. These are namespaces that scream "hey, put any old class in here, I don't care!" would be much better. Dependency Injection Instead of creating a you can have it automatically created for you by dependency injection. But that's a subject for another day :) 

TL;DR; Don't calculate the possible moves every single time. You've overlooked a key concept: the potential moves for a knight on f1 are the same regardless of what move number it is. It doesn't matter if it is move one (the N is on f1 because it hasn't moved yet) or if it is move 199 (the other N has wandered all over the board and ended up at f1). If you calculate the potential moves every single time you consider a move, then you are wasting a significant amount of time - it will always return the same value. And then your chess engine will be very very slow. The solution is to precalculate the potential moves before the games starts, and then for every move you take the precalculated potential moves and subtract the moves that are not possible based on the actual position. You still need the function, and to make the improvements others have suggested, but you need to pass in the piece as well. Source: I have written a chess program. 

In regard to your first program, consider this case: you opt in for Package B, and you end up taking advantage of 10 hours of internet. According to your program, you'll be charged $3.95. In response to this logic error, consider using an statement to decide whether or not the customer/user is above the monthly limit () prescribed by their Package. Also, consider cleaning up your code on line by breaking up the elements onto their own lines. This means putting what's between the brackets on it's own line and bringing the last bracket onto a line. @mdfst13 mentioned in the comments how your logic is wrong in the second program. Consider drawing on paper a diagram for how each output will be calculated. It might look like a tree diagram or a flowchart. 

It all depends, everything has a purpose and a correct time to use it. It's up to you to determine if what you're doing is the best implementation. Would your example be correct usage, yes. However, many people are unfamiliar with late static bindings, and so it could be easy to misinterpret or skip that line if a new developer is reading your code. Perhaps there's a way you could reevaluate your code to see if you can restructure it in a way that does not depend on this functionality. 

Overall, it seems like nice looking code (not nice functioning code, though). The biggest issue is that it's very localized and in fact quite error prone. Developing with this in a year would be a huge pain in the ass! :) 

The parentheses around aren't necessary. And I'm not sure where is created, but it looks like it just appears! In the handler below that, the argument isn't very concise. It's a simple name, which could be more specific, or less possessive (, , , etc.). Directly below that, you have: