Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

For file IO, the way you're currently doing it (saving after each add/remove) you could add it as part of : 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

Now, each filter simply takes an input and transforms to an output. We need a pipe to tie to it all together: 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload. 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Couple of quick comments, since you don't really specify what you were looking for. Seems like everything other than should be ; I probably wouldn't make them extension methods either. I think the whole thing would be better suited to a rather than 3 or 4 coupled methods. Your recursive is an odd implementation that I haven't seen before. It looks like it'd work OK, but doesn't seem standard. Your method seems broken; it never adds the ; I'd probably just replace that class with a or something since it doesn't seem to add much value but could be a breeding ground for bugs. No reason to on ; just return the generic . What happens if or is ? Looks like a , when I'd expect a list of all the added or deleted instead. 

You can get rid of the index variable by using the string pointer for iteration. Also use a loop which is more concise: 

I would also change to which expresses intend better as you only use values of and anyway. Edit: As pointed out in this answer the OPs code (and mine aswell) is vulnerable to buffer overruns. Although OP stated that input will be ASCII only (which is in the range of 0..127), if the string is user input then it shouldn't be trusted. One way the vulnerability could be mitigated would be a range check of the input characters. If they are out of the ASCII range, discard them, replace them by a "dummy" value or do whatever fits your situation. 

Instead of copying the string char-by-char use which is pretty well optimized. It typically uses special CPU instructions that copy multiple bytes in parallel: 

The template is an utility that is used to create a default return type of that has the same character type as the input string. 

Now the convenience wrapper. can be any string range (like ), null-terminated char array or pointer to null-terminated string. The result will be by default, but can be changed to any class that has a member. 

I often need to write string processing functions that take an input string and transform that into some output string. I'm looking for a pattern to make such functions as generic as possible (with reasonable effort). Requirements 

I think creating a new class for that just obscures the code. To understand your code one has to look up what your class makes different from . The suggestions made by this answer are simple enough that they can be used directly in code. Anyone reading this code will immediately understand it then (provided that they know about the standard classes of course). Using (C++11): 

You can omit the implementation of the default constructor if you initialize the members where they are declared. This also reduces a source of error as you can't forget to initialize members when you add a new constructor. 

It can be good excercise to write such thing but in production code I would not like to see "yet-another-string-class". That being said here is my review: 

It makes no sense for to be of a signed type. I suggest replacing by which is unsigned and will be large enough to store the biggest possible object size. On some 64-bit platforms such as Microsoft Windows is only 32-bit, whereas will be 64-bit. 

I currently approach this by splitting the interface into two template functions. The first one is the idiomatic generic interface which is iterator based, the second one is range based for convenience. The convenience interface is allowed to trade some generalism for ease-of-use. Example Escape all occurences of the characters , and in the input string. First the idiomatic interface. 

Basically, just a wrapper around a double. The double is called SIValue, like Standard Unit value. The idea is to keep the value in the unit of the standard system. So Kilogram for a mass, or meter per seconds for speed. Each of the derived class must override the method for specify how to build a new unit based on a value in SI unit. Here is how we use it : 

Now, the questions : First Point : I have defined the SIQuantity as a generic type, so my abstract class contains all the logic for adding, substracting, compare the value, and return the good type. This way, it looks like a hack, since I have to define my generic type to extend an interface I have called ISIQuantity to access the SIValue. This looks weird. Second Point : The mechanism to add two values is typically 'take two, unwrap, add, wrap, return'. 

You use a global private varibale to store the cards, each time you will instanciate a new deck, that list is going to change. So you can't have multiple decks? This is a major flaw in the design. This is an immediate red flag for me. The rest of the code is pretty good actually. I like TypeScript, and you use interface and object oriented design well. Too bad you don't see how wrong it is to use a global variable in your code. And use a linter. I put your code in tslint, I got 49 linting errors, that is huge! 

I find it ugly. The first thing is that each of the based class must define the method CreateFromSI. I tried to find a way to do it all in the abstract class, but since I can't define a constructor or something like that in the abstract class, I have used the kind of factory pattern to build the object. Can I do it in a better way? In a more general way, have I reinvented the wheel? I search a lot on something similar already existing, but I find nothing. I use this code a lot, lot, and lot. It makes my life sooooo much easier. I don't fight anymore, all my algorithm is type safe, I'm confident on the unit of the physical values I use, I unwrap the values when it's time to really use them, like this little method : 

A lot of physical values are passed from function to function as double, and it is a nightmare. I fail a lot at giving the right value at the right parameter, and also at the good units. Sometimes speed is in m/s, sometimes in km/h. So my idea was to create an abstract class for different physical values, like Speed, Angle, etc... Since you can add doubles, you can also add speeds or angles, so the abstract class must support adding, soustracting, all basic operations you can do on double. So here is my abstract class :