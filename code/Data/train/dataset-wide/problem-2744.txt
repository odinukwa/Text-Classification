Once you've found the minimum and maximum, you can save a little bit of computation by not finding the number of unique values; the number of unique values is greater than one if and only if min < max. Are there no separate "greater than" or "less than" comparators? The 5 in 'one patameter passed' (note: should be 'one parameter passed') and 1 and 10 in 'two patameter passed' look like magic numbers. You should define constants equal to these numbers, or pass them as parameters. You have a lot of repetition; you should consider re-writing it so aren't doing the same thing in different blocks. 

General tip: if you're doing an if-then with several elif/else clauses, consider whether a dictionary would be simpler. 

Now you just have to split the hundreds part into 2-digit sections. Instead of doing this one digit at a time, you can do it two digits at a time. 

One big area for optimization is your function. First of all, you should keep track of whether you've already checked a number for primality: 

Your function is incredibly inefficient; you can calculate the number of divisors from the prime factorization rather than checking whether each number is a factor (and even if you were brute forcing, you could improve by a factor of two by realizing that the only divisor greater than half the number is the number itself). Consider the number 24 = 2^3 * 3. Since the only prime factors of 24 are 2 and 3, a factor of 24 can't have any prime factors other than 2 or 3. So a factor of 24 will be in the form of n = 2^a * 3^b. But if a >3, then n will not divide 24. So the allowable values of a are 0,1,2, and 3. Notice that there are four allowable values of a, and this is one more than the power of 2 (the power of 2 in 24 is 3). Similarly, there two allowable values of b. So the total number of combinations of a and b is 4*2 = 8. Thus, there are 8 factors of 24: 1,2,3,4,6,8,12,24. So you should break into two functions. One should find the prime factorization of n, and the other should multiply together one more than the powers of the prime factorization. You can improve the prime factorization function by maintaining a dictionary of numbers that you've factored. Then once you've found a prime factor p of n, you can use the prime factorization of n/p. And since prime factorization uses prime numbers, you should keep track of what numbers are prime. You can also use the fact that the nth triangle number is equal to (n+1)n/2, so you just have to check the number of factors of those two numbers. I recommend checking two numbers at a time, so you don't have to deal with checking which number is even. That is, if you check 3 and 4 in the first iteration, then 5 and 6, etc., then you know that you can divide the second number by two. Also, you can get rid of the "magic number" of 500 by setting a constant . 

EDIT: the above find decreasing numbers with , but it will look at higher numbers first. To get decreasing numbers, I believe this algorithm will work: 

You could do this treating the number as a object rather than a , but I don't see that treating it as a is all that unnatural. 

You could replace the blocks after the block with a case statement. Using recursion in this case is rather odd. The basic structure of your function is: 

You don't need to store the whole previous node, just the value. Also, you can replace checking whether the gap is smaller with , although it's mainly a matter of taste. And is a rather opaque variable name 

Generate an array of n percentages. Calculate the average percentage. Subtract the average from each element. Do a for-loop of i from 0 to n-1 and set 

If the number consists solely of n nines, then the next number consists of n+1 ones. Otherwise: a) find the last non-nine digit. b) Add one to this digit. c) Replace the original digit, and all following, with this sum. 

returns the remainder of when divided by 2. Python is not a strongly typed language, so this remainder can be used as a boolean; if there is a remainder, is truthy, and if the remainder is zero, then it is falsy. So you can replace your with . 

Your variable names should be more explicit. Most of them are a single character, and even the multicharacter names are rather opaque. , for instace, would be more clear if named something else, such as . You're using integers for values, but it's not really being used as an integer. Your code would be more readable if you assigned it strings describing what each state consists of, such as . You're using conditionals where a case statement would be more appropriate. Your last case sets to 2, but I don't see how you get to that unless is already 2. However, since you're progressing through each of the values of , the whole structure of the while loop is inappropriate. You have three things you want to do, and the second always happens after the first, and the third after the first and second. The natural things to do is: 

If you put it in a Pandas Series, then you can use to get a DataFrame containing the data you want. If you want it as a dictionary of lists, then you can just convert it with 

There are two primary use cases of : you want to feed in a variable as a parameter, or you have a large number of elements. When you have , you're feeding in three fixed parameters to get an iterator with only three elements. It would be much more readable if you just put . There are quite a few lines where I don't understand why you have the code you do, such as instead of and instead of (And while misspellings don't affect your code as long as you're consistent, "opponent" has two p's) If you have the same list over and over again, you might want to name it. E.g. On a broader level, an option would be to name each line in which a player can win, e.g. , then create several dictionaries: has lines as keys and lists of squares in those lines as values, has squares as keys and lines that include those squares as values, and has lines as keys and the sum of the squares in those lines as values, where 'X' is worth -1, 'O' is worth 1, and blank squares are 0. Every time someone makes a move, find what lines that square is in, and add the appropriate number to the appropriate line totals. If the absolute value of a line total reaches 3, the game is over. Assuming the computer is 'O', you can then have the computer turn check whether any line total is 2, and if so make a move in that line, otherwise check whether any line total is -2 and if so move in that line. 

When you're checking for failure, instead of asking "is it one of these cases that I've thought of that are bad", ask "Is it not one of the case that are good". Doing the former raises the issue of whether you've thought of everything that can go wrong. What if they enter a float? A string? Instead, do: 

These lines seem to be based on the assumption that all numbers eventually reach 1. While this has been verified for numbers you are likely to come across, it hasn't been proven for all numbers. You might want to instead check whether you've entered a loop. Also I think it's better to explicitly return whether than relying on Python returning the last line executed by default, so you should have . And get rid of the semicolon. Also, you're repeating a lot of code. The only difference between the odd and even case is that in the former case you have and in the latter case you have . The and statements are the same. So you can simplify your code to the following: 

Don't rely on users following your instruction to enter in lower case. Do . Instead of doing , check each possibility separately, and ask again if it's neither (you might want to do rather than `'wet' == conditions in case they put an extra space at the end or something). Since you're going to divide by a non-integer, you're going to end up with float anyway, so it's probably better to cast as a float to begin with, and avoid rounding if they don't enter an integer. You should also do a block to catch people entering non-numbers. 

Maybe I'm the one who is confused, but I think you have misunderstood the phrase "unique words from x". It doesn't mean "the set of words in x that appear only once", it means "the set of words in x, with each word presented only once". So, for instance, the unique words in are . My solution: 

Well, it is correct to say that . Do you really want to add all this complexity to your function just to handle the special case of n<2? It depends on what you're using it for. If you're just wanting to be able to give Rodney the correct answer, he's probably not giving n<2, and if he does, you can just say "not prime" without running the program. You should consider just raising an error when n<2, rather than complicating the output. 

if you're having trouble understanding , consider the case of generating the 7th number. This is going to be 4+7+13. But 13 was calculated by 13 = 2+4+7. So the 7th number is 4+7+(2+4+7) = 2*(2+4+7)-2, which is 2*(6th number) - 3rd number. So the nth number is 2*(n-1)th number - (n-4)th number. This does require handling the first few rows separately. One way is to manually create them, and then if you don't want them, you can delete them afterwards. Note that if you're deleting them, then you don't have to fill in the ratio column for those rows. You will also have to initialize to the proper value. 

One strategy: Do binary split of , and for each split, keep track of the smallest number of that is greater than or equal to the largest element of each branch and the largest number of smaller than the smallest element of the branch. Once those two numbers are adjacent, don't split that branch any more. So, taking your example . I'll split , with scores in brackets surrounding each branch in bold. At iteration 0, I have {[120]( 100 100 50 40 40 20 10 )[5]} That is, I haven't done any splits, so everything is in the same branch. The largest number of the branch is 100, and the smallest number of larger than that is 120, so 120 goes on the left of the branch. The smallest number of the branch is 10, and the largest number smaller than that is 5, so 5 goes on the right. In iteration 1, I have: {[120](100 100 50 40)[25]} {[50](40 20 10)[5]} iteration 2: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20 10)[5]} Since there are no numbers in between 120 and 50, the first branch is done splitting. Since there are no numbers between 50 and 25, the second branch is also done. So the next iteration moves on to the third branch: {[120](100 100)[50]}{[50](50 40)[25]} {[50](40 20)[5]} {[25](10)[5]} Iteration 4: {[120](100 100)[50]}{[50](50 40)[25]} ]} {[50](40)[25]}{[25](20)[5]} {[25](10)[5]} At this point, Iâ€™ve done all the splits I can, and I can just read off the ranks; each rank of a number from is the count of distinct members from to the left of the first instance of it, plus one. 120 is all the way to the left, so its rank is 1. The first instance of 50 has one distinct element of to the left of it, so its score is 2. And so on. The dense ranking requirement means that you'll have to get rid of duplicate members, but other than that this algorithm should be logarithmic time, rather than linear time for your algorithm. 

The initial strategy that I thought of was iterating through possible multiplicands, and checking whether the product is monotonic. You seem to be instead iterating through monotonic numbers, and checking whether they're divisible. This may be a better way of doing it, but it can be implemented in a simpler manner. For one thing, you seem to be re-generating the list of monotonic numbers for each number in . Instead, you should generate a monotonic number, and then check it against all the numbers in . You can speed this up even more by deleting numbers from as solutions are found. Another issue is how you're generating monotonic numbers. Your method is rather convoluted and I don't fully understand it, but I'm pretty sure it's not optimal. Monotonic numbers can be generated through the following algorithm: 

should be moved to right before the elif block that uses it; there's no point calling a function if you don't use it. Also, since there's nothing after all the elif/else blocks, you can just return at the end of each block, and then you can change the elif's to if's (with returns at the end of each block, you can't get to a block unless the previous conditions have been false). Building on Julian's answer, you can do: 

For instance, suppose you have 11239. The last non-nine digit is 3. Add one and get 4. Then replace the 3 and all digits after it with 4, and get 11244. The following code found solutions for 147 out of the 162 target numbers in 86 seconds. Presumably, increasing would get more of them. (and making it less verbose would probably save some time) 

You could also try a regex to create and see whether it's faster. If you want to run this just once per puzzle, you could just iterate through letters, but that likely wouldn't be optimal. 

You don't really need a method. You can simply have a object with a method that randomly picks a card from the deck. Whenever you need a card, a card from the , and part of the method is removing the appropriate card from the . If you have eight players, you'll need to draw 21 cards. I suppose conceptually it's nice to "shuffle" the 21 cards you need before dealing any out, and to include the other 31 cards in the "shuffle", but I personally don't see much value in doing all that work just to imitate more closely how "real world" poker is implemented. You seem to be using for both the position and the value. You should distinguish between the two, e.g. versus . The line is really weird. Apparently you're initializing the pot with the blinds, but are you removing the blinds from anyone's chip stack? You should have a bet method, and "force" the two blind players to call that method. Also, having a method named "Shuffle" that does a bunch of stuff other than shuffling, such as initializing the pot, is bad naming. I think that betting order should be an attribute of the table rather than the players. There's no need for a player object to know what its betting order is; if a player wants that sort of information, you can just pass them the entire table configuration (that is, I can see a player asking "What's the betting order", but I can't see a player asking just "What's my betting order?"). The table should have a blind method that adjusts chip totals for bb and sb, and it should have a method that asks the current player to act. Both of those methods should know what the betting order is, and be telling players when it's their turn to act. If the player objects know who is sitting to their left and right, then you can just have the table ask for a player to act, and then ask for the next player to act, etc. Instead of doing , you can do , and then you don't have to do . Under the hood, this is more complicated, but conceptually it's simpler; the button just moves to the left. Other things such as the betting action can move similarly. Adding 2*cnt to a number and then taking the result mod cnt is a bit odd; should give x for every k. 

I tested the following loop strategy by generating a list of numbers between 0 and 1, and then randomly selecting a number from the list greater than a threshold. I found that as the threshold goes up, the time for the list comprehension strategy goes down, while the time for the loop strategy goes up. The cross-over tended to be at around threshold = .8 . So this suggests that if more than 20% of your word are "long", the loop strategy is faster. However, I didn't exactly replicate your use case in my tests, so the cross-over is likely different. Also, if you're going to sample repeatedly, it's probably faster to calculate the list comprehension once and then sample from it repeatedly.