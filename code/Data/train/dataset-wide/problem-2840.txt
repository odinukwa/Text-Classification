Unfortunately, I am not experienced enough to give you advice on the specific aspects you mentioned in your question, but maybe you still find some of the following points helpful. 

OK, so much for the code. Now, for … The Algorithm Your algorithm works, but it requires a condition that is not necessary for the applicability of the task of finding the maximum frequency of elements in an array. This condition is, of course, that the elements must be comparable, either through their natural ordering, or through a . What's more, this ordering must be consistent with equals, otherwise, the method will be out of control. This greatly reduces the usability of your code, even though the task it carries out is a relatively simple one. But you could simply iterate through the array, counting the frequencies of all elements along the way, and then determine the highest frequency and get all elements with that frequency. That way, you won't have to worry about the elements being comparable, and because your code doesn't do more than it needs to do, it will probably also be faster. Update Another problem just occurred to me: By sorting it, you are modifying the array passed to the methods (in case it is passed as an array and not as varargs), but you don't state this in the method's documentation. This is inconsiderate. You should either specify this in the documentation, or create a copy and sort this copy, or simply require that the array passed to the method be already sorted (like the methods in the class). 

Inspired by azro's answer, I was motivated to squeeze every bit of code duplication out of it. This resulted in a design that is, ironically, even more verbose, but on the other hand allows for great flexibility in case you want to change the temporal units of the output (e.g., don't display seconds) or the type of the Temporals themselves (e.g. from to ): 

In general, your code looks fine to me. You could make and in . Also, you don't have to create three separate objects in . Instead, it would suffice to create only one from and and pass that object to the threads you start, because the objects themselves will never change, only the the point to, and since they all point to the same (which is ), creating a separate for each thread is redundant. And about that : I can't envision a scenario in which an could ever be thrown in your program, but your comment "" implies that you think by merely swallowing the exception, you let the flow of your program be unaffected by it. However, this is not what would happen if an were actually thrown. If your code actually caught an , then it would no longer wait for to die, but instead, the for-each loop would move on to the next thread, if there is one. So theoretically, it could happen that, if an is thrown, by the time you call , not all 3 threads (or however many you start) are dead yet and the guinea pig is secretly still being tortured. To prevent this from happening, you could rewrite the code to look something like this: 

Here is a slightly convoluted algorithm that yields the same result as yours but is faster. It takes advantage of Java's native support for arrays instead of using an internal : 

I'm not sure what you expect from writing an - construct where both the and the block contain exactly the same code. Your method is effectively equivalent to the following: 

OK, so I'll try to review that which you have provided. Since you didn't post all the relevant code, I might have misunderstood some of your descriptions, so I'll base my review on how I understood them. First, I suggest you get rid of the class . The way you describe it, only seems to be a wrapper class for a , without any functionality. I really don't see a point in that. You might as well use a itself whenever you deal with a serialized representation of something. Then, about your empty interfaces. I don't really see why the interface would be useful. As far as I could figure out your description, there is no case where a method parameter can be both a or a , and doesn't declare any methods itself, so it is completely dispensable. The same applies to and . If the and don't even share a single method, then what's the use of them having a common superinterface? Next, I'm not sure if I understand the purpose of the interfaces and . They both return a and , respectively. But if I understand the design of your program correctly, then a message is deserialized using a schema, and a schema is deserialized using a schema format. So why does have a getter for a ? I thought a describes how a schema is (de-)serialized, which means that a is not a property of a , so there is no place for a (or similar) method in a . The same logic can be applied to . Furthermore, I don't think I understand the difference between a and a . If a message might either contain both keys and values, or just the values, then it seems to me that these would be two different message formats, or at least two different variations of the same message format. Since you didn't provide concrete code, I can only make assumptions, but it seems like you scatter a single responsibility over the two classes/interfaces and , which makes everything more confusing. Now about something in the code you provided. You cast to . As far as I can figure out, this is unnecessary, because accepts a as an argument, and not only an . The whole point of this abstraction is that you don't need to know the concrete type of your at compile time because the deserializer will determine at runtime what to do based on the runtime type of the passed . So there is really no point in casting to , you might just pass to the deserializer directly. And concerning the "main part" of your question: I really think it would be easier to review the class if you posted its source code. However, maybe it would be better if you first responded to the points I mentioned, because, depending on how well I understood your description, redesigning the rest of your code might make everything easier to manage. A last thing about your class/interface names. I think names like or are confusing. If I'm not mistaken, a is primarily a format, and a is primarily a parser, and "schema" and "message" only describe the format/parser further. In the English language, this would be expressed with a noun phrase where the primary noun (the "head") comes last and the modifiers precede it, like "parser factory", or "data provider". Therefore, I also think that a better name for these interfaces would be "MessageParser" or "SchemaFormat" (unless I have misunderstood the purpose of these interfaces). This can cause even more confusion when a method name contains a verb, like "setParserMessage" (at least it did for me when I read this method name). Update (reviewing and ) OK, so about your class : There is really no need to declare two variables to hold instances of and , because their sole purpose is to act as intermediate storage when invoking and . You could instead make the methods and return a and , respectively, instead of (and rename them accordingly), and just use the returned parser inside the "deserialize" methods, thereby reducing its scope to the smallest extent necessary. Otherwise, you are littering the heap with unused objects that the garbage collector can't collect because, while being assigned to a field, they are still being referenced by the class (and, in a way, littering the class with unused fields …). And regarding the class , I think this class can be dropped entirely by simply taking advantage of the fact that an can have fields and methods. Each could contain a field with the respective , and each could contain a field with the respective (in the following code example, I'm going to rename the interfaces by switching the order of the nouns, it's just too confusing for me otherwise): 

In the following, I am going to propose a few alternative, simpler notations for single statements in your code, even though some of these examples will be irrelevant after following mdfst13's suggestions because they can be replaced together with other statements by one, simpler statement. 

Now we fill up the next rightmost column in the same way. The upmost element has no value above it, so it is identical to the value to its right. 

Chatton has already explained the general unnecessity of making public, but I would like to point out a specific problem in your code: By making both and , you are putting your list in danger of being corrupted, because with a reference to , one has almost complete control over your object, more than you would probably like (only remains inaccessible directly). So even if the class is , you should still make at least one of these two methods . I also agree with chatton that, if you pass 0 as an index to or , this is simply a special case and there is no more elegant solution for this. If the index is 0, the new node must be set by changing the reference of a 's instance field (). If the index is greater than 0, however, the new node must be set by changing the reference of a 's instance field (). The classes and are unrelated to each other, so using a common method to change that field is not an option. The most "elegant" way I could think of that does not handle both cases separately is by determining the field whose reference to change at runtime using reflection, and I doubt you would call this "more elegant" (at least I wouldn't). I look at your and methods and see duplicate code. Alarm bells ring. Even if it's just 3 lines. You could make a method that returns the at a given index and call this method instead: 

You could try taking advantage of the fact that, if you remove the first and last letter of a palindrome, then the resulting string will be a palindrome too by storing the indices of a discovered palindrome substring, along with the indices of all substrings that you get from that string with the method mentioned above, in a cache so you don't have to check these substrings separately. This means that you would have to check the substrings in descending order with regard to their length. 

I don't think it can get much simpler or more straightforward than your code. One way to improve upon what you already have is to also handle the case that the maximum value occurs more than once. True, the exercise does not prescribe how to deal with this situation, but it's something you might want to consider. You could also choose a more meaningful variable name for , like you did with the other variables. 

Since every value in the lookup table is the sum of the value above it and the value to its right, we can first fill up the rightmost column from top to bottom (since the values in the rightmost column have no value to their right, every value in this column is identical to the value above it): 

Then, you write a separate method that tests that method by constructing a map like you did in , passing this map to and then inspecting the returned . This would be a unit test, because you are testing the functionality of a unit, i.e. the method . 

As for your question of what happens to the intrinsic lock when the is thrown: As soon as is called, the thread relinquishes the lock, which is stated in the documentation of . Continuing to hold the lock would defeat the purpose of , which is to wait for some other thread to do something for which it needs the lock and be notified when that thread is finished with the task and no longer needs the lock, so that the current thread can start trying to re-acquire the lock. This means that, in order to return from and, if needed, execute the block, the thread has to acquire the lock again first. Once the thread does have the lock, however, entering the block will have no effect on the thread's ownership of the monitor. I found this question, which, along with the answer given there, might contain what you're interested in. Update Here's a test to demonstrate that, even if the block is not synchronized, it will still only be executed after the thread has re-acquired the lock, because the thread must first return from , which will only happen when it has the lock it was waiting on.