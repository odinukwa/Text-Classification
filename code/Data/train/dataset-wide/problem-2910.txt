I'm not sure about this condition. There are other states where connection state isn't Open, and yet it should still be closed - see $URL$ I would err on the safe side and try to close it anyway. You could test it, but I don't think anything bad's going to happen if it's closed already. Or you could make it instead. Since there are other possibilities (, , , ), this is not the same thing. 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

Prefixing a string with an empty string makes no sense. (I know what trick you're employing, but "/" does that for you already). 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

By convention, parameter names in C# should begin with a lowercase character. Name of the method is unclear to me, as it doesn't seem to actually "filter" anything. It performs more than one responsibility: asserting whether the code is valid, and providing a default, fallback value if it isn't. I'd move the "lg-3023-1335..." out of it, possibly passing it in as a parameter (, or ) 

That's probably not a practical problem, but for what it's worth it wouldn't work properly if prefix and suffix overlapped. I'd use a regex... I would also include and the expected (but not matching) prefix or suffix in your messages. The more contextual info in an exception message, the better. Otherwise if you don't catch it red-handed, you'd be wondering what exactly went wrong. 

A couple of the things they mention are only a concern for Python 3+ like . Also, it seems is a grammar rule introduced in Python 3+. (However, you may want to account for this in the future.) You seem to be also removing docstrings from , I am not one hundred percent sure, but you may also want to add as well. There is also a . However, I find it rather weird stylistically compared to your current method of looping. So... I'm not confident in making any comments about whether you should be using it or not. Nevertheless, I'm putting it out there so you are aware in case you weren't. 

The reasons for this are described in this answer. You should move your loop into the main function. Refactoring the while loop Don't use a flag. Just when you are done: 

allows you to reference the current object in a nice manner, while also giving you the index that the item belongs to. 

At a quick glance, you do most (if not all of these tests). So in some sense the coverage is good. The amount of testing may be overkill. You have to realize you can't test every possible thing. With that in mind your tests should: 

Your naming of variables is hard to reason about. When I think about what your program is doing you, I come up with the following sequence of steps: 

Take in a divisor count. Index through each triangular number and check if it satisfies the condition. If it doesn't increment and repeat. Once it does print out the results. 

For starters, I feel inclined to go meta and question the design. One possible shortcoming of your method is that it falls back to the default value, which - for primitives - isn't null. So "blah blah" would evaluate to or , and unlike , your method won't tell me if this result actually came from the input, or whether it only reflects the inability to convert it. This could lead to issues with invalid data getting swept under the rug, and as such it's sort of buggy by design (especially when handling dates). The biggest no-no though is that you're not handling exceptions. That's quite a leap of faith when invoking a method by reflection, especially as it's only loosely identified by its signature. I wouldn't blindly trust the return type, or that the method we happened to find actually does what we hope it does. Given that the name of the method promises to fall back to default if parsing is impossible, I would say not handling an exception breaks the principle of least surprise here. 

By convention, names of methods in Java should start with lower-case (so, and - just like and ). Parameter names shouldn't start with "m". There is a - controversial - naming convention that prefixes class members (or fields) with "m". I personally think it's iffy, but some people do that. This convention at least has some logic behind it though, whereas prefixing a parameter with "m" makes no sense. As of now you can pass any class to this method, which isn't as type safe as it could be. If you made it generic, you could narrow it down to subclasses, making it more typesafe: 

Organization As Simon points out, you shouldn't put the list of functions inside of . It doesn't make much sense. Move them out into the class. Use in python is equivalent to in C# and many other languages. This: 

I don't understand it, what do you mean by "create a pixel"? It is not, as of now a docstring, to make it one, use the triple quoted string and put right below the function declaration, so: 

It appears that you are using across multiple threads. I guess you plan to replace it in the future, but still, according to the documentation: 

Is prone to errors when you don't use braces. Python enforces indentation so it is hard(er?) to make a mistake with the lack of braces, but in Java the indentation doesn't influence anything here and some programs will silently "work" that shouldn't and no error message will be given. 

Just use . You don't use , ... that often, I would just use to save space. Although there are many reasons not to make code as terse as possible, adding lots of these variable declarations makes your code hard to read. 

This could be vastly simplified using JSON and the Python library. tl;dr JSON is a convenient way of storing data (in file) that roughly resembles a Python dictionary. (There are also alternatives to JSON like XML, but I prefer JSON). You can also refactor using JSON. Place stats into a dictionary. I would put the player stats into a dictionary so you can make access stats like: 

There may be some others. Please read the link so you can find the issues, or run pylint on your code to correct all of these issues. Structure You really should avoid using global variables unless you absolutely have to. In this case, you don't need them. Classes Given that you have some global state at the moment, it might be a good idea to write a class describing your game. 

Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

It's simplier. Alternatively you could use a regex pattern and get rid of all the injection chars in one go (with ) rather than one by one. I'm not too fond of the name - it's actually filtering the injection characters out. Personally I'd rename it to - somewhat clearer to me - or perhaps just , which is a widely recognized synonym for this operation. 

But why would you assume that whatever time passed between opening the connection and disposing of the entire object, was consumed by query execution? Especially since you do this at the very end, after disposing of the connection, params object, transaction and command objects :) and the object is apparently supposed to be reusable (). Disposing