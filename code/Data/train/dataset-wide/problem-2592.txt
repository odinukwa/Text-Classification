Correctness Although maybe some comments would convince me that the code is in fact correct, I'm highly suspicious of the parsing. is called once per line of input, and inserts a directed edge. Nothing in the supplied problem statement suggests to me that streets are one-way. I also find it highly suspicious that in a completely disconnected graph is going to end up being negative. If it's counting streets, surely it should be zero in that case? 

This was unexpected. The docstring said nothing about , and I wasn't expecting it to be a form of output. IMO it would be sufficient to return if it's complete or otherwise. 

If I'm looking just at the generated documentation and not at the code then it's not obvious what the URI base is. I would have guessed that it includes the scheme, host, port, and a path prefix. Would "URI base path" or "URI path prefix" be a better name than "URI base"? 

Classes in model layers should be aware only of interface of underlying layers (DAOs or something similar). If it contains than you are telling your business model what view you are using. Send text from textfield directly in you service (model) methods. Or better send them some DTO wrapper object. You misused and . belongs to the controller or view layer and belongs to the model layer and check the business requirements. Also you duplicate the name of the cities. When you want to add new city you have to change the model and the view. Put them in one place (maybe something like CityRepository accessed by the Model layer classes) and get the cities from there. So to recap Model is businees view. It should contain validation and perform your business task (in your case some traint icket processing) and should be aware only about data model. View should be aware only of controller and provide interface to interact with and methods how to get the data from the user Controller Drives the flow - it gets the data from view, wrap it in some business objects (like TrainTicket, User, etc...) and pass it to the model, takes output from the model and present it through the view. 

Thirdly, the commonalities between the and branches could be exploited a bit more. In particular, both search for a two-byte sequence. This could be pulled out into a method which can then be optimised once. Although that would mean losing the from the loop in the case, that's a good thing because it's probably faster to use than to manually copy byte by byte. The particular optimisation which I have in mind is to only look at every other byte. If you find one of the two interesting ones then you can look at the previous/next one. It won't be twice as fast, but it might be 1.5 times as fast. There may also be ways of searching faster by marshalling to an array of a wider type (e.g. ) without copying, but I think that would require C++.Net and unsafe code. The subtlety here is how to handle overlapping from the last call. One option, which you may feel is too tricky, is to push it back into . That would give the following structure (warning: not tested): 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

What about having generic abstract dao class which will contain these methods? You will most likely have to create some concrete dao classes anyway to have specific methods. We are using this approach in our projects (behind JPA facade) 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

I presume that you modify the input and also return it because you want to support a fluent style, but I can't actually see any evidence of that here. I've already suggested refactoring this function away, but if I hadn't then I would suggest making it return a new object and treating fraction objects as immutable. That favours maintainability and probably also helps JIT. 

I had to reverse engineer from the case what the meaning of is. A comment explaining it would have been helpful. 

I would prefer to here because it's more consistent with the way Java's and work. Although I'm not entirely sure why there's a method to compare two integers in the first place. 

You say that you're looking for techniques to shrink the code. The simplest one is to not overcomplicate. Consider 

If you find yourself calling the same immutable method dozens of times, you should think about storing the result in a local variable. I count 17 calls to , which I assume all give the same result. (If not, you have other problems!) 

And don't mix classes from primefeaces and dao as suggested in axels comment. When creating this wrapper convert this view classes to some custom backend classes. in some object. I have class. It is much readible and convenient to use. Instead of use CollectionUtils.isEmpty I recommend you to extract nested ifs and loops to methods. Maybe when you extract them you will find some place where you can remove duplication. 

I would separate calculations of shoe sizes and distances into separate classes. It is called SRP Name your variables properly is just a random letter not a name for a variable. For methods with a lot of arguments you can use some wraping object 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

Why ? The code looks single-threaded. Is this planning ahead for multi-threading? Also, code to the interface rather than the type. At the very least, the fields should be rather than . 

Only 90? I'd expect worse! is really quite slow. In the worst case that's going to copy about as many elements are there are in the original array, which means that you've lost the benefit of using a binary search instead of a linear one. If you want to use this conceptually simple approach to binary search then you will get much better performance from . However, the standard approach to binary search doesn't bother with wrapping anything round the array. Instead it keeps two variables to represent the subarray and moves them towards each other until the value is found or the range is empty. (Incidentally that case seems to be missing: does your code have a bug when the value isn't in the array?) 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method.