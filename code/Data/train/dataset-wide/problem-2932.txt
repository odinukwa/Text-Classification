Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: 

All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

It's very explicit. It's clear as to what cases are invalid, what the reason why they are invalid, and which cases are valid. It's maintainable. If cases for validity/invalidity need to be added or removed, the line is simply removed from the fluent calls (along with the function for that rule, assuming that approach is even used). It's extendable. If new entities are taken into consideration (maybe dice, or a coin flip), simply pass it into the rules engine. Frankly, the rules engine doesn't even need to be built here! It can be specified elsewhere. 

(Not tested, but hopefully you get the idea) As an example of how it might "beautify" your code, it would transform this: 

IMO, this is a step in the right direction, since the rules are very explicit now. Of course the would return itself for each of the calls to and , checking if an end condition is met (the would have to manage this state as well). would just set the end condition to if its argument is , would set to . would do exactly what it says: return the validity (the end condition) and update the next . One additional step you could take, at this point is to create functions that "name" each of the conditions. Like such: 

I don't want to give away the answer, so, hopefully these tips will suffice to get you in the right direction. 

I'm new to Clojure and macros so any thoughts on this code would be appreciated. I have a few concerns that you could start with: 

Then and could be changed to accept a function rather than a boolean, and pass along the game context (which they should construct from values passed in ). That would change the logic to look like: 

Overall, I hope some of this helps. If readers have any feedback for this review itself, it would be much appreciated. 

"Beautiful" is a tough, highly relative term. I can think of something that might simplify it (at least slightly): you could extract your common error handling logic into a function that takes a callback. Like so: 

I might also suggest you extract your query (I'm assuming it's some NoSQL query) into a variable, simply because they tend to clutter up the code when inlined. In my mind at least, I should be able to think about "getting the data" without thinking about "how the data is gotten" and vice versa.