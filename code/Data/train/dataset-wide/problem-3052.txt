That's the general principle behind getters and setters. You should be able to extend that logic to all of the other methods as well once you understand the logic. 

Also, if possible, could you give the variables better names? The first three are fairly self-explanatory, but once you get into all your random letters, it gets pretty hard to follow what you're trying to do in your code. For example: 

This might give you a bit of performance where you don't need to bother going down into the and methods. Also, is there any way you can get rid of that cast? Probably not, but that would speed you up ever so slightly. 

Just wanted to say that this is a perfect example of the kind of method that belongs in a "utility" class. It's completely divorced from the actual game and really is just a helper method. Great. 

Overall, your code looks pretty good! I'd say if you want a more thorough code review of your abilities, you should write up some code that doesn't simply call these external methods. It's hard to get a good feel of whether you know good programming/Java habits when all of your methods only call other methods that have been written for you. With that said, my primary qualm is with your method names. In general, you should always design your methods with the idea that someone else will be using them in the future. That means they should be as self-explanatory and intuitive as possible. For example: 

Your code is actually pretty good overall. I have one very big question, though: why do you want all these to be inner classes? Normally, we use inner classes only for a very specific reason and only if the class in question is a critical component of the outer class and somehow inseparable. Usually, this is done with enums, for example: 

You don't have any input validation here. Meaning if I type in , your program will break. Not a big deal for a beginner's program, but you can start to look into Exception handling as you progress. 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

Same thing here. Since we're going to be getting multiple integers from the user, we may as well encapsulate the processing. 

This is only my third Python script. Be brutal with me. Any tips, tricks, best practices, or better usages would be great! 

This controls the flow of the program based on normal execution. It should be pretty easy to see why this isn't ideal, simply for code readability, not considering aspects like performance, style, and best practices. What you have in the above code is fine. Throwing Exceptions for errors is what they're for. If you're throwing Exception simply to break out of loops or functions or are using them during the "intended" execution of your code, that's when you're going down the wrong path. 

For an example intrinsic to the Java API, you can look at Thread.State. Here, it doesn't make any sense to have a Side without a Coin, and it makes the code more understandable to always reference a coin's side as something like . We don't get much added benefit from extracting it into another class (i.e., ). Would you say this is the case for all of these inner classes? My personal opinion is "No." You're even creating whole hierarchies of classes in here, with your and then having other inner classes it. All of this is a bit complicated and all over the place for the function of a single class. This is often quoted, but it's true: remember that a class, just like a method, should do one thing, and do it well. Consider extracting some of these classes into their own files, if you see fit and think it will clean up the code some. 

This code will return if I pass in for both and . Is that intentional? It's unclear from the way you've written your code that that would be the desired result. When I think about it, it makes sense that the method would return in this scenario, but I'm not sure if you understood that consequence when you coded it, just based on the style. 

Name your variables more descriptively. Never copy-and-paste logic; if you find yourself doing so, make a new method or analyze why you're repeating it. Don't pass around components if you don't have to (like es). In general, Swing components are global variables. Follow appropriate code formatting. (Proper tabs, indentation, spaces between brackets, etc.) Don't create unnecessary variables (i.e., ) Perform validations and error handling while doing dangerous things like downcasting. 

One last note: I could have just had them all be statements as well, since each only returns and removes the method call from the stack anyway, but I find that it makes the code more readable to have s, since it means the conditionals are logically joined to the reader. EDIT: I actually had to expand the initial checks slightly. Technically speaking, given your rules, if the is passed in as , it should return , not the empty string. 

Use of : In my experience, any time I have to use , it's indicative of bad design. You should either be using local variables, function arguments, or the constant should be well-defined and not hidden by any local fields. 

Below is another version which is a bit more advanced because it uses an enum, Reflection, and Generics. I like this because it makes getting a valid car size from the user and retrieving a from it much cleaner and ties all the data together nicely. It also prevents me from having to make , , ... etc., etc. It may be a bit over-engineered for this particular example, but it was fun to make. Figuring it all out is left as an exercise to the reader. :) 

Notice right away how my variable names tell you exactly what they represent. It's very easy to know what I intend each one to hold. If I had just named them , , etc., or something even more arcane like , it would be much harder to understand. Java is by nature a verbose language which encourages explicit names for things. 

Not a bad start at Java! :) Below are some comments that I hope can help you improve. Some big things: 

Notice how much cleaner this is than having the constant pairs of and ? It's because any processing which is repeated over and over can usually be encapsulated in its own method. This makes your code more readable and reusable. Let's skip down to the method to see what that means. 

Your code is really good and very well written. I think that's why you haven't received a response; not much to critique! You have good comments, good style, pretty much good everything. I wish I saw code like this in my production environment. The only thing I noticed that you might clean your code up a bit is this part: 

This entire block is very difficult to scan. What it does isn't readily apparent by the way you've named all your variables. For example sounds like the rightmost node in the tree, but in fact it's the left node of the right node in the tree. Then with all the subsequent processing, it's very confusing without stepping through line-by-line to get a better understanding. Consider renaming your variables to be more meaningful. In my opinion, the most beautiful and elegant code is self-documenting. Also, if you were looking for ways to further improve the code's functionality (besides adding recursion), you might look into generic types so that your nodes can hold any data, rather than just an . 

This entire method will be refactored below. But basically you don't need two loops, since you're just looping through the class's fields. This also eliminates the need for the overarching constants for the field names and the method signatures, as you'll see. I cut your code length by about half by doing all of the above, and I think it's generally more readable and understandable this way as well. 

I'm sure you're fine with this, but just be careful with unsafe casting! :) I like to check whether the cast is valid with either or, preferably, . 

The Sieve of Eratosthenes is one of the most efficient prime-finding algorithms out there. If you really want a program with good performance, make sure to Google the clever methods that have already been devised. "Don't reinvent the wheel" is a common programming mantra. As far as your implementation, there are a couple of simple logical notes (which I believe are covered by the other answers): don't check even numbers at all (increment with rather than ), and don't print until/unless it's absolutely necessary. To address issues in the comments below: Division into the constant value is computationally trivial compared to the process of actually finding the primes. It's the finding that we want to speed up. After all the primes have been found which are less than the desired number, we can iterate over them from highest to least and find the largest one. It's pretty straightforward. 

It seems wasteful to check the conditions twice through each iteration of the loop, and I feel like there ought to be a better way to accomplish what I want without the vague code smell. Anyone have any cool tips or tricks to make this more elegant? It also prevents me from using an enhanced for loop, which makes me sad. is a . Also, for those saying I should just join all the s with , that's not an adequate solution. Firstly, it doesn't actually address the general coding practice. Secondly, when writing to a file with a , it's important to use rather than writing a . 

In general, you should try to have more descriptive method names. Following Java naming conventions, they should always be verbs or verb phrases. It just makes your code more readable and easier to follow. For example, this could be called or something. 

I wrote this script a few days ago to find all files which were taking up over a certain threshold of memory on the hard drive. A hard drive on one of my computers had just 6 GB left, so I needed to clean some space up. I used this to identify bulky folders to find out where the problem was. Is there anything I could have done better? I'm particularly displeased with the exception handling in the function, since I ended up handling the same exception twice, just at different levels. Couldn't think of a way around it off hand, though. Also, efficiency was an issue with this script. I know I could've invented some framework to keep track of all the folders previously scanned, but that seemed like a bit too monumental of an effort to make for such a trivial script. The recursion was much easier to implement. Any and all suggestions are welcome! 

That's just my particular style, but even if you don't like mine, there should be a consistent structure you use throughout your code. 

Constants should almost always go at the top of your classes rather than being spread out through the file. Same with inner classes, as a matter of fact: group them all together either at the top or the bottom of the main class. In general, I tend to lay out my classes like this: 

Your code certainly seems to do the job (assuming that the tree is only a root node with two branches; otherwise you will need to implement some recursion). It doesn't "feel" very Java-esque, but you've said in your previous questions/comments that you don't really want critique of method and variable names, so I'll try to avoid that. 

Without having written the code, this statement takes awhile to figure out. It would go a long way to have meaningful variable names rather than random letters. Java is supposed to be verbose, so don't be afraid to make it so. I won't say I understand what your code is doing with 100% certainty, but you can see how something like this is a bit more understandable, hopefully: 

It's a bit hard without the full context of the method (or even the entire class), but it looks like this will have the functionality you want (assuming and are the two "safe" directories that you're checking for). I have a couple of tips for improvements, though they're not major. Your set up for and seems a bit more convoluted than it needs to be (again, this could be because of the method's surrounding context, though). There's no need to even hold a reference to , it seems like. You can do something like the following: 

Here you are attempting to do some error handling, which is good. In your comment you say "You cannot set selected item [in] a [JComboBox] with a negative number". And that's very true. But notice that you already do so before you perform your error check. First you call and then you check to see if is less than zero. But at that point, your code has already broken. Always check for valid data before doing anything else with it. Now I'll show you step-by-step how I refactored your code and present you with the final version at the end. 

This will let us set the references for each missile type upon initialization. With these references, each missile will be able to calculate its values on its own. 

You're doing like four things here. You're comparing to produce a , extracting an element of a list, performing a slice operation, and printing a value. Again, it seems obscure because it is obscure. I can't even begin to trace out what you're trying to do in your first line of code, unfortunately, or I would. I have a story which demonstrates the point. On one of my more recent projects at work, a contractor had produced some code with several nested ternary conditions. It looked something like this, in one line of JavaScript: 

Follow Java naming conventions. Class names should have , and variable and method names should be . Also, class names should be nouns, and method names should be verbs. For collections, the overarching interface is usually used. (i.e., ) Not really that important in my view, but it adds some style points according to some authorities. Most of the literals should be true constants. So for example, you would have at the top of your class, and then call . It doesn't matter for this small application, but for large-scale projects this will allow you to change the setting globally just by modifying this one value. Otherwise, you'll be doing a lot of digging through your code, and you're guaranteed to forget to change that one spot it mattered most. Every. Single. Time. Why are you bothering to convert the into a before returning it? You may as well just change the return type of the method to . In general, it's best to avoid primitive arrays and use these data structures. And they can also be used in the enhanced loop in your method. You should hardly ever swallow s and do nothing about them. Again, it's pretty trivial in this case and doesn't really matter, but if you're looking to develop good programming habits, start logging and doing safety checking and all that now. It'll make your life a lot easier down the road.