Naming / description You describe your code as an "SQL Prepared Statement Factory". That suggests that it helps one create prepared statements, yet that isn't what it actually does. It is more or less analogous to a prepared statement itself, albeit with none of the pre-compilation advantages that JDBC s typically provide. Parameter types Your query factory accepts only Strings as parameter values, whereas SQL recognizes a variety of data types, and most databases recognize an even wider range of types. It is not safe to assume that presenting a string representation of a value of some other type has the same meaning in your query as presenting a correctly-formatted literal of the correct type. Furthermore, the syntax required for values of various types varies from database to database. This presents a serious problem for implementing a generic query factory that does not ultimately rely on an underlying JDBC driver. Your code seems to rely on the user to format non-string values appropriately for the target database. Quoting Your code seems to express the odd idea that quoting is necessary only for values that (may) need to be escaped. I guess the idea is to work around the lack of parameter typing by expecting the user to request escaping for parameters that should treated as SQL strings, and to not do so for parameters that should be treated as the verbatim text of SQL literal values. That's crazy. For one thing, if you want to have special treatment for parameters that are to be taken as string value contents, then I would strongly recommend an altogether separate method for setting the values of those parameters. As it is, your API is unclear and a trap for users. SQL string values must always be presented quoted, but a user of your API who wants to insert a String parameter value that they are confident does not require escaping (maybe because it's a Java String literal) might think they can set it without requesting escaping, but they must provide their own quotes in that case. On the other hand, a user who wants to insert a non-String must be careful to specify non-escaping lest their value be unwantedly quoted in the generated query. Security For another thing, the possibility of feeding arbitrary unquoted text into query parameters severely undermines the main point of a class such as yours, which is indeed the point on which you explicitly sought feedback: 

and the answer is certainly "yes". Other than broad generalities such as I have given so far, however, code review is not really a good platform for what essentially boils down to designing a complete replacement for your present code. From here out, therefore, I focus on the code you actually presented: 

The actual palindrome search uses an exceedingly naive -- but clear -- algorithm. For each length from 2 through the length of the string, you test each substring of that length by extracting it as a , computing its reverse, and comparing the two. Note first how many redundant reverses you are performing. You need only reverse the whole string, once, to obtain the reverses of all substrings. Note second how many redundant palindrome checks you are performing. Given any palindromic substring of length greater than 3, the string obtained by removing the first and last characters is also a palindromic substring. You don't need to find all those inner ones separately if you structure your search to find the palindromic strings centered at each position. Note also that your approach creates and discards a rather large number of temporary strings. It does this mainly because it relies on to do its comparisons. You could build a much more efficient approach by: 

Code Style As @coderodde also remarked, you should import specific classes. Wildcard imports are for throw-away code and early development; no later than when your code is approaching completeness, you should replace any then-remaining wildcard imports with specific imports. There are tools that can help you with that. Also, format your code consistently. Your indentation and placement of spaces are irregular. I find code much easier to read when there are spaces on each side of every binary operator, but if you prefer not to use such spaces then at least be consistent! I/O For what it's worth, unlike @coderodde, I have no problem with for your input. For input whose form is so simple, does not provide much advantage. Performance This is the main area of concern, and indeed I do not find it surprising that your code ... 

... and everywhere else print to instead of to . Doing that cut my run time by more than 50% relative to the original code, for a maximal-size test set. 

Sieve implementation The Sieve of Eratosthenes is a reasonably good choice. There are other prime number sieves, but the SofE is pretty simple to implement and surely adequate for this task. Your particular implementation could be more efficient, however: 

That initializes element 0 to 0 (== false) explicitly, and all other elements to 0 implicitly. Note in particular that that does not involve an assignment. C does not have whole-array assignment, and is not an array literal. 

Sure. There are various minor tweaks and tricks that might shave off some cycles, but the biggest win would come from choosing a better algorithm after all. The resulting "improved code" would not look much like the present code. In the code you've presented, you count palindromes by testing every number in the given range to determine whether it is palindromic, keeping a count of the successes. That's very straightforward, but it costs O((max - min) log max). That's not very efficient, especially if the range can be large. It would be far more efficient to compute the number of palindromes via a combinatorial approach. Consider: 

That's still O(n2) in the worst case, but it cuts out a lot of excess temporary objects (duplicate palindromes are now the main source of unwanted temporaries), and it avoids all the unneeded reversals. Fine details In , there is no need to perform a null test on before closing it because there is no way can be at that point. The bounds on the inner loop of don't capture the true limits. This is evident from the fact that you compute at the beginning of each iteration, and if that is too large. That's actually bad two ways: not only is the loop's termination condition deceptive, but you perform a bunch of do-nothing iterations that you could easily avoid. That is, instead of this ... 

That can be computed very swiftly. It gets a little trickier when the upper bound is not a power of 10, but note that the only tricky part is counting the in-bound palindromes with the same number of digits as the upper bound, and even that's not so bad. The count of smaller palindromes can be computed exactly as above, and can even be tabulated if you wish. You don't need to worry about accounting for upper and lower bound at the same time. Given a function built around the approach outlined above, you can count palindromes between and , inclusive, as . Even without tabulating or re-using anything, the asymptotic complexity of this approach is O(n(log m)2) for n ranges with upper bounds not exceeding m, which is much better than O(nm log m) for your original approach. 

Convention Package names should be all lowercase. Yours (Palindrome) has an initial capital letter. Implementation / efficiency You asked specifically about efficiency, and there are indeed several opportunities for improvement here 

That can be implemented in about 8 lines, as opposed to your 100-ish, with those 8 being largely self-documenting. Or just a few more if you want also to output the per-position messages that your current code does. Impossible / incomplete results Your simple approach to filling the board affords results that could never arise in a real game. The example run you presented in fact demonstrates this: players 1 and 2 both have threes-in-a-row. This may not be a concern in practice (i.e. that may be what you intend to do). You also do not produce representations of many of the possible games -- specifically, those that end in fewer than 9 moves. This, too, might not be a concern in practice. Spelling You're at least consistent, but in English, a flat surface for playing a game upon is a "board", not a "bord". The misspelling makes no functional difference, but it is distracting. Code style The code style is pretty good in general, but the most widely accepted coding conventions call for class names to start with an initial capital letter: . 

Code structure The nested loops obscure the structure of your code. In method , all iterations of middle loop are being performed during the first iteration of the outer loop, before the rest of its body, and all iterations of the innermost loop are performed during the first iteration of the middle loop, before the rest of that loop's body. That's effectively three separate, unnested loops running in sequence, and it would be much clearer to write it that way. Variable scope and protection Class has multiple instance variables that should instead be local variables of method . In fact, the only ones that appear to make sense as instance variables are and , and possibly also . The others have no business being part of the state of a ; they are details of a particular run of method , and therfore should be local variables of that method. Furthermore, few, if any, of the variables that are retained at class level should be . As a matter of style, convention, and good practice, member variables should normally be , with accessor methods where appropriate. There are exceptions, but you've presented no reason for me to think that any of those are in play here. Improper use of You initialize a new instance of for each random number you want to generate. This is at best wasteful, but it may actually be biting you by producing results much less uniformly distributed than you presumably hope to get. The correct approach is to instantiate once, and then to draw all (pseudo)random numbers you need from that one instance. Convoluted algorithm You're just filling the board, not simulating a game move-by-move. With that being the case, there are far simpler ways to go about the task than the one you have implemented. For example,