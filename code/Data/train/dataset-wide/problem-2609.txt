I just noticed your edit, and I'm wondering whether the NULL checks are even necessary, since I don't see any NULLs in your sample output. I also agree with the comments that this code indicates issues elsewhere, and that simply focusing on this method is not enough. 

In one and the same LINQ method you first convert SharePoint s to an anonymous type, and then convert those to s. This is something that really should be happening in a separate class. Moreover, it should not be a two-step operation: convert those s to s directly. 

I can't help but feel that this is a hacky way of something that should be done with for instance and etc; Consider this (I'm assuming is a global variable of the class that contains all of the code in the ): 

The column names you use in are also appearing in . These are "magic strings" and should be constants, stored in a static class. 

Please read up on the capitalization conventions: methods -- for instance -- should be PascalCase. But this method name also exposes how deeply your application logic is tied to your UI, and that's a bad thing. If you had used WPF, you could have implemented MVVM but this kind of separation is much harder to do in WF. 

The moment you start copy-pasting code and only changing one small thing, it's time to move that code to a method. 

Hmm, I just noticed the resulting JSON is quite odd. Why not include the when you're constructing the -level ? 

To me, suggests a collection, but instead it is a class. Make it easy on yourself and call it... a . 

So it sounds like they want it so you can add a mouse to the choir and it will only squeak, and a cat will only meow. Instead you have a single choir which randomly picks a sound to make and no distinct objects for the animals. I suspect they were wanting an Animal to make a single noise which is specified upfront in a more object-orientated way. Something like this at a minimum: 

You can increase the readability and reduce the number of checks required in your if block by performing each of the four booleans you get at the start, then checking against them instead of performing it over and over as well as separating out the check then reveal logic into its own method, like so: 

As this part of the question has been skipped so far, I'll take it: Do you think this is too hard? I think it is. Similarly to your game, in classic Mastermind, the player has to guess a combination of 4 non-unique coloured pegs, and each time is given a mark for the number of correct position and colour combinations. 64 = 1,296 possible combinations However, with your game (to borrow the nomenclature), there are 10 possible pegs, and as they're unique the combinations are: 10 x 9 x 8 x 7 = 5,040 possible combinations Which is an increase of 288.8%, furthermore you're only giving the user 5 attempts to guess, as opposed to Mastermind's 6, 8 or 12. The reason Mastermind plays with a minimum of six, is that you get to test every combination, e.g: 

And manually implode some queries with it. To make it generic, have a method which removes vowels in this way, such as: 

Now all I needed to do was assign the proper values to the properties, and pass this class to the method where I needed to use the parameters. Is this the ideal way? Not if I had to create a dozen of these classes, no: then I'd made sure to use reflection to figure out the type of a property so I could return the proper OracleDbType, I'd have used an attribute on a property to store the parameter name, etc. 

Why aren't you using an ORM like Entity Framework instead of this ugly, needlessly generic code? I mean: , -- really? 

Disclaimer: I'm a C# developer and I haven't written Java in ages. First of all I'd move this to a separate method, with as parameters: 

Your comment style is inconsistent. I'd put the on the line above the method, not next to it on the same line or below in the method's body. Also, is it even necessary? 

I can't say much about the code, since there's so little of it. It doesn't look that good, to be honest, and I'd certainly move it to a specific method since both blocks seems to be part of a much longer method. 

If you want to keep it a method, you'll need to change its name since a method name should contain a verb. More worrying to me is that you repeatedly call this, so it is repeatedly calculated, but this is pointless since won't ever change. Right now if is 10, gets called over thirty times! If you don't need to expose this it could simply be a private field which you set in the constructor . Even if you need to expose it, I'd still advice you to set a private field in the constructor and have a -only property to expose it. 

The first thing that jumps out is all the Strings you have which are reused throughout, those need to be removed and ideally put into constants so you only have to change them in one place if you ever need to rename them: 

This way, you don't have to override every time, and you also don't have to put "ERROR" into the actual text of the exception. 

You do a lot of mapping from parameters to arrays and vice versa, which you could simplify by storing an array of the parameter names and whether or not you want them trimmed, for example: 

If number of lines is your primary concern, then really all we can do with this is merge your array creation lines, and use to create temporary arrays which you can loop around, like so: 

Obviously the on every iteration is inefficient, however as I need to maintain a counter, an enhanced loop means keeping a separate counter and performing a check on it every time like so (list declaration skipped for space): 

Though even this is pretty sloppy, depending on the amount of time you have I'd probably go deeper and write out the standard s and es they're looking for with these tests: , (for all the validation methods), , , etc. 

If you want all your exceptions to follow this style, then you could have one parent Exception class, then make your application exceptions extend it, like so: 

What I have so far seems to work fine, apart from the aforementioned issue, though the amount of code for what sounds like such a simple function is far above what I'd hoped, so I'd really appreciate any ideas on how to reduce it. 

Is there a reason why you use WinForms? Quite frankly I feel the technology is outdated; WPF offers you far better ways to do the same thing. For instance, you can use MVVM. 

Your constructor is 50+ lines. That's far too long, IMHO. Some of it should be moved to private methods, but I'd urge you to keep lean and move the logic in your constructor to a separate "Creator" class. I'd make into a class of its own as well. (Why is this a method?) Perhaps also look at replacing it with a and finding a more elegant way to fill it instead of a 70 line . 

Aren't there batch methods available? Can't you cache data for movies in a local db or an XML file so you only need to look up movies that aren't stored in that db or file? Also: are you seriously retrieving "image-unavailable.jpg" every time? Why? Do you expect it to change form one second to the other? Why not get it once and store it on your HD and retrieve it from there? 

First of all, there's the inconsistent behavior: in one case the is either or it's an empty string, whereas in tow other cases it's a name plus a relevant suffix, e.g. or . Equally inconsistent is how you fill : this can contain or an empty string. That's not an expected behavior. Also, it's bad enough that a bool has to be converted to a string, so why not use the available tools, i.e. change this line to ? 

Also, why does return a which you then immediately have to convert using ? Avoid working with the likes of and instead convert data from your database to custom classes as soon as possible. Why not use an ORM like Entity Framework or NHibernate etc.? That way you also don't need to have ugly code like (yay, magic strings!). 

Additionally, I'd suggest reading up on your SQL for a start, this whole thing screams out clause. In every case, your database will be more efficient at sorting the results than whatever programming language you're using them in (and certainly PHP). Such as: 

I've been implementing a custom internal server error page in ASP.Net MVC which will check if the current user is either an administrator or accessing the page from localhost, and if so, show them a whole bunch of details about the error to debug it with, otherwise just send them to a basic HTML error page. So far, it works great, but one problem I had was that if there is an error in a partial view on the page, the system gets stuck in a loop trying to report the error. To avoid this, I'm storing a temporary counter of how many times the current action has requested the error page in , but I find the amount of lines and style of the code to get, set and check this variable a bit verbose: 

You also haven't got any access modifiers on your methods. As directly prints out a segment of HTML which wouldn't be valid on its own, I'm guessing that it's probably only used once somewhere in your View and as such should be or to prevent misuse. As for the actual code, aside from collapsing some statements there's not much to change. These lines in don't appear to be doing anything though: 

However, when you increase the number of possibilities to 10, and reduce the guesses to 5, you can no longer do this, and the chances of never guessing a correct number increase dramatically, e.g.: