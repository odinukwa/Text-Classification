A small optimization would be to use an idiom recognized by many compilers for comparing two numbers. 

Some quick reviewed parts using a compilation with warnings fully enabled. What is a bit cheesy about this is that a grader could first take your code and run it through a compiler with lots of warnings enabled. Your code made about 80 warnings. Lots of minor ones. Some of the more significant ones are summarized below. But is is like a term paper with spelling/grammar errors. All those warnings (some minor, others trivial) distract from your presentation. Advice: Compile code with maximum warnings enabled and clean up code. 

Candidate alternative . The commented out is on the right track, yet it should divide by . Code should also be careful how to convert to floating point. With the below code, small values retain more precision than OP's code. 

General: Do not use for values. Either use and functions like or use . When is close to , OP's approach suffers severe loss of precision due to the or . More numerically stable code posted. Still needs some divide by 0.0 checks. 

Small simplification with . Using a instead of allows a simplification that a compiler may not catch. Similar with 

Pipe creation and usage Although there is much good error handling, fails to check the return value of . 

I have found a sample usage of the routine (maybe in the header file) surrounded with a useful asset. 

I'm leaning that may benefit with being . Have to ponder that more. For easier to read semantics, consider a clear function. has more clarity than ("setting the error" of "OK error"). Further looks contradictory. Perhaps ? 

The use of for width is relying on integer types being 64 bits or less. Highly portable code would adjust this. It is not unreasonable to see an upcoming compiler use as 128 bit. is not necessarily a signed type. Instead of , would have made more sense. Further, is not necessarily the matching numeric specifier for . Likely need conditional code to handle well. 

Good that initial coding attempt is to save type . Saving a generic type has pitfalls that are best handled after mastering the basics. (OP is very close here.) I'd declare functions after non-static functions in preparation for moving the non- functions into a "darray.h" file. is OK and recommend to follow that idiom. This is even more important should the code set functionality tolerate/detect in other functions. 

Given above issues that a compiler should have reported, it implies compilation is not done with warning fully enabled or code is using non-standard C. Recommend fully enabling all warnings. 

If user enters the coefficients in order, code gets nice and tight. No need to save all the coefficients and no need to limit them to 10. Calculate the sum as you go. BTW: Always good to check the results of . 

Minor: not needed, --> Style: I favor the style of rather than . Nice to begin with as that insures multiplication is done at least as . 

There is a discrepancy between "ascending digits" and . The first implies "135" is acceptable as the digits are greater than previous, but code implies they need to be sequential. Assume sequential. The requirements are silent on single digits sequences. Assume acceptable. Check the return value of . Maybe make this the function's return when non-zero. 

Use type to index arrays. It really is the best type for arrays being not too wide nor too narrow. may be insufficient. 

No need to perform type shortening - no space not code savings expected. Use the type of the functions return/use, in this case. This avoids automated warnings about shortening/sign-ness change. Recommend to use the sizeof of the de-referenced variable rather than the size of the type. Easier to code, review and maintain. 

Style: explicit initialization of global values, even when 0. Although not needed for functionality, global variables are 0 bit filled, it self documents that indeed these variables are meant to be 0 and not a coder's oversight of a forgotten initialization. If these globals are not to be used by application code, make them static. 

Goal: "Your implementation of check must be case-insensitive." If limited to , converting to lower or upper makes little difference. When using extended (8-bit) character sets, robust code would use a round-trip as extended alphabets do not always have a 1-to-1 mapping. 

Missed detection of : returns an with values in the range of and the negative value of . Saving that result in a loses distinctiveness should return due to becoming closed or input error. 

Out of range constant. is out of range of most compilers, even when exists. Portable code would use a different way to set the as well and a different type. Good that it work for you. 

Allocation woes. needs enough memory for a null character terminated string. This implies a +1 to the addition. The cast of is not needed. Multiplying by the size of a pointer is wrong. It should be by the size of an element of , which is a . should be rather than , but that make s little difference with small strings. 

Same code loses precision near and total loss of precision near . The same line of code unnecessarily loses precision. To improve #1, 2 and 3, rather than being a power of 10, just use integer values and add to . This will greatly reduce but not eliminate issues near . There will be less precision loss, but not fully eliminated. IOWs, the generated will be closer to the best one. [Edit -->] Another simple improvement: Rather than , use . This will allow precise calculations near the extremes of without undo over/under flow. Quality assessment. Unknown - but should not be. Part of writing a good is to test its correctnesses. By renaming this to and testing against the standard would be a first step. Then rate how close the two functions are. This post omits any statistics, so I assume none have been done. With any math functions, such an analysis, even crude, should be attempted. Note that such test code can be much more code than this and it is work. If truly interested in improving your algorithm, refine it with by first writing a good (using only math) and compare that against . I do not see clear consensus about use of sign on so may or not be needed. Also, that code might not provide result in . Consider using . One of those FP corner cases. Pedantic: expects a value in the (or ). With a signed , the below is a problem with negative values. 

Concerning "I would love to get rid of the outer while loop". That loop exists to silently consume . If you want a loop to do that, just preceded inner loop with 

House keeping Good coding practice would free in the end. Of course, such allocations are implicitly free'd when the program ends. Yet with an explicit , someone re-using this portion of code would benefit. 

[Edit] Sample aligned allocation code which uses : "an object type whose alignment is as great as is supported by the implementation in all contexts". C11 ยง7.19 2 

All uppercase variables names like will often be reviewed by coders as being macro constants. Better to use or , etc. 

In a couple places, use to allow wider application of the functions that are not changing the referenced data. 

Concerning . Any parsing that lacks a scanned digit (or inf or NaN) should flag an error. E. g.: , , , , etc. 

Could employ Information hiding. If the declaration of the is not needed in the header file, but only in the .c file (or a local .h file should the implemented functions exist in multiple .c files) Of course more helper functions to read/write the fields are then needed if user code need to know those fields. With this code, it does not appear that access is needed, so hide it. Use the easier to write, check and maintain allocation paradigm: allocate to the size of the referenced variable, not the size of the type. Also cast not needed. 

Use error detection With non-numeric input, and following code will not function as expected. Handle bad input. For now, simple whine and take your toys home. Later you can add more sophisticated error handling. 

Use of as Code uses return value of to indicate an error, yet a is not necessarily wrong in a general sense and so with a return value of , it is ambiguous if that is an error or ? To support , the architecture of this code may need significant re-write. Is this important? - Depends on coding goals. For a general purpose function set, I say yes. 

float v double Variables are yet constants (, ,...) and functions () are double. It would make more consistent to use or throughout. 

Small review and could be rolled into one. would benefit clear size==0 functionality. Pedantic: lacks overflow protection. 

Basic compiler warnings: Printing with expects a . Passing is undefined behavior, although commonly not a problem, 

is a potential infinite loop. Should input consists of a non-integer, like "xyz", will return 0, the loop will continue using the old value of , possibly uninitialized. Consider: 

Code's usage is good and correct. This correct usage can allow some compilers to further optimize code as well provide the self-documentation OP noted. 

It is not clear that the block is part of and not a free standing block. Consider the below. The first lacks clarity that the first block is part of the and the 2nd block simply a stand-along block 

Avoid mixing / types. and have 1) different sign-ness and 2) potential far different positives ranges with usually more than . is the right-size type for array indexing and string lengths. "how can I optimize code" --> No need to call twice. Weak compilers will iterate the length of on each call when only once is needed. Check results 

Certainly found the alternative (2nd version) immediately understandable. Not so with the first (both simplified below). The 2nd maps directly to the stated requirement "exits early and returns false if any call fails". This alone gives it a strong preference. 

Buffer a bit too small " file can have thousands of lines each holding up to 1540 chars" implies a line is up to 1540 characters and then an end-of-line or 1540 characters including an end-of-line. In either case, is at least 1 or 2 too small as needs a to append a null character.