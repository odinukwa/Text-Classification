Unless you want to release the capture from a different thread, in which case it seems like you're more likely to run into the 'Released by wrong thing` problem. Why do you need to know if it's captured? Try to capture the lock and if it fails, you know that it's captured... What purpose does the property really serve? 

Any feedback's welcome. I'm particularly interested in feedback around any scalability issues this approach is likely to encounter, or if there is a more modern approach with C# for handling multiple clients. 

NPCFactory.java Stores templates for creating normal and boss enemies and provides methods for creating random creatures. 

Giving up control of the running thread could be achieve using (although this isn't particularly efficient) and you may want to pair it with . For flags, you probably want to look at either and/or variables. 

I like to use a single global PRNG in my c programs (similar to Javascript's ) because it simplifies things and the unpredictable nature of a global is quite fitting for a PRNG. I recently started using multithreading more so I adapted my global PRNG by making it atomic. Besides the obvious, it is meant to be atomic in such a way that two threads requesting a pseudo-random number simultaneously won't get the same number in the sequence of pseudo-random numbers. Using a CAS-loop seems to be the only way of accomplishing this, if there is a better way do let me know. Primarily I'm looking for confirmation that it actually is atomic. Note that isn't the same as , the latter is a typedef of . Admittedly not the best naming ever. The real magic happens in but the whole thing is pretty small so I've included all of it. It can also be found on github. 

First, removing the continue. It does nothing, since the loop will just continue anyway without it. Continue should only be used at the beginning or the middle of a loop, never the end. Next is the try catch. In the event that the int.Parse fails because the user entered an incorrect string, either maliciously or because of fat fingers, then this will prevent the program from crashing because of uncaught exceptions. Finally, I recommend breaking down the Main function, mostly for readability and comprehension. A good benchmark is that if you have a function that is over 100 lines long, then it should probably be split up into smaller functions. The code for playing a game should not really be in the same function as the victory text. Splitting the game itself into its own function would improve the readability, especially if you wish to return and read the code at a much later date. 

Because the code generated by the two macros that make up darray is so similar to that presented in my previous CodeReview and the suggestions made there have already been taken on board, it is probably best to focus on what's new, namely the template-like use of macros. In particular I'm looking for feedback on the use of macros (which is fairly extreme, but likely unavoidable in this case as C doesn't have C++'s templates), like maybe there's some corner-case I haven't thought of, or some best practice for C-style "templates" I've missed. Even just a double-check on the code and correctness of the associated documentation (such as the big O claims) would be very helpful. CodeReview has a tendency to quickly spot issues I would've never even thought of on my own. Associated Documentation (In the form of a header-comment in the actual library, hence the limited formatting.) darray provides the following two macros: 

My gut instinct is to agree with @Olzhas Zhumabek, that you should be using a std::string for your . With it a lot of the issues go away and you've already deviated from the original spec by not using a . Looking at your code, your choice of has created a discrepancy in the interface for your class. You construct the object and set the value of name using , however you only return the name as a . This feels odd. Your copy constructors use the public interface to perform the copy semantics. Again, this feels odd. Part of the benefit of writing the copy constructor as a member of the class is that it can directly access the private class members of both sides of the assignment and avoid the overhead of the public interface. 

First thing that jumps out at me is that you assume that the Players enter a number. Never trust users. What seems logical to you is not always what a User will think. Int.Parse will throw an exception if the string handed to it is not actually a number. I would change the following code: 

First, I would like to say that I am not familiar with Python itself. However, I am familiar with basic programming principles that are the same between games. Second, you have far too many if statements. There should only be one if statement when entering a position, and that is to check if the position you have chosen is valid; ie, there is an X or O in there. (or better, if I understand the python initialiser right, is not ' '). Instead of what you have, you should be converting the number the user types in to the coordinate in the array. Ie: 

Generates actual definitions for a darray type containing elements of , named , with functions prefixed . The first argument should be either or , which will define all generated functions as either or . darray usage: A darray type as generated by the above macros represents a dynamically sized array containing elements of any one data type. Each darray type comes with a multi-purpose interface allowing it to be used as one of several data structures, such as a stack, a queue, a binary-searchable list, or all of the above at once. The individual functions are documented through comments. darray performance: Where relevant, darray functions perform bounds checking, which may incur a small (but likely negligible) performance overhead. The different usage patterns supported by darray (stack, queue, regular array, etc...) are balanced in such a way that each of them performs as close to optimally as possible without slowing down the others, minimizing the performance cost of versatility. Big O performance is about what one would expect for an array-based data structure, with length/get/set/pop/clear/ditch being , push and dequeue being amortized , insert/remove being , binary search being , and sort being or . darray returns: Many darray functions are documented as returning -1 despite returning (unsigned), which will actually wrap around to . It is safe to detect these returns by checking for equality with -1 or , but checking for less than 0 obviously will not work. EDIT: The -1 return has since been replaced by a constant so this is no longer relevant. The code samples are left unchanged to preserve the question. Several darray functions are documented as returning zero on failure, which simply means an all zero value of the contained type. For a numerical type this means the value 0, for a pointer type, or for a more complex struct type (all bytes set to 0). Getter functions which return zero on OOB or if empty do so merely as a safety feature (avoiding SEGFAULT or returning garbage data), using these to check for errors or OOB is strongly discouraged as this practice will break when zero values are stored in the darray. darray.h (Bear with the highlighting, StackExchange doesn't handle macros too well.) 

I checked, and the modulo is the same in python as other languages like C#. Modulo retrieves the remainder from a divide operation. You will likely need to change the order of which number corresponds to which location in the visible grid. In addition, the code for checking whether or not the position is clear is near identical for both players, and could be moved into a separate function (returning a bool that the players choice was correct) that takes in the players character to write, which would have the advantage of ensuring that code for both players is identical. I know there has to be a better way to check the winning condition than the if statements, but I'm not sure what it is off the top of my head. Like the above, the check itself can be moved into its own function that checks based on character, rather than repeating each if for both players. This function can then be called for each player. There will be other optimisations based on python itself, which I am not aware of. But those are the basics that should help with efficiency in any language.