The key benefit is that this call runs regardless of success or failure, similar to a block or a destructor in RAII. You can add more blocks at will and you won't have to add redundant cleanup code. Another way to do this is to use (if you are not morally opposed to it for silly reasons - it actually works well in C code for this specific purpose and you'll find it all over large projects, including *nix kernels.) 

It could be that at 100 connections you won't notice, but you should be aware that the 1-thread-per-connection model does not scale well and is not in line with the current state of the art. See what is written about the c10k problem. With a thread-per-connection approach you will have high memory overhead from each thread's stack, and you will spend a lot of time context switching. What scalable network code does these days is: 

In this particular case the assignment to is a no-op, since 's value came from . However, I would argue that doing something inside every block (like your assignments to ) get tedious to maintain. One style would be to not have early statements, and do the assignments you want at the end. You can still check for errors, just don't heave repeated s, example: 

When programming for Windows, you should almost never want to use the ""/"ANSI" versions of functions. This is legacy from Win9x and you should be using Unicode. Windows is not like Unix where the C library can assume UTF-8 and everything can keep chugging along with the full set of Unicode chars accesible: by restricting yourself to the "multi-byte" encodings you will (1) see inconsistent behavior depending on what the user sets their language to and (2) not be able to access some Unicode filenames that the user may have on their filesystem. You should define the and macros and use instead of 8-bit chars. (Since it seems you want to use the C++ classes I believe works instead of here.) Second: The class looks weird to me. Not all Windows APIs use - some of them may return or do something else. From that perspective you have not captured the full generality of Windows errors. I would also say, perhaps controversially since this is not the path everybody has taken, that wrapping Win32 errors with exceptions is a bad idea. There are some Win32 errors that are not error conditions at all, for example will fail with when you reach the end of a directory, or I/O will fail with to indicate that the I/O is happening asynchronously. A Win32 program will occasionally have to react to such errors and I would say the way you've done it loses some of that information, or makes it less convenient to work with. But maybe it's OK for your use. YMMV. 

Error handling in C looks very ugly when done poorly, but if there is a general approach to coding style it can work elegantly.. The trick I like to use is to make your failure paths mostly the same as your success cases. This typically means that there's a part of each function that does "cleanup" - deallocates everything you've allocated, releases whatever's been acquired, etc. Kind of like the RAII pattern in C++ where your locally-declared quantities will do their cleanup in a destructor. This would get run regardless of success or failure. If some allocation or resource acquisition outlives the function, then make the success case be the special case, because this will ultimately allow you to make more fluid code modifications vis-a-vis complex error handling. In case I'm writing too abstractly, an example of this would be: 

If you hit that you will leak the allocation of . Now, you could introduce a inside the block... But many C programmers (myself included) prefer to avoid early statements, because what happens is you end up with repetitive "free all the buffers" cleanup blocks. Instead of doing an early , I like to let the scope own the allocation, meaning I insert the whenever something like goes out of scope, having the same cleanup block run in a success or failure case. (This sort of imitates C++'s RAII pattern, but with C and more manual.) 

This has some undesirable traits in that it will silently truncate the string if the input is larger than the destination. If you are working on a system that has the non-standard , that has some cleaner error conditions: 

This means that there can be only one instance of (maybe make it a static object in your file), and the memory overhead per is 1 pointer. (3 times less than your code). 

can be larger than the buffer allows.[1] In that case, your program will crash or worse, continue running while corrupting some other part of memory. To avoid that you should always use functions which let you track the size of the destination buffer and detect overflow. For example: 

Check for errors in , , , and , to name a few. If the exec fails in the child you should call . Do you really want the in ? This is not guaranteed to be the same as the you just -ed. If is your will look for a file at and it will likely find the program in . I would use and either do that lookup yourself or simply omit that part and require the user to specify a full path for something in (eg. instead of just ). The + observe state + thing is a race condition. Another process can change the attributes on the file in that timing window. This may or may not be important to you. Given that this is a security-ish program I would say it may very well be. Instead of returning 0, you might want to return the child process's exit code (which you can get with .) You might also want to return nonzero when the functions I mention in #1 fail. This way a shell script or something calling you programmatically can determine success or failure. 

However I'm not sure if this will work right if you do it on memory mapped from a file by . Keeping this kind of atomicity in a page fault handler seems complex and I'm not sure if the standard guarantees that it should work. 

Which brings me to the next point. I don't see any calls to . For a structure like this I think it's good practice to have a single alloc function (which is good, you already have that) and a single free function. So let's write the latter: 

I'm not sure what you're using this for, but my advice: Don't bother validating the filename. Just open the file. The system knows the rules better than you do, and by adding too much validation you can cause problems down the line. On Windows these rules are especially complex. Frankly you will never find them all. Here's a few you missed, off the top of my head: 

This is weird. Maybe instead of returning a magic value, your pop function should have a different interface. For example, maybe your pop function has an output parameter (pointer) which receives the popped value, and returns a boolean indicating whether or not a value was popped. 

You might want to consider working line-at-a-time rather than pixel-at-a-time. Looking at the documentation this would mean calling and rather than /. Each call to either of these functions must convert the coordinates you specify to an offset into the buffer (eg. ), and if you do this for every pixel in a large image these multiplications can add up. So something like... 

Then after this block, you can in any place you like, success or failure, even throw exceptions, and COM will still get uninitialized. (Notice I didn't initialize COM in a constructor. This allows us to inspect the on failure without wrapping it in an exception. I'm sure many would suggest wrapping s in exceptions. This is not personally my taste. YMMV.) 

You leak if any of the lines between the and the fail. There are several ways around this. In C (which does not have exceptions or RAII), the best way around this is to avoid early statements when there's something to clean up. (Allocation, file handle, lock being held, etc.) For example you could do (just meant as a quick sketch): 

Note that can fail, so we don't initialize anything in that case. (Callers of should do the same check.) Actually your allocation also highlights something: 

Not sure if you are using ARC, but without ARC this is a potential use-after-free bug. If you are not using ARC you should consider: 

Don't bother casting a to another pointer type. This is a C++ thing. In C you don't have to do it, the conversion can be done implicitly. 

You should be aware that you're re-writing functionality present in the standard library. This is all right if you're learning, and I would encourage you to continue to do so (it's a great way to learn), but here are a few thoughts from this angle: - this is basically . - this is what does. (Note the extra r in there means "search in reverse") - you can use as a boolean expression. (If the result is non-NULL then it has that character.) - it seems a bit redundant to call before . You can use the result of to determine both that there is a space (result is non-NULL) and where the last space is (using the result as a pointer). As a style point I would argue that it would be more "C-like" to talk in terms of pointer arithmetic rather than offsets. (i.e. Take the result of , do something with that pointer, rather than thinking in terms of "give me the offset of the next space".) 

These integer operations can overflow. Maybe that's not a huge deal (I'll admit, I myself write a lot of code that doesn't handle overflow), but something to be aware of, should you be allocating sizes around the boundaries of the type of the size variables. 

You don't have to write . You can just write . Or you can just write . This is a style thing though, different people make different choices. 

Failure in will return , not (usually I think expands to cast to a pointer, meaning your failure check won't work). As for style: This is just an opinion, but I think your style could benefit from the concept of a "cleanup block". For example, instead of this kind of style [paraphrasing your code, not doing literal quotes]: 

If you deal directly with the family of syscalls, you can pass unadulterated strings directly to the program without any chance that the shell will misinterpret them, because there is no shell in that case. Hence there is no need to escape. There are more potential security problems with code like this. Here are some that I can think of: 

Your call does not account for the extra 0 byte (also called terminator) that must end C strings. You repeat this mistake in a bunch of other places. (To reiterate: if your string is size , allocate and set the last byte to 0.) will recompute the length of the string at runtime, by searching for that character. This is bad. Every concatenation will lead to another traversal, leading to an O(n2) kind of curve when concatenating lots of strings. I see the use of in pretty much any code as a sort of red flag. can fail. Check your return codes. A large part of writing good C code is being able to answer the question: "how does this code fail?" I feel like a lot of higher-level coders (usually Java and C#, but these days also objC) seem to fail to grasp this and code rather "optimistically" instead.