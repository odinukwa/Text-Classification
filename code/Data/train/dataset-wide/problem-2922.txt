There are two things here. Firstly, in any code that is not directly related to the system itself, is almost always a bug. There should never be a need for this. Let the system look after itself. It really does not need your help. The second item is that it may be taking a long time to load the Images. If you are scrolling to unseen areas of the system then the code may need to be calling the method a lot. You need this method to be fast. Convert the line to be an AsyncTask, and let it populate the imageView in the background. That will make populating the views a lot faster 

There are some things you are doing wrong with your ClientThread setup. If you want the client threads to die when the main thread stops then you should set them to be Daemon threads: 

Generics In Java, it is not safe to create an array of a generic type. This is what you are doing... is really , and you are creating an array of . Because the generic types get removed when you compile the code (see Type Erasure), there is no safe way for Java to ensure that you have the same types of data in your array. For example, you could have specified your input as: 

From the code you show, this launcher does not do very much, it clears a cache (In the background?) and (on a call-back) starts a child process. Is there any reason you need to create a full program for this? A Batch file seems like the right tool (maybe you need a program to clear the actual cache files?): 

Why is that better? Well, it streams the text in the form of sentences, and then finds the first match in a sentence. If there are no sentences, it matches the whole thing. Note that the same principles can be used with a non-streaming approach. Split by sentences, then find the first match. In an android environment, you could do: 

This code can be simplified a lot, and in to a single update without the cursor. This may be a problem, though if your transaction log is not large enough to accommodate a mass update to all your records. Right, how to simplify the update? First, build the case statement in to the logical table... Consider this: 

Sometimes this is not avoidable... but, in this case, it is unnecessary. By splitting the logic in to two methods, it becomes harder to 'grok' the recursion. Additionally, your previous questions where you have had similar sorts of work, you have always 'defaulted' to using collections instead of using simpler mechanisms like arrays of primitives. Arrays are much faster, and smaller, and tend to lead to better structured code. This is because the array is essentially a stack, and popping the stack is as easy as changing it's size.... you do not have to do as much manipulation of the stack head. Finally, this problem is one which should have a more general solution. You have hard-coded this solution to only work with 1-step and 2-step 'strides'. The problem is actually simpler if you make the stride options a general thing.... Consider this alternative code... it: 

The point here is that all the logic is contained in one place.... You will need to add a way to schedule the background runnable every ten minutes, or when needed. That should be easy, with an ExecutorService.... 

Create an object (the ListIterator) in order to get a member. This is overkill. This pattern is repeated often. Rule of thumb, if your code is going to act on just one member in the list, then using an iterator is probably not the best solution. Iterator "implemented" The bulk of your logic is implemented in the ListIterator. This is a backwards way of doing it. The Iterator should call methods bck in the list, and not the other way around. assertIndexExclusive This should be called assertIndexInclusive (it includes the range end). Bug in subList The following code: 

The system you have in place is efficient in the sense that it offloads the network-based work on to an AsyncTask, and the callback updates the wallpaper. You don't give the details of your , but you could neaten a few things up by putting them in to there... and it would look something like: 

Function Extraction I realize that programming challenges like this often end up with logic piled in to the Main method. Object oriented code and challenges like this are often incompatible. Still, functional extraction is useful, and you don't do it enough. Consider code like: 

where you the value, which implies you expect white-space on it. The very next line you check to make sure the first and last characters are actually parenthesis and . You should trim the value before that check because trailing whitespace is surprisingly common, and would be legal. I cannot find a good reference on Annotation syntax, but it appears that there cannot be a space between the annotation name, and the opening parenthesis.... is this true? Still, the correct solution for the whitespace problem is to solve it in the regex. This can also solve the parenthesis checking poblem. Consider the regex: 

Using an appropriate structure OK, that's some minor stuff to start with. The real issue, as I am sure you are aware, is that you have a lot of code duplication. I would strongly recommend that you separate out the display logic from the calculation engine. Right now you have a single, large, class that does both. The standard way to break up your program would be to use something like the Model-View-Controller (MVC) system for user interaction. There is a relatively good description of the process in this Java documentation. The basic structure would be something like: 

Badge classifications The first change required transforming the badge source/classification data in a collection of in-statements, to a set of virtual tables instead. Statements like: 

Return statement in the finally block is almost always a very bad idea..... The sematics of the finally block are complicated, but, if there is a return statement the block, or in a block, then those will be called, and then the finally block will run, and it will change the return value. IDE's, and the compiler, will complain about this: 

You should probably add tests in there for special cases, like the input equals to , or 1, or 0. See the code running here in ideone 

which you can visualize as being half the area of a rectangle, where one side of the rectangle is , and the other side is What is the size of , well, it is the number of 3 multiples there are: 

The hashCode method can be simplified down to (just simply restructuring your logic and removing redundancy): 

If begin or end are less than then you can do a binary-search on and then just output those primes while they fall within the array, and between and . No need for calculations..... Your inner loop scanning primes should terminate when > . At the moment, if is 31, you are scanning all 3400 primes to see if they are factors.... ouch. 

This test, on its own, is not enough. Additionally, the test is called , but it does not actually test that the value is updated. What it does is: 

If the bounds have been previously calculated, then it will be very fast. If not, it will have to do a lot of work, and additionally create a bunch of instances of . In essence, if you check the bounds often and don't change the Polygons, then your bound-check is amortized quite well. If not, then you are doing a lot of unnecessary work. In order to improve the elapsed time (execution time), about the only two things I can recommend are: 

The and variables are duplicated in different scopes. The closure pattern is the right pattern, but give your variables different, non-shadowing names. Also, why and instead of just and ? 

In this case bit-wise manipulation is your friend .... (as it often is...).... I believe the following solution makes the combination/permutation expense a 1-off setup problem, and using the makes it almost trivial ... The code I hacked up appears to have a time-complexity of O(n) related to the size of the rank, and a small penalty for the number of wild-cards.... but, in essence, the method runs O(1) since those things will never change much.... but the code looks like: 

Corbin has provided a pretty comprehensive answer. The part that I immediatley noticed though is the accessible HashEntry class, and how it is leaked through using the method. Your hash is a mapping of a key to a value. Your put method is , and to be symmetrical, the get should be Your get returns the HashEntry which should never be released. Because you do that, people can mess up your entry because the and are public too. The get should return int, and you should establish a protocol that allows you to determine whether the key did not exist (return 0?) or whether it exists (the can be a double-check). 

Using dynamic queries to alter the database schema is typically a pretty bad idea. If you are changing "real" tables, it would be better to pull the alter statement in to a completely separate session and run it from there. Sure, use the SQL query to build the alter statement, but then copy/paste the alter statement in to a new session. That way you get the chance to inspect the alter before running it. Additionally, it would be much better to have a concatenating process inside your loop, than to actually run the dynamic statements. Consider something like: 

This way, at the end of the loop, you have the index to the first pair of indexes for values with the largest diff. You can then loop through that list using and pull the actual values back from the array. This is not actually very different fdrom the way you have done it, but it is a bit neater. Nice job. 

A discussion in The 2nd Monitor made me realize I had never 'solved' the N-Queens problem. Additionally, as I read up on it, I realized that the 64-squares in a chess board would work well if represented as bits in a 64-bit long.... That was a nice thought, but it became complicated, and really, 8-size chess boards are quick to process. Instead, I considered representing each queen as a bit in an integer, and each integer represents a row on the board. Using a 'long' I could have a 64/64 board, conceptually. With that representation, I could solve any size board up to 32, and that makes it a decent N-Queen solver. Switching to longs would make it a 64-size solver. Still, I also realized soon that anything beyond about 15 size boards is pretty slow to brute. Regardless, Here is an N-Queen solver, with some utility methods to make it friendly. The algorithm I use relies on only adding a queen to the board (one queen in each row) when that queen is added to an un-protected square. It calculates what squares are protected in each row by using bit-wise manipulation. Hoping for reviews that focus on: 

The most glaring problem in your code here, is that you open and close the file on each call to the function. You should instead open it once in the calling function, and pass in the already-open files to the method. The open and close operaions are both slow, and should be minimized. I recommend that you re-work that part of the solution, then re-post as a 'follow on', but then also include the calling part of the function in to your question so that more of the overall structure of your solution can be reviewed. The variables , , , , , , and are also all horrible names... you should rename them to be 'self-documenting'. They should be called what they are. The variable is particularly problematic because it is so easy to confuse with . I struggle to understand the difference between the and files. It appears that you are copying the first chunk of data from the a-file to the b-file, and then merging from two different places in the b file back to the a-file. I would recommend instead having two read-poitns on the b file and then write back to the A. The extra copy is slowing you down too. There's no need to copy from a-to b if you can jsut swap them... 

Conclusion Right now, your code could do with a major refactor and shuffle. have a look at your options, and then try to bring it together in a more structured framework. Your current code has out-grown it's exoskeleton, and it's time to spread it's wings and try something different. 

To me this indicates that the best way to manage this problem is 'the hard way' of typing in the method name. Using the stack-trace is not used by any popular system. Now, a second issue is that Logging is enabled, configured, and diverted based on the 'key' used for the log message. This is typically set as the full class package.Name. Your code is losing that information, and using just the one Logger instance for the LogUtils class. Thus, there is no way to configure the method entry/exit logging for just one class in your system. For your LoggingUtil class I would consider the method: