where each row states which likes which . If you already have a members table then it might feasible to actually link the table to the member rather than a name: 

Your functions and variables not always very well named. The name of a variable or function should convey its purpose in a concise manner so that when reading the code it is immediately obvious what the intended purpose is. So for example: 

Yes this can be done better. Storing data in a serialized format in a database (be it JSON or XML) is a bad idea more often than not. The main issue is that you will have a hard time querying for specific items in the serialized blob (e.g. trying to find which member has liked which images). The basic thing you can do is to normalize your data by introducing a table: 

But actually what you meant is "units". So the entity you are trying to measure is an angle. And code using it should, for most parts, not care what unit it represents - just that it represents a specific angle. Expressing it as a value in a specific unit is only really necessary for calculations in algorithms which require the angle to be of a specific unit, serialization, display, etc. Therefore I suggest a different design: You have an type which represents a specific angle. Choose whichever unit you like best as internal representation of it. The type then exposes methods to create an from various value in specific units and convert them to such. Something along these lines: 

In your method I assume your forgot the brackets around the block? Right now you always collapse visibility of . Your and methods share lot of code and should be refactored into one method. The only real difference is which file you read and what you do if you read a specific string. Pass in what you want to read and remove the concern of what should happen if you do read it by returning a indicating whether the string was found (the purpose of the method should be to determine if a certain file contains a certain string): 

All serialized types need to have a parameterless constructor although it is enough for it to be . All properties and fields you wish to be serialized need to be public. The serializer will ignore private properties and fields. 

I'm not doing a lot of Python but one thing leaping out at me is the usage of all these single letter variables which make the code really hard to read. While longer names will make the code a bit longer I think they will improve readability quite a lot: 

I think the implementation is too leaky - it should not expose how the blocking internals are achieved since if if decide do change this you might have to change a whole lot of application code which violates the open-closed-principle (the O part of SOLID). This can be easily fixed by making the class and using of the . I think the more idiomatic way to start a new task is to use . I would rename it into since that what it is. Since you're talking about long running operations you may want to add a method of canceling the task. It might be useful to add a capacity for the intermediate blocking collection as well to provide better control of how much data is cached. 

Answering whether or not this implementation is correct would require to know what the specification of the problem is. Now assuming the spec is: 

Instead of spawning a new thread every time you probably should execute them on a thread pool. You want to wrap your list in a or else you might run into unexpected race conditions when removing multiple servers at the same time from the list from two different threads. 

You have tremendous amounts of code repetition. Programming is about efficiently solving a problem in an automated way and you should also try to apply this to the code your write. One of the most important principles is: DRY - Don't Repeat Yourself. 

is not a very nice name. would have been better. should probably just be as it represents a bulb object. Rather than using the somewhat generic names of for a string of bulbs maybe would be better. I might be missing something but your outer loop which loops over constantly overwrites the content of and only the values from the last iteration will actually be in there due to the assignment operator. Did you mean to write: 

Naming conventions ( for properties) You now have introduced a property but that doesn't affect anything (the property is not used anywhere in the class) Although you have introduced a named constant you are still using magic numbers in various places. You have added some rules but they are implemented inconsistently - in you enforce the rule in the while in you do it in the . The way you have added the rules is simply bad - you silently coerce the values and the user of your class won't have a clue what's going on. Assume this calculator is used to process the payroll in a company with lots of employees. Further assume that some of those are contractors which have not worked in the last week for whatever reason. Now you read in the work hours for each employee and everyone who hasn't worked at all () will get a full week payed - ouch. If properties have restrictions on what range of values they should be in then enforce them in the method by throwing an stating what was violated. It's better for your program to crash with an exception than to spit out bad data. One of the few places where coercion of values makes sense is in user controls which force out of range values back into the range and then feed that back to the user (e.g. numeric up/down controls which a given min and max) but in most other cases it will do more harm than good. 

The best refactoring was mentioned by slaks though: Get rid of the implicit mapping and assign the codes directly to your enum values. In general: Try to accept the most generic collection type possible - this will give the users of the function more flexibility regarding passing in the arguments. I find nothing more annoying than having to make a temporary collection to satisfy some interface which expects a which might not even use the fact that it's a list. "Be liberal in what you accept and conservative in what you produce" - I find that approach quite useful not just in data processing but also for interfaces. 

Update One more thing: contains too much responsibility: it reads the data, solves the problem and outputs the data. Those concerns should be separated: 

Both versions convey the semantics better than the for loop (imho). You can reduce nesting a bit by using . E.g. 

Regarding performance: Well this will reduce portability but MSVC, gcc and clang (same as gcc I think) all have intrinsics defined for which will probably perform better than your implementations. At least on x86 they'll probably make use of the instruction. So you might want to have a few 'ed alternatives for different compilers. You are allocating memory which is only needed for a specific code path so maybe you should just not allocate it if . You can set and still unconditionally call on it as is perfectly legal. Your naming is a bit terse. itself is ok as it's a reasonably known operation but what the heck is and (it's also inconsistent vs )? Please prefer more explanatory names like and . I find code like this confusing to read (the pointer alias is confusing to me): 

Design As it stands your code is hard to unit test due to the async nature of the timer. Consider creating an interface which you can pass in with a thin wrapper implementation around the .NET . This way you can pass in a mock implementation in unit tests which you can control as to when it executes. This is somewhat annoying but so far the only way to reliably test things like this I have found. 

The code is much easier to read and has probably less bugs than your self implemented one. It's also fast. I can pump 10,000,000 items (I tested with ) through a channel (buffer size 100) with single producer single consumer in 5sec. That's 0.5ns per item. 

You can run into a buffer overflow when the user types in more than 15 characters. You should use - Note that will automatically add the null terminator (hence instead of ). While it is accepted to use single letter variables for loops you have abused this extensively in your sorting routine. 

There is nothing inherently wrong with having multiple using statements. It keeps the lifetime of objects to the minimum which is not a bad thing to do. Another point is that I'd possibly re-factor the error raising: You always prepare the error message with the same parameters except for the actual message. This could easily be encapsulated in a little helper function. So the refactored code could look like this: 

You mix UI and logic together. You should extract all the copy code into a separate class and pass in the parameters from the form. This will make your code more reusable (right now you can't write an automated copy program which takes file names from a config file for example). When you refactor then let your exceptions bubble up and let the caller (the UI in this case) deal with them. should probably be more something along the lines (create if not exists). Something along these lines: 

Your code in and the classes is so heavily intertwined that I'm having trouble actually figuring out what is going on there and what is supposed to happen. In the long run this is unmaintainable code. The next developer which comes along in 2 years time and tries to make a change here will just bang his head against the desk for a while until he can figure it out. So what to do about it? Let's see if we can decipher the intend of the code: You build a list of what I'd call content providers. Then you process that list by appending all straight html providers together until you hit a function based provider, at that point you stop, raise an event which returns an object which is the used to execute the provider returning a string (presumably dynamically generated html). Now your problem is that you don't have a common interface for your content providers which results in a lot of type checking and casting which is a bit nasty in OO. So let's see what they have in common. For one thing they all produce a string but while one provider can produce the string immediately others require external context. So I'd suggest something like this: 

Make your implementation not require to be Allow you to call multiple times on the same object without ill side effects. 

You don't need to cast the return value of in C. In fact it's considered bad practice as it can hide problems (like forgotten to include the appropriate header). You should check the return value of - in case it fails it will be and you are usually left with a somewhat meaningless segfault when trying to access the memory. You do but then immediately after in your for loop you do 

First of: I like the iterator approach. We use the FizzBuzz problem as part of our interview process and to this date nobody went down that route. The main points I have: 

You algorithm yields the sequence A -> B, B -> C, C -> D with a total cost of 7 which is indeed the set of edges connecting all nodes with minimal cost. If you were to use Dijkstra's algorithm to compute all shortest paths from A to every other node you would get: A -> B, A -> B -> C, A -> D at cost 13 (if you do not count A -> B twice) since the path with the minimal cost from A to D is indeed the edge with cost 6. So your implementation finds the set of all edges so that all nodes are connected with the minimal cost. This, as mentioned above, is typically called a minimum spanning tree for which several algorithms exist, most notably Prim's algorithm and Kruskal's algorithm. I haven't checked it in detail but it looks like your algorithm essentially is an implementation of Kruskal's algorithm. So it's not entirely wrong - it just isn't the algorithm you set out to implement. You could rename your implementation to and try again with Dijkstra (if you need help with that then Stackoverflow would be the better place to ask since CodeReview is about reviewing existing code). 

This condition can be simplified to since if is not unequal to then it is equal to . Also this logic is repeated again in another class - this violates DRY. It should be a method on the (if I got the type right). In some properties reference the - it seems odd that an engine style class has a reference to the UI but there might be perfectly good reasons for it. Just seems a bit suspicious so I mentioned it. In you use in several places. Would it make sense for those casts to return ? Can the constructed objects deal with those parameters being ? If not then you should use a direct cast instead. This: 

If you have indeed identified the json deserialization to be a performance problem (by profiling it) then you can 

So basically you make a copy of all rows for a specific job, replace the job number and append the changed row back to the database. Sounds like this should be doable in one loop with the help of and no need for a temporary table: 

So the whole around the instantiation is pretty much useless as it will crash anyway. Even worse: Instead of getting a which pretty much tells you what is wrong you get a fairly meaningless . You have two static arrays and . These names are useless as they do in no way give you any idea whatsoever what they are being used for. The name of a variable, method, class, parameter, etc. is effectively the advertising sign for its purpose. A good concise name goes a long way of 

If all the methods look like in the provided sample implementation then I see several approaches to make your factory method cleaner: 

is a bad name for the function. would make much more sense. Judging by the one range-based for loop, you're using C++11 - so might as well use it to the full extend: 

Magic character should be moved into a named constant like . Since you need to classify the another way to encapsulate this logic is to create a set of extension methods like this: 

you repeat the term several times. However this only changes with the outer loop so I'd consider extracting it into a variable like this: 

The method should be encapsulated in it's own class which has an interface. This can be injected into the controller which will make unit testing easier. Something along these lines: 

Same in your implementations you do - assuming that the beginning of the string should represent the outermost layer (the first thing visible) then this is the wrong way around as well. Similar for . 

Now, we only review working code but because the above things are mostly access modifier problems rather than actual code bugs I'll continue with the review anyway. However you should test that your code compiles and work first before posting here. Review: First off: The idiomatic way to create tuples is to use . This way the compiler can infer the generic types automatically which saves you some typing work. In your case this means: - much shorter. 

The multiple of data is still data and not datas. The main thread method can be simplified by introducing a little helper method which filters out relevant updates and again a bit of LINQ: Helper method: 

The method returns a string representation of the found entries which is generally not very useful to a program using your class. You should simply return the result, or if you want to pass back the indices of the found entries as well then return a dictionary with the indices being the keys and the todo items being the values. Pretty sure is simply meant to return the human readable string but you are also printing things out which is probably unexpected to the caller. 

You should check the return value of . It returns the number of items successfully converted. You initialize with so any invalid input will yield in a single output but it might be good to indicate failure anyway. Using and are more portable ways to indicate success/failure upon return to the OS. is is not representable by an 8-bit type. The binary representation is 1 0000 0000 - so the 9th bit is set. An 8 bit unsigned type can only hold 0 - 255. Multiplying an integer by a power of 2 can be done by a left-shift. So for example is - this eliminates any need for multiplication or even invoking . You print out the order of bytes in big endian notation (the highest ordered byte is printed out with the smallest index) while for example x86 is a little endian architecture where the lowest ordered byte has the smallest index. Actually scratch that. The data in memory is laid out little endian so your code will print it in little endian order. Your size detection works on the assumption that a char is 8 bit. This is not guaranteed by the C standard which requires to be at least 8. For example there DSPs where is 16 and in the past there were architectures with 9 and 12 bit bytes. Your size detection only goes up to 4 bytes however is 8 bytes on many platforms. So if someone puts a large number in the it will simply omit the upper 4 bytes.