first element is 19, since abs(20-19) = 1 is the nearest distance to 20. let's find 19 in the sorted array: 

I wrote a simple class in Python, which controls code invocation, in a multi-threaded environment, with the following logic: The class' main method, named , takes two function pointers as arguments: and . In any point in time, only a single thread can invoke code the function passed as argument. If a specific thread tries to invoke its code, but some other thread is already invoking its code, then the is invoked instead of . If there's an exception in the code being executed, it should raise to the calling context. The code: 

What if the script renames file "a.zip" to "b.zip", and both files "a.zip" and "b.zip" exist in the same directory? 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

Without reviewing other aspects, I think you should separate the code so that there's the server itself in its class (or, maybe even better, its own project), and there's the UI. For instance, you should not show a MessageBox inside a server's code. There are so many reasons for that so I'll just leave this statement as is. In other words, the server should behave as a black box, returning error codes, or throwing exceptions, or anything else, according to its own API. Mixing the server's code with UI is not a good practice. 

. UPDATE: I'm still googling and looking for ways to do better. Let me add something for your consideration. I'm closing the prepared statements via the servlet's destroy() method; the same servlet that calls the method "initialize()" above in order to create them. The idea is to create them once (and only once) and have them available forever for all users (i.e. until the app or server is shut down). I'm going for a kind-of a pseudo-stored procedure. I would just use stored procedures straight out, but the database exists to support another application (their in-house sales system) and I'm going to use it for Internet sales read-only ... avoiding any potential conflict with their maintenance efforts or agreements etc. by not doing anything to change their database set-up. I have suggested that my app use a new account limited to read-only privileges. And come to think of it, I haven't tested whether I can use Prepared Statements in that mode; just seems like it should work. Each result set is closed in the finally block in the method where they are created. I guess that's ok? I reuse the same RS variable name for multiple result sets (on the second two) but close only once. But wait! Do I even need that? The ResultSets are declared within the scope of the method. If resetting them without closing the old ones doesn't cause leaks, then exiting the method should do just as well on its own. It is a static method, but the ResultSets will be reset every time it's used (at the very least). So, at most, there would just be a single set of ResultSet handles available for reuse; not run-away "leakage." I'm wondering if I can send the two select requests in the loop both at the same time, simply by turning them into one prepared statement separated by ';'. Or just found "MultipleActiveResultSets=True"; document allowing SQL Server to process multiple transaction requests on a single connection ... still investigating this. Or is there another way to create a prepared statement that would fetch ALL the data via a single submission? (Seems to me like there are too many round trips.) Finally, I might get a boost from using connection pooling, which I haven't done yet. It's low priority in my project right now, but I might have to do it before we go online. 

Find the nearest number, in terms of distance, from the array to the given external number (20). sort the given array. find the value in (1) in the array. it can be done using a binary search. now, to the main point: the next value would be either to the left of the current value or to the right of the current value, since the distance is now between the next value to the current one, and the array is sorted (!). so all you have to do is to hold two additional indexes: inner-left and inner-right. these indexes represent the inner boundaries of the "hole" that is being created while constructing the new list. 

Just a direction, not a full solution, but anyway... If limited by space, you could directly calculate each item in the matrix, given its indexes and N. So eventually you could have a function with the following signature: 

It's not clear to me what are and ? If these represent the radius values (like C1-P1 line for ), then perhaps (and ) would be a better name here. I'd create and use a data class for each point-radius pair. Say, class with and or something similar. I'd separate constructor and results. The results are calculations that should not be part of the constructor. Take, for example, the class named in .NET: you can construct it, change the inputs, and only when you call the property named - you get the calculated uri. The same should apply here, too. Constructing a class gives us an instance with a valid state. Calculations - in their own methods or property-getters (that are practically methods, by the way). So should be the returned type of a method (or maybe if this pattern apply here), and not part of the class' state. 

Since you didn't specify a particular aspect to code review for, I would review the code and comment and whatever I see fit. Inconsistency seems to be a repeating issue in your code - inconsistent code confuse people. In particular: Why do you use Pascal casing for one field and then use _ prefix for another? 

Congratulations to the completion of your substantial project. It is really smart and brave for you to ask for feedback. I am going to tell you what is not so perfect about your code, after all, that's the whole point, right? But don't be discouraged, for you have done a decent job! Let's begin with the high level algorithm: The first thing I would like to point out is the usage on memory, in various places you make deep copies of all the cells. This is pretty convenient to do, but it also take up a lot of space. For the unique/elim/subset functions, you can simply return a flag if the board is changed, and save a copy in the solve function. It might be difficult to remove the deepcopy in the guess function, and that's probably fine, as you might be making a lot of changes. Try save some space, you should notice a performance change. Then let's talk about the code: The checkpuzzle function and the backgroundcheckpuzzle is almost identical, why don't you just parameterize it just like you did in unique? A lot of the code have the structure of going through each of the row/column/squares. It looks like a lot of duplication to me. What if you abstract them into a concept called block, and just iterate through all blocks? Last, and probably least, you made a few typos, 'recieve', 'posslibles' 'indicies', and I highly doubt the word 'possibles', although Wikipedia say it is a plural of an adjective. 

and the rest is obvious. Again, this has nothing to do with Python in particular. It's purely an algorithm to be implemented in any language. This algorithm takes O(n log(n)) in time, while the one suggested by the original poster takes O(n^2) in time. 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

Naming Consistent: might look better if it becomes Accurate: perhaps could be used instead of , since init means some kind of a setup, while the method actually changes the array's values. In addition, perhaps the class' name could be changed from to , which, at least in the aesthetic aspect (to my own eyes), looks better. 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Î˜(N) in time, and O(1) in space. Just an idea, though. 

I am building a web app with a single (not pooled) full time (jdbc) connection between static classes and the database. This is expected to be a low traffic site and the static methods are synchronized. In an effort to speed up access to product information, I am trying PreparedStatements for the first time. As I test, on localhost, sure that I'm the only one running the app., it seems clear to me that my the prepared statements are slower than the unprepared statements I use earlier in the process. This may not be a fair comparison. The unprepared statements get a single result set from one table and it's done. As you can see from the code below, what I'm doing with prepared statements involves three tables and multiple queries. But since this is my first time, I would appreciate review and comment. This does actually work; i.e. all data is retrieved as expected. The first method below (initialize()) is called once from a servlet init() method when the application is first started. The second method (getItemBatch()) retrieves information about as many product items as match a product name (Titel). My little development / test database has less than 100 (total) items and only 1-3 items matching each name; most often only 1. The server app and database are on the same machine and I'm accessing from a browser via localhost. I'm surprised by the consistent perceptible wait for this detailed product data compared to fetching a master product list (all items) mentioned above. 

Coupling seems to be yet another repeating issue in your code - it limits the reusability. Your code made a lot of assumptions on how it is going to be used. For example: You seems to believe that's the code will only be executed in a context where you do have a Console? What if you don't? Like when it is ported to become a service, or a GUI application? Environment.Exit() is another. Why don't you let your caller to choose what to do when the file is invalid/not found? The path is yet another. What if it is used in another environment without that particular path? The general principle is as follow. The less policy you put in your code, the more reusable it would be. Of course, more effort on the caller side to specify them. For a utility class like this, it would worth the effort to make it reusable. 

Why do you use Logger to encapsulate the Console for output and then directly do Console.ReadKey() later? 

You print out "Start" to the standard output. This basically restrict any usage of this class to have access to a console. What if it is used in a GUI application? What if this is used in a server application? Also, "Start" what? Whoever read the console will have no clue what is started? The object is constructed as a static field, and Java did not guarantee when these static constructor are run (they only guarantee it is run before the class methods is run, so it is basically you have a console print that is shown in non-deterministic time. This is not great too.