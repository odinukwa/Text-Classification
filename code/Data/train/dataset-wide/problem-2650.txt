Via this mechanism it is possible to make a type implement a wrapper interface without writing boilerplate. It is more common in the form of than in this form though. Final words Lastly your code formatting is in need for some improvements with respect to indenting the anonymous classes, but it may be an oversight and the rest of the code looks great. When I have some time I'd be eager to show you a pure Java 8 solution as I strongly believe that Apache Spark is making a mess of your code currently. I do understand however that you need to operate with Apache Spark at some point and for that you may be forced to use Apache Spark's classes. My method using Java 8 As addendum I'll show how I would identify your problem in question and show you how I would do it. Input: An input file, consisting of words. Output: A list of the words sorted by frequency in which they occur. 

Besides deciding if a coefficient is valid or not the function can also say what is wrong and suggest how the user can fix it. In order to communicate such information up to the caller and up to the user interface you can use throwing an exception. Main success scenario would mean no s, just sequence of statements. Exceptional flow would be encoded in blocks, either in this function or somewhere upwards or in the final handler. Whether the code would be easier to maintain or not is only opinion-based matter of taste and your established coding conventions. The main improvement would be that the end-user would know what happened and what to do next. See also: 

Nowadays I would look for the appropriate algorithm in open source codes of a library that does it well, besides Google I'd take a look at Windows Presentation Foundation (WPF) source codes, e.g. $URL$ 

I have decided to create a dashboard view of a number of running processes/programs/applications, because it became tedious to monitor a bunch of applications, which I had to boot up manually. Please keep in mind that the .fxml files have been autogenerated using JavaFX SceneBuilder 2.0 and hence may not have proper formatting, but are necessary if you want to run the program. I'd like a review on all aspects and the design may also be reviewed if you wish, but I'm not a GUI designer. Dashboard.java 

I have decided to create my own , because I wanted some abstraction and a couldn't give enough in my opinion. I'm also using the class, as I really like how it is being used in JavaFX 8 and figured it would be useful. The basic properties of a cursor are: 

are simply too long. Your code would benefit from giving a static method that creates a new , more over it seems that the parameter is specified two times there, though I might be wrong. In either case, your static method would be called as or . This also hides the specification of the type parameter multiple times. 5. Use try-with-resources if possible I do not know all places where try-with-resources is possible in your code after a brief look, but the following seems a good candidate: 

I see as open question how does your code handle the edge cases (extremely black "theme" or extremely white "theme"). In order to decide if your shading algorithm produces good results, the only way is to draw complete shaded color space map and decide if it is "pleasant" by consulting several users. There is no one clear answer and although a various color theories exist it is mostly the graphics designer who makes the decision (not a machine). Some decade ago the code below worked for me (found by guessing) and was able to reproduce what the lighter/darker color calculator used by Microsoft Windows Control Panel did. When user chose a COLOR_3DFACE this calculated appropriate COLOR_3DLIGHT and COLOR_3DSHADOW 

pattern is easy to follow and it prevents unintended memory leaks nicely for byte-to-byte memory compare in better use built-in function instead of custom array traversal. In an old language runtime source codes this function was implemented in optimized assembly language using for file-offset is not very future-friendly idea considering that it is normal (for average end-user) today to work with video files in 4K resolution where single file size can be >4GB using Memory Mapped Files for read-only file access will give you simpler code (whole file is an in-memory array) and faster I/O operations (on-demand reading managed by OS kernel code). This method can give you significant boost if the original file is big and the searched-pattern is located near the beginning of the file the loop should end at (+/-1) as beyond this boundary the pattern can not be found anyway you can get some speed by comparing against the original byte array just offset by the index. Creation of the intermediate would not be necessary (throw away, safe some memory allocation and memory copy CPU-clocks). Like this: 

For every provided regex it creates a pattern and matches and replaces the occurences with the replacement. It is also important to look into now: 

But it can be done way simpler, just use . I can see you thinking: "It doesn't work with arrays", well... it does! Watch this and read the explanation: 

The background of this is that this is processed OCR output and I want to force a word to match a certain regex. If it cannot find a match, it should return an empty , otherwise it should return all that match the specified regex. Example: 

The code is not intended to work with the and classes just yet, I have only included those classes such that the code is complete. The code is also available in my GitHub project. 

A mapping that can safely map instances to . The only methods to interact with it are and , the ensures that the types are correct on compile time, it also uses which is from Java 7, but you should be able to convert that. The method can safely cast back to , because the method ensures the types.