you have a simpler run-time execution model. your exceptions, if any, related to creating the MessageProcessor have better traces. you do not have complicated circular dependencies at construct time. you only create instances for types you use. 

Not that this would ever be recommended, but, it can happen. The character-by-character parsing system you are using is also not great. The best way I have found for doing this sort of expansion is to reverse the logic. Take all the environment variable names, and see if they match what is in your string. If this is something you are doing 'often', then I would recommend you build a class that can handle this: 

There are a few minor things, nothing too serious, that I feel can be improved. Java 8 From a Java 8 perspective, you have a function with significant side effects, which is bad practice. The modifies state outside the function which makes it a poor practice. Instead of modifying , you should return a clean with the right values applied. If you need to merge that Map with afterwards then use . Additionally, you have some blocks where too much functionality is happening in one place. Personally, I am not a huge fan of declaring concrete instances of Lambda-based constructs in Java too. I feel that if you have something like that you are doing something wrong. It restricts the application of the logic too much, and it is what I personally consider to be an anti-pattern (though it is too early in Java8 'practices' to say that's a common thought process. As another criticism, your exception handling can be improved. Why the ....? Any time I see that I wonder what the programmer is thinking..... On that topic, when you report an error, you should at least try to help the user by identifying what file failed to parse. "Unspecified parsing error" with a stack trace does not help the user to identify which file failed. For example, taking this code: 

A listener and callback mechanism is a common pattern in many places in Java. The logical place to look for examples is in the Swing API. Will get back to that in a second, but, there are two items that are useful first: 

you do not start with the at (you know that for the first check...) It is common practice for the 'right' index to start at the length (i.e. to be 1 after the last member). you have odd handling for the duplicate value case you are returning instead of you are not swapping the pivot to where it belongs.... The point of the partitioning is that you are supposed to end up with the pivot value where it belongs. you are not checking for left >= right on the increment side of the partition loops 

That runs the benchmark on both your function, and the Scanner function, and does a warmup run (to get JIT optimzations done), and a "Final" run to get real results.... what are the results, you ask? 

Sorting of enums in their natural order should not be a problem. As for the general case, I think your system is OK. I can't think of a better way to do it... the Map seems expensive, but it is small, and limited in size, and should be fine. For small input Lists (less than 5 or so), I would consider a simple Array containing the members, in order, and loop them checking each one.... and returning the index of a match. Benchmarking may prove enlightening. 

So, the sum of all 3 and 5 multiples less than n is easy, but there's a probem.... if we add the two sums together, it will count the multiples of 15 twice..... so, the sum of one 15's series is: 

Alternatively, if you need to create the full array for other reasons, consider the slice and concat: 

Right, talk about confusing. This code is written about 'suffix search', but all it does is prefix-search. Suffix happens at the end of the word, prefix happens at the beginning. 

Your algorithm is way off.... ;-) Let's consider the solution to a decent number. For any decent number, the more 5's we put at the front, the better. So, let's break it down to some maths....: 

(See ideone here) Without the conditional / ternary operator it is more likely to be tighter/faster code as well. Comments You have used magic numbers, so you attempted to document them with a comment: 

Additionally, it is a small thing, but if you have , , or , inside a conditional inside a loop, then there is no need to use ... It is just a small thing, but your code could be: 

Problems like this are often "academic" in nature (although the principles can be applied to other problem-spaces too). In this instance, I believe that the challenge is to use the correct form of "modulo" and integer-division type arithmetic and to have a "simple" conversion function for each target element. Your initial output array creation looks good: 

Note that the matcher looks for three comma-separated number-groups inside explicit parenthesis, with an optional trailing semi-colon. The parenthesis around the in the pattern makes those available as groups. The (expanded) pattern is: 

That takes the second letter from the Enum name (e.g. it will pull from ). Since all your Enum names have a systematic name scheme, this will work, but, it's not the best system... But still, once I have the working off the internal values of the enum (instead of the ), you can do the following: replace the line: 

What does the above code do? It converts the long input value to a string without any spaces. It uses the and from that, it subtracts the full number of blocks that have to be padded. So, the following table gives the 'input' and 'end' result: 

There are some confusing aspects to your XML, and some practices that you may end up appreciating..... Technical Your XML is valid, but it does not follow best practices. The XML: 

is a tree where the node with value is broken. It should be to the right of the root node . Using your logic, the left and right nodes for node are good, and the left and right nodes for node are good too. You will declare this tree to be 'good'. When checking node 5 you should be comparing it on the left side to and not to in order to isolate the problem. In other words, when checking a node, you need to check the maximum value of all its left-sided children against the minimum value of its right-side children. While the sample code you have uses a recursive process to do that, you can also use a more complicated approach that does a depth-first traversal of the tree, and 'carries' the max (or mmin if you had to go down the right-side) value up from the bottom in order to test the state of the parent node. This method will reduce the scalability complexity from O(n log(n)) to O(n) I have taken the liberty of writing a 'carry-up' version of the check which will visit fewer nodes to do the ckck, but will also do a bit more work at each stage to calculate a Min/Max value. The full system, using the same tree as snetch suggested, looks like: 

Note, I have used a printf at the end to simplify the logic of the output. Well, it is simpler for me, but, I thought you should see how printfs are used in Java. What that printf says, is print a floating-point value with 3 decimal places (), followed by 'mph', followed by a newline . The floating value to print is the speed. 

This, and your past few questions you have asked, have been progressively getting better. In particular, the naming of methods and variables in this question is much better. You are suffering from 'Hungarian Notation' in the constant name. There is no need to call it because we know it is a String. A simpler name would be fine. In order to take your programming mindset to 'the next level', you have to start to abstract the functions from the particular use case. How do you write your program to solve a general problem, and apply it to a specific use case? In this program of yours, the guts of the function can only solve one problem, changing to , in a single phrase. What I would like to see is a more general use case. In this problem, you have three Strings: 

Performance There is a trivial, but effective optimization available for you, by breaking the inner loop when the product will always be less than the previously found largest. Consider the code: 

There are a couple of suggestions I have here. The first is a major performance one... you have the code: 

I know, it has the magic number for the k loop, but at least it checks each key.... Ideone I have put my recommendations in to this ideone... take it for a spin 

You do not override the hashCode of , so the result is just a somewhat unique number, and thus, even if you have two trees with the same value at the root, they will have different values. If you override equals, you have to override hashCode, but, if you override hashCode, do it properly! The Performance issue relates to the core addItem method. Your method is an \$O(n)\$ operation, scanning almost the entire tree, to get to the last item added. A better algorithm would be to maintain a stack of the path to the most recently added node's parent. This would be maintained at the same time as the root node.... consider: 

Code Style Java Code Style puts the open-brace at the end of the line, not the start of the next line. For example, you have: 

The above array will be used to say: Anything less than or equal to the value at index will have have bucket . We use this table to build the actual lookup table: 

You cannot avoid having the input arguments to the function. This is a "drawback" of Go. When you become more comfortable with the language you avoid constructs like you have, because they are hard to maintain (anything requiring is probably a bad idea). Additionally, your usage is broken - you need to manage the lock on both the call, and the call. Your call is also broken because it has a race condition.... Note that reads on the map also need to be sync'd, not just writes. So, this code: 

Your code indicates that you have a serious problem with your object oriented design. Objects are supposed to be 'opaque', and you should not be able to see the structure of the data in your object. Instead, you have this code, which is somehow able to access: 

Now, here we have a stream of increasing long values, and we can report progress, so let's convert that stream of counts, to a stream of values... 

Now, all that's left to do is strip the last line's end-of-line marker. I struggled with this, and while your solution may be more reliable, I was tempted to suggest just stripping the final bytes with something like: 

the value at this point plus the sum of all values above-left of us plus the sum of all values above us plus the sum of all values to the left. 

General Now that you have such neat postings, the answers are going to need to be neater too. GUI Bugs When I run the GUI, it does not let me select directories from the File Browser. It also starts in the 'Documents' directory, and it would be better to do one of two things: 

Q: How many threads should you have? A: 4 - the management thread, and 3 worker threads. How many threads are in your code? At least 24 .... potentially hundreds .... let's count them... 

This class is... problematic. It is not thread safe at all. It has a mix of 3 different concurrency tools, and each of them has problems. Volatile is almost always a bug. If you think you should be using , you are wrong (almost always). Textbooks like to cover , but "in the wild" it is about as common as the Sasquatch (clever pun there...). In your code, for example, is only ever accessed from inside synchronized methods, so why is it volatile? Atomics You use to keep the lap time, but you have a race condition: 

Simplified ToDecimal Similarly, for the function, I would keep most of the calculation in integer space... Your code is not to bad, but can be improved: 

I think you need to work backwards from a 'this is the way I want it to work' concept, and then implement the ClientData class to match. A sophisticated ClientData class would only give you valid hosts (or hosts it believes are valid). To do that, it is useful for the ClientData to know when a host succeeds, as well as when it fails. If it know when hosts are being used, it would also have the ability to load-balance different threads against different servers, as an added bonus. This is how I would want to structure the use-case code: 

add as a prefix, even though it is slightly redundant Make them final... one variable per line... (it makes revision-control diffs/patches easier to read) 

Your regex is not matching the value properly because the character may not be mapping directly to the regular character in your regex. You should use the 'whitespace' escape-sequence in your regex instead of , like Unicode string literals in python should be escaped with either the or escape, but they are different: 

This is not doing what you think it does. Because the instances are the key to the WeakHashMap, they will never be garbage-collected (the key is a strong-reference....). Using a WeakHashMap is complicated, and harder to describe than what can easily go here. 

I like the solution you use by filling a set with all possible matches. This does indeed make the lookup a \$O(1)\$ operation. The naming, style, and presentation is all fine. I have a suggestion about the algorithm for computing the permutations of the starred words. When dealing with problems like this it is often most convenient to use bitwise manipulations.This will eliminate the cumbersome storage of the . To explain it better, consider the word . This has 4 letters: 

Note that I put the column level items first, followed by the constraints. I removed the one redundant CTE. I put the colum level queries first because that's the order of building the create-table and I feel that makes the query flow better. I got the query working in the following SQLFiddle. As for the XML hack, this is a common hack to need when confronted by your circumstances. The right solution is to remove this logic entirely from the query.... and process the data in either a cursor, or in a third-party application. SQL is not designed to solve the problem you are throwing at it, and you are thus running in to its brittle components. Pull the data in to a tool like Java, python, whatever, and process it better that way.