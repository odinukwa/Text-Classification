Now the controller expects a bookisticsEntities instance as constructor parameter but the default controller factory in the MVC framework only can use a parameterless constructor so you need a solution for this; use a dependency injection container like Ninject! It's easy to use available through Nuget. N-tier It seams to me your application missing one or two (maybe three) application level becouse currently you managing the database directly which is not a best practise. You have to build at leas one level between the MVC and the dataaccess tier which is called business layer (or two: a service layer and under that a business layer). In this way you controller will expect one or more different type of object instances but not your database model! If you are done whith this you can use simplified models in your application, for example in the Books action method you can use a model which can contain the author's name, identifier and the books also (books can be simplified also). Learn Entity Framework Read a lot about how EF works. :) 

No need the type magic A key cannot be null and it should be a ValueType An Equals and GetHashCode implementation should be symmetric and fast (your solution is slow and i'm not sure it is symmetric or not) 

Factory basics If we talking about MVC then we have an object oriented system which contains a lot of objects. Factory methods and classes mainly exists to help instantiate other orbjects. Look at your code; is your factory do what it have to? No. Your factory only loading a file in a strict way, you need a class loader as Wouter J suggested. Learn how PHP namespaces work ControllerFactory If you have a class loader then you can build a real ControllerFactory. What should it do? Get the controller name (namespace + controller name, not file becouse the actual controller is a class!) from the input parameters (route data) handling all namespace and naming issues (for example not only in your controllers "folder" (namespace) can contain controllers). If we have the controller (full name and the class exists) then we have to instantiate it. A ControllerFactory can handle some kind of dependency injection container to allow controller classes to have parametered constructors. If there is no DI container available, then the instantiation can be really simple: new $namespacedName() The ControllerFactory it self should not be static becouse it will be hard to test, the implementation could not be replaced if it would required and we could not pass anything to it's constructor (it wouldn't have a ctor). Ofcourse it can have static methods to set the default ControllerFactory, like: 

If the Place have a string property what can be use at the "is kochi" check then use that in the Any() and leave out the .ToList(). Instantiating the TestDataContext() in this method is bad (can not test the method) please inject it as method or class constructor parameter (you can inject a lambda for instantiating it also). (Syntax errors maybe exists in my code [powered by Notepad].) 

Hide and seek The first method is shorter but is that a good thing? Compared to the second one it hides a few thing internally which can be either good or bad and i would say bad. To me this method looks like a core application logic which has to be crystal clear so i think you shold not prefer the shorter version. But wait The second one still has some coding issues but nothing catastrophe. I have changed it in some parts, lets see: 

What is a router used for? Translate one address to another one connection two different network to eahc other depending on rules. It will never instantita a browser to display for example a HTTP request. Your class doing to much and much lesser than it should Your router should only deal with the input address and not instantiating a controller and other stuff. How should it work? 

The tricky part is how you handles the transaction. I have created an ISession interface with some methods (BeginTransaction(), InTransaction, Commit(), Rollback()) and created a default implementation. In my default IUnitOfWork implementation the constructor recieves an ISession instance and starting a transaction with it. The ISession implementation has an inner counter to count how many other actor started it's own transaction. When an IUnitOfWork from the shared storage Commited the counter is decremented by 1 if someone says RollBack then everything is rolled back. EDIT (Dec. 03) Fixed the IUnitOfWork Dispose behavior: the default is Rollback() not Commit() In this way you can test your code easily. 

Maybe a god approach would be to use extension method when you would duplicate data if you would put another property or method into your class. In your example you would do that: storing (i know you don't store both of them) the date of birth and the age is redundant. 

Svick is right Use the AggregateException class to collect all exceptions you need. With AggregateException everyone can prepare it's own code to handle the multiple exception situation but with your original solution they have to handle a huge string in a stock exception class. How can be this usefull? Storing exception.Message It's bad. If you store only the exceptions' messages you will loose a lot of information and the types of the exceptions. How would you handle an exception if only the Message is what you have? Parsing it? And we havent talked about the specific properties of specific exceptions like some validation exception which can contain the unvalid property name and value for an object. 

[ThreadStatic] - DO NOT use in threadpool environment (like ASP.NET) When the threads' lifetime isn't managed by us do not use ThreadStatic variables becouse the threads will be reused after every request (in ASP.NET) and we can accidently share variables and their status across multiple threads! 

This will mean that if we have an url like book/details/5 then the framework somewhere will instantiate the book controller and call it's details method with parameter 5. 

First i have introduced an overloaded method to remove the null check against the List (null object pattern for collections are the empty versions of them). Changed the type to ICollection which is more flexible and intruduced a new static member which get involved in the process where no parameter is passed (can be static for reading it is thread safe). I also removed the AddRange call becouse internally it is interating through the parameters with a foreach loop but only works with Array type parameter so after introducing our foreach loop calling Add manually we have removed an extra ToArray() call which would involve an unnecessary memory copy in the background. Also changed the fill of the DataTable to a more used way and the MySqlHelper.ExecuteReader() does the same thing too. 

This is bad it makes the code dirty. Do not write these kind of try-catch block, they are unnecessary and this one especially bad becouse it will not work at all. When you are not in the global namespace in your catch block must reference to the base Exception type with the namespace qualifier (\Exception) if you want to catch all exception (if you got an Exception class in your custum namespace then it will work but please rename it a custom one). (My code may contain typo-s.) 

First i have provided az overload to avoid unnecessary passinf if the IEqualityComparer and in the method i'm checking against null values. Then checking their references because if they are the same there is nothing to do. After this i'm using the as operator to check if the input collections are real ICollections and if they are are their Count equal. The casting is fast no need to iterate throught the IEnumerables to get a fixed size collection to get the item counts. Next step is to get the item counts it is using a Dictionary (as Hashlacher did it) with another casting to try get the initial size of the dictionary (not good idea when we have a list with 5 million items but every item is the same). If we have the counts we can make another checks against them: if the item counts or the null counts aren't equal then the collections aren't equals. If the counts are OK then we try to check every item from the source collection whether it is in the other or not. If not the collections aren't equal. 

An API key only have to be unique enough to avoid collison nothing more and here you are doing to much to achieve this. For example the rehashing will incrase the chance for a collison. I have created a class for generating unique keys for example an API key usage or simply for primary key in a database table. 

DO NOT LOCK ON EMPTY STRING In .NET every string is stored only once in the AppDomain so if you are locking on empty string everything will stop until you release the lock. The correct syncroot can be: 

From the IP validation point of view null or empty IP addresses are exceptional actions so you can not say that two null or empty strings are the same IP addresses becouse they aren't IP addresses and sometimes not even strings. And you don't have to sorrund the logic with try-catch block becouse it will eat usefull information when things will get ugly. If you don't want to deal with parsing exception then use IPAddress.TryParse it will be faster becouse throwing an exception is always a heavy weight stuff (check it with profiler).