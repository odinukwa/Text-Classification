Let's say the input data has 1000000 members, and we need to swap 10 of them... array contains.... do we really just keep guessing until we hit a random value that is in the data? This is... a problem. One solution which will produce a suitably random distribution of the swapped items relies on a 'simple' algorithm which does just one rand() per item, and there's no guess-work. This is done using a fisher-yates shuffle. But, for this problem, we don't shuffle the items, we shuffle the indexes... so: 

That's a relatively complicated loop. It puts both the readline, and the loop-check in the same place. It reads the line in to , then also makes sure that is not empty. While the above is relatively uncommon to see, it makes the conditional really concise, and reduces duplicate checks. Oh, and using a on the resulting list makes the print really easy.... 

As a result, you don't run in to the duplicate data issue quite as much, and the sort is fast. Then I removed the from the random partition, and just used the mid-value, and he results are: 

Generics Generics... you want them. In your solution, they would be relatively easy to apply too. Consider your Node class: 

I wanted to make it configurable (specify the folders to back up outside the script) sometimes the backup was long-running, and another backup could start before the previous one completed (these snapshots are taken at every hour). My monthly backup routine copies the entire snapshot disk to an external drive, and this takes hours, and I want the data to be consistent on deeply-hard-linked files is a slow process.... so I had to remove it from the script.... 

Your code is a bit messy, and buggy, and you have a significant memory problem in the event of there being a lot of test cases. Buggy The problem specifies that the number of candies (N) and children (K) is a value \$0 \le N,K \le 2^{33} - 1\$ The telling part is \$2^{33} - 1\$. That number is larger than a Java value. You need to use in order to support the specified input values. Messy You declare the variables: 

Your version You have a bug in your three-loop implementation. This sort of bug creeps in when you use copy/paste to code without being diligent about checking what's useful. In your 'k' loop you have: 

There are two major issues I see with your implementation, one functional, and one performance. You have implemented the method and, additionally, you have implemented the method too. It is good that you are implementing them both, but, they are broken. The hashCode() method only calculates the hashCode of the root node (if any), and it does not calculate it off the value in the node, but off the node itself. 

Pre-computing the possible moves, and reducing the conditionals to a simple mathematical expression is a nice way to solve problems like this. Your code also suffers from repeating blocks, and duplicated logic: DRY - Don't Repeat Yourself. Solve that by doing function extraction. Finally, your code is full of magic numbers, which are prone to leak bugs..... Consider the following code, which, though longer than yours in terms of lines, is actually significantly more readable (except for the complicated 2D array, I admit). 

Update: As per your comment, the use of ReentrantLock and Condition is not necessary. I prefer to use consistent locking mechanisms in my code, and I have 'standardized' on Locks. Locks can do anything synchronization can do, and then more too. Unless you have many thousands of events all happening at once, the memory cost of the locks would be negligible. Still, I agree with the sentiment you expressed. The same can be done with synchronization: 

Note that in this case the utility method has moved outside the constructor and is now part of the invocation... but the concept is similar. 

9765625, but let's call that 10 million Now, each list is a which creates a instance for each member, so, each LinkedList has 6 instances created to store references to the members (and the list itself), so, let's just say that each instance is 32 bytes (which is about right - by the way).... that's 

Could this be considered a basic brute-force? Sure, for a limited use-case, but even then it is pretty inefficient. To be clear, normally a brute-force system requires checking all combinations against some hashing function to see if the hashed result matches the hashed password. For example, imagine the password is "password", and the hashed version of that is: (that's the actual MD5-hash of "password"). What you normally have for a brute-force system, is the hashed version, not the original version. You would normally have to generate many possible passwords, and hash the results, and then see if the hashed results match the known hash, and from that, deduce that the passwords must have been guessed. In your case, you are just checking each letter 1-at-a-time, against the raw password. That's not a very realistic situation. Still... you are brute-forcing things. Let's work your algorithm to make it more efficient though. What you are doing is reading files until you find one which has a password that is only letters through . How about code that does the negative of what you have: 

At some point everyone ends up trying to parse HTML. And, in some of those cases, it is even unavoidable...... ... but, some suggestions (in order or preference): 

get line source get a line, find if any parser can handle. feed lines to the parser until the event is parsed when the event is parsed, notify the listeners that work is done. return the parser in to a 'fishing expedition' looking for a parser. 

You can see the above running in ideone: $URL$ Note that the concept of describing an element in an output array as a function of the output index is sometimes a nice "trick" and neatens things up. You have to be able to spot this, though, in real code. Note that the above code basically says where is some function taking as an argument. Your code, on the other hand, works off the source index, and it tries to calculate the indexes in the output array from the source location. That's not "wrong", but as you can see, it makes for a nested, and ugly loop. Knowing when to reverse the logic is more of an art than a science, but being able to identify these logic inversions is important. 

Note the use of the Common Table Expression (CTE) to reduce the complexity of the final select. There is no cursor needed, no temp table, and the operation is set-based. 

That can print any 2D slices, not just arrays of a very specific dimension. It makes it reusable. Changing to slice from array would be quite a change in your code, though. Constants Your use of constants is impacting the code in odd ways. I mentioned the array-to-slice above, but it also impacts things like passing pointers in to arrays instead of slices, etc. The names of your constants are also "horrible", , and are ugly. your constant is a better name, but really it is a computed value: . I would not use it at all as a separate constant. Constants in general are a bad idea, unless they really are constants. The dimensions of the board should be passed around, or inferred, as parameters. Channels Your use of the result channel appears to be a good idea, but it runs the risk of failing when no result is found. The fact that the 8x8 board has at least one valid result means that you are lucky, and that the channel completes OK. If there was no solution, though, your code would hang indefinitely. You would be better by having a combination of a waitgroup and closing the channel if/when the waitgroup completes. it would be best to solve that problem in it's own method too. It makes the process easier to read. Dangling go-routines your code does not clean up any go-routines that are still working when the first solution is found. You should find a way to terminate these routines cleanly - this would make your code usable in an application that does not immediately exit on the first solution. You can use a select-with-default on the channels to implement a killer. 

In that way, you maintain the 'atomicity' of the transaction - the value only changes on a successful insert. I would consider using a stored procedure to encapsulate that logic. Note that you are still vulnerable to someone deleting records, you will still end up with gaps. 

the maximum sum will come from the combination create an array with space to count sum instances up to that magnitude start with a collection of N=6 balls with an upper limit of value 49. record that sum in the count: 

Java class names should be CamelCase. Your class should be . use whitespace in lines consistently, especially around keywords and operators. Lines like: 

Like, really? What value do those add? Oh, I see what those are...... right. You have created those interfaces because you don't have the generics on the Parser. I get it. You don't need them at all, you can just have: 

Then, because that is private, noone else can ever lock on it, only you. Who knew that bare Objects would ever be useful? Now you can use it like: 

Note that the above stream technically has side-effects in the folder, as the folder is stateful. Here's the complete code I have for the above solution. You should be able to copy/paste and run it: 

and also in the calls in the checks. If you change your method signature to be a generic method like: 

Your algorithm is relatively clear to see, and it makes sense, and it works. In an interview, these are good things. Your algorithm is an \$O(n^2)\$ algorithm in time complexity - for every value in the array, you effectively check every other value for duplication. There are a couple of things I would note here, though. The array is unnecessary. Instead of marking all 'future' duplicates of the value, why don't you check all processed values so far? Consider this "inner" loop: 

Short Answer Yes, I believe it will be functional.... Dubious Recursion Calling this method recursive is a problem. It is not a recursive method. Just because it is calling itself does not mean it is a recursive function. What you have is a bad loop. From Wikipedia: 

Update I have rewritten the OP's code to extract the stream preparations. Consider the following code: 

Metrics like the cyclomatic complexity are only useful when taken in the context of your code. For example, your method has numerous calls to JSONObject where it could throw a JSONException. Each of these calls adds one to the complexity (or should do). On the other hand, I think your exceptions are not overly complicated, and the code looks fine. So, in this case, I would look at the code, and note that with 5 calls to and at least 8 conditionals, that's already a complexity of 13... Then the additional 2 catch blocks, brings you to 15. For the method, as I look at it, it seems just fine (the complexity does, anyway). I would be more concerned about two other things (bugs).... You have a concurrency bug (same bug twice), and a poor Logging bug (multiple times). Concurrency Bug Your code: 

The deviation you see from the expected results is probably in large part due to the poor use of . When I time your code, I get: 

The last removes the trailing space on the output. The actual suggestion I prefer, though, is using a format String, like: 

You have a single thread handling all network processing. A CPU is faster than a network connection, so, just so long as you had fast processing, a single thread is more than enough for an interface. You can reduce the number of active threads from 1-per-client to be 1-per-CPU (or so). 

The magic number here is . What is that? The number of quotes? Does this mean that you have the switch statement: 

Your problem is not really a fizz-buzz problem at all, it is a sum-of-sequence problems, and is commonly based/equivalent to the first "Project Euler" challenge Note: your code has a bug, you are supposed to sum values that are a multiple of either 3, or 5, but you are summing only the multiples of both 3 and 5 (i.e. 15) that are less than the number... There is an algorithmic/mathematical solution to this which completely removes the need for the iteration at all. Consider the sum of all the multiples of 3 less than ....: 

Other answers have good input on a number of factors I agree with, especially about the early-return logic, the bugs that were pointed out, and the bracing strategies. My suggestion though, is to use a different (the right?) tool for the job. Regular expressions are a tool that are designed for text processing, and a well-crafted expression is typically faster and more concise than the hand-coded alternative. Regular expressions are not always the solution, but in this case, the result would be simpler to read (for someone familiar with them). In this case, the logic requires checking that all 'g' chars are happy for the check to return true. Alternatively, to make sure there are no unhappy 'g' chars. The expression to check for unhappy 'g' chars will be: 

Now, you have a folder dedicated to the current process (and collisions with other running instances of your process are impossible - at the same time - though there may be an old instance of that same folder for an older process - that's OK). Then, create a counter (a "global") too: 

Now, you need error handling on the Scanner, and it needs to be closed as well. Without that, you have a program that is ugly when a user types in . Since you have no error handling, you may as well just junk the lines with the Integer... And, there is no reason to convert the StringBuilder to a String directly... Without error handling, you can: