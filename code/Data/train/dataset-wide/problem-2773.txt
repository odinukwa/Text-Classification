Yes, the Single Reponsibility Principle can apply to methods (I know that article is geared towards Swift but should hopefully still be practical in other languages). While there are guidelines like this answer: 

Overall I think it looks pretty good as it is. I like the use of functional programming (i.e. using ) and the recursive functions. There are a couple minor changes I would make: parseInt radix Pass the radix (usually 10 for base 10 numbers), i.e. the 2nd parameter of parseInt(), to ensure that input with leading zeros or other numbers will not be parsed contrary to your expectations (e.g. this scenario): 

That way, we keep a reference the element that was just created and don't have to query the DOM for a reference to it. The same is true for adding rows (and cells). The following lines: 

A while back, I went through these exercises about functional programming in JS and since then I strive to use those techniques whenever possible. Bear in mind that functional techniques can lead to slower code, since a function call is made for each iteration instead of just running code within a loop block, but hopefully it is easier to work with each array element in that fashion - e.g. would you read/type or ? After reading Igor's answer as well as this article about with respect to functional programming, I believe the following should work: 

in my eyes, in the case of deciding between two options, the short form of the if statement can be used to make it clear: 

this elimiates the switc statement. you can get a instance directly from the argument. 3.3) Make use of Lambda expr Looking at we see that this fits the Functional Interface definition. This means that instead of having to write a separate implementation class, we can write a Lambda expr as the enum argument: 

This design also greatly simplifies the code for deciding what to cast (hint: oyu can get to an enum instance from its String name using ) now what about maxLevel? is it the same for all skill types or different? Moving on: in your game, every has the same set of skills. that's fine. but every develops differently and this should be reflected by individual Skill instances together with the attributes that can modify a basic `Skill' 

in addition, interface contains a method that returns a boolean. how do you plan to prevent clients from calling it? 

See it in action on Teh Playground. What would you do differently, perhaps for readability, performance, etc.? Would you take a completely different approach altogether? Update 10/6/2017 Taking the suggestion by J H, i.e. "You're doing a linear scan through an array. You'd be happier if you were doing hashed \$O(1)\$ time lookups in a set (or map).", I have updated the code to use the end time as the index of the output array (i.e. the hash map). Also, I have incorporated more functional techniques (beyond array_map()) and used array_reduce() to iterate through the timeslots. By using the end time as the index, the code will look for that end time in the array and if it exists, then combine it, setting the last start time, moving the combined timeslot to have the index of the new end time and un-setting the timeslot at the previous end time. Then when outputting the times, the keys don't need to be considered for the output, since the output only needs the start times. A great advantage of this is the need for referencing via the statement within the lambda function is eliminated since we aren't iterating over the keys anymore. 

Note: the posted code does not specify how and which are mentioned in the statement are declared. note that these will have to be final in order to be included in a lambda expression. 

First of all, ? come on... how hard is it to call it or ? (no need for , we can see its type) but what does the line mean? why are you asking about the first character? ok, you want to know if the subsquent String is to be added or substracted, right? so why not make a method that returns an enum that has values and then you can have a separate method that accepts enum and performs the actual operation. The benefit of this design is that you are better prepared for new operation requirment like which will mean... I don't know, something. Now that I think of it, perhaps you can add the identifying character to the enum values and then in you extract the first character and search for the matching enum, which is a behavior of the enum: 

For the sake of efficiency, what you have may be close. As others have pointed out, the selector for the fields to reset the value of could be combined (e.g. the single selector offered in the answer by Roland Illig. Another approach is to use event delegation by adding a click handler to an element containing those inputs - e.g. the document, form, etc. Then check the property of the argument to see if it: 

Then the current code would attempt to load an image with the src attribute set to "jcstine". An alternative is to store the images in a property - e.g. images within localStorage. Unfortunately objects need to be serialized before storing in localStorage - use and to unserialize. 

Why not just iterate over the inputs, and if the values of the id attribute exists in then add the error class and show the affiliated error message, otherwise add the valid class and clear the error message? When the DOM is ready, the input values can be stored in a variable: 

since I know Java :) I have the following comments to add to the previous answer: resources handling Resources, in this context, are the input files you are reading. Their lifecycle is not handled properly. In other words, you do not close the files, leaving OS resources open after the file was read and parsed into memory. This is not a big deal in your program since you only open two files, but it is still a glaring omission. Since proper handling of lifecycle of resources can be tricky, starting with version 7, the Java compiler gives you the feature of try-with-resources, offering automatic closure (and better exception handling) 

The actual iteration over the collection is left to the stream library which may decide to optimize this instead of sequential loop. The code is more concise and clear. 

You can argue about the readability gain. someone who is familiar with java 8 stream api will know what this is about immediately. Naming Convention 1) a getter returning ? 

I think in these types of questions, where input is known and does not change, arrays are bettter suited then Collections, since they offer more concise syntax: is more clear then naming conventions: variables start with lower case. 

Store pair as key, and score as value This way the sorting can be simplified - using asort() with SORT_NUMERIC as . Then reverse the array for descending order using array_reverse(). 

Redundant unit strings Don't Repeat Yourself. It appears that each row follows a simple (yet lengthy) pattern. This can be simplified by pushing each result into an array, and then using Array.join() to separate each unit by . Also, the parentheses around each array element reference are unnecessary. Additionally it appears that the code in the loop over-writes each variable in each iteration. For example, if is 16, then each of those variables gets assigned 16 times, which means every iteration except the last is superfluous! The code below has the loop removed, since there is no need to generate the units multiple times. I also made this jsPerf test for the sample three units in the example. The simplified code typically has ~8 times as many operations per second compared to the original code. I expect for 16 units it would be a much larger difference. 

Advantages: 2.1) all the advantages of static constructor 2.2) lazy instantiation (only when you access the value) Disdvantages: 2.1) still cannot receive an argument during initialization. Although an enum can receive an argument, you have to specify it in the enum value decalration. You can use a setter like described, but then again, you can use a setter with the static constructor solution as well. 2.2) cannot have a parameterized method. 

at run-time you can associate one mixin to the target class. Jackson matches properties and methods by name and takes the annotations from the mixin. overriding any from the target: 

so, I ma not sure how many LOC are now present, but im my eyes, the code is clearer and more maintainable and extensible. 

I am not sure how many lines of code can be reduced but one thing is for sure: whenever you encounter a resource that can be closed, you should use Java try-with-resources feature (since java 7). Not only this feature saves you the operation (one line less!) but also ensures that the resource is properly closed by the end of the try block no matter if it ended successfully or not (the compiler adds a clause). in the current code, if an exception is thrown, the resource is not closed properly. I looked at the thrift javadoc and indeed from version 0.10.0, is auto-closeable. So the code on both methods should be 

incrementing a counter variable inside a The statement has "two syntaxes"1 and because the array indexes of are numeric, the second one can be used to have the value of updated automatically (i.e. to have each numeric index assigned , starting at 0), reducing the initial assignment of the counter variable (i.e. ) and updating the counter value at the end of each block (i.e. ). 

Making the Javascript code more versatile You can query the DOM for all select list elements (i.e. ) to handle the change event on any of them. 

Looking at the three functions that call it appears that the main redundancies are with the click handlers for the buttons. See the response to the question below for one technique to simplify that logic. In a comment, you asked: 

The code inside that conditional could be moved to a separate method. And that click handler could also detect clicks on other elements and delegate to other functions See an example in this codepen. 

Validation with separate methods To keep the string length validation using strlen(), you could define separate methods and call those for each field. For example, the first_name and last_name fields could both be validated by the same method: