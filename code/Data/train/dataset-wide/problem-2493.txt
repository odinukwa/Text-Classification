First, a general note on this answer: I am going to use the type names and , even though in your code they're both represented by s, because it's easier to understand that way. 

First of all, the field in is redundant, because it only stores the number of vertexes which is already reflected by the size of and . Having a property stored multiple times makes code confusing and fragile, because a bug could cause the respective fields to contain contradictory vaules. Also, I don't think should be a field of , because the way you use it, it is not a property of a vertex, but only a value that's associated with a vertex by a graph, so while the field makes sense in the context of a graph, it is meaningless when considering a vertex alone. Now, removing the field from reduces to a useless wrapper class for a , so you might as well scratch the vertex class and simply store the vertexes directly as s in . Now, about the purpose of . Theoretically, it represents the order in which the vertexes were added to the graph, but in your code, it only serves to associate the vertexes in with the edges in . Again, this makes the code fragile, because a bug could cause to contain a set of edges at an index that's not meant for the vertex with the key . Instead, you could store the vertexes in a (I'll just use instead of as per my earlier suggestion), and if you want to preserve the order in which the vertexes were added to the graph, you can use a . That way, the relationship between vertexes and their neighbors is expressed directly by the code rather than an arbitrary correlation between an field and the index in a list. Next, your method can be simplified. First of all, instead of creating an empty and then manually adding every element from a different , you could just invoke the constructor instead of the no-argument-constructor (also, I suggest you avoid using raw types, because generics provide additional compile-time type-safety). Besides, there's an even better alternative: . The advantage of this method is that the returned will not be modifiable directly, but it will still reflect changes to the original map, so you might think of it not as a "copy", but rather as a "read-only access". In this case, you might want to rename the method to (although I'm not sure whether this is really more descriptive or just a personal habit of mine). Also, I see that you are using a for , even though you are mostly performing operations on it, and is O(1) while is O(n) (where n is the list size). Only in do you remove an element from it, but keep in mind that, while deleting an element from a per se is O(1), first has to traverse the list to find the element, which is O(n), while would find the element in O(1) and remove it in O(n). True, removing an element from an can be slow for very large lists, slower than finding an element in a , but unless you intend to create gigantic graphs with hundred thousands of vertexes where you continually remove vertexes in a loop, I doubt you would gain anything from using a . Also, is O(1) unless the internal array must be resized, in which case it will be O(n). Finally, you are mixing up user interface with program logic by including all those statements. I think it would be better to throw exceptions whenever appropriate (like an , for example) and let the calling method handle it. After all, a graph doesn't care whether an attempt to add a vertex or an edge was executed via the command line or by some other erroneous code. 

This reduces the code duplication, but you still have duplicate code, namely the procedure of checking whether both values are non-null and proceeding accordingly. So you could also move this logic into a separate method, for instance, into the method of a separate comparator: 

The only reasons I can think of that your code was deemed incorrect are that it doesn't consider 0 as a perfect square, and that you don't consider the possibility that (although maybe the test defined as being greater than or equal to and this is not a negligence of you). As for the performance, here are some suggestions: 

First, I benchmarked 10 test cases where every array contains 10,000 random integers, with a different random prescribed sum for every array. Here are the results: 

Note that, unlike , this only checks the classes for equality and returns if one class is a subclass of the other. If you want to consider subclasses as well, you can use . You should also be aware that, unless returns a primitive type, you are comparing the models based on reference equality rather than comparing their contents. I don't know what type returns, but even if it only returns a simple , will not consider the contents of the Strings but only check whether the two variables reference the same object (which might not necessarily be the case even if the String's contents are identical), so you would need to use if you want to compare the contents of the two Strings. 

First of all, I don't think using a global variable is going to make a significant difference in performance (if at all), because it does not inhibit the creation of objects per se, it just doesn't cause them to be passed from one method to another. But you are still creating objects with all your invocations of , and whether you pass them to one of your own methods or directly to is, in the end, only a matter of readability. Your javadoc comments reveal that you once had the transcoding methods return a instead of . I would go back to this approach, because then the methods would only access state that is directly passed to them as arguments, which I think would be a clearer code design than if global state is involved (by the way, your method still has a local variable that hides the field of the same name). I know your question was about performance, but your code is so extremely complicated, probably much more complicated than it needs to be, that it would most likely be more than helpful to first clean up and simplify the code before thinking about performance, because then it will be much easier to spot opportunities where you can save performance. The first thing I would rewrite is your implementation of the various tokens and the method to obtain the appropriate token for an , because it doesn't depend on anything else in your code. There is a system to your assignment of the letters to the various ranges, at least until the letter P, so instead of hard-coding every single token that falls into this system, you can write an algorithm that calculates the letter based on the system. The last two tokens are exceptions (for whatever reason), so you would need to handle them separately. 

You are only able to access 's fields and from the method because this method is declared in the same top level class as . I don't know why you chose this design for your code sample, but the fact that you made the method a method outside the class rather than an instance method of makes me think that is also supposed to work "from the outside" without having access to 's internal implementation details, so I'm wondering whether your code design in this regard is intentional. If it is, then I won't argue against it, but if it isn't and if should also work if it were declared in a different top level class, then you need to implement a way for to provide some way of accessing the contents of the list it represents. A way to start could be for to implement the interface , which would require to have an method. This method could, for instance, look like this: 

Other than that, your usage of and looks fine. However, there is a phenomenon called a "spurious wakeup", which means that a thread can be awakened for no apparent reason at all. This is very unlikely, but theoretically, it is possible that one of your two threads is spuriously woken up after it enters the waiting state but before the other thread acquires the lock on , which could result in one thread printing two consecutive numbers if the thread that was spuriously woken up re-acquires the lock. You might take a look at this. Also, your program never terminates. You can rectify this by calling or after the loop. 

That way, no information that isn't needed enters the method, which makes it easier to understand its workings. Also, the following line is really unnecessarily complicated: 

OK, so let's look at your . I see you are using . I won't reiterate what others who have more experience than I have already explained, so I'll just refer you to this stackoverflow question on wildcard imports. Next, you should extend instead of . Using provides compile-time safety about the contents of the list, whereas using the raw type does not. If you extend instead of , then your method will not compile, because returns a , not an , and will be interpreted by the compiler as an implementation of / an override of because the generic type parameter will then represent , thus rendering the method signatures equivalent. In the current state of your code, does not override because with the list being a raw type, the compiler will read the method declaration as , so right now, you have two independent, overloaded methods, one being , implemented by , and the other being , the first of which throws an , because this is what the default implementation of does. Also, you seem to have missed the point of creating a custom implementation of rather than extending . The reason why I advised against the latter was that your database does not accept elements, whereas an does, so extending an and overriding to refuse elements would violate the contract of . However, your current does allow elements, because, for some reason, you removed the check from the code. So right now, your behaves exactly like an , which means that it could just as well simply extend and not override any methods at all, which on the other hand would be pretty pointless, because, seeing as it adds no functionality to an , you could just create an directly whenever you need to create a new database and make the method and return a instead of , effectively rendering the class a utility class. So you should make check for values and return a conforming to the specification of so that you don't violate its contract (this means returning if an element is added and throwing an exception when an element is denied, which is explained in , which is linked to in the documentation of the value of ). Furthermore, by making extend , you don't have to implement the method yourself. You can, but inherits a default implementation of this method from , so you don't have to reinvent the wheel. The documentation of explains exactly which methods you need to implement yourself and which are already implemented by default. Reading it, I see that you don't even have to implement , so I was mistaken about that. By making implement , and, in turn, ( is a subinterface of ), you can use a for-each loop in . Also, the method is now redundant, because with being a itself, anyone with an instance of can simply call on it. This also makes it obvious that calling in your original was pointless, because you were only accessing it and not passing it to another method where you want to ensure that this method cannot modify your database. : Declare inside the loop, as it is not needed outside it. Also, has to be , not . Finally, making a static method does make sense even when is not just a utility class. After all, the generation of random objects does not necessarily have to be tied to a specific database. You could instead move the method (which, by the way, could be renamed into something like , which would be more descriptive than simply "data"), along with the three arrays containing the random values, into the class and make it a factory method for obtaining objects. The act of adding these random s to a database would then be completely independent of their generation, which would be more in the spirit of the Single Responsibility Principle.