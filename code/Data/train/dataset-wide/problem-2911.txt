For the third point — CreatePacket takes PacketData Certainly. I think you fell into a trap in making the factory take the ID of the kind of packet to create. As mentioned in First Point, you used that instead of creating normally when you already knew the type you wanted, on the sending side. So yes, have a static factory include the logic to figure out what kind of packet it is, hiding that detail from the users of the class. Then, since the factory has the data, why not have it do the deserialize too? You are already dispatching to a function that’s written separately for each class. So pass the data through to that! 

⧺C.149 — no naked or . Probably, and should be , not raw pointers. It goes deeper than not freeing nodes when you delete. You seem to be ing nodes all over where it makes no sense whatsoever. 

Core Guideline C.149 — no naked or . You should probably make this a as a drop-in replacement without otherwise changing the architecture. inline pthread_t &get_pthread() {return m_render_thread;} This is a pure accessor; it should be . It’s already been noted that the keyword is not needed here. I won’t repeat the earlier observations on the overall class design. 

Problems I’ve looked over the code in more detail, and I see what is the central idea: Your receiver object is not necessarily controlled directly by a shared_ptr, but may be used in any manner, such as a subobject or local object. So, a proxy is created which points back to this object, which is itself controlled by a shared_ptr. The destructor of the object drops the reference on the proxy which renders subsequent events able to detect that it is no longer there. However, this will not work. Consider: Receiver Object destructor is called. It goes on its merry way tearing down the Object, all the while the EventReceivable’s shared_ptr is still unchanged, so events processed on other threads or recursively will hit Receiver Object while it is in a bad state. The inherited EventReceivable is destroyed last, and it drops the reference count. Meanwhile, suppose that an even is still being executed on another thread. It is holding the reference count, so the EventReceiver is still alive, still pointing to the now defunct ReceiverObject which has had its memory reused for something else. Another event being processed, perhaps on a third thread or as a nested event to handle, sees the Event Receiver is still alive and proceeds to use the bad pointer. The point is that you cannot use a proxy lifetime manager stand-in like this; you must reflect and affect the actual lifetime of the underlying object! 

Likewise for the other array looks. You also have (one space) and I don't know if that's what you really meant. I’ll assume for now that you mean for the name to be empty (that is, blank). Strings initialize themselves. If you wanted to initialize to something other than empty, you would put it as an initializer in the constructor, not an assignment in the body of the constructor. That’s true about all the stuff in the constructor — nothing you have there should actually be in the body! For the plain int and double values, you can use inline data member inititializers to good effect here. 

Tell your instructor to become familiar with the Standard Guidelines. You can find presentations on youtube where Stroustrup introduces this as a keynote speech, and many others speaking on them since. 

In C++, the style is to put the modifier with the type, not the declared name. This has been true since Bjarne’s original book, where it is pointed out explicitly. 

You know already returns a . You do not need to check that against again. In fact, it’s rather silly. 

You don’t need say when it is defined inside the class like this. Don’t use to refer to your members. 

Certainly! Read through and bookmark the C++ Standard Guidelines. Numbers I note later are citations from this. Don’t write . Prefer prefix over postfix 

So just what is it you’re trying to achieve? I did not understand the paragraph at the beginning of your post. Let’s decode the code: For each block in A, For every block in B that is different from the current block in A, copy it to . For each block in B that matches the current block in A, output “both vectors are not equal”. That doesn’t make sense to me. You will print this if the vectors are in fact equal, but more generally will print many times, each time a portion of the vectors are equal. The is incremented in both branches, rather than in common code as part of the loop. The will contain multiple copies of blocks of B, each time it does not match one of the blocks in A. What is the point of that? 

If you did not want the side-effect of logging creation, you could just say SingleLinkedList() =default; 

The problem with the Command Pattern is indeed the explosion of classes and the verbose boilerplate around each little function. That is better done today with lambda functions: the closure syntax automatically packs up the values in a struct and makes a callable with the code body. To use that at run-time (rather than templates), the code takes and manipulates . Sending a struct to match a is rather circumlocutory, which is probably what you are complaining about. 

Don’t go through the collection by index. Look how many times you use in the block of code! Use the range- construct to iterate directly over the vector! 

The top part of the function uses a lot. In fact, that is the only value of the board that is used at all. So you should write this as a range- loop and forget about working with , , and loop bounds manually! 

appears inside the timed region. When benchmarking, use a microbenchmark utility to just surround the actual code of interest. In this case, you can discard the answers you found without affecting those results, so just don’t print. I’ve had cases where I wanted to keep results or logs as well as check time, and I got around it by storing the results in a pre-allocated array instead of writing to a file. Then afterwards, they can be saved all at once. 

In my first question I tried to show “real” coding concerns while still keeping the implementation brute simple; using a loop over data rather than a string of separate testing statements, isolating the algorithm from the I/O of game play, allowing easy (compile-time) modification and extension. Now, I present ame 2. A stateless algorithm has to do modulo (division) for every code word on every number, and division is a very fat and slow operation in the CPU. By remembering the state as an instance, generating the next number can be done by subtraction, keeping track of the remainder. As before, it’s also an exercise to help me adopt “17” features and review my style and habits to update them if needed to reflect the changing language, library, and culture. configuration data input Game 1 was hard coded to use the global for its configuration. Game 2 takes a constructor argument, and it is flexible in being able to take not only any kind of “range” of items, but allows for conformal assignment of the item itself. In particular, note that the internal state uses which holds a , and the uses . But, I can construct the player with the (primitive) array of pairs containing lexical string constants. Any container, and flexibility of what’s in the container. Let me go into more detail about the contraints and parameter checking here: In the class, the constructor is declared