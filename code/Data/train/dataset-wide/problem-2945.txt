The result of both of these is that you force a rather strong well-formedness requirement on input and it's basically impossible for input to do something bad. Errors are also better and identifiers can be of any length. The one thing I can think of that isn't covered by this is that it still allows improperly matched brackets: 

It'd be a neat idea to actually use dictionaries here, but if not one can at least use sorting and . This would be better if sorted nicely, so I'll change it to the empty string. This gives 

It's not really faster on CPython because the number of things you do tends to be more important than what you do, simply from interpreter overhead. 

The cost of caling is low (constant time lookup of a C attribute), so I'd remove that last line and just call when need be. You're mixing and somewhat haphazardly; stick to one. You seem to be using more, so I'll adjust others to that. Now, I'm confused about what this actually does. Why separate out and , as opposed to all other calls? 

produces the same number of instructions total, but early-outs () faster for the exceptional case. Unfortunately the normal case () gets an extra , though that can in theory be done in parallel to the main operations by the CPU. 

I would recommend in this instance, as it will lowercase more letters than otherwise possible. For example, run and . Alternatively, consider writing this so that only letters which can get translated do. But, I'll be honest, I don't like this behaviour. Why should passing in 

There are some quick fixes. Firstly, we can try binary search. Python has a fast implementation in the library. But even better is to "move" the paint can as we go along: 

although the trailing space suggests maybe you didn't realize they were printing on separate lines. All in all this gives 

Secondly, the function is generic. It does not read data. It does not care about . IT just groups data in a certain manner. That is what it does, so that is what it should say it does. Its name should reflect this. 

One also only need the first square root of factors, since larger numbers are paired with the smaller numbers anyway: 

In theory this has speed benefits for larger grids since you don't need to copy the whole grid each time. It loses this benefit on 3x3s, though, where it actually does more work in the worst case. These changes make it reasonable for to also be a since it's actually immutable. This gives us and for free. can be just 

should just iterate over ; the is optional. You probably shouldn't return on failure; I suggest as before. In , you have . It makes sense to call this . I would also do the loop as: 

Then let the caller do the writing. You don't want the function to do the writing to call directly, because that recouples IO and logic (albeit to a much lesser extent) - just pass into the function. Further, just the output. When running the program, it's trivial to redirect to a file. Thus, printing it makes a lot more sense than hardcoding the file you're printing to. I recommend at this point as well. Lots of your documentation is in comments above functions rather than docstrings. You should write docstrings instead, and use clearer, more declarative language. Before we fix 's documentation, though, notice that it's really taking two parameters: 

Now the meaning of is much clearer, the API of is not over-specified and if you decide you actually want another type instead 

is more idiomatic (and faster). You can simplify the loop by iterating backwards, since you don't need to conditionally change the iteration index: 

I would then change (generally) to and to (or even ) - there's no reason to be using variable-length integers in this day and age for these types, and you don't need signed values. When you do want variable-length values, you'd probably rather stick with . (If you find these unwieldy, them to , and . Just don't use and 'cause they're prettier.) Compiling with warnings, I get 

but never touch again! This implied that a class is really the wrong abstraction in some sense; you're not using to store state but to stick itself onto the board somehow. Get rid of the class entirely. In the constructor you use for two purposes. One is to hold a random boolean you use once and another is to hold an unused string. The first can be replaced with a at point of use and the second can be removed entirely. This can be further simplified by just writing and not mutating it further. Your loops can be replaced with ranges using the and parameters. This all gives: 

This kind of error is hidden by the somewhat haphazard formatting. Going with the change to , I would use something like: 

seems like a really long method, so that's where improvements should be focussed. First, you have lots of code blocks that are simple duplicates of eachother; deduplicate these. I suggest using janos' techinque. This gives: 

Don't call 's constructor; has pretty much no disadvantages and is more idiomatic. It's also Python 3 compatible and could use less space. Josay mentioned iterable unpacking; that's a great idea, although I would suggest wrapping the line: 

I would do: def loadWords(filename="english.txt"): with open(filename) as f: return [line.strip() for line in f if line] and ditch the global. For 

This makes sense as is fully determined by its divisor and remainder and there must be at least one number with for . There isn't one for 0 or less and there isn't one for or more. This suggest we use: 

The dashes don't seem to be particularly useful at this point but do make me a little confused; if you are using them to count elements then why does 

Let's quickly work on that docstring. First of all, note that it's in the wrong place and not in the right voice. 

This is because the new method allows better case analysis - we've forgotten to check that such operations are actually valid! 

Your code could do with doc comments; at least could. These don't need to be long. There's nothing wrong with caching files locally, but I would suggest writing to . returns a file-like object. Moments later you use on a file object but you neglect to do so on 's! I would do an early return in . Your check is strange; if it's a directory instead you don't actually deal with the resulting problem. It's not a big deal, but I would use to prevent it looking like you're actually checking. would be better as a default argument, and I'd call it or even . IMHO isn't that great a name either. Here's the updated code, still writing to the same file: 

Your solution is recursive and does a lot of allocation. A much more effective way would be to make a function using this Wikipedia section, either generating them lexicographically or by some more efficient method. 

I don't know what you see, but I see a 304-character line with loads of spaces. This is not good. Here's something a little more approachable: 

Namely, this is a no-op. My first criticism before I look at this more in-depth is to read PEP 8 and stick to it. As the code is written, it would alienate any current Python user.