I tried whipping up my own extension method but, as I'm not really familiar with enums or arrays in C#, I'm afraid it's a little sloppy: 

You could hide the errors to begin with (just put on them), then you don't have to hide them in your script. Also you can group your variable declarations: 

sets up an event listener for the tick event, then unsets it once it reaches the coordinates. The ticker is passed as a parameter: 

The reason this works is is a shortcut for . With JavaScript, it is usually recommended that you keep from cluttering the global namespace. You currently have everything contained in , which is good. But since you're using jQuery, you might as well use a jQuery plugin, which would allow you to do something like this: 

Ending here, really nice code, not much of a review. As with all things related to performance, profile first and profile after if you decide to optimize. 

1) What overloads make sense and what are missing if any? 2) I'm really not sure about if adding composite formats like where is for the scalar value and is for the unit is a good idea. 3) Is nobreaking space the best choice? 

returns an instance that only has one method The method returns the same instance but as that exposes the 

If this is a web application, you can use an HttpModule to do your session management. Begin every web request by opening a session and beginning a transaction. At the end of every web request, commit the transaction and close the session. As long as you're wrapping all the hits to the database in a single transaction, you don't need to worry about efficiency too much. 

My game uses configuration files in JSON format. One of them is used for setting up control bindings, and it looks like this: 

Putting the as single child of the grid is wasteful. Add to the grid. As a rule of thumb is almost never right. After writing WPF for a couple of years you will probably find yourself using ~95% of the time. Grid is a bit verbose but it is the panel you will not have to refactor away from. Also Grid makes reasoning about layout simpler. You can try this to bring down the verbosity a bit. You can add BindsTwoWayByDefault to EightPieceBoard.Selection but I don't mind being expliclit about it. The viewmodel should not know about the view: it makes testing harder and is smelly in general. Not a clean separation of responsibilites between view & viewmodel. 

Both share the following code used for loading and instantiating the player object: (Don't get too hung up on the loading stuff. It's fairly complex and might take a while to step through. I just included it in case someone wanted to see.) 

Other than that, it might not be a good idea to send the user's email in plain text. You can have an AJAX request use the method as well as , which would improve (slightly) the security of personal information. 

LINQ does not add much imo, if the logic was more complicated the for loops are nicer to debug. One downside with LINQ for this is that it requires formatting to be readable. If you rename things the formatting needs to be maintained. With the foreach loops you get formatting for free. Edit: As per @RobH's suggestion: 

Passing in cancellation token is more consistent with how it is done in the framework. With this design there is no risk for deadlocks and leaks. I omitted the overload permutations with . 

If you don't have a strong reason for using the attribute on your element, I would suggest attaching the submit action to the form without it. This would work: 

In my game, I need to detect whether any buttons/keys are pressed at all before I try to process any input. This is easy enough for keys since the XNA library provides a method on the class: 

If you know how reflection works in .Net, then you know it's looking for the methods by name in the MyGame class. The Exit method is actually defined in the Game base class, which I don't control. What does everyone think of this? I am considering moving the MoveDown, MoveLeft, etc. methods into another class, like IPhysics or something, where I would also do the collision detection. Since I haven't gotten that far yet, these methods live in MyGame for now. EDIT: Initially I tried to focus this question as much as possible on the Input class, but I would be grateful for any advice. 

In my experience there is rarely a need for delayed invokes on the dispatcher, what problem are you solving? If you do something in a constructor that you want deferred until loaded there is already an overload for that: 

Same as above, don't add the grid as single child to the outer grid. This can hurts performance and is noisy to read. Better with a grid than a stackpanel though :) 

Nothing wrong with your code. If you want you can use linq if performance is not critical. PseudoCode: 

I'm no PHP expert, and this might be personal preference, but I like to initialize variables at the top of the function to make it clear that their scope is not limited to the constructs in which they're defined. 

When MyGame is constructed, it calls the Setup method of the Input class, which creates a dictionary using reflection: 

I'm writing a program to help with remembering complex bash commands. On invoking the program, it asks for a description of the desired operation, e.g., "increase volume" or "find orphaned packages", and displays the commands matching the input ordered by closest match. Matching is determined by splitting the command text into a string vector, then the description, and combining these with a list of additional keywords to compare with the input via . This is currently case sensitive, which I plan to change. This is my first C++ program so I've probably made plenty of mistakes. A couple things I'm still unclear on: when to pass arguments by reference, when to use and , and when to use pointers. 

I would probably not have this as an extension method as it doesn't mean any real reuse of code. For cancellation you can use this: 

As is a singleton it should be thread safe. ConcurrentDictionary is a nice fit for this. Using the code would look like this: 

Regarding Initialization Initialize methods is a pit of failure as it requires the caller to keep track of if it has been called or not. If possible you should always aim for that an instance is good to go after the constructor. If initialization is needed any way you can perhaps use this pattern: 

This way, you aren't introducing another variable into the global namespace. Plus, the jQuery plugin architecture affords you some additional benefits, like syntax, etc. 

I've come up with two ways to do sprite movement with CreateJS, and I'm wondering if one is better than the other as far as performance and maintainability. The player data is saved in a json file and looks like this: 

Then, the first implementation has the following. When the mouse is clicked anywhere on the stage, is called once: