usage: My output of for every case after trials was always 85899345920000, which is incorrect - due to wrong specifiers - . Correct ones are if you declare and as long long. Why not use i wonder? Using for division results. Then again after fixing this in some cases of a small container with few elements i've kept getting . Thats not good, so you'd want to use a floating variable to store the duration divided by . Otherwise the precision is reduced due to implicit conversion of the division result to integer. Preparing for measurement. Also as this part goes: 

And this will save you lots of time for redundant calls to here. is true only generally. Use which gives that guarantee, and then makes sense. Or better yet divide by . That way nothing is going to surprise you in the future. I'd also avoid calling every test together: 

Make a switch statement and call only one of them per run, so as to avoid compiler further optimizing the switches between those statements. If you turn off optimization flags, then you'll get quite an interesting picture of what's happening but your insights wont be applicable once the optimizations kick in. I think its true that measuring timings without optimization flags set to true is quite pointless. 

You're just wasting time here by searching memory to reallocate. Since stl container call default ctor your above code could be replaced with: 

It calls the copy assignment operator and copy ctor without dtor. And you're spared the calls to .at operator and incrementation of . Though even if you leave it the timings will be quite close. Such alteration seems more or less close to your broadly stated purpose. 

and inside the loop add then by calling after the loop you should get the actual number of distinct memory location used by first element. Answer is 2. One for container and one for copy. In a real life application you'd probably copy the container and let it be consumed by some other function, meaning that a call to would probably have to allocate a new space for copy's elements on the heap. So while moving the stack pointer up down is a single instruction, what can become a bottleneck is allocating new memory on the heap. So with this in mind, if you provide a copy ctor that wont really help measuring imo. I'd try to narrow down your request. What do you actually want to measure? Copy of arrays with dtor? Without dtor? Memory reallocation on the heap? If you declare outside the loop 

That's just one way to group the code. Another way might work better for you. You could also group your functions with similar functions, to make them easier to find. As one example, and could be next to each other, and could be toward the bottom. While grouping your functions, you can check to make sure no functions are called before they are declared -- it won't make the code run better, but it will increase readability. 

If you wanted to take it further, you could create a small function to do the character-checking called or something similar that would return if it found a dash or space, and otherwise. Then for your checks, instead of checking for both the dash and space, you could just do something like which would make for slightly longer code but might make it easier for someone new to follow what's going on. You could even have that function return the value itself, so you could call and would either be assigned the wrapped string (if a dash or space was found) or the original string (). That would allow you to combine your two separate statements into one -- . 

The code looks pretty good. Here are a few suggestions: You reference quite a few times. Why not assign it a shorter variable name at the top of your JavaScript file, like you did with and ? You could group your code into sections, to make it easier to find things. For example, have a variable-declaring section, then a functions section, then the code execution section. The sections can be differentiated with comment lines, like: 

Also, if you ever modify your code to where you need to access the cloned elements by ID, keep in mind that your cloned elements will start with . You're using the length to generate the number, so when you add the first element the length will be 2. 

I have implemented a solution to Project Euler problem #60. In summary, the problem asks to find the smallest sum of a set of five prime numbers such that the decimal strings of any two numbers in the set concatenated together form the decimal string of a prime. I'd like some comments on the structure and style of my program and advice on improving its performance. I'm pretty new to OOP style, so advice on how I can use OO patterns to make the code better is desired too. The basic idea of my solution is that the set of primes with this relation can be represented as an undirected graph. A "prime pair set" is a clique within this graph (A clique is a fully connected subgraph). I determine if a node is part of a clique recursively each time I add one to the graph. Here is the pseudocode for my algorithm: 

Does it make sense to use here instead of ? The next part is the functions that I use to generate primes (trial division), and check if two primes form a pair. I test primality of concatenated strings with a Miller-Rabin test that I won't show. 

Just for fun, these are my implementations: Edit: These implementations take advantage of recursive function definitions. I think the ease of writing recursive functions is one of Haskell's many great features, so I thought I would show it off a little. It's part of "thinking functionally", and I think you should use it more often. 

The ensures that the histogram isn't displayed upside down. You could apply it to , but I reasoned that a list of integers is easier to reverse than a list of strings. I haven't checked though. I leave it as an exercise for you to unspool into .