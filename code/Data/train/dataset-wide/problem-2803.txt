Yes, this usage is acceptable if your intention was to have a of objects that can be removed by the garbage collector if they are not referenced from elsewhere. Instead of using the old-school keyword, I'd recommend to add a ReentrantReadWriteLock field in and use it in the three methods. I think that your implementation is already quite simple, readable and usable. Making it better would depend on the goal you are looking for. But there are still a few remarks after these answers. If you add another method like , it will have drawbacks such as pollution of the APIs of the objects that do not need the second method, ambiguities in the choice of the method to use for the caller, etc. If you want to grant your user a possibility to define custom events, the simplest way that I see here is to replace the argument with : the API will not be coupled with the rigid enum (which needs to be modified in order to introduce a new event type) and the user will be able to define his own event types easily. 

The solution above is just a quick ad-hoc tip. Personally, from the point of view of the style, I don't like in-line anonymous implementations. They can be extracted in dedicated entities. I doubt a lot about the methods and member in . This should be a normal object without statics. The constructor is too long. It should be split based on semantic parts (GUI elements, listeners, frame config etc). is ugly, I removed it from the main action processing. 

Now we need to parse a raw token, represented initially as a . A token can correspond to a numeric value or to an operator. We can use Scala's Either construct to represent this choice: 

Since there are about 3000 nuclides and if you cannot use a resource file (a CSV would be ok...), I'd suggest to split this instantiation in groups per elements. But, seriously, an external resource is much better. 

Nesting Using nested functions is not a bad practice per se, but all depends on the concrete case. Often they are used to enrich the parameters, to share with locally scoped values, or to hide the from other members of the same object. In many cases, they are just equivalent of functions with private visibility. But when too much nesting appears, I'd suggest to flatten the things for the sake of readability. In this example I don't see any special reason to make the function nested. It does not use any of the values available to . Keeping it nested would not be a mistake, but the flat approach seems cleaner: 

Grid.center - you already know what it is on initialisation, so create a normal variable for it and remove the @property version. This avoids calculating it several hundred thousand times. 

and reword it to the following to make it easier to read (imo) and maybe even split the loop contents into another () function: 

Move all your global variables into the main function. You'll have to add a load of parameters to other functions, which seems like a backward step, but it'll help. You'll notice a lot of repeated parameters, which indicates they should be packaged together into a structure of some sort. Concerning the cellArray map, the items are currently a dictionary of exits, id and position. Instead, make it into a class with separate position and connections objects. As an added bonus, it even has a method , although please change it's name to something positive, using not(notConnected()) is confusing. Other 'obvious' structures are the maze, xy coordinate, display. PickNeighbour is far more involved than it needs to be. Creating an function will simplify it a bit, creating a map from direction to "cell offset" will flatten it to just a general case. Apart from the above: 

Depending on what you are ultimately doing, probably the neatest way is to use a standard module, . Using as an example: 

As you've discovered, s are hard to deal with. Assuming that you now know what to do with your repeated code, here's one method of dealing with them. If we start with a function: 

You can do things slightly differently - instead of manually sorting, you can use the standard library sort() function. Below I've modified things slightly for convenience, but using it, originally gave 16.3 seconds for 10^6 iterations and now gives 10.8 seconds. 

Is it quicker to deal with one blob of size max*max, and replacing dp[i][j] with dp[i+j*N]? Are you sure that your values are doubles, or could they be 32, 16, or even 8-bit integers? - less space to alloc/memset. Similarly, is your 2000 limit a specified one or one "large enough"? I'm not convinced that you actually need memset at all (You'll need to guard the term which reaches below the diagonal for the first cells)! Because you're always refering to values to the 'bottom left' of the current cell, you never access values generated by the previous run... Also, because you "shouldn't" access values below the diagonal, all the dp[i] lines are actually (N - i) in length, so less to alloc/zero. You will though need to make other changes to the indices in the loops (and especially guard the term). 

First of all, please check whether it is possible to use a newer version of SVNKit. According to mvnrepository, the used version is dated of March 2009, which is quite dinosaurian in our days. The obsolete version might explain the long delays you are experiencing (I underline might explain, because there might have been a lot of optimisations compared with the most recent version, but I don't have any precise idea about it). Another explanation may be the network communication lags with the SVN server the app is connecting to. It hugely depends on your network conditions and it is possible that there is no remedy for that. To prove that the problem is related with networks, roughly and manually, the calls of methods on field can be surrounded with time measurements, as well as method entries and exit points, for example: 

Exceptions type is too general and is discouraged to be thrown from any method. Try to find semantically more appropriate existing types. For example, in function, if the stack is empty or contains more than two elements, it is in an invalid state. There exists for that and it might be used. I'd also suggest more informative messages in the exceptions and probably add more checks for the cases when numbers or operators appear in unexpected positions. 

Logic According to the tests and the implementation, ranges like (1, 10, -1), (10, 1, 1) are considered as empty. This choice looks a bit weird, because these ranges have valid bounds, but the value of the field is inconsistent with these bounds, making them senseless. I think that the constructor arguments should be validated, with an thrown for such cases. And what about ranges like (1, 10, 20), (10, 1, -20) ? Are they also empty? If the current implementation does not correspond to a strict requirement, I'd suggest to define an empty range as a range where the and the values are equal. P.S. please remove the method from class. There is already for that. 

It looks very ugly and should be extracted. It will be a bit difficult to implement it by using a hierarchy similar to the Panes, because of chained method calls. But this can also be done by implementing a single builder for all your Panes, where there will be a way to set the type of the pane to build. After all these refactorings, you'll see that the total number of lines of code will be reduced at least by half. 

Always use for single line s (and , etc), even if it's not required. It'll save a lot of time one day... Rather than and then , you might consider using instead to do it automatically. leaves still allocated, and hence a memory leak. Either free it in the block, or use another label and free it there. I would avoid for statements with multiple controlling variables like 

may be better split up into two functions, one to create it and the other to read the contents from the source, even if the function is called from - and you need to be aware of the possibility that the allocation may fail. On the other hand, you may wish to consider just allocating a single block of size rows*cols of memory, and indexing it via rather than allocating several smaller blocks. For 'neatness', you should consider using instead of , just to give a (possibly) sensible initial value. could do with some layout changes, such that each row is on a separate line, and the corresponding cells line up under each other, something like (but would depend on the type of data expected). 

From a quick thought - Shouldn't WriteFile actually work when hOutFile is the console? Otherwise I guess that you may need to check whether GetStdHandle(...) == hOutFile. 

should be . The use of may be bit of overkill for what you want it for. If you use a space in the text, you get told that it's being replaced by a space. Create constants instead of using 'm' and 'eng' 

I think you can use these to prove anything you like. If your program is running too slowly, your attention probably should be directed elsewhere. 

Enumerate over the array/columns when displaying as you do in other places. This will stop you doing an list index that's repeated: 

One of the points that should raise a query is the amount of repeated code - you have a duplicate for every if. This suggests creating a function to handle it instead. Personally, I would end up with something like the following: 

If you want to avoid the creation of the on each call of method, one of solutions would be as follows. Change class to implement interface. This will allow to put its instances into a block. The created inside the original method will become constants in the changed class and they will be closed inside the method when the routine exits from the block (normally or with an exception): 

The methods prefixed with should be renamed to because assertions are what they actually do. The prefix is often used for test cases annotated with . 

I think that the second implementation of the function is the most readable and concise. There is just the name of that should be changed. is too vague, would be more concrete. It's probably a matter of taste, but the first implementation seems to contain too much nesting (parenthesis and braces). The third implementation looks also a bit more complex than the second, mostly due to the mechanism of . By the way, I've got two suggestions that may slightly improve this code. 

Moreover, your method may then go directly into this class, named something like . The loop in would look like this: 

The idea to separate it into a dedicated class is not clear. (BTW, it's not a good practice to include much logic into constuctors, neither to throw checked exceptions from them). Its only role is to wrap , so why not producing them in a utility method, ex. ? And there should be a try-with-resources wrapping the initialization of . To check whether a file is hidden or not, is not reliable, because a file name may begin with a dot without the file being hidden. A better way to check is . 

This can also be transformed in Java8 streams processing to get a more elegant solution, but since the original code strongly looks like "before-Java-8", I decided to keep the style. To compare the solutions, I've also written a simple test with an ad-hoc object definition. The tests executed on 6K objects, with 5900 "inserts", 100 "updates" and 5900 "deactivated" expected items in the results gave the following: original time: between 350 and 450 ms. improved solution: between 8 and 15ms. For this implementation, there is still a drawback concerning duplicate items from the original lists. Only the last occurrence of each duplicate will be retained in the s. But since you say that you don't care about duplicates, I don't care about them neither :) P.S. And I'm not sure if it is still necessary to keep the object, if it was used only to check for processed items.