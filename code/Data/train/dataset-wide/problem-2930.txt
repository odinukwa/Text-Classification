You should also check the items of the passed in collection for null references. If any of the items of the would be null, your code would fail with a null refererence exception at 

Therefore, You can simplify the exact same behaviour at least in terms of the final state as follows: 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

EDIT 1: You also don't have to check and assign moannie if it is passed in as euro because it already has the value euro: 

Then, why restricting the second method parameter to ? Let's get that as an . This way, your method can also operate on or instances 

Reading through the code, I can say that it is well written, concurrent access in mind, and at the first sight, it can be said that it has no flaws. I especially liked these lines: 

In that sense, the creatively defined method name and the parameter names and will not do. The General Naming Conventions states: 

I will apologize for the lack of formatting and using your code segments as straight example - but as I re-read your code I see my old self a whole lot and I don't consider myself any level near some of the coders here. However one important aspect to improvement is obviously trial and error and a lot of refactoring. So you asked about OOP going from procedural php within a single require I would assume your going into one right way which is using classes - however there is a lot of pitfalls in your code. The first would be that to effectively do OOP you should use SOLID design pattern. First there are plenty of ORM out there that does your PDO wrapper. One thing starters would like to do is to wrap a low level class (the PDO object) into a higher wrapper functional object - its not wrong to do so - but its been done over. In reality what you should do is not offer the user (ie you in this case) a simpler form of accessing data that you need while using the database. The database of your APP can change...what will you then? You will need to write a wrapper class again because your class is tightly coupled with PDO. Lets take a look at the database class 

The following is the IL generated for There seems to be full optimization by inlining , and The CIL runtime stack works only with 4 byte or 8 byte integers, even the LDC_I4_S pushes a byte as a 4 byte integer to the stack, so, there is no performance gain in changing parameter types to smaller integers, byte or short A slight improvement (may be); These methods need not to be instance members and can be defined static. Changing them to static will remove 1 push instruction to the stack (argument 0, the instance to invoke the method on) at the caller site. That's all. 100 million iterations on my 2-cpu 8 core windows 7 HP machine executes in 17-18 ms, and 8-9 ms of it seems to be the iteration (empty loop) itself. 

Method name is a common method name used by collection types to add a new element to the collection. An method with source as the first parameter and the items to be added as the second parameter does not make sense. and are bad names for parameters and should be changed at least to and or similar. And in Capitalization Conventions 

If you are working in PHP use a framework that has MVC such as Laravel(up and coming and popular), Symphony, Yii, Codeigniter(defunct), etc. Each of them will enable you to use some reuse mechanism. Laravel itself uses a template PHP called blade. There are several other template mechanism such as Twig that enables you to template your views to even add more granular way and cleaner. If its a single file system that you must what you are doing is fine because you are using require_once it enables you to call other files and you can modify that file and it will reflect any other files that references it. 

Ok with all that routing question out of the way - I agree with mbanzon with basename being fine to check for internal directory structure to block people out... If you want extra security you can run a short alpha numeric check to make sure nothing funny is included. As for the white list - since this is a routing file and a static one a white list can also help speed things up as long as its minimal, one problem though with that is if you file system becomes extensive it maybe best to not have a whitelist at that point (you dont want your lookup to be too large to maintain and add. Side note: if your looking for interesting ideas symfony2 routing is pretty good (its being use at core with laravel). It is more extensive than your solution of course but still interesting to look at. 

I would move all of the functionality into a single document ready handler. I will use the short-hand notation. 

First, I would rename that variable since also refers to a current index - how about instead? (I even debated going with and for clarity.) I also renamed to because I think the "is_" prefix makes my booleans instantly identifiable as booleans. Next, I would improve readability by assigning those look-ups to friendly named variables, like and . I don't like the inconsistency caused by the fact that the limit on questions is , but the limit on chapters is - that "- 1" is awkward and it looks wrong to me, but I have left it in my answer in case it has to be there. I have also renamed to for clarity. I think a lot of the redundancy in the conditionals can be replaced with and an . The code in my answer assumes that cannot be greater than and that cannot be greater than . If you wanted to take a more defensive position, you could throw an error if either was greater than its limit. Finally, I cannot understand the purpose of decrementing when we reach the "done" block, so I have omitted it. 

You should pass the body of the mail as an argument and it will do what you need. The body part should have been on the outside and independent of the mailing function. This way if you decide to expand this - you wont need to copy paste a third version 

From a first pass over - all you are doing are if else without any throw or inspection as to what possible errors that the PDO might be tossing out. Thats bad because on production servers - I would assume that you won't be turning on error/warning reporting but will be logging them. Also as @Alex L mentioned - you are missing a IF statement that checks if $pdo == null then throw exception. However its better with a try/catch 

Here are some observations noticed: For something to be OOP it needs to be somewhat reusable. As always use SOLID principles to achieve this. Because you are using styling it broke some of the rules. Consider returning outputs such as errors and such to be pure text without styling and let the return handle it. Reason: what happens if you want to log the fail message and shoot it out internally or to a log file. Your sendmail is a jack of all trade: it does the header, store the emails, AND checks for errors - this is procedural (start, middle end) - consider separating it into different functions of class (your original one and then have a separate class to do validations which you send as arguments). Consider using a constructor. You initialize the object with settings and then reuse the function. Another point to add: attributes (or variables from a class that pertains to the class) should never be never accessible to the "main" or elsewhere but to the class itself. Use accessor functions like get/set or magic functions instead. Classes are suppose to be encapsulated so that outside code cannot effected without going through a checker. I'm aware that its easier to just access it directly but you defeat the purpose of OOP in that sense. Lastly, too many if/else renders the code too tight which is why I suggested the validation class - let that be the class to check on the arguments rather than the mailer itself. 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK 

Yes, it seems thread safe. I run a test to prove it which I give the details at the bottom, but first are some code review comments. 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

I'm currently using a make shift INSERT on DUPLICATE UPDATE function that relies on a DB raw query from eloquent. I'm looking to improve the quality of the code and the speed. Please take a look 

NOTE: function is only valid on model level and does not allow mass insert. Doing will allow to have a inserted as long as fillable is used however it will reject if there is a duplicate key 

I have a private function in PHP that takes a given URL string and just leave the Alpha or numeric and certain punctuation left. I need the stripping of string due to having it match against ElasticSearch and ElasticSearch doesn't take it too kindly for special characters when it comes to exact match. The following function so far is working fine. 

I will extend mulquin's short post. Sanitizing your POST will enable you to make sure there are no SQL injection. Since you are using PDO - you should use prepare() function reather than exec(). exec doesn't escape your query. (as shown in the link provided by mulquin) Furthermore - you are not checking if the email is indeed an email or not what happens if its not a real email address (ie the format is not john@doe.com) - you will be storing gebrish at this point. So a bit of validation so that not only spammers won't just enter anything. 

I will use less verbose selectors for creating my jQuery objects and I will cache them by assigning them to variables. 

I think that hiding the form on the textarea's focusout event is a bad idea because this event could be triggered by the user tabbing out of the textarea. Hiding the form at this point would prevent the user from submitting the form. I think a better approach is to take our direction directly from your requirements and hide the form when the user clicks outside of it. We can do this by attaching a click handler to the . In this handler we will call only if the clicked target was neither the form element nor an element within the form. 

In the showForm function, we will attach our window click listener so that we can capture clicks while the form is displayed. Note that we do not want our click of the to bubble-up and trigger our handler, so we will ensure our call to is outside of the current call stack by using setTimeout with a delay of 0 milliseconds. 

I could be wrong (and my answer down voted) but when it comes to routing or submission of forms consider using Behat or a behavior test framework rather than PhpUnit testing. The reason why I'm stating this is because you have sessions, and submission and cause/effect returning that you want to test. Those ARE valid things you want to test but its more user behavior test rather than what PHPUnit is built for which is functional testing. A lot of time when doing unit testing when relying on other classes your able to "mock" or substitute classes that normally function in production to be isolated which is only to initialize a class or a function that you are running a test on. What you are doing instead is testing if the routing mechanism is behaving with set inputs. 

Can it be better? is there a lib that does this better? I've used Laravel Validation service where you can specify alpha_dash but this is not for validation but rather I need the left over to see if there is a match to the Database Storage for a search.