Why are these globally scoped functions? When should you ever need to call these from global scope vs, having these methods calls be made from within the classes that control game action. 

This is really just here for informational purposes. I would suggest you look at common frameworks out there to drawn further inspiration around structuring your model classes. 

Your application should probobaly only have 600 permissions (or possibly 644 if other system users need to read to files) in the upload file directory. I assume none of these files are going to be executed (thus needing 7). 

Odd to see a return within a try block. Does this code even potentially throw? There really is too much going on in a single line of code and REALLY assumes a happy path operation of all 4 underlying operations. There might be need to better handling of edge cases here (what if JSON doesn't decode? what if "parsing" doesn't work?). 

sorts an array in place, so no need to assign to new variable. No need to define a function here as you are just using default sort behavior. This line should probably just be: 

To your comments around unit testing... I don't think this section of code is a good candidate for that. Typically, when you think of unit testing, you are thinking of unit testing the various methods and functionalities of objects or interfaces in your system. This code is simple procedural code, which does not lend itself to easy unit testing. You would, in fact, probably need to actually complicate this code to a certain degree to make it unit testable. That might not be worth investing time into. On the other hand, if you could envision yourself building out more fully featured server-side validation classes or similar, you would then probably be interested in also adding unit tests into the mix. 

Maybe a stylistic choice, but if working without a templated approach and mixing HTML and PHP. I would prefer to have blocks of PHP code not indented with HTML for easier visual separation. Inline PHP variables output I would keep in-line with HTML though. I might code this section like: 

Should this be a ? I would think you would want your application to fail loudly if a class is unable to be loaded. 

I like the general idea of the criteria class as a general means for defining rules that could then be interpreted by various rules engine implementations. I find myself not liking the specific rules engine implementation that you have provided, primarily because of it's reliance on . I would think that your rules engine implementations might be made specific to the data store/provider against which you are working - , , , , etc. which all implement a common interpretation interface. It seems odd to me that you would need to manually loop through a data source outside of the interpreter. Why would you not just pass the full data set to the interpreter to get the final result returned? Without this, you are really no better off that using , and in fact you limit the types of data you can work with those data sources that allow for array style iteration. Why are the , , etc. methods in the interpreter public methods? What value do these have to an outside caller? These methods sure would be nice to use as callable functions with in an class that can accept an entire array as input. I like that you start to write doc blocks. Be consistent and write these throughout. 

Does it even make sense to have a public constructor for this class? Why would one ever want to instantiate an object of this class without having appropriate settings for host, port, auth, etc? You could perhaps end up with half-set-up object being passed around your system. If you want to have public constructor instantiation, consider removing the method and making sure the dependencies for that method are passed to constructor and that the constructor actually performs the connection successfully. Also, I would think you should have a failure somewhere MUCH earlier in your call stack that a core dependency like functions is not being met. To me, this might be more of an application set-up concern rather than something deferred until object instantiation. If you are on PHP 5.6+ you might consider placing before your class definition to both make clear the dependency and to enforce that this dependency exists at compile time. 

I think it is good to fail loudly here, however I do not think you should not be throwing a PDOException and you should not be throwing an exception without any message at all. The PDO classes should be throwing PDO* exceptions, not your custom class. After all, who is to say PDO is the underlying cause to why you don't have a valid PDO instance to work with. Also, if you truly want to test that you have a valid PDO object, the validation might look like: 

This allows you to unit test these class methods more easily. It also allows you to better override specific handlers in inheriting classes in a much more straightforward way. 

as there is only one index value where should ever be encountered. Alternately, I would consider a regex like to be able to validate the input string and capture the components of the string in one pass. 

You put your javascript smack dab in the middle of your HTML view and in global scope. It probably should have, at a minimum, been in a document ready ready block or IIFE, ideally in a separate file to demonstrate that you know how to decouple view from logic. In a real world application you would likely have components of this sort defined at a framework level, decoupled from page view. 

You are inconsistent in bracket placement after flow control structures. Sometimes they start on same line, sometimes on following line. You should strive to be consistent in your styling. I would recommend a good PHP static code analysis tool like code sniffer or phpMd to help to enforce consistent styling as well as point our other questionable coding practices. 

You should get in the habit of explicitly setting accessibility information on your class properties and methods. Without these, everything on your class is public. This may be OK for simple applications, but can be really bad in working with more complex applications. This also helps force you to think about what should code calling the class really be able to change. For example, should code interacting with a object be able to actually change the properties after the class is instantiated? My guess is that this would be undesirable in your application and that the objects should be immutable after instantiation, meaning the properties should be protected/private. 

Your code is very happy path. You just assume many of your file retrieval, directory creation, file writing, etc. operations work. This makes this code extremely fragile. 

Note that you would probably need to work with the parameter values as integers rather than strings as shown in this example if you did not want a lexicographical comparison. Note that this could also greatly improve the performance of the query itself as you will no longer be requiring the query execution to have to look at all the indexes for all fields even in the cases where the field filters are totally meaningless. The bottom line here is to write a good query first, then figure out how to generate it dynamically in your code. To get to this point, I think you need to abandon the approach of iterating through each known dimension/field, concatenating meaningless where clauses in the process and actually work with the parameters passed via GET. Those are what you should be iterating on. You might also consider using a URL format like 

For your queries, don't just break them up arbitrarily across lines (which I assume you did based on comments to post), structure them in a meaningful/readable way. For example: 

Since you are just POSTing url-encoded query string, can you not simplify setting of for AJAX call to: 

This sort of approach is very common when you need to read a "flattened" database result set into a multidimensional array or other hierarchical data structure. Note that this approach would require that your result set be sorted by the restaurant id (as is shown in your example). I would also suggest that if memory usage is a concern for you (i.e. at some point you are going to be dealing with a large number of rows), that you may not want to read out the entire DB result set into an array before passing it to your function. You are, in essence, having to store all the relevant data in memory twice with this approach. Of course, this means you would need to restructure your function call a bit to take a single row at a time and return an appropriate outlet object/array. I won't digress any more into this approach here, but it is something to think about. A few other code comments: 

I think you are missing an opportunity in only validating your form at submit time. You are using an excellent jQuery validation plug-in that will let you do things like validate individual fields when their values change, giving more immediate feedback to the user around validation errors. I also think you may not be taking full advantage on the configuration options that this plug-in gives you such that you might better separate your validation logic/configuration from your static HTML. 

Let's expand your example. Let's say I had 10 columns I was going to insert. In this case you could do this: 

You don't seem to have any concept of objects or other reusable code in what you have written. I would take a step back and think about what real-word objects you are trying to model. At a minimum, I would think you would need three different concepts: 

I guess my first suggestion is that, unless you really understand cryptography, you really should not be writing your own encryption libraries. Use an existing one like libsodium (or something based on it) , or, if you can't install the libsodium extension in your environment, perhaps the defuse/php-encryption library which is well-regarded. Now on to your specific code... I would start by not having your in your codebase at all. Any sensitive information - passwords, encryption keys, etc. should never be placed in your code base where these items can be visible in your revision control systems. Ideally, you can derive this from environmental configuration and inject the secure material during environmental deployment. Stylistically, you should consider starting all PHP class names with uppercase letter (which is pretty much de facto standard) and stay away from mixing camelCase and snake_case in your code libraries as you are doing here with camelCase class name and snake_case method and variable names. I know PHP is not good about this within it's built-in classes and functions, but that doesn't mean you shouldn't be in your own code. From a use standpoint, is there really reason for a class like this to be instantiated, or should these be static methods? 

Now, the challenge here is that if your table has multiple unique indexes, you can get some unexpected behavior. So you probably need to reconsider your uniqueness criteria. Why would you check uniqueness of hashes of field combinations? This makes NO sense. Think in REAL WORLD terms about what makes a company listing unique. This probably doesn't include things like links to one or more websites on a related website table, or one or more phone numbers on a related phone number table, or one or more emails on a related email table, etc. All the fields you need to determine uniqueness of a company should all exist on the company table, so you can place a single unique index across them. 

Should this string template be either moved out of your class altogether into your display code, or perhaps at a minimum stored as default value on class? 

The error message here seems incorrect. What does this check have to do with presence of dots in the string? Why not which actually matches what you are checking for. 

DB Manager thoughts: 1) I am generally not understanding what you are trying to achieve by even having this class. It is not doing anything like managing database connections, abstracting the user from SQL formulation, adding transactional handling around queries, or other things that one might often implement a class such as this to do. As it stands now, you have in essence only added some custom exception types, while severely limiting the sorts of methods and ways of working the caller may desire since you have not implemented them in this wrapper class (How do we check number of rows in result set? How can we work with one record from result set at a time? Both very common operations.). I honestly think you would be better just having a simple PDO provider class and let your calling code just interact with the PDO object itself (PDO is an abstraction after all). 2) Without seeing code for the new Exception classes to understand if there really is some value being added by these (rather than simply more complexity for calling code to deal with), the value certainly is not clear here for having these. An exception specifically for getting an empty result set on a select query seems VERY odd, especially since there are many reasonable use cases when a DB might be queried and be expected to potentially return and empty result set. Now you may have a case where you would never expect a query to return an empty result set because of how the application is structured. In that case the logic calling the database should handle the empty result and perhaps throw an exception, but this should not be logic within the database class. If you were truly doing something useful in this DB class like trying to abstract out the caller from knowing there is an underlying PDO object, then perhaps you would catch PDO Exceptions (which you do in many cases) and map them to exception types more meaningful to your application - terminal exceptions, retryable exceptions, etc. - not add in additional subclasses to PDOException. 3) 

You need to get into the habit of performing all of your business logic before your start outputting to the browser. Say someone posted bad data and you wanted to redirect to a 403 page using . You can't do that now, because you have already started output. Right now your code could also lead to malformed HTML. What happens if is not set? You get an open tag. Similarly, you have some HTMl output near the end of the script which seem to be output without regard to success of intermediate API calls. You need to perform all your data validations, API interactions, etc. up front in order to determine application state that should be presented to user and then present that state. This can greatly eliminate a lot of your nested conditionals and such when it comes time to render output. 

This proposed functionality gives you a valid object representing either the cookie-derived timezone or, as a fallback, the system timezone. You can use this object to instantiate any object you may need on your system with those objects automatically taking on the expected timezone behavior.