Using "white space" to help with readability When scanning code, if a whole bunch of lines are grouped together without spaces between it can sometimes make it harder to read. So in general I try to put some white space around logical parts, and especially if I'm using braces. So: 

Yes, it seems fine from an efficiency point of view. Here's a couple of simple alternatives you could consider. Remove the need for the ! condition. I quite like this option as I think it flows nicely and is easy to read. 

The serverside code would be responsible for creating any redirect urls and we wanted to stick with the inherited controller RedirectToAction() method where possible in our controller actions. We are using jQuery unobtrusive validation and some situations meant that new forms were rendered onto the view via ajax. That meant we needed to ensure those new form fields contained and validated when required. We wanted the flexibility to return html (PartialViews), json or tell the client side it was a redirect and the URL to redirect to (initiated via 1 above). Before page redirects at times we wanted to show div popups such as a Success confirmation. Hence although we were using RedirectToAction() in the backend we wanted the javascript to actually perform the redirect. 

How about something like this. It's pretty much what you have but all I have done is seperated a couple of the parts into methods 

Ideally we would remove these however I'm not sure exactly the best way to approach this might be. I'm thinking the ManagementObjectSearcher would be the likely first candidate. Perhaps injecting via a constructor. Something like: 

The downside from this from what I can see is if you use this parser in alot of places then you will need to handle the exceptions accordingly. However the upside is that if you wish to do different things based on the reason why something failed then you can catch individual exceptions as required. Offered as an alternative for consideration in any event. 

I assume this was a grammatical error and you don't actually call dialogs from within the viewModel itself? If so I seriously think you should reconsider your approach to using the ViewModels. ViewModelBuilder or someother approach. Aside from this I would consider having another object that was responsible for building up your viewmodels. Of course it depends on the design and requirements of the system but I would be asking. 

Then I thought. It would be nice to be able to unit test this class as it seems a good candidate for just this. And considering it might be a well used class a unit test might be beneficial. However looking at this I came across a couple of pitfalls. 

Now I don't know about the BONUS option, but if you wanted to further eliminate the need to always be specifying the Scheme and Host when Creating the action you could consider writing an extension class on UrlHelper. 

I'm not sure if this is any better and it might depend on how many if statements or different categories you have whether it's worth it. But an alternative could be something like: 

Using correct casing for variable naming (in this case manually camelCase) It's standard practice in c# to use camelCase for variable naming within methods. So 

As well as what squillman suggested I might look at passing in SQLConnection rather than the connection string. This way the connection could be re-used as it is fairly expensive to create SQLConnections all the time. Something like: 

in most of your methods and then comparing the result to check whether it's null or not. By definition single expects there to be exactly one element that matches your query. If there is not one element (0), or > 1 an exception will be thrown. 

I agree with what Jesse said in that a grouping of your repositories into one related is one approach and may be the one best suited in your case. However I'd like to offer another approach and that would be use composition in your ViewModel and have it contain lots of smaller ViewModels. 

I noticed in your razor you are including your sql and db access. This might be ok if you are just quickly whipping something up, but I think you are mixing the concerns of your view by including database, querying (T-SQL) and view concepts. I would consider instead making your view strongly typed to a ViewModel (or model if ViewModel is overkill) and then only using that. All of that razor syntax would then be evaluated in your controller action. Essentially then, your view would have no need for this razor syntax at all and your question about whether it's right would be moot. So yes, there is a disadvantage and something I wouldn't recommend from a best practice and maintainability point of view. 

This is actually a stab in the dark but could you use the .NET 4 System.Threading.Task object for this. Something like: 

Just after a bit of feed back or peoples ideas on which practice is best. I currently have a method but am unsure of the best way to approach it from a readability point of view or even from best practices point of view. Or perhaps it doesn't really matter at all and they are all fine? My three options I explored were: 1) 

In saying that I might also consider passing in the SqlConnection to the model class. This way you take away the responsibility of the Model from knowing how to create this aspect. To do this, you might consider using an interface for your model which takes a connection. 

One small point on the c# side. As SqlConnection implements I would rather consider wrapping that in using statement within the Save method. This way if a problem occurs in the method you can ensure the SqlConnection is closed and you don't incur any leaks. 

Note, I'm not sure if TotalHours is calculated differently but if it's just a sum of the Task times then you could include that logic into the Viewmodel itself as in. 

You refer to alot in the code. You should be able to remove this by replacing your first loop with a ). The if statements such as refer only in the context of your outermost loop and never change in the inner loops. Hence you are needlessly checking this condition on each inner iteration. Consider moving one layer up to avoid additional checks. I think you can get rid of the first index check in your article loop and hence improve things slightly by only doing an increment on each condition. I would consider using constants for the weighting factors. At the very least at a method level, if not class level. 

Following on what Magnus said in comments can you not inject the necessary dependencies. For example: 

Further thoughts: During typing this I thought you could even look at making an extension method on the PersonalInformationModel class (or on the class itself maybe?) to do the name conversion: 

I agree with everything Simon has suggested. But to add a slightly different approach (albiet a bit over the top maybe for this question), I would consider removing the need for the exception altogether and introducing a couple of methods. Even being simple, by moving some things into methods I believe it helps with readability as well as abstracting away some of the method details so that the main method can concentrate on flow, not the rules within that flow. The resultant code might look something like: 

At this stage I would probably leave the code as is in that I wouldn't consider a more OOP solution. The fact that you have thought about it is good because it means at least you know this possibility exists and it's in the back of your mind in future development. Now, if you find yourself doing another switch statement on you might want to consider refactoring the code to a more OOP approach. But until then, I like your KISS approach. In saying that I do have a couple of comments up for discussion. 

I guess one way to potentially speed it up (if the issue was with running over the enumerable twice) would be to use a foreach. However, I don't think it's as readable as your solution; 

Now the class has no dependencies on concrete implementations and you can mock the interfaces however you feel. For example, the ILog interface you might want to mock so it logs to the console only. The IUserDao interface might be mocked to a internal list implementation or you might use a mocking framework such as Moq. 

I personally think this is fine if the concept of creating a , is directly tied to creating a , i.e. one cannot live without the other. That is because the abstraction of the method CreateAccount() hides away the implementation details of what needs to be done (insertion of data into 3 tables). As you already have this abstraction you are now in the postion to potentially refactor the CreateAccount without effecting the rest of your code. Excellant! So, as an option, I might consider refactoring the service layer itself so that the CreateAccount() method is a bit more streamlined, as you put it. 

I can't guarantee but this code should be slightly faster and a bit more readable. So a first crack at a refactored solution might look like.