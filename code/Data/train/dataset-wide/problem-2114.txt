How can I dump this statement again? I looked at but only found a way to do a data-only dump or a schema-only dump. If I do the following, then I get both (CREATE TABLE and GRANT statements) 

If I would store this data in YAML, then I could use variables to avoid repetition. AFAIK this does not work in relational databases. I could store this in DB, but AFAIK I need to evaluate it myself: 

I want to check if our code does use only indexed columns. I think it does, but I want to be sure. How can I configure/modify PostgreSQL to raise an exception if it needs to do an sequence scan? It is ok, if PostgreSQL wants to do an sequence scan, but an index exists. Then I run our software tests to see if an exception gets raised. 

In my first attempt to fix things, I rebooted the remote storage server. This did not change any of the observed behavior. In my second attempt to fix things, I restarted the SQL Server instance. This eliminated all of the error messages mentioned above. After doing this, I was able to complete a DBCC CHECKDB successfully, and I was able to retrieve data from each partition of the table. Two things that stood out to me while researching this: 

Based on your sqlfiddle link, here's a brute force way to get what you're looking for. I inject an ordering value for each result set being unioned, group on matching values to get the minimum order, and then order by the minimum order for each grouped value. 

Assuming that the Ageing values match the names of the columns in your expected output, then this should work: 

How can I avoid redundancy if I store this in a relational database? Unfortunately these values are not always equal, only in most cases. I use PostgreSQL 

We use check_postgres.pl to monitor our database. We use this to check the count of the locks: $URL$ We often see more than 150 locks. The question was: What is going on? We patched the script to output this sql statement, if the lock count was exceeded: 

How to realize these improvements? Are there other things which could get improved? I am using PostgreSQL 9.3.13 

The application "foo" uses this plpythonu source code to read the custom variable . I guess this is way too complicated. How to shorten/simplify below lines? 

After pg_upgrade one check fails. This SQL gets executed to list tables and their sequences. In comments to this question it is called "above sql". 

We've encountered a problem after moving the database of our customer to an extra server. This should have had positive effects on the site's performance, but there is a problem with table locking in MyISAM. (I've heard of using InnoDB instead of MyISAM, but we cannot change the engine in the near future). We could spot it to an update-query which is performed when a moderator activates a comment on the articlesite. This is the process: 

It doesn't matter which fulltext-column I exclude from the query - as long as I match less than 4 of them, I get the duration and explanation of the showed Query2. Maybe interesting: the amount of rows is equal in both tables, about 180k. I'd like to know the reason why this behaviour occurs. I mean, it seems like the whole way of excecution would depend on the number of matched columns. edit: now I'm completely confused. I deleted the fulltext-index. I matched all 4 (ex-)fulltext-columns (Query1). Now it takes 0.1205 seconds. EXPLAIN shows me that no temporary table is needed; but I wonder how I can match faster in Boolean Mode without having a fulltext-index. 

Note that this doesn't exactly match the results you're showing in your question, as they differ from what's in the code sample. 

I have a database with its primary file and log file stored locally. One table is split into 101 partitions which are stored on a Windows share on another server accessed by a UNC path. Each partition filegroup file is 1GB in size. Yesterday, I ran a bulk process to sequentially load data into partitions 2 through 58. The partition schema ensured that none of the files were filled to the 1GB capacity. The load did not report any errors. Today, when I attempted to retrieve data, I began to see three distinct errors: 

While examining logs on the virtual host of the storage server, I noticed two occurrences where device latency increased significantly and then later dropped down to normal. I lost these logs during the reboot. [If this problem occurs again, I will definitely check for a recurrence of this and update this question with the specific warning message.] 

this returns only 8 rows. I receive only rows which have matches to "Punkt" itself or words which I think are taken as "Punkt" as in "i-Punkt". I then tried boolean mode: 

The order of the listed tables has changed. For tableB, the index was used, for tableA no temporary table was necessary. 

At this point the whole page becomes slow. The database itself is busy for minutes. I fetched the processlist a few times and saw about 60 entries of different select-queries, which were all on the state waiting for table level lock. 1. I don't unterstand why this update on the table can affect select-statements for table to wait for table level lock. In processlist almost all waiting queries were from this table. I've read about the fact that updates/inserts are preferred to selects and that this can cause such problems, but the articles-table itself isn't updated when comments become activated, so the selects shouldn't wait. Did I missunterstand that? 

We have a PostgreSQL based system which is installed at 20 customers. Sometimes I run a SQL query over all systems. Up to now I do this with the command line tool like this: 

I search for a simple way to select all columns except one in psql. With I mean the interactive command line. I would be happy with a tool that expands to to a list of quoted column names. Then I could remove the column to remove by hand. My question is just about the interactive usage of psql. It is not a duplicate of questions of people unhappy with the sql standard and who want to execute something like "select *-foo". 

Since I only used plpythonu up to now, I solved it like this. It works, but I see two things to improve: 

If you only look at the database everything is fine. You have transactions and if somethings goes wrong everything gets rolled back. That's nice - I like this. BUT: I want to send mails. Now I am in trouble because I can't rollback. example: 

returns 92 rows. I receive rows which have matches, for example, like "Punkten", "Zwei-Punkte-Vorsprung" and "Treffpunkt" in column meldungstext. I set a fulltext-index on the column "meldungstext" and tried this: 

I like to do a full-text-search on tableA by joining tableB on it's foreign id and ordering the results by the indexed columns of tableB. 

2. Is there something besides changing to InnoDB to prevent this behaviour or at least to get a better balance? I'm very irritated about the fact that this problem did not appear before moving the database to the new server. I guess there is some misconfiguration but I don't know how to identify. 

returns 44 rows. I receive rows which have "Zwei-Punkte-Vorsprung" or "Treffpunkt" in column meldungstext, but not those with "Punkten". Why does this happen and how can I set a "fully" working full-text-search to prevent using LIKE '%%' in the where-clause? 

In another answer, @SQLRaptor makes the suggestion of using STRING_AGG. Working with that, it seems like the following should do the trick: 

I was able to query all of the empty partitions (1, 59-101) without error. In addition, I was able to query partitions 25, 26, and 49-58 without error. When querying partition 39, I received the third error message each time. When querying any other partition, I typically received the first error message, but sporadically received the second error message. After repeating my queries several times, the second error message went away, and I only received the first and third error messages. [The numbering of partitions corresponds to the order in which data was inserted into them, with 2 being the first data-containing partition, and 1 being an empty partition reserved at the beginning.] DBCC CHECKDB also failed, and it returned the following: