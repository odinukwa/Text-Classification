Edited additional points In this line you'll notice that you are printing the address of not the value of as denoted by the , remove this if you want your program to run properly. 

Now the succeeded value is available after the method returns, and will only be true if all values past the test, and now there is no nasty exception throwing, which hurts your application's performance and is just bad practice. You can call the method like this now. WITHOUT a try..catch surrounding it 

use iterator instead of , I also took the liberty to use ternary operators instead of giant if-else bocks. 

Lets kill that giant nest of code. When an Exception is thrown, it interrupts the flow of the program. The code does not continue to execute beyond that point, it is like an early return in that regard. This means we do not need to nest our next statement in the Else block, because if an exception was thrown the program has returned. You should not be throwing Exception, not to say you should throw exceptions, but just not throw the base Exception class. Instead make your own exception class that inherits from Exception. An incredibly simple way of doing this is just... 

If you were looking reduce the amount of code further, you could probably skip the whole dictionary part of this, and just compare the lists returned from the , by intersecting them and subtracting one list from the other. I just had to try :) 

However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

Edit: This is of-course personal taste, but I dislike (what I consider to be unnessary brackets taking up newlines). 

Yes... there is a simpler way. You have two choices, but each about the same. Use an Array, or a Map. The more advanced way of doing this would certainly be with a Map. Think about a map as a type of array where instead of using an integer to index the array you can use anything. In our case here we'll use char as the index. Because chars are ints you could just use a simple array in this case, and just mentally think of 'a' as 0, but we're going to take the larger step today. 

I was able to compile and run using , perhaps I wasn't using c99. So perhaps just don't use c99 :). If you have to use it, then declare those ints as symbols or consts above , then you can say 

Make sure you are disposing(closing) your database object. I presume by the way you have your class setup that when your database object is disposed it will close, in which case I would recommend using the keyword. Which would make your above code look more like this in practice. 

I'm working on some precompilation operations for a world compiler. Currently to identify flags placed by the level designer I need recognize when a specific entity exists at specific coordinates from the flag's origin. I need to generate a list of offset coordinates from the origin(and include the origin) in string form. That is 7 coordinates. this operation is done for every flag in the world, so it is preferred to be efficient. It is not an operation that takes place during gameplay, so I don't have to worry too much. My current implementation works correctly, and quickly, however I still would like to get a review on what I have written, and hear any advice to better this operation. 

Tip #2: The next option is to use or similar cache manager with cacheloader and you wouldn't have to manage scheduling etc. 

Tip #1: Since you are using spring I would think about making as a spring managed bean. But if you are using CassUtil in non-spring components you don't have to read following: 

3, Constructor has 40+ lines - I think you should break it to few methods. At least is candidate for private method. 4, rename method to follow JavaBeans syntax definition 

or you can use your method but it would be better to change to and check whether was created successfully. 

Sugestions for your solution: I have few sugestions how I would improve your solution. BTW it's really good job what you have done. 1, externalize sql queries 

In my opinion your code it's not so bulky but I would do something like below with few changes. I have not tested it too much but it should works. I will use for easy manipulation with files like getting basename or extension of file - it will save you some of the lines and also it is one of the most used library for file manipulation. I would remove and and create self-described function and delete in code comments. I also removed return false for - I would like to get another draft of the name in the next iteration. I dont like spaggetti code when some string is creating like (with ): 

This should be executed on the startup of spring application so I suppose you don't need at all. After implementing this approach when you will need to get you just and call . 

In my opinion in the code there should be as least as possible hardcoded strings. When you will need to change table name from to you will need to recompile all the project - it's OK for one or two times but what about 20times? I would pull my hair out :). 2, Method refactoring I would rather vote for: 

So assuming you have some like method - there is the best place where you can create singletons etc. is basically the beginning of your application and since this method is called you should be able to use . In my opinion is something like in spring so it should not be configured as lazy loading. I would change to singleton pattern: 

From my perspective doing async work for REST with Threads is little bit tricky. And open to few potential problems like - too many Threads, by default all threads with the same priority etc. I think that for some async tasks the best way is to have approach. You are doing something, then you want to run something in the background to avoid waiting for response and return response without already finised async call. To avoid doing another call you can push somewhere this event and process event somewhere else which is not depended on the current application. Check also $URL$ 

I would use there some message processing tool. Send somewhere and than process what should be processed. But it's much more complicated. I would use which is provided by . I think it's old school to create Thread manually for this case. 

You can use where you can create one spring for and inject this instance into your class where is method located. 

With that you are able to inject () wherever you want (in spring component of course). I would create new spring like: and put here all methods like and also (dont forget to ):