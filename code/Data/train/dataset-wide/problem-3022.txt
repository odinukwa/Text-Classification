And you don't have to check for collisons becouse it has a really small chance to have two identical Guid generated with openssl_random_pseudo_bytes(). The only thing you have to have is a PHP installation with version 5.3.0 or higher but it's recommended anyway to have the most recent PHP version (now 5.5.7). 

Error class If something goes wrong simply throw an exception and handle it. No need for some custom magic error handling stuff. PDO usage Yes you can use PDO like this but if i were you i would create a wrapper for it to minimalize code duplicates and provide more readability. I recommend you to fatch objects from database rows not associative arrays becouse it is a bad habbit in the PHP community (arrays are for storing data which are same types). Hashing First see @Peter Taylor's comment. In my example i'm injecting an IHasher implementation through the constructor but this is not the best i think. You should have some membership provider stuff and that can have a configurable hashing method what can be used at authentication/user registration and password changing scenarios. 

The idei is to create segments in the defined range and pick one value from them randomly with taking the segments also randomly. No overlapping will happen and also works with negative values. 

You cannot change the type of the input field on client side in some or all browsers. I would create a custom hiding method in Javascript and leave the input type in text mode (SingleLine), but maybe this has some drawbacks in security. Other solution is to remove the original input and create a new one on the fly with Javascipt but i think not all browser will let you to read out the value of a password type input. Third version is to send the field to the server side and get back the new HTML fields but in this way you may send multiple times the password to the server which can be a security hole. 

Hard coding The checklists are really hard coded (long if with OR relations), try use some container for them (an array and use in_array() for example). 

need a collection of rules, call RouteTable (will store Route instances) rule: how to translate an url to a usefull address in the framwork (how to get named parameters like controller or action and so on) the Router it self which is containing the logic 

You don't have to maintain the DropDownList's seelcted item becouse it will do it by it's self. The problem will only occur when you have disabled the ViewState for the control. 

Your code In your code you are hard coding things when you are using the new operator in your classes, to avoid this use dependency injection as i did. Your SoapGet class has 3 responsibilities: checking credentials, connecting and executing calls, do this is separate classes: one class for validating the credentials, injecting the SoapClient instance and then SoapGet can execute the requests. Hard coding Never fix parameters like connection data, parameter names in "generic" classes! Exception handling 

After this you only have to iterate throught the $data array and execute paramtrized INSERT SQL commands. 

We can create different handlers for different routes: can have one for handling an MVC task, another one so serve special images (so we do not need to go through a complete MVC cycle can be create a thinner logic). These rule should be mapped into our RouteTable which will be the responsible to store these and for example keep the unique route names. Router A router will need two things: 

Yes you can have different formats if you like, the default __toString() call will result in something like: 

If the correct route has been found my routing engine returns it to the other parts of the framework but not just the pure route but mapped all the values came from the request. If nothing has found i face with an exception. The way i see the router above does nearly nothing compared to a real router but do things what should not be done by it. Beside this it's unflexible (fixed array indexes, has a hard dependency on a Config class and a default controller (why?)). 

Wellcome in C# land! You are trying to implement a dynamic array or something like that so why not to a List or another collection like Collection. These are dynamic sizeable no need to worry about size/space handling. In C# do not be an array-oriented coder feel free to use other powerfull collections. 

Model classes Model classes should not have any hard dependency in their constructors especially not a PDO or similar stuff. Model can not have any business rule they are containing only data and that's all. Ofcourse if you have some mapping between model classes (Author <--> Books) then some of the relation informations have to be in the model (Mediator!) classes but that's all. Model classes should not have any knowledge about their storage type. It can be anything not just az SQL database handled with PDO. They can not have self managed CRUD methods (if they does then they become Active Record(s) which is a really bad thing (~God object), antipattern) (maybe factory methods are okay but these methods also can not have anything heavy (query database through a horrible static global accessible thing) inside). CRUD Mapped entities should have some kind of top level storage (like in .NET an ObjectContext) which is dealing the storage problem; handling SQL connections and providing transaction capabilities with an Unit of Work (Commit, Rollback) solution. The top level storage can have for example mapped SQL tables for querying from the underlaying storage, inserting into it, deleting from it. Other thing is that this top level storage is the responsible to track the changes in the entities. Of course we have to put some stuff in every model in the system (Mediator #2!) to handle this session but the main logic still in a state manager not in the models. Repository Repositories are tricky. With powerful ORM systems we can forget them if the business logic doesn't require another application level. What should a repository contain? Add, Delete, Query methods but no Save() or anything else (not even named query methods like: GetUserByEmailAddress($email)). You can use DAO classes for named queries which are operating one or more repository or on the entire object tree. Do not forget: not every entity has a repository! Only aggregate roots can have repository, for example: an Order model can have a repo but an OrderDetail can not becouse it belongs to an Order model and can not exists whithout it. Static In your example your are using in static context object which are containing state (your repository stuff) information which is bad. You will introduce a global state whith them which will bring more harm to your code then good (global hyperspace is inreliable, anyone can modify it). 

The output buffer handling is never part of the view it self. There have to be some kind of ViewEngine which can handle this thing. One thing one responsibility. The problem with the example is that is's missing a whole lat infrastucture! In my MVC expiriment i have Controller, ControllerBuilder, ActionInvoker, abstract ActionResult, ViewResult a lot of other stuff what is necessary to get thing done. In my default IView implementation i have a Model "property" beside the ViewData, i can map a lot helper like Html or Url and any other and just then comes the others: RenderPartial(), RenderSection(), Section(), SectionStart(), SectionEnd(), Layout(); these are pointing to my current IViewEngine implementation which is handling all these stuff. 

In this way you have no string dependency to a SQL database to query user you can have for example an in memory store for users if you want to test the Auth class. Echo or return? Neither Currently you are echoing text from a business logic layer which is bad really bad. Only in the presentation layer should be print out stuff to the end user. The return would not be the solution for this becouse you can't tell what was the Auth process result (only from the message) so create a result class: 

(If i were you i would put this into a seperated class to keep everything clean.) What are we gain this way? Testability, flexibitily (can be changed the default factory in each application if needed). Controller factory with dependency injection 

Edit You can create a derived class which constructor accepts only one object instance which is holding all the information what are needed to establish the connection. (The implementation can be read the configuration values from XML or any other source.) 

Yes Yes it belong s to the controller. If you are interacting with HTTP... stuff then you should do it in your MVC tier in your N-tier application stack. If you would put this thing in the model then it would be in your business logic and then you would have a hard dependency on the HttpContext which is bad becouse what would happen if you would create a WCF service endpoint for your business logic? MVC tier is just an public service interface which is communication with the users on HTTP channel nothing more. If you don't have an N-tier design in your app then you should get start to clean up your solution and put things were they belong. 

Ofcourse as you can se you have to create a decent way to set the connection properties for your database. 

TextFormat Using a SortedSet is better becouse we don't need additional Sort() or Distinct() calls becouse it will handle all these stuff by it's self. SetLineNumbers The main problem was is that the testing Regex was always created inside the second for loop instead of creating once and then using it in all the iterations. The parallel stuff isn't necessary but we can speed up the code a little bit with that. Results Your code was executed on my machine a little bit above 2 secs and my code is finishing around 0.25 secs. Other things Do not ever write comments at the line endings becouse they are really useless and annoying. I've added an additional parameter to each method which can be used to specify the output file. (But the code still isn't really reuseable or testable.) 

And yes you should use double check locking. The other thing is thati would use a ConcurrentQueue instead of SynchronizedCollection. 

Usage #2 as abstract The instantiating is the same, in this current example the options aren't injected (i would do this in a generated db specific object context class but in a general DbConnection as in the example). 

You aren't over complicating things - you try to over simplify them. Class loading In your solution you are loading all classes if only (for example) 2 of them required to serve the request the loading of the other 52321 class is just a waste of time and resources. Read about automatic class loading: Autoloading Classes With this feature in your mind you can create a custom logic to load the necessary classes (name resolution, class location in file system etc.). Template The other thing what you want is loading your templates into the rendering process. This is hard to do it right, all depends on your "framework" solutions for example naming conventions, is your app frame an MVC based stuff etc. 

Dependency injection $objShowPDO = new mShowPDO(); is bad a mShowPDO instance should by injected via method or constructor argument see dependency injection topics 

Yes the code has grown a little bit but i think everything is in place now lets see what i did. I have splitted the parse and the apply operations into different method and i have elminated the double split (separator '-') and removed the foreach loop and changed it to a Linq call with string.Concat(IEnumerable). You can put additional error checks into the method i have only added the null check in the input methods (constructor). The KeyValuePair is not the best to hold two indexes togatcher becouse it stands for a complete different stuff in the framework as it's name is telling us. The class bejavior can be overridden in derived classes because of the virtual methods and the separated reponsibilities. Test I have created a unit test too to check the results but i have only implemented one trivial test. 

Reinventing the wheel If you need a generic repository class use IObjectSet for base type and implement it if needed (in production code it is not needed, in tests you can use an IList<> as backend). Leek on the abstraction Repositories aren't supposed to have Save method becouse if someone else is in a transactional moment in shared context then you (or the other guy) can trick each other. Please create an independent IUnitOfWork for this. 

I think you have created an unuseful abstraction. Mostly your methods only calling the underlaying MemoryCache instance and you have created something weird: IDisposable wrapper over a static instance. Of yourse the MemoryCache can be disposed but not this way. You have a service with InstanceContextMode.Single then you should only call dispose or provide oppurtunity to call the Dispose method when your service stops. Insted of your wrapper i would create some extension method for the typed get/remove logic wrappings: 

I would create at least a simple Event class to keep clean the code. The example above is a very simple one but if you have 5 more minutes for this you can create a DatabaseEvent class which have a Subscribe method what is expecting an IDatabaseEventHandler "interface instance" as parameter (public function Subscribe(IDatabaseEventHandler $handler)) which has a few or a lot of methods: LogConnectionError($arg), LogQueryError(QueryErrorArgument $arg) and so on. Whith this approach you will need an adapter class as a default interface implementation of the IDatabaseEventHandler for easier usage (for example when you are writing your unit tests). Of course the DatabaseEvent class have to have a lot of named log methods to call the subscribed handlers when it's neccessary.