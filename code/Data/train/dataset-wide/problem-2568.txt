Just don't. Don't do this. This is not the C++ way to do things, and can lead to all sorts of trouble down the road. For example, what about this: 

give names to your parameters. As is, this line is unreadable because one cannot know which parameter has which meaning. Do not define a destructor if it does not actually do anything. The compiler generates the empty constructor for you anyway. Put your s inside your header guard. There is no sense in making compiler and preprocessor do additional work if you do not actually use these headers. Order your s. As a rule of thumb, begin with the header this source file implements (if in a file), then all headers from the same project you are working on, then headers from other libraries and finally headers from the STL. This ensures that all your headers are self-contained, i.e. include all the necessary headers themselves. Also, you should sort your s (in their respective groups, of course) alphabetically to make it easier to check whether some header is actually included or not. Do not include C standard library headers directly. All of those headers have a C++ version with a prefixed that brings the definitions into the as opposed to the global namespace (i.e., instead of and prefix everything from that header with ). Why do you prefix all your variable names with ? If this has to do something with name clashes with parameters to your constructor, you should instead use the variant or, even better, if using C++11 or later, a member initialization list instead. Choose better variable names. One letter variable names are high up on the list of things that hurt readability the most, because knowing what a variable contains and what it stands for is often crucial to understanding code. I realize that some of your variables represent mathematical symbols, but those who do not should definitely have a more descriptive name. Make your naming scheme consistent. For example, why do you have some variables with a capital letter and some without? Why do some methods follow CamelCase and others a plain capitalize-the-first-letter-and-nothing-else-scheme? There is no general consensus as to which naming style is best, so you are free to pick one, but please stay consistent (and do not pick a style that is hard to read, e. g. all lowercase). Adopt a sensible indentation scheme. Again, this is something where a lot of programmers do something slightly different, but there are some general rules that most people follow. Most importantly, you should always indent when creating a new block, which you already obey. However, when you are not creating a new block, there are seldom reasons to increase indentation. In particular, lines such as 

This method is completely redundant because c offers the method isalnum which does exactly the same. 

should be the first modifier in most cases. Things like are bad because most people are used to thinking of it as an which is also , in contrast to a which is also (i.e. the first level of categorization is usually , then ). Leave a space between and the corresponding angle brackets/quotation marks. The fact that has a "meanings" comment hints you at the fact that you should probably choose better names for your variables. Usually, typing a few more characters is not going to hurt your coding performance very much (especially not in times of auto completion!) and will make you code much more readable. As a reviewer, I do not want to switch back to to look up the meaning of a variable every time I encounter one. should probably take its parameter by reference, because you are not actually doing any modifications to the object. You should rethink your approach on ownership. Currently, does not own its children, which means that they have to be owned by something else. That means that your whole design structure is not self-sufficient; you always need some kind of class that maintains a vector of all current , to which each of your s only holds a reference. You also need to make sure that none of the objects expire before your , or else you will run into undefined behavior. Also, if any of your are moved, you will need to update their reference accordingly in their , which is cumbersome at best and invokes undefined behavior at worst if you make a mistake. Thus, I suggest you to change the relationship into an owning one, and possible give out references or pointers to other users (also, you still need to face the issue of relocation and thus invalidation, which is why you will probably need another layer of indirection (i.e. a vector of )) If you want to begin your class definitions with the public members, I would recommend you to use instead, since all members of are implicitly public unless marked otherwise (still, this is very much a question of personal style) Use the correct integer types. For example, it appears that can never be lower than 0, so it should at the very least be . However, for variables denoting a length, is generally more appropriate (especially since you assign it the length of a string, which is also of type ). 

This is a follow-up question to Sorting algorithms - Bubble sort Again, for practice purposes only, I took on an implementation of the well known insertion sort as a method to be used similarly to . As expected, the code lives inside a header file called insertion_sort.h: 

What are the alternatives? Since you seem to be using C++17, this is an ideal use case for . If this is not the case, then the guidelines support library offer as variety of string spans. If both of these options are blocked for you, you could template your way out on the type of the parameter. As a last option, you could also just simply take a or . About Overall, this method seems a bit unclear to me. Starting right from the definition, why do you have an anonymous first parameter? What is the point of it? This seems highly dubious to me. There are only few reasons to have such a parameter anywhere in the first place, and none of them seem to apply here. Does this method follow an interface requirement that you did not tell us? Seems unlikely since it is private. Following, what kind of Frankenstein string is ? When I was reading through the constructor, I was really confused at first because those last strings in the calls to this method didn't seem to make a lot of sense. In fact, these strings only make sense in the context of . It seems to me like you were hit by a sudden case of design pattern madness: Valuing the DRY principle above everything else, you reduced those two message strings to the bare minimum, divided every common divisor out. If this were normal code, that would be most likely fine, but we are talking about strings here. Even if this method is private and no user ever would have to deal with this quirky interface, think about what you are actually doing when you are defining any method. You are abstracting away a certain functionality behind a name, and this name now has to convey its meaning where it replaces the code it contains. In your code, however, nothing conveys the fact (which is not at all obvious) that only part of a sentence should be passed to . In general, splitting up what logically belongs to a single part of a string (such as a sentence, a phrase, a name, etc. depending on context) is almost never a good idea. You are certainly decreasing readability, at the gain of a few characters of saved code. Another thing I am not a big fan of is using numerical indices instead of iterators. Doing so gains you very little, but decreases the semantic integrity of your code. After all, is not a very useful name. All it says is "this here is an unsigned number", while expresses "this here is a position in a ". Iterators do have some drawbacks, such as the possibility of invalidation if the underlying container is moved, but those do not apply here, since everything you do that could be written using iterators is a single logical action. This would also get rid of the (arguably) ugly , and the ugly method of (to be replaced by ). One last point: is quite heavy implementation wise. While it is, in general, not a design problem at all to use it (and I would go further and say that it is even a good practice), it can have pretty heavy stack and performance drawbacks. If you don't mind those, you can go on using it. If you do, you should make the type of a template parameter, or go with the C way of passing a simple function pointer (which is arguably much worse style-wise, but better for code size). Ignoring Values 

I'm not familiar with image processing at all, so I cannot give you any advice about your algorithm implementation. However, there are quite a few things I'd like to say about good practices and code style in general: 

Avoid magic numbers. In particular, when checking the result of , check whether the result is equal to , not -1. There even are some places in the code where you are already doing this, so please adopt it for the remaining places as well. Prefer early on failure. Concretely, in you return an empty string only after you have checked for and possibly returned a valid result. Although this is quite minor, I would have expected the method to work the other way around, i. e. 

As to question 1: Yes, what you are doing is unsafe. Yes, there are better alternatives. Why is allocating memory manually unsafe? The most simple reason is: You might forget to free it (in which case you cause a memory leak), or accidentally free it twice (in which case you cause undefined behavior), or use a pointer to manually allocated memory after free (also causing undefined behavior). Let's see whether any of these points apply to your code. 

Putting all of this (and some bits of supporting code) together, a reworked version of your program could look something like this: 

I tried to follow most hints and suggestions I received for my previous question about bubble sort. I am aware of the fact that the algorithm can also be implemented in a way that only requires forward iterators, but I decided to require bidirectional iterators here for ease of implementation. Again, I also provide you a file for simple compilation and testing purposes: