During the launch, the host AD server is contacted and a list of all OUs is retrieved. The OU list is parsed into a . Since the OUs are in the form of LDAP paths, this process involves: 

Right now, the only way I see to do this is a multiple iteration of the results. I must go through the file system to fetch all the directories and save them, then find the longest path, and then format them all into a string. Needless to say, this takes a very long time on large file systems, such as one of my company's network shares with over 200,000 directories. It takes over a day for the program to run on this share, but if I make the path print in a single cell, using only one iteration, it takes minutes. For more narrow queries, the program runs acceptably well, usually within a few seconds. However, I'm sure there is some way to reduce the multiple iterations so that the time required is reduced also. PermissionsChecker 

This is a Windows Presentation Foundation application that queries active directory and can display lists of users, users by group, groups, and users by manager (direct reports). It operates on whatever active directory server the host computer belongs to, and dynamically builds a of all the Organizational Units in the active directory for the user to navigate through. Once a user has selected an Organizational Unit, they can use one of the buttons to start a query. The results of the query are then displayed in a . Complete Process: 

Explanation We use to create a new array from the existing numbers array. The new array contains the first 11 digits of each number from the original array. Each element is an int, converted using , which lets us apply to sum the array. We then convert the sum to a string, and take the first 10 chars. And voila, you solved it. This assumes you already have an array of strings, as is the case in your code: 

I removed the and private methods. They added no value. Ruby 2 introduced keyword arguments. They are superior to an options hash. So I removed that in favour of keywords args in . Player exposes a setter. Instead of passing to the player under , just set the player's position to the cell's location using the setter. 

I'm building a JSON API. I'm writing my controller tests so that they compare the response body to actual JSON I'm generating in my tests using ActiveRecord. I wrote two helper methods that make the process easier. The first simply parses the actual response body and returns it. 

Once more, I've opted for keyword args in . I've simplified the method. It plays a turn, moves the player, then checks if the player has won (landed on last square). If the player does not move (no where to go), it checks if the last roll gets him in excess of the last square. If either of those things is true, it sets , otherwise the turn ends. 

Your conditional statement using the variable reads very oddly. Granted, I normally wouldn't be using a loop over a collection with a randomly generated number as the conditional, but maybe that's just me. Outside of the code itself, I don't understand what "problem" you are trying to solve. I don't see how this type of transformation would be useful. In your example, the code will actually do nothing, as the first list is initialized empty and nothing is added to it. 

I am trying to get active directory groups with their users, all while disposing of all assets when they reach the end of their usefulness. The groups and users are passed into a method that extracts certain properties and adds them to . This requires a decent number of nested blocks. Since the method is private, and most of the variables only exist in the blocks, I gave the variables very short names. Naming them properly as or would involve breaking even more lines to fit the long names. 

Is there specifically any way I could improve the argument/input parsing blocks? Would it be more consistent to ask the user for minutes if they supply an hours command line argument? Should I offer the variety of options at all, or should I stick to command line arguments only or "dynamic" input only? Bonus: Are there any meaningful names that could be assigned to the 1, 2, and 3 in the parsing blocks that would make the code more readable? Magic numbers are bad, but since it is checking the number of arguments, I can't think of anything other than which seems silly. 

I'm going to be bold and review my own code having spent the last hour refactoring it. The original implementation had bugs. Sometimes less than 10 ladders were placed. This is because the algorithm did not check to see if there was a ladder already present at the current insertion point. 

I wrote this jquery plugin to do remote validations on the server. The code self explanatory. When the field blurs (event is customisable), the plugin checks to see if there is a value and sends the request. Nothing fancy, but since I'm relatively new to JavaScript I'm sure I might have missed a few things. I think the init method is a bit long in the tooth. I am also calling from a bunch of places in the method, but that might be necessary. 

The first check is for the length of the string: If it's odd, the can't be balanced. I then iterate over the chars of the string: 

I wrote this short, plain Ruby lib to handle email address validation inside and outside of Rails applications, and I would like to know what you think. 

I was not able to get @Jerry Coffin's particular implementation to work, but I used his idea to create this similar \$O(n)\$ implementation. As he describes, we reverse the array at \$A[0..S-1]\$ and \$A[S..N-1]\$, where \$S\$ is steps and \$N\$ is the length of the array. We then reverse the entire array. 

I am making a kind of form, and I want the user to be able to enter a dynamic number of string inputs. The idea is that a single will be displayed, and once the user has filled that out, they will be able to add another one, and repeat the process as they keep filling the text boxes. Once there are multiple, they can remove any text box if they no longer want it. This is accomplished with a containing a custom which is a with a and two s. XAML: 

I have created a few extension methods to get the direct reports of a as s themselves. This saves the user of the API quite a bit of typing. 

Converting user principal to dictionary entry. Getting direct reports property of dictionary entry. Casting property to string enumerable. Using each string (distinguished name) to search for a user principal. 

which is far simpler. The odds that someone will be randomly working with are pretty slim in my opinion, so you should perhaps consider changing your method(?) to accept a if not a or even an instead. Speaking of "method," it seems that this code should be one. It effectively takes an input and produces an output, so why not isolate it to be its own piece of code that you can call wherever you want? You could also get rid of that statement in favor of a proper . It would look something like this: 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: 

A square can technically contain the tail of a snake and the base of a ladder, or head of the snake and head of a ladder. But this could have weird side effects (presumably why I've not seen a board with those characteristics): You slide down a snake only to reach the base of a ladder that takes you to the winning square; or you climb up a ladder only to reach the head of a snake that drags you down. While not fatal, such side effects muddle the role definition of ladders and snakes; in that, ladders are no longer necessarily good, and neither are snakes necessarily bad. Example World 

The idea is to isolate presentation logic that is only needed for the report, in the report class itself. You then have cleanly defined responsibilities for each class.