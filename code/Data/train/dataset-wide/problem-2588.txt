'remove' naming From the class header it is not obvious that this is going to be a never exit thread worker method. I would be concerned that a future client might try to call it to remove one item from a queue. Consider renaming it and making it private. Worker thread Your worker thread has no termination condition. You should provide a mechanism to signal it that processing is complete and it is time to terminate. If there are no items in any of the queues (such as when the thread is initially created) then the thread function will spin, draining resources that could be used on other things such as inserting items into a queue. One approach to improve this would be to count items managed and wait while it is zero, or use a single flag that is set when items are inserted and have the thread wait on it if it fails to read from any of the queues. initWorkedThread If this is called twice you will start multiple worked threads. Is this expected/desired behaviour? I would assume not, in which case you should add protection to stop a second thread being started. One approach might be to make the private and have it called automatically from the constructor. With the current approach if two threads are started, there is a race condition between checking the queues size and removing an item. 

This defines interactions and choices which lead to the next interaction. You can then add extra information like Mobs/Bosses, effects on stats etc etc and fairly easily rearrange your adventure. You can introduce well known tokens into your text which are expanded by the code (such as Player.Name, Player.Weapon etc). Your code then becomes more focused on representing the structure and walking through it. Taking this sort of approach makes it possible to move towards a database back-end for representing the scenarios (if you want to learn about accessing databases from Java). IT also makes it possible for you to use the same game engine to tell different adventures by simply using a different text file. 

Should probably handle an invalid index (I'd suggest throwing something like an out of range exception). At the moment, you're going to be triggering a null pointer reference. You keep going until is : 

Some initial thoughts... The board It seems a little odd that the board array is being passed into the class. I think if you really want to inject it as a dependency into the class, then you'd be better off wrapping it in a class. Alternately, the simpler option would be to make the board a private member variable of your class, which it then has complete control over. As it stands, both your and your class have intimate knowledge about the array and it's size, although the class doesn't validate this in anyway, so if the caller creates an array that's too small things will start going wrong. Checking for tie When you're checking for a tie, you're checking for upper and lower case players ('X' and 'x'). If it wasn't for the fact that the array is being supplied you'd be guaranteed that 'x' wouldn't occur, since you only insert 'X's into the grid. You do the same 'X' or 'x' check when allowing the player to make a move. Winning condition When you're checking for a win, you're trusting the caller to pass in the correct player ('X' or 'O'). If the last player to take a move was 'X' and they placed a winning move, but checkForWin was called with player 'O', it would declare 'O' the winner, even though there is actually a line of 'X'. Checking for line wins (horizontal + vertical) is easily modelled with loops, which will help to simplify your checkForWin method. I'd also suggest taking the winning player from the board, rather than from the supplied parameter. Prompting You convert 'X' to 1 before prompting the player to make a move. Why not just have it be X's move? 

It all fits nicely on the screen, which again aids readability. Comments Some of your comments are helpful, but others don't really add much and some might actually be misleading: 

Which will ignore all of the entered characters up to the end of the input line. That way you don't start going round the loop multiple times, or with left over characters if the user enters: 

Your tests as they stand aren't great, they are probably adding friction rather than value. That said, it depends a bit on what you're trying to get out of testing in this manner. As an example: 

As you're developing code you want to try to keep the amount of clutter to a minimum. That means not introducing new elements until you are ready for them and cleaning them up when you don't need them anymore. Duplication Keep an eye out for duplication in your code. It's a sign that there is scope to extract some functionality so that it can be reused. For example consider these lines: 

This isn't a full review, just a couple of points: Help Text You have a method , not included in your code. I'm assuming that it returns a formatted help text that tells the user how to run the program. To get this output currently you need to know the command line arguments for help. Rather than having the user guess until they get it right, why not have this as the default behaviour if the args can't be parsed correctly? Stdout/Stderr You've got several methods that refer to and (, ). This may be OK if you only ever intend to run the application from the command line. If however, there is a chance that you might want it in a library, or to put a GUI in front of it then decoupling it now may be worthwhile. Putting a wrapper around / something like or would minimally change the code, allow the output method to be easily changed in one position. 

The line will never be executed, so should be removed, it's just confusing. Include Order I always include system includes, before project includes. This is partly because I don't put includes in my header files, but it's also because I know that the system headers shouldn't depend on my headers, but my headers may depend on the system headers. Essentially, include files in the order the compiler is likely to need them. You should also pick a style. If you're going to include dependencies from headers then don't also include them from your cpp files. At the moment 'Circle.cpp' includes 'Point.h' which is also included from 'Circle.h'. When you're working with very large projects even this small duplication can add up to noticeable compile time differences. Polygon Your polygon class feels like an artificial abstraction. If you're not planning on adding any functionality to it, and you don't need something that can refer to 'Polygon's, rather than just 'Shape's then I would remove it. Naming You mostly use descriptive names, however should 'tempPoint' 

From the line grouping, it appears that lines 2 & 3 are supposed to be within the block, however only line 2 is actually in the dependant on the . Generally speaking it's better to always include the braces for statements, even if initially you only need one line, that way when you introduce the second line you don't introduce a bug. Magic Numbers Some people really hate the use of raw/magic numbers in code. I'm generally OK with them when they make sense in context, or if there's no better name for the value. If there is a better name, use a constant, however for things like the armor effect of items this might not be necessary (a constant is no better than using for example). That said, lets look at this code: 

Consider Your Audience The columns that are returned by the query don't appear to have been selected in any particular order. This is OK for queries that are being run by a client, for example from a programming language however the primary client for the stack query is likely through the website. On a lower size screen format (such as mobile phones), this means that the left side of the returned data set is the most important and should contain the columns that will most influence the users actions. 'Post Link', 'Tags', 'Highest Answer Score' and then 'Views Per Day' seem like the most important columns in that order. Consider Closed Questions The query is aimed at finding high view questions that might need some kind of action (close votes, new answers, or votes for existing answers). These actions are most relevant to open questions, however currently the query doesn't exclude closed questions. The easiest way to exclude closed questions is by adding an additional item to the where clause: 

Superficially you're existing approach will work for the short number of items you are reading. However it looks somewhat brittle. What happens if the file is edited so that instead of: 

This way, by each thread having its own mutex, threads are only ever allowed into the area when they have something to do. 

A few things stand out... Function declarations I'm not a huge fan of specify return type on previous line style: 

Vs I don't really have a strong preference, but if you're initialising to then you should probably test for it in your enumerator, or initialise to . Whichever one you choose, be consistent. 

Your two queries are essentially the same, except the second query is also joining to the table. This suggests that you might be able to remove the first query and simply execute the second query. OUTER JOIN Since you've said that it is possible for a client to have an active session, but no user associated with it, then you would need to to use an outer join, which mysql seems to support, to connect to the users table. The explanation in the documentation isn't overly easy to follow, but essentially, when you do a normal join results are only returned if all the join criteria are met. If you do an outer join, then results from the outer joined table (users) will be returned if present, otherwise columns from that table will be returned as null. You can then determine if a user has a session (a row is returned) and if they're logged on (users columns have values) from a single query. 

One of the benefits of circular buffers is that they can be filled up to the entire size of the buffer, with completed fields being extracted from the head of the buffer immediately freeing up space. This isn't the case for your buffer. Space in the buffer is never freed until the entire buffer has been read, so if partial fields are consistently read there is a risk the buffer will get to a full state. dataTail You've declared your other access methods, including as . Is it a mistake to not declare as const? It's not entirely clear to me why a client would need to have a pointer to the bit of the buffer you haven't used. Or are you expecting the client to actually write to the , without amending the afterwards?!? push Your extended seems like it has a bug (or allows a very strange use case): 

Mains in classes I don't like having methods in non-application classes, which is what you've done in both your linked list and stack classes. Having a main method in the class blurs the boundary of what the class is responsible for. At a minimum it's responsible for being a 'stack' and being an application entry point, it feels wrong. Public interface Think about what it is you're trying to model and what that means for the interface to your classes and what the classes are responsible for. When I think of a stack class, I think of something that is going to let me push objects onto it and pop them back off. So for me, a Stack would at minimum have public and methods. Yours doesn't, the methods are private. I suspect this is because you're only using them from your which is in the same class. Separation of Concerns You linked list is asking the user to supply data, then using that to create nodes and add them to the list. This is too much responsibility for the one class and it makes it difficult for you to reuse the list in other ways. If you had a list builder that was responsible for driving the process of collecting input from the user in order to construct the list via it's public interface, this would lead to a more focused implementation of the list. This would for example allow you to reuse the list in order to construct the stack class. A linked list is an easy structure for implementing a stack. To achieve stack like behaviour, you always add new elements to the head of the list (push) and only allow the first element to be removed from the list (pop). You can't currently implement stack like this however because of the user interaction embedded in your linked list class. Bounds Checking Currently your push method on your stack doesn't check if it's going to overflow the internal array. This is OK at the moment, because the method is private, however as I've said it's odd for a stack class not to have public push/pop methods. If they do become public then they need to start doing bounds checking to prevent an overflow. Only implement what you need As far as I can tell, you don't use your method on the class. Try to avoid creating extra work for yourself by creating methods that you're not calling. It just gives your more friction if you decide you need to refactor the way your code works. 

In addition to the many issues pointed out by @Fabian, you are overflowing your buffer as soon as you create it: 

This number will need to be bigger if you have to support multiple digit numbers, however the will scale this for you if required. Instead of calling , you then append to the : 

Initialize Vs static constructor is a static class, rather than providing an method, you would be better off providing a static constructor that performs the class initialisation. This would make construction more straightforward and remove the need for the variable. There can be only one On the face of it, there doesn't seem to be any particular reason for the restriction on only being able to perform one conversion at a time. Unless I've missed something, once the class has been constructed, you only need read access to any of the variables stored at class level (All write actions are performed against local variables). I'd consider removing the variable and associated checks. Magic Numbers There are a lot of magic numbers in the class, particularly in the method. I'd consider if some of these might be more expressive as constants. Color Matching Overall, I think the conversion is quite good and has a powerful effect. However, looking at the unblended image, colour wise it isn't what I would be expecting. The original smile is mostly yellow. Although the match appears to have picked an yellow emoji like a lemon in the outer circle, this isn't the emoji that has been chosen for the face, instead a grayish bunny? has been chosen. Similarly, the eyes are brown, but colored emojis have been picked, although the brown one that is used for the smiles outline might have been more appropriate. From what I can tell, you're picking the emoji based around the average color of all the pixels in the block, versus the average color of the emoji. CIE76 has been superseded, so it may be that updating the color difference formula to use a more up to date method might help. Alternately, using a different method to determine the average (for example using the median, rather than the mean pixel colour) may result in a better colour match. 

Compilation Error Template code often isn't resolved until after you exercise it. I'm not really sure if you code is supposed to support this or not (I'm not overly familiar with some of the newer standards), however if I use an , then I can do this and it works ok: 

In general, I think I prefer the second approach, because whilst there is more code overall, each handler has a distinct job in the flow. I can see how I can expand it with more states to handle player creation / add better validation to each step (for example adding retries on failed password entry). That said, there are somethings I am not so keen on. At the moment, the handlers all implement which makes sense for most of them, however some (such as the and ) only transmit to the client, they don't process input. Does this mean the name's wrong or am I shoehorning handlers in that shouldn't really be there? Any and all feedback welcome. This is a work in progress, so some of the periphery classes (repository etc are stubbed) and others like the will change as more commands are implemented. I think I've added all the relevant code for the review, however I'll add more if needed or it's available here.