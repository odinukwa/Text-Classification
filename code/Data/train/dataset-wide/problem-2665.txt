which behaves in the same way as the original method by using only the lazy evaluation feature of the and operator. Regarding the search problem related to the case of the strings I'd just apply a or to both strings. The end result should become the following: 

Just taking into account the code that's present in the question here (and not considering a possible extension scenario in more tasks): Being that you have to wait for anyway, I'd suggest to rewrite the code in the following way: 

In my opinion, there are a few improvements that can be made. I'll address only some readability issues here, not the performance or algorithmic ones. Remove regions There are a lot of discussions on this, just google it and you'll find a ton of discussions. The methods are too long Try to reduce them by using already existing object or methods. For example: 

Avoid wrapping all the code of the method in a block. Here are some ways to deal with exceptions. Also, be consistent with spacing and indentation in order to improve readability. 

and, by taking a look at the delegate, you could transform it (but it becomes a little less readable/understandable) into something like: 

In addition to what has been said by the others, and noticing 3 distinct blocks of code in the original method, I'd suggest to split into distinct methods, and also use where possible (for readability's sake, being that it changes very little from the performance point of view, unless - of course - this method is called a lot of times). So, the original method becomes something like the following (this is not tested): 

is repeated code (the two cycles are almost the same) and could be transformed in a method. Other things seem ok. 

The end result - after applying the changes in the first solution and the changes for these 3 points - should be something like the following: 

Reduce the space between the lines of code. Right now is a bit too much. Reduce indentation. Reduce width. 

Given that the sum of \$n\$ matrices is independent for each couple of matrices you can sum the \$n\$ matrices in groups of 2 in an async way. You just need a queue of objects. 

Glad you took my suggestion and posted over here. I'm going to start from the most important (but also high-level) bits, and work my way towards specifics and code here. DESIGN ISSUES The main issue is that you're using lots of inheritance, which is a BadThing(tm). See below: There are a few things about your design that could be greatly improved, before we go into code. First off are some basic principles of OOP, called SOLID for short. I'm listing all of them for completeness, but your posted code is falling foul of the O and L bits: Single Object Responsibility: Each class should have one thing that it does (you are doing this). Open/Closed: A component should be open for extension, but closed for modification - you're falling down here because you're using very deep inheritance trees. This means that, if you need a specific ability to do something new, you will either have to cast that ability to the specific type or add a virtual method in the base class (thus needing to modify the base class design). This process eventually leads to an anti-pattern where the base class accumulates more and more virtual methods. $URL$ Liskov Substitution Principle: This is perhaps the most important, and the one that your design fails quite badly on. Basically, this says that if you have a base class, instances of that base class should all adhere to the same contract, regardless of the types derived from it. Roughly speaking, this equates to "don't specialise by inheritance". As in, inherit from a type ONLY to extend its capabilities, not to restrict them. Clearly almost any deep inheritance hierarchy is going to violate this principle. The alternative is to "own" a capability rather than "being" a capability. $URL$ (a little abstract) and also $URL$ (which is basically a design philosophy that arises from Liskov substitution). Interface Segregation - interfaces should represent indivisible capabilities. You aren't using interfaces here, but you should be (see below). Dependency Inversion - your Ability class depends on your Entity class. Assuming that your Entity class also depends on your ability class, you're falling foul of this. The best way to avoid it is to have the Ability class depend on a minimal interface, which has just the properties and methods that you need. CONFUSION BETWEEN TYPE AND INSTANCE There is a key issue with this design, beyond OOP principles, which is that you appear to be confusing type and instance - there isn't a distinction between the ability to pray, and the ability of a particular character to pray, for instance. Essentially, you're missing an entire set of classes that actually cast these abilities. For instance, suppose you wanted to introduce an ability that could be re-cast a limited number of times while it was already in progress. You would have a problem, because the class hierarchy that captures the ability to pray is the same one that's responsible for tracking the execution of a particular prayer. I would do the following: 

There are a few things that popped in my mind seeing this: Generalization The method can be used to split any enumerable/collection/array, but this is just a minor point. 

In addition to what's been already written, I'd say that it shouldn't be necessary to implement the method. That is a test method and it should be in a test module. Regarding the implementation, I'd make the following operations: 

Another thing, when working with strings it's better to work with the StringBuilder class and/or the string.Format method. 

We get the sets of 2 non-contiguous substrings. For each set of 2 strings do the following: 2.1. Get the last string. 2.2. Repeat operation in point 1. 2.3. Add the other strings in the original set to the calculated sets in 2.2. Repeat point 2 for the sets of 3 strings ( in general) until no more strings remain. 

Regarding the complexity of the algorithm we have that time complexity is \$O(AvgBagCapacity^{NumOfBags})\$ (that is reduced a little by breaking the computation early). Regarding the space complexity depends on the approach used to expand the tree. Personally, I'd suggest to use a depth-first approach as it reduces the space complexity to \$O(AvgBagCapacity * NumOfBags)\$ (if you don't keep the already expanded nodes in memory). If you want to furtherly reduce the space complexity you could use lazy initializations of the nodes so you use only one node at a time. By doing so, the space complexity is \$O(NumOfBags)\$. For the sake of clarity I wrote some code which does what I described. Obviously it has a lot of room for improvement (starting with the naming :P ). I also included some tests (the first two are the same as two of your examples) so you can do comparisons and play with it. 

I'm developing a web application for simulating electronic circuits and I'm trying to add backward propagation options (guess you can immagine why). During refactoring I came up with a base class for logic operations and wanted to ask for some feedback (whatever pops up in your mind) on it. The class code is the following: