I'm surprised how this simple design solves all the problems of the other approaches. Prototypes make multiple inheritance hard, hashes won't allow privates, there's no more the "this" binding issue, instances are JSON-serializable, all that without depending on external libraries. Is there any cons to this method, or something that is hard to do with it - or can I just go and start preaching about it? 

JavaScript doesn't offer a module system. There are many third-party solutions, like or jQuery's . Most, while good, they bring dependencies, extra kbs and/or limit your folder structures. Sometimes it's necessary to make a .js file self-sufficient. This said, what is the smallest snippet that can be inserted at the top of a .js file, which will emulate "import", so it can load other scripts before running itself? The .js file should look like this, for example. Notice the addition is just a small one-liner: 

Use meaningful names Your use of , and are 3 examples of meaningless variable names. Consider more meaningful names. Use independent loop bounds Your Loop uses as the loop variable and the starting index: 

I've sacrificed a few features of Collection (like being able to add a Widget before or after an existing collection key), and I haven't honored the CompareMethod of a Dictionary, but these are easily added. Have I missed anything? Am I missing some performance tweaks? 

Clarifying the Form type Access has built-in objects, but also allows the use of VBA . It might be helpful to qualify the type as : 

I guess everyone will agree this reads too much better, and the only cost is that you have to modify the native types prototype. So, which? 

Often you have to chose between cloning or not an object before making a computation. Which is best? 

I'm writing a function to increase a string so, for example, "aac" becomes "aad" and "aaz" becomes "aba". The result is horribly inelegant, I can't get it simple enough and I feel I'm missing something. How to improve that code? 

Your code is actually very good. I'd advice against using OOP there. It's an overused tool which, when not necessary, only makes things more complex. JavaScript works very well without it. I'd recommend a more functional style. So, if you want to make your code more reusable, you could abstract your functions to work with any kind of collection. You could also use existing functions to define others: 

There is a PHP function specifically for filtering input. Funny enough, it's called You would use it like so: 

The first stage involves reading the string, parsing it from beginning to end, recording the logical aspects of what exists. The second stage involves manipulating the logical record that represents the tokens, transforming it from a representation of what exists, to a representation of what string manipulations are required. The third stage is executing the string manipulation. 

This gives you a reliably clean way of doing what you want; no regex to get wrong, no ambiguous code (since does what it says on the tin), and an easy way to tell whether the key didn't exist and if the sanitization failed. It leaves nothing to chance. With the above conditionals, you can be sure that you get an int when you think you'll get an int, and that you'll know when you didn't get an int. When you want to sanitise for things other than an , or when you want to perform validation on email addresses and so on, this function takes all the hard work and error-prone code out of it. (No more regex! Woohoo!) It's a recent addition to PHP5 (PHP 5 >= 5.2.0, PHP 7), so it's not yet well known, but it's been added because there are all too many ways of trying to solve this problem, and even for those programmers that write comprehensive unit tests, there are always gotcha's which can leave security holes. PHP now has our back with this function; experts have written that function and tested it to death to fill the need. You should check out that page's "See Also" section for related functions that can be used to sanitise arrays of input etc. 

Extra points for a brief functional style solution! (Even if it needs to implement other functional functions such as zip or whatever.) 

But before I'd suggest checking some functional JavaScript libraries such as , which already implement similar functions in very clever manners. Using them in your daily code will make it smaller, simpler, more readable and robust. 

The function returns the full dependency tree of that node. For example, . Is this code correct, overall? Is it correctly checking for circular dependencies? Is there a name for what I'm doing? 

I needed to convert some Ascii text to binary in Hex format . I've written an and a function to do the conversion. I've avoided using concatenation in favour of performance. I'm assuming that assigning the results of to a byte array, and then using to convert the array to a Unicode string, is more efficient than assigning the results of to a string array, and then using to concatenate the strings. I need to use this in Excel, so I'm using to return errors, but this could maybe benefit from being more generic. Sample usage 

I would split up the code into objects, with good object oriented patterns. This should result in objects that have very distinct responsibilities. The pattern I think you should primarily look into is the "Proxy" pattern (See "Design Patterns" book by "Gang of four".) It can be used to extract the code that ensures security, for example. It makes the security code independent from the domain logic / data access / user interface. It may mean refactoring a lot of code, but once done, you can then write thorough unit-tests for the security proxy in isolation, giving you a rock solid foundation. Write tests, then write the testable code, (i.e. isolated) then refactor to the point where it's neat and tidy. 

I have an XML stream that looks like the following (attribute and node quantity , and node depth reduced for demonstration purposes.) 

Using `Val` The function can run into problems when converting string values, depending upon the locale of the user. It is generally safer to use , but it will depend on the input. See Internationalization Tips Indenting/Line spacing Your compiler directives follow on the immediate line after the function signatures, which looks a little cluttered, and hard to spot the beginning/end of the compiler directive. I'd like to see an extra line before and after the compiler directives. Enum ordering I'll let you off the hook for the inconsistent casing of enum members, as I see that you're trying to implement a consistent style, but also trying to maintain the Win32 capitalizations. But, you are using inconsistent ordering of the enum members - sometimes the members are alphabetical, and sometimes they're by hex value. In my experience, it is better to define the enum in hexagonal order (as it's easier to spot omissions), and then rely on the Object Browser/Intellisense to render the enum members alphabetically. Magic Numbers/Constants There are numerous references to magic numbers (like for Office 2000) and string-literals (like ) throughout the code. These would be much better defined as constants (with a view to allowing multi-language support). You make the effort on occasion, but not on others. You also use magic numbers like 240 and 480 (for x and y), but without adding comments (or descriptive constant names) to explain why. Passing 0 to GetDC Your function accepts a Long/LongPtr, but you're passing a integer-literal of . You can avoid an implicit conversion, by using instead of Backward Portability It seems this would almost work in VBA6 hosts, but the compiler constant wouldn't be present. For portability, it might be nice to add a commented-out compiler constant of: 

It is not just the safety of your code that you should be worried about. You need a holistic approach; your question suggests to me that you have not looked at the bigger picture. Read this article and you will see you need to approach your question differently. For one, it depends on your server's configuration. Depending on how important the security requirements are for you, I'd suggest using a third party service; either one which takes the problem off your hands entirely, or if that's not an option, have a consultant guide you to making a setup that will stay secure even over time while code changes and cracks can slip through unnoticed. There are some services that can try to find holes in your system, but they are only of limited use. If you need a better answer than this, I think you're going to have to give a lot more info on the context of your code; where it's used, how it's used, etc.