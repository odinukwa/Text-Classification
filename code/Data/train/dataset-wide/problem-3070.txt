I would also say that the user should have no idea about . A practical reason for this is that I, as a lowly stack user, have no idea what the most efficient is. The OO reason for this is that this is a detail that I do not need to care about. All I need to know about a stack is that it is a FILO container. I would expect it to have push, peek, and pop functionality. I don't care if it is implemented as a dynamic array, or a linked-list, or whatever. 

I'll just say it, I don't like singletons. Rather than create static member variables, I would create static class functions: 

Forgive me, I've never written a word of PHP, and all of this under the assumption of possible. Making it's own scope would be a first good start. 

As a side, your if statement isn't doing anything because both cases assign the value to configOptions. 

assigns last to temp, which may be null. If the list is empty, you will call on null. Otherwise, it is a pretty well made list. I would change the names of your functions/class. 

As general advise about naming, the words you are using to describe what is happening are good hints at what names the functions/class should be. For example, you use Doubly Linked List in the title of this post, and you use the word "popped" as output to the remove functions. 

you are indeed setting a new value to , but because is just a copy, the original does not change and with you get the orginal object. That's why 

and in you just do and . I've checked the code above (I've updated with the destroy functions) with valgrind and it told me that everything was freed correctly. 

you are leaking memory because you lose the reference of the pointer returned by and you cannot free it when you destroy the object. And you are not checking if is returning 0. So I'd change it to: 

shouldn't do end in a recursion, because points to , but is still unchanged and points to . And now you can use the same behaviour for destroying the Employee object. Let's say you have function pointer in which points to the destroy function: 

so now the destroy method can do to free the memory of the base object. edit An alternative is that you create a init function for objects that gets an object as an argument and does not allocate memory by itself. I'd do: 

I told you that you would be leaking memory because you lose the original pointer that returns. And that is true, however I failed to realize that you have in fact a pointer pointing to the original address that returns: the member of the struct. In you do 

Palindrome Function You don't need this function at all because we know that if the string is not a palindrome, it is only off by one character. We were able to figure out the index of this character just by moving and Anyway, since the function returns a boolean, it should be named 

Flow The and s inside the while loop make me feel the loop is doing too much. I would say that the loop should be for moving and and then put the logic outside of it: 

jQuery has , which seems to be what you are looking for: $URL$ Otherwise, if you don't want to use jQuery at all, you can make a for loop: 

Again, forgive me for not knowing any PHP. You may even consider making 'active' it's own scope as well, what good is it for an admin not to be able to find inactive and restricted movies? I would probably make the pagination it's own scope as well. 

Now you can have a static interface to your class and still be able to limit the scope of your variables. 

The stack should be an incomplete type to the user. This is going to allow you to hide all of the implementation details of the stack. Right now, it is possible for the user of your stack to change the variables contained within the struct. 

is dereferencing , the type is not . In C when you do an assigment with struct objects (not pointers) you are copying bit by bit the bit pattern into a new object. That means that the bit pattern of is the same as the bit pattern of , but they are not the sam object, the reside at different places in memory. You can only call when stores the address returned by either or . If you do you are passing a completely different address to that one that returned in , this is undefined behaviour, you cannot do that. There is no other way for you, you have to store the original pointer in the struct, that's the reason why I added the in the struct, so that the original pointer is not lost. 

Sorry, it seem to me you don't have a real understanding of memory managment and what the dereferencing operator does. First of all, you have no guarantee that after you can access the contents of . After the , points to an invalid location and accessing/dereferencing it is undefined behaviour. Secondly 

There is one thing I don't line about : you are leaking memory. should be a pointer, not the object. You are creating the object with , by doing