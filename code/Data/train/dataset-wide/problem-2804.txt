No need for ; after functions. Only declarations end in semicolons. When passing AABB objects, which are on the large side, consider passing parameters by const & instead of copying. It is faster to copy objects less than 3 words. This is 4 floats, it is kind of borderline but I will check. Certainly if you use double, then pass by reference. 2b. AABB is a weird name. Boundary would be better. Do not pull code out of the class when it is so short. The constructor and destructor are 4 lines each, the code becomes more readable and shorter when kept in the class definition, and this is the kind of code where you want those inlined anyway. Do not pass Data by value!!! This is huge, you have no idea how big T could be. Always by reference when you don't know. The biggest so far that I found is that in insert, you are testing nw,ne,sw,se. You should be comparing your value and deciding which one to do without trying them all! You might consider having only a single bounding box at the top and computing the bounds of each sub quadtree dynamically. It might be just as fast and would take substantially less space. 

Is this a reasonable approach? Is there a better way to handle columns larger than 255 characters? Blobs add complication and can't be searched, right? Suppose more types are added. Do extra fields just get added in new tables and joined to the base question table? If so, every kind of question then requires a different query. Is there any better way to do that? Ideally, I would like to be able to write a stored procedure that loads all questions in a particular quiz. The two approaches that occur to me are selecting each question and based on the type, creating the object, or selected all the objects of each type. If the system expands to 10-20 different types of questions, what would be the best way to implement this query? 

Of course, you could instead use std::swap. However, given all the alternatives, if performance was a non-issue (e.g. absolute clock cycle count was unimportant), I'd impress simply using std::min and std::max. 

This final version, $URL$ works the same as the original code, using just 35 lines of code. Included here is the JS code. 

Avoid Hard-Coding Values should validate the level range. In a real game engine, you'd probably have files in a data folder instead of hard-coding the levels within the source code. For example, you might have files that look like this: 

What you've actually implemented is an unoptimized reverse selection sort; in this case, you've combined a bubble sort with a selection sort, which has better performance than a pure bubble sort but not as efficient as a pure selection sort, primarily because you're making potentially far more swaps than you would with a pure selection sort. You could change it from the current implementation to a pure selection sort with minimal change: 

One file per level still applies, though, as it will reduce loading time and memory usage (not that either is significant in a game this small, but the principle is important). 

Under the covers, each matching element will get its own closure, and therefore operate correctly. I'm assuming in this code that one div is contained within the other (there's no HTML here). It's pretty trivial to use other methods, such as finding siblings, etc. In an absolutely worst-case scenario, you can use data attributes on the clickable element to target other named elements, or you could make a named map: 

This query will return array of all posts that have your set to 1. You'll have to check if the current post id is the same as the one in this query, if it is, you can continue to save, and if it isn't you'd remove (with SQL query) this entry from the postmeta table. Also you could only check if the meta key exists, and if the post id is different, remove it. This will ensure the deletion of the database entry even if the value is 0 (unchecked checkbox). The other thing that comes to mind is . But I think you'd still need to sieve through posts with this post meta key, see if the key exists and the post id's are different, and then delete it with . 

If the variable is set and not empty string you'll get a true as a value that will pass the test. I'd do it like this: 

I'd do your code like this. It's a bit cleaner imo, and it has translatable strings in it, if you ever want to translate your theme/plugin: 

If you're on a single post or a page, you'll get the post meta, and if you're anywhere else, you'll get blog description. And then output it only if it's set and not empty. My advice is to see all the cases that can come up with conditional tags and set your description accordingly ;) 

Can this code be optimized somehow? I tried to use directly, but couldn't find out the count that way. The only thing I could think is to create am array of numbers and go through each one. I mean this does the trick, but optimization is important, and I was wondering if there is any other way of doing it? 

Even if I'm not quite right, 99.9% of the abundant numbers will immediately be abundant with this test, so in constant time you will have detected them. You could check a few manually the rest of the way if you are "close" to abundant. I leave you to decide how close is close. A number that is not divisible by 2,3,4,5,6,7 is almost certainly not abundant. So you can find that critical value and then not test anything higher. Store the abundant numbers into a vector. Given the list of abundant numbers: 

I was perplexed why you want a better answer if your current answer is able to solve this in seconds, but if you are interested in the math, there are definitely better ways to do it. They just don't matter much if the maximum number is on the order of 28000. If you eliminate the lists and go up to the square root, the code should get faster by a factor of 1000 or so, a rough estimate based on the difference between 28000 and the square root which is 167. Another factor of 2 due to only dividing by odd numbers after checking 2. But if you look at Wikipedia on abundant numbers: $URL$ You will see that the first abundant number that is not divisible by 2 is 5391411025 First of all, that's way more than 28000. So you can immediately ignore any number that is not even in your search for abundant numbers. Wikipedia says 2 or 3, which is confusing and seems wrong. Perhaps I misunderstood them but I was looking at their list of abundant numbers, and 20 is abundant, and it's not a multiple of 3 (it's a multiple of 5). 1+2+4+5+10 > 20 Still, this means that any number that is abundant is going to be divisible by 2 and either 3 or 5 (or both). Think of it. How are you going to get factors that sum to a lot? You need factors that are an appreciable fraction of the whole number. The closest you can get to n is n / 2. The next closest is n / 3. The highest number you have to check is the square root, and since the square root of 28000 is about 170, that's the high end. But you can immediately terminate if you find that the number is already abundant, or if the sum is so low that it cannot possibly become abundant. So try only even numbers, and do the following: 

Using method will have an side-effect if is modified. This is because arrays are passed by reference, and so any changes to will be visible to the caller when the function returns. Use if you need to manipulate id or name, unless you intend to return the modifications to the caller. Example: 

Using this design means that you could literally edit levels into the data folder and have them appear when the menu is displayed, and offer (potentially) unlimited levels. Since we're talking about C++, the files could be simple, something like: 

Which basically moves all of your if-else logic into standard library calls. By the way, a popular method for switching numbers in place without a temporary integer goes as follows: 

Where 's' is the starting point, 'e' is the goal, and # are the walls (basically, similar to the format you have now). I'd also include a title, but that's a personal preference. In this case, I'd read the first line from each file while displaying the menu. Alternatively, to avoid reading tons of files, you might just have an "idx" (index) file (e.g. levels.idx) that contains some format, like: 

This design violates first normal form, which is a concept that states that each data field should contain an atomic value (using type and ID together makes this a composite value). This makes certain types of queries more difficult, and you'll use more database space and suffer query performance. Store the type in one column, and the ID in another. If you have many tables, you might consider breaking it out so each module type has a corresponding "likes" table (e.g. and . This uses significantly less space and makes maintenance easier, but makes some queries harder (such as "show me all my likes"). Using a single-table notation is acceptable, but by breaking the type and ID out, you can use an and an instead of a , which will improve query speed on full-table scans, and use less space on disk.