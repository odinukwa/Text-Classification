If you are in a single threaded environment then your implementation is okay. But if you ensure the shared_ptr is cleaned up before you return then shared_ptr's life won't be extended. 

Prefer declaring variables where you need them. This makes it clearer where they are expected to be used. Don't worry about optimizing stack allocations because the compiler will move the increment of the stack pointer tot he beginning of the function anyway. Only when there is a cost to initializing the object should it be pulled out of loops. 

adding and halving is cheap, don't bother optimizing it out unless it is a problem all you need is and and derive the rest from that: 

This means that you'd need to find it again in the priority queue and shift it up if needed. So you may as well remove the for loop and change the name to This can be more efficient by first collecting all changed neightbours to outside the loop over all neighbours. And then submitting the collection of changed vertices. This saves you the loop over all vertices in the open set to once per . Even that loop can be saved by using a secondary index (like a HashMap) that will let you find the index of each changed vertex in constant time. 

I don't like using the object as a mutex and Condition variable. Doing that would let another programmer spin up a thread to lock and never release the . Instead you should either provide a and sync on that or use the java.util.concurrent.locks.ReentrantLock and its condition: 

It looks to be correct. However this code can result in unbalanced trees (like if you add all numbers in increasing order). To keep it balanced you can use the techniques described for self-balancing trees 

In your placement new is to a location a location that already has a initialized node, you should first call the destructor on it or assign a default constructed node. 

Consider if you have an tile with 2 possible paths to the goal one direct one which takes or another way which has more steps each with just . Your code will select the inefficient path every time. When using a queue you will need a way to find the node and tell the queue to update its internal structure. However if you accept the memory cost then you can simply add the new neighbour with better FScore. Then when the one with the worse FScore comes up you will already have pushed it into the closed set and the will catch that. 

You should probably try to understand the reasoning behind . After you get the pointer you need to be sure that it won't get deleted by another thread while you are using it. That's why it returns a to let the calling code decide when the object is allowed to be deleted. 

After reordering the operations it's now clearer that they are opposites. Especially after extracting the range as variables. 

You can combine and into a single group You can pull in the negation sign with a is equivalent (usually) to and can be pulled out to the end (or use the api than only matches the entire string. 

This will create a lot of namespace collisions. Writing where you need to isn't that awful. You have a destructor so you should also create copy and move constructors and copy and move assign overloads so you follow rule of 5. Your create node makes extra copy when it doesn't need to. Also let the store value be initialized in place: 

Thread safety is pretty poor. Instead of making threads I suggest you change the WorkerThreads into and make the do only a single and return the best move. Then you can submit it to a 's which will distribute the work over several cores automatically. (You can get a using ) This should be created and held by canvas to allow the executor and it threads to be reused as needed. 

You use a busy loop for a timeout. There is a better method with javax.swing.Timer. This removes the need for and the thread. 

In pre-java 7 (without the try with resources) I find it easier to nest the try-finally in a try-catch: 

Extending this you can split the list up in numbers and operators and use 1 loop for the numbers 1-9 like above (with 3 replacing 4): and place the operators and 0 separately. 

When looping over all primes you can make use of the previous primes you have found to skip the non-primes. This can be done using the for example sieve of Eratosthenes. 

After the first outer loop has run once you know that the largest element is at the back of the array. This means that you can shrink the number of iterations of the inner loop by 1 each time the outer loop completes 

Your code assumes that of the result list is thread safe for different indexes which may not be the case. You resizing will fail when someone uses the fixed-length to store the result. Instead create a second list to temporarily store the result (in a thread safe manner) and then fill the passed in using a list iterator: 

You have a destructor but no sign of a copy constructor or copy assign (nor of the move variant), you should implement them or mark them deleted to avoid use-after-free bugs: 

You can swap JEZ and JNZ and then remove the noop jump to check, and because the instruction before start is the same as before the JMP to it at the end you can remove the two instructions: 

To wait for all worker to finish you can join the threads (this will wait until the thread is finished) like you do in the destructor. You can check the property of std::thread to see if it's already been joined or add another boolean flag: 

You don't need the s to see if \$s[i] = “a”\$ you only need to do . If you really want to minimize the time it takes then dumping it into a would be best. Something to note is that you can square s much faster doing the simple multiply with self method than convert to and use call . Also the square root of a square is the same as the original number. 

The Pattern is always the same so you may just as well make it a constant. This will avoid having to recompile the pattern each time. 

You should create a immutable Card class that hold the value and suit and use an enum for the suit values: 

First the lists you pass have generic parameter while the nodes have parameter . This feels like an error. Second you don't clear the list you don't pass back (setting to null) which means that it will destroy its nodes (which are now part of the list you returned) leaving the list you return with a dangling pointer that will end up double freed. I would recommend not accessing the innards of the linked list in general. 

There is a lot of duplicated code in there. Most of the later parts of the blocks in fact. And there is a condition in common in both outer conditions: So lets pull that out first: 

A simpler solution would be to let the calling code be responsible for all memory buffer allocations. This changes the example code to: 

You leak every single node you pop. You need to the node. You should add move and emplace push overloads. So that non-copyable T can be stored. you check against "overflow" by testing top is less than -1. However signed overflow is undefined behavior and if you ever had more than 2 billion items in your stack you probably ran out of ram earlier. You can check if the stack is empty by testing if is . So top isn't really necessary. For every operation you seek the end of the stack, that is not necessary at all. 

The callback should not be exposed to the calling code. Instead hide it in a nested class for that. In Java8 you can create a private function and pass to . 

is sorted at the start of each while loop and the sorted list thrown away (if I read that selection syntax right). This is a cost of O(n log n) on each iteration. It is then followed by a remove which takes O(n) time. You don't need the full sort, only which element has the smallest cost. And the priority heap will let you get that efficiently. If you don't opt to go for a prio heap then keeping the sorted list around can speed up maintaining the list sorted. As sorting a partially sorted list can be faster than sorting a completely randomly ordered list. Especially when you take into account how nodes get out of order. 

My MainWindow popups a SettingsDialog. The setting dialog need to hide certain fields if the connected device is certain type. 

2 Scanners wrapping the same input stream will conflict with each other. They will each read a portion of the input and interpret the data and then keep "leftover" data cached for the next call to . This cache is not shared between scanners. It's better to use just the one scanner. 

first check if the priority 1 are unequal and then return 1/-1 accordingly otherwise check priority 2 and repeat If you reach the end then all terms will be equal: 

You can name crutch into something better that describes what it represents. Or keep whether ChangeToSmall or ChangeToBig was called last and replace crutch with that property. 

First did you compile with optimizations enabled? If not then do so when profiling. A good optimizer will produce equivalent code after unrolling the loops. The first double for loop is superfluous. It is doing busy work that is overwritten in the second loop. 

The player class doesn't need to exist. All it does hold a name and forward operations to its hand. Your shuffle assumes the deck starts out empty. It is a proper shuffle so you did that right. However there exists a for your shuffling needs. The ace card can have 2 possible values 1 and 11, you didn't account for that at all. Your builder doesn't do any defensive copies which would let using code modify the internals of Deck.