Euler project problems are best optimized using a different algorithm, the double for loop leads to O(n^2) while it can be much faster using a sieve method. I'll be keeping an array of all already found primes to test against. Besides that the inner loop should only run while (if there was a larger number that divides i then we would have found first) and put the sum part out of the inner loop: The if is true once in the inner loop at the final iteration, you can then move the code to the outer loop after the inner for. Using the array: 

I think the major part of the slowdown will be applying the style. Otherwise you can pregen an array with the possible phases: 

Try to avoid allowing the invocation chain to go from a valid object to an invalid object. Your allows that. Instead you can make a method which takes all the required configuration items for setting javaSE to true. 

you #define and but then don't use them in the nextFrame function. Also enum beats macro for a group of related constants. 

This makes it easy to change the semaphore to a fair one by passing true to the constructor. Though I expect you will want to implement the wait queue yourself as an example. If you want to go a step lower and no use the pre-implemented locks can instead use LockSupport which lets to park the current thread and unpark it from another thread safely. 

(I've added a little creative whitespace to show parallels between the branches.) The only thing I'd change now is to pick a better name. For example, might be an okay name for this. I'll mention one more thing, which is that this can also be implemented quite beautifully as a list comprehension: 

If we're feeling fancy, we can choose to use instead of two separate calls to and ; and we can unroll the definition of ; but I think neither of these is terribly important. Nevertheless, they're idiomatic, so: 

Personally, I often prefer to , and the is complicated enough that I feel like it should be named, so I'd write it as follows. But this is an aesthetic choice that you may or may not agree with. 

We first need to fix up some typing issues, since we've changed the interface to and this is a caller. As before, we can do that just by putting in a ; as before, we'll spell the combination of and as . 

As usual, the tests. Since the old function was pretty partial, we'll arrange to have inputs it knows how to handle, though our new one tries to give an answer even when you feed it garbage. 

but you don't use it after that so there is no need to keep it anyway. You can upgrade the algorithm to A* by guesstimating the cost of the remaining path and comparing the . As long as the guess is lower than the resulting cost then it will remain correct. 

This can clean up the init code as you don't have to do and can instead just pass directly. Though having said all that you can just put the List of neighbours straight in the and not deal with having to look it up in . 

Your Big O interpretation is a bit flawed, This is only O(n) per recursion step (single loop with every operation in the loop being O(1)) leading to the normal O(n log n). The first optimization you can do is 

Don't use raw pointers and prefer keeping the Field by value in . Each dereference into cold cache is 200 cycles dropped on the floor, you force the cpu to do 2 of them each time to get a . If you instead have a single std::vector with size indexed with (you can overload to retain the interface) you will get faster random access. Whether a is closed can be kept by adding a member field into defaulted to false. is equivalent to and you got just a little bit earlier. You may as well have just kept it temporarily. When updating a you should remove the from the set and reinsert it. The you use won't work correctly when you update it's values in place and invalidate relative ordering. 

Actually, this whole process at the very end is quite roundabout! If you squint, it looks like what we're really trying to implement here is a little function 

though this spelling is optional. In fact, everything is short enough now that I would even feel comfortable inlining the definitions: 

(If you haven't seen before, I encourage you to try to code it up yourself! Then check the Report and compare answers.) Additionally, we're going to have to change things up a little, since we've changed how works and calls . Before, we had and hence . Now, we have and hence . Since we expect each of the lists in the output of that to be singleton lists, we can smash them all together with : 

By the way, there are functions for this available, too; take a look at from (base-10 specific) and from (pick your favorite base). I won't try to write tests here, because the types of these functions are more informative (and more correct in many ways). Final result Barring the reuse of already-written functions, here's the final versions of all the functions. 

Now, we have this branch primarily because still isn't total (it can't handle an empty input list). Instead of protecting ourselves from calling in this case, we should just let deal with empty lists correctly. So: 

I would make it clearer that you are looking at a single array that is split in the middle in the parameters. Instead of pre-filling the result vector you can reserve it and push back the values. The value type of the iterator can be discovered by using . The reserve is not strictly necessary but it will avoid reallocations that aren't needed. 

You don't reset the when you return the result. This means that between calls you need to reset the state manually. Instead you should reset the state: 

You can gain some efficiency by wrapping the writer in a BufferedWriter. If you are using java 7 or better you should use try-with-resources to auto close the writer, otherwise you should use a try-finally: 

You use lock locks in the get and release methods. This somewhat defeats the purpose of using the threadsafe pool. The getPoolSize doesn't need to wait on finishing the get or release as is thread-safe and the pool's size is fluid anyway when multiple threads are contesting over it. For shutdown you can use to clear the pool to another collection when shutting down: 

On that note I suggest renaming to and remove the from it. Some added functionality for it would be adopting a locked lock, relinquishing a locked lock (without unlocking it). I also expect (from experience with such in C++) that creating one will automatically lock the lock for you. There is generally an overload for when you don't want that: 

This isn't obviously better, since it still fails in all the same situations it used to fail, and it never returns multiple answers. So we should differentiate the two cases that lead us to the branch: 

Whoa, whoops! Can you figure out which refactoring above was the culprit? =) Now we have to decide whether we like the old behavior better or the new one. I think in this particular case we should like the old behavior better, since the goal is to show a number, and we'd like to show up as rather than as . It's a bit ugly, but we can special-case it. Since we like our future selves, we'll leave ourselves a note about this, too. 

This name sure leaves something to be desired! And it leaves another important thing to be desired, too: there's lots of inputs where it just crashes. Nasty! It turns out that you never call it on inputs of that form later, but totality is another good habit that you should get yourself into. It's just another tool in the mature programmer's defensive programming toolbelt. In our case, we'll want to handle cases like , or , or , etc. where there's no good answer to return. What should we return if that happens? One simple and quite common choice is to change our type from 

Erasing the individual means moving everyone that comes after. If you don't care about order then do a swap with back: 

If you don't mind using more nodes you can simplify Node 2,3 by letting it ADD UP ADD RIGHT and MOV ACC, DOWN (and MOV 0, ACC) Then Node 3,2 and node 3,3 is a copy of node 2,2. This removes 2,3 as a bottleneck that needs to gather 3 values and instead will let the other nodes help gather them. 

Node should have a destructor the deletes its child nodes. The signature means you can't build from a dynamic array (build itself is private) or a std::vector for example. 

Besides that if you are using it for parsing then you will be popping and pushing nodes often. So it may be worth reducing allocation cost on that by keeping a linked list of previously allocated nodes: 

When you update the vertex' estimated distance you should signal the openQueue to update it's position in the backing array. 

Add a buffer length parameter and then use to avoid overflow. Your testing code hides the usage of the function. It's clearer to put it on a separate line: 

Now, I wonder whether recomputing the power of ten each time is really the right thing to do. One thing we could do is to use and divide by 10 in each recursion. But division is slow, so let's take another plan: instead of computing the length of the list explicitly, let's do it implicitly by having also compute the appropriate power of ten. 

First things first: you'll definitely want to learn a bit about precedence! Normally I'm in favor of adding some unnecessary parentheses if it helps disambiguate a strange situation or if the operators involved aren't often mixed, but too many of them can get in the way of readability. Also, take advantage of that sweet syntactic sugar for lists that the language provides! So iteration one of this function is 

There's something a bit funny about this base case to me. It seems like it's not the most basic one you could choose. If we let the "loop" run one more time... 

It's common in cases like this where the trailing arguments to the function you're defining are also trailing arguments to a function in the definition to omit the arguments entirely. The technical term for this is , I think. Whether you choose to do this yourself is primarily a stylistic choice.