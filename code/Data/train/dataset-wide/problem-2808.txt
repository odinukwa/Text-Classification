I'm trying to lighten the code review load for the maintainers of boost.math, and I was hoping you guys could help me out. I have a pull request which implements tanh-sinh quadrature, which is provably optimal for integrands in Hardy spaces. Here's my code: 

Unfortunately, the imposition of these requirements has left me dissatisfied with the design and look of the code: 

It should support progress reporting, ETA, and graceful cancellation. It should handle finite and infinite intervals. It should allow restarts, and changing of error goal in flight. 

It is a class and not a function. This is a bit confusing; I worry that people will not recognize that the constructor is doing some one-time calculations to make integrations faster. It takes a long time to compile. I generated the abscissas and weights to 100 digits, and then they must be lexically cast to their correct type. I could keep fewer levels of abscissas and weights in the .hpp, but then the runtime would longer for complex integrands. For integrands in Hardy spaces, the number of correct digits always doubles on each refinement. However, we want to do just the right amount of work to deliver the requested accuracy, which is almost always overshot. 

I have a PR implementing multithreaded naive Monte-Carlo integration here. My requirements for the class are the following: 

Since the constructor accepts primitive types, it can also be wrapped in Python with moderate effort (you'd need a shared object and some template instantiations, but let's assume that can be done). You can also let and go out of scope and the interpolator will still work. The tragic flaw is that it performs a huge memcpy, which is slow and not space efficient. Is there a way to refactor this class such that 

6) You do not need to create an label and GOTO that label. Instead you can do either of the following: or . They are identical, and neither form requires an explicitly declared label. The only difference is that can take an optional argument specifying the returned errorlevel. 7) You should encapsulate the logic for writing an email into a subroutine that accepts the variable portion as arguments. It reduces the amount of code, and eases maintenance. 8) I've simplified your ERRORLEVEL logic by using an extra variable to store the return code. I also make use of the conditional && and || operators with FINDSTR - I find them to be more convenient then checking the ERRORLEVEL. But I didn't use them with WinSCP because the logic is a bit complex. Note that if the last command within a block raises an error, then it would cause the block to fire. That is why my :sendMail routine explicitly exits with a return code of 0 (success). Using the above principles, I would write the code as follows: 

You can use a FOR /F to parse out the command from the arguments. I would define a variable containing a delimited list of all valid commands. Then you can use simple search and replace to validate whether the user entered command is valid. Addition of a new command is as easy as adding the command to the list, and creating a labeled subroutine for the new command. I would use CALL instead of GOTO so that each routine can easily parse the arguments. The only disadvantage is CALL will double up quoted carets ( becomes ) Here is a basic framework that can easily be extended. Note that user entered will be corrupted (or expanded) because of delayed expansion. There are simple ways to get around this limitation with additional code. 

I feel the classification of the limits as finite, half-infinite, and infinite is an unnatural hack. Is this necessary? Each thread needs to accumulate a variance, and average, and a number of calls. These must be atomic so they can be reduced by the master thread without a race condition. However, a vector of atomics cannot be resized, so I used a map, which, though not a catastrophe, seems suboptimal. Is there a workaround? I'm using (say) , which seems to have widespread compiler support, but won't have official status until C++20. A workaround is to use a mutex, but a mutex is a disaster for performance. What should be done? I'm taking the function by , but should it be forwarded ? Or should it provide two constructors? I tried many random number generators, and the Mersenne twister seems to be the only one that doesn't contract 'weird seed' and reliably 'does the right thing'. However, it returns a 64-bit integer, which must be remapped into the open interval ]0, 1[ (or else it'll hit singularities on the boundary). Using was too slow, so I use , which is always <1 and >0 in double precision. In float precision, it gets rounded to 1 or 0 quite frequently, so I've added the following hack: 

Yuck. Generally, it is bad form to take STL containers as arguments, as the bounds require. Any suggestions for replacement? Perhaps the template parameter is redundant, and can be replaced by the return type of the function? 

For those of you interested in performance, I have used google benchmark to measure the runtime, which is reproduced below: 

I can almost guarantee it is not doing what you think. The most it can do is set the ERRORLEVEL. However, The EXIT command expects a numeric argument, but you pass . The EXIT command returns 0 if it does not receive a numeric argument. I doubt you have a variable with a name of "0", so the EXIT command sees a string literal value of , which is non-numeric. It consequently returns 0 every time. Your very next command (FINDSTR), is an external command, so it will set the ERRORLEVEL anyway. There is no need to initialize it. 2) It is generally a good idea to enclose SET assignments in quotes. This guards against poison characters, and inadvertent trailing spaces. (There are some exceptions, but it is a good rule of thumb). 3) It is generally a good idea to always enclose file paths in quotes if a portion is a variable. You never know if the variable may contain spaces or poison characters. The value normally does not have spaces, but it certainly could. 4) There is no need to delete "%temp%\rdcto.txt" when you immediately turn around and recreate it. You can simply redirect using overwrite mode () instead of append mode (). This will guarantee you start out with a fresh file each time. 5) Why do you write the value of %MailDst% using a FOR statement? You can simply echo the value directly. 

Use FOR /L to iterate a range of numbers - much faster than SET /A with GOTO loop. Use SETLOCAL to localize variables so no need to undefine them. The EnableDelayedExpansion option does just that so that you can use within a FOR loop. A minor optimization - it is faster to combine multiple math computations into one SET /A. 

As you can see, the first argument is the current script file name, and the arguments following are the dependencies. We account for dependencies that have already been loaded by testing in the arguments to the function: 

You can think of the problem as one of mapping the rows of three letters to the correct button. If every button had the same number of letters on it, then we could simply divide by 3 and add 2. To correct for the fact that two rows have four letters, we can treat them as special cases by "pulling them out" and shifting all the letters that follow into their appropriate spot: 

Or if we wanted to break it up [ignoring error-handling for the moment], you could do something like: 

And then the function ignores any falsy dependencies. If it were more widespread I would have used the operator instead of . Last update: What I decided to do instead is have a PHP function that you call like so: 

The following page simulates XSS attacks and successfully (?) prevents them. I want to know if I've missed any other major attack vectors (or small ones) and/or if anyone has suggestions as to improving my escaping methods. There are three contexts in which I attack: 

The one thing that I don't like about this approach is that the code which grabs is not encapsulated in a function. If I did have a function, say called , which grabbed the code, the file that it was stored in would have to be retrieved in a similar way, so it would be a circular solution. The ideal would be to use a CMS with modules that handled dependencies like this for us, but that's not something we have right now. Update: I've tried to make it as easy to copy and paste from script to script as possible: 

Other possible changes: I didn't make any of the changes below because you said your code was working, and I don't know those programs enough to guarantee the changes are an improvement. A) I don't see why you run WinSCP via START. I believe you could simply use: 

B) Your sendmail arguments look very suspicious to me. Normally values that contain spaces should be enclosed in quotes. Note that the routine above preserves the lack of quotes by using and instead of and . C) I don't know WinSCP, but I suspect it will overwrite any existing log file, in which case you could remove the prior DEL command. 

You could even parameterize the two divisors, but then a different algorithm is needed. Here is a fully parameterized solution that is efficient, though perhaps a bit obfuscated. I still use a modulo operation to test if divisible, but instead of an IF statement, I intentionally divide by zero to raise an error and trigger the conditional execution of the SET statement. Of course I redirect error messages to NUL to avoid unwanted error messages.. 

You probably want to localize any environment changes. You should initialize your variables to a known state at the beginning, otherwise you could get the wrong result. You have a lot of redundant code that can be eliminated by using a CALLed subroutine You can use the operator to conditionally execute code if the previous command failed. I find it simpler than using IF ERRORLEVEL. You can save a bit of typing by storing code in a variable to be used as a simple macro.