You save yourself having to cast another float2 (for the x & y math operations), and you leverage .xy per-component math which is faster then doing it each separately. In your pixel shader... 

You create a single float4, and then just work with it's .rgb through the shader, but return the float4 whole at the end. You can do this in other places, too... often people will pack HLSL vars full.. eg: they'll take 2 float4's and use the .rgb parts for colors and then pack a float2 in the .a alphas of them... eg: 

... that way you declare 1 float4 return value, and do the math for .rgb and .a separately. B/c as you're doing it in your initial way, you're wasting calculations a) generating a float alphaChannel var that never gets used, b) calculating color.rgba when you just replace color.a in the return anyways (by re-calculating alphaChannel), c) you're casting another float4 in your return, and inefficiently comma-delim'ing your color.r, color.g, color.b values when you can just color.rgb them together. The idea is to reduce the number of variables casts you make... so while you can "float4 ( somevalue.r, somevalue.g, somevalue.b, somevalue.a )"... if you're already creating a return value, then just use it as the return value instead of recasting it. Sometimes your return value you're dealing with may just be a float3, eg: if you're only pulling the rgb of a texture, working with it, and the alpha .a will always be 1. Even then.. just cast a float4 from the start, do all your work with the .rgb float3 parts of it, and then set the .a part of it to 1 and return it... eg: 

Then you can call instead of and instead of You could also put a inside to make things even shorter. These changes give you a kind of API to shorten and simplify interaction with your game state. Here's what those helpers would look like as macros. (Hopefully; I'm far from a macro expert.) In this case, since we're not doing anything special with the order of evaluation, the macro version of looks exactly the same as the function version. 

Not to be excessively negative, but the solution in the C# code is much cleaner than the one you implemented. No shame in that; it happens to all of us. But I assume you wanted some advice on making the code you have run faster, because if you just wanted to copy that C#, you easily could have. So that's the direction I'll go with the rest of the answer. It honestly puzzles me that this code is so much faster than yours. I would have expected the BigInteger math to be the really slow part, but this code does the same amount of BigInteger math as your original code. Your code does take quite a bit more memory, since it stores all the Fibonacci numbers it calculates, whereas this code only stores what it needs to calculate the next one, and uses an integer to count how many Fibonacci numbers it's seen so far. An array list is backed by an array, so actually accessing the items shouldn't be much slower than with a plain array, but there might be some kind of cache or memory allocation effect. With this code, the compiler can block out a single, static chunk of memory. In the original code, the that stores Fibonacci numbers keeps on expanding, so the backing array might have to be reallocated several times. Every time the array is reallocated, everything stored in it has to be moved over to the new storage space, which is pretty slow if you have a big list. If that turns out to be the problem, you can try passing the constructor a guess for big you think the list might get (the default size is ten). If I were you, I would profile the code and look for some issue like that. Dig into the implementation and see if it's spending a lot of time reallocating. Just see where the code is spending its time, and try to figure out why that's where it's spending its time. If you don't already have a profiler you like, Netbeans has a pretty good one built in, and I'm sure Eclipse and other Java IDEs also have them. If you profile and post some of your numbers, we can probably give you better help with diagnosing performance issues. EDIT: @ChrisHayes discovered why the code is so much slower: it's the call. I took the original code and just replaced the call with a check against a limit of \$10^999\$ as the C# code does. Still used the array list, still stored all the Fibonacci numbers. As Chris Hayes observed, this reduced the runtime from about 900ms to about 13ms. The author of this blog post also found that was quite slow. An answer on this page implies that BigIntegers are stored in a way that makes it easier to implement the method that lets you convert a BigInteger into other bases, like hexadecimal or ternary. One could apparently implement in a more specific way that makes it quick to convert into a base-10 string, but difficult or impossible to convert into strings in other bases, but the standard library implementers chose a representation which was more general, but slower to convert into a string. See the end of the answer for my final version of the code, including modifications I made to get rid of . [/EDIT] Aside from the performance issues, I had some readability issues—not that your code was unreadable, just that it was harder to read than it had to be, and that contributed a little to the confusion that we had over where the number 4872 was coming from. The biggest one is the variable . Unless you're working with coordinate axes, please don't call variables . The C# code gives the analogous variable the name , which is better, since you can tell it's probably some kind of counter. In general, that C# code is quite clean, so it's a good model to learn from, though I'd probably just go all the way and call it . could also work, since it's traditional to index the Fibonacci numbers with . (This is another reason why is confusing; if I'm reading a program about Fibonacci numbers, I can process or the like pretty easily, but is just strange.) I also found your use of the do-while loop with a boolean flag confusing. A or loop with a statement would have been better, but I think the best would be to let the do-while work for you, and write something like this: 

For readability I would recommend create a instead of working with . Typos are sometimes difficult to track. 

Depends on what you want. Typically programming challenges are not validated on clean code. But on correctness and efficiency. 

All that is left to is checking if all bits in the mask are set to true by the current player. This is very easy using the bitwise -operator. Example: 

Don't do a lot of work in the constructor This is a bad programming practice in general. Because just creating instances can already take a lot of time. I would prefer an method instead. Or put the work you are doing in the constructor, in the method. Which can call a or something. Prune entire BFS iterations If you hold a maximum radius for each node while visiting. You can determine at start that a certain node will not decrease the radius. When it is already visited with a higher or equal radius. 

=> All bits in mask are set to true REMARK: Instead of looping, you could hardcode all row and column masks. Which are still only 8 masks. If you understand this, you should also be able to understand how to 

In this case you just want your input to be an integer (or a long). So using the regex is one idea. But you should also consider malicious users. What if you try 

First off, I'm going to have to complain about your taste in function names, which will probably be unproductive and just lead to hurt feelings on both sides. Yes, it's that function . I don't mind so much if small inner functions defined with have names like , but to my eye, something declared at the top level of namespace—private or no—should have a more descriptive name. I would probably not define as a top-level function at all; see below for more on that. It's also confusing that you call the top-level function , then also call the function passed as a parameter to by the name and then go ahead and pass as the parameter in . I kind of don't like that you expect the output of to be a vector of vectors, but you depend on the function passed as a parameter to to return a vector instead of putting that logic inside . If I had a top-level private function that's only used once and seems too specific to ever be useful again, like , I would consider making it an anonymous function that gets passed in the one time it's used. So I would probably rewrite like this: 

Or, if you're uncomfortable with the shortcut syntax for anonymous functions (it can get pretty hairy), like this: 

would call with as the value of and as the value of . The more complex way to do this is to use the module from the standard library. If you're sticking with all positional arguments, then reading directly is probably fine. You can do something like 

... HLSL has an intrinsic function called "lit" that you can read more about here... $URL$ Basically you hand it a sun luminence dot (NDotL ... dot ( normal, light)), a specular reflection dot (NDotH ... dot ( normal, halfway)) and a specular pow value (your materialPower) it does all the pow, saturate, etc.. basically creates your float specular luminence to * by your float3 specularLightIntensity. While you still have to calculate the dots in the shader, you'd use the lit function, b/c it replaces the pow,saturate,etc you have with a built-in function doing it more efficiently then you coding it in the shader yourself. I would also change this stuff around... 

... you're not using alphaChannel; you're adding filterColor.a + texColor.a in the return again.. so just make your return be... 

I think that's how you tie two different registers to one global. Might want to double check MSDN HLSL reference to be sure, though. With your xy multiplier now a float 2, you can change this... 

.. I mean... it does the same thing: loads the float4's with their values. But, it casts a second float4 on the right-side of the equation to do so. We're casting 4 float4's there.. the sunU and skyV, and then the right-side equations to piece together what we're packing in them. The way I wrote it eariler, you only cast 2 float4's in the struct, then use swizzling to tell them what goes in what parts without having to cast more vars to do so en-masse. It seems like such a minor thing, and overall it probably is, but when you have something like that in a pixel shader firing off for every pixel... it's just unnecessary overhead ... X many pixels times Y number of frames per second... it adds up. 

I recommend against having print statements inside classes. One of the benefits of classes is code reuse. Having print statements inside class methods makes the class less reusable. Some of these can just go away, or they can become logging statements if you want. The ones inside your clauses should probably become rethrows. They can also be logging statements if you want. I would probably write it like this: 

and instead of a sequence of vectors, we'd get back a sequence of maps with keys , , and . This usage is totally unrelated to your original intention for this code, but it shows how generally useful the function is—so why make it private and hide it where no one can access it? Let it out and see what uses people can find for it. Finally, for such a small program it probably doesn't matter, but one of my favorite features of Clojure is docstrings. I would write one for any function I was publicly exposing: 

I'd like to echo the comments: it would be really helpful if you told us what this code is supposed to do, exactly, and maybe explained some of the pieces that touch on what you have here, like what type is and why you chose to represent it that way. In your second code snippet, you have this section: 

which takes advantage of the fact that gets initialized before the loop condition is checked. The class has built-in constants for zero and one, since they're so common. So you can initialize your array list like this: