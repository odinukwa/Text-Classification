- Make use of initialization. In C, "initialization" means designating the value that an object will have at its creation, and it is accomplished via (exactly one of) the object's declaration(s). This is distinct from assigning a value later, even immediately after, and it has its own rules. For example, when you initialize an aggregate object other than a union, any members not explicitly initialized take default initialization values (generally 0). Thus this ... 

Stylistic issues "Indivisual" is not an English word. It seems likely that you mean "individual". Please use CamelCase with an initial capital letter for class and interface names. It makes your code much easier for others to read. Specifically, --> , and --> . Please use camelCase with an initial lowercase letter for method, field, and parameter names. In particular, --> , or, more precisely, . Class names generally should be singular nouns, for a class always describes one thing, even if that thing is an aggregate. Descriptive class and variable names are generally good form, but it is possible to go overboard. The name is considerably too long for my taste, and at the same time a bit inaccurate. I tend to read it as "absurdly long name", which defeats the purpose of descriptive naming. It would be even worse if there were other names of such length to distinguish among. For this particular case, I would certainly choose something more pithy, such as . Where descriptive comments for variables are needed, I generally prefer to see them on the preceding line, not as trailing in-line comments. The latter work for me only if they are quite short. However, do resist adding such comments at all when they add nothing to what your nice, descriptive variable names already say. It's at minimum unnecessarily verbose to compare boolean variables with boolean literals, such as in the expression . It is usually better form to just use the boolean variable either directly or subject to boolean negation: . Correctness issues is flawed. Given distinct instaces and with the same values of , and will both return -1. Just because you're comparing floating-point values does not mean that you can ignore the equality case. Performance considerations You wrap up your question by raising a series of performance considerations: 

You cannot reverse a standard linked list without touching all its nodes, which has a lower-bound asymptotic complexity of o(N) operations. Your method has O(N) complexity and uses O(1) extra space, so you cannot improve its asymptotic complexity in either of those dimensions. Note that the usual recursive solution consumes o(N) overhead, all on the stack, so an iterative implementation is clearly a superior choice. You could, however, make it slightly more efficient by updating just once, at the end, instead of at every iteration. In particular, instead of inside the loop, you could use immediately after the loop. No other changes would be required. Consider, however, that if speed of the method were of paramount importance, such that it was reasonable to sacrifice a bit of list-traversal performance, then you could create a List class for which is O(1). I would do that with an internal circular, doubly-linked list of Nodes, with node traversal performed via a Node method that relies on an instance variable of the host List to determine which direction to consider as forward. With such a structure, (logically) reversing the list would be achieved simply by changing the value of the single variable that controls list direction. Example: 

Code style Whether you write an / chain with common actions afterward (my preference, and your original approach) or a series of separate blocks, each of which returns, do put the body of each conditional block inside braces (), contrary to the example presented in another answer. Omitting the braces creates a big maintenance booby trap, as last year's major Apple SSL vulnerability demonstrated. 

This isn't a big deal, really, but as a matter of style I recommend using -family functions only when you're actually relying on them to do some formatting. For outputting string literals, one of , , , , or is usually a better choice. In particular, I would recommend as an improvement on . 

For example, the number of palindromes less than of equal to 1,000,000,000 is 1 (for the palindrome 0) plus the sum of 

Overall I think the problem you're trying to tackle is a lot more complicated than you've given it credit for. You clarified in comments that you wanted to "implement [something] similar to JDBC's PreparedStatement," and I guess you have done, but I'm afraid that the similarity is pretty superficial. 

Compute an upper bound on the time required as m * max(xi). Perform a binary search over the times between zero and the upper bound to find the least time after which all the grains have been consumed. 

Of course there can. You already said yourself that the standard library's does not offer some of the operations you really would like to have, and therefore that you have to use a workaround. On the other hand, the standard library's PQ has to be very general; all the operations it does implement, it must implement in a generic way. Although I have every reason to expect the result is robust and efficient -- and obviously, it's already there -- it is likely that additional efficiency would be possible from an implementation tuned to your need. 

You store your palindrome substrings in a , and avoid duplicates by testing whether that already each candidate you discover. This part is O(n2) in the number of palindromic substrings. You could instead do it in O(n) and without requiring an explicit check if you used a for palindrome storage, or in O(n log n) and without the explicit check if you used a . Between and , the latter also allows you to skip the subsequent sorting, but for large numbers of elements it may be cheaper to collect elements in a and afterward dump them to a and sort. 

Your code looks pretty good, and surprisingly free of bona fide problems, even for code posted here. I find that I have little or no criticism of its behavior. C does not have such a strong sense of common stylistic convention as does, say, Java, but here are some things to consider: 

Common characteristics Asymptotic complexity Both algorithms perform θ(n) operations for strings of length n. Since the task always requires examining every character of the input, there can be no alternative that provides better asymptotic complexity than these do. Additionally, each has memory overhead that does not vary with the input, which affords no asymptotically better implementation in that respect either. Of course, implementations with the same asymptotic complexity are not all equivalent by either measure. See also below, however: your implementations of these algorithms are potentially flawed and less efficient. Wrong range for Your codes assume that the string elements all have numeric value between 1 and 126, inclusive, but can be a signed type, and whether signed or unsigned it can have more than 7 value bits. Also, is always a valid (from C's perspective). As a result, on any conforming C implementation there are valid C strings which, if provided as input to either of your functions, will cause that function to exhibit undefined behavior. To solve this problem I suggest declaring your arrays with dimension , and casting input s to type before using them as indexes. Failure behavior Each function exhibits somewhat surprising behavior for non-empty inputs that contain no unrepeated characters. They return that character among those with the minimum number of repeats whose first appearance is earliest in the string. It's unclear what the function is supposed to do in that case, but the the actual behavior is potentially misleading. It would be better to return an error code. You could use 0 as an error code, as it is the only value that cannot appear inside a string. Your functions will already return 0 when presented with an empty string as input, though I'm uncertain whether that's by design. Alternatively, the functions could return type , with the result being -1 when there is no unrepeated character, else the first non-repeated one cast to . This is the scheme the function uses. Loop termination conditions Both codes contain loops with for their termination condition. The compiler can lift the evaluation of out of the loop only if it makes several assumptions about that function. Inasmuch as that's a standard library function, it is conceivable that that would happen, but by no means certain. If it doesn't happen then your implementations become θ(n2) instead of θ(n); I therefore recommend lifting the call out of the loop manually. Alternatively, consider avoiding altogether -- since you need to iterate through the whole string anyway, just break the iteration when you reach the terminator. That should be more efficient. Using type for character counters Each code uses objects of type as character counters, but 

Your code is pretty clean and well-formed, but I do have several critiques. Unexpected behavior Your program will exhibit unexpected behavior if the phrase entered by the user is longer than chars. In that cases, the call in will leave the tail of the line unread, and reading should be expected to pick up there in the subsequent call (to terminate no later than the end of that line). The user will no doubt expect the phrase to be encoded according to the next line they enter, not the tail of the first. To fix that, you should either arrange in to keep reading through the end of the line. You can discard characters after the th if you like, or you can arrange to append them to the phrase (you'll need ). Just don't leave a tail of the line unread. behaves similarly when it reads the key, which again could be surprising. It is not certain to be sufficient to limit the input key length to the message length because you don't necessarily use all of the key characters (you skip those that aren't ASCII letters). Cutting off the tail of the key can therefore change the result. This fragment looks wrong: 

You test every candidate number for primality, even though the only even prime is 2. It would be a bit more efficient to make a special case for 2, and then to test only the odd candidates in the main loop. The inner loop can start at instead of at , because the smaller multiples of will already have been sieved out by the time you get around to testing . You therefore do not need to even consider candidate primes greater than , for by the time you reach those candidates, there cannot be any multiples less than or equal to left to sieve out. (But this changes if you decide to build a list of primes, as discussed below.)