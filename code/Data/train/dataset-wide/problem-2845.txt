This is necessary within Emacs Lisp and one of the ways it varies from Common Lisp and various Schemes. Example Use Despite the difficulties that add complexity, provides a great deal of flexibility: 

Is "tree recursive" and therefore does a lot of extra work. Tree Recursion is described in The Structure and Interpretation of Computer Programs. Section 1.2.2 has a very helpful illustration that shows how tree recursive algorithms wind up performing substantially more work than is necessary. Alternative Functional Approach Recursive Design: Structurally recursive algorithms have two part: a base case and an inductive step. The naive approach to Fibonacci treats as the base case and as the induction. The alternative code treats as the base case and as the induction. This means has always been computed previously. 

An Minimal Implementation This code does not attempt to be particularly Pythonic. It attempts to reflect the underlying mathematics in an object based manner. 

A sound inheritance model allows for C style stack semantics where simply deletes the top of the stack without returning a value and is the way to read the top of the stack. 

Remarks on the Code [] The use of demonstrates the understanding data validation is important. It is a clear strength of the code. [] The line is a bit weaker. In part because is equivalent. In part because if the reason for using is to express intent, then more clearly expresses that intent. [] The code phrase: 

Instead of using the symbols ...it's not obvious what comes next without taking notes and working through the code and figuring out the implementation details... is more typical of Racket and other Lisps. The reason is that it aligns the level of abstraction in the program with the abstractions in the problem domain. When I see the parameter in the procedure my first thought is that it's type is a directory. The code base starting with low level string parsing probably sets me up. The extra characters of are worth the added clarity. 

On the other hand, the statement is very similar conceptually. The syntactical differences from recursion are: 

Create a higher order function that takes a structure and returns a function that can serve as the argument for . The returned function is also a closure over a particular . 

Note that the locally scoped function takes no arguments and uses to create an executable block of code. 

Like I said, it ain't exactly pretty. Like I didn't say, this might be more efficient on paper but not in real life. Modern compilers do a lot of sophisticated optimizations including JIT'ing at runtime, and CPU's that do predictive branching optimization. Therefore optimization should begin with measuring something that works and determining where the actual bottlenecks are. The other answers that optimize around are examples of why ideas about optimization are not always actual optimizations. On the other hand, the general approach of precomputing a cycle is applicable to other languages and other problems and the larger strategy of avoiding work is a good place to start changing code when measurements indicate changes are warranted. Final Comments I appreciate that the code in the question seeks to generalize the problem by tackling the 'Arbitrary FizzBuzz'. I also like that all of the modulo's are done in one place...one of the optimizations that are built into Python is optimizing development time. 

The instructions refer to "the first line". This strongly suggests that the program should read from a file rather than the console. Doing so would get rid of the hard coded prompt strings. The program output is "yes" or "no". The requirement is "YES" or "NO". 

Naming The name suggests a natural number even though that is not case in the implementation which operates over integer values. More importantly, perhaps, it does not reflect the 'problem domain' or 'business logic' of the underlying mathematics in which exponents can be anything that counts as a number. Precision The use of floating point values limits the precision of the numeric results and does not take full advantage of Common Lisp's numeric system: e.g. arbitrarily large integers and exact ratios. Completeness The function does not handle non-integer values for the exponent, e.g. throws an error instead of returning the square root of 3. In fairness, Common Lisp includes a function that performs the operation. The implementation in SBCL is non-trivial at just under 200 lines of code (begins at line 158). Speed Optimization applied at the wrong time and/or in the wrong place has been known to occasionaly lead programmers astray. This seems to be a case where the hard problem is writing code that reflects the underlying mathematics has been foresaken for benchmarking implementations that don't. Recommendations The code might be improved by acknowledging the problem domain. For example rather than . It might be improved by testing for mathematically sound arguments that it does not handle for example: 

Final Thoughts Shorter is so long as it does not come at the cost of power. Writing one's own version of a function provides an opportunity to make a pneumatic tire along with the risk of reinventing the wheel. 

is a typical way to handle long lists for improved readability. The style guide also favors over and it's related forms. The advantages beyond readability include not having to debug against the differences between . Proximity Explicitly naming is good. Limiting the scope of symbols lexically can avoid subtle bugs. The first definition in the code is it is not used until the last definition and it is only used there. Nesting the definitions is probably appropriate here. It might also have made my confusion in Naming 2. less likely. 

The game "Rock Paper Scissors" can be specified in terms of states. Specification The game is played by two players, and . Each player selects from among a set of three options . is used to represent the state before a player has chosen. Using an ordered pair creates the possible game states: 

The infinite capacity of the third jug allows it to represent a sink into which the contents of the other jugs may be emptied. The infinite contents allows the third jug to represent a faucet for filling other jugs. The problem Ordersky presents is none of these. It is a generalized case based on a Python example from Peter Norvig's Design of Computer Programs course at Udacity. The problem Odersky is solving has an arbitrary number of jugs with finite capacity plus one jug with infinite capacity and contents. I would like to dub this the "n+1 Jugs Problem" because captures the sink/faucet and hints at the notion of [at least in my little world]. Readability A joke: I married my wife despite her adamant unwillingness to change her name. What's the big deal about being called "Donna" to match my tattoo? Rich Hickey invented Clojure to help working programmers write good programs, not to give the world another excuse for tribal tattoos. I don't think or inside a function are big deals. They're very Pythonic and they couldn't make the code less readable for idiots like me. Chiapas I found the code opaque. "What is ?" I asked myself. I could look at the code for hours and never really figure it out. It took a half hour of concerted effort involving Google and watching a video of Martin Odersky...twice before I came up with a good answer: is a vector of integers. In Ordersky's code this is explicit at line 6: