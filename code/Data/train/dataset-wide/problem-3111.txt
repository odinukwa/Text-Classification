The mash-up you continue to have with Objects and primitives is something that is easy to resolve, yet you don't. Is there some reason I am missing why it is important to convert your data to an Integer Object before converting it back to an int? 

OK, so we have a method, that takes your arguments, and returns a function that filters a CSV record if the right field is matching an argument. Now, our main method can have: 

This is generally nicely presented code, and it is good to read. Your suspicions that the code is not as efficient as it could be, is correct. There's some simple things to fix, and some harder ones. First though, the sieve: Sieve A sieve of Eratosthenes is best implemented as an actual array. Your code uses a list as a type of queue. Let's look at this code here: 

Now, I am not suggesting this is easy, but, it works, and it will work fast. When splitting the original sentence, it is possible for there to be some leading space, punctuation, or other junk. This may lead to having an initial empty string in the word-split, so we need to ignore empty words. Putting this together, you get: 

Your question implies that you have a sieve of Erastosthenes, but you do not. The sieve works from known-primes forward to a value with a given magnitude. In other words, you start with a known prime (2), and then you eliminate all the multiples of 2 until you get to the end-point of the sieve. Then, you move forward from that known prime, to the next prime (which is the next number in your sieve that is prime). You then eliminate all multiples of that next prime too. This ends up looking like a 2-stage process with a setup stage, and a double-loop stage. Your code has a setup stage that is not used, and then has a three-loop structure that does things back-to-front. The setup stage creates the sieve, which is a fixed size, that needs to 'cover' the 'nth' prime, wherever that may be. You may have to cover more than the exact value, which is why the formula looks handy, but you should investigate this Wikipedia article about the approximate value of the Nth prime So, once you have a large enough 'sieve', you then loop through it as follows: 

There are a number of common tricks to solving this problem. The most logical one in Java 8 would be to use a LocalDate instance.... 

Note, the recursion is clear, the decision making in the recursion is clear. There are no Function instances, no Eithers ... either, etc. The problem is conceptually simple, but all I see is over abstraction. What is unclear is whether it was you who introduced it, or the interviewers. 

The service should be final, make it immutable. The service is created outside the class, but then shut down inside the class. This is asymmetrical. If the service is created outside then it should be shut-down outside. The class should be instead of having the method. 

The UNION condition is also very buried in there, and it has too much indentation ;-) Finally, white-space is cheap in SQL, I really don't like the space-less expressions, spacing them is easy . Right, that's the nit-picky stuff done. Talking about the UNION, the statement could be rewritten as: 

Often in larger projects this type of handling becomes quite regular, and it is common to centralize some of these validation processes in to a 'Utility' class that is reused. This is especially true with unit-testing, and I commonly see something like: 

This will also save some interesting and embarrassing bugs like when someone calls your from method with: 

Is it an ugly practice? No, not by itself. Method chaining like that is even expected in some circumstances - Java streams come to mind. Your code is pretty clear, and the only changes I would suggest are: 

There are a number of items which concern me in your code. First up, when I pull your code in to eclipse, it immediately gives me lots of warnings.... which are easy to fix, but make the code cumbersome. Also there's a couple of other items: 

Your code is inverted. The code I am seeing here would appear to belong in the class that you have referenced as , whatever that class is, is likely where this code belongs. You should mark all those variables/fields as private, and discover what you need to do in order to put the code where it belongs. The following should all be private fields: 

Your code is neat, functional, and I really like that you keep everything in the primitive domain (i.e. you use instead of ). When dealing with primitives in Java it is almost always faster, and more logical to keep the two domains separate - especially if/when the values are used in calculations. So, your goal of appending additional values to an array, and returning a new array with the combined contents, is good. While using seems logical (it's what a calls it) I would recommend you use the name because on a could have different meanings. As for your implementation, it's correct, and I understand it just fine. In more recent Java versions, it's better to use the methods though, instead of the routines. This is because the versions are more type safe, and have better in-code semantics. So, your code would be (though you cannot avoid the one call): 

You should have better handling for what you do with the buttons as well, but these three changes will go a long way to making your code more readable. 

Context I have a node.js application that uses many other modules and libraries. Some of these modules pull details from process environment variables, such as URL's for databases, credentials, and so on. In particular, because this node app is running in Bluemix, there's a large JSON variable called VCAP_SERVICES that contains all the connection information the app may need (users/passwords, names, conditions, and target URL's). When the application is running in the "real" Bluemix environment, it will have these variables set. But, when the application is running in development, or debug mode it is convenient to set these variables in a more friendly way other than specifying multiple complicated, large variables. To solve this problem, I have created a script which looks in a specific folder for files with a specific extension . If a file is found with that extension, the environment variable with that file's name is inspected. If the variable is set, it is left alone. If the variable is not set, it is set to have the value of the file's contents. This has to happen synchronously because this work has to complete before other modules have loaded. To help things along, and to simplify the code management process, I have put this all in to a sub-folder, and created a .gitignore file that ignores all files with the extension . This prevents any passwords or other tokens from being committed to the source code repository. Here's an example context of how the code would be used: 

Your two print methods are odd in the sense that they are inconsistent with how you present them. A 'classic' matrix consists of primitive arrays (like ), and not nested containers (like ). I can understand why you have one and also the other, but the mix of them is bizarre, . Remove the second print method. Let's go through some other items first though. Let's narrow the ArrayList down to the interface level, just . There is no reason to constrain the method to the concrete implementation because that severely restricts the applicability. I would actually go further and constrain it to . This produces the signature: 

This will be just as fast, but the code is easier to read. If the one place where you declare the dashes is still unsightly, then you can compute the value using the other mechanisms shown in other answers... e.g. : 

the second stage involves processing the KEY_FRAME records, and identifying where the Second_Packet records are. From the map, order the requests to happen in byte-position order from the stream. Here we scan the file again, in order of the Second_Packet byte positions and the KEY_FRAME instances they belong to. 

Now, what is the sum of the values in the rectangle? We know that, because we have our grid right now which looks like: 

You have an interesting problem to solve. Your solution would be helped a lot with a small extension to the class. Consider the following version of it: 

If all those values are int values (and I suspect they are), then the use of Math.floor is completely unnecessary. The pixelX and pixelY values are always required to be positive, and this in turn implies that all the int values above will be positive. Again, this is important, because it means that and simple integer truncation will both produce the same result (which they do for all positive int values). So, taking one of the above lines: 

This way you can move things around a bit more, and you are guaranteed that a later refactor of the code won't mess things up. You have special cases for and . I would change the code: 

If your collector is used on a concurrent stream, there is no way for you to determine the order of the combination function calls: 

It's really nice to see code like this up for review. I have had to do some reading up on what the Monte Carlo tree search actually is, but I have enough of an idea now that I can see where you have applied the various concepts to your code. First up, at first, I really like the API you have managed to present. The use case is particularly neat. After digging in to it, though, I started seeing holes.... Generics As I say, at first glance, the generics appeared good, but then I actually pulled your code, and realized there are a number of problems. The most obvious place is that I failed to compile your factory method: 

Note, using named variables instead of constants makes it clearer what you are doing. See this running on ideone: $URL$ 

Having said that, if these issues are OK to live with, there are still a number of technical issues with your implementation.... Hygiene The following thoughts are what I have based on your current implementation. Things I would fix even if I did not change the way the code works. Your initialization of your class is inconsistent and overly verbose. Here's the relevant code: 

Where the method is the method you currently have as . The reason for doing the in the calling method is for memory efficiency. At some point you will need to do the final merge, which will require the entire data array to fit in to a memory 'copy', the . You will also do many more smaller merge sorts requiring a smaller size of memory. If you are going to need the large space anyway, you may as well create it in the beginning, and reuse it many times, which is better than creating many small which never get reused. 

logs will be consistent Exceptions will have more meaningful messages Programmer's expectations are clearly shown 

Looking at your first code example, it's somewhat sensible. The method creates a "happens before" memory barrier, and as a result, all threads see the same version of the data at that point in the code. There is a vulnerability in that code, though. The method means that your lock is publicly accessible. Anyone can synchronize on your wrapper, and create a conflicting lock, perhaps creating a "denial of service" situation, where you can never get in to your method because some other thread has your instance locked. This is rare, but it does happen in some programs. About your second block of code.... this is just plain broken from a multi-threaded perspective: 

How about the simple process of converting the chars to separate strings, sorting the Strings, then copying the results back to an array? It would look something like: 

Code Style You should declare variables where they are used. blocks sometimes mess things up, but in this case, they do not. The following code: 

For beginner code, this is quite good. I am impressed. Good enough for me to assume you have worked from some example code. That is not a criticism, everyone does that (me too). Still, many examples are based on other examples, and they have some issues that are 'historical' in nature, and then there are some practices in Java which make sense which are not visible in your code. Style Really, it's good, no big problems. There is an extra empty-line in the middle of your if/else/else statement which is inconsistent. If I were to be extremely nit-picky, I would say that I personally would not put the empty line after the return statement (but like you I also would put one before the statement). Order of comparison.... I am not sure why I dislike this one, and I have no reference for it, but, you have the line: 

Without that, you risk getting an exception in your method. Your modulo computation is also wrong. I presume you want to allow any 5-digit pin, but doing will return the values through , and never . Your modulo should be . Finally, you should be using , and not . If your resulting number is 5, you want the pin to be , and not . With your code the way it is, you will be getting a random skew in the sense that you will bever get results with leading zero's, and you will be getting an increased frequency of pins with trailing zeros.