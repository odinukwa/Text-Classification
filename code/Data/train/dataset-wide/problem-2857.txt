I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 3): $URL$ I'm doing the 2nd part of Day 3. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 3 (part 1) in Functional Programming (FP) 

Is there a better way to write it in FP (without any libraries and with vanilla JS only)? Also any improvement suggestions are welcomed! 

I got 2 while loops that are nearly identical. Is there a way to refactor them? I tried to refactor them into one function. But that function takes and returns 4 parameters: 

Is it possible to solve this problem yet still be consistent with fp, i.e. no mutations and no loops? And of course: Any other improvement suggestions are welcomed. 

What is ? What is ? Inconsistencies You have bits of code where your and have a space before them when calling a function or indexer. Personally, I find this very confusing, I've never seen this done (Let me know if there's a reason for this, I'm curious). If there is no reason, I would suggest not having a space before them. Examples below. 

Psst...You have a typo: should be . Consider making a list/array of the texts you use for dialog so that it's easier to see the text as a whole, then loop through each one adding it as you loop (see below). Then you could do something like this: 

is an object containing our bindings. We haven't created that yet, so we should probably get to it. We create it by binding elements as its properties. Binding an Element 

Running this code with in normal mode will create a . I had to "cheat" by running this code in : (node 6 supports Tail Cail Optimization (TCO) when the flag is turned on). I also tried to cache the but this didn't help either. I got the feeling that big size Input is the limit for FP. 

I'm doing the 2nd part of Day 5. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP) First my procedural solution: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 6). You can only access the 2nd part if you type in the solution for the 1st part: or look at my solution for part 1. 

In debug build, the insertion sort will trigger some asserts because can go off the end of the base vector. I just used instead of insertion sort. My above code suggestion doesn't make any difference. Either the compiler or the CPU must already be avoiding the extra fetching I was trying to get rid of. It did make a difference to avoid the calls in . Apparently they cause a reallocation of the vectors. Instead of using a sentinel, I added bounds checking to the merge loop. I guess an alternative would be to use to make the vectors big enough before the copy and append. I also tried parallelizing merge to see if it really was an issue doing it serially. I could only see to split the work into two parts (not recursively) by merging n/2 elements from the beginning and n-n/2 elements from the end in parallel. That didn't make any difference in total timing values, which further supports memory access being the bottleneck (though an error on my part is quite likely). 

First I wanted to solve this using recursion. But I reached the stack size pretty quickly. Therefore I opted for generators. But I'm not satisfied with my solution especially because of the generator: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 2): $URL$ I'm doing the 2nd part of Day 2. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code Day 2 (1) in Functional programming (FP) 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the 4th problem from project euler: 

The FP solution is longer and slower. I couldn't solve it without recursion. After a while you hit the stack size. Thanks to Thanks to @Blindman67 he suggested a workaround with . Do you know an FP approach that is faster and shorter than the procedural one? 

Inconsistency I noticed that in the first part of your program you use a statement for handling but then in the you used an if-statement. The switch statement is a nice use in this case since you're comparing the same variable and you could end up adding more values later. var You can use the keyword instead of typing the variables type twice (e.g. can become . This is mostly preference, but you can imagine how convenient this will be. It has no effect on performance, the compiler is just deducing the type at compile-time. Conclusion That's all the nit-picking I could manage, haha. Overall, your code looks pretty good, especially for a beginner! 

This binds the email input with an id of email to a function that returns whether the email element is valid or in this specific example returns true if it is not empty. Defining it as a function parameter means that you can have different validity requirements for each element that you bind and the logic for each function is not clumped into one hard to read function. Events The last part of the program is the events. We obviously need things to happen at certain times. Firstly we need to update the consent checkbox and refresh the validity of our form elements. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the a problem from project euler: 

The code above has got more operation than in the first part of this riddle. But it's way faster and shorter than the functional approach of the 1st problem (Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP)). My FP solution: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code. $URL$ 

As you can see, it is not consistent with the idea of FP. First I wanted to write it using recursion but I hit the stack limit. Therefore I used generators (and loops). That was the only solution I could come up with that resembles FP. Any suggestions how to write in FP without any additional FP-Library (i.e. in pure JS only) is much appreciated. 

Profiling is always good to locate bottlenecks. If quadtree construction is a bottleneck, it might help to use multiple passes. A first pass might only store the x/y values which are all that is needed to determine the structure of the quadtree. For a second pass, the buckets can be pre-allocated to the correct size (most less than ) and each point goes directly to the right bucket. For the resulting quadtree, do you really need to store the point values (multiple times, at that)? Maybe just the summary info is enough (min/max z, min/max intensity). Or if you need the points only rarely, store an index to each point and do a more expensive look-up to find the point specifics when needed. Lastly, if your coordinates are used at display resolution, you can store them with floats instead of doubles. 

Do didn't ask about performance, but you can speed up for sparse bitmaps by first looking at a byte at a time. If looking for a 1, you can skip bytes that are 0x00, and if looking for a 0, you can skip bytes that are 0xFF. After that, you can scan the bits on the next byte or use a look-up table on it. As far as the API goes, you might add 

All this does is make it to where you have to type less, there will be some cases where you won't want to do this. I feel like the best way to know is experience :) Doing something like this might make your code a bit more concise (and therefore readable) since you don't have to create a new ServiceResponse multiple times a function as you are doing now, which is multiple lines of code. Hope these tips help or give you some of your own ideas! 

Is this used for anything? Repetitive Code You have a few places where you repeat code. Typically programmer's aim for minimal repetition. For more information read up on the principal (stands for "Don't repeat yourself"). This: 

Naming. Names should do more than be a unique identifier, they should tell you the purpose of the function/variable. 

I'd also have take its size as a bit count instead of a byte count. Then if the client only cares about, say, 26 bits for letters, they don't have to worry about a search returning 27 because the bitmap really have 32 bits in it. 

Maybe you're at a memory bandwidth limit. I've done similar experiments with Java threads on an 8 core machine (2 quad core Xeons). Non-memory tasks scaled very well, but memory intensive tasks did not. Try something more computation just to see if memory is a limiting factor for you, too. Or, in the same spirit, try to make your code less memory intensive by using a higher optimization level or hand-optimizing. For instance, the inner merge loop appears to do three memory reads each iteration when it could do one (plus one write). 

so the client doesn't have to worry about how many bytes to allocate. And/or provide a macro to help with allocations. A macro instead of a function if you want it to appear in array allocations. 

This way on first use it'll cache the list and then from there on out you will have the list already loaded. This way if you were to ever change what is white-listed or want to use this in another project it's already setup to be re-configured. Pointless variables In many locations you have something like this: where you don't actually need the variable. The places validTag and tag are used are as follows: 

The name tells me absolutely nothing about why it is taking an object and what it is doing. Yes, it tells me it is doing something with time, but what? Try narrowing your names to something more specific (Yes, this can be very difficult at times, but 2+ weeks from now if you look at this code again it will be worth it). A suitable replacement for might be perhaps? I don't claim to be the best at naming; the point is to describe your functions/variables as best as possible. If you're using generic names and the code isn't generic, you should look for a better name.