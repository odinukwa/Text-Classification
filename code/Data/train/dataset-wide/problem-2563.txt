This method should be a static one because it doesn't require any instance data to work and much less protected. Are you really going to override it? 

Your doesn't have to be . You are not using any resources and clearing a dictionary isn't doing anything useful. 

In my library for styling the I need to be able to add or update two styles: and . The use case is very simple. There is a string with styles that I'm building and that I update to change the color if necessary. I divided this task into three steps: 

I'm afraid a builder such as this is a dangerous thing. Field and property names are case sensitive. Changing their casing like the below extension could result in setting the wrong field or in case of different names not setting it at all. There is no guarantee that the backing field has a similar name as the property. 

This is not very professional. You do however consistently use confusing names in all parts of the code: 

This is where you actually use the method as an event handler. But its name doesn't match the event. The correct name should be . So going this path you should now have this: 

You can simplify this and make it easier to use by using strong tuples with named properties. All you need is to throw away the type and let the compiler derive the tuple for you. 

There are some improvemants possible but they are rather of technical nature then about performance as I don't think you can do much about it until you have measured it either with benchmarks or a profiler. 

This means it should not have any side effects. Properties are expected to be cheap and their purpose is to access data (quickly). If an operation can take some time it should be implemented as a method. On the other hand the property would never return a so it's actually useless too. You could never tell if an object is not-initialized. 

The core part should be a class that can generate spiral coordinates and return them as like this totaly overengineered one. 

If I had one instance of the parser and called in two different threads weird things would happen. You try to hide it by instantiating it via the method but the default constructor isn't private so theoretically it's possible to use it incorrectly. 

This way your printing becomes even cleaner and you can manipulate the header separately. The same applies for other cases. 

It's not necessary to call the method two times. It's better to just check if the result has rows and then get the one and its or otherwise an empty , finally you turn it into an array and you're done: 

I suggest just a tiny little change as there's already been said a lot. For the exact same purpose as your utility method: 

I'm not saying I like this but you could reuse the longest overload for the shorter ones. Here I took the one that takes three parameters. 

You can use some encapsulation if you turn certain parts of your exprssions into LINQ queries. This will allow you to use the keyword to define s. I think with all the helper s it's both easier to maintain and to understand. 

After the parsing the data is stored in a few classes derived from . They mainly provide the valid range for a field. The base class also implements the method that requries a date-time-part that the derived classes need to provide. (In future some of them will additionaly evaluate the cron-expression extensions but I don't need them yet so they are "missing".) 

DRY Don't Repeat Yourself. In the above method you do the same thing twice. Try to merge the conditions and give them a meaningful name rather then putting a long expression into an : 

Where is the ? Don't you like it? You should not use abbreviations unless they are well known like html or xml etc. 

and a null-markup-element that is used only as a builder. I'm not happy with this one but I didn't have any better idea. 

I don't think this parameter has any value and is actually very error prone because the user of this attribute has to know that he can use the and what it means. I'd stick to an automatic message about the value not beeing allowed. 

Does this design have any obvious weaknesses? I've added the beginner tag because I have very little experience with all the stuff. 

With this test however you test that the mock that you created returns a fake process list that you created.... this is pointless as this doesn't test anything useful. You are testing the mock itslef. It would be fine to mock the if you used it as a dependency for something else that requries a list of processe but in this test, there is no such thing. This test has no value. 

This means the base class will get the name of the filter from its type and it'll be able to implicitly cast it into a string by calling . Now everything the derived class needs to do is to implement its own : 

I still need to write a few unit-tests for it but for now I'm satisfied with the result (I'm pretty sure there are still a few cases where the expression-string isn't optimal but I'll implement them when I come across them). In closing a few examples: 

You cannot rely on members as they actaully do not have to follow any conventions. The naming conventions etc. apply only to APIs. What would happen if I had two fields with names that have different casing? The builder would set only the first field: 

The can actually be simplified too by deriving it from a dictionary. By adding the search method to it you can easily use it on any node. I named it . Another adjustment you can make is to use instead of the so you can use one of the construtor overloads of the dictionary and make it case insensitive. This way you won't need the . 

SettingsModel Instead of having a constructor with a parameter I suggest keeping it clear and creating a new property 

The two main filters are the and the . Each of them customizes the patters further to create the final version that either must start with a or be at the end of the string so that I don't have to use for common exclusions like . 

Implementation You could improve the current implementatio to be more functional by using more LINQ. The method could work like this 

All your methods differ only by one parameter and they are all amost identical. You also use the same properties for each control (second parameter). You should create an interface for it