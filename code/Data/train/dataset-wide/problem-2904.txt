And that's it, job done. As I said, this solution may not be applicable in your case - I have no way of knowing. 

By convention, names of methods in Java should start with lower-case (so, and - just like and ). Parameter names shouldn't start with "m". There is a - controversial - naming convention that prefixes class members (or fields) with "m". I personally think it's iffy, but some people do that. This convention at least has some logic behind it though, whereas prefixing a parameter with "m" makes no sense. As of now you can pass any class to this method, which isn't as type safe as it could be. If you made it generic, you could narrow it down to subclasses, making it more typesafe: 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

This being said, it could be overengineering for simple cases. It's hard to say without knowing broader context. All info you've provided is that there's 5 cases, which is quite a few already, and it makes me guess there's a chance for more to come; if all I knew was that there's 2 or 3, I would say keep it simple. 

Looking for an element and finding out that it's NOT present in the collection IS a successful operation. Just because an operation renderered a negative answer doesn't mean it failed. The purpose was to find this answer, and this we did. Encapsulation I don't like that is public. Wouldn't a more restrictive visibility modifier do? Rendundancies As I pointed out before, after a is always redundant. 

It compiles, since á’¿ != 2. But it won't work for every digit - see $URL$ if you want to try. Even if it did, I wouldn't recommend doing this in production code :) All in all it's a fun thought exercise, trying to find a workaround and kind of trick C# into doing something it's designed not to. But the truly elegant way is to embrace the language the way it is, and not try to hammer square pegs into round holes. If you were hell-bent on using extension methods, at the cost of being unable to rule out illegal values in compile-time, here's make take on it - more heavy-weight, but providing type and conversion safety. I did it for the heck of it, I know it's not the perfect solution. It resembles @radarbob's answer in that it puts extension methods to use. Let's define the basics (it can all go into one static class): 

There is some room for improvement in this code. Below I have enlisted comments that I believe your code could benefit from: 

Abusing the use of macros I think there is no good reason for implementing and as macros - such an implementation may result in hard to find bugs as you don't have any type checking. Lack of parameter types also makes it harder to understand what the function is expected to do in case of more complex functions. Also, the names of these functions are misleading as they don't inform in a clear way that you are expecting an input to represent a single digit and any other input is invalid. If you stick to the macro anyway, it's a common convention to use uppercase letters for macro names - most people would expect an ordinary function after seeing lowercase /. Single responsibility principle violation Using catch this way: 

Modern compilers would use copy elision here, so there's no unnecessary copying. BTW it seems to me that this function is necessary for the object to be usable. If I'm right, consider embedding it as a private method and call it from the constructor. If you plan to add some non-classic boards in the future, you can pass an enum to the constructor that would trigger the right init method. As for now, it's easy to forget to call this function after declaring an object - the object should not be in an unitialized state after its constructor is called. It's the job of the contructor to set all the variables, not some outside function's that might be called or not. Don't put so much code in , especially game logic code Ideally, your should contain a couple of lines - that way your code is easier to manage and understand. If you'd divided all this code into functions of meaningful names, it would be easier to figure out what the code does. Also, avoid defining functions in main.cpp. belongs to your game logic and is necessary for the game to be run regardless of the user interface, whereas the main.cpp itself it's going to differ depending on the interface you're going to use in the future. 's place (as well as the code from main()) is inside the namespace. All this code is logically tied together and is required to play a game, so the natural move would be to put it in some game_logic module. What is now inside the function should be delegated to a stand alone function of the name like (ideally after dividing it into smaller helper functions first). Use more descriptive names Function names like don't say much about what this function is supposed to do. It's less of an issue, but I also thinkg should be renamed to - that way it's clearer what they do. Make return const reference It seems that you are using this method only to compare its return value against something, and you never actually copy the return value or modify it, so it's reasonable to eliminate unnecessary copying by making the return value . Format your code with readability in mind This: 

This is nitpicky now, but I would change the order of these assignments. Because If throws an exception, the object will be left in inconsistent state. Again this is a consideration for easier debugging. 

Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

Code style Magic numbers In "DatabaseManager", I would convert "magic numbers" (connection life time being 5 minutes, command timeout set to 120 etc.) into constants. Fluff / noise 

It's simplier. Alternatively you could use a regex pattern and get rid of all the injection chars in one go (with ) rather than one by one. I'm not too fond of the name - it's actually filtering the injection characters out. Personally I'd rename it to - somewhat clearer to me - or perhaps just , which is a widely recognized synonym for this operation. 

Not always. It can also return an error. Exposing crucial request settings as public properties (rather than eg. method or constructor parameters) is questionable too, in my opinion. It doesn't enforce calling code to supply the necessary minimum of information required for the request to succeed. So it's not a particularly friendly API, if I the burden of remembering which properties need to be set is still on me. Your method doesn't even validate it explicitly - eg. if is not set, I'll just get an exception from complaining about the lack of , and you're leaving it up to me to figure out that it translates to the not being set. Same with . Such mutability also introduces an inherent lack of thread safety - what if someone changes one of these properties (from another thread) while is being executed and is half-way through? We don't always need thread safety, but it's one thing not to implement it at all, sort of ignoring the issue altogether, and another: to throw it out of the window by design, for no good reason. Other things being equal, I'd say prefer stateless/immutable objects to stateful/mutable ones. Naming: if the class is named already, there's little point in naming all its properties , , etc. (with curious omission of - why not , then?). It's known as Smurf naming convention anti-pattern.