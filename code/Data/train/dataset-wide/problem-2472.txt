const methods should still return references Your and for non-const return but for const return . Why make the extra copy? You should give back a . should bounds check By convention, should (a) check that the index is within bounds and throw if it's not and (b) return a reference. That's what , , , , etc. all do. 

Generators, not lists Rather than returning a list of Fibonacci numbers, it would be much more useful to simply return an infinite generator of them. That is, them. This way, you don't even need the max: 

Why do you need to walk the whole list to check if your list is empty? That reminds me, you should add . But secondly, you have access to your private data. When is ? When . That's a much faster check. When your is , be very wary of using it. I would try to use it... never. 

This ends up with you checking composite numbers for primality twice! Once in each branch! The second part could have just been . Additionally, explicitly checking for is an anti-pattern. Prefer: 

It's better, but still verbose. I would say... just flip the loop. Instead of looping over the training set one time, and then checking N different things... loop over the set N times, checking one different thing each. That is: 

Check primality for lots of numbers Your original example wanted all primes under 30. The standard metaprogramming mechanism for getting all numbers under 30 is: 

Those are two different kinds of values. If you're just returning "smallest tuple for weight ", then should yield . And your recursive step should just be: 

But if you're already constructing using placement new, we could just allow for arbitrary arguments. It'll let your users do more with what you have: 

This solves all of the problems above. Now, isn't copyable. It is moveable, and that just works correctly. You're also no longer leaking anything from . This also obviates the need for a destructor, so you don't have to provide one. This leaves the camera. You don't it, so it's unclear who actually owns it. If the does not own it, then a raw pointer is of course fine. Although, you have . What do you do with the entities returned from that function? Are they stored somewhere else? If you need shared ownership, then you need to use a (or something similar, like ). If you need shared ownership, it doesn't really matter how much overhead those smart pointers add... Bug In , you will fail to erase all the destroyed entities based on their configuration. Also, you're deleting the wrong ones. Let's say we have two entities, and , the first of which needs to be destroyed: 

but on the other hand doesn't really need to exist anyway. Just let the user pass in where he wants to start. This strikes me as just bloaty. const functions should be , and you're missing . You could also provide a and , which in this case just alias . Additionally, consider providing a different constructor so that I can construct a from a . That's something that makes sense. throwing If you're throwing due to out of range indexing, you should throw . But generally, avoid having throw. This is what you're going to use most often so it's best to make it as simple as possible. If you want to provide a throwing alternative, the typical pattern followed by the standard library is to provide an function that does the bounds checking and then forwards along to . constexpr Everything here can be . Just go overboard. 

Lastly, if you want to follow PEP-8, your function name should really be . And should probably be replaced with some single-letter name (, , , what have you). 

Okay that part is easy. What do we do in the other cases? First, there's not really a special case for if you think about it. There is a special case for 0 though. Did we hit a dead end? Let's quit. 

Stick with One of the things you do is effectively convert s into and . But that's not necessary. Stick with , and then you can ignore those comparisons. I would additionally explicitly default the arguments: 

Even if you want to allow temporarily invalid , namedtuple is the way to go since it makes so many other things easier. For instance, since a is just like a with benefits, you could count your s directly: 

That isn't initializing , only . Which is unfortunate since it's only that needs to be initialized. Avoid this kind of multiple initialization, and simply do: 

Math is cool Assuming the answer will be 6 digits (seems safe), we know it's divisible by 11. We know this because the digits of the number will be \$abccba\$, and the handy rule for checking divisibility by 11 is to sum the even digits and the odd digits and check if the difference is divisible by 11 - and both the even digits (\$b+c+a\$) and the odd digits (\$a+c+b\$) have the same sum. Since we know it's divisible by 11, we know one of the factors must be divisible by 11. Let's pick . This let's us reduce the loop to: 

Code Comments First, that is a thoroughly excessive amount of commenting. I appreciate your zeal in documentation, but you do not need to comment every line. Just a couple comments here and there is thoroughly sufficient. Second, your function should do its job. If you want to time it, that is an external job. Use the library: 

You're never using the second part of that zip. So you're basically making lists for the two s, making lists for the two s, making lists for the outcomes of those things, all to drop most of the information. You can simplify that to just: 

I find that a ton easier to read. The reason I wrote the second filter with is that it naturally lends itself to adding a custom comparator: 

Code looks fine, I have one important issue and some minor comments: Typedefs One of the common uses of policy classes are their typedefs (cf. ). Using hides all of those, since in the delegating case, you hid , and in the deriving case, you inherited privately. So I would suggest at the very least deriving ally from and exposing it as a typedef in both cases: 

That's confusing. The extra typedef adds no value. You could've just written . It's not worth it. Also, you agree, since you don't actually use it anywhere yourself! 

Not what you did with the extra member variable. It's unnecessarily verbose and just looks funny. Redundancy You are keeping track of twice as much information as you need to. You have an edge from 2 to 5 and 5 to 2. If you are just keeping an adjacency list in an undirected graph, you can just keep the upper triangle. Add a helper to put the vertices in the correct order: 

First things first, PEP-8 recommends for variable namings. So definitely , , , etc. Also isn't a great name - what is the number doing there? Perhaps ? Getting all the Inputs will raise when we run out of numbers, and the conversion will raise if the user enters not a float. Rather than having a sentinel value input (what if I want to do ?), just use what the language already provides: 

Template metaprogramming is all about rewriting your program to be functional instead of imperative, and then not worrying about caching since the compiler takes care of that for you. The other important guideline is that the return of a metafunction is a type named . Template metaprogramming is about types - anything that isn't a type is just really annoying to have to deal with, so stay in the type world for as long as possible. So how do we write this functionally? Let's look at the loop - which is the only really interesting part of the code: