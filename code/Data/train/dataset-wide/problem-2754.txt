Be 'topRight'? It makes it easier to understand what you're doing... You're also being inconsistent with your use of member field naming. Triangle has 'm_vertexA' etc, but also has 'edgeA'. Pick a naming style and be consistent. If you're going to prefix with an 'm_' always prefix it. 

Surely the path is the important bit of the check. It should be saying don't create an entry if there is already one for that path, not 'for that path with a given user at a specific time`. The time aspect in particular seems like it will result in the match never being made. Maybe you're handling all of this in the higher level code and filtering log entries based on the time they were created to decide if the application holds a lock or not, however it then relies on all your clocks being in sync which can be an issue. 

@venerik had already covered the majority of the code, however I think it's worth mentioning that checking: 

On the whole, I found your code very easy to read and follow. Your division of work is sensible and easy to understand. There's a couple of things I noticed whilst reading the code: Line length You have a few lines that go over the common target of 79 characters. Most of these are under 100 though, which seems reasonable to me, but you do have one that is over 130 characters. GameMessages In your class, you've got several methods that start by instantiating an instance of . This makes me wonder if it should really be a member variable of the class so that it can be shared between methods. while continue_selection.upper() != 'Y' or continue_selection.upper() != 'N': This line is checking a condition that's always going to be true (you break out of the loop before getting there). I'd consider reworking the loop so that it only contains the retry logic. Something like this: 

Naming Good naming is hard to get right, however it's worth taking the extra time because it makes your code a lot easier to follow. This applies to all elements of your program, albeit classes, methods, variables etc. is a very generic title for a class. What does it really represent, ? You have a similar issue with some of your method names. Looking at your class, it's got three properties 'Sign', 'State' and 'Value'. On their own, they mean nothing to me. It's not really obvious which property might represent the 'X' or 'O'. It could be , it could be . The process of coming up with a good name that encapsulates the responsibility can also help to flag up when an element is responsible for too much. main In your main, you're doing things like setting the title and size on your GUI. This seems like it should really have been done in the GUI constructor. The GUI knows it's a TicTacToe game and is pretty tied to it, why does main have to tell it? Gui or Game You've implemented your entire game within your GUI class. This means that if you were to decide that you wanted to implement a console version / a web version, you'd be starting again. It's generally a good idea to try and break your application into different layers. A good starting split would be to separate the display logic (show the board, let users pick where they want to play, provide a means to feedback the winner), and the game logic (maintain internal board structure, expose methods to make a move, the actual logic that checks for a win). You could then break these layers down further is required (it could make sense for example to have a scoreboard class to keep track of the running scores). Having this separation has several benefits. It means that if you decide to plug in a different front end, you just have to worry about the front end. The mechanics of the game could be reused. It also means that if you want to, you can write untit tests for the logic to validate different scenarios. Winner validation Your winner validation is straight forward and can be called at any time. This isn't bad, however you're probably making more checks than you need to. When you place an individual piece, you only actually need to check rows/columns/diagonals that the piece is on. If you place it in column 1, then it won't have impacted column 3. 

You're not accounting for variations on centuries. Years divisible by 100 aren't leap, unless they're also divisible by 400. 

childtype This gives me a compiler warning because not all paths return a value. In reality, this shouldn't be triggered, since the parent should have a child pointer, however you should make this explicit in the code. There's no need for the else, if you're not the left child, you must be the right, or something is wrong: 

The overwhelming first impression I get from your code is that without the text description above, I wouldn't have a clue what it is you're trying to do. A lot of these types of problems have some kind of prompting which helps, however your code doesn't have that, its only output is after it's finished. The two main improvements I'd suggest are: 

Change Return change is returning the value of the change to be paid. Given the way payment was made, this feels wrong. It feels like it should perhaps be returning the coins that would make up the change. This would be a pain without using control structures, however you could do it by returning a coin at a time and subtracting the coin's value, until the changeDue was 0. Reset Your comment on says: 

C++ Vs C As has been said in the comments, your code reads very much like it's been written in C. You're using C functions like instead of the more C++ and you haven't broken your logic down into classes etc. Commented out Code Commented out code creates noise that distracts from the rest of the code. If you want to have conditional compilation, it's better to build it in to your process. So, instead of: 

IComparable The way you've implemented is confusing and couples its implementation to its expected usage. is supposed to return one of three values, to indicate <,==,> the item being compared to. Currently yours only returns 2 values, it's either the same (0), or it's less than. This is confusing because it means that the result of: 

Synchronisation I think overall, the way you've synchronised between the consumer and producers is fairly tidy, although your variable names could be improved to describe what their function is. is clearly a , but what's it being used for, how is it different from ? For the scenario you've built, having the consumer wait until all of the producers have completed seems to work ok, however in the general case, where producers might take different amounts of time it might make more sense for the consumer to handle information from each producer as it is complete. 

First up, I'd start by wrapping your code in a function. This will help to define what it is your expecting to be passed into your algorithm and what you're expecting back out of it. This in turn will make it easier to reuse the functionality if you decide to ask the user for the note information / read the information from a file instead. I'd also think about the comments you're using. Generally I try to use comments to describe why something is done, not what is done. Programmers can tell what the code does by reading the code, so the why is the missing bit. This also helps to stop the comments from getting out of sync with the code if you refactor. For example, this comment adds no extra context: 

In this scenario, the first ace should be treated as 1 (giving a total of 15), not 11. A better strategy would be to sum all the values (using 1 for ace) and increment the ace variable you aren't using whenever an ace is encountered. After adding all values, you can then add 10 if ace > 0. Player1 and Player2 As far as the global players go, you've imposed unnecessary restrictions on your program by having hard coded player variables like . You've gone to the effort of creating a class for a to hold the cards, adding a class to hold the state would make it easier for you to make changes going forward. For example you could easily add a configurable name to the players, or work from a player collection so that you can have 1-n players instead of always 2. 

However, if you're going to use it, be consistent (your main is defined differently). should work in all cases You're assuming that the file you're reading does't contain any nulls. This may be OK, as you're not opening the file in binary mode, however if you decide to reuse the code for binary files, returning a null terminated buffer without a size field is going to cause issues. Main is leaking I know your main is just a test harness to demonstrate the code, however it's best to always use appropriate memory management. Your function is allocating a buffer using , you should be ing it in your main. By including this in your example it demonstrates that you recognise responsibility for the returned buffer is sitting with the caller. 

I'm pretty sure you have the potential for a race condition if one thread releases the lock and removes it, after another thread has got the lock but not yet locked it. 

I think it's unlikely that interviewers are expecting you to write perfect code up on the white board. The main goals of these tasks is to get an insight into how you go about solving problems, knowledge of the language features and attention to detail. You can demonstrate attention to detail by writing 100% correct code, however you can also demonstrate it in other ways. My starting point is usually to clarify the requirements with the interviewers. You can do this in the context of unit testing to help identify some test cases that you are considering and getting them to clarify what the expected outcomes from those cases would be. These can be added to the board so that you have a reference. So, for example: 

Locking? The locking you're implementing is cooperative locking. All parties within the system need to comply with the locking process in order for it to work. With networked file systems this is often not going to be the case, you may be competing against various other applications accessing the files (explorer, cron jobs, shells etc), although you could manage this at an operational level. With that in mind, whilst your locking code can be used to drive your menus to help prevent the user getting into trouble, I'd suggest that the code that actually performs operations needs to be aware that it might not really have exclusive access and be ready to handle errors appropriately. Paths It feels like you're assuming all clients access a given folder/file using the same path. Again, you may be handling this at an operational level however it's worth asking if your system will work if two users map the same network folder to different drives, or if there are nested network shares and two different users access the folder from different share levels. i.e. These shares exist: 

I'm not sure I really buy into this as an idea. I can see it being useful where you want to do things like collect validation errors, but I'm not sure I'd want it to be responsible for swallowing exceptions and putting them into a list. Also, in your method you're doing this: 

This is ok as a start, however it's possible that the player could end up with 5 aces etc. Is that really what you want? With a pack of cards, there are many cards that have a value of ten (10,Jack,Queen,King) yet your current random approach thinks all card values are as likely. In reality, the chances of you getting each card decrease as cards of that value are removed from the deck. Consider adding a deck class that you initialise with 1 or more packs of shuffled cards when constructed then remove from the deck as each card is drawn. This would make your draws more realistic and allow you to reuse the deck class in any future card games you may construct (such as poker). Duplicated Code - Player Vs Dealer Dealers and players are almost the same. You're performing the same calculations in that you are performing in . This could be generalised if you were for example to add the concept of a Player (dealers are players to, they're just automated) to your class. You could do something as simple as this: 

Since gate_Leave returns an int and is often (always?) used to return values this is probably costing you extra instructions (although it might not as the function is inline, depending on how clever your compiler is). Indentation and Labels Labels are quite important in assembly. I'd consider adding indentation so that they are easier to find, a lot like you would indent the contents of a loop. 

Naming/Function Prototypes If you're going to go to the effort to declaring your function prototypes, it's worth adding parameter names so that it's clearer what the expectations are. Looking at the following prototype, do you really have any idea what it does? The only hint is the pretty nondescript name of the method . 

Using a class member in your classes is overkill and will result in an unnecessary performance hit. The way that you have constructed the classes, you only use the variable from a single thread at a time. The writer thread updates the variable as it is working out the multiples, however the you are joining the thread before you read the value from your main thread. This means that you don't need the protection of . Changing the class member to a normal int has a significant impact on my system (time reduces from 10 seconds down to 3.5 seconds for the partially threaded implementation). This can further be increased by using a local variable for the counting, rather than a class member, then assigning the class member afterwards. This reduces the time on my system further down to less than a second. 

I haven't used it, however all of the documentation seems to suggest that you need explicitly free the memory allocated through: 

A couple of things stand out... Initialise your pointers You don't initialise your thread pointers, which means there's no way for you to tell if they're pointing at valid objects or not: 

One of the calls to is unnecessary (probably the one in connect?). connected_ When a network event causes the socket to be closed, is set back to false. This doesn't happen however if the socket is closed by the client calling the method. So you can't always reuse the same client by calling , followed by . Close should probably reset the flag. exception_event I can't help but wonder if your exception_event method should be doing the cleanup, before calling . 

Exceptions from privates This is probably subjective, but I don't like the way your private method is throwing an exception: private static int median(int[] sample, int start, int end) { if(sample.length < 3) { throw new IllegalArgumentException("arrays of length three or greater"); } If your private throws that exception, it's because something under your classes control (one of it's public methods) has failed to supply the right data. Validation should be performed at the public interface to the class, you shouldn't need to perform it again in your privates. 

What do the variables ,, represent? If was called the comment wouldn't be needed, etc. Language Looping Your first while loop is redundant, and also contains unnecessary checks. After you get input from the user you call . This throws an exception if a valid number isn't input, which escapes the loop and bypasses the if/else statement. If == || This line: 

Look out for duplication If you look at the code above, it's clear that there is some duplication. Fetching a value from the user, checking it for 0, exiting if it is. This strongly suggests that some of the code can be refactored to remove the duplication. Members Vs Locals Looking at your methods, they are all declaring a local variables (with the same name as the class field) and then returning it, at which point it is being assigned to the class field. All of the methods are private and have access to the private fields. If they updated them directly, it would allow the flow of your program to be simplified. Alternately, you could change them to be more generic input methods so are driven by parameters. Putting some of the above together Using some of the above, you might end up with input code that looks more like this: