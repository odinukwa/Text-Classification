Note: You don't have to use exceptions, but RAII does provide you with the flexibility to choose whichever error handling system you want (exceptions, checked errors, etc) while simplifying the cleanup process. 

Writing to a stream is exactly equivalent to writing a , followed by a to a stream. For buffered streams, manual flushing could have a significant cost compared to automatic flushing. If you explicitly would like to flush a buffered stream, then stream so readers of your code know flushing was intended. If you just need a newline, prefer . 

Abide by the Rule of Zero/Three/Five. If you define any of the special member functions (destructor, copy constructor, move constructor, copy assignment, move assignment), then define them all. Scott Myers takes this a step further and recommends you declare them explicitly and explicitly opt into the compiler-generated implementations. 

Ignoring the fact that you allow internal nodes to have shared ownership externally, consider the worst case situation with your implementation: The tree contains \$n\$ elements, ordered, with a breadth of \$1\$ (essentially a linked-list). Everything is fine if you have enough stack space for all these recursive destructor calls. Since your stack depth isn't bounded, you'll need to provide an iterative approach to destroying the tree. Also consider how the copy operations work with smart pointers. is copyable, but the default copy operations simply shares ownership (shallow copy) instead of creating a separately owned object (deep copy). is not copyable. To get the correct behavior for copying a tree, you will need to implement these special members yourself. So you need a user-defined destructor, copy constructor, and copy assignment operator. According to the rule of five, if you need any of the special member functions, you should consider them all and explicitly define them (, , or user-defined). 

Factor out common code into functions. Functions promote reuse and limits the scope for errors (making testing easier). 

The use of feels like unnecessary obfuscation. I'd recommend using two variables with descriptive names (like and ). 

We gain reusable functions, avoid magic numbers (), and can -qualify our immutable objects. Prefer to treat warnings as errors For these small learning programs and new code bases, turn up your warning level and treat warnings as errors. Older code bases should continue to use the same rules that are already being used. You have mismatched sign comparisons for each comparison. Use the C++ Style Declarator Layout 

The amounts that people owe and the amounts people pay are incorrect. The total of all the transactions is $900, so how can C alone owe $900? D owes 1/4 of the $100 breakfast she participated in, not the full $100, and she winds up netting $900 on the deal (as highlighted). When I first reviewed your code, it was unclear how it was solving the problem. When I ran it, the output showed that it wasn't. The key thing I think you're missing is calculating each participant's liability for each transaction. I see that you are grouping by Payer, but what's missing is calculating the liability per participant. Rather than pinpoint the bugs in your code, I figured that demonstrating my approach would give you some food for thought. I invite you to review my approach. I wanted to solve the problem with classes, and respect their autonomy - i.e. avoid manipulating their data from outside, ask them nicely to do things, etc. For the sake of anyone first encountering this post, this is the 4th iteration of my solution. The first two suffered from my own lack of properly reading the problem. One thing that tripped me up initially was the fact that D paid for a cab for B & C, but did not ride in the cab, so should get all their money back instead of paying 1/3 of the fare. Here's the output: 

I have also improved the logic that determines if an Account has a credit or debit balance, and to avoid plunging further into rounding madness, it now ignores balances of +/-$0.01. 

I reviewed your code. I wanted to give you some feedback and share my approach to the problem. Your code relies on some advanced data structures such as Queues and Dictionaries, and I am fond of those things, but in the interest of readability, maintainability, and simplicity, I took a class-based approach, with advanced data structures as required. One of the main principles I follow in object-oriented programing (OOP) is "Let the objects do the work." First let's review the output of your program: 

Each transaction shows the payments to balance itself, then the reconciliation gives us the net payments across all transactions. In this case it combines "A pays B $25" and "B pays A $100", into "B pays A $75". The net payments calculation requires matching transactions by both parties, regardless of side. While my LINQ skills are improving, there may be a more efficient way to do it. I have also added the ability to read the transactions from a file formatted like this: 

If you need to take ownership of a pointer, use /. C++14 adds , but you can use it C++11. Note - Don't add make_unique to like shown in the linked answer. DRY (don't repeat yourself) up your and . The two statement bodies for each function essentially does the same work. In , you trade away a pointer copy for a branch. 

Avoid in library files. The C++ standard requires static construction of the standard streams (, , , and the wide versions). If you want to allow functions to be streamable, consider and reference streams through parameters. This also means you should removing the debugging prints that litter your code. Consider using a logger that can be enabled at compile time with a switch or learn to use a debugger. 

Also wasn't sure if the missing space before the was intended. Utilize extensions/tools (Clang-Format, Astyle, etc) to maintain the style layout. 

Don't state in comments what can be clearly stated through code. When programming, the code states what is being done. If you need to provide/document any reasoning regarding your intent, use comments then. Write functions. Lots of functions. You've already split your program into single logical operations via comments. Break up that monolithic into parameterized functions. 

If your return type is an , will Ackermann values overflow if \$m < 4\$ and \$n = 13\$? Are there Ackermann values that don't overflow when \$m = 4\$ or \$m = 5\$? Consider what actually is computable and throw an overflow exception for values that are not computable. 

doesn't feel right as the function name. I would not expect a percentage being returned from that function. Maybe a count? Perhaps a collection of the individual even digits? Don't use after . 

You can write a non-owning read-only adaptor. The underlying container is a protected data member of the Standard Library container adaptors. 

C++11 introduced move semantics, so we have 2 more ways of adding elements to the collection. Tackle these as a next step. 

When class data members are initialized with constants, prefer in-class initializers instead of member initialization. In-class initializers make it explicit that the same value is expected to be used in all constructors, avoids repetition, avoids maintenance problems, and leads to the shortest and most efficient code.