(You haven't updated the question based on Peter's answer, so I can't really comment on , and will primarily focus on the rest.) First of all, your function names are misleading: should draw a triangle, while yours draws a certain number of triangles. I suggest pulling the triangle-drawing logic into a separate function called and then renaming the current to . You might even be able to make a function which takes a function for drawing one shape -- I haven't looked too closely, but it seems like this could work: 

You instead could use a list, but then the indices would start at 0, which I don't think you want. Thirdly, although your functions are all short and fairly self-documenting, I would suggest adding docstrings to your functions, as well as comments whenever you feel like you have to make an important decision. Even if you don't expect the code to be read by anyone at all, spotting similarities may be simpler in text than in code. You may also want to name your constants -- the aforementioned 100 is a good example, as well as the point you use in (why did you choose that point?). Speaking of which, may be better-named , if I understood the purpose correctly. In general, you may want to have function names start with a verb. 

Can it be better? is there a lib that does this better? I've used Laravel Validation service where you can specify alpha_dash but this is not for validation but rather I need the left over to see if there is a match to the Database Storage for a search. 

I'm currently using a make shift INSERT on DUPLICATE UPDATE function that relies on a DB raw query from eloquent. I'm looking to improve the quality of the code and the speed. Please take a look 

NOTE: function is only valid on model level and does not allow mass insert. Doing will allow to have a inserted as long as fillable is used however it will reject if there is a duplicate key 

Here are some observations noticed: For something to be OOP it needs to be somewhat reusable. As always use SOLID principles to achieve this. Because you are using styling it broke some of the rules. Consider returning outputs such as errors and such to be pure text without styling and let the return handle it. Reason: what happens if you want to log the fail message and shoot it out internally or to a log file. Your sendmail is a jack of all trade: it does the header, store the emails, AND checks for errors - this is procedural (start, middle end) - consider separating it into different functions of class (your original one and then have a separate class to do validations which you send as arguments). Consider using a constructor. You initialize the object with settings and then reuse the function. Another point to add: attributes (or variables from a class that pertains to the class) should never be never accessible to the "main" or elsewhere but to the class itself. Use accessor functions like get/set or magic functions instead. Classes are suppose to be encapsulated so that outside code cannot effected without going through a checker. I'm aware that its easier to just access it directly but you defeat the purpose of OOP in that sense. Lastly, too many if/else renders the code too tight which is why I suggested the validation class - let that be the class to check on the arguments rather than the mailer itself. 

A function makes sense when there's several places that call the same exception-throwing function and they all want to immediately catch and handle a single kind of exception said function may throw. For example, often makes sense as parsing may be common and may have only one failure state (no parse). It makes sense to do 

Unless you have further restrictions on your input, your code cannot be correct. You're assuming there can be tag nesting, so you should be making a parser. As far as I can tell, your grammar is: 

From a design point of view: yes, I'd say this violates the single responsibility principle. You have a method that not only does certain calculations, but also creates a if necessary. If creation has to be modified at any point, then you'll have many places to change that. (Unlikely if it's default-constructed like this, but I doubt it's that simple in practice.) It looks to me like should actually be a member function of . 

It's hard to say whether the solution is proper when there isn't a problem to solve. How a class should be designed depends on how it will be used; a class in isolation is hard to judge. Even if you want to focus on some specific aspect, try to fit it into the context of a larger problem. Back to the code: I suspect should be a function. I don't see why printing a would change it. You probably also meant to pass your constructor a . Finally, are you sure a member function is really what you want -- why not an overload? Moving on to the function specifically, I don't think such a function is meaningful. An overload or a free function sound significantly more sensible to me. More specifically, the usage: 

From a first pass over - all you are doing are if else without any throw or inspection as to what possible errors that the PDO might be tossing out. Thats bad because on production servers - I would assume that you won't be turning on error/warning reporting but will be logging them. Also as @Alex L mentioned - you are missing a IF statement that checks if $pdo == null then throw exception. However its better with a try/catch 

You should pass the body of the mail as an argument and it will do what you need. The body part should have been on the outside and independent of the mailing function. This way if you decide to expand this - you wont need to copy paste a third version 

I will apologize for the lack of formatting and using your code segments as straight example - but as I re-read your code I see my old self a whole lot and I don't consider myself any level near some of the coders here. However one important aspect to improvement is obviously trial and error and a lot of refactoring. So you asked about OOP going from procedural php within a single require I would assume your going into one right way which is using classes - however there is a lot of pitfalls in your code. The first would be that to effectively do OOP you should use SOLID design pattern. First there are plenty of ORM out there that does your PDO wrapper. One thing starters would like to do is to wrap a low level class (the PDO object) into a higher wrapper functional object - its not wrong to do so - but its been done over. In reality what you should do is not offer the user (ie you in this case) a simpler form of accessing data that you need while using the database. The database of your APP can change...what will you then? You will need to write a wrapper class again because your class is tightly coupled with PDO. Lets take a look at the database class 

What inputs (if any) could cause these functions to perform undefined behaviour? Are there enough comments? Is the macro safe to use, and is there any way to let it be used with types other than ? (I used templates in C++, but am at a loss in C.) Would there be a significant advantage to using instead of here? Are the tests sufficient? Are there any cases I missed? Are some unnecessary? 

I don't see how wrapping a single identifier into parentheses is ever going to make things clearer. On the other hand, I also don't see myself immediately understanding how parses for every possible operator , or what will evaluate to. There's also plenty of cases between that, especially when you add operators with (imho) unexpected precedence, like bitwise . All in all, I advise to allow your coworkers to decide which form to use where, and to spend code reviews checking code for correctness, not for compliance to formatting standards. 

When there's only one function that calls the function, the added benefit is significantly less; we end up obscuring what exception is thrown and losing the ability to rethrow if necessary. If this is all insignificant, a try function may be worthwhile; however, I'd use it in reaction to a common pattern, not in anticipation of one. 

I could be wrong (and my answer down voted) but when it comes to routing or submission of forms consider using Behat or a behavior test framework rather than PhpUnit testing. The reason why I'm stating this is because you have sessions, and submission and cause/effect returning that you want to test. Those ARE valid things you want to test but its more user behavior test rather than what PHPUnit is built for which is functional testing. A lot of time when doing unit testing when relying on other classes your able to "mock" or substitute classes that normally function in production to be isolated which is only to initialize a class or a function that you are running a test on. What you are doing instead is testing if the routing mechanism is behaving with set inputs. 

Too many variables - the majority of the time the need to hold onto the DB's credential inside the object is not necessary - it should be part of your configuration of the APP and invoked as such then passed inside to the DB object to initialize the connection - once that is done you don't need this info. If you change information then a new object should be created. Why? because image you do need to connect to two different DB (one for user, one for tracking as an example) - if you store your credential your stuck to this. Also as I can see from your constructor - your not even passing your credentials to it - its fixed from a global stand point. The majority of your class is just a smaller typing of what is already presented ie: query, then bind, then execute. Its a rehash of the system's PDO. Another flaw is your Single() function - it has the command - what happens if your query returns more than one result and you want to iterate it one at a time - you can't re-execute the query to grab the second row. fetch()'s purpose is to go fetch and iterate through the rows one by one. You can argue that you can use resultSet() to grab all then foreach but if you are returning 10K rows you will be in a heap of trouble. Next - lets touch a bit of the tracking class. One flaw is the getInstance. Singleton are bad for maintainability because you can't make more than one object of it and its hard to test it. Ideally - since all your functions are relying on the database - you should have passed it (aka injected) is part of your constructor and then call your functions which uses the DB. Its not like you will instantly use a different DB within the function because you are tightly coupled from it. Basically: your Track class is your repository, and your PDO is redundant because its just shorthanding the coding. thats my first pass through of your code. 

First of all, please make sure that your indentation is correct, especially when posting Python code. Also, take a look at PEP 8. You are violating it in at least the following places: 

The code is much longer and the bonus in efficiency isn't going to matter. Granted, with C++11 you could change the into , and then it would be decent, but in C++11 you could also just do: 

In my opinion, you should get into the habit of programs working on files, not on user input; you'll find that programs are much easier to chain that way. Possible further improvements are handling the (catching it and printing something like "No even numbers entered."), splitting the repeating functionality into a function (questionable use), and maybe adding a function that would be something along the lines of 

Well, first of all, you should put code in an block to make sure it doesn't run whenever the file is imported. Thus, just copy pasting: 

If this looks confusing, don't worry about it; it's most important that you get the basics down (like using ), and iterating is just a nice option that you can keep in mind for when it's more efficient/clearer.