This header i believe is pretty straight forward to understand. You find three important parts in it. 

The Dissamble function takes the current Opcode pointed by the IP and prints the meta information stored in it including the line number within the code as well as the Name and Value of the operands. 

What you see is the that each instruction if constructed is automatically be stored in the global array you have seen in the header file. This shall insure that every instruction ever instantiated is accessible via this very array just mentioned. This is important later on. An saves 4 kinds of information 

I want present to you my little Virtual Machine. It nothing really sophisticated. It is an stack only virtual machine with the exception for some 'global' variables which i would count as registers but besides that all calculation done by my VM is done on stack. What i planning now is to show the most interesting parts of the project How i implement this VM. Reason why I do not post the complete code directly is you can find it on GitHub where you can clone it and test out locally. I recommend if you really interested download the project, execute and take a look the code and THEN comeback and read the post. It makes it probably easier to understand. It's not that i do have a lot of files but to keep the code readable I think that this is the best choice. Let me know if you think otherwise! Also Unfortunately i am not good writer, not just only because English is my second language... I try my best to correct as much orthographic and grammatical mistakes as possible. 

Using this function is has an improve in performance over your current implementation. 2) Readability You could extract your conditional and use it as a function so your intent would be more clear: 

[1] Try to separate responsibilities. Functions are things that can be (mostly) separated in three parts: Input -> Processing -> Output If you can, you should try to write functions that follow this logic. If one day someone need to change from where the data comes its easy to what needs to be changed and where its is used; [2] Make clear of what type is each variable In JavaScript you don't need to specify the type of each variable so its the job of the programmer figure out what the type is. When you see a variable called , you imagine that this variable hold a list of adults, but that is not the case in your code so you should name it as something like or to make its content obvious. So following my suggestions your code would be something like; 

What is more interesting is now how such an instruction is implemented. I will not show the whole implementation file but instead a small section of it: ByteCode.cpp 

The really interesting part start now with the static function . is called from the VM at beginning of it's life cycle. It does constructed all instruction just by calling the constructor of the class . The function expects just the pointer of the current instance( a class shown later) which is given to an lambda who implements the behaviour of a certain instruction. The lambda which contains the behaviour of the instruction captures s function argument, which is the pointer to the current instance of the . Through this i enable the lambda to access the VM's representation of the stack where all operation happen. You see two s implemented here. NOP and IADD. NOP simply does nothing so the lambda is empty. IADD on the other hand adds to integer variables which are stored on the stack before this instruction is called. if nothing is there, well that would be a problem then. This scheme just repeats for every instruction defined in the enumeration in the header file. VM.h The header contains the nested struct . represent any values possible in the VM. To make life easier anything which is not an Pointer is stored within an double regardless if less bytes are need. Efficiency was not the purpose here. In essence is a tagged union. Because Every Instruction or Opcode is represented by an Byte, ergo is an Value, it can be expressed as an in the "Code Section" of the VM. 

Even without these improvements your code passed all the test cases that i could come up with, so you just need to adjust your style and get deep understanding of the JS api. I can see that you tried to cover all possible cases that is pretty good, you should continue aim for this as much as possible. 

Use better data structures. When you have a problem you should try to find which data structure have more advantages for you, in this case i think that it should be an . Using an array. The bigger advantage of using this approach is that is easier to remove or add new dishes to your menu, and you dont need to specificy the n-th of the dish, you can see that using 'first'/'second' would start to become difficult for a menu with 10 options or so. Instead of: 

The tl;dr version of my code review would be, Try to use the best data structures for your information, and think about how would the maintenance of the code, "how can i make it so its easier to add more features?". After improving this bit your code should be pretty good, keep coding! 

The main programm Here you see the snippet containing an array of Type. This shall be the code executed by the VM. I tried to make the definition of this array more readable by using c-style macros. The project is not yet at the point that i can read from a file and execute the code stored there. Any code must be hard coded right know. 

If the trace is enabled we print the current state of the stack as well as the instruction which causes the current stack. 

I present my implementation of an and . Similar to the implementation of my ArrayView which justs open a window into sequence here a generic implementation of an actual sequence. I have to admit both classes(ArrayView and Stack/HeapArray) look very similar but they are supposed do to a very similar job, so i think that was not avoidable. As always my aim was to avoid any runtime operation as far as possible, so that the compiler can resolve most of the code at compile-time, here in this particular case it is not as easy to follow this policy which lies in the nature of runtime allocation for the implemenation where the can be resolved mostly at compiletime similar to . Both classes have the same interface the only real difference is the way the array is allocated. The allocates the requested array at compile-time as normal c-like array in the form of while handles the the array dynamically via the special overload oif . I am not sure if that is good or bad use of this specialization of but i like the idea quite a lot not to use myself in a direct manner. I could imagine this could be point of critic but maybe not. As usual any criticism are welcome and is much appreciated. You will find an code example at CompilerExplorer The HeapArray: 

Your code look good, but there is some room for improvements. Comment your code Its is a good pratice to comment the behavior that you code should have. There is a good article written by Jeff Atwood called "Code Tells You How, Comments Tell You Why", when you have time you should read it, but the best way that i find to write comments its to write them before the code itself. So if i had to write your code myself my first step would be something like: 

This one below have O(n), but will need to make sure that all model1 and model2 have the same keys, or add some conditionals to make sure that the behavior is correct. 

You code looks pretty neat, i do not think that using recursion would improve it very much, but i have some minor suggestions; 1) Performance-wise improvements The only thing that seems odd at first glance is how you reverse the string to compare ; I had to look it up, but i found that the way that you are doing its the right way using In-built functions, and its pretty much good for almost all cases, but if you want to improve a little the performance you could use something like: 

The member function cpu() is quite interesting and a bit difficult to read. It first checks if the stacktrace is enabled; if so it prints the first line as you can read. Then we enter our interpreting loop; for each instruction contained in our code given to the constructor earlier. this loop runs as long as our instruction pointer is less than the code size, otherwise we would try to access code which does not exist. The first step is to fetch now our first Opcode and increase our IP by one. We than check if the recived opcode is valid and if so proceed. 

The function from the class does what you expect. it stores some kind of Measurement(here time). It's not really well coded and if you interested please look up the code at my repository it is in the same project. The Argument given to calls the lambda of our Opcode/Instruction and Measures how long it takes to execute and stores this information for analysis later. I did this because it seems interesting to me to know just how fast is my Virtual Machine. 

Conditionals Inside the you have the conditionals and , you don't need to check again because its was already checked, the same its true to the block of code of your else statment. Complexity If you are sure that all the keys in model1 is always exist in model2 you don't need to iterate model2 to get its value. Instead of the second forEach if the you can get the value of the in the object without the second loop; This code have O(n^2) complexity: 

So as the array starts with 0, identification for the first dish is 0 as well. Now instead of creatring one event handler for each button we can abstract it to: 

And for free you now can make your events more abstract in a way to avoid repetition: There is one thing in HTML called data-*, its purpose is to hold some information that you need in order to identify the element; We can use it here: 

The hard part its (almost) never writing the code itself but thinking about it, if you have no problems writing these comments you should have no problems writing the code itself. This helps you to make sure that you undertand the problem that you are trying to solve with code, if If you find diffucults in this step you should spend more time thinking about the problem. Iterators You are using but seems that you only need to iterate until the first positive result so you may use , so your function will not need to iterate all the elements, so your function would be something like: