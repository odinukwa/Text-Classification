Uh oh... Global variable declarations. As a rule, you should keep variables in the proper scope. Instead of 

You have this commented out, but the variable hasn't been declared, so I assume there's no use for keeping it. 

Your indentation here is not conventional. You should keep indentation to a limit of 4 spaces, except for when wrapping a line that is too long, in which case an 8 space indentation is recommended. Instead of: 

That's the way to do it. There are no other ways to do what you want to do without using bufferjs, which likely handles things the same way, or less efficiently. Now, there is one optimization you can make here. By adding the parameter of Buffer.concat you can improve efficiency by avoiding an additional loop in the function, which would need to check the new length of the new buffer. 

Ok first of all.. Silverlight Rant. Silverlight was a flop far less successful than Microsoft expected it to be. HTML5 + WebGL, on the other hand, is the future of handling anything that anyone ever thought Silverlight might do. If you want to maintain highly supported, future-proof practices, start doing some WebGL research. It's INCREDIBLE. Silverlight is another one of Microsoft's attempts to avoid standardization and control the web with their own tech. They've failed every single time so far. Lesson: Avoid Microsoft's proprietary stuff when possible. Now, for a Review on Practices.. As far as your code formatting and practices go, I'm happy with what I see. There are a few improvements you can make to make your code a bit simpler: You use all over the place. Try this instead: 

Your factory method takes an existing , but you don't provide a getter or anything for the , which means that you could also provide an ordinary 

Treasure Item The fact that you have a variable named and that your function returns the tells me that you might have other variables, such as or and , etc. If you do, this is a bad idea. You should have a class with the properties , , and (or whatever properties you need). Having a class would allow you to store all the information about a single together. 

Edit: When looking at your code a bit more, with all the method and stuff going on, I wonder if it perhaps should be right from the start, so that you could use 

(To make things easier for you, you can also add your as a muppet and override the method to return a custom string if , this would also remove the need for adding one in , and would greatly simplify adding the items to the adapter) Then I would use the as , so that you can get the selected item like this: 

HTML Your html is flawless (to me) pretty good. Good job. CSS Also completely flawless pretty good!. Well written, efficient, I wouldn't (personally) change a thing. JQuery You made a few formatting errors here. I'll refer you to this awesome JavaScript formatting guide by Douglas Crockford, and walk you through a few mistakes that I noticed ways that you might make your formatting a little more conventional. The blank line here isn't suggested. Blank lines are, for the most part, best used at the bottom of function declarations (if at all). 

That way, you type that selector a little quicker via the variable. I've touched on some simplification. Someone might review this to contribute improvement to the structure, but this is not bad code. +1 for you! 

4... The parentheses of anonymous function literals should have one space of padding on either side. Messy: 

First of all, your code looks great. It brought me to study the internal workings of Node's stream API. The piece that you're concerned with, and rightfully so, is: 

I have a Visual Studio Solution which has a bunch of Projects in it. One of these projects is called "Services" and is basically the junction point between all remaining projects. When I built it originally I made it as generic as possible so I can expand on it. At the time I only had to work with Entity Framework backed implementations of it, but now I've added QuickBooks to the mix as well. It mostly worked out well, but I saw the need to refactor and redesign bits and pieces of it. To that end I've spent most of yesterday doing that and I have new code that takes care of the weirdness I had before, but, I find myself using lots of interfaces and lots of inheritance and I'm not exactly comfortable with it. For example here's my "DbService" implementations: 

This is very similar to my current code and allows me to only inherit from a base class that has the functionality I want. For example, if a can be listed, but doesn't need to be displayed as a select list, then I'll inherit from the fourth . This way I know I can upgrade or downgrade my inheritance as I need to. That being said, it itself has a lot of inheritance between base classes and interfaces. There's six levels of base class inheritance and 12 interfaces. So, this morning I tried to bring it all together a little bit and came up with this: 

The short answer is: Yes, there are ways to improve it! Coding conventions First of all, you are not following some Java coding conventions of indentation and where to put -characters and similar. Error messages "Please try again" is not a message that really describes what went wrong. If I would see that message my first reaction would be to try to enter the exact same value again, which would just give me the same error message. What your code does Your code is essentially divided into two parts. The first part is: 

Let's say that you would want to add a new difficulty to your game. Where would you change your code to do that? 

This is a bit inefficient, as ultimately, once should be enough. To accomplish that, we need to check each item exactly once (or technically, at most once, as it is possible to return false early). Also, to make the method slightly more useful, you can use . Which is easiest, checking if the list does adhere to your requirements or checking if it does not? In my opinion, it is easier to check if one of your requirements fail, which means that we can have the method as the last statement and perform some early returns for if something doesn't match your requirements. What I would end up with is this, which is pretty much straight-forward: 

Now this version obviously reduces the depth of inheritance on the base classes to three and the interfaces to three, but, it forces me in a position where some inheriting services will not be using all of the features so I'd have to use placeholders to fill in some of the parameters and that feels like it will end up dirtier in the long run than the first code sample. Also, I do realize that I'm using lots of generic parameters, but it works for my needs and this not being a publicly exposed API, I'm OK with it. So, my question for you fine folks is, am I being too zealous in trying to reduce the base class and interface inheritances or am I OK to continue as is, which has worked so far (referring to the original code I was refactoring which is very close to the first example)? Visual Studio gives the first example a maintainability index of 86.5% (average), and 82.5% (average) for the second example, so if I follow VS assessment, I should continue with the first example? 

Note that here I actually use , more or less just for the fun of it but mostly for the reason that for this method, it doesn't need to know what kind of we're dealing with. It only needs to be able to know the size of it and remove items. By doing this simple method extraction, we've reduced your original method a bit: 

Overall, I think you are overusing your , or in one way underusing. You are using it to reduce code-duplication, and yet you still have code duplication. Once you put the input for both and into your classes, I would agree with the usage of it more. However, a method for new-line is a bit overkill IMO. I personally would think it is more clear to actually print once or twice when you want an empty line. Other suggestions Instead of what I have done above, you could use a class to store the and let it have the method.