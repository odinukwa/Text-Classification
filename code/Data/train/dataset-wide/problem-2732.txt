Yes, as far as I can tell. The best way to make sure is to run the code and test all parts of it. The way of OOP 

If you did need some event to happen on resolution then using is the better approch. Should your function return a bool? that is up to you. The has access to the state so it can be used to workout the current state. However it is better to return a result via the promise callback (see snippet above, returns false on timeout) Why are you polling? I am having trouble understanding why you need to poll some state. There are many other ways to communicate state changes in JavaScript (TypeScript) without the need for code to run at regular intervals. But without some context it is hard to say which approch would be best. 

For performance use a loop, it has much less overhead as it does not require a new context and heap allocation for each iteration that are required when you use the array iteration methods like . Also replacing the array using requires two copies of the array to exist at the same time, the new array being generated by and the existing array, on top of the heap allocations that requires. So the most efficient way is 

This only gained a slight advantage, ahead of 82%. I then looked to see what code gave the best result, it was almost identical???? Code from leetCode best answer in terms of performance. 

Example I have done a very quick rewrite of your map generator using some patterns you may not be comfortable with. Take it as an example only and use what you want, it is not the only way to do this type of thing. I have provide various links in the code to MDN in regard to JS language features you may not know about. MDN is a good reference for all things browser and worth having a bookmark to. The example generates a map using the same logic you used. The additional calls to and are needed. You can define many worlds each with a different set of terrains and set ups. The example only uses one named Click on the map to regenerate a new one (it uses the old map so not a completely new map) 

The first without the curlys was introduced some time way back and is the dumbest thing to have ever been allowed in any language. We can not remove it from the languages that allow it, too much source already written. But you risk your coding sanity if you feel you do not need { } for single lines. Because if you make a change adding another line and forget the curls, you have a bug that is so hard to find, hours and days will be burnt for no good reason but lazy fingers. Just use the rule, all blocks are delimited with {} even if you don't have to. 

By breaking the problem into smaller parts you reduce the overall complexity and make it easier to read and maintain. 

Review This is a code review so I will point out some style problems first Function expressions V statements There are several ways to ways you can declare a named function. 

You will need to use the and traps to get them. The one you don't see. Also you will not see modification that are indirect. 

Too complex As the other answer pointed out your solution is too complex. The number of bits you test in the function is proportional to the number of off bits in the value. For the value 0 you loop inside a total of 32 (off bits) * 32 (checks) for a total of 1024 iteration. With the mean number of off bits in any random 32bit int being 16 the mean iteration count (bit checks) is 512. The whole thing can be done in an average of 31 iterations per value. Bad testing Also your testing is very poor. The problem is easily scaled to a different number of bits. For 8 bits you can test all 256 combinations and will give you all possible types of patterns you are looking for. The ideal test is against a known working algorithm and check every unique combination. IE you dont have to test 0b1111000 if you have tested 0b111100 Example of a quicker test It only does 8 bits 

This was developed in response to a question on Stack Overflow, Removing comments using regex. What the OP needed was a regular expression to use in C# to remove comnents from lines of a file. All comments were specified as beginning with a double slash and everything after that is ignored. Comments may also begin at the start of a line, resulting in the line being blank. Quotes, double or single, when properly closed, will shield any double slashes from triggering a comment. There was no indication that the target file was a C# source file, only that the processing file was C#. Taking advantage of the C# environment given by the problem enabled the use of conditional matching. These constructs are, to my knowledge, only supported in the and engines, so were acceptable to the OP's use case, but not in many other cases. When used the pattern will return the non-comment portion of the line(s). It will return a newline for lines of code that are either blank, or have a comment beginning in the first column. This keeps the line numbers the same in the original version and the stipped version if the results are written to a new file. Makes comparison easier. The patterns given here are as they need to be seen by the regex engine. I am not a C# programmer, so I don't know all the nuances of escaping quoted strings. Getting the pattern into the code, such that all the backslashes and quotes are seen properly by the regex engine was explicitly left to the OP. The pattern was built and tested under the ignore white-space adn multi-line options, rather than the other way around, so the commented version is the original and the single line version was created from it. The comments were intended to aid the OP in understanding the pattern, so they are rather verbose. In my testing it passed every pathological test I could throw at it, and I believe it is sound. The test file I created is: 

I'm looking to see if there is some optimisation possible, of some trap I've fallen into that will create either a false postive, or miss a match that should be made. Not that my test file includes comments in the style, and they are not stripped by the pattern, nor did I want them to be, as the OP made no mention of doing so. 

construct, but I was more interested in the time spent by the machine (and previously, by me in the chair) than in the CPU time involved. The Script: The code comments should explain what it does, as well as why I did some of it the way I did. 

Another consideration would be hex strings. I haven't looked at them relative to your code, but I know that often I've been less than satisfied with how they have been sorted by other routines and tools. Sorted purely on ASCII value they sort nicely (if case insensitive), but adding the parsing you do, will they remain "natural" or not. Of course, hex string aren't natural, in an of themselves, but some of us computer types think they are/ :) 

I need to run CPU-intensive tasks on a very old machine with overheating issues. The script below will monitor temperature and pause the jobs when it gets too high, continuing them when it's back to normal. The actual commands run are, of course, not included, since they are irrelevant to the question. I am looking for hidden traps I may have set in my code (listed at the bottom), and for other things I have done incorrectly. Aside from special characters in the commands and arguments that are run, which are hand created so I can control that risk, what traps or "got-ya's" have I unknowingly set into the code? What ways are there for making this more error-proof, or better in other ways? For the timing function I know I could have used the 

There is also the school of thought that requires variable declaration to be within the closest possible scope (an unfortunate hang on from the old days of C where scope also implied CPU register usage) 

Recursion, a glorified stack. In Javascript recursive code has a large overhead. Each call creates a new context that is pushed to the heap. You also can never know how deep you are in the call stack, so a recursive function is always at risk of a call stack overflow. Recursion is in reality just a way to implement a stack. Each recursion pushes the current execution state to the stack and create the new one. Each return disposes the current state and pop the previous one of the top of the stack. Many people forget this when writing recursive code, and don't realize that the state stack can many times be more efficiently implemented as a simple stack using a JavaScript array. Another very common mistake in recursive code is the exit condition. Stepping into a function is expensive and should be avoided. Annotated your code to show what I mean 

Timing As you have not supplied a working example there is no way to know if you are overloading the page or not. The important thing to remember is that all browsers have a fixed display rate of 60FPS. Making changes to the DOM at a rate higher than this will only result in shearing and flickering. It can also have a pull down effect on the browser as you block it from doing what it needs to do. You must particularly be careful with events that are driven by the mouse. Some mice can trigger 500+ events a second. You should never update the DOM from move events that can come from the mouse. RequestAnimationFrame When ever you make any regular changes to the DOM use the timer callback via the function . It is designed to present the smoothest possible animations. It is synced to the browsers frame rate, and will not present changes until the display device is not scanning out the pixels. To use 

Use rather than to set just pain text. ES6 offers many features that you could have used to simplify the code. One of which is getters and setters. In the rewrite below I have used setters to change the score, check the answer, and start the countdowns There where many places you could have used ternary expressions rather than if/else statements. 

Repetition, similarities, and redundancies To simplify code you start by looking for repetition and similarities. In most cases you can remove the repeating/similar code by adding variables to take care of the minor differences. Count how often you use a variable name, eg and are defined 5 times, and you have had to type them in 10 times each, and has even more. Variable names also should not have repetition. If you find yourself creating a pile of variables that all share some prefix or postfix, it's a good sign that you can optimize and simplify. Don't do something twice when once is enough. A common practice is 

A need I have always found dynamically creating SVG content and filters a painful and messy process. 

The rewrite As there is missing code this code is untested and thus likely contains bugs due to typos and stupidity (on my part) The compact version because I am pushing this style. 

When ever you are animating anything on the page were you define every frame use it ensures that the animation is in sync with the hardware and any other page rendering. It also prevents updated content from being presented to early or quicker than can actualy be seen. Smooth animation is not about speed, but about being in sync and limiting the amount of work the computer must do.