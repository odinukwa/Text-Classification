However, I think your is not very useful. I don't see any reason for why you need it. You can accomplish the exact same things by using: 

Java 8 If you are not allowed or unable to use Java 8, skip this section :) If you can use Java 8, there's a way to do this very smoothly. It may be a bit advanced if you are new to the Java language, but if you are willing to learn I suggest you check out IntBinaryOperator. Your can be replaced with . Operations can be declared like this: 

Does it really matter if or ? No, it doesn't here. And if then neither of these current ones would be true which does the . So that's a giant bug waiting to happen. So those two first if's should be shortened into: 

EightsCard I consider the method here a code smell. It indicates that there is some design that you can improve. The main reason for this class seems to contain two things: 1. Logic for checking if a card matches another card by suit or rank. 2. Give a score to the card. Put the logic for checking card matches and scoring a card in another class instead. There are some different levels to do this at: 

In addition to this, I also suggest adding to all possible fields in your class. Once your s and s has been created, they shouldn't be recreated again, right? 

Your method is not checking for invalid input. Calling causes incorrect results, without any kind of warning or indication that an error occurred. Throwing an exception is the least you can do! An exception should probably also be thrown if it goes outside the valid range. Also, the string should be converted to uppercase inside the method to also support strings like . 

While you are doing this, try to remember to Tell, don't ask. What this means, simplified, is that you shouldn't do something like this: (sorry for the Java-syntax there, I hope you understand it). I think your current code handles this quite good, just remember to keep it that way :) It is also important that you understand how Objective-C deals with, and how you should deal with, memory management. (Objective-C handles this a bit differently from other languages that I am more used to) The utility methods that you are mentioning, if you are copying those methods to each class that is using them, then you are doing it wrong. Instead put them in one file and use for that file in the other files where you are going to need it. Your indentation of the code is mostly good, but in the end of the method, things seem to go wrong. This seems to continue to the entire method which is indented one step too much. Speaking of the renderTile method, it can be improved quite significantly since there's a strong pattern for cases 1 to 6. It's been a while since I wrote Objective-C code but I think this should work, and if not I hope you get the idea of how it should work: 

That's got to be one pair right? Nope, the code says that is two pair. Again, two pair of both high and low aces. So what is a possible fix for this? In in , pass the results first through the following method: 

Where is a Or, you could utilize the fact that the method of a set actually returns a boolean indicating if the add was successful and use a . 

There is a whole bunch of in your code. More specifically, everything that has to do with specific indexes seems to be unsupported. All this makes me wonder: Should you really implement the interface? In my opinion, you should not. Because essentially, those List-specific methods are not supported. I think you should consider dropping that class entirely and use LinkedHashSet or TreeSet, which I think should be sufficient for you. I think what you are looking for is which is a that preserves the insertion order of elements that are added to it. 

If you don't have anything to do in else, just skip that part. is enough, you don't need else. You'd better remove this, or else... 

As the lock keys are different for different sessions, it is a whole lot more safe to use . That way you are at least sure that the dictionary won't screw up. However, your approach of the map I have some doubts about. What you really seem to want to synchronize is the and calls, so I would place the lock only around those. Speaking of placing the locks, consider placing them within the class. In fact, I would try to move the and methods to the class. If it needs the object to perform its job, then pass the as a parameter to the method. Right now your seems to be only a , make better use of that class. I think you created it for a reason. 

My first thought is: Interesting. The class as it is right now First, some feature-requests or changes you can consider: 

Nitpicks is a bad variable name. or would be better. I am not a big fan of in your original code. is not dependent on at all. They start at the same value, sure, but it's more clear to set Your method lacks an accessibility modifier, you probably want to make it a method. Overall Well done! 

Personally I would recommend other learners to use the pure Android API instead. Writing utility classes like this can be nice for your own learning, but think about if you provide any more functionality or if you in fact take functionality away. 

It's quite easy to make these changes which would make your code much cleaner. Perhaps more importantly: Use a loop in your method (which perhaps should be named btw) to check if all your persons are at the eastmost position. 

Actually, would say even more if you would override the method in . If you are writing these classes to be used as a library by many other people, then it could be good practice to explain that the activity must implement some interface. Otherwise, I don't see the point of it. But either way, there's no need to create an entire class for this. Summary: Get rid of your additional class, just cast your to and don't catch the exception to throw your own. So in the end, all that remains is this one line: 

Note however that now I'm adding parenthesis around the last statement, as I don't like mixing with on the same line. Once again though, consider the readability differences to this line compared to my previous non-one-liner rewrite, or compared to @200_success' answer. 

For the different operations, you should consider using the Strategy Pattern. You can use an enum instead of a byte. 

What you are doing here is that you are doing something that is the responsibility of the activity. But you are handling it inside the fragment. This is a bad practice. If anything, this is what I would have rejected you for. 

As far as I can see, there is no functionality that you would lose out on if you would go this way instead. 

In my opinion it would be better to pass the File to load in to the constructor of this class, for flexibility. Now perhaps you only need to load a specific file, but in the future you might want to support multiple files. Who says that you always want to load ? Sometimes you might want to try different configurations, and instead of making backups of your config file and renaming files like crazy, you could instead load 

This also applies to the method, but there you can simply remove as comparing with true is the same as returning the boolean directly. 

Efficiency The best performance gain I can recommend would be to consider caching the value that is calculated in the first loop, as I have a feeling that value will not change very often (if it will change at all). Choose Treasure Item - skewed randomness Now that you have a class, you can return the directly, instead of returning its key. Also, your is wrong. Imagine that you have the weights which adds up to 9, then you are randomizing a number from 0 to 9 (inclusive), and then iterating and adding to again and comparing with , now let's see the distribution: 

These are clearly related. 1 kilogram = 1000 gram = 1 000 000 milligram = 1 000 000 000 microgram. So instead of using multiple maps for , , etc. Just use one base unit: Gram. 

Now, when this loop finishes, contains all the parents that was not empty. Now you can loop through that using a loop, or use it with or whatever you'd like :) 

Overall it does look like you have improved over time. A little additional improvement I would recommend is to separate the game board and logic more from your Java FX controller class. I would use one file for , containing the array and who's turn it is, then I would use a method that would place a mark at the specified position and return which player made the move (for the button to know what mark to set). This game logic class can be made entirely independent of your JavaFX controller, so that it can be easily used in a Java console application, a Swing application, or another framework. This is an important step and skill in programming, to be able to create re-usable classes. 

Note how many times that 3 is declared? Would be better to extract that to a constant, or even better, a parameter. And with a few other changes to the above (as suggested by @rolfl in chat): 

Here we are specifying logic in by using a "lambda", which is available since Java 8. Now you can create a object and use a loop to find out which book(s) should be recommended. 

There might be even better ways to rewrite this code, if I would know more context about it. I agree that you should not move the logic of inverting to the method. Explanation of the ternary operator: 

Overall I like how you made a lot of your classes immutable. I also like the OOP-ness of your code. I'd say you'd definitely "pass the test". A class just to have a class 

Conventions According to coding conventions, Java class names should start with an uppercase letter. should be . Variable names Whenever you have a comment after declaring a variable, rename the variable to comment itself. 

Currently, this is a not very advanced chat application as you can only have one client. It'll be a 1-1 conversation. It will just be one server and one client talking to each other. You can run the in a loop to allow you to have more clients. The server then needs to loop through all the available clients (so you need some for those) and then send the incoming message to all clients. 

What you actually can do is to refer to . Java keeps the reference to the outer class' within anonymous inner classes and allows you to reference them using 

One major "overthinking" to me is the I personally use that mostly for the Builder pattern. As your class is named , it doesn't sound like a (possible rename?). You mentioned that you have other methods as well, so the main question is: Does it makes much sense to chain them? Or do you only have to call one or two of them and then get the result? If it does not make sense to chain them, which it doesn't by the look of your code in your test: 

Using is better. It is likely that you want to do this comparison in more than one method between two variables of , in which case you don't want to duplicate code. Step 2: 

(I do however agree about @Jeroen's answer about putting the denominator check first) Returning something useful 

Once you have used some of the format flags enough, you will remember them. , and is the most common ones you need to know. Specifying number of digits and stuff are a bit more advanced, but after a while you'll learn that gives you a float formatted to 3 decimals.