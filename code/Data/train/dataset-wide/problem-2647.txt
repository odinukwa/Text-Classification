Another approach, assuming that all the methods return and requires could be to use delegates. Then I believe you could have a whole bunch of static methods in your class and use one utility method: 

I should add though that your code is very readable and understandable, so don't think of this as a "your code is crap" review. Think about this as a "Have you thought about this?" / "What about this way?" review. 

One small improvement, because you are not using return values less than 0, is to as a "special case" to indicate that it is not a valid integer. This would get rid of the variable as a start 

This is because your class is not static. Non-static inner classes can access all properties and methods of their parent class, therefore the compiler warns you that if you use you won't be able to access the from . Making the class static will solve this warning, and will effectively tell the compiler that you're just not interested in the outside class. 

The call to is not the responsibility of the fragment. You are violating 'Tell, don't ask'. Big time. Instead you should read up on Communicating with Other fragments 

Other comments: You should use String resources properly, this will separate the code from the text neatly. Use the resource id's instead. 

Naming The class isn't restricted to only problems that implements the interface, is it? I'm sure you can find a better name. perhaps? 

This however still makes them mutable, which is why an is a good approach. It is not possible to add a member to an enum at runtime. Another approach could be to use 

Besides what mbaker3 wrote, I just have one thing to add (for now at least), I consider it quite important though: 

All these should be marked . In addition, should be marked final and does not need to be initialized there as it gets a new value in the constructor. Your gets a value in the constructor so the value is only used for initializing the . This may lead to potential bugs. Your variable should also be initialized in the constructor, after the value. Your has a horrible name. I can see that it is a string, what is it used for? A better name would be or . 

is not one float value, it's actually three floats. , and . In Java 8 you can use as separator. Android however, doesn't really support Java 8 code yet. 

You are correct about that. Even though I have to say that I do like your idea of a method. I do feel that it is more common to do your first version: (but without using the inner class). 

There is also an "example" directory on my GitHub repo which contains a script that I used a lot while testing, run and it will output something like: 

Is it really necessary to create an object of each tile? In many 2d map-based games, the tiles are not objects, but each tile is only an in a 2d array. I don't know Unity, but I feel that it should be possible to render a 2d map in a better way than creating a for each tile. If possible, I would make your code something more like this: 

I know I could have created a more user-friendly menu and such, instead of switching the commented line or changing file name. This code is not really meant to be user-friendly, but I hope it is programmer-friendly. 

You're doing nine times (because it is inside the loop), as you're doing it inside the loop. Do it outside the loop instead. What you should do: 

According to a PHP blog post, yes this is exactly the way that it should be done. Even w3schools (whom you normally shouldn't trust too much since they're not related to the real w3 at all) recommends it. I like that you are using instead of . I am not so sure if you really need the though. I recommend you read the documentation of the include function (which also applies to require, require_once and include_once) to make sure that you really are aware of how it works. Note that if you are using any PHP scripts inside the included files, any global variables (which you should try avoid using too many of overall) also gets included to the calling script. 

I totally agree with Ocelot20, but wanted to point out some more things and provide some comments of my own about some things that has been already mentioned: About : 

UGH! Considering that usually you don't have the user id and only a user name, you would have to make two joins here to join with the player table. Better would be to have a many to many relationship between game and players. One player can play in many games, and one game can contain many players. The fact that one game only contains two players (at least for now) is irrelevant. Either it is one, or it is many. So create a games_players table for this relationship. It can contain: game_id, player_id, result. can be an integer to support up to any number of players in the future. result = 1 for the winner, result = 2 for second place, result = 8 for the "biggest loser" (no offense if you would end up here) in an 8-player game, etc. Now let's make this query again: 

Using strings in themselves to determine the isn't the biggest problem, but you really don't need to create classes and subclasses and stuff for this. Instead, use an enum! 

It would then be the job for a single utility method (or two) to create a list of files from these parameters: . As for the question about return type... If you need an interface for this or not depends on how you are using these counters. And also: Which possible counters are there? If you have one counter for returning total line count and one for returning a of line counts, then you don't need two different counters. Since you need to know all the line counts in all the files to know the total line count, using a makes perfect sense here. 

This one can be cleaned up significantly. You don't need the here. In fact, you don't need the either. It doesn't matter what kind of iterable it is so you can use . As you're not defining a variable of type anywhere in your method, nor is using that type in another obscure way, all you're really interested in is that it is an . So: 

Even though you store the result as a , you're actually using int division here which makes the result an . To add some accuracy, you have to specify one of the ints as being a double, a simple way to do this is: 

Besides this simplification, I agree with Kinjal's answer. As your variable is local to only that method, there's no reason to use which will modify the index variable, that's why I'm using here instead. 

I honestly think that your code suffers from over-engineering. As you can see in your interface and class, there is a lot of code that is required to use what you are building here. So to be blunt, I have to answer with NO. 

Many of your methods are both returning and modifying the array. This feels strange to me. It can be more preferable to create a copy of the list and sort it in a specific way and return that. 

As for alternatives to using mod, even though it is possible to use two separate counters and decrease them and reset them once they hit zero, I don't think that would improve the code much. Considering that I managed to understand your code and learn a bit of Forth, I'd say that's a compliment to your code. I believe that with some of the changes I've suggested here, it would be much easier for new Forth programmers to understand it. 

Your code is very readable, well-formatted, very clear. Well done. You have implemented hashCode and equals well and all other methods look well-implemented. It's good that you define the only once. Your exceptions are clear and well-implemented. If I have to complain about something, it would be these variable names: 

Use the modulo operator. At the moment you will likely end up doing repeated subtractions from the same number (e.g. 1.6248e42 and 1.234e4) until the other one is smaller. Instead, always change the bigger number into and add to (which I greatly doubt needs to be a , a should suffice. Use or or 

A comment like this is completely overkill. Make your code as self-documenting as possible. The variable name tells you that it is addition. 

There are a few methods I've left up to you to implement, but I hope you get the idea of them. So what is the most important change? The idea is to keep a map of all created reflections, stored with an id, and when you previously created the new reflection, you look them up through the factory (which contains the map). Essentially, this creates what would be called a "Multiton". A class which has a limited amount of instances. (Compared to a "singleton" which only has one instance) 

Arrays and Lists Speaking of I wonder why your constructor takes a instead of an array: . I don't think you gain anything by using a list. The only thing you gain at the moment by using rather than is the possibility for this: 

I don't think this method belongs in your interface. Perhaps in a (which might be a bit overkill). Or in your class. Or somewhere else. This is just my opinion though. 

Brainfuck Multiplication Elaborating a bit more about 200_success' multiplication, and the "shorter, less readable version, using similar ideas, but with more cell reuse": The ASCII values of what you want to write is, as 200_success mentioned: 

Which of these ways you prefer is up to you. The problem is that you have a total of three branches. One for , one for and one for . I don't believe it's possible to simplify this in a better way (I would gladly be proven wrong). 

I would however recommend that you do it the old-fashioned way, so that you better understand what your code is doing. I just wanted to provide this approach so that you know what you have to look forward to :) 

All your test cases contains pretty much the same code, but with different parameters. With the change to a method, the test cases will look more like: 

It looks like your MVC-approach is fine. Your model does not directly know about the view or the controller, which is the most important part. About SOLID, let's see... first of all, do you know what SOLID is? Single Responsibility Principle I don't think and methods belong in your view. You could add a method to your enum. Also, that enum could deserve having a value as well, to avoid using . Additionally, your method is responsible for two very different operations: Clicking the "new game button" and making a move inside the game. I would use two separate ActionListeners for this. If you're using Java 8, I would even use Lambdas. Otherwise, feel free to use anonymous inner classes or anything else. Interface Segregation Principle + Dependency Inversion Principle You're not using any interfaces at all, so this is not SOLID. (I personally think it's a bit overkill to use a whole bunch of interfaces for this simple program though). Other comments You're currently doing: 

A variable named sounds like it's supposed to count the number of items in the entire array. That's not what your variable is doing. A common name for simple iterator variables is (and then for an inner loop). As long as you're not dealing with two-dimensional arrays, using the names and is OK. If you want to elaborate more on the names, you could name them something like and . 

Because if it's not more, and not less, it has to be equal. If you really, really, really, really think that it can happen, throw an Exception 

This is not how you should give two cards to a player. With this code, there is a probability that the player will be given the same two cards. That should not happen. This is why the answer by 200_success is very important, where the cards is first shuffled and then a card given with: 

This is less code and has the same effect. And it also looks better and improves readability as changing strategy now calls only one constructor instead of two. I assume you're compiling with Java 1.6 or above, and therefore your classes that implements the interface should mark the method with to comply with the Java coding conventions. (Marking methods with @Override that overrides interface methods was not supported at all in previous Java versions) 

The biggest problem I see here is that you are printing a warning message to and then using a default value for something which sounds like an Exception. Why allow negative values at all? 

However, simply writing this would be so much simpler, and a whole lot easier to read: (Especially for people who are used to reading HTML) 

EightsPlayer This class contains a copy of the scoring logic previously found in . This class both extends Player and also have its own eightsHand which leads to duplicate data - which one should we use? This class contains both business logic - - and acts as an AI in the method. The logic for handling the situation if a player cannot make a move should be in the class. Only call the method if the player really can make a move. You could have a look at an implementation of Rock Paper Scissors Lizard Spock to get an idea. 

This is a quite easy fix. All you need to do is to extract a method. Both snippets have the same input: Both snippets have the same output: Both snippets can throw the same exception: Put this method somewhere: 

You have put the whole game, all it's screens, all the game functionality, all components, everything! into one single class. This has made it very hard to see which things belongs where. For example, if I look at the method or alone, I have no idea in which part of the game they are used at. If you would have properly divided your code into a class, a , and a entry-class, that would help a lot. (It can probably be divided into even more than that as well). At the moment, your class is just... too large.