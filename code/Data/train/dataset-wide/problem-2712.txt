I also switched to using a named element instead of letting it default to . Alternately, you could pass nothing into the function and use in the as you did. That would work but isn't a best practice. You may not have realized but the was a regular expression with single quotes as the delimiters. I prefer to use curly brackets for regular expressions. If you wanted to be really plain about it, you could have said . 

This version accepts years with three or more digits but rejects two digit years (often abbreviations for four digit years). It throws a general invalid year exception if fails or if the year is non-positive. If the year is between 0 and 100, it assumes that it is abbreviated and asks for more digits. This still catches and rethrows the exception on non-positive years, but it doesn't discard any information in doing so. If you want to reject three digit years as well, you can just increase the boundary from 100 to 1000. However, I'm strongly against rejecting five or more digits, as that essentially puts an expiration date on your code. It may be early, but why introduce an unnecessary Y10K problem? 

You don't need to from at the end of execution. The compiler will handle this for you. Only if you need to do so early. If you do explicitly , then do it as follows: 

What do you plan to do if a class doesn't grade like this? I've had classes where each assignment, test, and quiz had its own weight. Are you just going to make each its own category? Note that you'll have to calculate the percentages prior to entering the data here. Unfortunately, not every professor will return grades in the form of percentages. If I had this as a task, I think that I'd just use a spreadsheet for it. A spreadsheet already has the relevant computing capacity and is very flexible in the face of arbitrary rules. It also supports saving, which this program doesn't. You'll have to enter the categories and such every time you use the program. With a spreadsheet, you'd save and would just need to update as grades arrive. All that said, for learning purposes, I'm going to go over the code that you have. 

By switching to the inequality, you can avoid a class of bugs where you start incrementing by more than one row at a time but don't update your gate condition. The check costs the same either way, so you might as well do the more expansive check. 

That way you don't have to generate all the tiles each time and ignore half of them (on average). Also, if is the empty space, this doesn't bother generating values of since all values of won't be checked. I changed to because I name scalar variables with singular names and collections with plural names. An is a scalar, so I wouldn't give it a plural name. 

Note that I'm writing out rather than abbreviating it as . The fraction of the second that it saves when reading will outweigh the fraction of a second longer that it takes to type it. Not necessarily today, but six months from now, you'll need to spend a moment remembering what means. And of course anyone else who reads it has figure it out immediately. Useful code is read more than it is written, so it makes sense to optimize for the common case. StringBuilder 

This creates a new table that ensures there are no duplicates and then copies all the values from the original table. Then it sets up the primary key so as to continue from the original table. Finally, it renames the tables so that the new table takes the place of the old table. The was taken from your table definition -- modify as necessary. Then you can just continue using the table as normal (after you check the table definition and rows). Note that you need to stop updating the table while doing this. You can sort of make the work by saying (again, 56 is based on the table definition -- adjust as necessary). If new rows are added, you can get them with . But you should stop updates before altering the table indexes and renaming the tables. An advantage of doing things this way is that if the data is wrong after the inserts, you can always drop the table and try again. Your original data is still there, untouched. And you can test it before doing it for real. 

This is bad style. You should always declare class properties before using them so that you can give them the proper scope. This also makes them quicker to access (it checks for declared variables first). 

Also switched to the shorter object-oriented notation. Switched the order of the comparison to because this will throw a compile error if you leave off an where will silently change the value of and evaluate as false. Consistently using this order will therefore make it easier to catch that particular typo. You switch between having the on the same line and on a new line. Either is a valid style, but please pick one and stick with it. My preference is for on the same line, but both are common. Scaling My primary concern with this code is that it won't scale well. You have every user in the chat polling to see if there is new data. For ten users, this will probably work fine. For a thousand users, this seems like it would put considerable load on the database. Not so much from the queries as maintaining a thousand simultaneous database connections for twenty seconds. As a general rule, a callback is better than polling. You can generate the callback only when required whereas polling has to continually check. PHP is probably the wrong language for implementing a callback model though. You could add an additional layer between PHP and the database to fix this. PHP would call your service, which would then only call the database once (or not at all if the service also manages sending a chat message) rather than once per client. In that model, one database connection is sufficient regardless of the number of clients. You'd only need multiple database connections if there were multiple chat channels, and even then they could share. Some languages (e.g. Java) have connection pooling so as to share database resources transparently to the client. PHP seems the wrong language to manage something like this, as it is optimized for HTTP request/reply connections. PHP's not persistent, while this problem space is. This will probably work for a small scale application, but if it grows, you'll likely have to dump the current method and swap it out for something more robust. 

It would be helpful here to explain why is a list of lists. Why not just a single list? Maybe this would be obvious to me if you came up with a more descriptive name. I'm guessing that is short for result. I would have probably named it . 

That way you can see immediately what happens when is empty, and you can see that the rest of the function is about when it isn't. This only works when you to end the , but that's a relatively common pattern. Note that I also moved the single statement onto its own line. This makes it more consistent with the multiline then blocks. Perl Regular Expressions 

If you do it that way, you can pass in the number in the constructor and set it for each object. You don't need a / in this case. A regular would do. If your permutations were in classes, you could give the permutation its own function. Then you could write code that looked like 

The original code did not make these assumptions. It's unclear if that is because they don't hold as it needed the checks for other purposes. Additional context might have made this clearer. An advantage of this version is that it will throw an error if the second assumption does not hold. The original code would just leave things in an inconsistent state. 

But that should be evident from the code. Why do you remove a trailing newline? Will it break the display later? Interfere with parsing? What? Another example: 

The more common name is , which has values like or . This allows you to offer different messages for British and American users. Because this is standard, there will often be easy ways to set it. 

It used to be that there was often register_form.php, register_process.php, and register_success.php, but the more modern way is to do everything with register.php (or even index.php?page=register). The only time that I've seen problems with this is when you redirect after processing the input. Yes, in that case, you may have to store the message(s) in the session and create a module to display them. 

OK, first we have the same problem as before. It looks like 50 has some significance, so we want to make it a constant, say MAX_ITEMS_PER_CATEGORY. However, looking at your code, totalItems is an array showing how many items in a category. That suggests that it should not have MAX_ITEMS_PER_CATEGORY entries. In fact, we should add it to the category struct: 

I'd call this instead to show that it returns a Boolean value. This also makes it read a little better in normal usage. 

First, this introduces a magic number. What's special about ? The answer is that it is one more than . 

What happens if ? Note that if is in an inconsistent state, you can add to indefinitely. The assumption is that you will never increment that far because then would hit and turn off B. What happens if you (or someone else) change that behavior? Will you remember that you have to add additional checks for ? 

That seems like it might be more useful. You accept a parameter if offered. Otherwise, you give it a default value. That may or may not be what you wanted to do. 

And you should be aware that when you specify , you are repeating the query once for each value. So this query would run six times. You may find it easier to run the six queries on the PHP side, as they'll be smaller. This can also help your programming logic. You might want to look up plans, as they should help hint at what your problems are. You might consider posting your SQL and explain plan to Stack Overflow (hint, just add before the and look at the results in an admin tool like phpMySQL). It's possible that the thing to do is to replace your column with a column and a column. Then your join would be on a fast integer join and you could do a straightforward date check. Rather than doing a , you might be better off with a regular inner join. Then look for missing times in PHP. Outer joins (left and right) are much slower than properly indexed inner joins. You may find it easier to look for the missing times in PHP than to have your database do it. I find it questionable to read all the data in and then use it. It's often better to read the data and then use it immediately. 

You can only have one tree in your program because your variable is static across all nodes. This is problematic because you have no way of ensuring that all the nodes will be in a tree. You can create nodes outside the class. If you really want to enforce the one tree policy, you should make the constructor private. You also have a function that can take you out of synch with the actual number of nodes in the tree. That probably isn't needed but should be private if it exists. Unless your tree can only have ten nodes, is a bad name for the variable that matches in and . Something like or would be a more common choice. In , the variable is not needed: 

This is cross-platform and doesn't rely on the OS understanding 0 the same as you do. Note: I hinted at this previously, but I'll say it explicitly now. A class would be a better solution in general. I only skipped it because it's too complicated to explain. The struct solution is inferior but closer to how your existing code worked. Similarly, a std::vector would be a better data structure but is less like your current code. I prioritized critiquing your current code over restructuring it. Another problem that I slid past is that you're doing no validation of your input. If someone enters input that doesn't fit, you should either handle it or abort the program. For example, if is greater than , you will get a runtime error when adding the first extra category.