Use the built in PHP function instead of . It is much safer. Every time you use on the same password, it generates a different string. To compare a password to the password_hash stored in the database you use 

We've used a function we didn't write yet. Writing it will be easier, since we already know how we want to use it and how it should behave. 

Use PDO and prepared statements to connect to your database. It is safer. An example of doing a database query: 

Note that when I use bindValue() on $variable1 and $variable2, the database already knows what the query is, which makes the query invulnerable to SQL injection. 

Store the token inside your users database and cookie/session. (example of a users table in this scenario: username, password_hash, login_token, ...). Whenever you want to check if someone is logged in, compare the login_token from the database with the login_token inside the cookie/session. And when a user logs out, set the login_token in the database and cookie/session to 0. 

Implementing a precise atof function is surprisingly difficult since there is no limit to the number of digits code may need to read to ensure correct rounding. Consider, for example, the following two values: 

In the original PongÂ® brand video game, there were two bats which were confined to move vertically. A collision would be detected if ball circuit was triggered at the same time as one of the bat circuits, and if the ball was not already moving in the proper direction for that bat. The ball's vertical speed would be set to an odd number in the range -15 to +15 based upon the number of scan lines of bat that were displayed before the collision was detected (basically the difference between the ball's Y position and the bat's position). What exact bounce behavior are you looking for in your game? 

I think you started writing the admin class wrong. I'm a beginner at OOP myself, but one of the most usefull tips I've encountered so far is to use your code before you write it. So when you start writing the code, you know how you want to use it instead of writing code and figuring out how to use it later. This might seem silly, but i'll give you an example: You want to check if someone is an admin. If he is an admin, you want his row. If he isn't, you want to do something else. If I would build your index.php and I didn't write the admin class yet, I would create an index.php like this: 

I followed the tutorial Build a PHP MVC Application and have implemented a database connection. I made a seperate database connection class and I call it in the controller. It works, but now I have to inject it whenever I call a method from the user model. Is this considered good (dependency injection) or bad (repeating same variable over and over again seems useless)? I was thinking about moving the db_con method to the user model itself, but then I'd have to include it in every other future model as well, which is repeating code. Perhaps I should inject it in the first controller method: would become ? I don't know anymore. So many possibilities, but where would it fit best? 

But it is still incorrect, because there is another case that the compiler doesn't warn you about: a negative value. Your code will return the entire list instead of an empty list. Consequently, if you use a negative on an infinite list you get an infinite loop: 

The gzip stuff is to work around a bug in Stack Exchange's API server: it always compresses the response even if you don't ask, which is a protocol violation. Using the requests library might make it easier. The way I get the last line of the file isn't the most efficient but it should be good enough. 

But why even use a class at all ? jQuery has .hide() and .show() helper functions, so you can just write: 

However, this does read the file, it even loads it all in RAM at once, which is a waste because you don't actually need to, so do this instead: 

The ideal thing here would be a (or better yet, a variation of a which allowed one to retrieve a reference to the stored item which matched a supplied key). Such a data structure would ensure that strings were shared whenever possible (a behavior which would not only reduce memory requirements, but also expedite comparisons among them, since comparing two distinct million-character strings that happen to be equal will take much longer than comparing two references to the same string). If one uses a , which is the best of the pre-existing classes for the purpose, it may be tricky to ensure that strings get kept as long as they may be useful, without having the dictionary keep them around even after they've become useless (if a string value has been used once before but all references outside the dictionary have been abandoned, having the string remain in the dictionary past the next GC cycle will generally serve no purpose; even if the same sequence of characters gets read again, it would generally be faster to have the old string evaporate and store a new string in the dictionary, than to have to compare all the characters in the new string against the ones in the old string and abandon the new one). 

I find it easier to reason about code that actually does something, so I made it display the sum of the inputted numbers. 

The two classes seem useless to me. only contains a list, so just use a list. Edit: see comment below. The class is unnecessary, this: 

There are variables defined here that aren't actually used in the script, and global variables shouldn't have one-letter names. 

Yes you forgot to cover some cases. Your compiler should be able to detect one of them. Here is what says: 

Firstly, you don't need to store the last date at the beginning of the file since it's already at the end. Secondly, you shouldn't compute today's date twice. Thirdly, you should use Stack Exchange's API instead of trying to extract information from Code Review's home page. It has everything except visitors/day. Fourthly, the date format is better than because it allows string comparison of dates. So, here's what I came up with: 

The most concise storage format which would be easy to work with would be a pair of UInt64 values, one of which would indicate which squares were occupied by white pieces, and one of which would indicate which squares were occupied by black pieces. One could find e.g. the set of white squares that also have white squares to their left by , or the set of black squares that have black squares up and to the right via . While working with bitmasks may be intimidating, it's a very powerful technique since operations can act upon the entire board at once. 

one would then be able to infer that because at least one of the 4's was correct, at most one of the other numbers could be correct. 

IMHO, the best pattern would have been one which Microsoft explicitly discourages: having the the primary logic be in an overload which accepts a parameter indicating what failures should be considered "expected" [the more commonly-used and overloads would chain to that]. If had included an overload with a parameter, then and the normal overload of could simply chain to that. You could then have a overload with a parameter which would get passed to the corresponding overload of . Bingo--no code duplication. Since Microsoft didn't do that, your best bet might be to write your own method which includes a parameter and chains to either or as appropriate. In that case, while the extra layer of wrapping on would be a little annoying, the logic for would only need to be implemented once. Incidentally, while could be a , it might be better to define an enumerated type; the meaning of would be much clearer than .