...as it is much clearer what the intent is. Use quotes not apostrophes To avoid confusion with template string declarations delimited by Back Quote try to avoid using Apostrophes (AKA single quite) Don't duplicate variables The object creates the object and assign the property the value of the argument . This is just a duplication as the only place you use is in the function it is available as the argument Design You are on the correct path to using JavaScript to create private (protected) and public states. Though there is no need to create the objects as you can use the function scope to hold the private state, including functions Simple example of a object with both public and private states, using getters and setters to protect type ( as a ), and access to private state from private and public scopes (eg function 'show') 

You can nest these objects creating additional levels of state security. You can also create several public objects that share a single private state, A rewrite As your code does nothing with its private states there was not much to go by. The Design section above would be more appropriate for what you may be after. The following does the same as your code with considerably less noise. 

AS pointed out by Joseph answer is a perfect, but his answer was a little bloated and can be simplified The is no need for the as it can be coerced with an empty string 

See code for more details. You put it in code of course with instructions as indexes into various arrays. THe best way to explain is in code so take a look at the source of the demo. The flow function walks the leds following the instruction in flows.map1 (map1 - map4) You can add other maps but you must make sure that you do not create an endless path. Or you can add an additional check for each step. If the current then you must be repeating so break and exit. It should not happen so I did not include it, but you may make an error entering data and the page will be blocked. Demo draws grid waits a second then draw flow. Waits 4 seconds and repeats using the next flow directions. Circle marks start of flow and cross the end. 

If you can, use a string rather than an array. Benchmarking If you want to write fast code then it is well worth investing time to learn how to correctly benchmark JS . Bench-marking is one of the most difficult JS coding skills to master. Assuming code is faster based on time complexity is a common performance trap in JS . There is not always a 1 to 1 relation between bench-marked performance, and apparent time complexity. This is because complexity can be hidden in the native code. JS performance is not always intuitive, nor can you assume that optimizations that worked yesterday still work today, or that slower code yesterday is still slower today. Browsers can update daily and updates do not always mean faster (New language features are particularly dynamic in terms of performance between updates) Rewrite Taking in the above performance points the function can be rewritten as 

The rewrite. So with all that said let's put it together, (I can only guess at the overall requirements of the object so the rewrite may not suit additional behavioural and state management needs) The variable cx, cy, and radius dont need to be exposed so we can close over them, the function getPath look like it is only used internally so again I will close over it. 

Using for variables that do not change and a ternary operator for the class selection. The most important part of coding is good and consistent style. Having messy code makes it harder to read and near impossible sometimes to spot subtle syntax bugs. Many IDE's can format the code for you, learn to use them they will save you many hours of bug hunting frustration. 

The cost of software In my opinion the code you have presented is overly complex and extremely resource wasteful. This is the type of code that gets sent back for rewrite. I understand you are still learning, and apart from the two bugs your code does its job. But there is more to coding than just creating working software. You write for the client first As a developer you must provide the best possible product for the client, the community, and the developer as a business. Software incurs costs for the client and community in terms of both time and power. This can be measured by CPU cycles and memory usage. Costs to the developer are in terms of deployment (bandwidth cost) and negative association (Developer X's code is slow and power hungry). Bugs The code you created also has a number of bugs. 

Danger potencial silent bug. Because the property is exposed there is a danger that you loose the reference to the worker, if it is accidentally or deliberately overwritten. This could result in a silent bug that makes its way to release degrading performance. You should make it safer (protect your state). Some style notes 

The design. There are some that will argue that adding to a built in prototype is inviting disaster, others will argue its a great way to extend the functionality of the API. As I see it there are two types of environments. 

Rewrite moves function out of also include the string function, the first is as you would write it if you included it in the API the second is how it can be written outside the API and thus trust the caller 

Someone that needs the comment to understand the next line would never be reading the code in the first place. Comment only abstract concepts that are not self evident in the immediate context, or comment for machine readers like linters, documenters, builders... etc. Comments are dangerous, as they are never vetted by compilers/interpreters and the debugging/testing cycle, they remain forever in the code. You may change some of the code and forget to change the comment. That comment remains in the code and one day when someone new comes to the code they will be faced with contradicting information. What is wrong with the answer? There is a trap in programming that is easy to fall into and that is over complicating the solution. And you have given a classic example of over engineering a simple solution. Complexity has many downsides. 

, and When declaring variables use the appropriate type. is the preferred type, unless you need to modify the value then use . If you wish to use let in preference to that is up to you, but be warned that is not hoisted. Avoid reserved words. There is a set of words that are reserved and represent existing, or possible future tokens. Two of these are , and you should avoid using reserved words. There are also many context specific words that you should try to avoid unless you are sure you are not overwriting an existing global property. For example , though you safely use it, I do not know if that is just luck or knowledge that is a global scope object AKA and you are in function scope thus not overwriting the global. Anti pattern I consider this as an anti pattern 

I will handle this as script agnostic Too many classes The solution you have created is just too complex. the code seams fixated on irrelevant data, and does little to aid the recovery of the wanted data. You are after the best hand out of 7 cards, for that you have created 3 separate classes. The class provides no useful additional information above what a simple string representation can hold, nor has it added any useful functionality that can not be done in a simple one line expression. "The jungle" The 's class only function is to vet the input, it then stores the cards without adding any information. You have simply converted from one abstraction to alternative equal level abstraction. "A gorilla." The class is the only class that does anything of value, but you have created it to be instantiated rather than as a set of static functions. 'It creates the wanted banana' The is the banana? or a gorilla? seams that the best hand is lost as no where can I see a way to find out what the best hand is. It got lost in the jungle. More than one best hand is possible. On top of that the resulting information is not strictly correct. Given a set of 7 cards there are 21 possible 5 card combinations. Of those 21 hands one or more hands can represent the best hand. Though it does not matter which one of the best hands is picked it seams that the best hand selection is arbitrary. Also you do a lot of reprocessing, with each evaluation step repeating many of the same functions as the step before. Data should only be processed once. Also you are constantly creating new arrays evaluated cards. Static functions. This should be done as a two static functions that return a simple object representing the best hand as a score that can be compared to all other possible hands. Maybe the hand name and cards as a string would be of use as well. All the many other object instances of hands, cards,... are not needed at any point. The rest of this answer is an alternative solution. It is not a perfect solution but just investigates the problem to a little more depth, and shows how you can solve the problem without unneeded overhead. Looking at the problem. Input string => vet string => evaluate all 5 card combinations => return array of equal best hands. Vetting the input string. There are 3 possible errors 

Yes always smart, but then all JavaScript is OO so a little hard to avoid OOP when writing JavaScript. The thing you need to ask is "Am I being smart and using good OOP practices" for which the answer is. You need to start creating objects that define and encapsulate the various parts of your application. Currently you are only using objects and indirectly creating them (functions are objects) JavaScript is very flexible in this regard, there are many ways to create and use objects. This type of application does not need to be defined as an instanceable object, as you will never need to create more than one copy of the game per page. In the rewrite I wrap all the code in the event function. This encapsulates all the data and functions, effectively making it a self contained anonymous object. I have also added an object at the top to hold all the settings. This makes it easy to make changes, as you do not need to go through the code to change each setting (particularly handy when the code starts to run into 1000's of lines) Some notes 

Naming Use a well defined naming convention, and use it consistently. Each language has a set of conventions that define how you create names for various things. In JavaScript we use lower camelCase for everything except objects that you create with the token, for which we use upper CamelCase Unfortunately JavaScript shares its environment with the DOM (HTML and CSS) and they have a completely different naming convention called BEM, which is incompatible with JS (you can not use BEM names in JS as they break syntax rules) Article regarding BEM and CSS Ideally you use the correct naming convention for the correct content and learn how to convert between them (when its automatic, when not automatic, and the exceptions) eg CSS becomes JS , element data attributes are automatically camelCased, ,any element attribute values (like ids) are not converted and may need to use indirect queries or bracket referencing.) You will note that these are conventions. Some (like me) opt to follow only one convention. JS camelCase, using it in the DOM and CSS for all names I define. This is not main stream. You have followed no apparent naming convention and that will make it very hard to know when and where to put capitals, '-' etc. You remember a variable by name, that for mere mortals does not include the naming format. Use class If you find your self setting class properties directly to elements you should give a moments time and consider if it is done better using a CSS rule. You do the following 

If you wish to identify single elements use the property to create a unique name and use that to locate and element. 

Note: I assume that the test you use is accepted as the way to determine if the array contains arrays. Test the input You can not be sure that the id of the element is correct. What you do in that case is upto the design specs for the function. I will assume that your function is not meant to generate any type of error. So you need to check that the id gets an element. As we are now calling an array method directly the function will throw an error is the passed argument does not contain an array. So you need to check that as well. A rewrite. 

Which on leet got above 91% on the first submission and on the second submission only managed to get ahead of 43% 

The string is used several time in your code. But then someone thinks that is not a good class name and changes it. You then have to find each string and change it. As you may also use it as a variable name you cant just replace you have to go by hand and change them all. 

Faster via lookup. What I don't like about this function is its complexity grows in relationship to the value n. As the range of valid input values is small this function would best be implemented as a lookup table. For speed I would also drop the type checking. Though you add a slight overhead just after parsing the code all subsequent calls will have the same execution time and be many time faster than calculating the value. 

Even the comments repeat, there are 12 ,3 and , and 9 I removed only the relevant content and counted the characters. ~80% of the the above code is redundant. with only 12 unique values in there, the filenames of the audio, and the element ids, which you repeat again in the rest of the code, and HTML. I don't think you know, but What makes it even more not dry is that every modern browser already has all the variables names created for you. Each line is simply replacing the existing global variable. Removing all the get element lines and your code would run just as well. 

JIT content rendering There is no observable difference in performance (after setting up) between using an image or a canvas to render context. As rendering content can be many times faster than downloading content it is a very good method of increasing performance at startup. Some warnings. Clean up state Using the 2D context requires that its state be maintained. Be sure to clean the state when you no longer have a need as the state can occupy a lot of memory. eg