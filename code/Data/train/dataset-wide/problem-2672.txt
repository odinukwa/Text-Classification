So instead of using as a safe assumption for our threads I used hardware_concurrency() to ask the system how many cores it has/we can utilize. The constructor of is more generic than and takes the function as a parameter. being templated we can safely use a C++ function with arbitrary arguments which allows us to change to 

Something I want to add to the other answers. Normally in finance money is saved in cents, etc., i.e. an integer. 

This fits better because we don't have intervals. Moreover floating point arithmetic has its own problems which you can avoid when using s. 

and enables us to remove the global variable and the unneccessary which would be in C++11 terms . Because we pass a reference we have to use to allow the template magic to find the right . Going forward, your classes and are redundant as well because there are std::condition_variable and std::mutex which do pretty much the same thing. Instead of and we use and (which describes their use cases and similarity better). To lock the mutex we use which works like your . A real difference is in because it takes the lock and not the mutex as a parameter . I know everyone (in C/C++) likes to implement their linked lists, but why bother when there is no real benefit. It takes more work, it increases cache misses because the objects are scattered in the memory and in your implementation it locks to this implementation without a reason. should just be a data structure regardless of the container it is put in. So I removed from it. To accomodate has to change as well. I decided to put a std::queue in it because it is exactly what we need. 

a) There is one conceptional behavior I personally don't like: The code will leave a partially written file behind in case of an error, instead of removing it. b) 

You added the cast likely because the compiler complained. But the problem was not the missing cast, but that you converted an integer to a pointer, instead of an integer pointer to a void pointer, which can be done without cast. When you store a correct pointer, you can then display it correctly with: 

This way changes of the data do not change the executing code, also the data is actually grouped together - you have a chance to spot erroneous data just by pattern recognition (or rather that something disturbs the pattern). Then we see that the data also correlates with the input parameter. We can include this, too: 

Note that in a garbage-collected system, it's possible to add items to the start of the list, or perform the #2 style of deletion, in a lock-free thread-safe manner. Nodes which are deleted may get unlinked in one thread and accidentally relinked in another, but the delete flag will cause the node to be unlinked again on the next pass. In a multi-threaded system requiring explicit deallocation, such an unlink and relink sequence could be disastrous, since a node could be unlinked, deallocated, and relinked; locks would thus be necessary to avoid problems. 

The most concise storage format which would be easy to work with would be a pair of UInt64 values, one of which would indicate which squares were occupied by white pieces, and one of which would indicate which squares were occupied by black pieces. One could find e.g. the set of white squares that also have white squares to their left by , or the set of black squares that have black squares up and to the right via . While working with bitmasks may be intimidating, it's a very powerful technique since operations can act upon the entire board at once. 

For N = 109 you have to store about 7.4 GB data, if you merely use longs with a size of 4 bytes. This is not feasible, which, I assume, is the whole point of the problem. You have 200000 Qs - storing the Qs instead takes up only 11 bytes per Q - one byte to determine the operation, 8 bytes for the two values which can go up to 109and 2 bytes for c, which fits into 16 bits, as it's not higher than 10000. If you store Q, you end up with around 2 MB of data. You could apply the Q operations at runtime to a single long (long) and then print each value individually. This algorithm will be memory-efficient, but very very slow. Looking at the problem, we will have a lot of array members having the same value. There are only 200000 operations but 1000000000 array entries - we can change 200000 different values - if we do this, we still have (109 - 200000) array entries with the very same value. Even if we modify 200000 ranges, this doesn't change the fact, merely the distribution of distinct values. So it's much more efficient to store a value and then for which array range this value is valid. In example: 

one would then be able to infer that because at least one of the 4's was correct, at most one of the other numbers could be correct. 

In the original PongÂ® brand video game, there were two bats which were confined to move vertically. A collision would be detected if ball circuit was triggered at the same time as one of the bat circuits, and if the ball was not already moving in the proper direction for that bat. The ball's vertical speed would be set to an odd number in the range -15 to +15 based upon the number of scan lines of bat that were displayed before the collision was detected (basically the difference between the ball's Y position and the bat's position). What exact bounce behavior are you looking for in your game? 

I am not sure if this is what you meant with your call because you only check for errors. But a nonexistent file does not return an error code. But from the context I think a check with is_regular_file() is a reasonable check to make. Theoretically there is also a Networking TS which should be tested by example implementation in the compilers like the Filesystem TS but I could not find any compiler implementing it. With this TS your network code could be simplified as well, but this is for another day. The final code 

First of all, I really liked your C++ code and even though I am not a professional I think there are some points to consider. To the future! It is 2016 so I would say we can safely use C++11 today (at least if you are not held back by embedded, an ancient compiler, etc.). There being at least three major compilers with C++11 support this shoud not be a problem. I went through your code from top to bottom and the first thing was . It is good but we do not need it because there is std::thread 

This is a mixture of storing the value and storing the operation. When you need to print a value, you look up the range and print the value. As you see, we need less than 64 bytes for this simple example to store the information how the 7.4 GB data is compromised of, yet we can print the value for each and every array position. Even if we have reduced the data, we still need to optimize the remaining data. We can't just dump it into a linked list - as stated, we can end up with Q+1 entries (200001), we can't afford to search the entries with an effort of O(n), let alone (r-l) * O(n). But if we put the data into a binary search tree, we can find the correct array entry in 18 steps within the 200000 entries. This costs us some more memory, not only due to the overhead, but as we need the array index as key, we can't group all identical values together, just as long as they are one range. So the example above will need 4 nodes in the binary search tree, to separate the value 0 twice. So, when you combine these two approaches, you should be able to get a decent memory and processor time consumption. 

When deleting an item, search through the list to find the previous item, then do the unlink. Have a "deleted" flag for each item. When traversing the list for some other reason, check the "deleted" flag on each node. If a "deleted" node is encountered, unlink it from the previously-visited node. 

Such an approach would allow the property to simply return a wrapper object, without having to do any real "work". Code which needs a detached copy of the list could use use , but code which will need it only briefly need not bother. 

IMHO, the best pattern would have been one which Microsoft explicitly discourages: having the the primary logic be in an overload which accepts a parameter indicating what failures should be considered "expected" [the more commonly-used and overloads would chain to that]. If had included an overload with a parameter, then and the normal overload of could simply chain to that. You could then have a overload with a parameter which would get passed to the corresponding overload of . Bingo--no code duplication. Since Microsoft didn't do that, your best bet might be to write your own method which includes a parameter and chains to either or as appropriate. In that case, while the extra layer of wrapping on would be a little annoying, the logic for would only need to be implemented once. Incidentally, while could be a , it might be better to define an enumerated type; the meaning of would be much clearer than .