The object is the workbook that is running the code, and by using a string argument as a call to the collection we can return the specific worksheet back. Working on the Worksheet Now lets get into the meat of the problem. Your code is slow because you are operating on the worksheet. Its that simple. A hundred calls to the will be slower than a hundred calls to . An array is faster, and is easier to use. Even worse is when you not only access the cells by a range reference, but when you do : 

Use existing functions/code where possible. This not only reduces the risk of bugs, but it can, at times, be more efficient. For example, denotes a and can be used instead of introducing an entirely new variable. This also makes your code easy to read. When I, as a reader, see I know what it is, whereas if I see I have to look for its meaning. Indent your code properly. I don't think this point can be over-stressed yet it doesn't always sink in properly. If you ever have code that is touching the window, aside from the Sub/Function declarations and Line Labels, something is wrong. For example: 

There isn't a big difference here. I have taken an extra step to ensure I have qualified the object I am working with, and I use a block to do this. As a result, all I need to do is put a period before each object I need to qualify and voila! On bigger projects, blocks can increase performance, and they make your code much easier to read. Above all else, they get rid of the pesky implicit calls. I'll insert a plug for RubberDuck here. Mat's Mug and his team have come up with a great tool that can make this process much easier on you. RubberDuck has a 'Code Inspection' feature that finds all this stuff for you, helps you fix it, and oftentimes tells you why it is wrong. Check it out if you have a chance. Once you have refactored this code to remove this beginner stuff, you may be interested in using the function, and Variant arrays in order to accomplish the original splitting of your data. Good luck! 

Notice how I ensure that only one line has responsibility over setting the return of the function to the default string. If the user chooses not to enter a custom string, then the function skips the If block and sets the string. If the user enters an invalid string it ignores the and again sets it to the default string. Always try to strive for this. It will make your debugging that much easier. Otherwise, if you do the same thing in two places, and it breaks, you have to fix it in two places. I can't tell you how many hours that has cost me before I learned to code smarter. Finally, my last note is this, and it is somewhat counter intuitive to my first suggestion: if you are relying on Boolean returns, and "On Error" statements to catch errors, you can improve. Look at why it breaks, and then try to handle that specific issue. As Mat's Mug mentioned, bubble it up if you can. In my most recent project I am aggregating a fairly complex report, and if even one of the sub reports fails it could invalidate the data. Instead of checking for errors at every juncture, I let the functions return empty arrays if they fail, otherwise they return the data they were supposed to. In my aggregation routine, I check to see if there is data in the input, and if not I handle it appropriately. I also alert the user to what data is missing, and where I am trying to use it. As a result, the routine fails productively, and I can then trace it back down to determine what went wrong. Overall though, 17 seconds for a routine to run isn't too bad. Youre likely taking the biggest performance hit on the fileread, and on the formatting on the worksheet (any time you perform operations on the worksheet it will cost you more than it would if you did it in memory). 

This bit of code is a prime example for what I am referring to, and is a good learning opportunity as well. Let's refactor it together. We will start with the sub declaration. As Mat's Mug will likely point out, you require 'WS as Worksheet' but this declaration is implicitly ByRef which means the object passed will be modified by any later actions on that object. To me, it looks like you are trying to use a Sub here to return a value (which is the purpose of a function). You have two options: 

I've done my best to get you pointed in the right direction, but your code is difficult to follow as is. Here is what I have: 

The firs thing worth pointing out is that you are ignoring a lot of special meaning with your current approach. Aspect ratios are a function determined by and thus we can use an aspect ratio and an inputted and to get the aspect we want, instead of looking through a list that are just saying the same thing in different ways. I took your original code and calculated each aspect ratio in order. Here are the results: 

There are two problems with the first version. The problem that is solved by the second version is that we specify the property we are accessing. The default property of a is so we don't need , but it is discouraged to implicitly access . The second issue is that we rely implicitly on ActiveSheet.Range("SomeRange"). This is a silent killer. I refuse to work with the Active Anything unless I absolutely must and even then, I prefer not to. It is always best to specifically call the object you are working with. 

Now, we can change sheets all we want but the correct sheet will be modified. This is a prime example of why we must always qualify our ranges. There will be some circumstances where ActiveSheet may be justified. The only instance I have had this happen with is when I am detailing into PivotTables, and getting the output sheet. Even then though, I try to avoid this practice if I have the time. Next, naming conventions within your code. Overall, you are on the right track, but lets look at a couple areas where you could improve. 

The beauty of is that you can have code within the or you can leave them empty and only have code in the block. Arrays This is the meat of what you are looking for. From your code, it looks like you misunderstood how to use arrays. Basically, arrays improve performance when the computations are done in the array (this is because they are being done in-memory versus in-worksheet). When using an array for your purposes I would suggest setting the array equal to the entire range with your data in it. So for example, if you have a table on worksheet in `Range("A1:Z100") your array would be: