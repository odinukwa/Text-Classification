This is wrong, the setter should be used to set the value of a instance, certainly not to save a value in the object. Also since this has all to do with and not with the , maybe this belongs in the class. 

This also makes your code cleaner, though it's not mandatory of course. Close the : You never closed your StreamReader-object, this is bad practice. You can do this in two ways: 1. Try/Catch/Finally 

I am a fan of loose coupling so I would suggest that you take the values of host, username, password and database out of your class. Pass the values through the constructor and set them in the constructor. This makes it easier to reuse your code. Second, in classes such as one that creates a connection to a database I would not "echo" stuff. You better throw exceptions on error or return meaningful values to the caller. Last, I'd suggest other names. This might be nitpicking but this has more meaning to me: 

Naming: A name like is bad practice. Give meaningful names to parameters/variables. Change it for example to . Although the class is , the method probably expects a "print-job", making a meaningful name. Writing output: Try to apply separation of concerns. In this case this means that you shouldn't write output to a screen in a method that merely returns a boolean. You could refactor it like this: 

You can also unroll the - loop, by copying the inner body 2 more times. If you can manage to change the mask_function: 

I think speed will only increase a bit, if at all, if you use arrays (The List implementation you use may already use an array). But you will reduce memory consumption if you switch to an array based implementation if you reduce the number of objects used this way. You should profile both implementations to compare speed and memory consumption. 

by an Enum which would add typesafety and also helps your IDE to detect e.g. if a state is not handled in your statement. 

I recommend to do the in a separate method (or simply use I recommend to use instead of I recommend to return an array with the size matching the new number of entries. even if might be cheap to compute, you should avoid computing the same over and over again in the loop-condition. 

This algorithm is far from optimal runtime O(n*logn), but I have chosen it because of its simplicity. For an Efficient algorithm see the comment of @corsiKa for a quite simple O(n) algorithm. 

I think you can improve the 'Inverse rotor pass' a lot by hard-code the inverted rotors instead of searching the inverse function every time. Your is never below so you could try to replace 

To see where the bottleneck is, you need to profile your code! Here something which may be a little improvement: replace: 

You could create a new class in which you define all sorts of methods like these to process a result and return it to the view-file where you will show it on the screen. Hope this clarifies it. :) 

I don't know if it is for testing purposes but you shouldn't write ouput tot the console in the method itself. 

Coding style Variable names Avoid variable names like or . In your code they still make sense because they're the abbreviation of the class name and it's not a lot of code, but it is still bad practice. When you have lots of code with less obvious class names or origins for the abbreviations, it'll become unclear what they are really fast. Rename them to and or something similar that clearly indicates what it is. Casing Per the Naming Guidelines by Microsoft, use the following rules: 

There is no easy or short way to achieve this as for each side/direction, the side values are not consistent in the same order (Not sure if I'm making myself clear.. :D). The only possible solution I seem to find is following: Create a method to initialise the dictionary. It takes two parameters: and 

I know I have strayed from the Exception subject but I thought this might help you too refactoring your code. Keep in mind that exceptions are for when your code does something unexpected. Ecxeption-handling is for catching situations which might result in abnormal behavior of your program, not for data that you (not the code) expect there to be. I hope you understand what I mean and that this helps! ;) 

If a number can not be divided by 2 it can also not be divided by any even number. So you can check2 and than only the odd numbers. you can make a list of all little prime numbers and check these and from the point where you have not the primes, try all odd numbers you can stop checking at sqrt(n) but that is quite expensive to calculate. Not so good, but still halves the work, stop at . 

to a method passing true or false as a parameter and reuse it instead of having nearly exactly the same code twice. 

In my point of view you cannot implement and any clearer or simpler. In the method I would somehow separate the values and also not print two times and not at all. Here is my suggestion: 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

And so on until you have only short methods with speaking names. This makes the code easier to read and understand. 

REMARK If there is any rule for the distribution of the intervals, you might be able to calculate the correct interval (or at least calculate a good guess and search from there). 

How to compare the the Algorithms: Either determine the complexity of your algorithm and the complexity of the solution in the tutorial. If you want to avoid to determine the complexity based on the source code you can simply implement the tutorial solution and compare the runtime of your algorithm and the runtime of the of the tutorial-algorithm. To get a good idea of the complexity behavior of both algorithms you need inputs of different lengths to approximate the runtime related to the size of the input. How to improve yours If your approach is very different you might not be able to improve your algorithm by looking on the tutorial-algorithm because they are too different. If the Tutorial-algorithm is better at all, you can try to understand the steps it does and try to memorize the general idea of this steps for your next algorithms that address similar problems. 

There's no need to encapsulate the whole expression again in parantheses. Simplifying the code: Finally, the important part! :) There's only one way I can think of to achieve this: reflection. I created following extension method to get the of your instance (note that it doesn't have to be placed in an extension method, I only think it looks cleaner and is good for reusability elsewhere if needed): 

Tip: new Constraint (C# Reference) I cannot reproduce your code and therefore cannot test the method. Please let me know if you got it to work using this method. Hope this helps! 

With you correctly used , but you should also have done it for in both methods since you know what the type is from the right side of that assignment. 

Your code looks well written and is easy to read and understand. As t3chb0t stated, you'll have to run a profiler and see where you might make optimizations. One micro-optimization I found was following: the properties of the can be set outside the most inner loop, since the parameters to set them don't change in the inner loop. 

Naming conventions: You should follow the C# design guidelines and use for public members, class names and methods. is for private members. Give your members and methods meaningful names. Names like or don't mean anything, except for you. Try using and instead. Method names should indicate what they do and/or return. So a method name like is bad practice. What are you getting from the database? Instead, use , or . Try to be specific, only use general names like the last example if there's no other way. This also applies to the other methods, use or instead of . (same for ) String.Format: Don't concatenate all sorts of variables with string constants. Use the String.Format method. Place the format and add your values as arguments. This results in cleaner code that is easier to read and maintain. Example, change this: 

So binary search should be faster, if comparison is the main factor, for n > 4. If n is constant (its seams 64 in your case) you can even hard-code the binary search to avoid the overhead of a loop. (that is also possible for linear search.) As an example how to hard-code a binary search: [for a array with 8 entries] Code will get quite long for 64 entries, but it will be fast. If your intervallBoundary array is intervals[0..7]: 

I think this method is not that long that you really need to refactor it, but you could do something like 

If possible I would try to avoid a method like . If someone manages to manipulate the this becomes a classical injection problem. If you do not need the flexibility to make any kind of db requests, use prepared statements for specific requests which only get some parameters. 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

Simplified tail-recursive code: end-recursive methods are likely to be detected by the interpreter and transformed to a loop. So this code might be faster and may nor waste memory. For more information see wikipedia Tail call 

You could extract the content of inner loops to methods with speaking names. E.g. You could introduce a method like 

While writing previous points I found that there had to be an easier way to achieve the same result. There are numerous ways to check for a palindrome. For numbers you can also use this method: 

If you read this carefully, you'll understand that an exception occurs when something unexpected happens, something you do not have control of (most of the time). In your example, the fact that for a given ID, no user exists is not an unxpected behavior of code. It just means that there is no data in the database for that ID. When trying to get an object with given ID (which will obviously return null) and perform some method on it or get a value from a property, this will result in an exception. In this case this will be a . I suggest you rewrite your code to following: 

This does not mean you have to write all your code in one line, this an example of doing too much in one line: 

A few remarks on your code; Naming: Names like or don't mean much, not to you, nor to others. Use meaningful names for your variables. The keyword: From the C# Programming Guide: 

Also, create another constructor that takes parameters so you can create a connection with other values. Combined you can overload the constructor and put all the logic in one. This looks clean and makes maintaining your code a lot easier. Example (classname is ): 

Why do you need a linear search [O(n)]? You can determine in which interval the value belongs by a binary search [O(log n)] (do not implement is with a recursion! use a loop or hard-code it))). Average number of comparisons for linear search is n/2. Binary search needs a constant number of comparisons of ceiling( ln(n) / ln(2) ). 

If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

I have never written any Lua code before, but a short view in a tutorial at $URL$ let me come up with this: Extract a method which returns 3 values: 

You need to check if each letter occurs the name number of times in both strings. One method would be to sort the letters and compare the lists of letters for equality. Here is my approach: 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity. 

Your code looks solid, however here are a few minor points. Catching/throwing exceptions You should only catch exceptions when you are going to handle them. There's no point in catching an exception when you're only going to (re)throw it. However if you were to use logging and still 'bubble up' the exception, you could go with this: 

This way you can also use a general method like before and use the tag to call the method. Like this: 

Here are a few remarks. I'm not perfect or write perfect code but I hope these tips will help write better code: Naming consistency: It would be easier to understand if the names of your two methods had opposing names. For example: and . It's obvious that deserialization will return an object, omit that in the name. Also, if you're using the same type/kind of parameter or variable in one method, give it the same name in the other method. Truly generic: You should make your serialize method generic too: 

Here are several tips that might help write better/cleaner code. Note that my tips or help might not be perfect but it gives you an idea on how to write better code. 

I think better would be to change the signature of the method and add a boolean (optional) parameter to indicate if you want to refresh the result: 

In my opinion there are two sides of your story here: 1. Wrapping exceptions This can be useful in situations where different type of exceptions may occur and you want to distinguish them, certainly when you want to give specific error-messages for each type of exception. As you have read yourself, when doing so it's best to follow the guidelines Microsoft has given. This was just a small opinion-based point but for me when reading your question, following point is more important to me: 2. To Exception or not to Exception First of all, here's the definition of the exception in the .NET Framework (from MSDN):