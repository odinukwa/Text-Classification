Instead of working with the objects in people_data i suggest you work with data structures. It becomes easier to manipulate that way. The data you care about can be represented with: 

Since I misunderstood the question. I offer up a second take. I have not convinced myself that log10 will increase the efficacy of the script but I use it anyway to show the concept of using math instead of len on strings. 

Instead of choosing a random chore, you could just shuffle them all beforehand, that way the randomness task is done. 

For big numbers and for many numbers checking for divisibility with prime numbers under the sqrt will give a big speed increase, you could still use the same method. But there are many ways to optimize factorization, many many ways. 

I ended up with this, and I don't claim that it is any better then yours. But I'll show it anyway for completeness. 

Python provides an argument here: . or is mainly used in if statements but could also be used in line: 

is not guaranteed to be defined. Prefer the qualified which is guaranteed to be defined by the C++ standard. 

Since C++11, if your constructor only initializes members to constants, prefer in-class member initializers. 

The use of an external buffer to store modal candidates is a violation of your first requirement. Consider a sequence such that the mode can be found at the end of the sequence and every other element in the sequence is distinct not a mode. $$S = [1, 1, 2, 2, 3, 3, ..., n - 1, n - 1, n , n, n] $$ What happens with the capacity of the buffer as we approach \$n\$? edit - This could potentially be a lot of appending and reallocating. If you actually pass that sequence into your function, you also discover a nice bug from exiting early. - edit 

Avoid in library files. The C++ standard requires static construction of the standard streams (, , , and the wide versions). If you want to allow functions to be streamable, consider and reference streams through parameters. This also means you should removing the debugging prints that litter your code. Consider using a logger that can be enabled at compile time with a switch or learn to use a debugger. 

Encapsulation: You are not working with kwargs and args, so don't name them as such, in the same sense that you should not name your variable i, it is very confusing. You are dealing with three different args and kwargs, namely the job, the executing process and the classes, and args and kwargs in the class, should belong to the class if needed or not. 

the obscurity magically disappears. This method of commenting your code is called annotations and is commonly used in python, I like them a lot. 

Your labels variables does not contain anything, you can not chain very much in python. It's a design choice from the developers. So the variable of the labels is unnecessary. This: 

If you put a statement like this as is in a function, you are repeating your self. In the same sense that 

is also unnecessary because, None is always return from a python function that does not return anything. 

In python, the ";" that you use in the end of some of your rows does nothing, python instead uses line breaks and indentation. You use very many variables, and you probably don't have to, and it seems that you are repeating yourself. If you want to do it that way, there are a better way. Function naming conventions in python is not camelCase, but instead function_name, camel case is reserved for classes. variable naming conventions in python is always lower case, and not B1, that looks to me as a poorly named class and not a button. You should write you variables after your functions, and not into right after your imports. When you top-down a piece of code, you make it dense, and hard to manipulate and read, break it up into functions. 

Your initial is a violation of your second requirement. edit - Misread the dataflow. However, the function still returns the wrong result. A sequence has no mode when all the numbers that appear in the data have the same frequency. -- end edit 

What is the value of ? Conversion of arithmetic types using separators is dependent on the locale of the stream. The possible results are 

You should be getting warnings about unused results. If someone you were working with was evil enough to overload the comma operator, that could have a side-effect on the expansion. You can guard against that by casting the result of your each expanded expression to . Casting to has the effect of ignoring the result and ensuring the built-in comma operator is used. 

Be aware of what actually does. is a stream manipulator that outputs a new line and flushes the stream. For unbuffered streams, this isn't an issue. If someone were to pass a buffered stream to this function, the flushing can wreak havoc. If your intent is to just output a new line character, then be explicit. 

I'm into async right now, so I'll offer up a async solution. I tried to follow your structure but instead used only three Labels. And I think it's justifiable to use async in gui programs. 

The manager might be unnecessary, you are only ever transferring one value. What you are looking for might be a Queue. 

My personal belief is that if you don't need the try catch, don't use it. However the above code is analogues to yours. 

Now to the suggestion If with any number that is even, it has a number of factors 2. So remove the factors 2 and do you algorithm on that number. Like this: 

Dict and sets has there differences, one being that membership testing is faster with sets, they also consume less memory, which will be important for the efficiency of your program. So a pythonic way of defining "english" would be something inline with: 

What would be the coolest solution? It would be to have a class inherent ThreadPoolExecutor and override the specific part of the class that executes the the threads inherent to ThreadPoolExecutor whit what you want to do. 

Keep functions short and simple. When functions gets to be longer than a few lines, look for opportunities to refactor into higher levels of abstraction. For example, your function has one large block that is essentially and another block that essentially finds the previous node. 

Note - Each member function should instead call a non-member free-standing function, but this review is getting pretty long and I'm trying to keep this example simple. By using a container type to automatically manage the memory, I don't have to provide a destructor, copy operations, or move operations. The compiler-generated special member functions all work correct by construction. Think about how you would implement a queue using the adapter pattern. 

Avoid as it does more than stream the end-of-line character. If you want the behavior, explicitly stream to indicate to the reader that it was intentional. Careful with your passing-by-value in the lambda. Prefer to use instead of explicitly typed variables to minimize your commitment to details (minimize rigidity). 

The Ackermann–Péter function should be tail-call optimized by any decent compiler, so you won't find much improvement with the recursive approach. If you really care for performance, calculate Ackerman values in constant time using the formula's for \$A(m,n)\$. $$ A(0,n) = n + 1\\ A(1,n) = n + 2\\ A(2,n) = 2n + 3\\ A(3,n) = 2^{(n+3)} - 3\\ A(4,0) = 13\\ A(4,1) = A(5,0) = 65533 $$ 

Valid. But your code is messy. You are taking one step away from the original traditional problem, and that actually becomes a problem form your code. Your actually better off with the one dimensional arrays then the two dimensional tuples. Tuples may be the wrong data type to use for your problem to resolve itself nicely. 

That being said, they problem statement seems foggy. The MD5 function does not yield the same hash for two different sets of data, when concerned with these kinda problems. That is way it is called a hash function or a one way function. If the hashes is identical the content is identical. The last thing I will say, is that even the very fast hash function MD5, is slower then a efficient comparing of the content. So I criticize the problem not your solution. Thanks! Good work. 

I'll go for the styling of your code. Firstly, python uses docstrings. There are one line docstrings and multiple lines docstring. 

In the problem you've provided each induvidual pairs order does not seem to matter, so load them as such. If you do that, you don't have to sort the in the calculation function. If you don't, you'll resort them later. Again and again. Them more samples you use, there more time is spent doing this. Times: 

A function that performs a single operation is simpler to understand, test, and reuse. Don't be afraid to break functions up into suitable logical parts and parameterize. is a nice utility when you need to iterate through a sequence but also want to know the index. Since you don't need the index, you can just iterate through the string itself. 

When we encounter a key, we just want to increment by 1. If a key doesn't exist, use the default value and increment by 1. You can initialize your hash to have a default value of 0 by . 

Also wasn't sure if the missing space before the was intended. Utilize extensions/tools (Clang-Format, Astyle, etc) to maintain the style layout. 

Optimizations: Use a better pivot selection. If you select the ends, you are vulnerable in the worst case on sorted and reversed sorted inputs. If you select the middle element, you are vulnerable to bell-curved inputs. Better Single-Pivot options would include median-of-3 and ninther. There is also a Dual-Pivot approach to quicksort. For single-pivot partitions, you should guard against sequences with many repeated elements by using three-way partitioning. Partition in-place. Your partition algorithm wastes a lot of space as it allocates two temporary buffers that cover the full sub-sequence. You can optimize pivot selection and partitioning to the iterator type. See Alexander Stepanov's Notes on Programming. Consider using insertion sort at a certain threshold. Insertion sort performs fewer operations (swaps, comparisons, etc) and takes advantage of architecture caching for smaller arrays. Reduce more space by taking advantage of tail-call optimization. Call qsort into the smaller side first then use a tail-call to recurse into the larger half.