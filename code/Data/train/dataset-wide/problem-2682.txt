The next post in my Checker series: The C# wrapper for my F# library to make it cleaner for these methods to be called from C# code. GeneralTypes.cs 

I like that you are setting the row size and column size in the ctor, which has a flavor of Dependency Injection and an extensible design; you can change those values to and , and solve the more generic N-Queens problem very simply. The problem is that you hard-code the values in without giving the caller a chance to say which version they want solved; you should make these parameters for the caller to specify. Because the 8-Queens problem is the most common variant of the N-Queens, these parameters could be optional, which would let the caller solve the 8-Queens problem by creating: 

Also, use braces. VS 2017 automatically offers to put them in, so you can fix everything in the project at once and just use them in the future. 

You have in both the and the , at the end of each. Remove duplicated code like this and place it after the /: 

If the user were to enter "r" instead of an value, for instance, it would crash. You can fix this by adding this: 

Take the next character from the first string Count all instances of that character in the both strings by iterating over them. Compare the count of the character in each string. 

I hope this makes sense; I know it can appear somewhat convoluted, but it really will make your code cleaner and easier to maintain. Basically, all your logic and display data goes in the VM, and the view is for pure presentation. Because the code-behind is part of the view, it should also only be involved in presentation details that cannot be expressed in the XAML, like fancy drag/drop details. Feel free to ping me if you have any questions. 

Also, I would probably just use an unless you really need the larger number size provided by an unsigned , in which case I would probably use a . 

It is easier to see which code is in which scope if you have it indented one level per scope. In fact, some languages take this so seriously that the level of indentation determines the scope, including Python. Also: 

Don't store information in strings. What happens if you want to check this value and type ? Or what about ? Those checks will both fail. Create an enum with these values. 

That's a bad call. Ideally, you should only use the preprocessor when no other alternative exists. In this case, many many alternatives exist. 

Yes. You can remove the difference between association and relationship, and define a single concept ("connectable object"). 

Create a new base, for objects connected to more than one object, that offers the same interface to client code: 

The gain in readability comes from the result type being explicitly specified. If you have APIs that only work for non-const pointers when they should work for const (this is the most legitimate use for const_cast) you should wrap them and centralize/localize/hide the call to const_cast. If you find yourself writing const_cast calls again and again, the problem is not poor readability of the code, but bad API design. 

You should not give access to the current buffer. You should instead expose an API that allows client code to add data to the terminal. If client code needs to know there are buffers, client code should choose the buffer in the write operation. Old code: 

Since the function takes a unique_ptr now, you now know you need to pass a pointer and you also know you are passing ownership as well. 

good naming is hard :) I usually choose this by writing a line of client code, then rephrasing it to read like prose. 

This is not setting a buffer, but selecting a buffer by index (consider the names , , and so on). is a structure. Consider creating it as a class (outside of Terminal) and not exposing it's data. Currently you expose it's data to client code and (because of it) you end up with this client code: 

I can see that you already have an accepted answer, but I think there are a few things that you should consider: 

This is incorrect. is "a type guaranteed to represent correctly the size/indexing of a ". is the same, for a native array. In practice, the two are the same (or compatible) ont the same platform. That means, you can definitely write: 

Normally, you should use the most specialized type for a job. In , and should be declared as . uses a big, monolythic switch. Consider replacing it with a dispatch map (extract cases into separate functions, then create a to map these functions to separate inputs). You should not have the entire code in a single file. Instead, you should have each class in a pair of files (.h for the declaration and .cpp for the definition). This would allow you to remove the huge separation blocks. Old code: 

This looks very clean and simple, which is always* a good thing when programming. First, you don't save state, nor do you have long functions--each function does what says in a couple lines. One nitpick is your naming: 

Please tell me the good, bad, and awful so I do, don't, and don't do the same in my next venture into VB land. 

ItemList, Back, and Forward are just s of MenuItems (they can't be s because they are bound to XAML objects that need to know when they are updated). 

That Linq strikes me as a mite messy, but I decided it wasn't that bad. The alternative is a list and a loop with a few intermediate variables. If you think it is worth it, just let me know. Here, I determine whether the s is a . If it is not, this inspection does not apply. If it is, I deliver both the and its parent to the inspection result: 

Now, you can change your method as much as you want, and you only have the magic number in one place, so it is easy to change your method to compare the values against a different number. Edit: Thanks to Eric Lippert, I have fixed two bugs. Eric found the bug that , so calling crashes. If you pass a value that equals , the program will crash. While fixing this, I found another bug in which the wrong value will be returned if you call the function with two values that are less than because they wrap around in the call . Both of these bugs are now fixed for the compare value of , still working on a generic patch: 

First, your algorithm looks a little better, but it still can be improved. It appears that it weights the higher values so they always drift to the left side of the board instead of wrapping around in a snake pattern: 

I needed to find whether any image's width at or higher than a certain directory folder exceeds a limit. Is this code a good way of doing this, or is there a way in which it can be improved? I ran it over at least a couple hundred images and several hundred other files contained in the main directory (not , but I don't want to show my user name), and it completed so fast the time is irrelevant. 

While not absolutely necessary, it might help prevent bugs if you use braces around one-line s and loops: 

As you said, if you can find meaningful function names, combining functions can make sense. As well the as character rotation functions for encrypt and decrypt, you can combine everything. Ultimately all the functions are similar: 

Before the prompt, it would be good to advise the full set of information that will be used (including the AD groups to be created). 

The loop was working fine, but it seemed odd the Dragon would move before the next turn and after a collision had been checked. You could reorder the loop from this: 

Help Messages There is also the option to add the help message, but the behavior is quite different: 

Splats Your splats are fine, but I personally don't like declaring variables I only use once (and on the very next line). This is a simple alternative which also uses splatting: 

When you add a light to the list, you don't need to check if it's already in the list. will return True/False for its success. Either way, you won't need to check before or after. Just know that if it was on the list already, it will simply return False and carry on. Likewise when removing it from the list. 

Function full of s Instead of evaluating conditions, setting return values then returning a , return the condition itself: 

How is this script called? It looks like a great candidate for a cmdlet. Parameters Validating Because it exits when a value is incorrect (instead of looping until data is valid) you could use Parameters with validation scripts. For example: 

I assume the commands are to view progress/status of the script? I would remove these if you are confident the script is reliable and accurate. Maybe one status () after every instruction line. 

For slightly less verbose loops, you could change loops to loops. This didn't make a large difference in times though. I entered the number into the website you linked, and your algorithm did give the correct answer. 

Replace all instances of and with . Change parameter type of from to (or omit the type altogether). New function: 

I like it, I learnt a few things about objects from this. I also really liked the board size can be easily changed. Immediate Collision When playing I noticed the Dragon was allowed to start in the same position as the Player. While it's not explicitly stipulated in the tasks, it might be nice to avoid that: 

Every loop of is evaluating all three conditions. You can combine these into an If/ElseIf/ElseIf so subsequent conditions are not evaluated when the first has already succeeded.