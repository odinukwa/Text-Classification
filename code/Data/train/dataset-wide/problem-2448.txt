Because this work is not part of a method you are exposing implementation details of your ID class via getter methods. All of which is bad: A better interface would have been: 

I would just let it fall through. If there is a possibility that does not grow it enough then use a loop rather than recursion. That will make it easier for the compiler to unroll and do other optimizations. Now what I would consider a good hashing function: 

The rules for a leading underscore are non trivial and most people don't know them. So even if you do most other people will get confused and panicky. The case where you use them it is not required anyway: 

If you pass it pointer to the constructor use those. If you pass in values save them locally but set the pointers up to point at the internal values. When doing operations always use them via the pointers (as the pointers point at the correct place always). 

But now think of the situation where somebody (a clumsey maintainer a few years from now) adds a destructor to Node that does stuff. The source object still has its original value of pointer and may affect the list of nodes. What you really want to do is move the content from but also put into a state that it can never be harmful to the surrounding code. setting the current objects members to NULL and swapping them achieves this: 

The approach you use makes it hard to verify. In my opinion the better approach to this problem is to use an epoch and calculate a day number for both start and end then simply subtract the day numbers to get the days between them. The following use the "Gregorian" Calander which was valid from 1752 (In Great Britain and its colonies including the US). Other parts of the world switch at other times. So I have written this to work with dates from 1/Jan 1753. 

Why do you use a different technique for numbers and char during sensitization. You could templateize the function and use the same code. 

That is the interface I would be looking for. Then I could easily change the type of the stream from a file to gzip file and not worry about changing the code. Code Review I hope this line is not in a header (and thus polluting my code). 

Your main issues is that on input you have different types for each key. So you spend time building a generic class hierarchy to hold each of the types. But the main code we see that each specific key expects a specific type of value and thus you try and decode the generic type based on the key value. Personally I would reverse this pattern. As you read the input. When each key is found extract the type you want and call the appropriate handler method. Your second problem is the number of keys that you will eventually have. Yes you should re-write the code to be data driven. That means you to store the mappings of key to action in data not the code. Thus making the driver code short east to read and the same in every case. The only interesting part of the code becomes the data. Below I have mapped keys to actions in the data structure . 

If this is a mutating copy constructor. Then just have the second one. Otherwise have the first one. Since the mutating one simple calls the const version I see no reason for the second one as a non const object will still bind to the const version. Move operations are usually . I suppose your are potentially throwing. I would need to look up all the funtions called. You should check and if your move operations are non throwing then you need to make an appropriate comment. 

It is not only a waste of time, but probably much less efficient than std::list (it uses pool allocations to prevent repeated requests to the runtime memory management system). Also did you really want a review on that? 

Forcing your user to write a whole section of code, rather than simplifying the task of writing code is where you fail. I also think you need to understand where C++ has been going over the last 6->8 years. This is towards the use of ranges (with iterators as the underlying model used as the building block for ranges). 

When you wrap a C object but still have to call lots of C code (because the interface is too extensive to wrap every function call in the interface (you may do it over time but not all today)). Then you can add a conversion operator that returns the C object when it us used in a context where you need the original C object. This allows you to pass your C++ object as a parameter to the C interface and it auto converts. 

I would do a couple of things differently. Early escape Your use of early escape is good and makes the code easier to read but you don't need the else section if the body of returns. 

You create a shared pointer. Get the pointer value from the shared pointer. Destroy the shared pointer then return the pointer that was in the shared pointer. So now you have a pointer but no guarantee that the object it points at exists anymore (as you destroyed your copy of the shared pointer). There are a couple of operations on the master pointer that you don't support. 

You may also notice that your compiler generates warnings about that. The variables are initialized in the same order as they are declared see below (not the order in the initializer list). 

I think the rule is so simple to remember that you are just making things more complex and harder to read. Just place and on the right of the thing you want to attache it to. 

So checkForWin() returns 0 for no winner 1 for winner and 2 for a draw. The first check above will result in win being 1 or 2 even for a draw, while the second check will result in 2 or 3 (which is probably correct). What you really want to do is make checkForWin() return the result you are looking for. 

So this will have a lot of blank words on the end. A better way is to read words from the stream until there are no more words in the stream. 

Even though the object created by will be destroyed when it goes out of scope; this object is assigned to the variable where its content is maintained. How this works: The object invokes the templatized move constructor on thus resulting in the contained pointer being moved from the object into (which takes ownership away from the temp object). When the temp object is destroyed it no longer owns the pointer and thus does not delete it. 

OK. So you try. But this is a very dangerous interface. There is no way to guarantee that the array and the array are at least size. 

But we know that the can potentially fail. So why go to all the problem of cascading threw the tree if will eventually fail. So you may as well do this up front and then only try and add the node if you can allocate it. 

Pointers have no ownership semantics associated with them. Ownership is the concept of who is responsible for deleting a pointer (releasing a resource). If you have a pointer you can't tell (without reading the code/documentation) who is responsible for freeing it (or how to free it or if it is even freeable). In the above interface I can quite easily break the program by doing: 

Since the only place you should be creating a from is within the call you should therefore make the constructor private and friend this function. You don't actually want to give people the ability to make objects of this type themselves. 

All the extra vertical space. Having is bad practice (see every other review about C++) Lack of around blocks of code in statement. You don't check to see if the read worked. Note if the read fails then introduces undefined behavior as will never have been initialized. 

If the members are non POD this will make a difference. So it is just a good habit to do it for all values (as types may change over time). Interface Design: This interface looks a bit leaky 

It will not be slower than your code but could be quicker. It also expresses intent much more clearly. Same comments as above: 

Am I supposed to delete the book when I am finished with it. Can the result every be Null? Pointers cause all sorts of problems about ownership. Returning a reference is nearly always the better solution. Are there object of type "BookSearch"? 

I really really hate when the comments (which are supposed to help) don't agree with the code. Because now you don't know which is correct (the code or the comments). 

I use the new style only when the return type depends on the inputs. Lexer I would have used a lexer tool. That's how I roll. Hard To spot break 

Also when re-sizeing. You should NEVER deallocate first. If the allocation of new memory fails then your object is in an invalid state and there is no way to repair the damage. Also don't you want to copy the data from the original array into the new array! This is generally what a resize does. If you are not copying the values into the new data storage area then this should probably be called Realloc. The processes should be: 

Will compile just as expected. Yet the test inside the function will never catch that -1. Truly unreadable 

If this actually generates a random number in that range then I would seriously kick the implementer of for generating an initial range of [1..(number-1)) This comment is even stranger: 

I see a normal iterator and thus normal access. You usually also want a const iterator with const accesses to the data. I see that you give const version of but not . 

Let the vector handle the memory management. You can handle the business logic. PS. You still need to implement the rule of three. Your connection is dangerious: 

Have a working version of MySQL implementation of ThorsSQL library done. If you want to check it out you can find the whole thing on github ThorsSQL. This is a follow on to previous code Reviews: Part 3: Layer 5 Req/Resp Part 3: Layer 4 Part 3: Layer 3 Part 3: Layer 2 Part 3: Layer 1 Part 2 Part 1 The documentation for these classes is here: Part 3 (Layer 5): The HandShake Resp and Reply When you first connect to a MySQL server; the first action of the server is to send you a package. The client should check the package make sure it knows the protocol suggested by the server. Then send a message to the server. If everything goes well the server will send back response. If we look at the code I posted for Layer 4 you may have spotted this happening when the object was initially created (added below for reference). 

Now that we can see the interface clearly there are a couple of things you should watch for. Const correctness. A method that does not change the state of the object should be marked . This tells the compiler that calling this method does not change the object. 

Your producer adds lots of items to the queue. But only signals once. You should signal once for every item added to the queue. 

Accidentally creating a shared pointer without knowing it. If you have a function/method that has a shared pointer as a parameter. Then the compiler will auto convert a pointer into shared pointer before the call. Thus taking ownership of the pointer. When the function exits the shared pointer is destroyed and your pointer deleted. If you did not realize that the function was taking a shared pointer then your pointer is destroyed. 

The node is a random place in memory it has no relationship to the order in the list. Giving your iterator this ability will result in it being misused. The should return the same as (but a pointer rather than a reference). For integer types (of T) this will make no sense (but will generate a compiler error). But when T is an object type it allows accesses to the members of that object. 

Const correctness. Its important to get your functions correct. There are a lot of situations where pass an object by const reference. When this happens you can only call functions. So it is important to get this correct. Dont test for a boolean result 

This way you would have retained a tiny bit more accuracy during the addition (which may have mattered). Before you cast it back to float. As mentioned by "The Dr" (MrSmith) above factor out any common code. But I would do it differently. Put all your conditions in a map to make the code more readable. You actually have two types of assignment. The first is simple assignment while the second is accumulation. So we break these two types of action into their own maps 

You over write the current members with the values from the rhs, but do not decrement the reference counter before overwriting. It might be easier to swap with . Don't include types that are not being used: 

If not enough parameters are passed then this can get you funny number in and which will affect how much memory you allocate. Don't use malloc in C++ code. You can not mix malloc/free with new/delete. So by only using one system of memory management you will not mix up the two different types of memory. 

Are you passing ownership of the parent? No. You have a seprat constructor for no parent and ownership is not being passed as a result you should pass the parent by reference (if it has a parent it must not be NULL and must exist). 

This is considered good in Java but in C++ it is considered bad practice. The only reason you need to use is to distinguish between member and local variables. Which means you have local variables with the same name as members, shadowing the members. Shadowing variables is a real no-no. Because the compiler can't tell when you accidentally do it wrong (using the local and not the member). But you can get the compiler to tell you when you shadow a member. Thus by never shadowing (and getting the compiler to error when you do shadow) your code is actually better as it will have less potential errors in it from using the wrong variable. In constructors use the initializer list: 

This is particularly bad here because it is in a header file. You should not use it in a source file either (bad habit). Doing so makes your code much more susceptible to bugs, read: Why is “using namespace std” considered bad practice? Putting it in a header file is worse because it can pollute other people's code (any code that includes your header file). If I include your header file in my code it could potentially break my code in subtle ways. Things like that get you band from projects. Its a bad habit and you should break it as soon as possible. The reason the "Standard" namespace is called is so that it is short and therefore not "much" of a burden to use as a prefix in-front of Types/Objects. Public Member Variables are always a bad idea: Anybody can come along and change the state of your object without you being able to tell. 

Tab characters are not 4 characters long. They are the length of required to get to the tab stop. So if you have a tab size of 4. Then you have tab stops at 4, 8, 12, 16, 20, 24, 28 .... So when you replace a tab you don't replace it with four spaces. You replace it with the number of spaces required to get the next character to tab stop. So if you find a tab at position 22 (ie there are 21 characters in front of it). Then you should replace the tab with only 2 spaces to make the next inserted character appear at position 24 (the next tab stop). =======================================================