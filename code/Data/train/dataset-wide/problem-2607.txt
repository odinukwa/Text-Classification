I also want to note here that your original property accessors dont use 'value'. You must switch to using value. The reason why is quite simple: 

Finally, making these few small changes has a huge impact on the readability/maintainability of the code. Here is the finished product (identical in function): 

Know I know **exactly* what my code is doing, and I can debug it much faster if something breaks. Indentation This is a pet peeve of mine, and it is a pet peeve of the community as well. Always indent your code (properly) and never post code on SO that is not indented. We will be cursing your name as we indent it ourselves (or, even more frequently, we just refuse to help). A lack of indentation will make bad code even harder to read. Shameless Plug For Rubberduck Mat's Mug and his team have a tool called 'Rubberduck' that goes a long way towards enabling you to fix these problems. Everything from indentation, to variable naming and variable use, even to Function and Subroutine calls. I highly suggest checking it out: $URL$ . In Closing Whatever you do, don't simply copy and paste my code, throw it into your module, and just go on your merry way. I spent time on this to help you learn, and my hope is that six months from now you will be in my shoes. If you do decide to forego the learning opportunity here, you will miss out on all of the things VBA can really offer. Best of luck! 

Somewhat recently I encountered an issue where my projects were simply taking to long to run. A lot of my macro work comes down to taking multiple tables (generally formatted in the same way) and joining together these tables based on specific users. This led to instances of loops that would loop over one table nearly 100k times, searching for a value in a table of a similar size and it would do so repeatedly (10 times or more). I ended up developing the class below for this task, but I am certain that there are things I simply don't know, or could do better. What this class does is basically provide a Dictionary with some additional methods that allow me input tables and return a Dictionary I can retrieve values from. The main reason why I built the class was that I didnt want to keep writing loops that would simply loop over a table and add a dictionary with the only differences being the number of dimensions I needed. I hope this all makes sense. Any advice is appreciated! 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data. 

Board Whenever I look at code, I first look at the shape and the color. When I look at the code for , I find a lot of mixed colors in my color scheme. This suggests to me that maybe you are mixing data with logic. There are also a lot literals in there. Perhaps you can extract these and replace them with named constants or methods? Are you following the SRP? For instance, what does have to do with the board? Perhaps this is a little more ambiguous, but what about ? For , you are using a 9-element array which seems okay. You might consider making it a 2d-array to make the public interface a little nicer, but I suppose it's fine. But why initialize them with the numbers 1 through 9? It seems to me that the board should be agnostic regarding it's contents. The indices already indicate the positions and having the contents be more clearly indicates that it is empty IMHO. Are you happy with the argument name for ? What about or ? Later in the code you use the term mark, so what about ? What about the method name? Is supposed to know anything about the rules of the game? The local variable is really a constant. Consider extracting it. You might also want to break it up into rows, columns and diagonals: 

I've done my best to refactor your code in such a way that you can use it to learn to improve your coding, but also in such a way that it all makes sense. I'll post it and then explain the process and some tips. The Code 

A constant () should follow the UPPER_CASE style. This makes it really easy to see when the constant is then used within the code. Special prefixes (, , etc.) hold special meaning, and should not be used within variable names. While it may make it look nicer, it will also make it more difficult for an outside reader to determine why the supposed is acting strangely, and they will assume that it is a bug within the language. They will not innately know it was a bug you introduced. 

Ok, so this ended up being a little bit longer/more complicated than I hoped. I will do my best to explain so that you can follow along. Please ask questions if you get lost or confused! Code first, then explanations: 

Public vs Private First I would like to note the use of a subroutine along with a function. This basically just means that the subroutine is accessible by other routines/the macro's list. On the other hand, the function is only seen by other code in the same module (so we don't risk the wrong code using it, and potentially returning a bad value). This is a little bit more advanced compared to where you are, but it is a good practice to get into early. Variable Declarations I noticed that you were using Hungarian Notation (HN). I would venture to assume we all go through this phase in the SO VBA community, but the sooner you break that habit, the better. It is far better to properly name variables than to use HN to denote the types. For this purpose, the names were easy. For larger projects it can be a bit more complicated. The sooner you avoid the habit though, the better. The Good Stuff Avoiding Errors Before They Happen Error handling in VBA is not very robust. It works, but oftentimes it is misused. I am of the mindset that error handling (in the line label sense) should be avoided at all costs. The best way to accomplish this is to use logic to your advantage, and to wrap repeated operations in a single function. In this case, the appropriate method was easy. The function takes an input cell, and returns a value based on the contents of the cell. While you initially checked for the function checks for since this will catch as well as anything else that isnt a number (since isn't but will throw an error if multiplied by a number). Why Use Functions? I like to think of functions as magical creatures that really are under-appreciated by newer programmers. Maybe I am hyping them up a bit. Maybe not. What I can say for sure is I used to avoid them. Then, someone came along (cough ThunderFrame cough) and lightly-reprimanded my avoidance of using single-functions for repeated steps (I had the same command in numerous places. He reminded me that, should that command ever change, I would then have to find every single place it lived and fix it. Simple advice, simple reminder, but it changed my approach to using Functions. I tend to ramble, so the point here is this: When you have some operation that needs to be done in multiple places (or on multiple conditions) you should strongly consider a function. That way, should the operation change, you can fix it in the function, and not in all of the places that you are calculating the operation manually. Functions also allow you to return different types of values. Declare a as a and you can return a a a . Whatever you want to do. They allow greater control over the flow of your code. Final Tidbits As I do in many of my CR posts, I recommend using RubberDuck, especially when you're starting out. You can find it here: $URL$ It helps for finding those little things you do without knowing it (Implicit reference to and for example) and help you learn better habits. Over time, these small changes in habits can make or break a programmer. Best of luck on this. 

Probably the names are a bit too verbose* and your algorithm may not make them quite as appropriate, but I hope you get the idea. * I don't mind long names for top level functions you call only once. 

Some editors may even help you by showing the type of the alias, rather than the underlying type. Extracting code to functions to improve singularity of purpose Finally, as has been mentioned before, it's helpful to extract each level of nesting into a little function. Not only is it easier on the eye, you can give each extracted piece of code it's own name. That helps to reason about what each step in an algorithm is doing as well. For example the first for loop is really just initializing a big old vector. I would move that whole loop into a function called or something and then move the second big loop into a function called or something a little snappier. And then maybe even have it return a new list or perhaps update its input and extract the printing section () to a different function as well. I know that its not quite as compact and also slightly (but not in a big OhO sort of way) inefficient, but it separates each section of code into what is logically doing. Some pseudo code to illustrate: 

Typedefs as an alternative to new types As others have mentioned, single letter variables are a detriment to readability. One way to help this is of course to add new types. As Corbin mentioned, adding a class or struct to hold just two ints can be a bit overkill (personally I don't mind). I'm not sure if this is considered good practice, but what I do in these situations is to create an alias: