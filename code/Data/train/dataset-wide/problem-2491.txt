This SQL, for what it does, is neat, and concise. There is no obvious place where any optimizations can be made. With the data size as small as it is, there is no reason to recommend indexes, or other improvements. The only glaring issue has been pointed out already: There are tools other than SQL that are designed to do these types of heavy computation with performance that your database just won't beat. Apart from anything else, the log functions are notoriously hard to get right, and there are multiple 'standards' for implementation. Consider math libraries designed for data and computations such as this. 

I am working on some multi-threaded code that requires a prime-number source. The following code keeps an array of primes in memory, extending it as needed. It works in the 'int' domain, being careful to avoid overflows, and to keep the memory for storing the data relatively small. it uses a state-based concurrency model... it keeps an immutable state that covers a range of primes (from 1..range). If a request is for some data that is outside that range, it will defer to a backup process which is single-threaded, where one thread extends the state. At any time, some other thread can query the state, and it is not blocked if the existing state covers its needs. The idea is that only one thread is working at a time on calculating primes, and any pre-calculated primes are reused by other threads. Additionally, during prime calculation, if one thread is calculating a really large extension, it regularly creates a new state, then 'breaks' out of the locked code, and allows any other waiting threads to use that new state if it is good enough.... The long-calculating thread will then start again on the next extension. PrimeReserveInt.java 

Algorithm Right, your algorithm. When I look at problems (things to review), I think: how would I solve this? I come up with a strategy, and then see if I can see the strategy in the code I am reviewing. If I can't see the strategy, I look harder, and try to determine what the strategy being used is... and I ask myself: Is it better than what I would have done? In your case, I have to admit, I came up with a strategy, I could not see it in your code, and your strategy is so complicated, and you admit it is slow, that I actually have not figured out your code at all... it's too much effort to understand the intricacies when I know there's a much, much simpler way to do this. This is a lesson for you... sometimes doing a google-search for an algorithm before trying to implement one is a good idea. So, instead of trying to understand your algorithm properly, I am just going to demonstrate an alternate algorithm..... The problem is: 

I agree with other comments, your naming for the product methods as add and sum is very confusing.... 

That function embodies the logic you are trying to do, and it can replace any search with any replacement in any text. How would this be used to solve the problem you have in the book? 

Using a helper function to check for the duplicate is a good way to put a code block in to a conditional clause for a loop. In essence, by creating a function, we have also created a powerful while loop check. The 'problem' with your code is that it was trying to do condition-loop logic inside the execution block, instead of inside the loop clause 2. 

That code.... is horrible... really horrible. What you do is spin-loop with a CPU at 100% utilization until the sound finishes. You need to do some blocking (or sleeping) until the sound completes. I would rewrite that loop, and the something like (note, you will have to handle an InterruptedException somewhere): 

Functionality The code looks functional, but there is one item that is non standard.... If you are passing in an array to a method for it to be populated, you should not also return it as the return value.... the method should be a method. About Surrogates, etc. It is right that you are concerned about Surrogates and other esoteric encoding issues. On the other hand, your code does a simple transformation that is 100% reversible. It simply converts a char system to a byte system, and back again. This transformation does not need to be concerned about items like surrogates. Because the input to the encode function is always a String, the output will also decode back in to a valid string too. 

You do know that you don't really use the enum as well as you should, right? A lot more logic can be put in there. Still, I suggest that you have far too much in the way of factory methods going on there. 

There, now Node is self contained, immutable, and generic. It can contain any object type, just specify the type you want when you construct it, for example: 

Scripts should have a shebang line. If you happen to be running in a shell other than 'sh' or compoatible, then this script will fail. Add: 

the stated goal is to return a new list, but your code returns one of the input lists that have been modified to have the merged results. This is buggy. If the first two elements in each list are equals, your initialization process will fail, one of the comparisons, either the first, or the second has to have an component, either or . As it stands, both the and the will point to the if the first values are equals. What's ? Why is it not ? Why use templates at all if you have only one template type that works? 

In this case I would go the regex route. Your code is basically saying: Anything that parses as a digit is fine, just so long as everything is a digit, and at least one of them is not zero. Express that as a regular expression: 

Algorithm Since you are comparing two files byte-by-byte, the hashing will make no difference. If the two files were on different machines, and you have a slow network between them, and if you could run the hashing algorithm remotely, then it probably makes sense to hash the two files on each side, and then just compare the small, and easy to transfer, hash result. Something like SHA-256. So, there's no need to hash, just do byte-by-byte comparisons. For large files like yours, why have such a small step size? Use something much larger like 4MB, not 4KB. It will make it much faster. Alternatives File IO is always slower than you want. Java has the NIO framework for higher-performance IO using Channels and Buffers. This would be a great time to learn how to use them, because, a 4MB Memory-Mapped IO operation on the two files will likely give you the best performance. See the MemoryMapped IO JavaDoc I ran up a test using NIO, and produced the following code: 

although I do appreciate having the braces.... Finally, even though the Node class is internal, I prefer having getters/setters for the right/left values. It makes spotting scope problems easier. Recommendation There are two basic styles of Linked node implementations. The one style starts with null values for the head and tail instances. The other style starts with constant 'dummy' nodes. In this case, the code would be much simpler if you implemented dummy-based head and tail. Let me illustrate: 

First, the slow part of this method is probably compiling the pattern, and you do it multiple times, each time the method is called. First, you compile it explicitly, second, you do a later on with the same pattern. How can this be improved? Well, Patterns are thread-safe, and reusable. Let's move the pattern compile to be a static, final field: 

Note, the use of block braces for the single statement, and not using the semi-colon to separate statements on a single line. These other statements should also be on their own lines (and the for statement should have a block): 

Algorithm MidPoint You have also copied your code from some reference texts, or otherwise done some mid-point research: 

That Set change will have a significant impact on your performance.... but, is there a better way? Assuming your limit of and assuming a relatively small dataset (less than a million, or so), then a better option would be for you to: 

String constants in Java are very efficient. In practice, your code is very high-performing. The issue here is not about how fast the code runs, because, essentially, it cannot be run any faster than this. If you want to have more efficient code in terms of space, then the practical thing to do is to declare the value as a string constant, something like: 

I am going to critique your class. Firstly, I think that code should handle the common cases really well, and, hopefully, success happens often. I would create a constant instance to indicate the success, and all other instances are fails. As a consequence, I would not have the method. How about: 

Note about the twitter-API rate limits. Sleeping for 2 minutes is a bad idea in your code. If you really have to be doing this sleeping, then you should change your code to do a background mechanism for accessing Twitter, and have a callback to your application with the results of your query. Also, you should have some sort of caching mechanism so that you do not need to re-query data you already have from Twitter. A limit of 1 query every 2 minutes is a really tight limit. You should also consider reading up on the Twitter API rate limits... they are not as harsh as you have allowed for. Also, there are headers returned as part of tyour request that shows you how many requests are available in the current window, and when the window ends. Bottom line is that you should be smarter about your rate limiting. Finally, your factory that gets Twitter sessions should not have a method but should instead have something like: ; Your method becomes: 

This class will 'accumulate' the parsed data, and return it when asked. It needs to do some tricks with both accumulators to get the data out in the right format, but you should be able to figure it out. Edit Here, I did it for you: 

We can count from 0 to 15 and use the bits in each value to mask out the letters and replace them with the asterisks. In code, this would look like: 

Yes, there's a better approach. The problem you have here is that each row is the same value, so a change to one row will be seen in all rows. For example, I added the following to your code to illustrate this: 

Now, that's got some Java8 stuff in it, but, all it really does, is time how long it takes to run a function. If I have the following 3 functions though (all do the same thing, with different names: 

Right, that's a tool to generate Fibonacci numbers in a way that is independent of the implementation. Now, putting your original question code in to that framework, so you can see what I did using a familiar starting point, I got: 

This is a huge step to take to solve a problem which I am not sure actually exists. Why do you need to reimplement the way the entire component is rendered just to add the ActionListeners in a different way? I think you have missed something here. You can override the ListModel () and add all the hard effort in to that. As far as I can tell, none of your requirements need to extend beyond that. Your custom ListModel can register actionListeners with each added list member, and can broker the correct action respoinses if needed. Additionally, it can handle all the other events and eventhandling that needs to happen..... I think all three of your concerns are valid, and you are right to be concerned... 

Matching Anagrams Your code is not matching anagrams. Your code matches words with the reverse of the word. An anagram is any rearranged form of the word. So, you have and in your list, but it should also match . Your code will not do that. The trick to solving this problem would be to reduce each word to its sorted array of characters. For example, to have a function like: 

Input validation is a critical aspect of any reliable program. Your code is functional, but there are a few things to note. First up, the is not a good error type to return, use an instead (because it is an illegal argument). Note that extends so it does not need to be explicitly checked/thrown. Next, you should validate inputs before using the values - using a "Guard Clause". While your code technically does that, the logic looks like the validation is done after the are updated. Finally, error messages should give the user/programmer an indication of what's needed to fix the problem. Your message should be more useful. So, all things considered, I would do the code as: 

Since this is probably the most common method to call when accessing the player, it may make sense to make the hand the result of the function ..... and it would make the code read pretty nicely.... 

You will need to change a couple of references to after the above change. I find FlagSet to be useful especially when using go-like sub-command processing. handling In your code you use regular expressions to parse error messages, and simplify them for presentation. The parsing of error messages is an anti-pattern in Go. An improved mechanism is to do type assertion on the error, and to directly manipulate the results. So, for example, the package is documented to normally return instances of an . You can use this in your code to handle the error better (see Error handling and go blog and more specifically type switches): 

Learning to use, and using the debugger are fantastic ideas. It is a valuable skill that will serve you well. Understanding how your code works (and breaks) is very valuable, and the debugger helps you through there. The remainder of your specific questions are somewhat linked to your actual implementation, and I am going to suggest that your implementation would be simpler with a String split operation. The specification says: 

Concept You have called this a "Longest Increasing Subsequence" problem, but it's not, is it? It's counting all possible sequences of a specific length, not just the longest. As a result, I think you may have confused yourself in a few ways.... Naming Your variable and method names are ... horrible. Variables should always be useful names, and, while and are referenced in the problem specification, S is not. Additionally, upper-case names are not encouraged... so you should have and instead. The method name is also off, it should be , and where does the in LCIS come from? Standards Your code compiles OK (with a warning about the missing return in the main method) with basic C compiler. This makes me think you intend to use C99 which compiles it without warnings. But, in C99, you should declare your variables where they are used, not at the beginning of the blocks. For example, you should declare inside the for-loop. Globals Globals are to be avoided. Algorithm Your concept of memoization is good, but I am not convinced the recursion is doing what you think it does. I am not convinced the memoization is used at all effectively. Frankly, I struggled to follow your algorithm, in part because does not tell me much about what is being memoized... I started hacking your code, and ended up restructuring it as a set of nested loops. The resulting complexity is somewhere around \$O(n^3)\$, which sounds really bad, but, for the problem given I am not sure can be improved on... A large part of the complexity is in the determination of the paths, not the combinatorics required to compute the count. I am likely wrong here somewhere, but my performance of the resulting code is more than good enough to be in the right ballpark... So, I use memoization as well, the system I use is, for each node, starting from the last, to record the number of increasing paths, and how long they are, to the end of the sequence. The last node, for example, can be the last node in the sequence, and thus has a count of 1 in path-length 0 (0 because I zero-base the path length - 0 really means "there is 1 path starting from this node where this node is the last member too"). With that system, I can then work backwards through the sequence, and simply add up the paths that have the right length. The critical method looks like: