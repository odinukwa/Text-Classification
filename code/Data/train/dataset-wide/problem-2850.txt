Notice that I immediately check for in the first line. Because logical operators "short-circuit" in Java, if , the condition will never even be evaluated since the will evaluate to regardless. Next, notice that I store whether or not to trim the associated characters in a variable right off the bat. This prevents me from constantly having to examine and break up the passed in , which not only makes my code slightly more efficient but, more importantly, makes it vastly more readable. Finally, the throwing Exceptions bit at the end might be a bit more advanced than your level, but there's nothing like a taste of the fun stuff you'll get to do to keep you interested. :) At first I simply had the last line as , since every ending branch must return something. But because the code should never reach that line anyway (since I have an exhaustive list of all possibilities in my if/else-if blocks), I thought it was better to throw an Exception (i.e., raise an error the program) in case it ever happened for some reason, since it means something fundamentally broke. Note that I could have also just left the last block as an in order to avoid the need to do something like that, but I wanted to make the code as explicit as possible for you to read through and understand. For reference, here's how I originally wrote it: 

You should try to use consistent style throughout your code. Above, you switch between having spaces between your assignment operator () and not having spaces. What I tell my coders is that it doesn't really matter which one you use, as long as you're consistent. The vast majority of work that will be done on the code you write will be done by people who have never looked at it before in their lives trying to do maintenance, so consistency really helps. 

He already checks for and then checks for . The only reason to use the second construction for a comparison is to avoid a ... which he's already done by checking against . So either he doesn't know that Java short-circuits conditions, or he has no idea what the purpose is behind the second construction. Also, it's generally a bad idea to have huge wrappers around entire method bodies. It would be a better design to have something like this (if it were needed at all): 

Here's my five minute rendition of it. Actually, my version uses inline statements because I find that it makes the code more concise and readable, but I laid it out a bit more to make it more intuitive for you. 

Comments: I think you make the very uncommon mistake of having too many comments rather than not enough. I'm actually loathe to even mention this, because I love when people comment well (and other people will love you for it, too), but commenting every single line is a bit overkill. For example, having a comment to explain that holds the player's name is redundant. Sometimes, it's okay for code to be self-documenting. (Indeed, some would argue that the best code is self-documenting with well-chosen variable/method names and good control structure.) Also, make sure your comments have consistent style. For some of them, you have just a description () while with others you have complete sentences (). Just having the description works fine and is less wordy, but regardless, choose a style and stick with it. Consistency is very important. Access Modifiers: All of your global variables are simply declared as , but they should almost always be explicitly , , or . Utility Class: I like that you wanted to separate out some of your functionality into different classes. But a true "utility" class is one which has "helper methods". These could be things like testing to see if a holds a valid , or validating that a user's input actually exists. Instead, you have functionality which is critical to the game in the utility class. As such, those methods would be better off in the class, since they really are part of the game. If you still want to separate out functionality, consider having a class called something like which has your method, and then having your game logic in a different class. That's actually a fairly common practice. Intuitive method names/functions: The names of your methods don't always match up with what the methods actually do. I'll explain more about that below. 

This / construction allows us to do some basic exception handling. Basically what's happening here is that will try to force the into an , which will then get autoboxed into our variable. If can't be parsed as an (i.e., if it's not a valid integer), then the call will throw a . This will be immediately caught in our block, at which point we simply print the error message to the user and continue execution as normal. Because we are still within our loop, we will keep doing this until the user enters a valid integer. 

I changed your to a in order to avoid your having to handle s in its initialization (or ignore them by having that ugly clause on your method, haha). This is just an easier API to use at this level. I've also moved it to be a field for the entire class. This will allow it to be referenced from all of the methods we create from here on out. 

I'm not going to go through all of this code since it's like 800 lines and would take me all day, but I can give you some good general tips just by glancing at it. 

What I'm going to do is walk through your code step-by-step, explain why I made certain changes, and then present the finished code. I'll also point out any assumptions I've made in constructing my version. I had to make a number of them due to your inexplicable variable names, but it shouldn't affect the final outcome drastically even if I made a mistaken guess as to what the variables meant. You should just have to rename them to something appropriate. So here are a few assumptions of mine right off the bat: 

This is the basic rule for how constants are defined in Java. I named the variable because this is a convention for referring to the "standard input" stream, but or something would be just as good. 

You might wonder why I'm using an here instead of an , and how that could possibly work with the rest of the code (since I explicitly declare that I'm returning an in the method signature). Java has a handy little feature called autoboxing which lets you switch pretty much at will between the primitive data type and its associated object wrapper. In this example, an is associated with the object, so when I (where is an object), it will automatically be converted to an to the caller since that's what I've declared as the return type. Why would I bother going through all this hassle and trickery? It's a good question. The reason is that a primitive type can't be . An defaults to . I want to have something good to check for in my condition, and I can't really check against an appropriately, since anything an can hold is... well... a valid ! By doing it this way, I always know that I haven't gotten valid input by checking that one variable, rather than setting a dummy (possibly valid) value like or making another needless . 

Your getters and setters would be for fields of the class, not passed in. I'll use your two simplest ones as examples for you to work from. 

Use reusable functions, especially when you find yourself copy-and-pasting code. Don't hardcode anything; use constants rather than "magic numbers". Don't use global variables. Wrap it in a . 

You should definitely go with Swing before trying to integrate Java code into a web-app. If you're interested in making Android apps, though, you can download the Android SDK and start toying around with that API. I'm sure there are tutorials out there for that. Setting up your environment might be a pain, though (your programs have to run in an emulator or be deployed to an actual phone). 

On a positive note, I really like that you named your loop variables and versus and as so many people do. It makes your code much more readable. But one of the principles of good code design is to avoid this kind of intense nesting as much as possible. You can do this like the following: 

(I don't actually know what the three decimal values represent when you're setting the console color. If they're not RGB, you can rename them accordingly. But you get the idea.) Finally, it's standard to encapsulate your functionality into a and call it like so: 

I rewrote your entire method as follows just by following some decent object-oriented design practices. 

means the previous count of a given missile; anywhere you use the infix or , it means something like "operational"; and, anywhere you use the infix or , it means something like "adjustment". 

I only see one really questionable thing in your code. Why do you call in your constructor? Your parameter-less constructor does absolutely nothing, so this line is irrelevant. If anything, I would actually even remove that constructor entirely so that your API can only be used with your meaningful and useful one. Also, as a side note, the following line opens you up to a since you never check to see if is or if it has any elements. 

Out of curiosity, is there a reason you make this two-dimensional array ? It doesn't affect the values stored in the arrays, and the doesn't affect the reference when it's returned from the method, so there doesn't seem to be much value in having it here (unlike its use in your class, which makes perfect sense). 

Casting is actually a kind of "all else failed" tactic in Java programming. Ideally, you should never have to explicitly cast anything. I think you're referring to the concept of polymorphism rather than just casting. A good way to learn about polymorphism is with some game or project involving different kinds of animals. You would have an abstract class or interface named , and below this you might have mammals and birds and all sorts of things. Turns out the world of biology is naturally suited towards hierarchy. Exceptions you learn naturally when you start actually trying to deal with errors rather than allowing your application to crash when it doesn't go down the "happy path". I think most beginners first experience this when they're trying to get a user to input integers and they have to deal with a user maliciously typing in . As you try to make your applications more robust, Exception-handling skills will develop. 

Small final note: I think you have a bug. The line where you display the results always says "sum", even when you're doing division, multiplication, or subtraction. :) 

Note: setting the combo boxes into the this way will cause issues if you intend to use the class with concurrency, but the solution for that is left as an exercise for the reader. :) 

For your next iteration... I challenge you to do some file handling! Download this file to your workspace and figure out how to read the words into your program and have it "think up" a random word from it. :) 

For a website, I've got some inline PHP, posted below. It's supposed to log traffic to the website, and it does its job fine. But at the end of the day, I'm not even close to a PHP developer, and this is really just hacked together from Googling and inferring from other, more familiar languages. How can I improve this? Is using PHP in the actual file like this bad? (This is in .) Also, I don't believe I'm open to an SQL injection attack since the variables are all drawn directly from the server rather than the user, but I could be wrong. 

Putting it all together, we get something that looks like this. If it were me, I'd probably further specify the function so that you could pass in something like or rather than the three decimals, but that can be for a future release, haha. There's some further encapsulation you could do to make the code still more elegant and readable, but I leave that as an exercise to the reader. 

This is of course pretty subjective, but this variable name is really, really verbose, even by Java standards. would be sufficient, or even just for these purposes. Just an opinion. 

I'm not a big fan of the above implementation because it relies on the method modifying the original array in place. It also makes your paradigm of returning a from the method irrelevant; you never compare or check for it. I think it would be a better design if you preserve the original board and create a new variable which you return from the method. 

It's a very simple point which I'm sure you already know, but I wanted to say it anyway just in case. You should wrap the main execution like the following: 

I'm going to use this above method to point out a couple of things that occur throughout your code. The first is minor: according to Java convention, your access modifier should come before the keyword (e.g., ). Not a big deal, but something to be aware of. More significantly, your method violates the "do one thing and do it well" policy. The method is called and returns a . That means it should evaluate the two numbers and check to see if the number is correct -- and nothing else. Instead, you're using this method to also provide feedback to the user. If you published your API and I wanted to use it, this would in no way be intuitive. 

It took me awhile to figure out exactly what he was trying to accomplish. When I asked him about it later, he said he thought he was being very clever and doing something good for the code by being "short and succinct". But it's not clever, and it's far from helpful. It's just frustrating for the people who have to maintain your code later.