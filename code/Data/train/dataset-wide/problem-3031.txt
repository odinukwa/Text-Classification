the use of is superfluous here since anything defined in-class is implicitly inline, and furthermore, is only a compiler hint for actual inlining (the main use of is to prevent ODR violations in header files). 

Working example on the Ideone online compiler (factor of 1000 less iterations, apparently Python is way slower than even Java). Unfortunately, the algorithm works by randomly throwing dice, and the Java/Python random number generators give different sequences, and the dice game may not have a unique equilibrium anyway. This means I can't directly compare the outcomes. Questions: 

I'd like to see a reproducible benchmark before being able to comment on whether a 10x improvement is really possible on . 

Live Example. Note that his adaptor also works for the two other Standard Library container adaptors and . 

Live Example that prints 27 (the same as your two implementations). What you are doing with your pointer cast to is very fragile, at the very least it's implementation-defined at possibly undefined behavior (for which no warning is required, and that includes the case that your code runs 10x faster on your system but crashes after you turn on compiler optimizations or port it to another system). Some issues that you have to be very careful about when doing pointer casting: 

Project Euler problems typically don't benefit from micro-optimizations such as inlining functions or flushing standard output. The biggest speed gains often come from algorithmic improvements. Here there are two key mathematical facts that can make this computation tractable: 

In generic code, I sometimes want to conditionally add a data member to a class template. Writing separate template specializations scales as for conditional data members. Absent a static_if feature, I have found the following user-defined class templates and useful: 

So I came up with the idea of caching the predicate values in a and dispatch the various actions based on that: 

It's a good exercise to implement the stack member functions , and in terms of the , and of the underlying container. It's still not entirely trivial, because you have to be careful about perfect forwarding and move semantics. The linked documentation should provide you with enough hints to comlete this. Note that does not provide an and neither does it provide iterators to view its elements. It does however have a protected member that gives access to the underlying container. You can then write an adaptor that uses the container iterators to show the underlying elements: 

I have 3 simple predicates and 3 simple actions to be taken based on those predicates. In my actual application they are not based on integer arithmetic, and in fact are rather expensive to compute (in comparison to the actions taken), but their dependency chain is the same. 

Live Example, using Clang 3.4 return-type-deduction in C++1y mode (also supported by gcc 4.9, and other compilers soon (use trailing return types for C++11 compilers) 

I agree with most of the remarks by @JerryCoffin. In addition, I would shorten the computation of and to a single initialization using : 

This will enforce that and have the same type, and you'd probably don't really care what type that is (it's not used in your interface anyway). If you really like the iterator traits, then I'd suggest writing an auxiliary helper trait: 

From these suggestions, it's easy to compose a general, flexible and almost certainly correct algorithm. Each step can be reasoned about in isolation. There is very little room for off-by-one errors. There is no unecessary copying of large vectors, just tuples of iterators. Regarding your question for test cases: I would start with some simple stuff. Sequences with 0, 1 or 2 elements. Sequences with only alternating elements. Sequences with no alternating elements, etc. 

how can I make my code more Pythonic? which other idioms / coding style should I apply? which other useful libraries (besides NumPy) could I have used for this exercise? 

Overall, I like your liberal use of C++11 style. One minor nitpick about the use of that occurs all over the place: 

I think you are right on track because your code has pretty much the same interface as as the Standard Library header . Just replace all your classes with , your to and to and you are all set: 

Live Example. So the repetitive logic is hidden inside the repeated values of in the , and the duplicate predicate computation is now reduced to simple lookups into the . Looking at the assembler from gcc.godbolt.org, it seems that the compiler even optimizes away all unnecessary calls to in (e.g. it sees that the remaining fields of the will be if the first one is), essentially reducing the code to that of . Questions: 

If you absolutely have to improve on the base line performance, you can rewrite your second solution as two successive calls to . First, by reinterpreting the as and calling at the block level. Secondly, after finding the first in the first mismatching block (which could be the final partial block containing the remaining s) and doing another over the remaining s. 

Oh and the in your question is already superfluous in C++11 for single-line lambdas. Generic lambdas are currently supported by Clang >= 3.4, GCC 4.9 and MSVC 2013 November CTP. I think Scott Meyers even has an Item "Prefer lambdas over bind" in his upcoming book Effective C++11/14. 

After looking in more detail to the assembler output, I think this is one of the very rare cases where the use of might actually be warranted (which is what the compiler is reducing the original code to): 

Note that the function takes its argument by-value, which allows also temporaries as arguments. As pointed out by @ChrisW in the comments, you could also use as argument but then you would need an extra copy in order to be able to sort. It works on strings of any length and for any character set. Live Example. 

Exploiting the empty base optimization then allows users to write class templates that have optional data members (conditional on user-defined template variable traits and ) 

write functions that take an and return an . Don't use Pascal like procedures by modifying a reference argument. This makes your code harder to reason about. separate computation from I/O: an algorithm should ideally have no side effects, and be silent. If you want to query the result, just print that. 

Why write it yourself if you can use Boost.Range's . You can even adapt this to set the starting index to and get type behavior (called here). 

Note that requires all 3 actions, the last 2 actions, and only the 3rd action. I was not happy with this code: while efficient in avoiding extra work, it seems overly repetitive. However, the following straightforward try at refactoring is a lot more concise but also less efficient as it computes all 3 predicates for all inputs: 

The documentation of Boost.MultiIndex is one of the best of all the Boost libraries, so you should be able to work out how to iterate over this container, and how to insert/erase elements. The library will guarantee you amortized insertion/erasure, as well as bidirectional iteration and splicing and sorting. If you wonder how this is implemented, there is a special section about that in the docs. I think that this is much better than to build your own container. Writing proper containers (with correct complexity, exception safety, resource management and move semantics) is very hard. Leveraging high-quality libraries should be your first priority. BTW, here's a somewhat related in-depth discussion of various ways to write an LRU-cache, starting with using combinations of STL containers and ending with Boost.Bimap (which is a special case of Boost.MultIndex). It shows how many of the pointer manipulations of hand-written solutions are quite intricate to get correct and efficient. 

The parameter is a signed integer that contains the , and the is used to convert without loss of precision. You can also define your own types , or this way. As you can so from my code example, you don't have to convert types to prove equality, just use directly on the objects. is only necessary to print stuff in different units, not for computations. 

In a professional setting, the advice would be: "scrap this entire code and use ". But suppose didn't exist in the Standard Library, or suppose you wanted to write some other container-like entity not yet invented. The professional advice would then be: "try and leverage as much existing code as possible". E.g. implement in terms of an existing container such as , or . This would automatically remove all the memory management issues from your consideration. In professional code, unless carefully documented why it would be absolutely necessary, I wouldn't expect to see raw or , and instead to see either and or memory managing containers like or . BTW, this is also how the Standard Library implements because it is a container adaptor and not a container. The precise class template is: