Function Wrapping Here is an alternative implementation, just for contrast with the other solutions. It needs a little work to be more robust, but the concept is clear. This version wraps the target method with a new method that checks the arguments. If all are nil then the default value is returned, otherwise the arguments are passed to the inner method. This approach's benefits include being purely functional and not being limited to just mapping; it could be used on any method. The disadvantage is that usage is somewhat ugly and not as ruby-like as one might wish. 

Your code is nicely organized, but there really isn't much to the calculation that it would require all of that. All you really need is your enumeration and a variable of how much you've accounted for so far. This code simply loops over the rates and starts summing by bracket until the quantity is fulfilled or it runs out of rates. Any remaining quantity is added in at the highest rate. 

Similar to dankohn's comment, there are really only a handful of operations going on, just with different character sets. Here is my quick implementation. It only handles the base 10 digits, and dynamically swaps out character sets depending on the power of the number. 

Ruby also has C-style format strings. Use '%d', %f', '%s', etc in the string and then supply an array at the end of the string with all of the arguments. 

Power Issue The increase in current when you increase the baud rate is expected behavior. See this question on the electrical engineering stack exchange for more details. Also see these guidelines on wireless considerations Arduino Code Some considerations: 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

Theoretical Code Evaluation Let's do some math to see how many operations you are doing. I'm going to use as my variable for whatever value you assigned to You have a loop that for every multiple of , it does modulus tests. For , the correct answer is 2520, so we can calculate that you code did For the correct answer is 360360, which is also the same number of operations performed. This doesn't seem too bad. However you are also calling every iteration. If you look at the source code for this, it loops through every value in the hash. This means that in the first iteration, the hash has one value and this is one operation. In the second iteration hash has two values (requiring two operations) but now we've done a total of three operations between the first and second iteration. In the third iteration there are three operations which makes for a combined total of 6 operations. After the fourth iteration we've done a total of 10 operations. This is a series of the sum of natural numbers and the formula for it is: 

I also fixed your condition in the loop so that it safely checks both values. You could also avoid some of the intermediate values, but I personally would preserve them the way you have them because of the readability/understandability advantage of having it this way vs. putting them all in one giant formula. 

Correct (produces the desired result) Reliable (always produces the desired result) Robust (handles errors appropriately and is not brittle when things change around it) Readable and Maintainable (try working on someone else's code or even working on your own code 3 years after you wrote it) Appropriate Performance (most code does not need to be optimized for performance) 

Cache since it doesn't change. Make your comparison be because you may never get . Use a larger pixel increment until you get close, then step down to a smaller increment 

First off, if you're trying to do these animations sequentially, the code isn't written to do that. You need to pass a function reference, not the result of a function call so this: 

If most of your code is the same among all the different delete URLs you are processing, then it makes perfect sense to share one route that branches based on the minor difference between them. Since that is what it looks like you have, then the way you have it is a logical way to do it. You could simplify your current technique a bit: 

It appears that you're just trying to create a list of players from the id values on a list of tags and also build a comma separated list of those ids. If that's the case, you can do the entire code block like this: 

FYI, I also find this a LOT easier to follow what's actually happening than the code you have. It also saves several comparisons on the value. 

In this case, it makes no difference at all. This IIFE really has no reason for even being there because all it contains is a single function. Your code does use any of the usual benefits of an IIFE (like a local and protected scope) or capturing the arguments in a closure. So the additional code that doesn't have any local variables of its own and doesn't use the passed in argument does not benefit at all from being in the IIFE, but there is no harm in putting it in the IIFE either. 

Set Unions Looking at your code, when you loop through the attrs, you are breaking after you find the first key that is in and in and in the passed . This is also known as the of the arrays. As such you can simplify the inner loop with: 

(Note that I wrote and tested this code in ruby and then ported it to C# by hand, so there may be a minor issue when multiplying decimals and floats or other trivial compilation errors) 

The BackgroundWorker.RunWorkerAsync() and RunWorkerCompletedEventArgs only accept/return a single object and you need to pass two (the block index and the block itself). You will need to either use a tuple/struct/class or something else to hold both objects when passing back and forth. Finally, You may need special handling for the last block of the file. Some encryption algorithms (zero) pad a short block to the expected length (1K in this case). This means that your encrypted file may be slightly longer than your unencrypted file. If this is the case for your chosen algorithm, your allocated output file size may be slightly longer than the original input. Depending on the file contents, this may or may not be an problem, however you should be aware of it as a potential issue. 

Create new StringIO objects Set and to my stringIO buffers Execute the code snippet in a object Join the thread Log the results in the stringIO buffers Restore stdout and stderr 

Foreach function, these tables show the number of calls and time spent on function call, recursively all the way down. Some portions, like the "range#each" can be ignored as part of of our testing overhead. Looking at the results, I can spot why dominant_2 is the fastest. Integer operations (FixNum) on a processor will always be faster. Floating point (Float) is slow and floating point divisiondividing is slow, and big integers (integer numbers bigger than that hardware can natively support, typically 2^32 or 2^64) will also be slower. 

By making your code generic (rather than one function per skill/ability) and making all skills and items just data it will make your project easier to debug and items and skills easier to modify or add to. 

In modern versions of node.js (v6.0 or v4.x in strict mode) or when using an ES6 transpiler, you can use the ES6 keyword: 

The object already exists, so no need to wait until it loads before attaching an event handler to it. Don't cache objects outside of the event handler unless it's really needed (consumes more memory, code is less encapsulated, makes your page susceptible to problems if layout or DOM elements change, etc...) Use jQuery chaining for multiple method calls on the same jQuery object Only use one event handler and put both calls in the same event handler. 

You should avoid assigning to named argument variables like you are doing in because this prevents some JS optimizations. 

P.S. Note, there is no reason to return anything from the callback as the return value is not processed by anything which is why I removed the return statement. 

FYI, if speed is really your goal here, recursion is not the fastest way to do this (because functions calls are kind of slow in javascript), particularly if you don't have much or any local state in the function so you could just use a loop of sorts. 

This "hides" the , and instance variables in a constructor closure so they are only accessible to methods defined within the constructor. This does not use the prototype for methods and may (depending upon JS implementation) consume a bit more memory per object, but does give you property privacy. 

It seems a little risky to me to just blindly use the language designation that the URL contains. If it's possible to trick Express into looking somewhere in your file system besides where you expect (perhaps with dots in the path), then you could have a security issue. It would be safer if you checked to see if it was one of a list of known-safe designations ("en", "fr", "ge", "sp", etc...). If you wanted, you could build a list of known safe designations by looking in the the file system at server startup and then just check it against that. I would also recommend using instead of adding in the path separator yourself. That will make your code more platform friendly should you ever want to run it on Windows. 

Break out of loops sooner This applies specifically to your spaceship and to a lesser extent to asteroids and torpedoes. Once the spaceship is destroyed, return. Any other collision checks are wasted processing time. For torpedoes and asteroids, once a torpedo has destroyed an asteroid, break out and move on to the next torpedo. This leaves a small edge case where a torpedo might perfectly hit two asteroids at once, so this decision is up to you. 

If Yes, read the next block from the file, pass it and the block index to the worker and start it. Remove the worker from the list If No, then sleep. 

Just because you mentioned recursion it in your post, here is an example, and also an example of implementing this as an infinite sequence. Pure Recursive Note that pure recursive functions in ruby have to be used carefully as ruby has a limited stack. Recursing more than a few thousand times tends to cause a stack overflow. Also note that this implementation does not include support for memoization, so it does a lot of redundant work. It is, however, a pure function. 

This line also removes the need of cleaning up your nils at the end Additional Thoughts While the logic is largely fine, stylistically your loops could be a little more idiomatic. Unless you are using older ruby, you should tend to prefer over . They do the same thing but .with_index is a little more functional (programming). Secondly, in general, try to chose better variable names than . You have comments describing what they are, but with better variable names, the code becomes self documenting. (I've used ix_row and ix_col, but that's my personal naming convention for indexes; feel free to change it, just make sure it's purpose is obvious.) Finally, you are overthinking your boundary checks as well. All you need to do is simply check the index. 

Since you are doing the same operation over and over, you can put your strings in an array or list and use a mapping function. For example: