I'll start by breaking the code down into different files. There are a many and here. If I am correct that will definitely grow with your project. Having all the constants in a different file is always a good idea if you are considering making it even moderately big. So to your question 

It is much more readable. Ditto for . Also why are you waiting till the API call is complete to throw exception in case there are more than two users? Just stop the whole thing when usersString has more than 2 user Ids when the class is created. And instead of this 

What's wrong? Where? If you catch an exception then you at least add the stacktrace to the printed messages. How? Google search. About catching only I say only catch what needs to be caught. If you are catching exceptions then if you can add some thing in the catch block to recover. If not possible then at least log a error message which does not require you to manually check what went wrong. Now what else can be done better? You can use Java's generics to make your Stack reusable. You should have created a class and then a which used the generic stack class to do its stuff. In your example the thing that you are calling is actually the as per the logic and the class that you have named is a stack. The main class should have just given the string and gotten the result out. 

I have not made all changes necessary because many things are not clear. In the typecasting I have left the Model class as it is. You can simply get the class name at runtime to do the casting. A simple example for casting to String class at runtime is . But how will you get the name of the class as String in the sub-classes? I will leave that to you to find out. 

You should read Python tutorials on exceptions specifically this section. In this the part about use of is relevant here. Combining that with list comprehensions this 

I would say you should definitely make a library. After that I'll go and indent this code properly. I couldn't understand where the function started and where it ended in the first go. If you want readability that is a something that you must seriously consider. All of your functions need proper indentation but for the function it is a must. There is a lot of redundancy in your function. 

Algorithm What can we say about a knights move? It moves the piece 2 squares in a line, and then 1 square perpendicular. You have listed all the possible moves, but we can just check if one of the absolute differences is 2, and the other is 1. 

This is equivalent to a list comprehension (or a filter) that might be easier to read. also reusing peiceSet for both the iterating variable and the list seems weird and possibly buggy 

The fact you need a comment to explain that the difference between this and later code is the order, shows that this is perfect to abstract to a method. 

You don't need to work out the values from the keys. Also .append(x[0]) for a list of size one is the same as extending by that list. (You can concat lists with either += or .extend) 

To get a real boost though, we need to look at the algorithm itself If we passed in "aabbcaa" currently it would loop through the string once to check if its a palindrome, and another 5 times before it finds the answer. While it is still O(n) best case, it is O(n^2) in the worst. For larger strings that is a nightmare So lets try and come up with something better looping through the string 

Why not call it playerX_name? Then the comment can be removed Self documenting code is always preferred over comments if possible. 

You call this 3 or 4 times a round, put it in a variable so it is called once and only once a round. I would change the logic a little bit, check if there is no difference between the shot and the enemy 

these two are different, so we know that one of these two must go* This gives us two choices "aabbaa" or "aabcaa" We can pass both of these in to our checkPalindrome function and we have an answer, and in roughly half the time (average case) *assuming that the string can be made into a palindrome with the removal of 1 or less characters. 

A final note, there are two parts to the function, getting the indexes, and checking which combination is the shortest. As such, we can move them to two functions. A cleaner version of the submitted code: 

I only have a few quick points, Names and consistency: In general, keep variable and function names to starting with lowercase. When I see an uppercase word, I think it will be a class. A second point here is if you are getting input, make sure the function name states that. There is no reason NameAndEmail couldn't be getNameAndEmail, and I know what the latter function does immediately. NameAndEmail looks like a class. 

I am going on with refactoring my code base while migrating from Python 2 to Python 3. I am using generators to make reusable components this time as I am more comfortable with them this time then last time. But there are times when I am stuck at their use. Like below example. These two are essentially same with one infinitely generating and other with a limit. Is there a way to make these as one function? Normally an extra optional parameter as limit will do the trick but with generators I am not sure how to use them. Is there some way to do that? 

Note that I am not familiar with Swing, only Java. You should remove unused variables. Like and in . They just confuse the reader about the logic. This can be improved. 

Similarly move and inside . Remember encapsulation. Ball's location remains inside Ball. You have this in the method of 

I am ignoring the implementation details like it should be . Similarly the second term is with summation running from 3 to n with step of 2. Third term is `6(n - 2). I'll leave calculating the second term to you. Simply adding these 3 terms gives you an program. 

I wrote the below function for doing a variation of bisection search that I came up with. This can be useful when the higher bound is not known. It assumes that as number increases the result of the condition is also increasing. For example - find the largest classroom size where the probability of two students sharing the same birthday is less than 0.99. If I have a function that finds the probability of two students sharing the same birthday based on number of classrooms then I can pass that function and perform a bisection search over an infinite range to find the highest number. 

Note that I used triple quotes to wrap around the stings to be printed. Read PEP 8 for why so be sure to read it. Any text editor with syntax highlighting would offset in reading due to strings being wraped around. Hope this was helpful. 

The second one is more efficient. Simply because in the first one you are calculating the times but in the second you are calculating it times. Also it can be made more readable and efficient just by using this. It eliminates which you aren't using anywhere. Readability doesn't need explaining. 

What happens if on player1's go, they win? The game should be over, but player2 still gets to try and make a futile move. 

First check if they are the same length, if not then we can return false immediately. Next make a list which will store the frequency for each character in the first string. ord() converts a char to its ascii value. Then we go through the second string, and subtract 1 from each corresponding frequency, and if we go below 0, we know that a character is not in the original string (enough times). Since they are the same length, we dont' have to check the frequency list for left-over characters. 

This is discouraged, I don't think it makes much difference in a program of this size, but it can be a bad habit to rely on. 

If a negative size was passed in, it is really a cause for concern, so we should throw an exception here. If we don't pass in the size, there is no need to check for it, so we can just replace this with 

The main improvements come from moving any work that is constant to outside the loop. We also avoid repeating work like working out the length of the snippet. For this kind of tricking about, profiling should be done to test the function. 

I attempted this problem from the ieeextreme, and I got timeout for just over 40% of the cases. Now that the competition is over, I was wondering what could be improved. The problem is as follows: 

It is up to you, but if I was designing the social media footer, I would use one nav tag, and just include all the link and image tags inside an unordered list, like the nav-bar. It means you can style all the buttons the same, without changing multiple lines of code in your CSS file. 

To resolve this, use the standard practice of trying something, and asking for forgiveness later. I would suggest either an iterable you build up. Still this seems like a case of reinventing the wheel, it is unfortunate python doesn't have it built in to the itertools library. It does define grouper in the docs of itertools, which is kinda what you want, except it pads a fill value to the end of the iterable.