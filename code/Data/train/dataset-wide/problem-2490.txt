The code parses and validates the command-line arguments. I'd make a separate method for it. It reads something from a file. It's a good candidate for a separate method, too. After that, it generates a random word. I'd make a method to make it more clear and easier to change in the future (if you ever need a change). After that, the game loop starts. I'd recommend to refactor it into a bunch a small and simple methods (for reading user's input, comparing it to the word she should guess, and checking if the game is over). 

I don't think there's a point in having multiple constructors in the class. I don't see why it should have any fields at all. I'd suggest to store the data in its subclasses (so that each subclass has only the fields it actually uses. It makes no sense for the to have the field, for instance). Actually, the could be an interface with just one method for computing the area. I would also create methods to read the input for each specific figure and print the result (so that each clause just calls the corresponding method). It will also help to get rid of a bunch of variables declared at the top of the method (they reduce the code readability because their declaration point is far from their first usage. Moreover, some of them are never used depending on the user input). 

I would let PDF.WrongPasswordException (because you don't have a choise) be the only exception to catch in this method, because all other exceptions have nothing to do with its Purpose (to check for password). If the file it self is missing or invalid, then you really can't tell if the file has a password or not and therefore returning false doesn't give the client valid information. If the IO exception instead is left to the client to respond to, he can react appropriately. 

In general it looks OK to me, but you could maybe consider the following: 1) Return a instead of and then yield the positive results when found: 

In the way you show that you create each Skill instance, you really have anything than the Description to distinguish them from each other. I read your Skill class as merely an advanced flag that defines a small set of properties. In the below I further anticipate, that each skill type doesn't change throughout the game. If that is correct, then I would make the Skill class as a "singleton" per Skill type (onehanded, twohanded etc.) and let a static Factory method create/return the right Skill according to a Skill Type enum: 

The product of the salary and the tax rate has two digits after the decimal point. So does the quotient. The method is unnecessarily long and complicated. You're trying to find the largest entry in a such that is less than the given value. That's exactly what the lower method does. Printing something inside the method is a bad idea. It makes the code less reusable (what if I want to just calculate the tax without any logging?). And violates the single responsibility principle (it calculates the tax and prints something to standard output). This kind of comments: 

To make your intent clearer, use when you need queue. Don't reinvent the wheel. Don't confuse those who read your code. Iteration over is very inefficient because it lacks memory locality. Don't use it unless you have a very good reason to. Use as a default container. Separate the words in variable's names somehow (either using camelCase or underscores). looks sort of gibberish. or looks better, doesn't it? Even if the input and output should have 1-based indexing, I'd still use 0-based indexing in computations. It's more conventional so it makes your code easier to understand (That's the main reason. Saving one element isn't a big deal). 

It looks alright to me, although it seems odd having a young man of age 20 to equal an "elderly" man of age 30 :-). I have 3 minor things: 1) One MemoryStream can be used to serialize all expressions: 

It's hard to comment on it. It seems OK to me - maybe a little to much list manipulation. I'm not sure if string concat with + is acceptable practice in F# but in general it's not. For fun I've tried with my own version with use of recursion: 

As the image shows checks against two different generations because the board cells are successively updated through the calls to in resulting in a false new state. The solution is to create a new board per generation and recursively check those while creating the next generation board: 

The calls to CheckForDuplicate(...) seems to be on the same level of concern so maybe make a combined handler for that: 

Singleton 1) It is fine to have the static context object as private and the static Method Context. But a pure singleton class should hide the contructor(s) as private in order to prevent undesired instantiation: 

This way, you main method would just read the input, call these methods and print the result. It would make your code more readable and testable (you would be able to test your methods separately) The comments should explain what the code does and why it does what it does. They shouldn't describe how it works. That is, it's a good idea to create a doc comment for each method saying what it does, how it behaves if it gets an incorrect input and so on. Conversely, comments like or actually harm the readability. They just create noise. They don't add anything useful to the code itself. Writing self-documenting code is a good practice (that is, ideally it should be clear what your code does from the code itself). doesn't sound like a good class name to me. I'd rather call it a (it's conventional to name classes with nouns and methods with verbs). The message looks kind of strange. I think it should say that it requests the user's height (it's not clear from the message itself). It's fine to keep the height as an , but I would show a message to the user saying that. Otherwise, they may get an unexpected error. You could also add some kind of input validation and error handling so that your program doesn't fail with an exception (it might be confusing for the user) but rather prints a more suitable message and possible prompts the user again. 

I think TheQuickBownFox's suggestion is rather elegant. With a little twist (the use of ) it is only necessary to call once per num: 

To avoid the overhead of cutting of the length you could use an enumerator instead like this in order to handle the first group separately: 

Although I strongly agree with tinstaafl in that the use of ToString() is not very beautiful from a mathematical point of view the solution he provides is rather unstable due the first if-clause (). On my computer the following errors are found: x = 0.000000000345; Wrong result x = 13 or 0.000054635 or 54.635 Stack overflow I haven't (had the time to) found a reliable solution, so it seems that ToString() is the best choice of stop-condition. sqroot() is missing one important input check: x >= 0 : 

If you've showed the environment the function is used in, the review could be more useful, but I think your reasoning is right, except that Lazy is used to defer instantiation and you actually use the lazy-created object () the first time it is called for by returning DataCache[key].Value. Therefore Lazy is of little use in this context as its object is instantiated at the same time as the Lazy. IMO your DataCache would give more meaning if you up front filled it with all possible queries without actually using them and then call them as needed. Alternatively you could just cache the queries directly in the DataCache without Lazy. 

Summary Managing memory is hard. Relying on standard practices and data structures can tremendously simplify it (in this case, they're: the copy-and-swap idiom, smart pointers and standard containers). 

there's no point in making a field. It can (and should) be just a local variable in the method. The same is true for other 's and test methods. Class design I don't think that the is a good name for your class. I would expect a calculator to be able to be instantiated once and then evaluate results of different expression. Something like this: 

Returning is a terrible idea. Firstly, can be a valid value. Secondly, it won't compile for an arbitrary type of values, so it makes the use of your cache extremely limited. Here're several ways to fix it: 

In general, avoid using loops when there is a standard method for doing what you need. If you are using Java 8, you can simplify the code even more by using the method of the to avoid things like: 

You can use a more efficient algorithm. It's clear that the unique value is equal to the xor of all numbers in the vector. One can write a nice one-liner to compute it: 

What are b1, b2, operation1/2 doing? A better naming would be suitable. Tuples are nice objects for holding (temporary) data, but I wouldn't use them in the above situation. Instead I would make a class or find another approach. 

As I see it, your code works fine as it is. You could though improve it a little bit by appending each priceTypeId in one appendFormat operation as in: 

Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

The Sprite class and inheritance Since Money, Item, Monster etc. all are subclasses of Sprite, I would only have one set of objects containing all sprites: 

because it will not return before all primes are calculated. It is btw strange that the client of the has to figure out that 2 is a prime :-): You could change the function to take a max or a count value to stop the generator when enough is enough. As an alternative it is IMO more useful to return a of primes, because it returns the primes as soon as they are individually calculated: 

Whitespaces. It is conventional to have a whitespace after , and keywords, before and after curly brackets. Variable naming. Non-static, non-final variables' names should start with a lowercase letter(and different words are separated using camelCase). It is not consistent in your code: , for instance, follows this convention, but or violates it. Design of your class. Having one huge method that does everything is a bad practice. Moreover, the entire class does too many things: it handles GUI and the conversion logic at the same time. I would recommend creating a separate utility class that converts speed units into each other. Current design makes your code very hard to test. Avoiding code duplication. Several event listeners contain the same code: 

There should be one whitespace before an opening bracket. Again, there is an inconsistency in your code: a whitspace is present most of the time, but it is not present, for instance, here: . Not following established style guidelines is not good, having inconsistencies is definitely bad. A little bit about blank lines: they should be present between different methods and it is fine to have them inside one method if it is really big and you need to separate logical blocks from each other(however, too long methods should be avoided). But having a blank line after each statement is pointless and it makes your code less readable. 

EDIT I admit that Husk has a point about especially in where the length reach as much as but tests on my computer shows only a pair of seconds in expense for n = 8. The algorithm exhausts the stack for n = 10 anyway... As an alternative you could use which seems to have the same performance as Husks version. 

I think you show a good understanding of F# as a language and functional programming in general as far as I can see. A couple of things though: You use as variable name on multiple levels of function definitions. It makes it hard to read. IMO is a very readable construct for more than two matches. But for only two I prefer if-statements. The function/sequence is a kind of double sequence. I would do it this way: 

First of all: If I were you, i would create a Point struct instead of having two parallel vectors for x and y coordinates: 

I would return in the outmost function too to avoid the call to ToArray() in order to let the client decide how to handle the output: 

Writing self-evident comments is a bad practice. For instance, this comment doesn't serve any purpose. 

Error handling. It makes sense to throw an in the constructor if the denominator argument is (it is not a valid rational number so it shouldn't be treated as such). The barrier between representation and use is not about having a constructor and fields and other methods that perform different operations. The barrier is the class itself. The clients of this class can treat it as a type with a set of defined operations without any knowledge of how it is implemented internally. 

Separation of concerns. Ideally, one method should do one thing. I would expect the method to actually rotate the array. That's it. Your method also prints something to the standard output. There are two reasons why it's bad. Firstly, it's confusing. Secondly, it introduces more reasons for the method to change. For instance, if you need to change the format of the output or write it to the file, you have to change the rotate method. It's not convenient, is it? The interface is quite strange. The parameter of the method is redundant (it's expected to be equal to the length of the array, isn't it?). It also makes the interface less clear (what if I pass a different value of ?). The algorithm itself is not efficient. Shifting the array be one times requires time. There are at least two ways to make it linear. The first one is pretty simple. You can copy the entire array to a buffer and that assign in a loop. However, it requires additional memory. The second one uses a constant amount of space and operations. It goes like this: to cyclically shift an array by positions to the left, one can reverse the range, then reverse the range and finally reverse the entire array. Documenting your code is a good practice. It's not clear what the valid range of values for is from your code itself. It's also not clear whether it performs a left or a right shift. Your code formatting violates the Java coding conventions. The indentation is kind of messed up. The binary operators are not surrounded with whitespaces. The names of the variables are not meaningful (for example, what does stand for?). That's why it's hard to read.