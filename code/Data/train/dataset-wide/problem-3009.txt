A small but important aspect of your code is the hashing method itself. And I've seen this gone wrong many times. DON'T use MD5! These hashing methods are way too fast, and therefore can easily be cracked. If you want to hash your passwords properly, use a slower hashing algorithm like blowfish. In php5.3 and above this is present in the function. php hash manual 

To learn some PowerShell I made a tool, I've made before in bash. It pings the subnet for arp values and checks if there is no weird behaviour. 

I am making the assumption that the word is in between spaces, but this could not always be the case! You could have or . Or it could be at the start or end, and not have the double space. In short this is rather error prone. 

loops per se are not a bad idea, it is just using a loop for this example is overcomplicating stuff. That makes it a bad idea. is awkward because you keep appending that item to the list and refering last element, you could also have stored the range as a variable and keep overwritting it. 

There is not much to say about your code then, Regex is slow. A non-regex solution could be to use Python's endswidth, this works the same as 

Variables should be as close to the scope as possible. When you modify globals somewhere in your program it might become really hard to track that 1 bug. You could use list comprehension to declare those varibales in one line like this: When using list comprehension and you don't need the variable, it is Python idiom to write instead. 

I created a new for each file. To have better accuracy I should have merged the frequencies for each file to a new , for instance . And once all files a processed try to break the text. My is redundant, I don't do anything with the frequencies. I could have just return the to yield the same results. 

you not need handle this at all. return number of bytes read. and you need use it. no any difference what bytes you read. 

SetCommTimeouts again - senseless code. this api simply send control code to device on which file open. usually only serial controller driver handle this ioctl. the npfs.sys, which implement pipes - not understand and not support this ioctl. driver return to you ( mapped to win32 error) but you not check for errors here. 

interface of course also must be absolute another. here faster need export class with virtual functions. class implement cmd exec and write commands to it. virtual callbacks with read data from cmd. you inherit own class from this base interface class, implement your own on read data handler and cmd exit (disconect). some basic implementation of class: 

then reallocate caller supplied buffer - this is very bad idea. for reallocate you need exactly know how caller allocate buffer. you must add to interface contract - how caller must allocate initial buffer and free final. which concrete routine use. say for example caller must allocate initial buffer with and free with . but nobody do this. usual used 2 ways: 

here - in/out parameter, but in only - if you reallocate user buffer - you must return new buffer size to user. may be next signature: 

another way - use for buffer. windows let reserve memory space. we can reserve tens of megabytes how minimum. this operation not allocate any memory but simply mark memory region as reserved. then we can already commit memory to region begin. when, after read, will be not enough committed memory - we commit more and so on. advantage - we from begin will be have contiguous memory - we never will be need copy/move/reallocate memory with this way. this solution is better when we assume big enough final data. example: 

but main question - are you need Contiguous Memory buffer at all ? for what you need cmd output ? for send it to remote system, display it in interface ? for this not need. after you read some data from cmd in fixed size buffer - just display this chunk in interface or send to remote system. and begin read new data chunk. of course you need absolute another interface for this. for parsing cmd output ? for this yes - need Contiguous Memory buffer.. but we never need parse cmd output. for what ?! if say we want list files/folders - we need do this yourself but not run dir command 

When I do a the IP of the Attacker is in the route. When I trace the route, and there is not a router device in my route it means an attacker(laptop) is listening on my connection When I the attacker does an , the ARP-table has duplicate values. 

I need cheap GPU's and decided to make a little ebay-scraper to make sure I can buy it at cheap prices. It works and I can search for (any) product to scrape the Title, Price and Shipping cost of that product. But I feel like I haven't done it in a generic way, hence the need to post it here. Thus my question is, could this have been done more generic? 

Review There are a few things that could be improved upon. 1 .Your could use some love I might understand using a dictionary so you can see which value corresponds to which direction, but this may be simplified to just using a tuple of directions. and are variables badly named I believe, maybe or something would be better. and implies that these variables are private/protected, and in your case they are not. Secondly I think with this: 

This should be enough for now, you can always add more. Secondly when using comments they should be like this 

Use indentation of 4 spaces, it looks cleaner Functions should be named with lowerscore letters. Example: You use a lot of which could be rewritten to Same goes for which is just You have some calculations like which can be rewritten to When using comments don't indent them! should be 

Any review is welcome! Plus I would be happy if anyone has additional information on how to prevent MiTM attacks. 

Code changes Your could be alot more simplified. Because a normal palindrome is just checking if the word is the same as reversed. Now the same goes for words with punctuation, but we just have to remove them first. When I apply my thinking, I end up with something like this. It might not be iterative but it looks alot shorter/cleaner. I first remove punctuation, with a list comprehension in combination with a check if a letter is in afterwards join the word together and check if it is the same as reversed. 

in this case and out only parameters. and you need say to caller - which api need use for free returned buffer. 

then look for (full nightmare) ; you all time read to to buffer begin () and never change . so what sense try reallocate buffer if you any way try read only bytes. then you all time read to buffer begin - so new read overwrite previous data. you use wrong and senseless , , instead of . for what you use before ? when you try reallocate buffer after every read ? even if still exist free space in current buffer ? on which size you try realloc buffer ? on 1 byte ?? and every time anyway try read constant to begin ?? for dynamic buffer buffer usually used 2 strategy: allocate memory chunk (usually 0x1000..0x10000 size). read to this chunk until exist free space in it (of course not all time to the begin of chunk but to the begin of free space inside chunk). when no more free space in current chunk - allocate new chunk (not reallocate existing !!) and so on. but not copy anything. when read will be completed - once allocate new buffer and once copy content of chunks to this buffer. for example. 

again bad and wrong. for what you create 2 pipe pairs ?? when 1 pipe pair only need. one pipe handle in you process and one connected pipe end in cmd. pipe must be duplex. what you write to this pipe end in self process - will be read in cmd. what cmd write to self handle - you read via handle in self process. so not need additional pipe pair. next - always need use asynchronous pipes and io here. synchronous is not efficient and can deadlock. 

ansi function usage. such as CreateProcessA this is very bad. windows is unicode (utf-8) system. almost all api implemented as unicode. the ansi (A) api - is shell over unicode (W) api. the A shell convert input ansi strings to unicode, call W api and finally convert out unicode strings to ansi. this is very not efficient. more bad that use ansi strings simply wrong by design. ansi code page is not invariant. it different on different systems. if you hardcode some ansi string in code, which use characters > 0x80 - you got different unicode strings after convert, on different systems. finally not any unicode string can be converted to the current ansi code page. use ansi code page for cmd is wrong. cmd use for pipe input/output not ansi but oem code page. this is different code pages. when cmd read multi-byte string from stdin file - he convert it to unicode via with . and when he output something to stdout file - he translate unicode string to multi-byte via with . so until he output characters in range you not view different. but if will be say "not english" file name in output, or you pass some command with "not english" file name - will be error - because you and cmd use different code pages for translation. you pass him ansi but he wait oem. he pass to you oem strings, but you wait ansi. also note about inherited handles - begin from vista better use also with for restrict list of handles to be inherited by the child process - not all inheritable handles, but only one pipe handle. yes one but not two as you use. 

For timing, see the Time complexity for python You use some expensive operations while this can be done is a single loop 

I think this code is very straightforward and easy to read. Good job! Some nitpicks are, You have a few PEP8 violations none all that concerning. 

Especially if you're new learning Python, I suggest to learn . Support for will be dropped soons since EOL (End Of Life) is just a few years away. It seems silly to learn a language that will be dropped soon. 

@200_succes has some very good advise, but I think I can add some more. Originally this was supposed to be a comment, but it got to long. 

Profile You can use the cProfiler to check where your program takes up the most amount of time Example Code 

The code, the bad and the ugly I kinda rewrote all you had for a more readeble structure, First of all, why 2 different functions for the stup of the game? In my opinion this would be better suited in 1 function: 

Here I return the players as a dictionary where the KEY is the players name and value the current_position, only drawback is that there cannot be any duplicate names. Now for the juicy part! 

You reinvent your 2. Use enumerate I think this was said in your last question you posted on CR too, and it is still valid. You should defenitly use enumerate when possible, see the corresponding PEP article 3. Doing this in one loop You have: 

Intro I have started a new course (Analyzing Big Data with Microsoft R) and have an exam soon. So I wanted to test my skills, and a nice way to do this was by doing a Kaggle competition Titanic: Predicting Disaster. I managed to get a decent score (80%). You can run this script by first downloading the , and set your working directory. I am using the latest Microsoft R Client. Any review is welcome, but I am most interested in: 

Another "safe" extraction is to put your into a (class-level) constant, which we will name , because as far as I can see, it is a floating-point comparison tolerance. 

You do that for every run you got thru your label, but in fact it won't change: neither nor are changed elsewhere in this method. So we can safely move this operation above . Same goes for , , and . Then we convert your into common-knowledge . To do that we simply replace with , enclose all code below in loop, add in the end, and instead of every . Inside loop we have three s. If we look closely, we'll see that they are mutually exclusive. We will mark it explicitly, so we don't have to guess. If we follow this line of thought, we'll see that every time we don't hit inside our we can safely return from call. So let's invert those conditions too. What we've now come to? 

Why are and , if it's not assigned anywhere in code? It should not be. Only things that implies assignment is call to , which should not modify anything, because it's only writing. You have not included your code, but let's assume that it's not doing any assignments inside too. So we get rid of those s. Next thing in here: you're passing in an array of s and some , most likely an index. But everywhere in method (with exception to calls to ) you're using . So we can safely extract it into temporary variable. Let's call it , for the lack of best option. 

Now I'll do some strange thing: I'll extract your call to to variable. I do this only because it is the only thing that operates with and and I can not make any decision about it without seeing it first. So I'll just save entire call for later. 

All that's left is . Most of it happens only when . Let's invert that so we don't have to think what happens if both bests are 0 (because we simply return at that, don't leave us hanging!).