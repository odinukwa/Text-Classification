The thing with this is that has the implicit contract that b will be in the same state a was, and vice-versa. Doing otherwise can lead to surprises, and surprises are never good. 

This is a very interesting idea! I have to say your implementation is definitely different from how I would have tackled that. There are two main axises of improvement that I see: 1: Why Pointers? I don't think you should be treating this as a pointer, but as an object wrapper instead. There is no reason to not be able to apply this to a stack-based object. If someone wants pointer-like functionality, nothing is stopping them from creating a or 2: RAII, please! If the unprotect -> reprotect flow really should be handled through RAII. Think and as references. The idea with this is to make it impossible to accidentally leave an object unprotected because of an early or thrown exception. A few notes on the code itself while I'm at it: Duck typing or type erasure, choose one. When taking a duck-typed operation as template parameter, creating a polymorphic base class is just redundant, and extra weight. Eventually, you want to use concepts instead, but for now, documentation is enough. Spelling: it's Primitive, not Primative. Broken code: Your copy constructor won;t compile, requires non-const operands. Do not encrypt in swap should leave the objects in swapped state. It forcefully encrypting the objects will just lead to surprises. At worse, throw an exception if one of them is currently unencrypted, but don't surprise users like that. Why is overwriteOnExit even an option? You zero teh data whenever you encrypt, so fail to see a scenario where you would ever want that set to false. If anything, should you move to RAII scemantics, it should actually be illegal to destroy the object when it is in an unencrypted state, followup feedback: 

Trying something out of my comfort zone here, and attempting to implement a D-style range around . Looking for any and all suggestions or improvements. One of the things I'm not exactly happy about is having to declare , and just to fullfill the forward_iterator concept properly, yet not being able to actually use them. I feel that this allowing me to initialize a vector straight from the iterator pair is worth the clunkiness, but I welcome any opinion on the subject, or suggestions on how to make it better. Thanks! 

Doesn't that look nicer? all the names and ratios nicely bundled together in one spot. That's also why I've set it as a global constant in my example: The ratios and their name have nothing to do with the main function, they just are, so they should exist out of context. Declare variables as late as possible should be declared as close as possible to the first use. Use algorithms when possible. You can use to calculate the sum: 

Good work! After a quick first pass, here's the main items I've found, in no particular order. I'm sure there's more to find in there, but these should improve your code a lot: overuse of explicit Edit: see comments below, this not not correct in every single scenarios. is only useful on constructors with a single non-default parameter. adding it to constructors with more arguments is useless. Weird use of pointers 

Instead of going through every little improvement one-by-one, I'm going to make two big sweeping recommendations: 

Forwarding is needed when the template deduction can deduce the type of a parameter to be a reference. I.E. the arguments themselves need to be templated. That's not the case here. You can simply use: 

Anyone who s your file will have these imported in their global namespace. You should should migrate these to your .cpp file, and just use for the two instances in the header. list<> vs vector<> There is nothing in your code that suggests is preferable to . Unless you need fast insertion/removal in the middle of the structure, is preferable here. For each ( in ) is not a thing is not standard C++, but a MSVC extension, use range-based for instead. Furthermore, by using instead of , you are working on copies of the adjacency list, not references. You want this: 

There's a few subtle advantages for the compiler, but the main one is that if you goof up and accidentally do something that changes the trie, the compiler will tell you. nitpick: is redundant here. The namespace of a class is private by default. Fun fact: that's the only difference between a and a . nitpick: redundant null-checking in your search function, when I read the last line: 

Since I'm a huge JavaScript neophite, I'm sure there's a lot to improve in there. So I'm looking for any and all feedback on style, general practices, functionallity, etc. 

This kinda violates the separation of concerns principle. Have a class/function do 1 thing and do it well is generally preferable. 

Only letters in the 'a'->'z' range are admissible. That's only 26 letters. Only strings of length <= 100 characters are admissible. By extension, this means we'll never have more than 100 substrings of a given length to deal with. 

make_tuple() should decay the type of its arguments. Specifically, you should apply on a per-arg basis so that returns a . No EBO Since you seem to care about packing, you should really be performing empty base class optimisation to get the maximum oomph out of your tuple class. This does make the code a lot more complicated though, so if you know for a fact that you'll never pack 0-sized types in a tuple, then I wouldn't bother. A note on : Making this a compile-time switch like this is pretty dicey, as you can eventually run into some nasty binary incompatibilities in the future. I would rather make a complete separate class called , and use the compile-time switch in higher-level code so that symbols related to and remain consistent between binaries. It also allows you to mix packed and unpacked tuples in the same binary which is potentially convenient, since can have a substantial hit on performance. 

This looks a lot better! Good job! Nitty-gritty stuff: better cleanup in the constructor You hava a lot of the following idiom in the constructor: 

What looks like "convenience" to you just ends up being "confusing" for possible users of the class as they have to wonder "which one of these should I be using?" Take objects by value if you are taking ownership 

Since I needed to do a query-response handshake over the websocket, I decided that I might as well generalize that, since I need to do it a lot more further down the line. client-side : 

The only improvement I can see here is pretty marginal: unordered containers have an average insert complexity of O(1), but that can become O(N) in degenerate cases (because of hash collision handling). That's pretty rare, but enough in my book to not use the datastructure if a simpler alternative would work just as well. In your case, doesn't provide anything you wouldn't get from a simple or anyways. So I would personally switch to one of these. That being said, depending on the context behind how and why you use such an index generator, there are sometimes better ways to do this. For example, if you are using this logic in order to manage a small block allocator, you can store the free list inside the unalocated memory. see example 

If you keep iterating on this project, sooner or later you'll have a , or a verbosity control argument. It would then be too easy to accidentally disable a piece of program logic. At the end of the day, injecting the dll and logging wether the injection is successfull is too separate concerns. Keep your concerns separated. inject_dll()'s error handling. The function as written is a textbook example of why some people argue that functions should only have a single return statement after initial sanity-checks. Even if this function is correct, that coding style of manually cleaning the proper stuff in each exit branch of the function is bound to bite you in the ass sooner or later and should be avoided in general. The best way to fix this would be to use RAII, either using a type function, or a std::unique_ptr<> with a custom deleter. Don't do massive allocations on the stack The following is too big to put in the stack in my opinion: 

Explicit begin() and end() creates a very wide invariant I would get rid of the and functions, and just implement them at construction/destruction, that will simplify the logic a lot (getting rid of mActive and mEnded altogether, as well as making cleanup a lot simpler). Telling users of the class to manage that cycle through lifetime and scoping is absolutely fine. Worker() = default; is rundundant If you don't add any other constructor, this is implicitely done for you. prefer header guards to #pragma once While widely supported, is not part of the language. If you are making a generic, portable, tool, you should avoid it. 

STL containers already store objects in the heap, and do a good job at managing them unless they have a that's ridiculusly massive (which would be super suspicious in the first place). You are wasting a lot more performance on hitting the memory system like a madman and inferior cache performance than you are gaining from marginally faster container resizing. Speaking of resizing... Deque is for fast front insertion, not fast resizing. you do not on , so you shouldn't be using a deque here. Once again, the marginal increase in container resizing is almost certainly not worth the decreased cache performance. has an amortized time of O(1), it'll be fine. InputSource design is dodgy It's hard to tell because seems to be designed to accomodate code that is not being shown here, but in general any "inherit to extend" design is suspect. Really, as far as I can tell from here, your lexer should probably just operate on a , and let the calling code handle concatenating token streams from different files. This would lessen the responsability on the lexer, and let it do just on thing: Lex. Big ugly if else if block: 

A review of the way the 4 specilizations of are built While we are at it, I would welcome any suggestions on how to improve the jankiness around using the macro. As usual, any comments/suggestions about the code in general. 

Looks really good! A few improvements: Confusing construction. Construction from raw is making your constructors more complicated than they need to be. Your class would be easier to work with if constructing from a value ALWAYS constructs by actual value. Also consider that boolean arguments are often hard to understand at the call site. Can someone not familiar with your library tell what the following line does without having to sift through your header? No, and it's a problem here since raw construction is clearly going to be an unfamiliar edge case. 

While you get mad props for using RAII to manage the FILE pointer, you should be using a unique_ptr here, not a shared_ptr. initialise() is unnecessary You can simply initialize the map using a literal: 

You are mixing your functionality with your test harness and have no business being members of this class, and should be free-floating functions. Once you do this, you will realize that there is a lot of stuff missing from your class as it does not expose the interface required to implement these simple cases. 

Use front() and back() to access the first and last elements of a vector You could make an argument that is as good as , but not for the last element. 

Your function currently will always go through a copy-constructor, and for this is definitely non-trivial as that has to be thread safe. By taking the StateRef by value, this gives users control over whether to provide a RValue, move in a LValue, or provide a copy of some other object. Maximum flexibility without any overloads. This brings us to: Prefer unique_ptr over shared_ptr I see no shared ownership scemantics here, unique_ptr would be better simply for performance reasons. But you may have other parts of the larger codebase that warrant it. That comment is just about the code I see in isolation. That's pretty much all I've got here.