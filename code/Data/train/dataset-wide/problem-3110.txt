Nano variable names are evil. What is ? An error? An exception? An event? To figure that out I need to look at a place where the function is being invoked. That's mental burden. Same applies to , , and ... If you are in VS Code or any other smart editor, it's a matter of hitting F2 and renaming it. Names and are particularly unfortunate since they are meant to be symmetric to/consistent with and . Thus, should be ! Also, I could not decipher what the prefix means in both of these variables. Just spell things out: , , , , , . 

Context I'm playing around the concept of a Finite State Machine. While I understand the basic principles behind it, I want to implement a simple, yet generic class which could be reused in the future projects. Focus The code below intentionally separates the and interfaces from the class which implements them. This is done in order to distinct the from the of a given instance of the state machine. This also allows providing the minimum necessary information about the state machine when it's being constructed. In other words, this separation is on purpose. What I want help with, are a few things I either don't like or don't know: 

Functional vs imperative â€” hopefully not off topic Disclaimer I don't think that Codereview.StackExchange is the right place to ask questions of that sort. The answers may get extremely subjective (and result in a "holy war"). The issue is that there's no universally objective criteria which could be used to justify that functional code is by definition better than imperative ...or vice versa. I prefer functional... Still, I chose the functional code snippet you provided and improved it, rather than the imperative. Here's the reason why, but please take it as an opinion. In my experience, functional code is less buggy, so to speak. Now, I do not have any data to back this statement, and my guess is that the scientific studies on that subject are contradictory. Nevertheless, this is what I feel about it. Reasoning behind "functional is better" Here are a very few functional programming aspects and their possible effects: 

Update 1 Just a few months ago I was not aware of which seems to be an answer to a part of your question: 

Update It is indeed much better to avoid unnecessary loops. I'd still use a "registry" of known coins to keep code generalized: 

Get "Enough" Test Samples Below is the "test bench" I used to compile your solution before feeding it to a profiler. If you uncomment the console output instruction in the block, you'll be able to see some unhandled exception which could be caused by either bad input my code generated or a bug in the parser code. 

updateUrl -- excerpt and ternary () operator can sometimes be efficiently combined too, but this kind of changes is really putting many developers on the fence. I'm trying to stop myself with ternaries, as soon as I start thinking for too long whether it's readable or not... 

Not the Strategy yet I'd try to not have a super huge ExtraCard component class if possible. The idea is to encapsulate the data in a interface/classes: 

I'm pretty sure you already see what I'm going to say. It's not a great thing to reassign a value that was provided into the arrow function by the caller. Today your code works. Tomorrow a junior developer touches it and things crash... I'd recommend to rewrite as or even as and use a locally scoped "variable" to prevent bugs. 

Dealing with DOM competes with . Do not mix DOM accessing styles. That hurts readability. Either use jQuery everywhere, or native API everywhere. jQuery is kind of out of fashion nowadays, mainly because major browsers got much better in exposing DOM accessing APIs. Dealing with Http Again, since your code already depends on jQuery, I don't see why prefer over . Inconsistency of the code is one of the biggest issues when it comes to maintenance, especially in case of new hires. Separate Data from Logic Your mood to color scheme relationship is data that can be encapsulated in a separate place (apart from the places where it's being used). Say, you define color scheme like this: 

Also, some of the elements that you access via jQuery, are static. There's no point in searching for them many times like . These instances can be hold in constants, so that there is a bit less code and a bit less calculation at run time. 

I then used ent - pseudorandom number sequence test for checking how well the solution performs in terms of randomness. 

Duplicate code is asking for extraction If I understand correctly, you have the same code repeated in several places, which are detected by the tool you're using. You can always find a way to extract such code into a function/method and invoke if from wherever it's being used. 

Of course, this code is only a sketch to demonstrate the idea. It should be polished. For example, I find it a bit strange that even the original code does instead of . 

I wish there was a commonly known first-class concept of a Range in JavaScript... Naming Things The only thing that pokes my eyes is variable naming. IMHO, you can do better than , , or . For example, the following is more readable, since real words are being used and the function is more explanatory. 

Why do that if simple cast would work? Like this: where is whatever the specific type of the entity returned by the API. 

If the reader has to deal with RxJs, he/she must know what does. You may still express the intent, though. To express the intent, you may extract code into a private method. This will, of course, change a bit the way we chain, but the code is still readable: 

The application user experience cay suffer if we load too many records (scrolling through more than a few dozens of records is rarely enjoyable). The application responsiveness cay be at risk if we load even more data. The numbers vary a lot, but I've seen SPAs that show noticeable lags while displaying "just 300 rows of data". That was the result of many things including heavy client-side calculation, sub-optimal code, and other... The application can become unstable (may freeze or even crash the browser). If the contact/contactGroups API(s) does not limit the response at all, and returns many megabytes of data, SPA will attempt to consume whatever memory is needed to accommodate all the records. 

Asynchronosity Is NOT Easy Yes, it's not easy at all. Even with promises. I really recommend you to read about feature of ES2017 which simplifies things a lot. With your code would look much more "regular" imperative code. It reads as synchronous but acts asynchronously. Here's a sketch (not a 100% working code): 

Very similarly, the code loops through multiple results' child nodes () and does two things: A) populates based on each child; B) calculates the based on the last child which has . Nobody knows what holds and what's the . So, better naming things and function extraction would clarify what is being done in that part of the code. 

One way to achieve what you want is to use and may be operators. operator taps on a target stream and executes a function on each non-error event in the stream. It is designed specifically for this purpose, which you can define more generically as side effects: 

If in fails, the promise will be rejected and we will fall into lines - which is good. There is one problem though... The promise created in line () will NOT fail even though we failed to update the . Try debugging it and you will see what I mean. I think, what you need to do there is to re-throw the error like this: 

Refactoring Disclaimer: Sorry, I didn't have a solid chunk of time to test the code, so please consider it as a direction rather than an exact prescription. 

If you are not planning to add the function that disables "moving" of an element, you may even not need a local variable holding the reference to a : 

In my experience it's best to make the components aware of the Stores. Wherever it is possible and straightforward. "Dumb"[er] components are the way to go. Nowadays, I rarely use /, and only in scenarios of grid-alike components (which still sucks, and I'm rewriting those too). 

I think, only the author can judge how far or how close this result is located from the desired one. Update 5 - Visualizing the Solution (or How I Screwed Up) Okay, I built a little tool to visualize the generated "random" sequence via the proposed algorithm (since I didn't find one online). The following picture demonstrates "little regularities" in the sequence... Well, the "random" sequence has very distinguishable regularities, so the proposed approach does not guarantee good results. I think, it's valid to suppose that approach in fact guarantees bad results. :( @Wagacca, you were right in our conversation under my answer! 

Your original question has a partial answer here I believe. In fact, ESLint is telling you the exact method(s) to use, which is , for example. 

My approach, design, implementation, and performance description Both time and space complexity of the solution is , where is the total count of bits in a bit representation of the integer number. However, I feel there might be some smart approach (or a "trick") that improves the solution. My code basically consists of three parts. 

P.S. As a minor side note, I want to mention that some devs like to explicitly mention the //... interfaces in the class' clause. I am not sure whether it's very helpful or a big deal, but at least the compiler will complain if the is missing while class declares that is implemented. 

Make Them (Devs) Read The Code [Maybe?] The following comment is not helping me at all -- I see what the code does. 

Since you're using / (which are great), I recommend being consistent about using carefully. Example: 

does NOT affect the original Observable stream in any way. This function itself returns an of the same type as the original one. does NOT subscribe to the original , so the invocation is required down the road. does NOT react to error events in the original . Therefore, you may want to use to log the errors.