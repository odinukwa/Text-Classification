So signal propagation is kind of recursive process. Communication between neurons. Code. All stuff is placed in namespace . Auxiliary objects sann.h 

2.5 class Parser Abstract class that provides a protocol for all parsers (there is only one for now). It 

Project I want to write a library that implements simple artificial neural network in C++. In this post I would like to discuss only a part of my project, namely connection between neurons: synapses. The idea is to create an interface to implement ANN's. I decided to make neurons - elementary units of ANN, to be a substantive blocks from which one builds ANN. I think this approach provides big flexibility, though something becomes more complex or cumbersome. For more information please visit this git repo. There you will find the list of definitions of the concepts I use below and test example that (I hope) will help understand what I have reached so far and what I want it to be. Implementation Communication between neurons. Description. This section contains a description of how neurons communicate with each other. The idea is to have a mediator that performs such kind of communication which are and classes, so neurons do not know about each other explicitely. and classes are responsible for connecting of neurons. Also class performs output operations for a neuron, performs input operations for a neuron. Connection is carried out by the following steps: 

Note the weak typing of using - if these classes are used somewhere else, implementing as an explicit interface would probably be preferable. You could do generics, but that makes the chaining harder. 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

From a high level, I have to disagree with your class design and names - they're really modeled after your implementation (, , etc.) instead of your problem domain. I would've expected to see some classes such as , , etc. I won't attempt a straight refactoring - though there's isolated areas of code that could be improved on, the main thing that jumps out at me is the mix of concerns spread across all your classes. Currently, your classes all know way too much about and user input - you need to centralize that logic, and split into dedicated layers: UI, business, storage. Here's an attempt to walk through a design - which should hopefully give you enough to tweak the specifics to meet your needs. Any compile errors or bugs are intentional and intended for learning purposes. Just kidding - though I will take some shortcuts since MarkDown isn't the best IDE. Let's first extract out a class so we'll have something to work with: 

Problem The problem that I can see is that class has access to all stuff of class . I cannot specify pointer to class inside class because of method (sec. 3.2) that reads from a file and therefore cannot be declared as . Sorry for a lot of code and what is your advice to me? 

The structure of a binary file is different depending on what option was used. For example the size of the prefix is 78 and 278 bits respectively. My purpose is to provide user-friendly interface to parse data from oscilloscope. Result I chose to place all stuff in the which I named . 1. owon namespace structure The following is just a short description of the namespace. 

I am not interested in the first two options (at least for know) so I will concentrate on dealing with binary data only. Another fact is you are able to choose how to record the data. There are two options: 

emits signal. That means that tells to its to transmit signal to all receivers that are connected to it in turn tries to update with signal value from in turn asks its to transmit weighted signal from . checks if in the list of senders and if so returns weighted signal and sets status of as being received Then asks its if it is complete which means that signals from all senders have been received and if so emits itself 

Now, we'll need something to keep track of the inventory levels. We could use a simple for this, but let's go ahead and abstract it out into an class, so that we'll have a place to put some convenience methods. Since we know we'll need to be able to remove an item by name (not caring about the price), we'll need some help to find that entry. We can also add some convenience methods around adding a product. 

That should clean up the code some. As I started typing that, I figured I'd check for edge cases too - since is filled with them (eg., it includes the negative sign in the length, returns if it overflows, etc.). You're handling the case, but a couple of edge-case values fail: 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

2.7 class PointIterator This class is developed in order to provide user-friendly iteration over the data points e.g. inside a loop. 

creates an instance requests connection with If agrees to connect then it asks its to register as a sender, after that registers as a receiver, assuming that has instance 

Discussion Neuron class Emit function The main problem I see is that this function might be waiting for a long time before return. This is because of recursive process of signal propagation. The worst case is when all the receivers has almost full dendrite and get the last signal from a sender and emit theirselves and this process repeats until the last neuron in the propagation chain. is it a problem or I am missing something? Creation of Dendrite and Axon I have and as a pointers. So they are initialized as in the constructor. When they are needed they are created via operator (note that instance can have only one instance of and ). I suspect that it smells like potential memory leak. Would destructor resolve this problem? Dendrite class Struct Synapse I am not sure about declaring inside a class. Is it bad practice? The motivation is I do not need to use that struct outside of this class. And also I need to store 's together with its status and weight. IsComplete function I see that I check if signals from all senders have been received by iterating over entire dendrite tree while having function that already responsible for setting statuses of senders. Is it actually a problem or kind of a design flaw? Mediator class As you could see and has a lot in common. I am thinking about create a class to place all of similarities inside it and then inherit from this class. What do you think? So let me know what do you think about it. As always any suggestion, critic or help would be appreciated. And sorry for a lot of material. 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload.