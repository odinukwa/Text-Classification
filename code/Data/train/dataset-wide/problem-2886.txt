which use the idiomatic, efficient range form which allows the compiler to bypass some index range checks and calculate len(a)-1 once. Unless there are at least two array elements, no sort is needed. The upper limit for the outer loop is len(a)-1 not len(a). Especially in the inner loop, avoid unnecessary address calculations, index range checks, memory accesses, and exchanges. Also, avoid inefficient comparisons. 

Your rationale is "I easily forget some things." That's not a problem. What is a problem is that you don't know how to easily find this information in the documentation. No employer wants employees who write idiosyncratic, unreadable, and unmaintainable code. Similarly, you write, 

Code should be readable, correct, maintainable, robust, and reasonably efficient. Readability is a prerequisite for the other characteristics. Start with Go Code Review Comments. You write: 

The most important property of a program is that it is correct. For the Caesar Cipher, Latin letters are rotated, in either direction, by a fixed shift amount. Decoding is the reverse of encoding. Your algorithm looks suspicious. I tested your algorithm against my algorithm. Encoding "Hello, 世界" for shift +25, your algorithm gives "a~\u0085\u0085\u0088, 世界" and my algorithm gives "Gdkkn, 世界". Your algorithm: 

Note: I don't claim to be an expert in principles, I do understand a bit though. Back to , violates the principle (The most frustrating concept to me). That is, when you add a shape you have to go and modify the code by adding an , this can easily solved by using , 

Code duplication is not a nice idea, it's a massive indication of code smell. You can create a helper class for your common code, ex: getting db connections, creating data tables, etc... 

The first thing you expect from a queue is to be able to , and for some reason you are hiding this function by declaring it where this should be . Do I really need to care about growing and shrinking the array in this queue, I am not supposed to know that they exist, so these should be declared . 

Looks fine for me, but such a class should be , because it does not make sense to be able create instances of this type. 

The unnecessary conditional path and indentation are a distraction. The most important path is the correct path. It should be easy to read the correct path. 

The code does not depend on the iteration order over maps. The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. A zero value map () or an empty map reasonably returns the zero value int (). In all other cases, for both 32- and 64-bit s, the result is obviously correct. For example, 

Now we have an easy way to test. Let's make sure that we can handle all reasonable values. Here are some values that you don't handle. and so on. You should always expect the worst from user input and handle errors gracefully. For example,' 

The code in Abdallah Hodieb's question is good (LGTM). I prefer the simpler, more readable form of the first loop. 

Code review is an iterative process. If there are significant changes, open a new question with the revised code. 

When you see yourself going and editing the same function again and again to extend its functionality then thats a code smell. The problem is that whenever you add a type you have to add an if condition to your converter. So the conversion could be the class responsibility. in Java 8 you can use for that and if you don't have Java 8 then is your friend 

As you can see here no static methods anymore, static usually presents a global behavior, and I need to force users to go through the constructor so I make sure weights are computed properly. I suppose that what you using is algorithm (not sure though), where your class name is , that's a bit misleading because is not the only algorithm and it doesn't work with negative weights, and you need something like Bellman-Ford for that.If you don't want to support negative weights for now, it is fine, but you should be able to add this functionality in the future.And this leads for extracting the Route finder to an interface 

The Go programming language was designed to operate at Google scale. Go programs are usually written to be reasonably efficient. For example, assume that your function is used by Google's search web crawler on billions of HTML pages (with multiple scripts per page) per day. I see opportunities to make your function more efficient by using CPU time and memory only when necessary. To estimate how much your function might be improved, I ran some Go benchmarks. 

Your program is running 100,000 client connections using goroutines. One connection has a problem, so you crash the program. We have 100,000 very upset customers. Handle errors and fail gracefully; return errors; don't or . See Errors. 

Go uses the testing package to write tests and benchmarks. These are the results for benchmarks of the various selection sort functions. Each benchmark sorts an array of 1,024 random integers from descending to ascending order and then sorts it from ascending to descending order. 

What makes your abstraction leaky is the fact that is not abstract enough, that is, Manager and client shouldn't be there. 

And because their values are known at initialization, its good practice to declare them . your method is not , use instead. Some validation on the parameter is needed as well. 

Yes , you don't need to iterate through the map to know if it contains a certain value or not, you can just call 

And now you are sure that suit always has a valid value and there is no need for the error msg in the method. Your in the Card class is not type-safe, it will throw an if the passed parameter is not a Card, You can instead implement 

This gives a clearer hint to class users that the value they asking for might not be there. If using then is there, otherwise Guava is your friend 

Or implement Guava suppliers anonymously if you running java 6 or 7. You can add an interface for convertable things that your classes can implement. 

Even if you write impeccable code, you will still be judged on the quality of the external packages that you use. The packages from are of very low quality. Here's my complete program. It's a first draft. 

Your is a massive clutter of messages. That may make sense for debugging, but it doesn't make sense for production. What is the purpose of this and similar statements. 

Go is statically typed. Every variable has a static type, that is, exactly one type known and fixed at compile time. You are not in dynamically typed Python anymore. You could use reflection, BUT DON'T! 

I reorganized your code. Don't write code as a heavily indented stream of consciousness. First, write the normal flow. The first step in a code review is to read and verify the normal flow, it should be obvious. Second, add exception handling. Third, add error handling. Sensibly minimize indentation. See Indent Error Flow. For example, a simple first draft, 

Threads??? Once you have threads in your code, your code becomes obsolete even if it was written 2 seconds ago. are the way to go, and you can easily replace your code by a single Task that keeps running and a function that accepts Tasks 

I wouldn't start this Task in the constructor as you doing with the ,thats quite dangerous, I would rather have a method called Start that does the heavy stuff where I am sure its gonna get called after the object got constructed properly. ADVICE: Such a data structure is reasonably hard to implement properly, I would try to find something implemented and tested. 

You have field that you mutating in a multithreaded code, this field can be cached and might ignore you changing it. You can declare it as to avoid this behavior. 

This code here is a bit dodgy, you shouldnt never trust values you getting from the , so you got to handle the exception and refuse the request if the value is not parsable to