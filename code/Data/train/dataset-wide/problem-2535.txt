weird function name Did you mean pythagoras? Oh, no, you meant . what does do? What are f,g? It looks like it returns two values based on , but it is not clear to me what the expressions signify. How did you get those expressions? It probably derives somehow from and its derivatives. Maybe it would help if you could show us what the code looks like for the arclength of the arc formed by between -1 and 1 (it should return 2). arc length algorithm Also, the arc-length runs the risk of running into a recursion-error. And it's slow due to function calls. Suggested implementation (typed on phone, untested): 

I know that threading is a bit of a problem anyway here, but I would just like to comment on this specifically: by writing you are waiting on the thread to finish before starting the next iteration. This gets read of the threading all together, as there will only be two threads alive at a given time: 1 worker thread, and the main thread waiting on the worker to die. I'd suggest writing it as: 

(Why I chose this: I saw that some arguments were recursion-specific, and were basically saying "Don't do this when you're already recursing". A clear pointer that we were mixing two concerns, which are now better separated). Note that splitting like this can be somewhat dangerous when this method is called somewhere else as well with the extra parameters. Sufficient unit tests would detect it. Bisecting You probably saw I named the helper method . That is because it uses a fairly trivial bisection algorithm. The algorithm works recursively. Recursive algorithms are really nice, but Python has a recursion-limit, no tail-call optimisations, and you are also building subslices of . In fact, look at the following lines: 

Culture-sensitivity You're using the pattern - only a few countries use dashes between the components and it is not ISO-8601 compliant. If this is intentional then that's fine - but if your users are coming from a variety of different countries (with their own date-formatting preferences) then you have two choices: 

I want to get a second-opinion on my use of . and only read the -value of a Stored Procedure after the has been closed. This is a problem if you want to interrogate the return-value to make a decision regarding how you want to read the data. In my case, the stored procedure I'm calling returns multiple output data tables followed by an integer return value. The number of output data tables is variable. 

Use ISO-8601 () which is unambiguous and as a bonus: is lexicographically sortable. Use Moment's built-in localization ("i18n") support: $URL$ 

The first alternative that comes to mind is to remove the negation operator () from each and move each subsequent operation to a branch under the , but this results in code many layers deep as there's about 8 or more result sets. Another alternative is to replace with a and throw my own custom exception, e.g. and in the block that surrounds the I would swallow the exception and have the return-value interrogation code in the block, or in code immediately following the block: 

But the problem with that is that statements don't define where the exception lands: so removing the statement means the program will compile, but crash due to an unhandled exception when it runs, whereas removing the label means the program won't compile, which is safer. Furthermore it avoids the expensive cost of throwing and catching exceptions as well as sticking to the mantra of "use exceptions for exceptional circumstances, not for program flow" - which is what it would be if I did convert it to a //. Is my use of then justified? 

Also, in Dijkstra's algorithm, the key point is not the nodes, but the edges. An edge is a tuple (source, destination, weight). But let's first see what we can clean up before tackling that. Your takes a list of things. It claims to be a list of nodes, but it's actually a list of lists: edges. So maybe it would make sense to define a namedtuple : 

There are so many things going on, it is a bit worry-some. Also, you might want to add a space around the operator, causing the need for yet some more work. By using string formatting ($URL$ you can make it a bit simpler: 

It's a bit hacky, perhaps, but it should lower the number of queries, and as such improve results. [edit: I just found a better way] Using ($URL$ you can rewrite it a bit: 

The difference will be that this gives a list of tuples instead of a list of lists. That's hardly going to be a problem in the following. 

(Here, I use the attribute of a cursor which returns the number of rows changed in the last query: $URL$ I tried to use more sensible names for the columns, and also used string-interpolation for the values that are hopefully not under user control (and can't be done using parametrized queries anyhow), while using paramatrisation for the which is more likely to change. 

jQuery Your code uses jQuery, but you don't seem to be using any features of jQuery that offer any advantages over the DOM - unless you need to target older browsers you can remove your jQuery dependency and thus make your code better: faster (less abstraction, fewer dependencies to download), more portable, more future-proof, etc). Simply replace with and with (you can alias it for brevity if necessary: ). Time-safety The function, when called, returns the current time value the moment the function is called - your code keeps on calling the function which could return different values each time it's called (if there's a long-enough delay in the interpreter, or if your code executes on a time-unit boundary) - issues like these can cause bugs if midnight at the end of a month happens while your function is executing. For this reason, you should get the value of "now" only once, at the start of your function, and perform all operations on that value (you should treat it as an immutable value too, even though is mutable, as that's best-practice). 

When using locales, use the "locale formats" rather than specific formats. Moment uses to denote a "numeric date" (e.g. "09/07/2016" in en-GB, "07/09/2016" in en-US, or "2016-07-09" in ISO-8601). Everything So your code would become: 

Get from their website Modify your initialization code: // Get the ISO culture settings for the current user, e.g. "en-US" or "es-MX": var locale = window.navigator.userLanguage || window.navigator.language; // Configure moment: moment.locale( locale ); 

First of all, the could as well be written , but the point is: sometimes returns 1 (and other times 0 or 2). In that case, you'd call , which is basically a do-nothing operation. In fact, I'd hope that would throw an error in this case, but I can't check your code there, so I'll assume it will happily move whatever you tell it to. Unreachable conditional? One of the conditionals in your code is the following: 

We're modifying here, instead of asking it to modify itself. We should be writing something like here, or maybe ('tick' is what's commonly used to notify an event about stepping forward in time). 

Why do you even have the /? It adds nothing of value. Also, the parameter is now a list of , instead of a . Another thing I'd suggest doing is using the attributes of our class we just defined. 

Which is much better. Getting the (random) element. Defaulting You already mentioned you were not sure about the defaulting. Important should be the question 'why the defaulting'? From what I can see, the only reason for the defaulting is the recursive algorithm you use, which is a recursive bisection algorithm (or binary search algorithm). It would be good to separate the bisecting from the choosing. 

What is referring to? This will also be executed for question 2 to 10. Maybe and would be better names? Leaving them be for now, but it's something you can ponder about. Next, the creation of the 'puzzle'/question.