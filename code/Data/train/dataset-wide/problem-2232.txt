If this is a workgroup, then may be the name of the computer SQL Server is installed on. Obviously, the account you're setting here will have to exist on the computer hosting SQL Server. This setup also works for domain users trying to connect to a SQL Server instance in another domain. 

There is a free version of DB2, the Express-C Edition, which includes most of the features of the "real" DB2 servers. It doesn't include some features, like label-based access controls or table partitioning; and it can only use up to 2GB of RAM and 2 processing cores. Have a look at this article to see what you may be missing out on from some of the "upper tier" editions of DB2. 

I will suggest to have a table valued function. This function will accept your string as an input parameter and then return a table by splitting the inputs separated by ";" in different rows with an index ID. You can use this function internally with you logic and determine the MAX(Us) from mapping table. Below is the sample example for the function. 

I guess you can try something like below. This is combination of identity column primary key with the computed column. Hope this helps. 

You can also try to below approach. ISNULL is more convenient that if-else structure. But this approach will only work when you want to compare the result with NULL. 

The function will ensure that you'll always have at least 14 characters (it implicitly casts the first argument to , and then pads on the left with the last argument to at least the number of characters specified in the second arg), which the function can then cast to a . This won't work if you're on the Mainframe DB2 (the only type of generated columns DB2 for z/OS supports is identity columns, row change timestamps, or rowids). I'm not sure about DB2 for iSeries. 

During the last step, all of your SQL is run through the Optimizer, which takes into account all of the statistics and various paths that the DB2 engine could take to fetch your data. It then chooses the path it came up with that has the lowest cost associated (with newer versions of DB2 [DB2 10 for z/OS], it may decide to take a "higher cost", but "lower risk" path). Once the path is selected, it is compiled and becomes a package, which is stored in the catalog (you can see all of your current packages with (z/OS)). Finally, there is a last piece that allows our programs to reunite with their packages, the . You create a plan by doing another BIND (). A plan is a collection of packages that the program is allowed to look through to find the package that shares the same name. With COBOL, you specify which plan the program should search in in your JCL. 

Only thing is remaining is to include an exception for the NA or "Input Does not exists" case which can be easily handled. 

EDIT: One additional point. You have to very precise while making us the if logic over here. As the same procedure needs to be called thrice, if may have an performance impact depending on what logic you are trying to implement. If possible make use of the same if block to incorporate all logic for the specific return scenario and keep the generic part in the head. 

What we have understood here is you want to migrate selective data from selective tables from SQL 2008 server into SQL express edition. Have you considered using the import/export data feature on the SQL management studio? Import/Export wizard can be accessed by logging into server using the SQL Management Studio. Here is the link to MSDN library. You can select the source as SQL 2008 server (production) and destination as SQL Express Edition (development). And then map the required tables and columns. If required, truncate the tables from the development environment first if you want to have a clean data. Once data is migrated, you can perform the update queries to remove/mask any personal or confidential data. Let me know if this serves the purpose else we will delete the answer later and will think something else. 

In short, compiled code goes through these steps to generate a usable : Precompile -> Creates a DBRM (with C[++], the precompiler outputs the precompiled SQL to an HFS file, which can be sent through the command-line bind program) -> the DBRM is optimized and a set of access paths (a ) is created -> The package is added to a , which is a group of packages that allow you to create a "search path" for your programs to look through. Since these programs are statically bound, if your table statistics change drastically, then the access path the optimizer chose at bind-time might not be the best path anymore, and re-binding will allow it to re-evaluate the SQL and perhaps choose a better path. 

Accept additional input parameter (like an integer with possible values 1,2,3) If passed 1 in the input parameter, at the time of returning result return the first result set. If 2 in input parameter then return 2. In main procedure, call this procedure thrice. Each time with different input parameter number (i.e. 1 , 2, 3). 

Considering you have to create a single procedure to deal with three result sets, below is the solution. But as Aaron Bertrand have suggested in comments, if possible try having three different procedures for three different result set. If three different SPs is not accepted due to complex logic or architectural limitation, then 

I think you should be able to use the command to set up your connection in SSMS. Create a shortcut on your desktop (or wherever), and set this as the target location: 

When you run a program through a DB2 pre-compiler, runs through your program, and if it finds any embedded SQL (in COBOL, these are statement blocks that go from to ), it carefully rips the SQL out, and replaces it with a call to the COBOL-DB2 interface. After this, there are two outputs of the , the COBOL source that has had all the embedded SQL removed ( from now on), and a that contains all the SQL that was removed (). Precompile does do some basic syntax checking, but be aware that the checks are only based on your table declarations within the program. It doesn't attach to DB2 to verify these! These two files are completely separate, and when you run the COBOL program, it has to find an and a that were generated at the same time. At this point, is compiled and linked with the standard COBOL compiler into a and placed in a load library to be used later. However, there is still a lot of work to be done with , the DBRM. This is where comes in. is sort of like a compiler for the embedded SQL code, and the output of the "compile" is a . In order to BIND the SQL into an executable "package", the BIND process attaches to DB2 and does a few things: 

You can make use of the procedure to get the logical foreign key information. But the limitation is you have to execute is by passing the table name as the input parameter. More info for the same can be found at below MSDN library. sp_fkeys Alternatively you can make use of below query to get all the tables from sys.tables and check if the same table object_id exists in the sys.foreign_key_columns. 

If I understood correctly, if stored procedure is called with @vCol1 = 'AA', @vCol2 = 'BB' and @vCol3 = NULL then you want to update only Col1 and Col2 keeping the Col3 value intact. Then you can go with the following solution. I agree its not the best one but it will get work done in simple manner. 

(Assuming DB2 for Linux/Unix/Windows here, since you don't specify, but this will probably also work on the other platforms.) You don't have to do funky date math, there is a built-in function that will do it for you: 

I see your Info Center link goes to LUW 9.7, and you mention that you've programmed in Java, but most of the experience I have with binding is with DB2 on the Mainframe with COBOL. So, you may need to adapt the explanation a bit (but generally, the concepts should be the same). I believe that binding is only relevant when you are compiling programs that include embedded SQL which is precompiled (statically bound SQL). If, for example, you're using JDBC, you aren't required to run a BIND. The JDBC driver will the statement dynamically.