The inner loop has now grown to 8 instructions from 6, but we have banished the branch mispredictions: 

This is just a "saturating" shift, which returns zero if the shift amount is 64 or more3 and which compiles to a branch4. It also turns out that the loop has no less than two very slow division instructions every time around, coming from the two operators in this line: 

Bring back the Vectors The next step is to vectorize this. This is getting long so we'll skip the first version ( which clocks in at 0.27 cycles per candidate) and just go to my final version, : 

The inner loop here runs once per prime and processes 64 bytes per iteration (512 odd candidates), in 14 instructions. The the two instructions are doing the heavy lifting of combining the bitmmaks into the two accumulators, and the rest is mostly just managing the indexes. The outer loop runs when the bitmap for all 30 primes have have been accumulated and stores the bitmap into a temporary buffer provided by the caller. We periodically break out of the asm code to examine the generated primes (in this case, simply counting) - see for some details. In a real implementation, you would still want to do the handling periodically, but you might inline it right into the function. Let's time this guy: 

I'd like to use lock objects that are specific to the person I'm updating. In other words, if thread A is updating Person 1, thread B is blocked from also updating Person 1, but thread C is not blocked from updating Person 2. 99% of the time, I don't really need the locks since I'm working with different Person.Id values. In the occasional situations when I am working with the same Person.Id value, I want to lock around some read/write code. The following code is working as I expect. I'm looking for any "gotcha's" I may have missed, or better ways of accomplishing the same thing. I decided to use the .NET Cache to store the lock objects so I don't need to worry about cleaning them up later (the lock objects are removed from cache when they haven't been used for a certain TimeSpan). This code provides the object to lock on 

Each bitmap is "normalized" such that the LSB is always 1. Then the loop is very simple: it loops over all 30 primes, and shifts the bitmap by the right amount to "align" it, and ORs all the results together. In this way, the loop handles 64 candidates. The shift amount is simply the amount need to correct stitch the bitmap from the last iteration so that it is periodic. Using a 16-bit example for sanity, the bitmap for in binary is . In the next iteration, you can use the same one since the effective 32-bit bitmap would be . Oops, two adjancent 1s! You just need to shift it over by 1: and now it stitches fine. In general the stitch amounts for any prime have period and take all the values between and inclusive. The last line in the loop calculates them. Let's try this guy: 

In this code, assuming 300 posts are selected from the database and 10 posts are specified per page, then there should be 30 pages. 

To generate a password, I generate a key using RNGCryptoServiceProvider. The key is 9 alphanumeric characters long into which I insert a single non-alphanumeric character for a full length of 10 characters. Having a mix of Uppercase, lowercase, numbers and symbols and being 10 characters long, as a plain text password (which you'd enter when logging in somewhere), this password should be more than adequate for most situations. 

I feel like I had to invent a whole new way to do this because I couldn't find anything that did this the way I wanted to... The basic process involves reading changes to cells and capturing information about those changes as they relate to the actual Entities in question and then persisting them to the database. Here's the XAML. I didn't use databinding because I don't quite understand it yet and I'm on a bit of a deadline for this one so that's item number 1 on my to do list when I get a break. Note that this project has been my first every foray into WPF. I've dabbled a bit in the past but I've really pushed myself to do things properly here... As properly as I know how anyway. 

Let's review this code purely from a performance angle, without a focus on style or anything else (in addition to optimization suggestions, Peter already mentioned several things in areas other than performance). First, you can play with all the algorithm discussed here in this github repo. I compiled it on Linux but it should approximately work on Windows if you have or - if you add a thunk to adjust the calling convention. If someone really wants it I'll do it. Profiling If you've ever asked for performance help, no doubt someone has told you to profile, profile, then profile some more. So sure, let's start there. I'm going to use Linux's since it is awesome and free and available on Linux, but you can get the same information presented nicely in Windows using VTune or maybe with this stuff. Anyway, let's run on the original algorithm to get a feel for any high-level issues: 

To keep things simple, all comms between client and server send and receive delimited strings which are read by each component and handled in a particular way for each. Is this a fairly decent implementation or a client/server program? How can I improve this or make it more functional? 

I can then validate the input at login more or less with this function - I haven't tested this code since I'm writing it for the first time for this question. 

From here the user clicks on a save button which loops through the changes captured in this list and updates the relevant records in the database: 

The Client is much the same, except its not listening for connections. It's only job is to send requests to the server and display the result that the server sends back: 

The first row (for prime 3) means that after doing a 64 byte read at position , the next read should start at position to properly stitch the bitmaps together, the next at 2, and so on. The row for 5 says jump from 0 to 4, then 3. Notice though that these are simple increments the prime. So the series for 5 is just "plus 4, mod 5": . All the rows are similar. So if you are reading 4 consecutive 64-byte bitmaps for prime 3, you can do it directly like this, without any index calculations at all (assuming has the base of the LUT for the prime): 

The is the "magic location" to load from the bitmap array which will have the correct alignment without needing shifting. We precalculate the offset values (they have a period like almost everything else) and store them in , and take the next offset on each iteration (the last line wraps when we hit the period). How does this one do? 

I don't think the user class you provided satisfies the Single Responsibility Principle. I can see a few situations that may require changes to the user class. 

(1) is related to the user class and changing the class is expected. No problem here. (2), (3), and (4) are really not the responsibility of the user class, yet they would probably require changes to the user class. You should consider creating an additional "address" class that can be reused for the physical and mailing addresses for the user. The user class could contain instances of the address class, and would not require changes if the address functionality changed. Any new classes that need address information could reuse this class. You should also consider creating a new class (let's call it userProvider) that is responsible for the CRUD functions. This class could have the CRUD methods with a user object as a parameter. Your user class could still define the CRUD methods if you want, but would simply pass the user instance to the userProvider class, which would be responsible for storing/retrieving the user information. 

Well, it's 2 applications really. Each one does its own stuff on the front-end. It's the networking that I'm most concerned about. The Server starts listening for connections on the specified port as soon as it starts up. When clients connect, it accepts, serves and boots them in turn (or rather that's the idea but I think there's a flaw in what I've got here). The server is multithreaded to handle requests on new threads so as to avoid locking its UI while it works. 

I used to use PBKDF2 but I was informed that bcrypt is better so here we are. While I understand the rule "never use your own auth", is this code likely to provide decent security? What sort of vulnerabilities are present in implementing this system for security?