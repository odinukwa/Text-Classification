Well, the problem statement is broken. Maybe this is a trick question? In the situation that the value to be inserted is at the beginning of the list (perhaps the list is empty, or the value is small), then you can't successfully control the changes needed to modify the head reference for everyone who has it. The code you have implies that the possibly new head is always returned after each call, but you run a risk of creating multi-headed lists with multiple heads, if the code outside your function does not do the correct assignments with the head. That sort of risk is not acceptable in a Java library/function, and thus your encapsulation is wrong, etc. In front of an interviewer, I would recommend that you say something like: "Well, this function would not be useful in a Java context, the data should be encapsulated and the node should not be exposed to the user. The function should have no return value, and should not take in the node as a parameter, but instead the function should be a method on a class that encapsulates a sorted list" Having said that, though, and looking at your code, your code does as good a job as can be done in the circumstances, and it has good style, naming, and formatting. If I was really picky, I would suggest that you reverse the if/else condition: 

it is now relatively common in Java to require the class is given at the same time as the constructor. If you have the following code: 

There are a few optimizations you can do to reduce the amount of work you do. For the most part, it comes down to understanding the math behind the concept. First off, if you have found the minimum common multiple for a small set of numbers to be X, then want to include another value in the set.... then the resulting minimum common multiple will be a multiple of X. Say, for example, you have the values 2, and 3, and the minimum multiple for those is 6. Now you want to find the minimum common multiple for 2, 3, and 4, then the resulting multiple 12 is also a multiple of 6. If we want to add the number 5 to the set, becoming 2, 3, 4, 5, then we know that the minimum common multiple will be a multiple of 12 too (and it is, it's 60). Taking it another step, if we add 6 to the set, well, 60 is already a multiple of 6, so there's nothing to do.... OK, so that's optimization 1.... instead of adding 20 each time, we can add the previously calculated minimum .... and now we are adding 60 already....which is 3 times faster than adding 20... throw 7 in to the mix, and the multiple is.... 420 ... which is now 21-times faster than adding 20's. The next optimization is to do things backwards.... instead of starting from 1, start from 20.... The smallest common multiple for 20, and 19, is 380. and in to that, add 18, and the multiple is.... 3420 .... now our increments are much larger than 20.... In addition to the larger increments each time, by starting at the end you also already include lower multiples. For example, 20 is a multiple of 10, 5, 4, and 2 so when we get to those lower multiples there will be nothing to do. Putting these two optimizations together, we end with the following code: 

but, inside the function, you never use . Why is it a method on an instance that you never use the instance's data for? It should be just: 

The text-to-key problem is one that has multiple solutions. The Map solution is a good one, there's nothing wrong with it. There are two other algorithms that are good too. First, though, please convert the char-to-key to a function. Having such a big loop is a problem. 

Note how I have also used the conventional C# style there for the braces.... 1. Switch: A switch statement can work on chars: 

Enable a break point at about that line Hit f5 to refresh the page. This should cause the page to partially load, and the break point will be where you set it.... Then, in the "Watch" tab we can inspect the array, which is the 'shuffled' collection of cell values that the grid is initialized with. Each member in the array documents the exact value which is placed at each location. This can be used to chose exact pairs without concern for mistakes. 

General Your methods all use a C-like system for the tree Nodes. In Java, the tree should be an Object, and the Node class should not be publicly visible. In other words, you should have something like: 

This code is begging for an EnumMap as the data store, rather than the individual variables. Creating an Enum with values like: 

That will always print Equals "true" for you, but it may not always print Same "true". Your code could likely be reduced significantly to just: 

Brute Force. Your use of go-routines is pretty simple, but effective. The part I don't think is best, is the use of the channel. The channel itself is good, but the control structures you have to read content from the channel, could be better. In fact, you have a bug in them (although you are lucky that the data means you don't encounter the bug). Let me describe the bug, first. You assume that every go-routine is going to add a value to the channel (there will be at least one palindrome). You also assume there is at most one palindrome. If there end up being fewer palindromes than routines, you may end up "hanging" on the channel when all routines are done, but no values are coming. If there are more palindromes than routines, you may have the "max" palindrome happen later in the channel than you read. I would recommend using a wait-group for the go-routine, and then closing the channel in the completion. In essence, I would restructure the code: 

General Style: Use functions where you can. You have embedded all the code in to one method. For many reasons, you should create a function which takes the 100 value as a parameter. Additionally, the purpose of the code is to return pairs of numbers that have 100 as the product, so what you want is a container to store each pair. This is a start to turning your code in to Object Oriented code. Classes (OOP) A container for a result, which is two values that multiply to the target, would be called something like CoFactors (Factors which together make the target). It would look something like: 

Count Down Latch option The previous atomic/link free code has an issue with the sentry node... it should not be a field variable, as a result, it is holding a reference to the entire chain of nodes... and that's a problem for the Garbage Collector. Fixing it made it significantly slower... for a reason I am unsure of. As a result, have worked it out yet another way, using a : 

This looks for an asterisk, followed by characters, and then a (zero length) word-boundary. Now, both and match that, since the happens before the asterisk. The negative lookahead would be useful after the word-boundary. Consider the following: 

Now, there's nothing wrong with that, but it is not the way I think about things, so I like to code it differently. I like to have "positive states"... where I know where things are at. I would prefer the logic: 

Nice little system, I understand though why you think this code could be better. I think there are a few things which would make a difference. The first is a try-finally block, and the second is a simpler loop First, the try-finally: 

Now you have a single SQL alter statement to run, instead of 20. This will have less impact and reorganization requirement on the table, and will likely run significantly faster, especially if the table is populated. 

The above will generate a random number, with uniform distribution, between 100000 and 9999999999 (and here, as an ideone ) 

???? Your Node class stores it as an , so there is no reason to do the multiple conversions. The algorithm you have used for the 'sorting' is similar to what I would do. There are a few nitpicks though (one of them is not so small....): 

If you really require the file locking, then do it all in one process anyway, and don't use the intermediate byte[] array: 

The other prompt allows you to simplify the other aspect of user input.... This is a summary of what my main method looks like, with the instance available: 

Text manipulation like that is always a pain. I like to extract functions for things like this, though. 

Running the CountDownLatch code with the previous LockFree code, and the original, I get the following results (Note they were run at a different time to other results in this post, and are not comparable with them). 

The above code (included in a function) will encode each char to a key, and unmapped chars will return 1. 2. In memory lookup A second common way to do this is to prepopulate an array with the indexes for each char: 

Your code can accommodate that easily. Your Characteristics should include . , , , and do not apply to your data. and ... these are the complicated ones. They are mutually exclusive. If you cannot modify the source data, then you cannot modify it in a concurrent way. If it is concurrent, then it is mutable. Bottom line, your characteristics should be: 

I am not particularly fussed with the name . This is a generic class ... if it was directly linked to Partners, then it would be different. You could probably do something to indicate the underlying data infrastructure, like which allows you to understand that the tool manipulates Lists to show different views of the data, and, in this case, two tools are available for modifying the View, sorting, and filtering. Other things I think you should consider changing though, are: 

You will see, and recognize this pattern anywhere. Because that pattern is so recognizable, I prefer seeing it rather than the slicing and dicing your code does. Additionally, since the formula for the number of iterations is so readily available, it makes sense to pre-size the output array you use. Pre-sizing the output array will make a significant performance difference. Further, even though the 'classic' for loop is used here, the performance will be fine. Other systems requiring slices or maps of list subsets will require additional work which, despite being 'idiomatic', will not necessarily be faster: 

So, if we have a folding function, that takes a new row to solve, and a collection of partial solutions that have been solved so far, we could have a folding function like: 

Using volatile is no longer a recommended way of handling memory access. A much better way would be to use an . It has increment and decrement methods to help. Additionally, you still have race condition in your method even though it is synchronized.... you could have a situation where the nThreads changes (up or down) during execution of the playSound method because the Runnable is running in a different method. To avoid the race condition, just pull the nThreads in to a local variable once and reference that. As for your performance problem, it is here: 

Then you should also support expanding any directory results from the chooser. This will make the behaviour in the GUI match the commandline more closely. A second problem is in the JTextArea display. It should have scroll-bars so that you can inspect the results before copying/pasting them. While looking at those changes, I discovered that you were doing all your File IO on the event-dispatch thread... this is bad practice.... I had to do the following: