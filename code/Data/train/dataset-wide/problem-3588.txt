Webmin is where most security questions would come into play, as it is where logins and such happen. Webmin has a very good security history, and its security record is public: $URL$ It's been several years since the last serious root-level or direct data exposure exploit was discovered, though there have been a few XSS vulnerabilities in the past couple of years. No software of Webmin's complexity will be completely bug-free, including security bugs, but we do take security issues very seriously, and they get fixed quickly. I think Webmin core is about on par with OpenSSH in number and severity of vulnerabilities discovered in the past five years, and I think we all agree that OpenSSH has a really good security record. PCI compliance is entirely possible in a Virtualmin system, as nearly everything related to PCI is provided by the OS (so if your OS is CentOS, then you'd take the same steps you'd take with a non-Virtualmin CentOS system; which isn't all that much). We have hundreds of users who have gone through the PCI compliance process. Note that the PCI scanner is kinda dumb, and will flag the CentOS (or Debian or Ubuntu) standard Apache package as being old and insecure (and since our Apache build is just a rebuild of the OS-provided package with suexec docroot set to /home, ours also gets flagged)...but the OS vendor applies security patches, which correct security issues. So, you have to add an exception for that particular package. This is well-understood by the PCI folks, and you won't have any trouble from them over this; it'd be more dangerous to build Apache from source, get PCI compliance, and then forget that you'd installed from source. We've seen security issues from this kind of thing a lot over the years, so we definitely recommend you stick with standard packages whenever possible, so that normal updates via yum or apt-get will work (and Virtualmin has an updates notification module on the System Information page to let you know when you have updates, if you aren't running them automatically). In short, I believe Virtualmin security is at least as good as the competition, though I'm certain no one has a perfect security record, since the target that the most popular products provide is huge. Webmin, cPanel, and Plesk are all prime targets for black hats because they have root privileges, and run on millions of machines (I know Webmin does, anyway, I'm not sure of the numbers for cPanel or Plesk). And, since jeffatrackaid has gone to the trouble to bring up our competitors forums, I'll mention that Webmin/Virtualmin also has a very active community at $URL$ (and if you like the old school mailing list support process, $URL$ has the hookup). Disclaimer: I'm a developer on Webmin and Virtualmin. 

Yes, you would enable SuExec. $URL$ Specifically, the section that begins Using suEXEC. Quoted here for convenience: 

We recommend you use SCL versions of packages, so that the PHP versions can co-exist peacefully with each other and not cause the conflicts you're running into. I've got Remi's PHP 5.6.15 packages running on our new server, under Virtualmin, and it's working fine (I did have to tweak the detection code in php-lib.pl, though that won't be needed in a few days when new Virtualmin comes out). Also, you should use the fcgid execution mode, and not mod_php. mod_php can only exist in one version in a single Apache instance and will never work with multiple versions. fcgid is the default execution mode in a Virtualmin system installed with install.sh, but it is configurable in System Settings:Server Templates:Template Name:Apache Website. "Default PHP execution mode" is the option you want, and FCGId is the right value for using multiple PHP versions (and for a variety of other good reasons). Current version of Virtualmin doesn't support all of the SCL PHP packages, yet, but the next version will handle arbitrary versions easily (and will likely have the ability to query the SCL command to figure out what your preferred PHP version is; I don't know how much of that has been implemented yet). There has been quite a bit of discussion about this subject in our forums over the past few weeks, as SCL has gotten more PHP versions, and as Virtualmin support for SCL packages has been expanded. There's some docs here (which I'm not sure if Eric has updated yet, to address recent changes in SCL, but they will be soon if not already): $URL$ 

This is covered in the Webmin documentation here: $URL$ This is just standard proxying stuff, and any documentation covering Apache proxying would also cover this kind of thing. It isn't unique to Webmin, at all, as it runs under a standards compliant HTTP web server (miniserv.pl, which also has a number of additional security features, as well as application server features, built-in to make Webmin safer and more efficient). mechcow is completely incorrect about running Webmin proxied through Apache being "insecure". Webmin would still require authentication, and most security features will still work fine. I will note, however, that if you have an IP address to spare, you can make Webmin listen on that IP on port 443, rather than proxying, assuming you configure Apache to explicitly only listen on the IPs you don't want Webmin running on. In this way, Webmin can be reached with just the domain name (no port needed). And, the domain name is irrelevant to Webmin. You need to setup your DNS or hosts file to resolve the name to the IP of the Webmin server. One more random thought: You do want to use SSL, regardless of how you set this up (whether proxying or running on port 443 on a specific IP address). You'll be logging into Webmin with root-level credentials, and if you're doing it over the Internet (rather than localhost), it's not safe to send those unencrypted. 

I can't figure out exactly what you're saying Webmin is doing wrong here, but if it's a bug in Webmin you should file a bug in the bug tracker, rather than asking random people at Server Fault how to work around it. Webmin is very actively developed...there's never any reason to work around bugs or incompatibilities in Webmin: Tell someone who can fix it, and it will get fixed fast. You can use the bug tracker at Virtualmin.com or the SourceForge.net one (but the Virtualmin.com tracker is faster, works better, and will get Jamie's attention faster, so I recommend it). 

Andrew Smith is correct, but has an unnecessary step in his suggestion. You don't actually need to login to ssh with a password for Webmin to work; ssh and Webmin are unrelated services. Simply set a password for your root, or sudo ALL capable user, and that will be the way you login to Webmin. 

Add more memory. 768MB is probably the minimum, if you want to run everything Virtualmin manages (mail with AV/spam, web, databases, mailing lists, etc.). Not because Virtualmin is big...it can be as small as about 11-12MB, but because some of the services it manages are very big, particularly ClamAV. If you need to free up memory, but need all the primary services, giving up ClamAV is probably the biggest bang for your buck. Reduce the number and/or size of services you're running. Add swap, either a partition or a file. This may or may not be a reasonable solution. If your system is busy on all services (e.g. mail and web and databases all work hard), then swap will just turn the problem from "services stop working sometimes" to "services are all really slow". But, it'll stop the system from killing Postfix due to memory. 

On Ubuntu systems, there is no root login, by default (a root user exists, but it has no password). Webmin/Virtualmin defaults to using the sudoers file for logins on Ubuntu systems, and so your administrative user (usually the first user you created during OS installation) would be the one you should use to login. That said, if you actually had a root user with a working password when you installed Virtualmin it should work fine. The port on which Webmin runs is irrelevant to the discussion, as long as you're actually getting a login page. The changepass.pl command changes the Webmin password...but, if Webmin is configured to use the system password via PAM (as is the case in a Virtualmin installation), I suspect it will have no impact (though it might...Webmin can use both, for users that don't have underlying system users; I'm not sure what it does for a password that exists in two places and is different). Normally, you would use the regular passwd command to set the root password, because Webmin is authenticating to the normal system passwd/shadow files via PAM. Login failures are logged to /var/log/secure, normally, on most Linux systems. If you don't see your failed logins, then something is going wrong between the browser and Webmin. Try a different browser. 

Why would you want hide it? The IP and your website are public information. There is no security to be gained by trying to hide either. 

I don't see any reason this would be a bad idea. Staging implies a non-production service, so you can have all your staging happen on one server without concern for redundancy, performance, etc. One other reason for separating applications and instances of applications is for security, but once again for a non-production service this is less of a concern, unless you host a copy of your production data on your staging server (which is another type of separation to think about). If there are security concerns, and you can't use subdomains, you could still use proxying in nginx to divide the instances up across multiple VMs. But, in the simplest form, you'd just run them all on the same instance, and use 'location' directives to determine what app each path runs. nginx doesn't care how you divide up your applications, though you'll need to configure a different proxy configuration (either different ports or different locations for configuration files, depending on the app server) to each application server based on the directory. How you do this will depend somewhat on what your app server is, which you have not specified. For example, with Ruby using the Passenger application server, you would follow these instructions: $URL$ Notice that Passenger hides some of the implementation details from you, so you don't need to think about ports, only directories. Whereas in the following example, you'd specify the port for proxying and it would need to be different for each application instance. With Perl Mojolicious, you could follow this example: $URL$ Note that the section in either example can be replicated for as many paths as you need independent instances of your app. It's the same as running multiple apps; you just give each one its own directory and configuration files. I suspect the reason you haven't gotten any answers thus far is that you haven't provided any concrete information about your deployment. I'm finding it hard to offer advice when you've specified you'll be using "Ansible, Chef, Puppet, etc." and "Redis/MongoDB"...are you using all of these things, despite the fact that they do very similar jobs? Most people choose one deployment tool (from Ansible, Chef, Puppet, etc.) and one key/value store (Redis/MongoDB). Configuration examples for all of these, and the caveats for things to look out for will be different for each. Anyway, the short answer to your question is: Yes, you can do that, and there's no technical reason you shouldn't.