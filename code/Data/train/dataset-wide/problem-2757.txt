or go one step further and use the pimpl idiom and move all implementation details away from the class declaration to the .cpp file. example: 

that way you will be sure it always works even if you change the size of one day. using meaningful variable names and functions would be better, is not very descriptive. To use boolean include instead stdbool.h 

you have an unitialized member variable called 'top', you use it in GenerateCode and it will be set there, but if you never call GenerateCode, just a simple class declaration will invoke undefined behavior since delete top is called in HuffManCodes destructor. 

you malloc should just take as argument i.e. the rest makes it just look difficult to read and in this case is wrong, same applies to . 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

Note that this code is optimized for arrays with at least 1 element; if the majority of its uses are on 0-length arrays, you'd see a performance boost if you added a short return. Alternatively you can use Array.prototype.reduce. I highly recommend that you not use this method - while it is more "unique", it is also much harder to understand and much less efficient. And good code strives to be readable and efficient (and robust), not unique. 

Your pop function just removes the top most int, but normally one would like to get the value as well not only remove it. seems more natural. Your functions do not deliver any error codes to the caller instead you select to display error message with cout. It makes the class less versatile, instead you should let the user of your class handle the error messages and just return error code/throw exception. It is good to be consistent with {} for each if statement not switch between with and without e.g. 

always write compound statements instead of single statements after conditions/loops etc. A common mistake is when somebody later wants to add more statements is to forget adding - especially when the code is not your own. 

Here's a second solution, which is slightly faster in Firefox, but otherwise between a little and 5x slower: 

is, actually, the worst variable name there is. It is impossible to create a less specific name. I would suggest renaming it. 

That has the benefit of not creating properties you don't use. Also, did you strip out some code? Because it seems like all you're doing is storing a reference to an object. Why not just use the object? 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

Your code is going to log an awful lot of "GameObject is not null" items, for very few non-null game objects. Basically, you've made an O(n * m * p * q) algorithm, where all you needed was (at most) an O(n + m + p + q) algorithm. This would achieve the same effect - beyond the fact that you'll get fewer logs of the same non-null combination over and over again. This code assumes that the library requires an enumerator. 

Introduce and AbilityCaster class, which is basically the instance of an ability owned by an Entity. This would know about the owner (but not the target list). The idea is that calling StartCast() would take a list of targets as a parameter, and return a new CastTracker (you can return a special "already finished" cast tracker for instantaneous abilities). Introduce a CastTracker class that just tracks the timing of a cast, and maintains the list of targets. This would have the Tick() method, and a Cancel() method if something other than timing can cancel a cast. Each tick would call back into the associated AbilityCaster class, with the necessary information to decide what to do. Remove all time tracking code from the Ability class, so it just becomes a stateless specification of capability. This could potentially be abstract, with just one level of implementation for the different capabilities. Something like an abstract DoDamage(Entity owner, IEnumerable targets) method. 

use c++ headers (as somebody already said but can't be mentioned enough) in you delete what comes in, it is a bit unusual to do it like that because the caller of the function has no way of knowing (from the prototype/name of the function) that you are doing a delete on argument. Use instead a as argument making it clear that ownership is taken over i.e. (even though i am not sure why you allocate an int on the heap and pass it, instead of just passing an int by value) you should use instead of normal c arrays e.g. can be replaced with use in a C++ manner, writing is writing it in a C-legacy style, instead write ; (const always referring to the item left of const i.e. in this case the pointer ) you normally don't use in c++ programs, instead use ... even for debug output always initialize all variables, in particular the POD ones and structs. try....catch is good to have in main to exit gracefully if something goes wrong. in main could be replaced with 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with.