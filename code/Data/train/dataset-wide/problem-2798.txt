There exists no reason why you need to use pointer-to-pointer here. It is slow and needlessly complex - a complexity that caused a memory leak bug. Simply do . Alternatively use a variable length array (VLA). If you for reasons unknown must use dynamic memory allocation, then do so on a proper 2D array and not some fragmented look-up table. See Correctly allocating multi-dimensional arrays for examples of how to do this - it is likely that your book or teacher is teaching you bad habits here. 

This code is very easy to understand. However, you asked for optimization and my code doesn't look all that effective; it is possibly slower than the original. Particularly, we have multiple checks for '\0' all over the place. Note that any truly meaningful optimization requires that 1) we have actually encountered and measured a real performance problem, 2) we have noticed that the compiler is doing a poor job at optimizing that particular problematic code, and 3) we have fairly good knowledge of the target CPU and hardware. It a bad idea to manually optimize code if those 3 above conditions are not met. Still, I'll attempt a manual optimization of this, since it was requested. It may or may not be more effective. Branch prediction may be a more serious concern than the number of comparisons executed, for example. For what it is worth, here you go: 

(To avoid subjective debating and to demonstrate that these aren't just the personal, subjective opinions of a random internet person, I have cited a widely-acknowledged C programming authority as source for each statement made.) 

Your use of the dictionary seems to be a way to allow the numbers to arrive out-of-order. Rather than sort them, you seem to be trying to use a dictionary (and associated hashing) to maximize efficiency. This doesn't really work out perfectly, since you wind up doing sequential searches for a given value. Hashing a low:high range (a dictionary key:value pair) to avoid a search doesn't help much. Only they key gets hashed. It does help in the case where you're extending a range at the low end. But for extending a range at the high end, you have to resort to searches of the dictionary values. What you're really creating is a collection of "partitions". Each partition is bounded by a low and high value. Rather than a dictionary, you can also use a trivial tuple of (low, high). To be most Pythonic, the (low,high) pair includes the low, but does not include the high. It's a "half-open interval". Here's a version using a simple of tuples, relying on hashes instead of bisection. A binary search (using the module) may perform well, also. It would slightly simplify adjacent range merging, since the two ranges would actually be adjacent. However, this leads to a cost in restructuring the sequence. You start with an empty set of partitions, the first number creates a trivial partition of just that number. Each next number can lead to one of three things. 

The statement can be removed, also, since it's really two generators. But that's being really fussy about performance. 

I've got a couple quick notes. Overall it looks like this method will work. Validating args[0] The only validation that you do on args[0] is to check if there are any images in that directory, but you don't check other possible failure conditions, such as if the directory provided doesn't exist. For a user, no images being found and the directory itself not being found would have different actions required to fix the problem. It would be helpful to perform better validation here and providing meaningful feedback, and perhaps a different return code. Duplicate Calls to Get Path There are a couple instances that call . This could be factored out to a variable. Use TimeSpan Formatting TimeSpan provides functionality for converting to a string in a particular format (see $URL$ In this case, I think you'd want the "g" format. Return Codes You return -1 in the event of no files being found, but you don't handle returning a different value if fails. If this was being called from a script, I'd expect any failure to return a failed return code. Catching Exceptions While the exceptions thrown by are likely all IO related, it would be helpful to catch at least some of the individual errors and displaying helpful information where possible. For example, if an exception was thrown because of a write permission issue, it would be helpful to let the user know that they need to correct their permissions, as opposed to hoping that the library you use provides a helpful description. There are also some instances that I bet could throw an exception that you don't handle. For example, I would expect to throw an exception in some circumstances. If some exceptions are handles and displayed in a user-friendly way, I'd expect all of them to. Commenting Some of the comments are helpful, such as the reference to documentation for a method from StackOverflow. However, there are also some trivial comments ( is pretty clearly going to get the elapsed time). But there are also instances where comments would be helpful, such as what the values you set on the MagickImage are (what does do?) 

It extends an existing partition on the low end or high end. The number is adjacent to exactly one range. It creates a new partition. The number is not adjacent to any range. It "bridges" two adjacent partitions, combining them into one. The number is adjacent to two ranges. 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

A few. Sorry it seems boring, but there's not much better you can do. The biggest change might be to make this into a generator function, which may be a tiny bit neater. 

Avoid trying to build a "mutable tuple" as a fixed-length list. Either use immutable named tuples or a proper class. 

Do not use a database for this. Use files. A single file with one tweet per line showing User Name, Tweet Text and whatever other information you have. You need to sort the file by user. Use the OS-level program, don't write your own. Once the tweets are sorted by user, you simply read and count. 

Don't reuse to be the index of the loop. It's confusing. It violates the meaning of start. The lengthy parameter parsing is good, but can be made more clear. Don't waste time on checking for or . Just use the statement. 

This may be better than a list. A list where the order of the arguments is critical is a bad thing waiting to happen. Code like is utterly opaque. It should be replaced with so that the meaning is obvious. Also, once you have an class, your separate function becomes needless. You can subclass like this. 

This is unnecessary. Without it, it will propagate the exception up, the same as manually rethrowing the exception. Remove Unneeded Controls You seem to have both a radio button list and 4 radio buttons. We really only need the radio button list. There are also a few panels that aren't needed. Use ViewState Instead Of Session Instead of using the session to store data between questions, we can use the ViewState. The ViewState doesn't persist the data on the server, but rather stores it on the client side. Since we don't need to make use of the internal state data (such as the current question), we can store it in the ViewState. Using ViewState also allows a user to have multiple question sessions going on at a time in separate windows, whereas the session data would otherwise be mixed between them. We can also use properties to simplify this access. Instead of using strings to access the variables, we can implement the access in the property, which will prevent us from accidentally using the wrong key. For example: 

Ideally, it would be great to have a result information class that we could serialize and pass through, which might include the percentage, which answers were right/wrong, etc. Note: It really shouldn't be using the session at all here (see reasoning above), but the architecture of transferring the data is out of the scope of this question, so this is here for a proof of concept. Separate Data Access From Rendering Currently both handles data access as well as calling the rendering method. I would extract the data access to it's own method, something like: