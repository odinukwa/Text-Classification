Personally, I'd always either write it on one line as in the second example or if there is a newline, I'd always add braces. For reasons see Apple's . But it's actually a personal preference, you don't need to do it that way but I highly recommend that you chose one style and stick to it. (Same with whitespace: there should be a space after the in ) Consistency would also be nice here: 

You shouldn't return a negative value from as for POSIX environments, the return (exit) value is just an 8-bit unsigned integer. Values above 125 or 128 are usually treated specially by the shell (marking that it was terminated by a signal). But in two's complement limited to 8 bits is = 255. Thus, your shell might think your command got killed. So instead of you should return . But actually, according to C99, the correct values to use are in your and at the end of your . Personal opinion This is just my personal opinion and I know others might not disagree, but here goes: I think an should always have curly braces, except if its body is short and on the same line. So I think this is OK: 

First, you are mixing statics and non-statics in a confusing way. Please seperate those. A singleton should only be created once. Your class does not have a constructor, so it can be initialized everywhere. Give your class a private constructor. This why, only the class itself can instantiate one. You lock the creation of the GlobalData to prevent problems in a multi threaded environment. Why not put your initialization inside a static constructor or initialize the static field directly, which prevent any problems with multiple threads. This also gets rid of the . The keyword is only required on changing values in a multithreaded environment. Your reference to the will never change after it has been initialized. 

Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: 

Which code is more readable? When it comes down to those differences, should the code: a. return . b. return . c. throw an exception? 

If one of the arguments is , code A returns and code B returns . If one of the arguments is an interface type, code A returns and code B returns . 

This is a revised solution. It is way faster than my original posting. I replace the by a which had a little performance boost (hinted by Jesse). Also, I used recursion with an early out algorithm. 

I have two pieces of they which do almost the same thing. They both return the most common base class of two types. They differ in two aspect: 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

Your code looks pretty good except for the . More about that later. Unsafe code has a few things that can make code go faster, like pointers to arrays and arrays on the stack. A pointer to array would make code only faster if the code is iterating through that array. does iterate trough , so yes, this part could become a little bit faster. We are talking about microseconds. You are also iterating through an the table array inside the constructor. So creation of this table could also become a littel bit faster. Personally: I would not use unsafe code in your case. About the static You have a static table, but when you create a new instance of it will recalculate all the (same) values. (Talking about performance loss!) If you have two instances of with different polynomials, then one of your instances will calculate it CRC's wrong, because they both share the same table (since it is static). How to solve this in a faster and safer way? Use a static! (Huh?) Yes, a static but another one: This will store all calculated tables. In your class use a local field: This one will hold the (already) calculated table. If the table was not calculated, it will be calculated and stored inside . You also use this mechanism to store hard coded calcaulated tables, as Jesse suggests. In that case you would assign your hard code table to the dictionary inside a static constructor. Your code could become like this: 

Either the call to succeeds or it doesn't. Your version doesn't make it clear that this really is an either/or. 

I think this is nasty: it modifies the string pointed to by . Granted, it is a instead of , but ultimately you're modifying the string from your s (BTW, the convention is to call that ). I would make a local copy of for that. That way, you could turn almost all your into (and const is good since it helps find accidental manipulation bugs). Standard compliance What is your option? Neither my GNU nor my BSD know it. Since you fall through to they're equivalent so you might be thinking recursive? It needs a comment, IMHO. Help If your tool is called with wrong or missing argument, it silently exits. IMHO a good command line tool should always have a help/syntax page. Return value from When you encounter an unsupported option you do: 

Hijacking the predeclared instance's fields In the factory method , I temporarily set the state and X/Y fields of the default instance, and then in the event of the new instance, I read those fields though the default instance's getters. As such, I've relaxed the conditions around being able to access the default instance's getters, but this could easily be re-added. The default will always have X and Y's getters return 0, in much the same way that the default will always have default value 0. 

If sorting the data doesn't help move the blanks to the end of the data range, and deleting the rows is a better solution, given your data, then you can try this approach. If you know a column will always have data (and never be blank) for a valid row, then you can achieve the deletions without a loop.