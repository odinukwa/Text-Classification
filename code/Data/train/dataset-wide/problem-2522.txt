There is no need to cast , you can just call It's weird to use both and for the same type in the same expression: 

1) Are you sure that it is safe to write to from background thread the way you do it? Because documentation clearly states that it is not: 

Well, i am new to this weekend-challenge thing so I am not sure, from which stand point should i review such question. I'll give it a try. 

Note, that neither the version above, nor your original implementation will work correctly for nested locks. To fix that you would have to implement some sort of reference counting. Your have inconsistent equality comparison. When you look for existing you check , when you call - you don't. This can lead to incorrect items being deleted. It looks like your code is prone to leaking locks. For example, if constructor throws after call due to denied access to log file, or due to thread being aborted, or due to any other reason, the is never released. Personally, I don't quite see how is any indication of . But maybe I am just missing something about semantics. 

It just occurred to me though, that it won't quite work for numbers: for "A1,2" it will return "A[1]". So you'll need a more complex solution. You could add tokens to stack until you can no longer parse it, for example. And only when that happens you would yield last successful and clear the stack. But there might be smarter way to do it, I'll think about it. 

Well what you are trying to do is not strictly speaking an abstract factory. For it to be an abstract factory the use case should look like this: 

Somewhat similar but still a bit different approach is to encapsulate your context into some container class and put this wrapper into IoC container instead of context itself. Might look like this: 

Your unit tests look fine to me (except you should move them to different file), tho i'm not too experienced with them. 

This method should probably be refactored into static extension method, so it is easier to re-use if needed. 

If you need some complicated logic added to enum, if you need to extend it, etc., that only means that enum is not the right abstraction in your case. Instead of trying to emulate 's behaviour in some wierd abstract class, you should build a proper class to represent your data and then use generic collections (or implement your own). 

And this is a typical game object that theoretically can represent anything from a stone on the ground to a bullet. It's just a collection of arbitrary components. 

should only be used to add an offset relative to element's position. You should never ever use to define the position itself, if you want to have scalable layout (and you do). To create a grid layout, you should populate and properties of your and then use and attached properties on your buttons, labels and texboxes. See this and this. You should learn default values of common dependency properties. For example deafult value of property is , there is no point in setting it to explicitly in your xaml. You should only set dependency properties, when you want to override the default value. You should use instead of . Don't name every single element in your xaml. Only name elements, if you need to access them via code-behind or data binding. You should probably implement a constructor with 4 parameters on your class. 

You have a lot of nested 's which can be inverted to reduce nesting or even removed completely, such as this one: 

and manually fetch menu item inside this method from your DI container. This way you won't have to create one million fields in you as your menu grows. You should also probably split method: 

As for your first question: you can override method of your class to return Name+Price the same way it is done for . Then you can simply call 

P.S. In case you are not aware, wpf supports basic filtering out of the box. In order to use it you should create a and set its delegate: 

I don't like the fact, that result generates itself. I would rather have two separate classes: one to run a benchmark and one to represent benchmark result. Also calling some method makes much more sense semantically than calling . 

is clearly copy-pasted. :) You should extract this logic to separate method. class is aready thread-safe. You gain nothing by locking it. Performance-wise it makes more sense to open log files once and keep them open for the life-time of your class. Re-opening file stream every time you need to write a new line is a huge waste of resources, if you write to log often. You should probably use separate locks for different files. There is no point in locking "error.txt" while you are writing to "log.txt". 

Well, using as a way to improve performance doesn't sit well with me, as it kind of violates the contract. I doubt the gains (if any) justify it. Micro-optimizations should probably begin with replacing recursion with a loop. Another thing to optimize is your partitioning logic: has an overload that takes start index and count. If you use it instead, you can avoid call and subsequent copying. If you do need a copy for some reason, then you should use Buffer.BlockCopy method. Element-by-element copying in loop is considerably slower for larger arrays. is a bit counter-intuitive as it apparently returns items. That's not what I would expect. There is also a little bit of copy-paste in loop's body, that can probably be avoided. You can use instead of and put results in correct order straight away using indexer: . No additional synchronization is needed as long as values are unique, which seems to be the case. Everything else looks alright to me. 

IMHO, static method only makes sense for value types, when its impossible to mutate an existing instance and/or its hard to tell the difference between and successfully parsed value. For all other situations a constructor (for immutable types) or an instance method (for mutable types) will do a better job at keeping your code clean. I am OK with this (for immutable objects): 

Also, you don't have to use operator if you are using attribute. You can just call (without arguments). 

In general I feel like proper unit tests should not use delays and should not rely on them. Not only because those delays quickly add up if you run this method multiple times, but also because the behavior of unit tests becomes unpredictable. The same test can fail on one machine and pass on another, simply because on one machine timed out, while on the other - it did not. IMHO you should take it as signal, that you design is flawed and should be changed. If you own , then you should probably modify its API so consumer can wait for the value (using async methods, events, observables or any other suitable tool). If you do not own then you should wrap it in non-static service and mock this service in your tests. 

My point is that there is always some sort of trade-off, and one approach might be better than the other depending on use case. However, by combining those two approaches, as you do, you are likely to get the downsides of them both AND gain non of the benefits. So I suggest you pick one or the other, and stick to it. 

and remove property. Then you simply use first method to add commands, and second method to add sub-menus. 

The downside is that for every sequence, I have to write at least two methods. First, method, to generate an actual sequence (), second method to wire it up to (). This looks like a lot of extra code for what essentially could have been: 

There is no point in cathing the exception if your code will crash afterwards. You are only making it worse. - this should be . 

The algorithm looks alright to me. You might want to replace with, say, to return earlier, but I don't think it matters for relatively small input. 

which dated back to 2014 according to version control. I mean come on. If you need to rename your fields or throw an exception - then for the love of god do so right away. Not only it takes a couple of seconds with modern refactoring tools, but it will also show us, that you actually worked on your code since your last review and improved it accordingly! And to add to the list: constants should be PascalCase in C#. No underscores in-between the words and no capslock.