So the original condition to swap elements not intuitively but is equivalent to the short form: . We will use this. As for the loops: I will make use of loops. Using the nice slicing feature of Go, we can rewrite the inner loop so that it only iterates over the "rest" of the slice by reslicing the whole slice: (slicing is efficient: it does not copy the elements, it just creates a new slice header - sharing the backing array). Now this is how this algorithm looks like: 

Subtract 1 from the first digit and add +1 to the result, and multiply the result with the digits count of this number. Add the total number of digits of all the numbers having less digits. Add extra digits specified by the parameter. 

To clearly state our problem/task: We want to compare 2 checksums, one supplied as a text being the hexadecimal representation, and the other being an array of the "raw" bytes. 2 forms exist: a hexadecimal representation and raw bytes. To compare them, we need the same representation. So 2 possible paths: 1. Convert the second to hex representation Let's see your proposed solution. If we want to handle leading/trailing spaces, and if the text input may contain lowercased and uppercased hex digits, your solution is as simple as it can be. A variation may be to convert the text to lowercased, and then we can simply compare strings without . The lowercase conversion can be done by calling or since we already have the input as , by : 

And that's all! It's extremely short and compact! It contains 2 multiplications, no divisions, and maybe like 10 additions and subtractions! The complete code: 

This works, but can be written simpler. Note that if a key is not in the map, indexing a map yields the zero value of the value type of the map (Spec: Index expressions). Zero value for the type is . So the expression will be if is in the map (because when you put it into the map, you stored as the value for this key), and it will be if is not in the map (the zero value of ). So this can be rewritten as follows: 

Explaining the invalid UTF-8 s: Since you are converting your input string to s, invalid UTF-8 bytes are reported as a value of (the Unicode replacement character), which when encoded as UTF-8 (happens when you convert back to ) results in a sequence of ; this is what the invalid byte is compared to in the test case. Performance wise I would use a => conversion as you not only need the s, but you also want to convert them back to a . Using is slower, and it has to assign a slice value (a descriptor) at each . Also note that if we convert the to , we only need to assign (overwrite) new runes which are converted to their upper case: This is how I would do it: 

Also it's a good habit for a specific type to be consistent. Either use pointers in all places, or non-pointers. In case of , you mix both: expects , but returns . 

Note that in the outer loop we only used the index, as the value may change in the inner loop (if elements are swapped). And now just for fun, let's also use a loop to test the 2 sorting directions. We will use a composite literal to create a slice holding 2 values (, ) by only telling that the second value is (and let the first value be initialized to its zero value which is ): 

All the following implementations along with the benchmarking code can be found on the Go Playground. The code posted there is not an executable but a test file. Save it in a file like , and run to run the benchmarks. The algorithm Let's examine the algoritm. Since the extra space has to be added for each number, it always means to the number of total digits. We can incorporate this at the end, so we don't have to think about it. So let's reduce the problem and algorithm putting aside for now. Example Let's take the input number . How can we calculate the total length of all numbers starting from up to ? 

Note that your algorithm is not correct: For example input it properly returns (), but for it should be (+ 2 for representing and +2 as defined by ) but your algorithm returns . The error increases drastically as grows. For example it returns ! Even if all the 10000 numbers would be 5 characters long, it would be a really high estimation of (instead of a million). 

Compare arrays () As a variation of the previous solution, we will use arrays to do the comparison as arrays are comparable. Since already returns an array , we only need to get the raw bytes of the text checksum into an array. The simplest and fastest is to create an array , and pass such a slice to that shares its backing array with our new array. We can obtain such a slice by simply slicing the array: 

Further optimization for small numbers If the is called frequently with small numbers, it is profitable to put some additional code which "hardcodes" simplified handling of these cases. Here it is: 

Benchmarking, speed analysis Let's compare the speed of this algorithm with yours. We'll write a short benchmarking code, one for each of the functions (all look like this, except they call the appropriate function): 

As the question is already answered nicely, my answer just attempts to complete the existing one, and give a creative alternative and further tips. Your function returns the slice. This seems nice so that you can print it immediately, but in Go it might give the wrong impression, it makes people think that it returns a slice because the sorting may be performed in a new slice, which needs to be stored. Since you sort the slice "in place", it is better if it's not returned, so people using your function will treat it like it modifies the content of the passed slice. For example the builtin returns the result because it may be a new slice, but (which sorts a slice of s in increasing order) does not because it sorts "in place". The function value in rolfl's answer is a nice, flexible approach. However in this solution I will stick to just the information whether we want ascending or descending order. This is 1 bit of information, I will use a type for that. Let's try to formulate when 2 elements have to be swapped inside the loops during sorting, telling if ascending order is required. Swap elements if: