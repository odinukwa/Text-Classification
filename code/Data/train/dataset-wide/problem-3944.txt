Go in armed (with information! Please! Only information!) Be polite but get your point across Be prepared for "no" Don't issue ultimatums 

This isn't quite what you're asking, I know, but I would recommend not putting all 35 years of your experience on your resume. The last 10-15 years, absolutely. The problem with putting 35 years or even 20 on it is that you're basically opening yourself up to be denied jobs based on your age. It's technically illegal but all a prospective employer has to do is look at the years on your resume, do the math, and figure out that you are at the least in your mid-50s (assuming you didn't enter into the industry when you were 7 or something). From there they can drop your resume into the circular file if they're so inclined and you'll never know the difference. This article on CareerBuilder.com backs up what I wrote and also provides possible exceptions (for instance, if the job you're applying for is specifically looking for people with decades of experience): $URL$ This article from CBS News uses the same rule of thumb (~10 years): $URL$ 

Was it really dumb? Yes. Will you ever get hired again? I'm sure that you will. At this point you probably don't have a lot of work history so depending on how long you had the job you may need to keep it on your resume. When asked, don't be cagey about the fact that you were laid off; at the same time I would not offer the explanation that you stole food. Say that you "were not a fit for the company's culture" instead; most interviewers understand what that means now and will make the decision thusly. You may find that you need to take a "step down" in your next job - another bank for example may not hire you off the street after you were let go from a similar position. But you are young and have plenty of time to, for example, work in retail, climb the ladder so to speak, and after a few years go back to working as a teller or whatever if that is what you really want to do. Needless to say, in the meantime, you probably want to hold off on stealing peoples' lunches. 

One way in which you could (potentially) get this to work is to get in with a contracting firm. My experience with contractor interviews is that they tend to assume that you know what you're doing and don't ask the "fizzbuzz" questions so much. Then, after actually doing nothing but coding for a while, perhaps that light will "turn on" and some of those questions will make more sense in and of themselves. From the perspective of the interviewers, it appears to be really, really easy to tell people you know what you're doing in programming without actually knowing what you're doing. At some point during the interview process, they have to figure out if you're really decent or if you're a good BS artist. For all they know, the portfolio you bring in with you could have been put together by someone else, your answers could be rehearsed/memorized (which is still the case with the "fizzbuzz" stuff, of course), and so on. I would go so far as to assume that any place which isn't asking you to demonstrate some level of programming proficiency up front is going to formally or informally have you on "probation", giving you smaller jobs to do while they figure out whether or not you know what you're doing. 

My experience with software development is that it's a combination of things: Not enough resources allocated to a job, combined with poor planning. There's that joke that goes around that devs always add 50% to the time they're actually going to take doing something in a quote, and then their PMs add another 50% on top of that. This isn't totally false and it's not always a bad idea either. A job you think will take you 4 hours may in fact take you a couple days to hammer out once you fix unforseen bugs, deal with complications that new requirements bring in (and I love Agile but that is one thing that happens with it), unit testing, QA testing, code review, and so on. The only way to fix that is to plan out enough ahead of time, and nobody wants to look like the slow dev in the group. Setting yourself up for failure As a contractor, one of the things that I like about going into new jobs is the change of pace and often the huge, gaping problems that I was brought in to fix. It's perfectly natural to work extra to fix those glaring issues, and on top of that I have to say that it's a lot of fun at first to deal with entirely new issues. That, I think, causes a lot of folks to work a lot of OT, paid or otherwise, at the beginning of a gig. Where that idea breaks down is that sometimes, especially if you aren't very clear about the fact that you're working extra time to meet deadlines, etc., the non-programmers on your team - BAs and stakeholders especially - get a false idea of how much you can produce in a week. That makes it extra hard to scale back 3 months down the line, as you then have to discuss why it is your productivity has gone down. The constant death march One thing that I have seen a pretty good amount of as well is a team being in constant crisis mode. It's OK to work a couple 50 or 60 hour weeks to meet a particular deadline, or if there's a major bug you've got to quash right now, but I've been at places where management seems to arrange things so that there's always a looming crisis right around the corner for... reasons. Some people think that this makes people more productive (I disagree but that's the thought anyway), sometimes you're coming in at a minus because the previous team spent a year to do something that ought to have taken them six months, and so on. It's hard to come up with a good solution for this issue as it tends not to come from developers but from management. All I can say to this is, make sure you stay in constant communication with said management so that they at least understand the amount of stress they're putting on you and your team. Scope creep As noted, I do enjoy Agile, and one of the things I enjoy the most about it is the constant weekly or biweekly communication you get to have with people who are going to be using your product. You show off what you've added, they talk to you about how it differs from what they wanted, you make those changes and show them off at the next sprint, etc. I think it neatly avoids the really huge problem of Waterfall, which is that you can spend months working on something only to wind up with an end product that is all wrong. That being said, Agile lends itself really well to people coming up with new ideas in those planning / demonstration meetings, and it's once again hard to be That Guy who says "that's not in the documentation. We can add it but it will add X weeks to the project". But someone has to be That Guy if you want to avoid scope creep possibly leading to the Constant Death March. It's just the way we work I think this is really the least important one of the bunch, but a lot of the time if I'm presented with a problem, I'm going to just sit down and work on it until it's solved. If that requires a couple of 14 hour days, then it requires a couple of 14 hour days. And if I can't take off early some time during the rest of the week, maybe I wind up with 50 hours plus. This isn't a normal office job where you clock in at 9am, take a 1 hour lunch, and clock out at 6. I've noticed that non-programmers tend to be a bit less cognizant of this when they see a dev taking off at 2 in the afternoon on a Wednesday (they aren't seeing, of course, that you were in at 5 that morning because there was an issue you just couldn't put to bed until you solved it), but the overall point remains: this is a job where at the end of the day you are not judged by the hours you work but by the stuff you deliver. Start-ups You aren't always going to have to work 70 hours a week at a start-up, but bear in mind that for a small company that's just getting started, you're not just working for a paycheck, you're working to keep your company in business. Sorry, but sometimes you just can't avoid this. If you want to keep yourself around the 40 hour mark, find a Fortune 500 company to work for. 

There are really good reasons why most companies will prefer to hire an experienced programmer over one who just came out of even a highly regarded school. Programming, frankly, is not nuclear physics. I'm not saying it's easy, but it's the kind of thing you can learn on your own. What you can't learn on your own are team skills. 

If you're looking at avoiding awkwardness, I'm not sure it's possible at that point. The awkward situation was created by the person coming in and spending nearly an hour on a test, only to fail it. All you can really do at that point is say "I'm sorry, I think we're going to look elsewhere" and leave it at that. I do wonder which IDE you're using because that can make some difference. If you're a .NET shop hiring a backend guy and you're using Visual Studio, yeah, it's pretty open and shut. If you're a PHP shop and you're using... whichever IDE people who use PHP use, that might be a tougher situation. I mean, hell, I work in a .NET shop but really only use VS proper for source control (I do front-end web development and the reality of our development environment is that it's just plain easier to deploy directly to a test server and debug using Chrome or IE's web developer tools). I have enough experience doing server-side coding in VS that I'm sure I'd do OK, but I can't very well speak for all experienced developers. Maybe to avoid the possibility of that "I know the language but not your IDE" situation in the future, maybe give the developer a heads-up that there may be a test component to the in-person interview and then state what the IDE you're planning on using is? That in turn means you probably can't copy a test from the Internet anymore but, well, that's kind of always an issue (and you definitely sound like a person versed in technical stuff but if you're not, I'd probably advise against tests like that, period, but that's another topic altogether). 

It's perfectly okay to ask questions like this during an interview; indeed, stuff like this is reason #1 why there is usually time for the interviewee to ask questions. The interview process is as much a chance for you to figure out if the company is the right fit for you as the other way around. 

The unfortunate reality is that you will actually meet these situations in the real world. My memory of group projects in school (caveat: although I'm a software dev now, I have a degree in the humanities) more or less mirrors yours: most of the time, you got maybe one other person in the group who pulled their own weight and you basically had to resolve things between the two of you. That being said, here are the strategies that have worked for me in the past: Assume you're going to do all the work I realize that everybody's just learning the system, which in and of itself is going to ramp up the difficulty level right there, but chances are your professors aren't giving you something that's undoable. In fact. there's a solid chance that you just might be able to take on the whole thing yourself. So, delegate responsibility and all that but if guys aren't meeting deadlines, just fill in the work for them. Don't think of this as doing someone else's work, think of this as taking advantage of the system. You want to be a great programmer? The difference between good programmers and bad ones is that good ones do a lot of it. Theory is nice and all, as is talking with other programmers, but at the end of the day the only way to really and truly learn about the process of programming is to just write a lot of code. On top of that, if you have a TA who will go in and critique the work beyond running a .exe to see if it works, that's, like, double the opportunity: if you write all the code, all the code review you get is stuff that applies to you. Think in terms of Agile, or at least try to. One of the tougher things about starting out is that you're only just aware of the concepts of coding (or maybe you're one of those guys who's been doing it since they were 5, who knows) is that you don't necessarily have experience with software development methods like Agile. You may want to look into how it's done (check out Scrum as well, which is kind of a submethod of Agile). Among other things, it tends to let you know early on who is going to help out and who is not. A brief synopsis of some of the things that having an Agile-based mindset might lead you to do in a group like this: 

I think the reason why you see devs with soft skills move to client-facing roles is not that you get pigeonholed but because a lot of devs just don't have those skills. Knowing how to work with other people, especially people who aren't technical, is a good thing and not a skill that will "pigeonhole" you at all. In fact, you may find that the opposite is true: most people can only go so far in a pure developer role and if you want to make the really big bucks and be responsible for big decisions, that's almost certainly going to involve dealing with non-technical people (and even if you somehow end up in a management position that deals solely with techs both above, below, and across from you, people skills are still just as important with devs - maybe moreso because a person who lacks these skills probably won't be equipped to understand that their boss lacks personal skills and is "just a jerk" or something like that). Also, you may in the future find yourself wanting to branch out in new directions. Maybe you'll get burned out of developing and want to do something else for a few years (believe it or not, it happens!). Maybe you'll want to start a business of your own - there's no place in a start-up for people who can't wear a lot of hats. Another underrated way that soft skills help is that by explaining to non-technical people what you're doing, you actually force yourself to understand your own material - be it the framework you're using, the tools you use to help you code, and on and on - better. I have a bad, bad habit of over-explaining stuff (part of it is personal preference; I vastly prefer giving people too much information than arrogantly doling out only the info I think the other party will understand but part of it too is a personal failing that I work on improving), but one thing I have found is that a lot of the time when I start talking out what I'm doing to an analyst or a non-tech manager, this makes me realize that the actual problem they're looking to solve isn't necessarily going to be fixed as well with the solution I think I want to provide than with another one. Worst case scenario, if for some reason you do wind up in a front-facing job and can't get back to developing even when you want to, there are always other companies willing to give a shot to a person who has coding experience and who presumably knows how to work well with others. Unless it's something you just flat out hate doing, there's not a lot of downside, really.