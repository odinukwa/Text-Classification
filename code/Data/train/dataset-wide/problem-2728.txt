That makes this function reusable. You don't want to go too far with reusability (YAGNI), but at the same time, you don't want to hard-code assumptions or arbitrarily box yourself in. Sometimes, it's just more natural to parameterize a function. The only thing that bothers me about this code is that setting the property has global side-effects that are visible outside of the function. This bothers me for the same reason that global variables make my skin crawl. One way to solve this would be to save the original value at the top of the function, and then restore it at the end. But that might not be worth it, if you are disciplined about always making sure to set this property to the desired value before any calls to the function. 

Alternatively, you could flip the logic around, testing to see whether the navigation is not coming from . 

Then, since the logic inside of all the blocks is identical, you could combine them into a single expression with a logical OR operator: (This works because the operator has short-circuiting semantics.) 

I don't know what processor you're running your performance tests on in order to claim this result, but the fact that you've made code shorter does not necessarily make it faster. (I'm going to talk about a bunch of obsolete architectures because I'm assuming that's the most likely target for 16-bit x86 assembly code! I'll try to throw in some notes on modern processors, too.) On the 8086, and especially the 8088, it is true that shorter code is almost always better, since instruction prefetching is so slow and there is no cache. Although there are some instructions that are slower than others, you can pretty much substitute a multi-byte instruction for a single-byte instruction and see a speed-up, as long as the cycle counts are comparable. That was no longer so true on the 286, and become completely untrue on the 386 and later. Especially on the 386, there are a bunch of "legacy" CISC-style instructions that are very slow. Replacing them with simpler instructions (regardless of whether or not they are shorter in terms of bytes) almost always makes the code execute more quickly. And thus was introduced the classic space vs. size tradeoff for optimizing compilers. A case in point is the instruction, which tests the value in the register to see if it is equal to zero and, if so, executes a conditional branch. Notice that this is equivalent to: 

The constructor takes the character set to be used and a beginning and ending range of passwords. For now, it assumes both passwords are the same length, which is useful for when you know the number of characters in the password. iterates over the range of passwords, and returns the password when found. If the password is not found, it returns . will calculate the next password in a manner similar to addition in base-N math. will return the current password, stored as an array of s, as a string. I generate my tasks like this, leaving Windows to manage the threads. Based on watching it in debug mode, it does create several threads, but not 95: 

Also, I would probably just use an unless you really need the larger number size provided by an unsigned , in which case I would probably use a . 

, , and are just s of s (they can't be s because they are bound to XAML objects that need to know when they are updated): 

is by design, as I only need to be able to access the s out of this class. This method gets the trees stored in the second level so I can get the items in the third level. returns the menus stored in the top node(s) based on which version of tutorial the user wants. gets the s stored in the deepest levels of the tree based on which version the user is in and which menu they just opened. These methods are the part I do not like, partially because there is no easy way to search the tree for a value. P.S. I'm not sure if this is more of a tree or a file structure as I need it to be able to have multiple nodes at any level, with the true "root" being the variable holding it all together. 

The standard (and recommended) way to solve this is for each module to provide its own exported and functions (or whatever you want to call them—the names are not important). This is what Windows DLLs do (for example, the Network API functions provide and to handle memory management), and you should strongly consider following the same model in your own project. Regardless of their names, the implementation of these functions is downright trivial. just needs to call (or if you're using C), and just needs to call (or if you're using C). They are just wrappers. Header: 

The code can be improved by writing simple C++ wrapper classes to implement automatic resource management, as was discussed above. You should also add error-checking. To really squeeze speed out of it, you'll need to resort to some ugly tactics. As written, this does much the same thing as the Win32 function, and like I mentioned above, your setup is such that you need to call this function repeatedly. The obvious way to make code execute faster is to reduce the amount of code that you have to execute. Here, that means factoring out common tasks and doing them only once: 

Unfortunately, the C# JIT compiler doesn't seem to be able to produce as efficient of code here as a C compiler would. In C or C++, your function would be transformed directly into that assembly-language instruction I mentioned above. In C#, you get 4 instructions instead of that one: 

Thank you for this interesting problem. I think your code is good to go, although it isn't quite how I would do it. First, avoid using unless you absolutely need to. is much easier to manage, which compensates for it's nominally larger size in memory. You can then get your data in one pass because a list is resizable. 

The Undo command. This command uses our very own Source Control feature, and undoes any changes on the selected component: 

In one method, you use parenthesis around the expression, and in another, you don't. In one method, you use spaces around the operator; in the other, you don't. These methods could also be improved by using C# naming conventions: should be named with PascalCase as at a minimum--writing out the full word "function" wouldn't hurt (although technically, this is called a "method" in C#). 

Wait a sec--why does your game player know when the program ends? What if you had two games, and the user was just exiting this game? Only should know when the program ends. 

This looks very clean and simple, which is always* a good thing when programming. First, you don't save state, nor do you have long functions--each function does what says in a couple lines. One nitpick is your naming: 

The basic construct you're looking for is a loop. This is what you should reach for any time you find yourself writing the same code (performing the same operation) over and over again, but in a regular pattern (e.g., on columns A–ED). There are several different types of loops supported by VBA (consult your favorite language reference for details), but you probably want a ranged loop here, since you want to loop through columns A through ED (or whatever maximum column). In VBA parlance, that would be a loop; something like this: 

Notice that each column follows the truth table for an XOR operation, which basically just says that the output is 1 (true) whenever the inputs differ. That's the "exclusive" part of the OR. Eventually, while doing this preliminary research, I suspect you'd come across someone talking about how XOR operations are used to implement parity checks. Mast's answer here already spilled the beans. Parity indicates whether an integer is even or odd, and can be calculated simply by a XOR sum of the bits. Judging from your comments in the code, you already know that for a binary number, the lowest (least significant) bit determines whether it is odd or even. So the good news is that your code is almost entirely correct. If you change the s to s, it will follow the rules of the assignment and produce the correct result. Thus, you would have: 

You are wasting your time here. Once you know the value is not a prime, you do not need to continue looping. This will reduce your time greatly: 

Second, you should always have spaces around your operators, not just sometimes. Third, you should use the correct levels of indentation, usually 4 spaces per level: 

My views are all either static information or a simple iteration over a list of data; here is my view for the above model class: 

Seventh, you do not need to identify each block on the page with an or . If you wish to style all HTML elements of a certain type, you can do so like I show above. The in the example can be replaced with , or any element you wish. 

For the most part, you are consistent, and I like how you use spaces around your operators and braces on your one-line s. 

As for optimizing code, I am not too good at that myself, so I'll leave that for the experts to cover. 

This is pretty good-looking code, except for the fact that every argument is passed as an . Let's look at what happens when I pass a custom type declared in the namespace to . First, succeeds, unless the value is null. Next, we reach . What is the value of ? Do we really know? If I have not overridden , it will return . If I have overridden , it could be anything. Finally, we reach . What happens here? We get an that crashes our code. Because you are working with a value intended to be an , you should take input as a string. Problems that could arise here are if the string "234r" is passed, which will cause to throw. You should probably use to ensure that the parse succeeds without crashing your code. 

(We could have just as easily done the first, before the . It doesn't matter.) Go through your current code, and prove to yourself that this gives exactly the same results, without needing to flip the bit with the , without needing to involve the carry flag (CF) via , and without needing to do any conditional branching (). Putting it all together, the code is essentially: 

But the code I've written above isn't quite what you want—we still need to fix a couple more things! The first issue is that it will display a message box containing the numeric ID of the problematic column, rather than the alphabetic ID displayed in the Excel UI. For your user's sake, you probably want to change this. Since you're using a loop with the numeric column ID as the loop counter, you need an algorithm to systematically convert that numeric ID to the alphabetic ID. I would define a reusable function for this. The following function is adapted from one appearing in a Microsoft support article: 

Whereas it is actually more work—and less obvious what is being done—when writing the code in C or C#. You have to explicitly notate both parts of the circular shift. The canonical form is: 

Your comments are redundant because it is clear you are adding it to the list if it does not exist. You did use braces here, which is good. Please be consistent whatever you choose, though, and either always use them or never used them when they are not needed. 

Rather than using "33*", those should just be "1*". If you wanted the middle one twice as wide as the rows/columns on either side, then you would give that one "2*", and so on. 

Fourth, you cannot have multiple 's with the same name. If you want multiple instances of data with that style, use a . An specifies a single, unique location on the page. Fifth, do not use spaces in your URI's. Represent spaces with , like this: 

Even though there is only one parameter in this method, I should provide the argument name so the person debugging doesn't have to look. This is done in .NET 4.5, which I am using, as: 

First, you should not compare values to boolean literals in an statement. This is better off written as instead of and instead of . Second, you are modifying a local variable right here, which will go out of scope as soon as you leave the method: 

When I see this question, I immediately understand what you are trying to do as a bitwise rotation (also known as a circular shift). You need to either rotate the bits in the value left by 24 or right by 8 (they yield equivalent results). As the bits are shifted off one end, they're inserted back in the other end. Ironically, this is one of those rare cases where the code is conceptually simpler in assembly language (!) than it is in C#. The x86 processor family has two very simple instructions that accomplish precisely this feat— and —which rotate left and right, respectively. That means the code in assembly language is almost as simple as: 

And here is the simpler code that doesn't use exceptions. Notice that it is exactly the same logic as before, explicitly detecting the error and handling it, but it doesn't use exceptions for flow control—just normal flow control structures like loops (which we're using anyway!): 

The Fundamentals: Style & Readability Before we get into optimizing, there are a couple of glaring problems with your coding style—that is, the way the code is written and the way it looks. 

Now we've XOR-summed all of the bits from the three inputs. All that's left is figuring out the parity of the result—i.e., whether the XOR-sum is odd or even. You've already implemented one way of doing that, but as Quuxplusone pointed out, it is an unnecessarily complicated way. While it doesn't always hold when you start getting into more advanced things, for simple arithmetic operations, fewer instructions means faster code. Arguably more importantly, it means simpler code, which is more likely to be correct code. Moreover, fewer branches virtually always mean faster code, and certainly code whose flow of execution is easier to follow, and thus easier to debug. I'd disagree slightly with Quuxplusone here and say that clever is totally fine, as long as your cleverness has some notable advantage. You don't always have to write code the "normal" way, because the "normal" way might be sub-optimal. Generally, if we're dropping down to write in assembly, it's because we want to write the best code we possibly can (either fastest, shortest, or whatever metric we are using to judge "best"), which means that "normal" isn't necessarily an important goal. Sometimes, "readable" isn't even an important goal. But, by the same token, I do agree there's no point in deviating from what is normal if your deviation is inferior, and that's certainly the case here. Your XOR-sum is in the register. You know that the XOR-sum tells you the parity in the least-significant bit. So what is the obvious thing to do? Mask off everything but the least-significant bit, and that'll be your answer! How do we mask off bits? Use a logical AND operation: