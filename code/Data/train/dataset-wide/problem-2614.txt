Improved (?) Code My implementation will trade time for space, which means that more memory will be consumed in exchange for faster execution speed. With the test input available on the UVA online debugging portal (the one for the UVA Online Judge), this code takes ~100ms ( on PowerShell) or ~180ms ( through on WSL) to cover all test cases, including JVM start-up time. I use Java 1.8, like the UVA platform. The run times are safely much lower than the 1 second of runtime offered by the Online Judge. 

For all your direction hierarchy, you are basically trying to duplicate an enum, which Scala provides no language-level support for. However, Scala does provide support for enumerations at the API level via the class, which should be extended by new enums. You could try something like this: 

The loop searching for the required number can and should be extracted into a function, which receives the initial value of as a parameter, instead of hard-coding it to 500. The timing and actual execution should be moved into a function, which is called using the standard script idiom of . The floor (or integer) division operator makes all those casts to redundant. Use a proper benchmarking toolkit for timing execution, with recommended best practices, e.g. . Last but the most important - the idiom is frowned upon in the community, when an equivalent can be used without control flow redirection. It makes reasoning about the code more linear. 

Hard-code as little as possible. Try to use more parameters. All those 5's are for a specific use-case. Try accepting them as parameters in your function. Return a instead of a - it associates each price with a count of stamps of that price and makes the returned value more general with respect to prices. is a bad idea, as explained above. Your code style and formatting is OK as per the PEP8 style guide for Python. 

About - remember how I suggested it should return a list of the factors, instead of formatting them into a ? In this case, since the factors of a number should be unique, I recommend returning a , whose elements are guaranteed to be unique, and specifically use a , as does not store its elements in a defined order, while stores them (for our use case) according to their natural order. I recommend using a as an intermediate in this case, as the elements of this are only ever iterated in order and the number of factors of the number is not known before the factors are evaluated - thus it will provide performance characteristics better than a on large or highly-composite numbers with where the number of factors is large enough to require reallocations of the underlying array. Note: You'll need to use instead of , as primitive types are not objects and hence cannot be used with generic containers without boxing to its wrapper type first. However, with the advent of autoboxing before Java 7, the process is transparent and thanks to caching will not incur a large performance hit from object allocation for small numbers (less than 127). Try this: 

Note that 's methods don't throw any exceptions - you need to call on to find out if any errors occurred. Internal calls may produce exceptions which may propagate up to , but that's not the general case. (Check the JavaDoc here.) The same for reading the file. Here my stylistic suggestion (2) should come in useful. Alternative Constructors and Encoding has a constructor , which does exactly what you do manually. You could just provide it the file path and it'll work. No need to manually create and objects. What is that in the second parameter? There's an overload of this constructor without the parameter - ideally, as @Peter Taylor said, you shouldn't use it. Why? "CSN" stands for "CharSet Name", or the output encoding. You'll generally want to pass in , which should be (case insensitive) for . You can find by importing . Encoding can be a problem when you go multiplatform. Note that or do not have such a parameter in any of their constructors. What you would want to do here if have Java 7+ is to use the class ' method to create the with the specified charset. You might call it like this: 

The initial direction is always ; although you accept the initial direction as an input, you never use it. That line should be 

Observations Your code is beautiful (proper naming conventions followed, proper whitespace usage, very readable. I particularly like the type-aliasing, which helps make the whole thing that much more readable than a or ). I cannot personally think of any more ways to make your code more readable, however, I do have 1 suggestion. The algorithm you currently follow is standard and ideal (you even have proper masking of higher-order bits); and in my honest opinion any other algorithm would be tantamount to obfuscation; but if you assume that the code will only ever run on a particular architecture, you could probably unroll the loop. Suggestion 

Style You have inconsistent indentation and spacing. If you are using some very simple text editor like Notepad for writing your programs, you might one check out editors with auto-formatting of code, or use an IDE. Also, you don't have proper whitespace surrounding binary operators. Finally, your variable names are somewhat nondescriptive, but in this case it would have been OK if you had properly documented your methods. 

Obligatory screenshot of output (don't mind me showing off my custom Rainmeter setup :P) - forgive the low font size, the whole thing wouldn't fit otherwise. 

Introduction This code was part of one of my projects where it was used to generate boolean input values for truth tables. I have since generalized it for combinations of variables with only 2 values, and added a dash of general Scala-isms. This has been unit-tested with ScalaTest, and has proper documentation. I rewrote my original code which used bitmasking and shifts because I thought it was too "magical", i.e., difficult to understand at first glance. The bitmasking method also does not give a proper ordering of the values as I would have liked it, which this method does. This also embodies the concept of a multi-line expression-bodied method. Notes My IDE (IntelliJ Idea) recommends not using superfluous parentheses, but I leave them in for clarity. I would like reviews on any and all aspects of the code and documentation, including but not limited to performance (not really important over clarity to me here, otherwise I'd have used the bitmasking version instead), clarity and idiomatic nature of the code. Running Just copy into a file with extension and run it in the Scala REPL as a script. Example usage: 

You'd retrieve the result with a dictionary lookup similar to . You'd simply do preceded by , where is the name of your dictionary variable. 

What you do is very inefficient. You check if the elements of the list are similar from the outside in, and that too utilising both very unintuitive pattern matching and guard clauses. Note: You do not need to specify the type parameter in the recursive call to , as the compiler can infer that. Your code, on simple singly linked lists, is O(n2), thanks to the repeated O(n) calls to . The code that I explain and provide below runs in O(n), as reversing a list is O(n) and subsequently checking for equality is also O(n). What is the definition of a palindrome? While what you have mentioned is absolutely correct, there's an easier way to think about it. A sequence is a palindrome whenever it is equal in every way to a sequence that contains the elements of the first sequence in reverse order. That is, a list is a palindrome if and only if it is equal to its reverse. I think that as your code already uses enough library functions, why not try this: 

All in all, functional programming is about composing functions together to write programs; immutability and stuff is good to have but it isn't primary. You have some repetition, as in the check - see if you can get rid of it (Hint - you might want a function which can iterate over the values of the enum and check if any of them have won). Also, this 

and . Primitive to Object boxing costs time! Plus, a only has amortized constant lookup time, not true constant lookup time. What you want here is a pure old array, somehow indexable by s. That's possible, pretty easily, in fact. Plus, you are reinitializing the on the turns of your test counter loop. You could just call on it, if you end up using it at all. For an array, however, reinitializing it is the way to go when clearing it (reinitialization is amortized constant time (including GC), not linear like clearing the array. It's linear time in both cases for the , and there's additional GC overheads). Lots and lots of I/O in a tight loop. That's always a bad idea, as I/O form most performance bottlenecks. Maybe you should take the input in separately before you do the processing? (2) brings us to using separate methods. Now that your I/O and program logic have become loosely coupled, you can easily separate them into 2 functions. Trust me, a function call overhead is not too much of a problem here. (I don't do this is my "Improved (?) code below" as it's mostly a stylistic issue, but you should). uses pattern matching and regexes under the hood. Those can be pretty slow. For faster I/O, you want and family. 

In Python, the accepted style is to use names that start with capital letters as class and type names, hence variables should be: 

I am going to focus only on the time aspect of your code, not the style or anything else, as that is not what you have asked for. i hope there will be others who will comment on that too. Obvious Culprits 

This answer is mostly an addendum to @Peter Taylor's answer, so I'll not address previously addressed points. First things first - you ask us to reduce your code without changing it. That, obviously, isn't possible. So you'll have to settle for changing your code. Others have suggested minor changes; however, I'll go wholesale with my recommendations. In fact, I'll even show you a way where your code becomes just 3 to 5 lines long! (Warning: Java 8-fu ahead!) Method names Your method naming is plain horrible - it lies to the reader and API user (and that's after ignoring the typos - you probably meant instead of . As to why it lies to the reader of your code - that's usually you - and other users of your code - that has been already been clarified by Peter, so I won't bother with that here. Whitespace Whitespace is free, and makes intractable sections of code more readable - here, space around operators and before opening braces is the Java convention. Bracing Style Use a consistent bracing style for blocks - the Java convention is to put the opening brace on the same line as the declaration, and the closing brace on a new line at the end of the block. Try to always use braces even for single-line statements - it lowers confusion originating from wrong indentation and makes it easier to add code later to that block. Method visibility When you don't want a method to be exported (you don't, usually, for methods that are implementation details)(that is, to be available to anyone for use and abuse), you want to use the visibility modifier instead of or (the default if you don't specify a visibility modifier). I'll cut you some slack on this as it does not look like this app will ever present an API, but recommended practices are recommended for a reason. Method Signatures It's easier probably for your formatting purposes to return or - but that's not what one would expect. In the case of , it should return (for ease of use) or (for performance reasons, not that that should ever be your primary concern). , (which should be (or to satisfy my tastes), by the way) should return . However, you've probably noticed by now that is already returning the sum of the factors (shouldn't it be named ?) - so why not just use that in , excuse me, ?