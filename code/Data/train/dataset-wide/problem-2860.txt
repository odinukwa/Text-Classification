You should write a PHPDoc style comment which explicitely states that specific parameters should not contain user input. This would of course also be the case if you used a whitelist to check against existing table and column names, as no user should have the ability to change arbitrary tables or columns. 

Echoing Your class should not echo, because it makes it very static and non-reusable. What if the calling class wants to handle it differently? It can't. Either handle these cases with a return, or throw an exception. Class size In my opinion, your class does too much (user model, handle sessions, register, delete, login, logout, etc). I would think about splitting some of this in different classes. Security: Cookies Important cookies should be , so that they cannot be read out via JavaScript. This limits the damage an XSS attack can do. Security: SQL injection Filtering is not the solution to SQL injection. Right now, it actually works fine, but what if your website grows larger, you get more developers on board, and then a user requests that they can be named "Jack Smith" or "super_awesome" or "Jack O'Rily"? As your filtering is very restrictive, a developer might "improve" it, or just remove it completely. And then you are in trouble. The way to prevent SQL injection is to use prepared statements always, everywhere, for all variable data. Security: XSS Same problem as above. Currently, you are save, but for how long? When echoing variable data, always protect against XSS. Security: Hashing is better than , but both are not ideal. If you still can migrate easily, use bcrypt. Inconsistent return values Sometimes, you use / as return values for success/failure, and sometimes / (sometimes these even mix in the same function). Try to be more consistent. Misc 

Security XSS You might want to consider HTML encoding the database values such as product name, description, price, etc. It may or may not be needed currently, but generally, you might want more than one type of user in the future. You may have a site admin, a sales manager, data entry people who add new products, and so on. If you do not encode these values, less privileged users could escalate their privileges via XSS. CSRF You also do not have any CSRF protection. This means that an attacker can add products if a logged in user with the right to add products visits an attacker-controlled website. As you are also open to XSS, an attacker can gain XSS via adding products. SQL Injection Escaping is really not the preferred way to defend against SQL Injection. It's certainly a lot better than nothing, and if used correctly will be secure, but in practice, prepared statements result in better and more secure code and are really the only correct way to handle SQL Injections. Structure Your code is generally quite readable, but it would be even more readable if you would separate code into classes and functions. This would also make adding new functionality a lot easier For later exercises, you might want to look into MVC. But even for a small example script, you might want to at least separate the database connection , so in case the credentials change, you do not have to change them all over the place, but just in one configuration file. Functions would help make your code even more readable. You might consider functions such as , , , etc. You might also consider extracting those methods in a separate class (or a class for the database interactions, and a class for the displaying functions). Misc 

These do not add any information, and thus actually make your code harder to read instead of easier. Misc 

Personally, I would create a real feedback object, but for this example I have kept it as an array, which may be fine for your purposes. Now we can use this function in a more generic function: 

You could extract the validation into its own function. It's shorter, and in case you change how you handle errors, it's easier to change: 

Comments I always appreciate method level JavaDoc comments, to get a small overview of what a method does, what arguments it accepts, and what it returns. It makes it a lot easier to see what's going on. Misc 

Approach It's good that you realized that additional commands can be added (what calculator seriously only needs and ), and that a programmer should think about how the program can be extended. It's also great that you realized that is just . And for a quick solution your approach is fine. But what if you now want to add next? Would you just add yet another loop? Sooner or later this would get really hard to read and maintain (it's already not the easiest to read). I don't want to suggest a completely different approach, but there are many math parsers out there which you could check out for ideas. One of the things most of them have in common is that they separate the parsing of the input from the actual calculation of the result. Ideally, the interface of your code would be such that adding new operands is as easy as you just passing an operand and it's functionality and precedence to your code. Misc 

There isn't really much to optimize here, but there are definitely improvements you can make regarding usability and coding style. 

I haven't looked at all the code in-depth, but here are some first thoughts about it: Error Handling Neither printing exceptions nor ignoring them is a good approach, especially for a low-level class like yours, because you don't allow the calling code to handle the exception like it wants. For example, users will probably want to create a custom error page. Input Sanitation It seems that it is impossible to distinguish between GET and POST variables, which is not ideal. HTML encoding should conceptually happen when outputting, as that is where XSS actually happens; that is when you know the context you are inserting into, which means that that is when you know how to properly defend against XSS (imagine eg inserting into or tags, or into attributes such as ). Encoding directly on input also means that you get unclean data, which may matter if you process the input somewhere (this may eg matter for passwords, or for external functions such as ). In your case, you also miss quite a lot of input, such as from and . For some (legacy) applications, it may still make sense to encode on input, and remember that in specific situations the input must be decoded. But since you are writing your code from scratch, it would be a good idea to use a proper approach. Something like a templating engine which by default encodes its variables might be an idea. For input sanitation, you still might want something restricting your input, eg like this. Structure Your kernel class seems to do too much. It handles and sanitizes input, loads modules, processes modules, seems to be responsible for routing, etc. Most of this work happens in a large code block in the constructor, which really hurts readability. At a minimum, I would expect classes such as and , and methods such as , , etc. Routing Whitelist Maybe I overlooked it, but it doesn't seem that you have a whitelist that checks if a method is actually allowed to be called with the given parameters (such as here). As your class also does routing, I would expect something like this to exist (it would also make it a lot easier to use the router, as it would give an overview over what routes exist). Sure, you could just say that all public methods are, well, public. But I don't think that this is an ideal approach for a framework, as you want to make it difficult for your users to mess up. Documentation It would greatly increase readability if you would use something like PHPDoc comments for your classes and methods. Comments You have quite a lot of comments, which on the one hand is good (it makes your code easier to understand), but on the other hand it's also a sign of unclear code. For example: 

This way, it's easier to see what you are checking, and also easier to see if you made some mistake. Cleaner Code You can always use two loops instead: 

The first thing I would do is introduce an function, because it's nicer to read than . Secondly, all your if statements do exactly the same thing (), so you can just combine them: 

This is still not perfect, but we did get rid of the deep nested ifs. Nested in This pattern is not optimal: 

HTML5 As you are using HTML5, you should think about using the newly available structuring elements (, , , , and ), instead of using generic s. So for example: 

Yes, it will be simple for an attacker to know when they used a correct key. I'm assuming that you would encode a message like this: , and then get it back from a cipher via . You can test this and see that a wrong key will give you a lot of non-ascii characters, making a distinction between correct and incorrect decryption easy. Misc 

or would be alternatives. Another possibility: . Non-technical people will assume that this means they should enter a whole number. If they enter a different number, give feedback accordingly. Consistency In your first version: getNumber outputs the prompt each time, while getBool does not. This should be consistent. The names of the input variable should be consistent as well (either or . I would prefer . Other You can do instead of . As already mentioned on UX, show the possible values for the boolean answer in the prompt when asking the question. So 

It is of course a matter of taste, but I find this a lot easier to read. I also extracted some duplication to a function and removed the tags which did not seem to have any purpose. You could generalize the function even more, resulting in less code, but also possibly reduced readability: 

Security I haven't looked at the security aspect in-depth, but this question might interest you. Here it is also suggested to not start at 0 for every encryption. Apart from that, Don't be a Dave and Don't roll your own (Although I'm assuming that this is for educational purposes only). 

The Attack What you are basically talking about is DOM based XSS. But it's a self-XSS, so the only possible attack vector might be via ClickJacking (depending on the used browser). Still, it should be defended against, especially for usability reasons. Proper Defense Here is OWASPs guide on preventing DOM based XSS. Basically, you should first HTML encode the input, and then JavaScript encode. For your example, the second part doesn't seem necessary, just encoding , , and should be enough. Your Defense Well, your defense works. It could be simplified a bit though. There really doesn't seem to be a need to set , and I also do not see the need for (or am I missing something here? Browser compatibility maybe?). That would leave you with