On a more important note: this is not encryption. Yes, you are using an AES Encryption library to process your data, but you have one, unfortunate issue that prevents this from being considered encryption. 

Why the ? It's completely unnecessary. There's no reason to have the code if in an block here, because you have an early-return. 

That will print , not only proving that this method works, but also proving, I think, your original design was flawed. How do you create an empty object if the only constructor for it requires a Byte-Array? 

First and foremost: while mutation may be generally frowned upon in F#, in some cases (like this one) it's acceptable to make a tradeoff of immutability vs. performance or maintainability. In this case, it serves both of those goals. Let's say you want to do this idiomatically, and you want to avoid directly mutating the array. It isn't that hard: 

Best-Practice Concerns Concerns about your are pretty obvious as well. You have, unfortunately, fallen into a bad-practice here. Using a field to store all the information, and merely is a poor idea. Why? Because there are certain features you can no longer get. 

If I had more time (going holiday shopping with the GF soon) I would describe how we could eliminate mutating it, but I think this lesson stood to prove it's point: we can almost entirely avoid mutable state in F#, and we also learned a few cool tricks on the way. 

Whitespace is free, use it. It makes it clearer as to what steps belong together. I would personally prefer this method, as you can extract this out into LINQ-SQL style, instead of using the methods. Personally, I prefer the LINQ-SQL style rather than the methods, but the choice is up to you. 

Even if you write impeccable code, you will still be judged on the quality of the external packages that you use. The packages from are of very low quality. Here's my complete program. It's a first draft. 

Go is statically typed. Every variable has a static type, that is, exactly one type known and fixed at compile time. You are not in dynamically typed Python anymore. You could use reflection, BUT DON'T! 

The code does not depend on the iteration order over maps. The iteration order over maps is not specified and is not guaranteed to be the same from one iteration to the next. A zero value map () or an empty map reasonably returns the zero value int (). In all other cases, for both 32- and 64-bit s, the result is obviously correct. For example, 

Your is a massive clutter of messages. That may make sense for debugging, but it doesn't make sense for production. What is the purpose of this and similar statements. 

which use the idiomatic, efficient range form which allows the compiler to bypass some index range checks and calculate len(a)-1 once. Unless there are at least two array elements, no sort is needed. The upper limit for the outer loop is len(a)-1 not len(a). Especially in the inner loop, avoid unnecessary address calculations, index range checks, memory accesses, and exchanges. Also, avoid inefficient comparisons. 

Go uses the testing package to write tests and benchmarks. These are the results for benchmarks of the various selection sort functions. Each benchmark sorts an array of 1,024 random integers from descending to ascending order and then sorts it from ascending to descending order. 

Once more, I come to you for assistance! I have written a significant bit of code that converts IP Addresses from strings to minimal byte-arrays. (So that you can store them in a binary format instead of as a wasteful string.) It currently works with IPv4 and IPv6 addresses, saving both to a 16-element byte-array. (The IPv4 addresses are padded with 0's at the beginning as per this RFC. It currently is only capable of converting an IPv4 or IPv6 address to a byte-array, though I am going to be adding the reverse conversion soon as well. I've omitted XML documentation from it to shorten it up to the relevant code, but you can view the code (as of this version) in it's entirety on GitHub. As usual I appreciate all comments on anything you see here. 

This whole thing screams for adjustments. Since C# it constantly trying to become more functional (why? we have F# for that...) we should take those same functional paradigms and apply them. That first line in the method () should be the last. Define your functions before you use them like we would in F#. (Not sure if you have experience with it or not, but that's what is required.) Next: 

Depending on the logic, I may also even recommend tracking that further up the stack, and only call to this function if it needs updated. (Rather than for every update.) 

We use a boatload of reflection, but it's pretty simple. We use instead of , and we have to call , but it works. At this point I want to talk about the transformations: we have a method for each object type as you mentioned: 

Go uses camelCase: . Go uses a capital letter for the first character to export identifiers. Use functions to encapsulate complexity: . Bubble errors up so that each level can handle them appropriately. Local variables such as and are not exposed outside the function. The function runs at the end of the function instead of the end of the program. For output files, check for errors on . Don't panic in packages: . is a rewrite of . Note that now truncates the local file only if there is no error reading the remote file. From a design point of view, we may want to download the latest version of the remote file if available. If there is an error, common on remote connections, we can elect to fall back to the last local file. Robust code gracefully handles failure. And so forth. There is more, but I'm out of time. 

Now we have an easy way to test. Let's make sure that we can handle all reasonable values. Here are some values that you don't handle. and so on. You should always expect the worst from user input and handle errors gracefully. For example,' 

Code should be readable, correct, maintainable, robust, and reasonably efficient. Readability is a prerequisite for the other characteristics. Start with Go Code Review Comments. You write: 

I reorganized your code. Don't write code as a heavily indented stream of consciousness. First, write the normal flow. The first step in a code review is to read and verify the normal flow, it should be obvious. Second, add exception handling. Third, add error handling. Sensibly minimize indentation. See Indent Error Flow. For example, a simple first draft, 

Also, we try not to abbreviate too much in C#. Something like isn't really necessary, and instead should better reflect what the method is doing: is a much better name, but even if you stick with the original intent, is also generally expected. 

Based upon a question from Stack Overflow, I wanted to expand on the answer I wrote and define a solution that would support ordering the strings (after processing). So this starts off with a basic , and you can guess what it's going to do: 

As you can see, it's still nice and short, and it's more robust than the original. :) This was an excellent start, and hopefully you take more out of this than just a bug fix. :) 

Even then, is truly unnecessary. I'd bet there is a separator of some sort between commands in the string, which really shouldn't be a string, but should be something like the following: 

I needed and for the next stage of a project I'm working on, so I developed them. I also needed to determine if two lines intersected, preferably as cheaply as possible. (Lots of physics calculations.) So, I built . Then I built , then . The intersection code is my favourite part, essentially it builds both lines in slope-intercept form (), then solves for , then plugs into the first line to get , and returns that point. For this method, I defined coincident lines as not intersecting. (Since they don't intersect at a single point, but instead an infinite number of points.) Once the point is found, determining if line-segments intersect is simple: just check if the point falls within the bounds of the rectangle of the line. (Why? We already know the point is on some location of the line, which means we only need to determine if it's falls in the range of our segment . I built the method to also check the since I named it .) 

Code review is an iterative process. If there are significant changes, open a new question with the revised code. 

Your rationale is "I easily forget some things." That's not a problem. What is a problem is that you don't know how to easily find this information in the documentation. No employer wants employees who write idiosyncratic, unreadable, and unmaintainable code. Similarly, you write, 

The code in Abdallah Hodieb's question is good (LGTM). I prefer the simpler, more readable form of the first loop. 

The Go programming language was designed to operate at Google scale. Go programs are usually written to be reasonably efficient. For example, assume that your function is used by Google's search web crawler on billions of HTML pages (with multiple scripts per page) per day. I see opportunities to make your function more efficient by using CPU time and memory only when necessary. To estimate how much your function might be improved, I ran some Go benchmarks. 

Your program is running 100,000 client connections using goroutines. One connection has a problem, so you crash the program. We have 100,000 very upset customers. Handle errors and fail gracefully; return errors; don't or . See Errors. 

The unnecessary conditional path and indentation are a distraction. The most important path is the correct path. It should be easy to read the correct path. 

We know that this is safe to do (a nil value for conn is OK) and that it is the expected behaviour because we read the net.Dial source code. 

The most important property of a program is that it is correct. For the Caesar Cipher, Latin letters are rotated, in either direction, by a fixed shift amount. Decoding is the reverse of encoding. Your algorithm looks suspicious. I tested your algorithm against my algorithm. Encoding "Hello, 世界" for shift +25, your algorithm gives "a~\u0085\u0085\u0088, 世界" and my algorithm gives "Gdkkn, 世界". Your algorithm: 

Etc. I won't go into detail on all of them, but you get the picture. Do note that is a custom type I built myself, not the built-in .NET ones, you can cut that and out if you want to try to use this and build your own alternative. Now eventually we come to the point where we want to use the types: 

Oh boy, there's a lot to talk about here. Good news is we have plenty of time. First: you variable naming is not the greatest. I.e. is not self-explanatory, is. I'm not going to comment on the names of the properties (or fields if you're into that) of the types, since you didn't post the definitions. But if you add a new question with the type definitions I promise I'll be just as brutal (but in a good way) on them as I was on this code. :) 

Though, it is fairly difficult to break statements like that into multiple lines while maintaining readability, I find this much more readable than what is already there. Likewise, this: 

Here, you do and , what if I told you that there's nothing different between and ? Because there isn't. The is a little more interesting: because operators in F# can be treated as functions, we can actually create a partially applied function for , by rewriting it as , and then as , which takes the operator and applies as the left-hand argument: 

In this case, you have a lot of whitespace to the left of the conditions, usually in this case I just break the to a new line and then work from there.