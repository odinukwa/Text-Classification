This is just wrong. The standard approach for determining whether some string occurs within another string is to loop over the substrings of that start with the first character in , returning true if the characters that follow are equal to the remaining characters in , in order. 

In fact, those four functions could be rolled up into one function that still satisfies the single responsibility guideline (note the name: the function does exactly what the name says, and nothing more), and it isn't all that large: 

Even in Java, the fizz-buzz problem should be very small (allowing a couple of violations of very standard coding practices): 

Two of the key sins in software engineering are scope creep and gold plating. Scope creep is a sin committed by clients and managers. Gold plating is a sin committed by programmers. This is a perfect example of the latter. The requirements for fizz-buzz are very simple. There is nothing in those requirements regarding printing 25 values per line. An implementation of fizz-buzz that prints one value per line is just fine. While Java is well known for being a long-winded language, even in Java, an implementation of fizz-buzz that is 63 lines long (counting blank lines and comments) is far too long. As an interviewer, I would congratulate you on getting the answer right. However, in the post-interview meeting, I would most likely recommend that you not be hired. 

Rule 1. When I add the same identifier twice, does it may sense to throw an exception saying that the cannot be added? Is there any harm in 'doing nothing' here? Rule 2. Trying to add a list id to the included lists throws an error if it's already belongs to the excluded. Does it make sense to introduce some helping methods like or ? Does it make sense to throw an if an empty is provided? 

I need to define an entity () that contains and manages two collections of identifiers ( and ) that are ids of some other entities (). The business rules are the following: 1. The collections must contain only unique identifiers. 2. The same identifier cannot belong to both and . 3. Identifiers can be added or removed (performing the checks above). Note: Adding an identifier to the is not opposite to removing it from the . For instance, there is a list A that contains included lists B and C and excluded list D. That means that . An attempt to add list C to the leads to an error while C is in the . If the list C is removed from the , the list A will be the following: . I introduced two properties to get the collections and four methods to manage them. There are few areas I'd like to hear some feedback about. Which variant is better? Property naming 

It's neatly formatted and follows standard naming-conventions. I found it easy to follow the logic. I'm not sure why you switched from a to a . It doesn't buy you anything, and makes the code more verbose. (If you did it as an optimization, the effort is misplaced. These days, Java compilers turn simple String concatenations into StringBuilder appends behind the scenes. In any case, even if you were doing this trillions of times in a tight loop, the possible savings from StringBuilder would be negligible compared to the time to format dates and whatever I/O you're doing). Rather than using a method, you could create an (e.g. ) and one or more implementations. This would be a bit more object-oriented and more future proof. You wouldn't have to add the flag (or whatever future formatting options might be needed) to the interface, but have that knowledge in a specific implementation. What is the foreign character string when ? If it's not a typo, it might be worth writing a comment to explain, for people who can't read that language. I'm not sure that is the right name, nor whether it is necessary. You don't use a constant for the other date/time formats in the method. 

This does not do what you think it does. It creates a list of elements. If you're using C++11, they're all garbage because those elements are default-initialized. Fortunately, you'll never run across those garbage values. Your calls to allocate a new chunk of memory. You don't want to use a list. Use a vector. When I run your program on my computer, compiled with optimization level 3, I get timing results of 

You did that here. What if is 0 or 1.75? You'll get a when your function performs in the case is 1.75, and maybe that's what you want. The function will return 0 in the case is zero. As others have noted, your function only works for . If you truly meant a base 2 function only, then you shouldn't promise that you can handle any base. An alternative to using log for this base 2 logarithm is to use the fact that python provides a function available on all platforms (even those that don't use IEEE floating point) that does exactly what you want: 

While neither one of these is a very good integrator, the latter choice is far better than the first. You should try the two variations and see what happens. Once you see that the second choice is far better, you might want to learn about more advanced integration techniques. 

A more drastic change would be rather than using , you might consider using the "Null Object" design pattern. That is, create a implementation of (an interface) that returns, for example, for any and for . This would eliminate a lot of conditionals and make the code significantly easier to read. 

Update: As requested by David Harkness, I have knocked together an implementation based around a polymorphic Node object. I'm not saying this is necessarily a "better" implementation, but it just shows an alternative way of implementing the code that removes a large number of the conditionals. Note: It's not a fully working implementation. It's just a gist. I haven't bothered implementing and if you the same value twice it won't overwrite the original. I haven't done any testing on it, so it may be full of bugs. I'll leave it as an exercise to the reader to finish it off. 

Other than that, you have implemented the algorithm correctly. It's worth noting that the way this algorithm uses recursion could lead to a stack overflow for a large block of color. Also, by dint of the +1 and -1, will end up calling fill() multiple times for each cell. 

The above raises a exception if there is no such index. The easiest way to deal with that is to simply let that exception pass through up to the caller. Doing the same with your next chunk of code reveals another one-liner: 

Now it's a simple matter of assembling the output. Once again, this is much easier than you made it out to be. Simply swap the values at the pivot and swap points, and then reverse the digits after the pivot point. Putting this all together yields 

One last point: You did not mention how you are using and . I'm assuming you used one of the following: 

A key problem with a monolithic construction such as my is that it's hard to see what's going on without lots of commentary. A key problem with a slew of overly-short functions such as in your implementation is that it's hard to see how things fit together without lots of commentary. There's a happy medium where you can still understand individual chunks of code and where you can see how things fit together, and without needing an excessive amount of commentary. Some comments about my code: 

The tests should be easy to maintain and understand. That is the tool that drives development. Sometimes it may contradict with the widely known rules you mentioned, but it does not mean we should be fanatic about that (as soon as the tests drive the development and work as the safety net). 

Also, you have to create an instance of the wrapper in the production code, haven't you? So, what is the purpose of the static class then? Static classes are inconvenient for unit testing. Instead of introducing wrappers that mimics the original class, you can simply get rid of statics at all and go with simple 'injectable' abstraction and implementation: 

Does it make sense in declaring 'Add' methods as and 'Remove' methods returning ? (similar to .NET collections). Does it make sense in adding other collection-specific methods like or ? 

That's totally fine and even more - introducing 'common' initialization logic increases coupling of your unit tests. Imagine you need to add a new 'common' line to setup things common for a few tests. You never know for sure if there are any other tests impacted; you may make your tests false positive. It's more safe to modify your test 1 by 1 as necessary. Tests like have about 6-7 arrange lines and 2 assertions. IMO, it is easier to read, understand and (!) maintain this single test than splitting it into two (or more) just because of the 'one assertion per test' rule. That looks like Facade tests. That might be fine to have them at some level, but it's important to understand that tests like that may be a bit more hard to maintain since there are more parts that might be broken during refactoring. Don't have any oppinion on that... Looks fine to me. 

Having lots of conditionals makes code difficult to read, which is reflected in the fact that you've had to put comments throughout the code to remind yourself how it works! How about this... 

Normally there's no need to specify the color to change from. You only need to specify the coordinates and leave it up to the flood fill routine to find out what color is at that location. I would define another method that is public, and make the recursive method a private implementation method. The public method would look up the color at the location and then call the private method. 

The public interface of the class is nice and small. The code is laid out well and follows Java coding conventions. The tests have reasonable coverage. There is a lot of unnecessary looping and casting in your code. Here's a more concise version that passes your tests: 

To add one more thing to janos's review suggestions, one thing I noticed is that many of your comments are saying essentially the same thing as the code. I'd suggest leaving them out. Developers can read code and trust it more than comments, which often get out of sync with the code.