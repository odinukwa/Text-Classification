I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

With advancing insight I have found a few issues with the code. Check for convergence doesn't work properly 

The latter is nice because you are certain you won't have any attributes from the last run leftover, messing with your methods, the former is nice because you don't have a multitude of instances (I am not sure what happens with the first application when you create another one, since it isn't stored anywhere). Not exactly knowing which way was the cleanest to do this, I asked a question on SO about resetting classes. It seems that calling or any -methods directly is bad form. We could however move the definition of the class attributes to and do the following: 

Ok - now we've got most of the pieces, we just need to put the actual program logic together. Let's move on to the method: 

From a high level, I have to disagree with your class design and names - they're really modeled after your implementation (, , etc.) instead of your problem domain. I would've expected to see some classes such as , , etc. I won't attempt a straight refactoring - though there's isolated areas of code that could be improved on, the main thing that jumps out at me is the mix of concerns spread across all your classes. Currently, your classes all know way too much about and user input - you need to centralize that logic, and split into dedicated layers: UI, business, storage. Here's an attempt to walk through a design - which should hopefully give you enough to tweak the specifics to meet your needs. Any compile errors or bugs are intentional and intended for learning purposes. Just kidding - though I will take some shortcuts since MarkDown isn't the best IDE. Let's first extract out a class so we'll have something to work with: 

In addition to the other remarks: does exactly the same as , so you could either call that directly: 

I have been refactoring this code myself as well in the meanwhile, so I thought I'd post some of the insights I have gained myself. Class inheritance Instead of passing a instance when creating a , by making a subclass of , I was able to reduce the amount of information that was stored in both classes. This makes accessing the attributes and methods of in 's methods shorter as well. does nothing 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload. 

Length You provide a method to calculate the length of the list. But from the moment of creation of the list, you should be able to track this length. If you add a private counter, increment it whenever a node gets added, and decrease it whenever a node gets deleted, you should be able to instantly provide the length, instead of having to compute it each time the user requests it. Repeated code You provide methods for deleting the first node, the last node, and any node. In the first two methods you kind of repeat the code of the latter method. You could redefine those by calling the latter: 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

This is basically a pipe and filter pattern - where you construct some number of filters into a chain and just pass the outputs to the next filter. If you control all instances, then the simple thing is to abstract out to an interface: 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Now, each filter simply takes an input and transforms to an output. We need a pipe to tie to it all together: 

If you're familiar with inheritance, hopefully you can see how you could add that functionality into a 'PersistentInventory' subclass. Hopefully, you can see by splitting the functionality out cohesively both readability and maintainability. Think through adding the following functionality in v2 of your app with the various designs: 

I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them. 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

You can over the directly, getting a . Or you can over and just get the . Either would be preferable to going over the just to get to the (and you don't check the return of ). I'd also change the name of your variable since the trailing implies that it's multiple dictionaries (FWIW, I'd probably go with just just so I didn't have to ever read a potentially offensive word over the phone; but that's just me!) 

Note the weak typing of using - if these classes are used somewhere else, implementing as an explicit interface would probably be preferable. You could do generics, but that makes the chaining harder. 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

I have been trying my hand a bit at creating a big integer class in C++. This is a continuation of a homework assignment. The class stores a big integer in a double linked list. Each slot contains 8 digits of the number. It is possible to create an instance from an integer or char array. Negative numbers are supported with a bool sign indicator. I implemented addition, subtraction and multiplication, aswell as their operators. I didn't manage to come up with a good division algorithm though. The code: BigInt.h 

Ok, now we have enough to get to refactoring the class. Currently, your class has too many responsibilities - it's showing the menu, tracking the current state, and adding/removing products. We're going to trim that down to just showing the menu and tracking the current state: 

Couple of quick comments, since you don't really specify what you were looking for. Seems like everything other than should be ; I probably wouldn't make them extension methods either. I think the whole thing would be better suited to a rather than 3 or 4 coupled methods. Your recursive is an odd implementation that I haven't seen before. It looks like it'd work OK, but doesn't seem standard. Your method seems broken; it never adds the ; I'd probably just replace that class with a or something since it doesn't seem to add much value but could be a breeding ground for bugs. No reason to on ; just return the generic . What happens if or is ? Looks like a , when I'd expect a list of all the added or deleted instead.