Don't explicitly check for files If not explicitly stated by your professor, I wouldn't log anything to . If you can't read from the input/can't write to the output file, this is a problem for the caller, not something you can deal with. A rule of thump is that problems related solemly to the arguments are to be dealt with by the caller because he has to decide how to deal with his illegal arguments. As we can not simply rethrow the because of the method declaration in (given be the prof, I assume), we catch them and throw an with the as its cause. If you are allowed to change the declaration in you should add an and simply delete the -clause. Using java's try-with-resource statement Another improvement is to replace the with a clause. The way it internally works is that you can declare multiple resources after which are automatically closed when you exit the -block by calling their method. This way, you don't have to deal with closing or manually, any longer, and they are always closed so you can't even implement the close errornously. Using #codifica(int) Generally you should avoid copying source. As the implementation of is alread given in the base class, you should just call that method directly. This also allows child-classes to override the transformation. 

I'm mostly interested in the design of and the efficiency of the algorithm and the returned result. If you find any bugs, please point them out. Any comments on code style and readability are appreciated. 

I have not seen the other answers talk enough about how you manage vector sizes. Design Issue You are declaring but at least you are using consistently. This would normally be using . (see Ben Steffan's answer point 2) Implementation bug has a bug. Specifically, if , you are overflowing which leads to undefined behaviour for and overflow for . The standard implementation of offers a method that returns the largest implementation defined capacity. Reserving or increasing the vector beyond that size throws a . Similarly, in you might overflow . Naming should be called . is . is . is called in C++. This leads me to my last point. Adhere to the container concept If you want your vector to be reusable in other contexts, you should adhere to the container concept. This would allow other libraries, e.g. to use your container. Part of this would be to change (note also that you should be taking this argument by const reference) to aswell as implementing an for your container. 

I have been writing a small compiler generator for which I need to solve the strongly connected component problem. As the Guava library contains, to my knowledge, no implementation for that problem, I have decided to write my own based on Kosaraju's algorithm. For this, I have created a class and a to iterate over the graph. 

A couple of years ago I wrote a pair of class templates to encapsulate specifications which have one or more of a minimum, typical, and/or maximum value, e.g. on a datasheet like this one for the 741 op amp: 

1 When I played with the private inheritance solution in the demo program's I discovered that Intellisense shows all of the underlying container's member functions despite the fact that most of them are inaccessible: 

Can my solution be improved? Are there any C++11 or C++14 features I forgot to use that would improve it (I'm compiling with Visual Studio 2017)? Is the name for the container a good choice or is it too similar to the objects it contains? Also, I've made the constructor private and deleted the copy constructor to try to make sure only a can construct a and nothing can copy one -- are there any other ways to construct or copy a that I've missed? Is it a good idea to prevent construction/copies or is it unnecessarily restrictive? 

Check the length before sorting It takes constant time to determine the length of a string but is \$O(N\log(N))\$. If the lengths don't match then you don't have to sort. 

You could do the same with the code that acquires the expenses inputs (in fact, you could write one function for both). Don't use magic numbers You've got a lot of repeated code like this: 

Now I just need to change the definition of once to use a number other than 4. Use to enforce the condition that \$N > 1\$ If your compiler supports you can ensure that \$N > 1\$ at compile time and cause a compilation failure with a simple message to explain the problem. Function template The multiplication algorithm is basically the same for any \$N > 1\$, so this function is a good candidate for a function template based on the dimension \$N\$. For example, you have with , but in the same program you could have a matrix (2D array) with and the same code is used to multiply with both matrices. Here's a demo using a function template: 

It's a shorter name for the container. This comes in handy when referring to the container and/or its , for example: is shorter and easier to read than . It's easier to change the container. You may decide later to use a instead, in which case you only need to modify the statement rather than all instances of . 

But there are a lot of instances where needs to be replaced. At the very minimum you should define 4 as a constant and use that constant in the code: 

I frequently design classes which model an object that has multiple submodules of the same type. For example, I have a class for a Printed Circuit Board (PCB) which has multiple subcircuits (I will call them "ports"). The class for the PCB () uses a container (e.g. ) as a member variable to store the subcircuits. Client code needs to be able to iterate over the ports to query the state of each port, control the port, etc, so I need to provide iterators for the ports. In general the board may have multiple subcircuits of different types (and therefore multiple member containers that need to be iterated over). For example, the class might have a for the ports, a for a data bus of voltage signals, etc. Thus I cannot simply provide and member functions -- I would need to call them something like and to differentiate the container of objects from other member containers. Such non-standard names would prevent me from using range-based for loops (which depend on functions named and ). I searched around on Software Engineering SE and Stack Overflow to see if there was a standard solution for this, and I found a couple of interesting suggestions to create a container class that privately inherits from the appropriate standard container (e.g. here and here) and makes the accessor functions like public. However, this seems to go against advice to favor composition over inheritance (e.g. here and here) when composition is possible. Below is a solution for a class that has multiple objects stored in a container called that uses composition instead of inheritance. and are simplified from the actual code, and for this review I'd like to focus mainly on the container class and the related accessor functions for it in . (Note that the first port is numbered 1, not 0, since that's how the ports are numbered on the physical board's schematic.) Board.h 

Please let me know the corrections that I can make to improve the code. Please tell me your opinions so that I can improve myself. 

There are N pots. Every pot has some water in it. They may be partially filled. So there is a Overflow Number O associated with every pot which tell how many minimum stone pieces are require for that pot to overflow. So if for a pot O-value is 5 it means minimum 5 stone pieces should be put in that pot to make it overflow. Initially a crow watched those pots and by seeing the water level he anticipated O-value correctly for every pot ( that is he knew O1 to On). But when he came back in evening he found that every pot is painted from outside and he is not able to know which pot has what O-value. The Crow wants some K pots to overflow so that he can serve his child appropriately.For overflowing the pots he needs to search for the stones in forest( assume that every stone has same size). He wants to use minimum number of stones to overflow the K pots. But he doesn't know now which pot has what O-value. So the task is to find out the minimum number of stones that the crow requires to make the K pots overflow in the worst case. Input Specification: 1) A array O corresponding to O-value of N pots {O1, O2, ....... , On} 2) Number of pots 3) K -value ( number of pots which the crow wants to overflow) 

If bar is not square in shape, then the largest possible square piece of Chocolate is broken and given to the first child in queue. If bar is square in shape, then complete bar is given to the first child in queue. 

Please let me know the corrections that I need to make the code better.Please tell me your opinions so that I can improve myself. 

Output Specification : Minimum number of stones required to make K pots overflow in worst case or -1 if input is invalid. 

Example: Let say there are two pots 1)pot 1 has O value of 5 , O1= 5 2)pot 2 has O value of 58, O2= 58 

Problem Statement In a School, Chocolate bars have to be distributed to children waiting in a queue. Each Chocolate bar is rectangular in shape. Consider its side lengths are integer values. The distribution procedure is as follows:- 

Let say crow wants to make one of the pots to overflow. If he knows which pot has what O-value he would simply search for 5 stones and put them in pot 1 to make it overflow. But in real case he doesn't know which pot has what O-value so just 5 stones may not always work. However he does know that one pot has O-value 5 and other has 58. So even in worst case he can make one of the pot overflow just by using 10 stones. He would put 5 stones in one pot if it doesn't overflow he would try the remaining 5 in the other pot which would definitely overflow because one of the pot has O-value of 5. So the answer for above question is minimum 10 stones even in worst case. Implementation: 

Alternative solution I would map each character in the two strings to the number of times it occurs. If all the characters in one string are present in the other (the two maps have the same character keys) and all the characters occur the same number of times, then the strings are anagrams. Once you've built the strings' maps you can use to check that the two maps are equal. Here's a demo: 

I've developed a set of functions to convert a or to a or insert it into a using . They are intended to be part of a larger library of conversion functions so I've included a few additional functions in the library for demonstration. There are two versions of each function: the normal one in the namespace, and one that uses a compact form of a string in the namespace. For example, the ratio is normally converted to the string and its compact form is . Not all conversions have a compact form, so in those cases the functions in simply call their counterparts in . Conversions of s take advantage of the conversions for s if the period ratio matches a typedef provided by the standard library. Similarly, proper conversions are implemented for period ratios which match a typedef provided by the standard library (e.g. and ). Here is the header file of functions, convert.h: 

Your comments could use some improvement Your code doesn't contain many comments, and it would be helpful to see more of them. For example, it's not immediately obvious why there's a separate function to delete the head () vs. a different position (). You should add comments to explain the requirements of the different functions. Even if you know why you have two different functions today, you might not remember if you look at the code again in a month. Some of the comments you do have aren't very useful. For example: 

Use more whitespace in your code It's difficult to read code like . Instead, use more whitespace as in . 

While it's a good idea to provide documentation on the parameters for your functions, these comments as is are not helpful. They just take up space and are distracting -- after all, I can see the names of the parameters just a few lines below the comments. Instead of simply listing the parameter name, provide some explanation of what values it is allowed to take (e.g. should be between 1 and 12, inclusive), what happens if the parameter value is not valid, etc. 

Not only is this an opportunity to refactor that code into a function, but the numbers and (arguments to here) appear multiple times in your code with the same purpose. Instead, define a constant (e.g. ) and use that constant. This means that if you ever want to change that value you'd only have to change the value of that constant once (the value of the ) instead of trying to find the literal all over your program. Use meaningful comments Your functions are commented as so: