it assigns a value to the String . now, I assume that the logic was meant that should be assigned the name of either or but the code actually allows for both statements to be false and the value will then be an empty String. You can fix that by changing the flow to an one 

The actual iteration over the collection is left to the stream library which may decide to optimize this instead of sequential loop. The code is more concise and clear. 

the class seems (to me) to fit the "utility" pattern of class that has only static methods (like or Apache's ). Therefore, I recommend that the non static method be changed into static. That would eliminate the calling (static) method having to instantiate an instance of . so there is already a method in . For clarity sake, choose a different name for your method (unless it is dictated by the exercise). how about I am not sure what was the exercise but you need to understand that this is not the proper way to parse an XML document into a Java bean. In the 'real world' there are 3rd party parsers that can build a out of XML document. Now, if we stick to string processing, the method does not really parse an XML element. all it does is cut a substring of a given string. I mean it is fed the starting and ending tokens. If it is to be an XML element parser, it should be given just the element name and it should figure out how to find the text part of the element. in psuedo code: 

Here are my comments, in order of severity: Bugs Did you test your solution? because it does not work properly. Try to invoke the method with argument 2147483646 (max integer - 1) Performance In the place where you do check for overflow, you first parse into double, and when you decide it is safe, you parse again into int. you could just return the double casted into an int. Code Clarity 

Too.Many.Comments. You should only write comment when the code is not self- explanatory, and that should be as rare as possible. Because it is your code that will be maintained, not your comments. If you feel like you need to write a comment, you should consider how you can refactor your code to make it clearer before writing the comment. I think your integer's variable declaration should be all togheter, or even parameters for a method (which shouldn't be the method , by the way!). You need a class, or something like that. Keeping code in is evil. In this class, you should split your mandelbrot generation and your image generation to make it clearer. Also, there are alot of maths in there. Personnaly, I like when maths are encapsulated within a method so I don't have to care about the equation, just about the result. eg. , which is a part of your code. You should be able to understand what a line of code does as fast as possible, and this equation means nothing to me. So if you could create a method, named with what the equation does, and use this method, it'd be much cleaner! Using OOP, your code would be much easier to read, and it'd be easier for people to understand it and for us to review the implementation instead of the design! 

In my opinion, the real problem you have with your algorithm is the number of time you go through your array. Going through it only once would bring better performance. I'd have a hard time explaining what I changed without showing you how I rewrote your algo. I decided to add all the values, since you can't know what is the highest/lowest score until you finished looping the array, then substract the highest/lowest score (more than once if needed). 

it states the purpose of the condition more clearly "is the queen's position outside of the board" what if, for some reason, queen position is advanced two places beyond the board's Size? 

instance variables and never get initialized and are never used. input file is never closed. some variables are declared out of the scope they should be. For instance in is declared outside the loop but is initialized and used only inside it. It will be more efficient to read the entire input file to memory. Java 7 has methods that do just that and that returns of s according to the input lines so you already know where new line was in input There is no exception handling. to have throw the exception is not good practice for exception handling. 

However, you forget to protect the code from NPE (): at the beginning inside the try block, both handlers contain . You first open the output handler, and then . However, in the clause, the order is reversed. So, if an exception is thrown while opening , is never initialized and you might encounter NPE in the clause. it is absolutely essential to ask separately about each file handler before closing it: 

This design also greatly simplifies the code for deciding what to cast (hint: oyu can get to an enum instance from its String name using ) now what about maxLevel? is it the same for all skill types or different? Moving on: in your game, every has the same set of skills. that's fine. but every develops differently and this should be reflected by individual Skill instances together with the attributes that can modify a basic `Skill' 

I think in these types of questions, where input is known and does not change, arrays are bettter suited then Collections, since they offer more concise syntax: is more clear then naming conventions: variables start with lower case. 

To sum up, the difference in complexity is because you seek different interfaces. Both interfaces are valid and work. Which one is more natural depends on the application. Edit: Here is a code sample of your version. Note that I just use auto return type deduction (as you suggested yourself in the code comment). 

Besides that, the code looks fine to me. Good job! Please also consider the alternative I wrote in the first part of this post. 

Like Kumar have already mentioned, just keep it simple and use . It is a very efficient data structure since every element is stored next to each other in contiguous memory. This gives you great cache utilization for sequential access (which is what you do in the loop). As for the ordering, right now you are doing 

The definition of function composition. A call to your is semantically equivalent to . Calling the linked article's is semantically equivalent to . Which definition is more natural is completely up to the reader. Both are perfectly valid. Your has the nice property that it is very easy to implement with variadic templates (since the recursion uses "pop front" logic). This is actually mentioned as an alternative in the linked article. Furthermore, they argue for their definition of function composition because it follows the reading direction. E.g., is semantically equivalent to which follows the expected behaviour of first receiving data, then decoding it, and finally storing it. To get the same semantics with your definition, we would have to write . Again, this does the same thing but is arguably harder to decipher during a cursory read-through. Alas, the linked article goes through a world of trouble to get that "pop back" recursion logic to work (using Boost.Fusion). So they do as they do not because they are oblivious of variadic templates but because variadic recursion simply doesn't cut it. Here's a quote from the article: 

First of all, ? come on... how hard is it to call it or ? (no need for , we can see its type) but what does the line mean? why are you asking about the first character? ok, you want to know if the subsquent String is to be added or substracted, right? so why not make a method that returns an enum that has values and then you can have a separate method that accepts enum and performs the actual operation. The benefit of this design is that you are better prepared for new operation requirment like which will mean... I don't know, something. Now that I think of it, perhaps you can add the identifying character to the enum values and then in you extract the first character and search for the matching enum, which is a behavior of the enum: 

I am not sure how many lines of code can be reduced but one thing is for sure: whenever you encounter a resource that can be closed, you should use Java try-with-resources feature (since java 7). Not only this feature saves you the operation (one line less!) but also ensures that the resource is properly closed by the end of the try block no matter if it ended successfully or not (the compiler adds a clause). in the current code, if an exception is thrown, the resource is not closed properly. I looked at the thrift javadoc and indeed from version 0.10.0, is auto-closeable. So the code on both methods should be 

First of all, I do not understand how this may happen, since in you ask on unequality of user ids. anyway, at the very least, you should make a method like . 

I think your abstract class should "implement" the interface, because otherwise you will always have to put both the interface and the base class in your inheritance list. Also, I think you should name your Repository -> SqlRepository, since all the code in the base class is coupled to Sql. As @Heslacher pointed out, you should inject your connection, because keeping the static connection might cause problems. What would happen if one of my implementation would dispose the connection? All your repositories would be down. 

Your implementation of the pattern is good. You've understood the pattern pretty well but I don't think the choice of which pattern to apply should be a responsibility of the class! This looks like a perfect fit for a pattern. You've got an interface to use and you need to pick one implementation based on a conditional statement. That line is the best explanation I can give about the factory. :p So let's start by extracting this factory from your class : 

If I remember correctly, accessing a row by and is built to be the fastest operation you can do on an Azure Table Storage. The performance drawback of using a probably isn't worth it unless the returned entity is really big. I feel like you should stick to the , but there's no better way to be sure than to profile both your solutions for performance to see which is better with your data. Because there's nothing else to say about your code, from what I know, you have the 2 existing solutions in your hand. Figure the best one now :) 

This way, there's no confusion about "abe" being everywhere, heck, I don't even need to know what is inside the variable, I just need to know it is equals to the retrieved one because I used it to retrieve the account. Actually, the use of constants should be heavily considered in my first example too!! Note : The string messages, aren't necessary. The default assertion message for will be very clear that the actual value isn't equal to the expected one. And your test name shouldn't include . You know it's a test, there's the attribute juste above :) (You should take a look at @Konrad's comment about naming!) 

All that being said, let me review the code that you already have written. Because, like I said, it is still an interesting approach! 

A very interesting question. I can identify two main differences between your implementation (using variadic templates) and the linked article's implementation (using Boost.Fusion): 

instead? I don't have the signature of an so it is hard to know. Beside those semantic issues, the code has good overall structure. Good job! I only have comments on the details. I'm going to assume that you use C++03 in the following: 

Edit: I recently read D4128: Ranges for the Standard Library: Revision 1 by Eric Niebler which proposes to overload all algorithms with Projection callables exactly as you did. Note that the very same proposal also includes Range Transform View which is an analogue to the iterator transforms I mentioned. That is, Projections and Range Transform Views coexist and serve slightly different purposes. You can read the proposal to get all the details. In short, a future C++ standard may include a feature which is very similar to your suggestion. It may even come sooner than C++17 in the shape of a TS. 

That's definitely an interesting approach. However, I would say that this interface is trying to accomplish too much. That is, should just be responsible for calculating the average value over some range and not worry about any indirection. E.g., only provide the signature 

Note the proposed alternative implementation using a reversion adaptor. That would be a nice C++ exercise. I wonder how that would compare complexity-wise. The linked article's implementation supports arguments such as . Yours don't. Of course, this adds extra complexity to their implementation compared to yours. There's not much more to say on this point.