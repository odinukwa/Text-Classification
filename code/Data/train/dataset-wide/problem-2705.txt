I'm going to expound on this answer later (when I'm on my Python 3 machine). To begin with, there's a lot of repeated logic, especially in the , , ... methods. You can avoid this with a class method to generate these instance methods. 

This does not seem to be the intention of the code. Assuming you want to check all lines in either and you may want to use the following code: 

This contains the name of each object, any keyword arguments that are necessary, and any attributes that also need to be created (as objects themselves). These can be created from this structure using the following functions: 

Sort But wait, this decrement function suggests that we turn into and turn into . This clearly isn't correct. While the outputs are larger than the original and the digits sum to the correct value, they are not the respective minimal solutions. However, if we sort all of the digits after the incremented digit in ascending order, the minimal solution is achieved. 

Sure, you could remove the global variable by moving the memoization to a decorator and adding a base case scenario to the function. 

There are minor style things that could be improved in the code, but that's unrelated to RxJs, so I'll not comment on that. 

Specify types explicitly whenever it's possible (including for methods and for instead of ). Use instead of -- it will help detecting unintended assignments. Try not to move things around when it's not necessary. E.g. the following section is pushing one array's items into another. 

Update 2 A related blog post. and a comment on it, and another one tell more about ternaries in functional programming. Another way to look at it is through the prism of a truly FP language, such as Haskell. Here's a link to comparison of if-vs-pattern-matching. In fact, a chain of ternaries resembles pattern matching functionality a lot (yet, not necessarily the same). Do not stick to the old dogma of "ternary is bad"! Harness it for the win! 

The result may look something like this. I'm sorry if I missed something — I don't know how to reliably test that my refactoring went well. Plus, it's a late night in my timezone now, so my brain acts funny. :) 

DISCLAIMER: I'm not very familiar with Redux. In my book triggering requests based on request completion is business logic. (Or even more generally: triggering "something" based on "something else" is business logic.) If something is business logic, I'd rather make sure it is implemented somewhere in my reducer, rather than a service. So, either the or its would emit a proper action ( in this case). 

This allows for a arbitrary number of objects to be created. However, this runs into some problems when we want to use the context manager since it is not natural to have an arbitrary number of required contexts. This can be achieved using a recursive function. Here, we will supply a sequence of callables that are to be opened with the statement, and a callback function and arguments to be executed once all of the contexts are opened. 

With this approach, the same result is achieved, but with much less code. Combining this all into a single function yields: 

I echo both of the previous reviewer's sentiments, but I'd also like to add that regex is overkill for the parsing here - will work just fine. Implementing this and some of the other suggestions might produce code like: 

Here, the "inc" and "dec" operations were abstracted into a dictionary of . This is slightly more complicated than it needs to be (one could simply invert in the "dec" case and add the result to the register), but allows for other operations to be easily added. The end usage would look like: 

My approach, design, implementation, and performance description I've solved a similar problem in the past and recalling the way I attacked it back then. To reach the bottom right cell, we need to either reach its upper neighbor and move down, or reach its left neighbor and move right. By induction, for the upper (or left) neighbor to be reached, we in turn need to first reach their upper or left neighbor and make a single move. And so on, until we find that we're at the top left position of the grid. If the "neighbor reachability moves" were recorded, replaying them in the reverse order results in the path we are after. Graphically it can be represented like this 

Your code has a structural repetition. The same cycle is written for every coin nomination. What you could do instead is create a coin registry, and use it in a generalized loop. 

Each invocation results in creating and returning a new unless special measures are taken (like , ...) 

Design decisions and improvements (as in "better approach(es) performance- and memory-wise"). Code readability. JavaScript (ES6) language idioms. Whatever you find important to say that does not fall into three categories mentioned above. 

I think having one in your definition of sublist is perfectly appropriate, but the use of isn't appropriate because you are going to need a list anyway. You aren't using it wrong, there are just better solutions. Also, as noted in the other answer, you can avoid repeated slicing by creating a copy of the list on the first run of the function through an optional default argument (see in the code below). Finally, summing three lists in your return statement is probably less than optimal. With unpacking in Python 3, you can turn this into a single comprehension which should be better in terms of intermediate object creation. 

Finally, we want to create a decorator which will do the following things: (a) create all of the objects, (b) generate and enter the required contexts, and (c) execute the supplied function. 

In addition to the recommendations suggested by @Austin, you could inherit from to create an object to register and recall your functions. For example: 

These do the same thing, but are much more readable once one knows that can be used to iterate over both the index and element at once and that is a common method to iterate over a list backwards (albeit, slightly inefficient). A final note is that I have updated all two-word names to use snake-case. 

UPDATE: You can run performance tests I prepared based on various code samples from the answers to this question: $URL$ When I ran them, I see that my code is second best performing. The best is the one by @Kevin Cline (up voted!). 

Here's my take on it. The following code uses the same idea about the string representation of date that is directly comparable for sorting. It is not possible to tell in advance how performant will this solution be compared to one you presented above. It all depends a lot on how many dates are being sorted. If you deal with tons of dates, there will be many more invocations to the arrow function we're passing to . Therefore, it's not good to keep translating the date via every time our arrow function is being used. Instead, I recommend three steps: 

P.S. Many programming languages that have functional traits don't push a developer very hard towards writing functional code. This is especially true for the languages that acquired these traits as a result of evolution (like C# and latest versions of Java). Developers can still write imperative code even in Scala, the language does not prevent that. Obviously, there's no silver bullet in programming. There will always be bugs out there, no matter what king of programming language we're talking about. It's the human beings who write the code, and we are not perfect in it. Realistic expectations may help a lot to achieve satisfaction instead of disappointment. 

Per Graipher's answer, I extended the chance of victory to accept an arbitrary number of regions and number of wins required. 

The biggest improvement you could make is to generalize the two-gram, three-gram, and four-gram functions, into a single n-gram function. This can be done with using lists instead of manually assigning , , and so on. 

I don't really understand what this function is doing, but it seems messy and could likely be improved. Then your function can be greatly simplified. 

We can't increment any of the 's since isn't a digit. Thus, we must increment the . From this, we learn that 's can't be incremented. 

To be honest, I didn't read through your code much because I don't have the attention span and it seems the biggest issue is the approach rather than the solution. Nothing about your code looks terrible or un-Pythonic, so I'm going to go through a different approach instead. The first thing that I noticed about the next number is that all but two of the digits of the original number remain unchanged. When going from to , the was incremented to a and the was decremented to a . When going from to , the was incremented to a and the first was decremented to an . This pattern suggests that we may be able to increment one digit, decrement another, and arrive at a solution. The first challenge is to find the digit to increment. Increment 

There's nothing (obviously) wrong with your code. You deal with observables the efficient way, IMO. Cache is good. The fact you're constructing a "base" observable in constructor without subscribing to it there is good as well... There are only a few things I can point out: 

This may be a bit more compressed at the cost of readability, which I provide as an option rather than recommendation: 

For me it's a situation where it's really hard to make a suggestion. To me the code looks pretty clean. I can only make a few points on style, which is probably subjective to a certain degree. Comments In The Code I am generally not a fan of comments -- developers can live with "just code". Maintaining comments is burdensome. I recommend you find a way to get rid of them. Refactor -> Make Comments Useless -> Remove 'Em 

It's always possible to break away from loop execution interfering keywords like and . It is also almost always possible to quickly rewrite the code in a "more functional" way. Question is, what exactly is the motivation. First, in functional world it all about function. And even though my code below does not use function composition, I'm adding , , and to simplify a few conditions. Another benefit of that is that these local functions' names are replacing the ugly comments. Second, is used to find out whether there's an item close to top. This is made as an independent step in the code and IMO it's more expressive this way. If there's no item close to the top of window, we can try to find the last position before the scroll. Again, now it's implemented as a dedicated step (via and ). Hopefully, it's now closer to what you wanted the code to be. 

Now you don't have to register each effect in your dictionary after the function declaration and this should clean things up a little. Additionally, if you import this object, you can add functions anywhere, easily see what effects are registered, and you can add logic to the class itself if you want more complex behavior (i.e. address the case where an invalid string is entered). 

Notice that this isn't contained within a because there isn't really a need for one; a method does the job better. Also, I made some (bad) changes to make the algorithm less readable. This new regular expression counts the number of 's that occur successively starting from the second-to-last digit backwards and replaces the old loop, the at the end absorbs the original . Now, if we really want to make things unreadable... 

Having a function mutate a global variable is a bad practice. In this case, it may seem easy enough to reason about what is going on, but I guarantee that at some point it will lead to an insidious bug that is hard to track down because you have no idea who is changing the global variable and when. Recursion is not necessary here; it over-complicates the solution and may make it difficult to change/update the code. 

State represents the final cell the robot needs to reach, and the arrows in neighboring cells show the direction of the move. States and show how the neighbors referred in can be reached. States , , , and show the same for the neighbors referred in and . This picture can go on and on, but there are three (four?) more special cases: 

Feedback I am looking for Here's the list of things I am interested to hear back (in order of significance): 

Update As @Gerrit0 suggested, is a better option than (more concise and achieves exactly the same result). 

I think, the key is in not fighting the complexity in-place, but rather move it out. If the language does not provide a construction you need, you can try using a library (like lodash; I'm not sure if it has what you need). If you don't want to use any third-party dependencies, you can still home brew the missing thing. It can be as simple as an importable isolated function: 

Code I really don't like sorting an array of primitive type element. Instead, I use which is a key-value object, where the key is used to sort the array by it. Please assume the code is correct (as CR requires it). At least, the tests are green on 52 data inputs ranging from 0 to 99 elements. 

Iterating backwards was smart, but, yes, there is a much simpler way to do this using a list comprehension – this is how one typically filters a list in Python. 

Here's a version without , I'm not super happy about either. Neither version seems particularly elegant. 

We can't increment the because we can't decrement any of the 's. We can't increment the right-most 's because then decrementing the would lead to a number less than the original. Thus, we have to increment the first . We would reach the same conclusion if we considered the number instead. From this, we learn that trailing 's should be ignored. 

We can't increment the because decrementing any other number would result in a number that is less than the original. We can increment the , because we can then decrement the . From this, we learn that the right-most digit should not be incremented. 

Or, as suggested in the other answer, test the number modulo 4 to figure out which path to take and avoid recursion all together. 

I don't see why you want/need three functions to download the different quality videos. There is a bunch of repeated logic both in the functions and in the main loop. Then, I would move all of the specific code into the section because that's the purpose of that section.