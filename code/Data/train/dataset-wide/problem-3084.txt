"myMatch" isn't a very good name either. C# is case sensitive, so you could simply use . In fact, this whole block suffers from some poor naming. 

You're likely to run across 101 different little gotchyas by rolling your own here. For example, you're not escaping any invalid characters in your solution. I would build your implementation on top of the existing UriBuilder class. By using it internally, I'm certain you'll save yourself many headaches down the road. 

Personally, I don't see a point to the and functions. It seems they don't do much except save a few keystrokes, but you've already written them and they're not actually hurting anything. I guess they're ok. This statement really needs some braces. 

Create a convenience constructor that takes in the external type and maps it to your internal model. 

You have a HUGE problem, and I'm surprised no one mentioned it. What happens if your code throws an error after you've set , but before it gets set back to ? It remains off. You really need to put some error handling in there. 

The doc comment seems to be at odds with the name . I would expect this to check on the current location of the crawler. Which, on further inspection, is exactly what it does. So, the comment is a bit misleading. It's not obvious what this method does by either its name or comment. 

Y r vars all 1 ltr? Is that hard to read? You betchya and so is this code. Just glancing at this, I'm completely assaulted by a large number of single letter, very similar, and practically meaningless variable names. Words to the wise: 

If you replace with the more standard name, you could get rid of the comment saying . I think it just reads more naturally that way. Give it some breathing space around comments too. Removing comments like is also a good idea. 

I recommend making it virtual so you can override the behavior if you find a need. Perhaps it's premature to do so. 

You're swallowing every possible exception with nothing more than a message in a log file. You should figure out which exceptions you can gracefully handle and catch only those. 

You could simply raise the custom errors I've mentioned and be done with it. (Easiest, but not necessarily the right thing to do.) Create two new interfaces. I think creating a that holds the common contracts makes sense. would implement only and all of your other existing classes would need to be changed to implement both and . The second new interface would be for those "presenter" methods that aren't really presenter methods. (By far the hardest, but perhaps the most "correct" option.) Create a single new interface for this new class. It will duplicate some code from both and . 

Keeping code DRY is a noble goal, even for test code, but it's less important for tests. Our first priority when writing test code is being precise and clear. The tests are the specs and the specs are the tests. It's important that it be immediately clear what the state of the mocked object is. We can expect to duplicate a certain amount of code. Looking at your test, in isolation from your extension, it's difficult to tell exactly what is going on here. 

While we're at it, we should take note that does not (and should not) be changed at runtime. Thus, it should be declared as a constant. 

Only the first one will pass the validation because you're checking for space around the lambda operator. Considering that these will (by necessity) be passed as strings, the user will not have the benefit of the IDE fixing the spacing for them. All of these should be allowed to pass through validation. The solution is to make the spaces optional with the question mark operator. So, the final regex pattern I came up with looked like this. It doesn't address the validation of the inline function after the lambda at all, but some of the concepts here should help you do some of that. 

You'll want to store your three different statuses at the module level and create them at an appropriate time. Perhaps on the sheet activate event. Otherwise, you'll need to create them on the fly each time the procedure is run. I'm not sure which way I'd go, but the important part is abstracting the data right now. 

I'm not sure the controller should be responsible for creating the models outright. That responsibility should be with some provider or factory that gets injected into your controller along with the view. 

Your question has been answered in my opinion, but this is Code Review and if be remiss to not point out that you might as well just be swallowing those exceptions. Sure, logging them off is useful to a point, but your user is going to continue on, blissfully unaware that their data has not been saved. Which means that you will likely be unaware of the issue as well. Oh sure, you've got the log, but do you really ever look at it? I'm betting you don't. Speaking of the exceptions, I don't see a great benefit to catching and , only to turn around and swallow every possible exception that could happen. If you're going to catch , you might as well remove the other two catches. 

I don't know much about threading, so I can't really comment on that, but there is an opportunity to extract some logic that I am sure is used elsewhere in your project. You have this in 

As I think you know, your grammar allows strings like and . This is definitively a bug, and a damn hard one to squish. Part of the problem is that Roman Numerals are not a context free language. (i.e. We want to add in this case, but subtract in that case.) I think you were right about counting the tokens, but I took an approach of doing it in the lexer, which I'm not sure was a good idea. It might have been easier to do at the Parsing stage, but it seemed to make sense to me that this be a Syntax error. Anyway. Here's what I did. I derived a subclass from the Antlr generated . This class counts the number of consecutive tokens and alerts any that there was a SyntaxError. 

Also, is a very poor variable name. These are both moot points though, because that variable is entirely superfluous. That part of the function can be rewritten to directly return the value of the expression. 

And a class implementing it. uses to create a default instance. The Logger class remains unimplemented for the moment. Console.cls 

I agree with @Heslacher about this particular statement, but I think it's a bit foolish to say that all s are bad. It's just senseless to use it for what could be one line of code. 

Pass things as parameters, or through the ctor instead. It's called Dependency Injection, you'd do well to study it. Don't go thinking you need some special framework or anything though. Look into "Pure DI" a.k.a. "Poor man's DI". Lastly, I think you missed the model-view-controller pattern by a bit. The controller doesn't seem to do much, while the views's code behinds are doing an awful lot of work. 

Just a quick comment. According to your header, you're making assumptions about the argent values. For example: 

I recommend making these named ranges and referencing them that way instead. It will greatly clarify the code, and as an added bonus, make your code less coupled to the exact location inside the worksheet. If you need to move these cells, you can simply make the named range point somewhere else. This way, your VBA code wouldn't have to change. As it is, you would have to hunt down every reference to these cells. By the way, I really like that you explicitly call on the range. ++ Good job there. Making the explicit call reduces confusion and bugs. With an implicit call, you run the risk of accidentally getting a reference to the range instead of the value itself. Yes, yes. Good call. 

But why? Observables/Observers are a really useful pattern?! You don't ever see anyone implementing Observers by hand because the language natively supports the pattern via Events. Way back before VB6 the Microsoft languages had this pattern built into not just the language, but into the philosophy of how these languages are meant to work at their core. There's nothing actually wrong with your implementation, but using events would be a much more idiomatic way to code it.