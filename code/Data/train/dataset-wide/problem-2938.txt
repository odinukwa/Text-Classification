The second option above only works because you run the entire functionality of the class from within the method (which may or may not be bad form). When the new instance is created, the back and forth prompt is executed right away, so the moment it would go out of scope and get deleted (because it isn't assigned anywhere), is only after you are done with your input and output (and possibly been given anyother option to reset). 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

Only during shrinking do we have to evaluate more new points. So we can extend the code where we break the iteration with a modification of the array and move the loop evaluating the simplex to outside the while-loop. 

I have been trying my hand a bit at creating a big integer class in C++. This is a continuation of a homework assignment. The class stores a big integer in a double linked list. Each slot contains 8 digits of the number. It is possible to create an instance from an integer or char array. Negative numbers are supported with a bool sign indicator. I implemented addition, subtraction and multiplication, aswell as their operators. I didn't manage to come up with a good division algorithm though. The code: BigInt.h 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

This post is specifically for the GUI, since this is my first time working with PyQT, so I am not sure if all is done properly. The file with the file with the classes Query and Universe and an example JSON file can be found on GitHub. 

This checks if the minimal and maximal function values of the simplex are sufficiently close together, but an easy counterexample shows that this nowhere near guarantees convergence: Consider the function . Of course this is trivial to minimize, but using this algorithm, we would have a simplex of 2 points. Let those points at some point using the algorithm be and . Then the functionvalues will both be , and the algorithm will stop. Instead, I changed this to checking the value of the centroid of the simplex. 

With advancing insight I have found a few issues with the code. Check for convergence doesn't work properly 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

I have been refactoring this code myself as well in the meanwhile, so I thought I'd post some of the insights I have gained myself. Class inheritance Instead of passing a instance when creating a , by making a subclass of , I was able to reduce the amount of information that was stored in both classes. This makes accessing the attributes and methods of in 's methods shorter as well. does nothing 

Because I am new to C#, I am interested in advice/commentary on good form, but I am also interested in the efficiency of this implementation. 

is defined, but used nowhere else. Also the use of is bad (was an oversight). Indirectly still iterating over 

However, in most cases, only one of the points of the simplex changes between iterations. So only one point needs to be re-evaluated. Conveniently, this re-evaluation is already done in the previous iteration: 

I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

If you want, you can always refactor functions like so that you type less. Something that I see a lot of people do is: 

This comment doesn't really add much value. Enclose your main code using an guard. Avoid putting it in the global scope. 

This one is a little subjective. For an algorithm like this, it makes sense to only write pure functions as that can make debugging easier. Your code is readable and clear, if a little contrived, but I wouldn't worry too much about this. JavaScript is sort of a weird language to ask this about since most functions won't follow this rule especially when you do DOM manipulation and frontend JavaScript. 

To invoke these methods, I would then have to export the models to the external calling file, which seemed like bad practice to me because I would then be exposing unnecessary internal parts of the module. My reasoning for designing the module the way I did was so that I could abstract away the complexity and only expose necessary methods. Is this good practice or am I approaching this paradigm completely wrong? This code works and accomplishes what I want it to do, so it falls under working code as per the site guidelines. If I invoke the exported functions in a one-off script however, the function will execute and then the script will hang because was never called. As far as I can tell from the mongoose tutorials, database code is supposed to be wrapped within a call, though I am not entirely sure how that works since the code that I have above works fine for database access and update. Should I wrap the functionality here with , and if so, what is best practice for doing so, or should I wrap the calls with in the external file invoking these methods? Is there a better way to do the bulk insert in the function? 

For a small game like this, your implementation of is okay since you don't expect to have lag spikes. has no guarantee for its timing and it's behavior can vary from browser to browser. You should use to do this instead. Additionally, it is a bad idea to have your physics engine tied to your FPS/tickrate and it can cause unexpected behavior with more complex games. You can get around that by calculating the delta time between each update and using that to do your physics calculations. 

Anything involving styles should probably be in an external CSS stylesheet. You can paste your HTML into the question and make a runnable snippet so that we can try out your application. 

I have the following code on my server that takes a string and inserts newlines in such a way that the string is separated into lines, all of which are shorter than in characters. This ensures that the text, when printed, will fit within a certain width. 

Refer here for the definition of a balanced binary tree. If you don't like having two return values, you can always refactor and write a separate function to get the height of a tree. This would allow you to implement it without having to return two values and would improve the readability of your code as well. This is the suggested way to do it. I would say avoid raising exceptions unless you're certain you know you want to. You should never raise an exception if you don't have to. 

Be aware that if you are modifying the objects in the list, you should use the copy to make a deep copy of them if they are not primitives. Try to make your code less verbose. 

Comments about the code are appreciated and welcome, but I have a few specific questions about best practices with regards to using Mongoose. 

As mentioned in other answers, list comprehension is the fastest way to solve this. However, I'd just like to point out that you should also consider using a generator function if it suits your needs to prevent the need to load the entire dataset. 

Welcome to Python, and welcome to Code Review! Here are some basic tips to help you along. 0.5. EDIT: I think you also have an unused import. is not needed. 

as implemented above is computationally expensive. Depending on your use case, you may want to consider using regex. Don't pad your question with lorem ipsum lol. 

You're asking for elegance and conciseness. Elegance doesn't always mean short/hackish, and neither does conciseness. You should never sacrifice readability for brevity unless you're codegolfing. As per your comment, just because you can read it doesn't mean the next maintainer or developer can. Someone (maybe you) revisiting this in 5 years should know what the code does without having to pick through it. Let's start by breaking apart the code into its components. 

welcome to Code Review and the Python language. You're off to a good start. Here are some tips to help you on your way. 

One important thing here is that you should put the game logic inside an guard. This prevents the logic inside from being exposed globally. This method of organization is just one way to do it. Of course, there are other ways to organize your game that make sense, but in general you should group together similar things and prevent circular dependencies. Avoid accessing member variables directly.