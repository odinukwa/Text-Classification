As lazy IO is considered deprecated, it is better to use iteratees/conduits/pipes to work with IO effectively and in compositional style. Here is an example using pipes: 

( is the result of the last computation in GHCi.) There is a function in Prelude that captures such a process of applying some function to the result of applying that function to the .... and so ad infinitum. 

From that nice formula it is easy to see that the process of computing √2 is iterative. You just need to decide what function to iterate. Let us consider this one: 

Haskell also allows different datatypes to have common field names, so the code could look like this: 

Also have to note that I like your coding style: domain-specific type aliases and short functions with descriptive names make code easy to read. 

Not a full review, but: is completely unnecessary. Because Data will be null if you didn't set it within the If portion. Just add an to the previous if and have it . 

This has the benefit of treating null input essentially as if it were not provided, which would seem a more expected result. You could still have an error thrown, but I don't see the value. If you choose to have an error, at least make the issue more obvious. "Prototype chains are assumed to be delimited by Object.prototype." is confusing and unclear what the issue is to me. I would go for something like: "Cannot appendToProto of null." In general the error message should indicate what is wrong with the input instead of the codes philosophy regarding what its input should be. 

We are using the return value by returning the even though this information is no different from the parameter that was passed in. Secondly, if the buffer was small enough, the function is zeroing out the remainder of the memory. This seems to be a wasteful effort. Perhaps it is enough to just null terminate the string? 

A few observations, Avoid comments that do not tell the reader any thing that they can not understand by reading the code. They just add to the visual noice. Instead add comments as to how the function fits in with the rest of the program, or how the function is to be used. 

A few general remarks I find that stepped whiles are as evil as nested if statements for readability of the code. Here, you have three levels of nesting. Relying on the surrounding environment for variables can some times obscure possibility to generalize (You make use of x and m for inner definitions) So here is what I would do 

Side note 2: Some libraries export functions with quite generic names (like or ), it is easier to read code when you have some explicit pointer about were function comes from. You can import library with alias: 

Working with text is easier with . E.g. it has already defined. Tagsoup understands so you don't need many type conversions. For greater amounts of data it will be notably faster and much more memory efficient. Instead of defining you can convert tag stream into tag tree, take first node and convert it back to stream: 

I switched arguments in because this allows to define function more concisely and it is also correlates with update/insert from : they have collection as a last argument. Now it is possible to skip directly to and implement it in couple of lines: 

There's not much here to optimize mostly because there's very little here. A few things you could do: Store your selection to a variable outside both functions (bad idea if you may have multiple notificationDivs). 

I wish I had a suggestion on how to improve your loop, but as you said, it's much trickier than you might think, and I'm probably not smart enough. ;-) Only suggestions I can think of here: 

I know names aren't hugely important but my 2 cents in addition to having already written some of what @tomdemuyt said (which I editted out): 

I'll admit to being new to this concept, and can't think of a real-world application for this method. Regardless, here's my thoughts. Issues #1 and #2 are directly results of your use of Object.Assign which seems an acceptable limitation. Issue #3 is stating a fact of how Object prototypes are set up. The prototype of Object.prototype is by definition null, so #3 is technically a given. However, your questions make your meaning of #3 more clear. 

Writing instead of is not only a bit shorter, it also allows you to change/reorder fields in without updating . Btw, in my opinion, splitting in several lines adds more readability than rewriting it somehow. 

This is pretty nice code. I have two main concerns. The first one is about handling errors. You are mixing tree approaches: , throwing explicit , throwing implicit (as in ). It's better to stick to or — they are explicit and you can handle them in pure code. The second one is about dividing your program in meaningful functions each having single responsibility. Such functions are simpler and you can more easily compose them. For example, checks if dictionary is not empty, adds to pattern and matches pattern. It is better to split error handling from data processing (in this case by lifting dictionary check to ). Another one is : it parses string into list of digits and implicitly checks for nondigits (throwing useless 'no parse' error). You can skip this as you check for invalid symbols in . 

Nice effort, :) here are a few comments. unless you are calling this as part of another class, do not use @member syntax. What you really want is a global. 

I use template haskell to derive data lenses, which make your directory access a little more succinct. I also use ViewPatterns so that the dispatch on string prefixes are easier. 

What happens when the name extraction fails? Also you assume that the name extracted is a valid file name. Is that always the case? (What happens if it is a query?) And I much rather prefer a smaller match like 

Here, I think you wanted to exit the for loop if start was found true right? Add a break after the assignment for both. You want to do this for most of the loops. 

The options are globals. So perhaps it is better to specify that explicitly. This will help in modularization later. 

In this case changing fields in or won't break . You can enable extension to get only specified fields : 

Maps as arrays In you are taversing heights 200 times. It is possible to emulate array with and do this in one pass: 

'encrypts' each letter of input string independently of other letters. This could be emphasized by using at the top of instead of hiding it in helper functions: 

It may worth inventing your own combinators with semantically appropriate names. Here is an example using ExceptRT monad from errors package: 

Vectors as arrays If overhead of trees is too much for you, it is possible to use which is for real arrays in Haskell. 

is the same as , so . You can use instead of to print strings without quotes. Using the fact that , you can merge and into: 

For reference, here's the code I used to find that your program doesn't handle intervals the way I would expect. Add a break point at the commented lines and inspect your locals to see what I mean: 

Your comments are excessive. Commented out code helps no one. If you remove code and want it later, that's what version control is for. Your method is too long. You should break it into smaller pieces. Use loops instead of very similar repeated code for instance: 

Not if I understand what you're doing correctly. So essentially each image has itself, and then some other element that should be before it as a buddy? Assuming they are all siblings, you should utilize some of jQuery's functions that support working with siblings. Here's an example, though I'm sure it could still be better: 

Here is my attempt. It follows ideas from your code but uses function to update vectors. It is subject to fusion hence runs quite fast (test case #15 runs in 0.18s on hackerrank). The code is a bit ugly because of index juggling. Python version does not require this and is much cleaner. 

Now, when you have all of the expansions, you need to filter and count those with numerator longer than denominator. 

With LambdaCase extension it is possible to write without (but it does not seem much more readable): 

is ok here, no need to make it faster. In functional programming functions are everywhere, even inside other functions and this is ok. Using ViewPatterns extension it is possible to rewrite as: 

Note that I'm using strict version of left fold (see here about vs ) and strict . This means that map of height counts constructed in single pass without thunks.