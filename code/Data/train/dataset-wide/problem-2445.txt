It's not really a problem, and I like to gently prod newcomers into learning features like lambdas. That being said, I don't think that your url duplication int the first case is anti-dry, its a perfectly acceptable method extraction and it's private. Within the scope of private methods you can do pretty much whatever you like and it's not going to offend anyone too much. Another possibility that you might consider (though it would be a greater scope) would be to extension method the url so you can do url.ConfigureUriVariable("foo", "bar"). The above would be a bit clearer if instead of a string you used a dedicated Url class. I recommend the built in Uri or make your own. But really, I think you're all good. BTW - the lambda is still compiled to a delegate so the generated CL is pretty similar using either of your techniques. 

Some quick advice since this already has an accepted answer - you will make things quickly less confusing if you use a few other javascript libraries. 

Or for the totally and absolute 1337 (meaning you shouldn't do it for something this simple but it demonstrates some useful techniques) 

I realize that a service and some sort of inter-process communication (whether windows inter-process communication, HTTP, or something else) is more standard and reliable but I have a frequently changing team and don't want to add another step that is necessary to run the app. This seems to work but I've only launched it in a dev scenario. Am I missing anything that would cause problems in production? That's a System.Threading.Timer by the way. 

is already visible from eventListener. It is in fact visible from everywhere inside the immediately invoked anonymous function. Try putting in there and you'll see. This is due to the concept of closures which in technical-ish terms means that when a variable is not found inside a function's context, it looks in the parent context (the context the function was in when created) and so on all the way up to the window object. In plain-english terms this means that you should forget all your Java/C#/Php training and the variables visible inside a function are exactly those that you intuitively think should be. That being said, there is going to be only one instance of for this block of code, so if the is ever attached to more than a single element all instances of the listener will be referencing the same . There are plenty of ways to skin this cat and you really did not give enough details on what your trying to achieve to give advice on best practices but let me try to give some advice anyways 

I'll say it, the generic implementation is better. is a great trapdoor when you get really bogged down with generics or anonymous types and there's neat things you can do with it (see Dapper) but it still has some gotchas. For example, I do not think your function with will work in most cases. expects and returns types meaning all types are being downcast or boxed. Therefore, if your function returns a object, what is stored is still an and what is returned from the cache is downcast likewise. Therefore your property will not be available until you cast, even though it's dynamic. Yes. The generic version - with some subtle yet real differences - will run as if it was written for the type you're filling with. The dynamic version will just be a "value" and let the DLR figure out how to invoke members (which again, unless you're calling or , will fail). will also be slower as the runtime binding has to be done every time, though admittedly this is unlikely to be any sort of bottleneck. Obviously I'm going to say always use the generic version in this case. 

Ok, so I just recently arrived at a way of doing this sort of thing that I actually like so let me share. In my opinion, the if statements aren't really the problem, its more that they are not really pertinent to controller code. Actions should strive to contain code only about major decisions of what code path will be executed. Solution: You take advantage of the fact that a Linq query returns an IQueryable to store the query logic along with the model and an extension method to give it a nice DSL like interface. Similar to the pipes and filters pattern. This is what the action is going to look like: 

Here you go, with comments. Obviously, in production I would have only a handful of comments and not the exhaustive ones I put here. However this is the sort of points I might make during a code review. When I write code I optimize for it for communicating to a human reader what I intend the code to do. In other words - I want it to read like an essay. Therefore, I extract anything detail-heavy into small helper methods at the bottom of the script. The idea is that someone should open my script and the first thing they see should give them a top-level overview of the general flow of logic. I didn't comment at all on your solution itself, instead just cleaning up the algorithms that were already there. 

you have non-unique ids! This is against spec and you will find that many tools and libraries have problems when using non-unique ids. Instead you should use 

A few limitations that I've discovered since then. This will work. However, it is subject to all the Asp.Net (currently 4.5) limitations. 

What about taking advantage of the (stupid) fact that the context parameter inside a function invoked without call or apply will be the window? 

Hmm well according to the datepicker source code it doesn't use the jquery ui widget factory, which is a bit annoying because it's not standard. But global defaults should be set how ChaosPandion suggested. However if you don't want to do global defaults how about your own defaults object? My favorite way of doing that is with jQuery.extend. 

where your clicker span gets a class of and your gets the class of . You could just use directly, but I find to be somewhat more descriptive. 

Javascript Javascript naming convention are to use with no underscores. It's not a big deal but it's pretty standard. The only exception is to use for variables that are intended to be used with the keyword (which you don't have here). To a lesser extent than php, but with the javascript community where it is, its probably time to start considering choosing a javascript framework (like angular, backbone, knockout, or the like rather than using jquery directly. In my opinion you are over-specifying your selectors, no need to do when id is already specified as unique, no need to when holds no semantic nor structural meaning. Consider that all this stuff is indexed in the browser so by adding more selectors you might actually be slowing things down however slightly. You don't need to use to select, you can just say Your scope management looks pretty good, I'm happy to see you using - another syntax which achieves the same purpose and you might find flows better (or not) is . You've got inline styling and html. Why? Just put the element on your html page and show or hide it from javascript. Finally, just about everything you're doing in js is handled in a very elegant manner by the jquery.form plugin. Just use that.