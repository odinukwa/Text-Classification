Singleton? Does it make sense for an application to have more than one instance of the class? If not, then should it be enforcing this through some kind of singleton model? Cleanup and Self Contention As far as I can tell, the code you've posted doesn't actually track which locks have been created by a particular instance of the (or the application it is running in). If a bug/crash/network failure results in not being called then the 'lock file' will end up with an entry in it that isn't necessary. If the user starts up the application again, does it take over responsibility for those locks? Is there a cleanup app that allows locks to be removed? Are warnings raised when locks have been held for too long? It feels a bit like your class should be tracking entries that have been added by it and then ensuring that they are removed as part of the , however that might not actually make sense in the context of your overall application. I'd also be a bit concerned that if you're locking by user it would be possible for a user to run two instances of the application (I do this all the time with explorer) and perform two interacting changes without realising it as both instances believe they hold the lock. This is often overcome by storing an additional piece of information, such as the processId that holds the lock. 

Globals Your tree seems to be built around a global parameter . This effectively limits you to only having one tree in your application at a time. Collections are quite common, so this seems like a restriction that will cause issues in the future. Example usage As an extension of defining the API for your code, it would be helpful in future to include an example of how to use your code. I had a stab at creating a list... It looked like maybe the way to start was with the method. This accepts two parameters a and a value to add. From what I can tell, the first time you call this, it ignores the , assuming that you want to create a new list using the global pointer, so you can pass node as NULL. The second you call it however it uses node so if you pass it as NULL it crashes. This is somewhat inconsistent. With that in mind, your public api should perform some kind of validation to make sure it's being called correctly. Some example calls: 

Buffer Safety You're using a fixed buffer size for your names(15 bytes), however you're using to read the input directly into the fields. If the user enters more characters than the buffer can handle it will result in a buffer overrun, trashing whatever happens to be in the memory afterwards. Header Files / modules Rather than having a header file for each operation, I would tend to have a header for the section of functionality. Possibly 'accounts.h' would be appropriate. This header would define all of the relevant interfaces (add,modify,delete) for your structure. Personally, I'd also put the implementation for these methods in the same '.c' file, rather than distributing them across different files. They're performing actions on the same data structure, so it feels like they belong together. As it stands, it is weird that add is in main.c and the rest of the functions are in different files. switch/break/return You've got a switch statement: 

Best case, the second time you call , it throws an exception and the thread function crashes. Worst case, the doesn't throw an exception and you don't notice that the thread function is in an endless loop, eating processor time. Once you've closed the connection, you should from the thread function to prevent the pointless spinning. 

I like your solution, it's clever & fast, however I can't help but feel like it goes against the spirit of the assignment. You've found a built in system call that greatly simplifies what it is your need to do, which is great, but in doing so you've delegated the algorithm, which may not be what is expected from the assignment. The assignment reads as if it's expecting your to use things like and to iterate through the folders yourself. You would then be responsible for maintaining state, and writing the iteration algorithm. -name or not -name Your argument handling is also a little bit on the naive side. Should I really be able to run it like this: 

One more thing Processing concurrent client messages also introduces a question of whether or not synchronisation is important. It's possible that the third message received might be processed faster than the second message, resulting in it being sent back to the client before the second. If ordering of the messages is important then either the server would need to manage this, or a message structure would need to be passed (for example that contained a message id) rather than just the text. 

At the moment, if you put something like "some random string" it will get confused and throw an unhandled exception. Generally speaking people don't like the use of labels (although this is obviously subjective), which is why I've used a loop instead of . 

Which honestly at first glance made me ask the question 'have they done something funky with exception filters'. Exceptions You don't actually do anything with any of the exceptions that you catch. If you don't need to access the variable, then you can simply catch the exception: 

This is done after which creates the file if it doesn't exist, so it's always going to be there for the check. If you want to change the behaviour (from create new file to append, then you need to supply an extra parameter): 

This is quite nit picky, but I don't like the way that you've got multiple classes in the same file. Whilst the underlying protocol is shared between the Client & Server, they are distinct and having the classes in the same file makes it difficult to follow (if I search I always have to check the owner of the method I'm in rather than relying on the file). This is made worse by the fact that you haven't grouped the implementation for each class together. If you really want to do this, then at least group the methods for each class together. At the moment, the constructor is at the top of the file, followed by the Client methods, then the Server methods and then the rest of the ProtocolHTTP methods. 

You load with the number of times you want to run the loop, then the instruction basically, decrements and jumps if the result isn't zero. Testing bits Your approach to testing bits works, but it's rather long winded having to push them onto the stack and pop them off into a register. Instead, you can use the instruction, which s two operands together without destroying them and sets the flags accordingly. So, you can perform this combination as the main body of your loop: 

All of which would test that the expected value is returned. You might also consider adding negative tests, although they're not covered by your requirements to demonstrate you thought about them and what to do in those situations: 

This comment is after you have called and assigned it to , so from the comment I would assume that you've established a connection to the remote server and started processing. In the context of the subsequent calls however this seems unlikely. It seems more likely that the connection is actually established when you call , after you've setup the URL, Agent and Read callbacks. Try to make your code as self-documenting as possible (through constants, functions, variable names) and use comments to supplement this only if there's actually something to add. 

I'm adding this as a separate answer, because I feel a bit like I'm missing something, which you may well be managing in another class that you haven't posted (and this is too big for a comment). Looking at the problem you've said you want to avoid this situation: 

You're actually calling out to the one that failed to open . Declaring nested variables with the same name is something that compilers will often warn about, so particularly when getting familiar with a new language it's a good idea to turn on 'warnings as errors' and crank the warning level up. That way the compiler can give you as much information as possible about what it thinks you might be doing (that you're not expecting). 

What does it mean? Is the meaning of obvious? Something like might be a bit more descriptive. What do I start with? Consider telling the player what their starting point is. At the moment, the first time they found out how much money they have is after they have decided to buy an Axe or a Sword. Typo's and telling a story You have some grammar/spelling errors in your text. For example ('wepon' and 'isnt') in the following: 

Terminal Size / Wall collision detection Collision detection didn't work as expected when I ran your program, currently you can run straight off the right side of the screen, turn around by going down and left and come back onto the screen. It turns out this is because although my terminal is only 80 characters, horizontal is set to 200, so it keeps going off the side. The terminal is capping the right hand printing, so the walls are printed correctly. Ideally you would either detect, or ask the user for their terminal size. You don't often see two breaks in the same case statement, maybe it should be: 

If is null, then no bytes are added to the buffer, however the tail is still incremented as if data had been written. So effectively, whatever is already in the buffer is added instead. Having default to null suggests this might be expected behaviour but it seems very odd. print may be a debug method, however its output is confusing. As you pop from the buffer, you're reducing the number of characters from the buffer that are displayed however you're still printing from the start of the buffer. This gives the impression that is actually removing from the tail, rather than the head. You should probably be printing from the head instead: