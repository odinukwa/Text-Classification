Typedefs as an alternative to new types As others have mentioned, single letter variables are a detriment to readability. One way to help this is of course to add new types. As Corbin mentioned, adding a class or struct to hold just two ints can be a bit overkill (personally I don't mind). I'm not sure if this is considered good practice, but what I do in these situations is to create an alias: 

Probably the names are a bit too verbose* and your algorithm may not make them quite as appropriate, but I hope you get the idea. * I don't mind long names for top level functions you call only once. 

Some editors may even help you by showing the type of the alias, rather than the underlying type. Extracting code to functions to improve singularity of purpose Finally, as has been mentioned before, it's helpful to extract each level of nesting into a little function. Not only is it easier on the eye, you can give each extracted piece of code it's own name. That helps to reason about what each step in an algorithm is doing as well. For example the first for loop is really just initializing a big old vector. I would move that whole loop into a function called or something and then move the second big loop into a function called or something a little snappier. And then maybe even have it return a new list or perhaps update its input and extract the printing section () to a different function as well. I know that its not quite as compact and also slightly (but not in a big OhO sort of way) inefficient, but it separates each section of code into what is logically doing. Some pseudo code to illustrate: 

Reviewing your design, you mention , however you have: - "name": "none", - "health": 100 These lend themselves to player actions and multiple players in a game. The health, for instance, where do you manage the "drink potion" and "being attacked" functionality? It seems like you need a class for the player and two methods, and - which means we also need a property for when (not real code): 

Several issues with your code which is causing you issues (this won't give you the final code but it will help you get there). Firstly, never hide issues by modifying the stack recursion, and never wrap operations in . The errors are there because you are doing operations the computer does not like (and you shouldn't be doing). As an analogy, you could drive sometimes on the wrong side of the road to get places faster - but you don't because it breaks convention. Next, update your code to be more python'ish. For example: 

I would narrow down your try:except to only the statement(s) which could throw the error. Having such a large chunk of code in a try:except block could result in many exceptions thrown, none of which would be caught as you're only looking for IOError. Also, for performance, you should build the statement and the data set from the loop, then throw the statement against as a single database call instead. Regarding construction, your code is just one huge blob. It's important that you refactor each operation into its own function, this saves on tracking down errors, and if you make changes in the future, your changes only affect one function. If the change is not liked by the rest of your code, it's easy to back out. Can you imagine if you made 5 or 10 changes in your program as it is right now, and then it stops working? Which change was the breaking change? How would you find out? Why did it break? etc. Also, I'm not talking just simple syntax errors, I'm also talking about logic errors or data errors. These can be hard to track down if you don't have any tests validating your code. Good luck! 

Board Whenever I look at code, I first look at the shape and the color. When I look at the code for , I find a lot of mixed colors in my color scheme. This suggests to me that maybe you are mixing data with logic. There are also a lot literals in there. Perhaps you can extract these and replace them with named constants or methods? Are you following the SRP? For instance, what does have to do with the board? Perhaps this is a little more ambiguous, but what about ? For , you are using a 9-element array which seems okay. You might consider making it a 2d-array to make the public interface a little nicer, but I suppose it's fine. But why initialize them with the numbers 1 through 9? It seems to me that the board should be agnostic regarding it's contents. The indices already indicate the positions and having the contents be more clearly indicates that it is empty IMHO. Are you happy with the argument name for ? What about or ? Later in the code you use the term mark, so what about ? What about the method name? Is supposed to know anything about the rules of the game? The local variable is really a constant. Consider extracting it. You might also want to break it up into rows, columns and diagonals: 

I always find that the literals , and are code smells in ruby. This is because ruby expressions are always implicitly truthy or falsey and either or not . This means that the expression can almost always be written more succinctly and more efficiently as just (the exception being when you really need and not just truthy). Game I found this rather complex to read. A first suggestion would be to use attributes. That will get rid of all those signs :). In you are calling . But start screen has nothing to do with initializing. It is already running the game. Why not move it to the method? Should all methods be ? What methods do you want clients to call? You are setting up the player defaults in start_screen, only to then potentially change them later. Why not set them once and only once? The method is a predicate, so should be named . The method is not a predicate, so should be named or perhaps something else like . I like the name of the method , but should it be responsible for drawing the board and checking the result as well? You might be better of using a plain old instead of a case statement in Example code Here are some mostly complete examples. I feel that there is more room to move stuff around, but they should indicate the things I touched upon. I feel that the example class still has to much conditions and to much raw data. 

You don't have to write or , to test for conditions, they can simply be expressed as and respectively. Asserting via the representation may look like it works now, but the proper way is to override your class's method (and as a form of habit, too). Your representation may change in the future, which means you'll have to update your test cases. Test cases usually belong to their own class, e.g. . Why do you need to when only the assertion is ? Maybe I only accidentally compared , and I'm not expecting any stack dump... 

Your "checks" for inside your method are exactly what methods are for (more below). Similar to a previous point, your class also seem to know how to output to the console. 

I'll just review the smaller parts of the code first, will dive into the logic if I have the time later... 

edit: One clarification regarding my final point above: I'm quoting the Javadocs from the classes primarily because you are using a currently for your "persistence". Even if you are going to replace it with a database back-end and JDBC APIs that do not necessarily return datatypes, it's worthwhile to consider what is the most suitable return value you need from your own APIs. Perhaps you discover that most of your use cases are just to check again whether the input object for and are persisted or not, and therefore the original implementation will still make sense (you'll want to document it properly too). Looking at your new changes... 

Have you considered rolling your own ? There is likely to be a more concise way compared to my suggestion below, but that's all I got for now by closely following the implementation of . 

When the program runs, it will load the player data and location data (knowing x and y from each section definition) and start the game. Finally, it sounds like you might want a decent IDE, I'd recommend starting with the community version of PyCharm from JetBrains. Hope this helps with your design and code. Good luck! 

Also, for your locations, having functionality and properties separated into tuples doesn't make sense, you'd need to create hundreds of tuples and track them all (how do you link them for the adventure? how does the user move between them?). It would be easier to create a base class of and or to inherit. The class would contain the logic of the user moving into and out of the location, Rooms would have additional functionality like light switches (and if they're on or off by default). For this, I'd use a feature map (a matrix containing a 's default properties) and make the process of loading them responsible for creating the objects (and adding certain items to a room). As this design is quite complex, I would suggest separating the location data from the code, possibly by using and storing the data into an file. Something like: 

having them all send a sql string into a single function. That way, you separate the database functionality from the business logic of each activity. For and , three things. Personally, I don't use double underscores for functions, a single one is sufficient to advise other developers that the function is intended for private use. Secondly, the string building process, you should attempt to use list comprehension to build the strings rather than a loop, this will result in much simpler code (and no "last param won't have..."). Thirdly, both these functions are the same, and only differ in their use of a or . You should have both refer their details to another function with a parameter. Something like (not functional code, just a typed up demo for the concept): 

Those URLs are certainly a good candidate as constructor arguments, i.e. the part. You also have some statements that display the site name, and a root URL, so a possible implementation might be: 

is a helper method that performs some basic validation on getting a value from the instance by calling its method first, for example: 

This comment sounds scary, which is why it's probably an indication of a potential weakness in your implementation. Comments lie, especially when they get outdated, or copied-and-pasted wrongly to other parts of your code. If I want to be even more particular, you are using the plural form here (head references and field declarations), so are you really referring to both and fields? What happens when someone changes them? If the code is improved upon, when can someone remove the comments? 

Iterating through a collection of objects Following @Robby Cornelissen's suggestion of using a , you will not need to create 'dummy' objects just to compare account numbers. Alternatively, your class can have a method to perform this check, instead of doing it within your class. Understanding methods Setting a , comparing it case-insensitive to some values inside , and then performing the appropriate steps is convoluted. Just have methods like or with the relevant arguments and call them from your class. There is no simpler way to describe this. 

My take on modifiers on method arguments and variables these days is that they are largely redundant, as long as you can easily observe that they are not carelessly reassigned. If you happen to come from a (programming) culture where this is done way too often, and thus you are introducing to check such practices, then feel free to leave them in until such 'reminders' can be removed. Looping via iteration Another way of doing looping via iteration is to rely on the standard -loop as such: