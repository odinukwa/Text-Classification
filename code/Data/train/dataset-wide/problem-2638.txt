While the whole code would now be longer, as you would have to manage both the page visual elements as well as the logic itself, it would also be more modular, organized and easier to maintain or add functionalities. It would still be necessary for some other function to call the game functions and update the corresponding page elements depending on the game state. A more modern way of doing what i did above is using ES6 classes: 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

I'm not going to go deep into variables and functions names since @Blindman67 already covered them. But i still can't help but mention them again. They are far more important than they look, and you haven't picked them properly. Take your time picking them, it's definitely worth it. 

As pointed out by @Zeta in the comments if the color to be inverted is a gray very close to the middle, the inversion will generate a similar color which may not be easy to read. You can try to avoid this by manually checking the difference of all channels to their inverted versions, and if all of them are bellow a certain threshold generate a different color. A simple approach to this would be to generate black if all channels are closer to white and white otherwise. There are also some libraries/micro-libraries that generate colors and their complementary versions with other approaches, such as using HSL. These may be interesting for you to take a look. Here are some of them for reference: 

Note how you are constructing the same selector 3 times with the . So this not only repeats the selector construction as it also fetches the element from the DOM multiple times. Save the fetched element in a variable and then use it: 

There is a similar question that you may want to take a look at for some extra insight, even thought it doesn't have the contrasting color feature: JavaScript Random Color Generator Now lets get to the review. Naming 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

is a fairly obscure function, IMO. Here you're assuming that it is implemented correctly and efficiently. I'm not sure that it always is, but I have no evidence to the contrary. The only immediately obvious way to get rid of is almost certainly worse: You could set another thread to notify the condition variable every seconds, and detect spurious wakeups by computing , instead of by looking for . 

Your C++ code could definitely be cleaned up by removing a lot of its blank lines and premature declarations; for example, there's no need to put a blank line in between every pair of declarations, and there's no need to pre-declare outside the for-loop. Just tightening up the style (whitespace and such) will go a long way toward readability. 

Anyway, if you don't want people touching your type at all, a common convention is to name it (by analogy with ). And if you do foresee people wanting to use both types, the best names are probably and , or just and . (That's right â€” I would avoid baking C's into your exported typedef! I would create a new for export. This allows you to change the implementation details of , such as whether it uses C or C++ or non-standard atomics, or whether it uses a mutex, without bothering the user too much.) 

This is all the same straightforward code as before, with the possible exception of . Here we're making an overload set of (with no arguments) and (with at least one argument). By construction, both and all the elements of will always be ; we could that, if we wanted to. returns a value-initialized (i.e., the "zero" of whatever type happens to be); I used instead of just in case is some wacky bignum type that doesn't have an implicit conversion from . Depending on your assumptions, might be the safer choice. 

However, your bitflag identifiers , , , etc., are pretty much unreadable, especially given that you already have English names for them right there in the source file! If I were you, I'd replace the entire function with simply 

Consider providing and possibly a template in addition to your . Of course this just increases the surface area exposed to the deadlock bug above; so start using first and add these member functions afterward. 

If I understand correctly, the catch-blocks in are hit only if the user invokes your program with an invalid option, e.g. . Your error messages are pretty unhelpful in this case. Consider adding some actual error-handling logic and a friendly message, e.g. "The argument to must be numeric." Also, you should check that the argument to is non-negative (maybe even positive?); and you should not silently accept -without-any-argument as a synonym for no--at-all. 

You're suffering from an excess of mimesis here. You've done an impressive job of translating your fantasy setting from English prose into a C++ object model... but sadly that's not worth anything, because the computer will never appreciate it, and the player will never see it. Let's start over, as if we were designing an adventure game program, instead of transcribing a worldbuilding session. We probably have a player (just one player, so we can just use a singleton named to hold his data), and the player has a current location, right? 

Refactoring When you see yourself doing the same thing many times, it is time to think again and try to refactor that part because there certainly is a better way. You have very few code that represents repeated logic, but lets take a look at the function: 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

I should start by saying that the game is quite interesting, and for a beginner the code is good, but of course there is plenty of room for improvement. Small details You have many small things that may a bit odd or unnecessary even, such as: 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

In this refactored version both roots are returned as an array. I included solely for clarity. You also had an variable that wasn't being used at all. Always be aware of those, as they clutter the code and leave readers wondering what they are for. With this new roots calculation could be way simpler: 

Which makes it super compact and easy to read. Objects One downside of the way you have your code structured is that you have multiple global variables. This creates difficulties in managing state and also opens the possibility of colliding with already existing global variables. Those may either be from the object or even some other plugin/library that gets included up top. All the game logic can be moved into one or multiple objects/classes, which helps you separating it from the presentation in the page. Sure you can consider this a bit too much for a such a simple game but it's definitely a way to improve especially if you want to keep adding features. As a first step you could consider the following approach: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

Your question is, can we somehow remove the requirement that be a named variable in this code? Well, the short answer is "no"; 's constructor takes a Container by non-const lvalue reference, and so we have to have a non-const lvalue for it to refer to. What's more, in order to keep from being a dangling reference, we need the referenced Container to live at least as long as itself. Otherwise, we could get away with something like 

At first glance this seems nice and straightforward... it looks like you're using a classical-OOP class hierarchy where a is-a , which means you have to use heap allocation and s all over the place. Now, I personally don't like classical-OOP style in C++ (because it requires all that heap allocation), but sure, as a learning exercise, go for it. Your use of is indeed correct, as far as that goes. However, I would expect a good programmer to write 

The usual names in C++ for the endpoints of a half-open range are and . I don't see a good reason not to use those names here. This would free up the name (or, idiomatically, ) for the pointer-to-last-item variable which is currently confusingly named . 

I don't know whether there's a specific use-case this is good for, or whether it's library-vendor paranoia, or whether it's completely unnecessary. (Leave a comment if you know!) 

First of all, I don't think this is a good use of variadic templates. IIUC, you're trying to make a function that accepts any number of objects and returns a ? I would express that at least as 

With your non- constructor, this will compile and call , because the conversion from to is implicit, not explicit. In general, you should allow conversions from type to type only if an object of type can meaningfully hold "the same value" as an object of type : for example, we allow converting to , or converting to . You don't want to allow silent implicit conversions where the conversion changes the meaning of the value: for example, changing a key into a Twofish engine. So, add . And then backtrack: Why are we limiting ourselves to for user keys in the first place? I would expect to see at least an extra overload of the constructor â€” maybe the only constructor â€” either taking a classic iterator-pair like this: 

This is redundant with your loop condition (modulo off-by-one errors). You should avoid doing any unnecessary math at all in your tightest loop, which means 

If I were tackling this problem, I would first ask myself what "the type of the first parameter" even means in C++, given that we have function overloading and templates. But then I might try to detect the appropriate type by messing around with