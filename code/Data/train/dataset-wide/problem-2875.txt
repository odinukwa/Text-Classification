You already got some great advise about your class, so I'll focus on your class. First of all naming: 

Security SQL Injection Never put any variable data directly into SQL queries (the type of query doesn't matter, all can be vulnerable to SQL injection). This allows attackers to execute SQL queries themselves, with which they can see confidential database data. Depending on the db software and settings, they might also be able to write to files (which might gain them code execution), read sensitive files, execute system commands, etc. Always use prepared statements. XSS Never echo variable data without sanitizing it. You do a good job here with , but not with the rest of the variables (eg , , etc, all of which are also user supplied). This allows an attacker to execute arbitrary JavaScript in the context of the victims browser, which allows the stealing of cookies, key logging, phishing, and bypassing of CSRF (which means the attacker can do anything the victim can do). Always use whenever echoing a variable. Also note this list of places where this in not enough to prevent XSS. Passwords is the correct way of handling this. Regarding your question: A feature should NOT be sending the plaintext password to the user. Instead, a password reset link with a token which can be validated should be send to the users email address. Captcha You seem to validate the captcha after inserting the user into the database. This doesn't make any sense. The only thing the captcha protects is the redirection to . But a user could just enter that path on their own. Misc 

It might seem overkill, but anyone actually using your function will be glad that it's there. You can remove the warnings about incorrect input if you don't care about it, or you can add error checking and throw well named exceptions and add extra comments for them, to clear up the comment a bit. Different Solutions As @Martijn said, letting the database perform the sort might be a good alternative. It would also be interesting to know why you even need to do this in the first place. Where does the id array come from? Is it permanent - ie hardcoded in PHP? In that case, I would probably just add a column to the table. Error Checking and difference between Functions Your functions are not exactly the same, as they handle invalid input differently (none of them handle it well). If my input is for example: 

Regarding your code: Return early By adding guard clauses to your functions and returning early, you can reduce the level of nesting, and make it more obvious when what values are returned. So for example, instead of this: 

It's easier to understand and performs a lot better (and again, you can use for even better performance). 

Reduce if statement nesting You have some if statements which can be rewritten a lot better using / and early return: 

It uses bcrypt (which uses blowfish internally), and it even manages salts for you. This should also answer your additional questions: You don't really need any of the functions. Misc 

That is true. But sha256 is not that much better. Problem: simple sha256 There are basically two problems with your approach: 

OOP OOP wise your code is pretty good. I would change the piece type (and probably the color as well) from strings/boolean to enums, as they are easier to handle. I would also separate the model and logic from the actual displaying of the board (you can leave your current method though, rename it to , and use it for debugging purposes), the advantage will be that you can easily switch how you present the board if you separate these concerns (ideally, you create interfaces). I would also extract the code to get player input from the model of the player (again, with interfaces), so that you can easily switch how you get input. Your class is a little odd, in that it accepts in the constructor, and then in the setter for the same field. Also, it is the only place that your setter returns the object itself. Naming 

Comments I think it's good that you have comments, and they actually helped me in understanding your code. But they can still be improved upon, I think. 

But you can see that most of these renames are not necessary or would be obvious if the functions were moved to a better context. Comments Your comments are helpful for people learning PHP, but if this isn't code for a tutorial, you should remove them. Inline comments shouldn't duplicate what the code already told us, but explain why the code is written the way it is. Your function comments would be better as PHPDoc comments. Also, some of them could be a bit more in-depth (eg : how does it "deal with errors"?, etc). Misc 

But this is really not intuitive. uses the array keys, but not the values, while uses the values, not the keys. If you go the OOP route, the code could be self documenting. You might have something like which has as methods , , etc. Then it might be used like this: You should also write documentation for the function, so users know how to use them without looking at the code itself. Usability I don't really see the need for functions like these. They make code less readable and obscure the SQL queries themselves. They are also not very powerful, so you will have a mix of hand-written SQL queries and use of these functions. If you do not want to write SQL queries by hand, you should look at the interface of existing Query Builders such as laravel or the query builder of doctrine and model your code after them, as they are a lot more flexible and result in more readable code. Security If you go to the trouble of writing something like this, I would not give users the possibility to add arbitrary SQL queries via a parameter, which could lead to SQL injection. A user will have trouble seeing which values are safe and which are not (of course, in this case none of the input variables should be user supplied, as it would lead to SQL injection in all cases. But a user of the function may not know this, and may assume that you validate the input in some way). At the very least this should be commented on. Misc 

Security Curl Set POST I don't think that there is a problem with passing user input to as post field (something like http header splitting is not possible, and it doesn't even seem possibly to add additional post fields, or to overwrite existing ones). Important information via GET It's not a good idea to send anything confidential via GET. GET requests can be cached, they can be stored in the browser history, they show up in server logs, and so on. Use POST instead. SQL injection isn't controlled by you, so you shouldn't trust it, the same probably goes for . Never put variable data directly into an SQL query, use prepared statements instead. CURLOPT_SSL_VERIFYPEER If you disable this setting, you weaken the security of SSL. Yes, you still encrypt even if is false, but you would also accept the key of a man in the middle instead of the key from the server, so an attacker could still read the communication. Here is the warning from the documentation: 

This doesn't look all that secure. A user can create any class, and they can call any method of that class with any argument they want. This means that you give up complete control over the control flow of your application. I would be very surprised if this wouldn't lead to DOS, SQL injection, authentication bypass, probably code execution, etc. You really need to create a whitelist of classes and methods the user is allowed to use and check against that. 

This is not a complete review, just a couple of points that jumped out at me: JavaScript Naming Short variable names are hard to understand. While , , etc are somewhat standard, , , , , , , , , , , , , etc are not and it is very hard to understand what they represent. Will you in six month still understand what is without searching in the code? I would guess not. But if you use , it is immediately clear what it does. So my recommendation would be: find good variable names for the one character names, and write out the abbreviated names (, , etc). Some function names also do not express well what they do: might be better named and better (same for ). Bugs If I set row and column count to a number different from 3, it seems that nobody can win. Long functions The function is definitely too long. I would at least extract the two red redraws to their own function. Saving fields in local variables In your method, you save fields in local variables: