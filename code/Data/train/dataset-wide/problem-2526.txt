The need for timeouts is worrying. Definitely needs investigating. Possibly due to async loading of SO content? 

The routes take no account of failure of . In fixing (1), you can (probably) execute once and deliver via a promise in those routes that use it. In routes that use , you can start with to ensure that nothing is executed if or failed. In , doesn't wait for . The test is a bit odd when is guaranteed to be undefined. 

will simplify considerably by taking an object-oriented approach to defining the filters and providing each filter with its own method. 

Untested and includes a few assumptions, therefore may not be 100% correct. Be prepred to debug, or just raid for ideas. 

Timer as a widget Your timer is essentially a widget. As such, it would be more easily invoked by passing in a single container element and having all the internal elements generated on view initialization. Hence, most of the statements would become statements (or their jQuery equivalents). 

Not sure this is 100% correct. Heaps af assumptions were necessary, so will almost undoubtedly need debugging. You may well choose to adopt some of these ideas and not others. 

Please note, from ECMAScript 2015 (ECMA-262, 6th Edition or ES6), some of the following advice will change. In particular, ES6 offers Classes and Arrow functions. At the time of writing, ES6 is only sporadically supported in browsers On a general point, unlike PHP/Java, JavaScript has classless constructors. What looks like a "class" is actually a constructor, therefore you can do more in than just declare its members. You can execute any statement you like including calls to methods established on the . Regarding : 

Reusability issues As it stands, is a strange thing that hovers somewhere between reusable and not reusable. 

The d3.js code is very similar for the two plots. You could save some 150 lines of d3.js code by writing a generalized function and passing in a few parameters. Other than that, I wouldn't agonize over the number of lines. Graphics code is often bulky. 

Performance-wise, hard to tell. May not be so bad. Would need to run tests. The worst feature is readability. It's not a standard approach to sorting. 

Very often a generalization is hard to spot when you are developing code. It is often easier, while developing, to write the everything out in its long form, then seek to generalize as part of a tidying exercise when it is working. The more experience you acquire, the more likely you will become at spotting a generalization early, but even experienced programmers will often write verbose code before boiling it down to something more manageable. 

Here's the kind or code you might end up with, meeting all the above objectives (except generalizing the d3.js code, which remains very bulky). 

Possibly also the 27 jQuery collections, though the prefix already identifies them pretty well. Then do a lengthy, careful trawl to pick up on the new structures. 

Note: No inheritance is necessary here. The same effect is achieved through closure of the method. Sample calls 

Also, I think the sort can be avoided. It seems that after the second loop, the values within each of the "data" arrays are cumulative, therefore already sorted ascending. If I'm right then all you need to do in the third loop for a descending sort order is 

... which is functionally identical but easier on the eye because it allows the first to be coded the same as all the others; it does not appear to be a special case. 

Code doesn't look too bad for a first attempt at using promises. Here are a few observations. General 

Separation of concerns: Better separate display/styling/HTML issues from the high-level application code (the questions posed and the responses provided). Object-oriented approach: Consider for example constructors; Survey(), Section(), Slide(), Radio_group(), Radio_button(). Question types: The survey is currently limited to a hard-coded "VERY DISSATISFIED" ... "VERY SATISFIED" scale. Other semantic scales could be offered, as could "Yes/No" booleans. Branching: It's not atypical for surveys to branch - ie to be responsive to the answers provided. Branching would probably require a change of approach, by which slides are built on-the-fly rather than building everything at the start. Colors: As it stands colors are limited to those specified in the CSS style sheet. You might consider a more flexible, data-driven approach, implemented wholly in javascript. Summarizing results: There are issues around the summarization of Likert scale questionnaire results that you need to be aware of. I'm sure the web includes many other good articles/discussions on the subject. 

I'm not sure about my caching strategy. From what you say in comments above, you may need to revert to what you had originally. script.js : "script.js" doesn't really need to be touched. The messaging protocol is unchanged. I've just made a few tweeks. 

The code looks to be pretty sound. Here are a few things to consider ... The need for the function (in the global namespace?) can be avoided by moving the contents of into the existing . Some DOM elements need to be rediscovered on each of several user interactions. This is trivial in a small development document but could be slow in a large, real-world DOM. You can cache more jQuery objects in the same way is already cached. This is a trade-off of UI responsiveness against memory. Fixed CSS maps can also be cached. Again a trade-off. Here it is complete with a few other improvements such as method chaining : 

Whenever you have repeated blocks of very similar code, you should always seek to merge them into one generalized block. Sometimes this exercise is hard, sometimes simple, depending on the nature of the algorithms/paradigms embodied in the code. Here, without changing the HTML or the CSS, the javascript will simplify to : 

You could probably contrive a way to handle the reversal and push objects onto in the second inner loop but at the cost of readability. Overall, the above changes are mainly cosmetic. You almost certainly won't notice any performance improvements unless the data arrays are huge. For small data arrays, I would be quite happy with the original code - maybe just do the (if it's correct) instead of . 

Thus modelled, the basic timer paradigm is . Only simple manipulation of value is necessary to provide count-up and count-down variants, and is a view consideration, not model. We should see : 

Yes indeed. Object-oriented filters will help considerably. Then you need a mechanism for defining filters in your "user-code". In re-factoring the code to provide a constructor, you might also consider : 

OK, with just 15 minutes of 2015 left to go (GMT) and with some shameless cribbing of ideas from @cFreed's and @Sumurai8's answers ... 

Alternatively, assuming to be the sum of all the other values, then it can be accumulated on the fly : 

would need to return 1 for to return . Therefore the last question is unlikely ever to be selected. For equi-probability (well as near as possible) use : 

Macro Observations As written, is a jQuery static method, not a plugin. It seems more appropriate to write it a genuine plugin, and invoke it on DOM element(s) with . You will then need to purge hard-coded selectors and take great care to ensure the independence of multiple invocations. Strict mode will help avoid making certain mistakes. You may get error messages in your console. Try passing the code through jsLint to check for unused/undeclared vars and heaps of other stuff. Meso Observations is "ul li a", therefore will select all ul,li,a elements on the page, not just the ones you are interested in. Try constraining the selection with something like . Probably similar elsewhere for other selections. is an initialisation function and would more conventionally be named . Default tab: Typically with this kind of functionality, you would write initialisation function devoid of code that sets the initial condition. Then, as a final step when all other initialisation is complete, emulate user interaction by triggering a click event to select the default tab. This approach can save much time and many lines of code. Micro Observations should be declared in the main declaration block with a good explanatory comment. 's local variable appears to be unnecessary. At the point where it is tested, it will only ever be , won't it? can be initialised simply as , same as . is rather oddly named given that it is used for jQuery collection object, not a reference. !? Look for unnecessary operations, such as : 

(Obvious) ... when doing simplifications, test at each stage and don't move on until it's working again. 

Some of the code looks to be as little dodgy. For example, means that any added class that is not will never be removed (unless by some other code). Contrast with , which is guaranteed to add/remove the same class. Aside: With the tbodys in place, you could consider styling them with eg a border that will expand/contract as the details are shown/hidden. If performance is still poor, you'll need to investigate deeper to discover what's taking time. Though I'm not an expert driver, Chrome debug tools are very good for diagnosis. Edit Back to a single but with , , , in place, try selecting as follows : 

Demo With some extra thought, you could maybe code a couple of built-in, named sorts in the plugin, or pass a callback for full flexibility. Demo 

A wholly synchronous step in a promise chain doesn't need its own and can be merged downwards with following synchronous step(s) up to and including the next asynchronous step. Completely flat promise chains are not always the best. Nesting is perfectly acceptable and often offers big benefits in terms of closure and flow control. You can avoid clumsy outer vars when it's possible to pass them down a promise chain or keep them in a closure. Arrow functions would help make the code more concise (and arguably more readable). 

It will be at least as reliable to test whether the parent element , as that class will be toggled synchronously in response to a click. You can also benefit, syntactically, from chaining and (or reducing to add/remove a single class). 

The following code is designed to demonstrate the above principles. Its probably not 100% correct; I had to make a number of educated guesses particularly regarding the static DOM hierarchy. If you want to try it, be prepared to do some debugging. 

Note: doesn't have any methods and isn't really necessary. It avoids a lot of bulk in . webworker.js : The result is highly readable, object-oriented code (untested) : 

Due to the volume of code, I would be inclined not to touch it. Recoding and revalidating would be a lengthy exercise. I wonder if the way ahead might be to enhance the (already good) comments, to provide better guidance to the existing architecture. 

tested only for js parsing So that's your BODEPLOT "library". To use it, you would write something like this : 

... and in general that is what we would write. However sometimes it's advantageous to start a promise chain with a resolved promise, even if it's not strictly necessary. For example, we might want a chain such as ... 

Automated tests would be fairly simple to code, though it's hard to envisage something flexible enough to handle any set of input elements. It's maybe more realistic to prepare a few sets of test cases, each comprising input HTML (a container full of elements) and an array representing the expected sort order. It would be a fairly minor challenge to run a sort and compare the resulting order of DOM elements with expectation. 

Edit: After reading the answers by @cFreed and @Sumurai8, I can see that my answer can be improved quite a bit - a solution of just 9 lines. I don't want to overtly steal from the other guys but will post my revised answer if asked by the OP. 

The worst feature of "webworker.js" as it stands, is the need to pass to almost every function, so (and its properties) can be operated on. This can be avoided by factoring the code into Constructors (classes if you like), each with a bunch of methods. I found that the code fell very naturally into three Constructors : 

Presumably statamic statements allow you to include/exclude statements within tags. If so, then you can write something like this in the document's : 

The worst issues are cases of the same element being selected multiple times in order to apply various methods. Repeat selection of the same element should be avoided because selection of DOM element(s) is expensive. There are also are cases where multiple selections have the same method applied. This isn't so bad for performance, but leads to unnecessarily bulky source. The code can be improved with the following techniques :