Be sure and use the "official" form of the equation - not a copy of whatever source code you have. Ideally, use unicode characters in your comments to put in whatever greek letters, bizarre symbols, etc. the math requires. It should read like your reference text, if possible. The idea is to provide a copy of the ideal form, so that you can look up and check it when you're coding. Improve your signature As Conor points out, your function signature isn't great. What does it mean when I code the following: 

Your collision detection routine is not needed, because pygame provides a collision detector for both rectangles and sprites. Just call whatever flavor of is most appropriate. You import windows-specific modules a few times. First, be aware that pygame has mouse support, so you don't need to call Windows for mouse information. Next, please make an effort to hide your windows-specific modules and code behind an interface. Ideally, make it conditional on the program actually running on windows. You can use the module for this. 

Advance! One thing you don't do is support multiple people moving at the same time. I don't know how important that is to you, but your code isn't structured to handle it. You would need a list of moving people, and their target locations. You could create a simple class for that: 

Is there a better way? Yes, absolutely! There are two tools that ship standard with Python that you need to investigate: and . For your code that looks like this: 

This return stays, and handles non-alphabetic as well as alphabetic characters. Also, what's the difference between and , and why are you converting from one to the other? 

I'll point out that IPv4Networks can return their first address, using an index of . I'll further point out that an IPv4Address can be converted to an integer using . Thus, you can sort your CIDRs according to the first address in their range, and you can sort your IP addresses according to themselves. The two orders will be comparable. This means you can essentially "merge" your two lists by sorting them in order, then iterating over the two of them in parallel. This will be essentially O(n log n) + O(m log m) + O(n+m) time, where n = number of addresses, m = number of networks. 

At this point, is a stack of generators that will only yield the rows you want. However, not a single one of them has been read! So you can just pass this in to your output code: 

And let people access and directly. (Python provides a mechanism, , for dealing with the case where you want to turn a member access into a function call. But it's not the first thing to do.) The next thing that struck me about your code was this: 

My take-away is that your code- as written when you posted this- is close enough to "doing nothing" in performance that tweaking it just produces noise on this benchmark. Sooooo.... you need another benchmark! Possibly several benchmarks. You should save this as the "creating arrays" benchmark, and add it to your perftest directory (which you don't have... yet). Then maybe create some other benchmarks, reflective of actual use cases, which we can use to hammer out the performance of objects when the arrays are actually accessed, instead of just creating them. Edit: Also, if slicing is actually used it probably deserves better treatment. There should be a way of copying the json and actual versions in the initializer. 

By creating a mechanism for dealing with abstract direction vectors, the code above can be used to compute a score in any direction. So you would only need one function - "what's the score from this point in this direction" instead of your many functions (score up/down, score diagonally, score horizontally, etc.). Block the other player Your "AI" function seems to focus on trying to make a simple pattern, without focusing on what the other player will do. You can probably improve your score by evaluating what the other player is likely to do, and biasing your own moves to counter that. For example, suppose you determine that you have two moves of equal benefit to you: there are two cells adjacent and you can append a third cell to either end of the line. If one of those cells is "important" to the other player, and the other is not, then you should prioritize blocking the important cell before the unimportant cell. Both of them help you equally, but one hinders the other player at the same time. To this end, I encourage you to design a "scoring" system for cells. Each cell can be rated for its value to a particular player - the cell has two scores! You will want to pick the cell that scores highest for you while also scoring highest for the opponent. There are various ways to do this. One obvious approach might be to compute the number of winning configurations that a cell could participate in. A cell in a corner would have fewer than a cell in the middle of the board, and this number would go down when opposing cells were positioned. However, it wouldn't go up when own-side cells were positioned, so an additional metric would be needed... 

For boolean variables, please evaluate the value directly rather than comparing it with or , like so: 

Update the pointer to that node. Note: It's important to note that there are two possible structures being pointed to by . In the first case, is initialized to point to , so might be pointing into a . After the first node, you update with which will be a pointer to a . So the double-pointer points into two possible kinds of struct. That's awkward. 

You would do well to use generator functions to break this down into parts that might be re-usable for other steps in your pipeline. For example, the first thing you do in your loop is read a row from the CSV file and process some of the fields. That's a good candidate, right there: 

Next, rename to something more accurate: or some such. Try to always write your code using the vocabulary of the problem domain. In this case, the problem domain is a board game. Finally, there are a bunch of opportunities for you to tighten things up. For example, checking for a win in the turn function instead of separately, or using a list-of-lists instead of three separate row lists. If you can make the changes above and update your code, then we can get into those changes. 

You are not using Python idiom for structuring your code. Please see this page (one of many duckduck search results) for an example and explanation. You should be using: 

Note that technically, when you "allocate" a match you are changing the dynamics of the weighting. So you could pass a modified replacements table down recursively, so used replacement values were removed from the weight computations: 

In this way, your parser can truly be a parser. Honestly, I don't think you need a , whatever that is. You might need a , but I don't really think so - I can't see what you're doing that would presently justify it. Instead, think about writing a "cnc report -> csv" conversion utility to just reformat the data into a more useable format. Managers love spreadsheets. If you actually want to post-process the parsed data, to generate the busy/idle information, for example, you can do it in the loop above with just a dictionary. That code will contain lots of references to the row data, and the various fields - it will look like a program about analyzing the row data, not about . It's a class library On the other hand, maybe you're trying to write a library of classes for managing CNC report files, and the program is just a proof-of-concept. In that case, your classes are not quite right. First, the class should be internal to the The only useful object you have is a . Everything else is an implementation detail. "How do you get the file information into the report object?" That's an implementation detail! "How do you manage multiple report files in a single directory?" That's an implementation detail! Of course, in Java "implementation detail" means Python is a "consenting adult language" so it doesn't mind sharing private stuff with you, but you still shouldn't be showing off your private stuff (unless your name is Harvey Weinstein) (and even then, you shouldn't). So your three modules should be one module. And that one module can define the class, plus whatever internals it wants. And it can either contain them, or import them. But that shouldn't matter to the user, because the user should just or whatever and have everything just work. Which leads me to : why on earth would I write code like: 

For a coding interview, that's too much code. You're asserted that your input is in the range [1,3999], so you should be able to do this in a single function, with not much in the way of looping. Instead of being overly general, try coding specific conversions for the various digits, using a lookup for the actual digit values. That is: if thousands, append thousands; if hundreds, append hundreds; etc. 

In general I like the fact that most of your code is close to the left edge of the screen. There are a couple of lines that are long, but only one really pushes the right edge. With that said, you seem a little too focused on breaking code down - it's a small thing, but I think I'd prefer a few more 3-tab lines, and a few less subroutines. There are some functions that probably shouldn't be functions. In particular, your separation of 3-digits and 2-digits is a mistake, IMO. Handling the English "hundreds" is really just a matter of computing a string, since it will either be "N hundred " or it will be ''. I believe you should handle the entire three-digit "chunk" (your term) as a single function. Use of Python 

how would it benefit you to "defer" the evaluation or construction of the and attributes? It would make far more sense to just parse and assign them all. On the other hand, if your API returns a list of 1,000's of, say, homes with lat/long coordinates, and part of the object initialization process involves computing the distance from a given origin address, then perhaps delaying the computation or delaying object instantiation makes sense. Please share with us the nature of the problem you're really trying to solve, and we'll be able to comment effectively on whether your proposed solution is a good idea. EDIT: I had a look at your linked code. The key was, I think, in the function. You appear to be re-implementing the behavior of the or dundermethods. I suggest that you look at implementing a simpler approach, where you store (say) '_attrname' as the lazy-evaluating function, and use to expand that value into 'attrname' when you fetch it the first time. Since Python will check for and only call if not found, this would provide the advantage of doing the subsequent lookups in C code rather than Python. 

I'd suggest that you add one, or maybe better two blank lines above the grid when you draw it. This would provide a better edge to the top of the grid, and (2 lines) suggest that the grid belongs to the text below, rather than the text above. Also, you might consider filling in the grid, or a second copy of the grid, with the available numbers not yet chosen. That would make it easier to play. At the very least, print the grid with available numbers after an invalid selection is made. Next, the code. Globals You rely on global variables too much. I don't know why you have at global scope - it's only used locally in one function. The , , and variables don't need to be global. They can be passed as parameters, or computed, or returned as results into local variables. Packaging You really should package the "game" into one more high-level function. There's a standard Python idiom that applies here: