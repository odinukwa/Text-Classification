View: I prefer to couple my views tightly with models, so the init/update methods take reference to actual model class (ie. View has to import Model). It's not storing the model reference, only using it's API to init/update it's current state and forgetting about it, so you can any time change the View to display current state of different instance of model. With the above model, and intent to have special effect for "level up" event, I would probably design API as: 

Hmmm... anyway, I really like what you wrote here: "I'm noticing that reading doesn't really help much as much as writing programs and running into issues and solving them." This is absolutely spot on. All this general babbling around usually makes little sense when hit by real world problem. Also refactor a lot. Not just the code, and implementations, but as learning is your goal, dive deep into finished project and go trough all the API, all the abstraction, and try to imagine something better, easier to use, easier to understand it's responsibilities, easier to read and get the idea and eventually easier to implement (although sometimes to get better API and abstraction the implementation can be more bloated, but the cost of bloat has to be clearly justified by the cleanliness of resulting API/abstraction). 

I like using exponents to factor each digit into its value place. I don't like having to define a mapping for each number from 1 to 3 and 6 to 8, and repeat that for the 10s, 100s, and 1000s digits. 

I wrote a Ruby gem to analyse strings for word length, word density, and a few more hand methods... The class accepts a filter (String). The class will remove any words from the original string that you include in the filter. Spec: 

Please review this small program I wrote to create a World Cup Group Table. You feed the program match info, and it builds a table based on that info. 

Try not to use with and conditions because it becomes confusing. It's clearer to use negation: . Some people are boolean impaired, including myself. I'm not sure under what circumstances the hash does not exist. So checking for its presence may be redundant. 

I suggest you extract two methods: to check if the user is authorized, and to handle behaviour. You would then end up with this: 

This will not compile, you should rather provide working source for review. By building it yourself before posting you will prevent some kind of accident, like cutting out more than you did want. Also I have no idea what is or , so no way to review it and put any advice on that. Except stop using cryptic short symbol names which can't be comprehended by reading like plain English. 

Why does the function end when is not equal to ? That should be mentioned in description, that must be to make it work. 

I would move lot more closer to the area where it's modified, so it can be easily seen with eye, where the whole block is, and span over fewer branching points (which is always error prone, to keep correct stack across some branching). You can actually surround just few instructions with , not having any branching at all. 

I also modified the code to be PIC (position independent code). This is first time ever I tried that with assembly, so I'm not 100% sure I did+linked it correctly, but the code works, in debugger I see relative addressing, and stripped binary has only about 6kiB, so looks OK to me ... and now I tried to run it multiple times in debugger, and the code address is randomized, so the ASLR works too. And fixed some of your comments. And I test return value, so now the code upon invalid input will simply output the current sum, and the program can be terminated early by entering non-integer, or Ctrl+D. 

Because we removed the Cell dependency we can remove the method in favour of a setter. As with above, I replaced the options hash with keyword arguments. It makes more sense for a player to keep track of its turns. Each time a die is rolled, it is a turn. I created a array property to track turns. Its size is the number of turns a player has had. removes the need for temp variables to hold onto the current roll in the board class. always returns it. So I added a convenience method. 

I wrote this short, plain Ruby lib to handle email address validation inside and outside of Rails applications, and I would like to know what you think. 

Is there a better to test this requirement other than to iterate through all the possible scenarios? I'm doing something like this. 

With the benefit of several days of thinking I'm going to have a bash and review my own code. To aid my understanding, I made a rough diagram of how my objects interact with each other. The Portal class remains unchanged, so first up it's Cell. It's decent, but it can be compacted. 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

how to use the result of (which has to be done anyway to test remainder) as approximation of suggested sqrt(input) test, for earlier exit. used to set zero into register (shorter opcode than plus modern CPU recognizes it as idiom of "set to zero" and optimizes for it) to check if remainder is zero (shorter opcode than plus modern CPU will recognize it as idiom of "test for zero value" and optimizes for it) resolving even numbers at the beginning (even numbers have zero in least significant bit: . And the only even number being prime is , no need to test other even numbers by . but that means only odd divisors have to be tested in the loop, because for sure. So my loop is testing divisors 3, 5, 7, 9, 11, 13, 15, ... some non-trivial usage of arithmetic instructions and flags to check for input values ahead of loop, as those would break the loop logic and produce invalid result. It may be nice exercise for you to "decipher" how it works. you should try to keep things "together" (if possible). For example you set up for at the end of your loop code block, so it's A) not together with , interleaved by (hard to read for human, no problem for CPU) B) you have code duplicity (), because you have to init the register values ahead of very first separately. => So I do initialize right ahead of , only single time in code, and it's easier to read IMO. 

I'm going to be bold and review my own code having spent the last hour refactoring it. The original implementation had bugs. Sometimes less than 10 ladders were placed. This is because the algorithm did not check to see if there was a ladder already present at the current insertion point. 

I'm passing a callback to handle hiding the from from the parent to the form, and then to the link component that hides the form. Seems excessive to pass down a callback through descendents. Validation is very complex, but I have a simple case here: text is required. It seems a bit ad hoc to validate this way. 

I added a feature that allows you to send in a Regexp filter instead of a string. It's my first use of Procs, and I'm sure it can be done better. It's not very readable, and probably not efficient. 

Ideally you will want a nice helper for this. Now you can helpers from inside the decorators using the context. 

But I suggest you think about using an authorisation library, or extracting authorisation logic into a policy object. This way you gain the benefit of DRY, and an extensible way to add and reuse permissions. 

(I did debug it in NASM, so if I'm unlucky, something may fail in FASM due to syntax, but it should be easy to fix. But it's highly unlikely, they should have identical syntax for instructions and I don't use any macros/etc) 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

(the exact value stored in is , encoded as 64 bit integer value) So you are just destroying precision bits of the original value, but the resulting value can still contain decimals with precision you don't expect. For some more information study how the floating point numbers are designed, maybe this may be of help: $URL$ 

Example implementation of those ideas in this post and comments: ped.7gods.org/WordLadder.zip Meanwhile, lured by the fun of figuring out algorithm, and writing the code, I completely went off the path of reviewing your code instead. Sorry Jonathan. And to make it even worse, my source is not as clean as to be proper example in every possible way, but I have it now for few days sitting on disc and can't get to cleaning it up more, so I'm releasing it at least for the sake of algorithm example, as is. 

Once more, I've opted for keyword args in . I've simplified the method. It plays a turn, moves the player, then checks if the player has won (landed on last square). If the player does not move (no where to go), it checks if the last roll gets him in excess of the last square. If either of those things is true, it sets , otherwise the turn ends. 

I was not able to get @Jerry Coffin's particular implementation to work, but I used his idea to create this similar \$O(n)\$ implementation. As he describes, we reverse the array at \$A[0..S-1]\$ and \$A[S..N-1]\$, where \$S\$ is steps and \$N\$ is the length of the array. We then reverse the entire array. 

Personally, from my experience of reading and watching educational materials, the newer syntax is preferred where possible. It's also less keystrokes: instead of is easier for me. 

I've packaged this into a gem, with appropriate tests. I have learned a lot, but still not enough to nail down my perfect design. I still feel that my interfaces are designed poorly. Here's an example: A rule states that a player who rolls three sixes in a row returns to square one, and may not leave until the player rolls another six. How would I bake this into my current design with minimal interruption? The natural thing feels like Player should control its own movement. The Player class doesn't know about Board and . So the interface has to be redesigned. There are other issues too. But this is a start. I will post a follow up. 

Hmm... ok, one bit of source just to make it look a bit less like "wall of text" (although I'm afraid it's too late for that :D ). 

I was thinking whether searching for neighbours for new word can be optimized by searching only trough "neighbours of neighbours of first-found-neighbour", but after short tinkering with it I think this is not valid, this would maybe work for all 4-letter permutations forming complete graph, not for regular words when plenty of possible 4 letter permutations are not available. 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code. 

I think some of your expectations might lead to brittle tests. I would modify the expectations a little. For example: 

I wrote this jquery plugin to do remote validations on the server. The code self explanatory. When the field blurs (event is customisable), the plugin checks to see if there is a value and sends the request. Nothing fancy, but since I'm relatively new to JavaScript I'm sure I might have missed a few things. I think the init method is a bit long in the tooth. I am also calling from a bunch of places in the method, but that might be necessary. 

Am I testing too much? Is there a better way? Running 70 or 80 tests for something like this seems excessive. As an aside, can my regex be expressed better? 

Using a hash instead of an array alleviates the problems of 0 index when using arrays. It makes more sense. 

I wrote a random world generator for the classic Snakes and Ladders board game. Snakes and Ladders is a dice game played over a grid, usually 10x10. You win by reaching the last square first. The board has ladders and snakes that connect specific squares. Land at the base of a ladder and you climb to the ladder's head (good). Land on the head of a snake and you slide down to the snake's tail (bad). Snakes and ladders are key value pairs; the represents the start point, and the represents the end point. Both are identical except that a snake's start point must be greater than its end point, while the opposite is true for a ladder. World rules: