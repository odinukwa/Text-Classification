If I was doing this, I'd actually make this a CRTP class so that it becomes very easy to create smart_singletons: 

Also, we can actually combine both and . Currently, the only difference is that you call with the arguments in the other order. Instead, what we can do is take a comparator in our class: 

Although this would then have to be defined in the header file, and you'd probably want to move the random engine to be in a different function, so that there is only one instance of it: 

Returning a is fine IMO, but there is a caveat: you must not let the reference live longer than the object. Things like this will be invalid (I think, but at least it's questionable whether it's valid, which is a problem): 

Your implementation of is doing way too much work. There's no need to recurse at all, you can simply do: 

One thing to note is that you rarely want to use . is equivalent to . You almost never need to flush the stream. In your case, every use of can be replaced with outputting a newline. 

It's fine for it to not be thread-safe, but in that case, it is very important for the documentation to make it clear. If you are going that route, however, it might be worth separating the from creation like so: 

You aren't actually consuming ; that is, you don't take ownership of the vector (you wouldn't be making a copy anyway). This is a sign that it should be a . As a general rule of thumb, make function parameters unless you would be making a copy of them, then take them by value: 

This way, there is only one "chunk" of information per line; it makes it easier to read. However, this isn't how you'd take a parameter that you want to ; you should just take it by value without const; it doesn't make a difference to the end user. Also, use brace initialization: 

I'm going to ignore that using a string is inefficient for this type of thing (each char could represent 256 values, theoretically, but you only represent 10). 

Both versions are thread-safe. The first version will be incremented every time you call . Although will sometimes return a value 1 less than is at the time, it is still thread-safe. The second version is also thread-safe. The main difference is that will read the correct value. 

The fact that you are returning an makes it appear as if you don't modify the input array (which would be better named ); however, you modify and then return it. I strongly recommend either doing one or the other. If you don't want to modify the input, then you could do it as follows: 

Granted, the initializes to entirely false, whereas this doesn't, but I feel like the readability is worth it. At the very least, define some constants: 

However, there's no real reason why we need to separate out the ideas of width and height; why not just use the class directly? Something like this: 

On the other hand, your code as is is littered with type names; do I really need to know that that is a when that's easily determined from context?: 

This is okay-ish for beginning programming classes, but should usually be avoided. See Why is “using namespace std” considered bad practice? 

is that the can activate ADL. If was, let's say, , and if I wrote a in the namespace , this call might call the one from the namespace instead of the one we intended. This is not good. As a rule of thumb, when writing generic code, avoid unqualified function calls like ; instead qualify it with the namespace: . 

For fun, I implemented a trampoline function for C++ functions, since the recursion limit for functions is much smaller (500 by default on gcc). It is a bit messy with the type deduction and the fact that the trampolined function must only take a as its argument. 

This utility might have a small performance problem. It is harder for current optimizers to optimize this style of object, with a pointer to member function (PMF) as a data member. I know this sounds a bit like black magic, but Stephan T. Lavavej claims that using is bad because of poor optimizability in this CppCon talk. Basically, the optimizer can have difficulty seeing that a PMF stored as a data member is actually constant, making it difficult to inline. However, if you don't store the PMF as a data member, the optimizer has a better time. Thus, it would be more optimizable in general to instead write a function with : 

Oh you are using it as a delay between states of the board. In that case, it should be named something better. However, you are working too hard here. You could just use Java's built in class: 

If you wanted to implement the base 64 conversion yourself, note that you are still doing too much work. Your function could be replaced with 

But then, from here it is clear that you are taking filenames that you will open inside the function to write to. This is not ideal. As a user, I'd want to use or : 

Make the strings the same length (e.g. and ) Compute the sums for each digit () Transfer carries (from the right) () Convert back into a string 

is an implementation detail and does not need to be on the interface to this function. Also, note that you take a as your first parameter. You are effectively defining a member function on . Why not put it there? 

What is this? How am I "moving from the most significant digit towards 16^0"? Oh, you must mean "iterate over the digits, starting from the leftmost". 

Please stop using fully-qualified names. You have such a large number of them that the code is hard to read. Instead, import them (NetBeans has a shortcut to automatically import such classes). Also, it's good to organize your imports into some logical order, but don't worry about it if the IDE put them in that order anyway. 

The Big Problem There is currently a rather big problem with your design: treats s differently from s. This should not be the case. Rather, the class should comply with the interface: 

That looks very awkward because stores part of one row and part of the next row. The if statements do go by the top, middle, and bottom row of the nearby cells. Please improve the readability of this when you actually code it. 

You could just not forward declare the function, and instead just define the function here. It's a little less code to write. It comes down to preference 

Then you can note in the documentation that returns a if there is no instance present; in a "global" scope (like main), they should call . 

Note that means that we don't have to write out the type, which would be something like (or since we take the string as , ). I strongly recommend using in almost all places. Also note that if you stored your numbers backward, the work would be slightly easier. Point 2: We can estimate the resulting size we need as . This might be 1 more digit than we need, though. 

I'm assuming that in OpenGL.h, you have . Don't do this. It is especially bad in a header. Also, if you find yourself using globals, you are almost certainly doing it wrong. These should either not exist at all (as in the calling code takes care of it), or they should be wrapped in a that the calling code passes around. These globals and the following point out that you really need to define a class. Maybe something like this: 

You don't need to pad the strings; if we could just iterate from the right side of the strings, it would work. You don't need to compute sums for each digit before constructing the entire string; we can compute and construct as we go. 

Then to get the value, you'd call , but first you should check . This speaks more clearly than a , so I personally find it easier to follow in this case. 

This is a long horizontal line. You really like long horizontal lines. I would recommend splitting this: 

Also notice that I used the member initializer list for the constructor; it's good to get in the habit of doing so. The benefit of this code is that it is now difficult to get the memory safety wrong. If I wrote this function: 

You copy the matrix to a temporary matrix and back every time. This is very inefficient. Although we tend to like immutability, I would avoid it in this case. There are two things bad here: 

There's no need to have a at the end of . For the specific case of the function, is implied at the end of the function. 

It is considered bad to extend . For most purposes, you don't even have to extend Swing components. The only time you'd need to is if you want a custom paint method, so just stay away from it. Favor composition over extending. 

Do note that this will likely lead to a virtual table lookup at runtime, unless you instead declare the in the header file and define in the header file: my-singleton.h 

By doing , you require that is a RandomAccessIterator, whereas you only need an ForwardIterator. Use instead: 

Returning from your function with in theory helps, but I wouldn't do it unless the code has proven to be a bottleneck with profiling. It's a small optimization, and one which I would expect the compiler to be able to do on its own. 

That may very well not be enough entropy to fully initialize the random engine, though (it will not for ), but to actually seed the engine is annoyingly difficult in C++ as of now. At any rate, this is better than using the current time. 

variables are initialized to IIRC, but there's no harm in just adding the to make it clear what the initial value is. Also is an odd name for a variable that is not temporary. 

You are using Java 8's functional stream programming, but you leave out method chaining. Depending on how you chain methods, it could be more or it could be less readable. You might be imagining this: 

The placement of a single in the index-sequence version makes the generated assembly identical for both versions. The missing was on the that was doing most of the work in the index-sequence version 

This code should not be moved into its own function as it's highly specific to this location and refactoring into a function just seems useless. Don't do this for the Java 8 code. In all honesty, separating each call into temporary variables is probably cleaner than making new functions for everything. Additionally, formatting the Java 8 code across multiple lines isn't "relying on indentation and newlines" any more than the other code example is. Try reading this: 

You are working too hard. Java has a Base64 class that does most of the work for you, all you need to do is combine it and the constructor for BigInteger, and you are done. 

This might be overkill if you only use the inside the one source file Huffman.cpp, but you definitely want to do this if the class will be used externally to the source file as well. 

You should use the member initializer list. You don't need all the , but some people do prefer having it. 

Why only add and subtract ints? If you think it's a good idea to be able to divide and multiply doubles, why not have the same thing for add and subtract? That's definitely something I would expect if I were using your calculator. Functions should only do "one" thing Your functions do multiple things: 

Don't implement all the functions in the header file. Instead, create and implement the functions in there. 

On that matter, it's a bit annoying that we have to rewrite the code for values as well as types. However, we could instead wrap the values in a type and reuse our type list: 

It might even be better to forgo the operator altogether, as with this operator, you might have , but because the is different. This breaks some expectations. You were defining the for use with a , but you could just as well define a comparator struct. 

However, if you don't want to use at all (this is generally a bad idea, but for programming practice, you might want to), notice that . Thus, for every 1.5 hex digits, we can obtain 1 base 64 digits. So take the last hex digits of the hex string: . In binary, this is . We only need to consider , which is . So we take the 45th element of the base 64 alphabet: . That's the last digit of the base 64 string. Now just shift the hex string over by 6 bits, and repeat (note, shifting by 6 bits won't be clean, so it's probably easier to instead process 3 hex digits to 2 base 64 digits, and take off the last two elements of the hex string). But noticing the "Cryptopals Rule": 

This means that (almost) everywhere you had to have a special case for an empty sequence, you now don't. For example, you can completely remove this: 

You want to remove the function chaining and temporary variables by replacing it with other functions. I strongly recommend against this. Breaking this into small methods, as you suggest, isn't good. Functional programming is designed to be highly readable as is like this. Hiding the details behind functions makes it hard to understand: 

This is only a mild improvement, and whether or not you call it an improvement is subjective. Your second function: 

On the other hand, if you do want the getter-setter mutable style, I personally find it easier to read if setters are . But this comes down to taste. 

This has the advantage of being easily parallelizable (which is actually only beneficial if you anticipate having a very large amount of values to find the gcd of): 

Due to my needing to use C libraries inside C++, I kept finding myself wanting to be able to ensure that the function got called, even if an exception got thrown. ensures that the function will be called at the end of scope. External documentation shows how to use it, and also clarifies that it is not allowed to have multiple calls on the same line (because is not always supported): utils.hpp 

Your code looks amazing. That said, I recommend avoiding the use of raw s. It's better to make use of thread pools. Seeing as merge-sort is a naturally recursive algorithm, the use of a fork/join seems fitting. Basically, by using raw , you might get a slight performance gain, but it's too easy for your code to bloat. You have two rather large files in order to perform your sort, but by using the thread pool, I was able to implement it in one notably smaller file like so: 

The problem with this is that it leaks memory, although not in the traditional sense of leaking. Function variables live till the end of the program. So while and are only created when this code is first run, they only get destroyed at the end of your program even though you never use them later. This eats up memory the entire time. On the other hand, the amount of memory it eats up is pretty small and constant, so for almost all purposes, it shouldn't make too big of a difference. Even if you repeatedly called a function that had this code in it, the static variable would live and not be recreated. Just don't use this in a way that generates the lambda 100s of times, such as in intense template metaprogramming.