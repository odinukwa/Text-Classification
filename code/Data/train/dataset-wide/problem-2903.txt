A note on performance As for the performance. I can not imagine that this is a particular fast implementation. You use a lot (which means a lot of scattered allocation) your memory access patterns are not very cache friendly and so on. But this is a VERY hard problem to solve generally for all graphs since it is so dependent on its details. solves this with a lot of trait classes and a Visitor concept and is IMO quite hard to use too... and these guys have a lot more experience than both of us. A cheap trick one can do to boost its performance is to supply an allocator-overload to your function. This way you could preallocate a memory arena or even use the stack. 

Note that copying is very cheap since its only a (pointer, integer)-pair and doesn't have any ownership associated with. 

always copies the arrays , deeply can be misused by passing and trusts the user that is chosen correctly. 

It's usually better to treat method parameters as readonly (unless they are or ) since it makes debugging things a bit easier (plus you may find you want to add some better logging later on and then you have no access to the original type anymore). You won't loose much by creating a new local variable instead: 

You don't have to assign the counter on every iteration to the result. Simply increment the counter while the letter doesn't change and then add the count afterwards. Another bug: the way you convert the counter into a string will stop working for any number larger than 9. You want . Also returns the length of the string excluding the terminating character so your is short by 1 in any case. Given the fairly severe bugs you really ought to test your code better. 

The standard naming convention for properties is in C#. I try and give default "magic constants" a name. In this case I admit it's fairly obvious however you never really know what your code will turn into. It is also good to form habits so you wont forget these things. 

instead. Make use of move assignments Currently you have to copy values into your optional. But what, if you just want to move something big that you want to return from a function? You need to add constructors for rvalue-s. 

If I read I do expect to search for a node. But take this as a weak complain only. Naming is hard. 4.2) Nodes should be passed by const-reference or (if you really need to modify s when accessing its children) The way you declare your search method makes it impossible to search in read-only graphs. I suggest something like 

Why is that? Whenever you move a pointer from to you move its ownership to close, but you never free any pointers form , only from . This 

Here is an example of how to use to use uninitialised memory. I think this could help you as well. Do not return by value if you can The line 

2.) Don't use abstract base classes for function objects 2.1) Use instead of abstract base class 2.2) Use instead of abstract base class [ Note: Or just take these as template parameters only. ] The rationale is that the way you do it is intrusive and a client has to define adapter classes to use your library. Since your abstract base classes only require virtual you are better of with which is just such a wrapper around any function-like type. Defining abstract base classes here might also introduce a lot of subtle misuses and errors. For example: you do not define a virtual destructor! Since you do not store your function objects polymorphically it seems to be okay in this case (and might leak otherwise), but on the other hand you take pointers to such objects without -checks... and your classes invite users to misuse them by letting the pointers dangle. I have no experience with fluent interfaces but I do not like this particular example. You gain pretty much nothing but a code bloat -- one selector-class for each parameter plus it seems to be easy to misuse. Maybe one can generate selector classes and avoid code repetition with Herb Sutter's announced metaclasses. IDK. 3.) Don't use an abstract base class to require a ForwardIterator Just rely on substitution errors or constrain your Node type with Concepts / + . This adds again unnecessary coupling for the client to your library. 4.) Issues in A*- 4.1) is not a good name. I suggest something that indicate what you search for (an element? a path!) Suggestions: 

This happens in quite a few places. Readability beats brevity anytime. You use for the count which means it will be unsigned 16bit on most platforms. So if the input sequence is descending like with more than 65535 elements then your count variable will overflow. Don't leave vowels out of names for functions or variables: vs . If you leave them out and they do not shorten the name sufficiently then why did you leave them out. And if they shorten the name sufficiently then it's likely it will become too garbled to read properly. So in either case leaving them out is not a wise choice. Your array holds yet when you check for the max in your temporary variables are which can lead to truncation. Your compiler should have warned you about it. Do not ignore compiler warnings. In fact it is not uncommon in production code to run with an option which treats warnings as errors (most compilers do offer such an option). Not sure why you think you need to make the loop variable : 

1.) Issues in 1.1) You require nodes to be output streamable in You did not state this requirement in your description. Visualising nodes is not your concern here. 1.2) Don't store naked pointers to objects, they might dangle You only store a pointer to the nodes but you do not control at what time this exception is being caught. These pointers might dangle at the time this exception will be accessed. Since you do not require Nodes to be copyable (it might be generally too expensive anyway) you have no chance to store a node here. 

If you want to initialise your data from any range use templates and constrain its type to guard for errors at compile time. Prefer regular functions for computations This means, that an implemented function is also a function in the mathematical sense. Same input data produces same output data. I found that this almost always leads to evaluations which do not change an inner state. Thus it smells to me that 

All these lines above have unnecessary whitespace, however the line below is missing whitespace after the comma in . 

Naming These aren't the actual values, they're type weights, so I'd add the word weight to the end of the variable names: 

You should cast expelliarmus on the magic number ! s are bad keys. In fact, useless. I'm not familiar with , but couldn't you just transform the instead? 

Structure: Instead of having a function encompass everything, consider using a constructor, or if you can use ECMAScript 2015, use the structure. By using the structure your code would look something like the following: 

Clarity: Your program is unclear, the variables are named with single letters, which is bad practice as it is unclear and potentially hard to maintain in the future. Consider using entire words instead of letters. 

Your code has a call in the loop, I would remove this from production code on your website. It's test-code at best. 

Here's the code on GitHub too. If you want to run this code, comment out the lines relating to calling and it should run with posting messages in console only. 

This data structure maps values from intervals of some type which satisfies to values of some type . I remembered this kind of data structure from an interview question. My current use case is a distributed vector where I want to keep track which MPI rank owns which parts of some global index space. I am not sure about the . Explanation I use a where empty optionals are my sentinel for intervals, i.e. marking their end. So when mapping some interval to some value I do this by inserting 

Since stylistic comments are also welcome I will start very simple. I prefer to reserve upper-case names for macros. Instead of 

You will see that implementing is very simple and beautiful in comparison to a direct . Edit: What I call here "upper_bound"-like search is implemented in the STL as not to confuse with . 

Prefer value type semantic Try to make classes default constructible and equality comparable whenever this makes sense. Currently your class doesn't fulfil neither. The following code will not compile 

First it should be noted that standard naming convention in C# is to use for public class members (fields, properties, methods) and for local variables and method parameters. It's useful to stick to standard naming conventions because it will make it easier for other C# developers to find their way around in your code. 

Try to break you code into different methods which take care of the individual things, like counting the words and copying the output. Otherwise your code will get messy quickly and you'll have a hard time trying different implementations easily (and compare them against each other). Your use of a loop with the is rather unusual. Typically you'd use a loop like: 

Your worker method writes directly to the console. What happens if you want to run this code in a windows service process where this should be logged instead? So you should pass some kind of to the method and use that to output the status/log messages. You hard-code your output directory to . This should really be passed in as destination folder.