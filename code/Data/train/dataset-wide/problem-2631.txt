Your code here is really just wrapping the Array class from the ruby library. As such, your performance will be exactly the same as just using Array itself. The array can hold as many items as you can hold in RAM and the performance will be determined by whatever machine you are running on. The ruby array class is written in C and performs fairly well. You ask about optimization but you don't given any criteria, so I can't really speculate beyond that. If you need something that is extremely fast or needs to scale across millions or billions of items, you may want to look at a different language or even a database. Looking at your code, you have several instances of the pattern . The last two are redundant and can be combined. For example, the max of an array with one item will be the one item, you don't have to break it out. Likewise for doing the average; you can average a list with one item and you will still get the correct answer 

This question was tagged connect-four, hence my shape parameters. Those could easily be changed to the variables input by the user (which you should handle in a separate function). Note that this will perform slower than the other presented solutions for smaller values. The speed improvement kicks in with larger sizes. 

You comment what the variable is, instead of giving it a more helpful name to begin with. It's good that you had the comment though, many people don't comment what obscure variables mean. 

Just looking over the two functions, I would probably say the first function is a better practice. It's shorter (meaning it's more maintainable), it uses fewer variables (which can cause less confusion), and does the same thing as the second function. Overall the advantage is that the first function is just shorter. In terms of speed/efficiency (if I had to guess), it looks like the first function would also be a bit faster as well (though not by very much at all). To know for sure which one is faster, test the function calls with OpenCV's methods and . gives you the number of clock cycles after a certain event, e.g., after machine is switched on. 

The stock span problem is a financial problem where we have a series of n daily price quotes for a stock and we need to calculate span of stock’s price for all n days. The span Si of the stock’s price on a given day i is defined as the maximum number of consecutive days just before the given day, for which the price of the stock on the current day is less than or equal to its price on the given day. For example, if an array of 7 days prices is given as {100, 80, 60, 70, 60, 75, 85}, then the span values for corresponding 7 days are {1, 1, 1, 2, 1, 4, 6} Looking for code review, optimization, and best practices. 

Given a binary tree, return the next right node. This question is attributed to GeeksForGeeks. For example, consider the following Binary Tree. Output for 2 is 6, output for 4 is 5. Output for 10, 6 and 5 is NULL. 

Given a linked list of 0s, 1s and 2s, sort it. Looking for code review, optimizations and best practices 

Overall, I think this is very well done. There is one major thing I find wrong with it though: Where is the documentation?!?!?! Sure, as a developer using this library I could read through your short source file and pick it apart to figure out how everything should work. But my time is better spent elsewhere, reading the documentation of other larger projects and programming my own code. That could actually even be a breaking point between using this library, and using a similar (even inferior) library that had good documentation for me to read. 

I thought the function would be optimal for this, and I believe it makes my application pretty robust and fast. On my Mac (ommiting 196 lines of filename output each): 

Reusability - is this Makefile easy to use for multiple separate projects with minimal modification? Organization - is this Makefile organized in a logical and readable way? Dynamics - are there Make features (or compiler options/warnings) that I am not taking advantage of that could make my Makefile more powerful? Miscellaneous - what other things could I improve? 

A BST has two nodes swapped. Figure out which two nodes. Looking for code-review, optimizations and best practices. 

Convert a sorted linkedlist into a balanced binary search tree. Looking for code-review, optimizations, and best practices. 

Why I don't extend or reuse: I am prepping for interviews, and interviewers explicitly want you to code, in my experience. I request the reviewer to not insist on reusing, as I am aware in real life reusability is the right approach. This does not work in interviews. Why don't I use a class instead nesting method inside linked list? That is because I need the to be an internal data structure. Had I made a class, it would have no access to internal data structure and perform operations on the node's pointers. 

Given a set T of characters and a string S, find the minimum window in S which will contain all the characters in T in complexity O(n). eg, S = “ADOBECODEBANC” T = “ABC” Minimum window size is 4 - “BANC”. 

Given a postfix expression, construct an expression tree. Looking code code review, optimizations and best practices. 

Like @Corbin said, there is little that can be done to improve the efficiency of your code. But there are a few things I can do to improve the code quality. 

You've all heard of neural nets, no? One of the "hello world"s of neural nets is OCR with the MNIST dataset. My idea for speech recognition is to train the neural net with short labeled spectrograms instead of characters. Unfortunately I don't know of a database for doing this, so I have to create my own software for doing so. Any suggestions on how to improve it? Note: Ultimately this is meant for real-time speech recognition, but when tested I couldn't plot and write spectrograms to file quickly enough for this to happen (as it interferes with how often the CPU can sample audio from the microphone). I would be grateful for any solutions detailing how to improve performance in this area. 

I am usually in support of using whitespace in programming. However, in this case I think you have a lot of superfluous whitespace in your program. Especially in between braces. 

Example: If a linkedlist list contains 10->20->30->40, and 2nd node has to be deleted then the output should be 10->30->40 This question is attributed to Geeksforgeeks. Looking for code-review, optimizations and best-practices. 

Left view of a Binary Tree is set of nodes visible when tree is visited from left side. Left view of following tree is 12, 10, 25. 

Given a singly linked list, swap kth node from beginning with kth node from end. Swapping of data is not allowed, only pointers should be changed. 

This program connects all nodes of the binary tree at the same level. A node of a tree contains a left, right and a sibling pointer which would connect it to the next node at the same level. This connection is from left to to right. Example: consider a binary tree with parent as node A and left and right child as node B and C. then this program joins B.sibling to C. If the immediate sibling is null, then it is skipped. More details if needed can be found here. I'm looking for code review, best practices, optimizations etc. 

You don't have any statement, yet you declare that you are returning an . Let's return at the end of our program to indicate success. 

This is my first time seriously exploring the aspects of Java 8 development. Therefore, I would like reviews to be tailored as such, since I would like to know the best way for using it in the future. 

Algorithm: There are a few fallacies that you assume in your approach. Nothing wrong, but things that could be improved: 

I have the following header included in some of my projects so that I can add a little color to the terminal output. Here is how it would be used: 

So Apple already has an implementation for this, using . A bit easier to implement than what you have now . 

There is some trick to get each row corresponding to that maximum value based on the parameter, but after investigating this for a few hours I still haven't figured it out and have given up. You could try using to get these rows instead, using to make sure we are grabbing the right values. 

Perform a graph clone. Verifying complexity to be O(E). Looking for code review, optimizations and best practices. 

Check if all leaves are at same level. This question is attributed to geek for geeks. Looking for code-review, optimization and best practices. 

This question is attributed to geeksforgeeks. Looking for code review, optimizations, best practices. Please ignore reviews which include improvements to class / variable names. They are named so for personal reasons and well aware they need to be better. 

There are n balls kept on a table and connected by same singe connected string (which can be cyclic or maynot). Write the code to select a ball such that after lifting the whole structure from that ball height will be minimum. (algo+code+ mathematical proof of correctness) Note, I do understand merits of unit testing in separate files. But deliberately added it to main method for personal convenience, so request you don’t consider that in your feedback. Looking for request code review, optimizations and best practices and complexity verification. 

Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must be O(1). To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, list, .. etc. Looking for code review, optimizations, best practices. 

I've created a regular expression (regex) parsing library in C, and would like some feedback on it. Speed is really important to me, but any and all suggestions are acceptable. 

I've just started a new class learning Java, and since it's been a long time since I've programmed in it I thought I'd put up my first project to get back in the swing of things. Here is my first assignment: 

Recursion here is slowing you down. Using Kadane's algorithm, we can make the time complexity linear, or O(n) . 

You can combine the attribute with either the or attribute, as in this implementation of the postfix increment operator () for instances: 

Test run: As you can see, the accuracy is somewhat low. The runtime speeds are faster than the original Python program in the post above, but I feel could still be improved upon. 

The output given is seen in the above. I know this can be done better. Any suggestions for improvement? 

means you no longer have to write all over the place. That not only saves keystrokes, it also can make the code cleaner since it provides a smidgen more abstraction. There are some places I wouldn't use it in your code, but the s in your header file can use them. 

Implemented iterator for a binary tree and "pre" "in" and "post" order flavors. I'm looking for code review, best practices, optimizations etc. 

Given a Binary Tree, find the deepest leaf node that is left child of its parent. This question is attributed to GeeksForGeeks. Looking for code-review, optimizations and best practices. 

Solution to bounded knapsack 01 problem. Once again comprehensive description is difficult in this space, refer here. Looking for code review. optimizations and best practices. 

Looking for code review optimizations and best practices. Complexity - both time and space is O(n*m) 

Find ceiling and floor in the BinarySearchTree. Looking for code-review, optmizations and best practices. 

This code detects cycle in acyclic graph. The assumption of this approach is that there are no parallel edges between any two vertices. Looking for code review, best practices and optimizations. Also verify the complexity is O(E) and not O(V+E). 

The question is attributed to GeeksForGeeks. Since the code dictates not additional data structure, I am forced to extract out TreeNode class outside, rather than keeping it as an internal data structure. Looking for code-review, best practices and optimizations.