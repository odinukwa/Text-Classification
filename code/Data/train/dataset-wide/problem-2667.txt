While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. Multiple functions in the program are overly complex and could be broken up. The function could be broken up into at multiple functions, especially the outer while loop. The while loop seems to be a good candidate for a function, the two clauses of the if statement also seem to be good candidates for functions. The more separate functions there are the easier it is to understand or read the code. This also makes it easier for any programmer to maintain or debug the code. You might also want to look at SOLID programming 

This does not directly relate to your question but I feel it's still relevant. The Windows API has a function for generating a guaranteed unique random file name (as in, a bunch of random characters and numbers). This API is exposed in .NET via : $URL$ Example taken from said page: 

I have a class that is used to basically store samples from data being read from a system. Within that class is a property that I use to store the date and time of that sample: 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The my_malloc function could be broken up into at least 3 functions to simplify development and maintenance. This is also true of my_free(). 

Good naming of variables and constants. DRY Code Applying the DRY coding principle or Don't Repeat Yourself principle would greatly reduce the amount of code that this program has. There are two very obvious candidates for functions in this program that would decrease the length of this program by at least 20 lines. Reducing the amount of code will make it easier to maintain and reduce the amount of debugging that might be necessary. There is a candidate for a loop as well. The first candidate for a function is this code: 

That's all you need when you use the recursive approach. If you add code to print out the results as shown: 

You would not have all those extra while loops all over your code. Each message would be a header indicating the number of bytes in the message and the content, or some other protocol. Each one of those steps would be a separate function. So your main loop would be about 10 lines of code (like my pseudo-code), and would be easy to read and understand. 

I admit I'm sort of stuck on this. I couldn't think of a better way of representing the card value that will be used in a playing card game. How well thought out is the casting an enum value to an int? I might be wrong but it does not seem very OOP. Is there a different way I should be doing it instead? 

Again, this doesn't help with your requirement for date and time stamping but I thought it was worth mentioning. 

It's much easier to maintain code when it only requires a one line edit. If I needed to change the puzzle size in this code, I would have to edit 44 lines rather than just 1 line. Namespaces Name spaces were invented to solve a very real problem in enterprise level programming. In the bad old days, libraries acquired from other sources might contain functions that that had the same name and variable types as the code one might be writing. Then we would have to change our function names so that they didn't collide with the library names. When a programmer includes: 

Now, according to your requirements you don't want multiple values used, but it's not clear to me if you are only talking about not using the same array element more than once (ie a[i] can appear just once for each i in each solution) or you are talking about using the same number more than once (ie the number x can appear only once in each solution), or you are talking about using the same set of added numbers more than once (the solution x,y,z can appear just once). If you want to handle the other cases, such as to prevent solutions with duplicate values then just check the existing solutions before adding another. Using a HashSet is ideal for this: 

The code seems to work, when I pass in a list of 's it returns the list in sorted order. Is there anything I've overlooked or should do differently? I know time and date programming can be a tricky topic with things like timezones, daylight savings etc. but sorting dates and times shouldn't involve any of that, I don't think. 

I've written some code that uses a to count the number of occurrences of a character in a string. How can I improve this code? What should I be doing differently? Any advice at all would be helpful. 

You appear to be new to Java. For one thing, you are using integers to store ones and zeros to be used as flags. Java has a boolean type to handle that. If you need to store more than true or false, then you can use an Enum to signify the separate "states" you wish to convey. You might consider using separate threads for reading and writing to and from the server. However, your current design does not really need this, since it's a simple back and forth of messages in pre-ordained sequence. More complicated scenarios could be handled by having separate threads, one reading from the user, another sending messages to server, a third reading messages from server. Your while (sTalk == 0) loop should not be a loop. In fact, it is a common pattern in your code for you to put in loops that never actually loop. Most of your "while" loops do not need to be there, none of them will ever repeat the loop. They are really just "if" statements. You use a the scanner class in this case, a more robust solution would use a messaging library like protobuf, or JSON, or http, or use some sort of protocol to organize data being sent into messages. Those three I listed are popular, but the basic idea is that you define what a "message" looks like and you always send data as a "message". That way you would not be making assumptions about what is being sent over the socket (ie you magically know when to expect a string or an int or whatever). A message would have a format, perhaps a header, a length, and you would read each message all together as a unit. You would also not need the magic" character 'a' to have a special meaning. Having a protocol defined allows you to avoid making such assumptions. JSON is a message type that does not even require a header, you might look into that one, it is a very simple protocol and very popular these days. You should probably not catch "Exception", catch "IOException" or whatever is specifically thrown, and you should have try/catch around the different places you do I/O to be able to differentiate the different issues that occur. Overall, I would say that your code is long-winded and not broken up enough into individual pieces. It also makes too many assumptions about the ordering regarding who says what and when. A simple client design would simply be like this: 

This question contains some C# code I've written as well as a XML format I have designed. My C# code runs a series of "jobs" by loading the XML file and then calling different SQL stored procedures and E-Mailing the results to different addresses. My question specifically relates to the C# code to parse the XML document and also how well designed the XML format is. The code allows for a variable number of email addresses and stored procedure parameters. To allow for multiple named stored procedure parameters, I'm using a dictionary. The key is the name of the parameter and the value is the value to be used with said parameter. My questions: