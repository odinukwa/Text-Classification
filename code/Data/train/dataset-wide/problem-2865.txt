The next thing we notice about this snippet is that we're setting immediately after a call to . This smells awfully like we've trying to preserve some invariant here — such as, " always contains the malloc'ed length of the buffer ." We should move the code that preserves that invariant into the macro. 

Look up "hygienic macros." The problem with a macro definition like this one here is that it'll do the wrong thing if the programmer writes 

Okay, so now we have all the mechanics that we need in order to put the player in a location and to move the player from one location to another. But what about planes? How will we represent that certain locations belong to a given plane? Ah, well, that sounds like a table lookup. 

Notice that the calls to and always come in pairs: first we do both on , then we do both on , then we do both on... oops! Red flag! We have forgotten to destroy the object that was move-constructed into the memory of on the first line. The missing destructor call could produce a memory leak, resource leak, or worse. In an ideal world, the red flag of "faulty parallel construction" would have tipped you off to this bug. But I admit that I was particularly looking for this kind of bug because I'd already seen it happen in the wild, in the code of . Type-erased move and swap are theoretically no harder than any other type-erased operation; yet empirical experience has shown me that in reality nobody gets them right on the first try. 

The following C++ code implements the "Genuine Sieve of Eratosthenes" algorithm as described in Melissa O'Neill's classic paper. On my MacBook it computes the first 1,000,000 primes in about 11 seconds. 

This doesn't even compile, unless happens to be . Try it with or the like, and see what happens. Furthermore, if it does compile, you get a memory leak because nobody ever frees the 'ed buffer. Replace your manual memory management with , and change to take two template type parameters and , which are not necessarily synonymous. 

Modulo some missing constructors, I think the above 26 lines of code addresses all the constraints of the Gilded Rose problem. However, this system is unable to express the concept of a "legendary backstage pass", nor of "legendary cheese". In Java, you might solve that problem by making an adjective that wraps a noun; for example, 

It seems like you're mixing two (maybe three) concerns here. First, you're writing a memory resource (a.k.a. allocator) that manages handing out chunks of memory from a buffer. Second, you've decided that the same buffer should also hold basically a as its first block. Third, your initial example (but not your complete final example) suggests that maybe you want the memory resource to take ownership of its buffer and free it when it's done with it? 

That's not particularly concise, but it's much less bad than you originally thought it was. So let's work on removing the unnecessary parts. First of all, you have three specializations of ; that's a red flag, because you should basically always have two specializations of any recursive template — you should have one base case and one recursive case. If you have two base cases, something is probably wrong. You can safely remove the middle case, 

I think you meant there. Regardless, you probably don't need this method; and if you must have it, consider spelling it either 

Again, it smells to me like the author was cargo-culting the practice from some codebase where "every object is heap-allocated" was just a rule of thumb. Perhaps their codebase was automatically translated from Java or C# (two languages where that rule of thumb is actually baked into the language semantics: in many OO languages, you simply cannot create class instances that aren't heap-allocated). This is not good C++ practice, and you should not copy it. 

depending on where you'd prefer to repeat the name . (I'd probably rename that variable to and then use the latter form.) Secondly, don't hard-code magic numbers like , if you can express them as "non-magic" numbers such as "the size of this particular array I've got". 

Not a full review, just an answer on the SFINAE-mechanisms part: I'd say that your method is perfectly idiomatic. I recommend an approach exactly isomorphic to yours, based on some code I originally saw being used by Eric Niebler: 

But basically, this seems like reasonably good code (modulo the wrong names for things like and , and the for-loops). Your use of mutexes and condition variables seems fine to me. will probably be more efficient than , but either one is fine. 

and so on. Plus, you could more easily extend your code to deal with e.g. , without having to bikeshed over whether the enumerator value for (or is it ?) should be 'l' or 'L' or... 's method deals directly in s, and it's always worked great for me. 

In C++14, it would be preferable to specify . I don't know of any best-practices way of saying "use but degrade gracefully to in C++11." 

I wouldn't recommend trying that with C++11's limited form of , though. And I wouldn't try it at all unless you were looking at the generated assembly code and seeing something that wasn't being optimized appropriately. 

I get it, I really do (he says unconvincingly); but I also really think that you're going about this backwards. Step 1 is always to "make it work"; you don't get to "make it fast, make it cheap" until after you get it working. So you should momentarily forget about performance and just work on fixing the bugs and infelicities; and then if it turns out to be slow, you find the bottlenecks and improve them. (I'm not going as far as to say you need a profiler; you can find bottlenecks with eyeballs and intuition too. But there's no point in micro-polishing code until the bugs are out.) 

I think the short answer to your question is "what you're doing is fine, but there are other approaches depending on what you want to do." However, first: 

On to your routine. ...Which is a problem, because you should have written a couple more helper functions instead of cramming everything into . Your code's flow here is: make a sequence of Fahrenheit , then print them out in a formatted table with their Celsius values. This is fine; but your table-formatting logic gets in the way of understanding the basic flow of your program. Let's split that out into a function whose single responsibility is to format the sequences it's given into a table. Perhaps something like this: 

However, this still has a major flaw: You're accidentally requiring that be default-constructible! That's no good (especially if it does happen to be default-constructible but the default constructor is expensive). You can fix this issue, but it requires metaprogramming. 

The last thing I want to talk about is the "genericity" aspect. Right now you have at least three things that the user might want to customize, and you handle each of them in a different way: (A) The data that belongs to an "element". Customizable exactly once per program, by defining . (B) The "less-than" predicate for elements. Customizable per-heap, by passing in a comparator (as a function pointer) to the heap constructor . (C) The "swapping" and "popping" behaviors for an element. Not customizable; instead, we hold, swap, and pop pointers to elements. (D) The source of dynamic memory allocation. Not customizable; we use . If I were writing this code, I would try to mimic the libc function as much as possible. In particular, I would give the comparator this signature: 

Writing from scratch is left as an exercise for the reader, but the trivial C++17 implementation is just this: 

Notice that I changed your prompt from to simply . This was because I didn't want to bother explaining how to write a variadic-template version of that would accept . It's possible — even trivial, in C++17 where we can write — but I want to keep the simple code simple. Now we've localized all the icky "state mutation" into the innards of ; we don't have to think about mutation while we're reading . 

where it saves you a line. In my long-rusted experience, Befunge idiom still values "small number of lines" over "small number of columns" — the language may be 2D but it's still written by line-oriented chauvinists. :) 

Your code is of the type that has no obvious bugs, so I just started at the beginning and tried to understand the algorithm. 

Shouldn't a be copyable? or at least movable? Right now your is neither copyable nor movable, because of its and members. 

You have an anti-pattern in your code: you're writing things like instead of . The former is exactly equivalent to the latter as far as the caller of the function is concerned; but for the implementor of the function, the latter is strictly better: 

Now, I can't imagine how you'd use in your codebase where any of these quirks might matter; but then, I don't quite see how you plan to use at all. Your only fleshed-out example is just using as a verbose way of writing , which doesn't seem very useful. 

Speaking of trouble with carries, let's look at the shift-left and shift-right functions. They're interesting because you're using for the shift count itself, which is unlike any programming language or instruction set I'm aware of. The shift count can only sanely get as high as the log of the left-hand operand, which is to say, it had better fit into . But okay, let's look at right-shift and find the place where you do "If the right-hand operand is bigger than 4 billion, just set the result to and return"... 

If you do this, about half of your code simply disappears! (You'll still need to specialize and/or overload the above function a little bit to deal with , but it looks like you've got the right ideas about that already.) 

Basically, though, this looks like good STL-ish code. The biggest complaint I've got is that that usage comment should be expressed as one or more s; the rest is nits that don't really matter, or won't matter once you constrain the container to hold only trivially copyable, trivially constructible objects. 

so that this overload would pick up the calls to that didn't get picked up by the other SFINAE overload of that signature. However, in that case the SFINAE isn't buying you anything. The point of SFINAE is to make functions disappear, not to make them error out. If you just want them to error out, that's what is for. Remove this overload, and replace the other one with 

...Oh dear. You should definitely give this one a rewrite. At minimum, it should know that bit-shifting by a multiple of 8 is equivalent to a single , and bit-shifting by any other number can be reduced to a plus 1–7 loop iterations. 

Why provide when it would be clearer and simpler to say ? (Besides, cheese does degrade naturally.) (Edited to add: On first reading, I completely missed that you made these functions non-static member functions of instead of member functions of . So you don't even have — you have a monstrosity like . Don't do that.) 

Anyway, I'd say you should learn about and and so on, before trying to invent your own string-handling library. Start with the tools that are provided to you and get good with them, first. 

And then I'd strongly consider refactoring the program along the lines suggested by symmetry: namely, would it make more sense to provide a function 

First nit: and strike me as basically synonymous. So it's kind of confusing that you're using both of them as identifiers in your program. Are these identifiers supposed to be meaningful, or are they just placeholders like or ? 

Your condition variables have mildly confusing names, IMO. Is the thing I should wait on when the queue is full? Or is it the thing that gets notified when the queue is full? A little thought shows that it must be the former; but I don't like thinking, even a little bit. :) 

The assignment is dangerously misleading. Unless I'm mistaken, it corresponds to two atomic operations: first "atomically load into a register ", and second "atomically store into ." If I were you, I'd definitely write this as two separate statements. It doesn't actually matter in this case AFAICT, but since you're apparently trying to come up with best practices for how to write secure and bug-free code... "multiple atomic operations in a single statement" is way high up on my list of things never ever to do. Alternatively, local variable doesn't really need to be . You could just set without introducing that variable at all. 

(Expand it out. Do you see why the control flow goes wrong?) Whenever you write a "statement-like" macro in C or C++, you must wrap it in for hygiene. Also, consider what happens with 

Here you're reading not-under-a-mutex-lock, while simultaneously might be writing to (that is, it might be popping from it). So you have a data race and your program is invalid. Also, your "busy loop" 

The "cookie" parameter can be used to pass data from the caller, through the generic algorithm , into the comparison function. In this instance we're using the cookie to pass the user's original function pointer through to be used by . But the user could just as well use on their data array directly, with no indirection through s. 

In the signed version, your use of is a red flag. is never appropriate in generic code. For one thing, if is some clever fixed-point type, won't compile; what you meant is more like 

When you see it... This is the funniest argument I've seen yet for suffixing data members with and never writing out except where the grammar requires it. :) 

Oh, and I strongly suspect that you're eventually going to run into problems where you're looking up a Unicode string in your map and you don't find it when you thought you would, because of Unicode normalization issues. So, be prepared for that, if you can. 

I may be biased, but I think some excellent advice for anyone trying to program in C is "Learn C++, and then write C++ in C." This immediately leads to a lot of minor improvements in your code... 

Your style here is highly unusual. First of all, you should be aware that in C++, a is just like a in most languages, except that members (and bases) are private by default instead of public by default. So, instead of writing , it is often more readable to write . Also be aware that in C++, unlike in C, you can refer to any type directly; you don't have to qualify the type's name with , , etc. This means that the C practice of is frowned upon in C++. Lastly, notice that your struct members will be laid out in order; so you could eliminate some padding bytes by shuffling them differently. Result: