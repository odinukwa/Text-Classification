You code is quite efficient and well designed. I think you can get a little bit more efficiency at the cost of making the code more specific to this particular task. In particular there are some shortcuts: 

even if you have only a single option it would be good to write your code as if there were many. This could be simpler to understand and easier to extend. I would keep the options (in your case which you could transform in a boolean variable ) as global variables, and parse them in a dedicated function. Once you have extracted that code from the main function you will feel more eager to add other options (for example --help to print the usage message). You function is definitely too large. Extract the arg parsing code. Put the logic into a separate function and let main just be glueing code. Here you are reinventing the wheel: 

Lock based concurrency in .NET is a fairly simple paradigm (compared to the other ways of ensuring thread safety in .NET). When you lock, you declare a block of code as a critical section, protected by that lock object. .NET ensures that a second piece of code in the same app domain will never be running in a critical section protected by the same lock object while one instance is. Here is a good resource for more threading information: $URL$ Pedantry When most people discuss thread safety they mean it in the same sense as saying strings are immutable. That is to say, as long as you don't do anything I shouldn't reasonably expect you might do it is safe. Unfortunately, locks aren't good enough to actually provide true thread safety (bulletproof against reflection and C# pointer code), they are good enough for most usages where you control the software stack out to the actual application. If you need to ensure thread safety in these instances you must ensure thread safety at the field level in your classes (stuff like the keyword will help you here, but watch out). Some example threads that would break your safety here: 

note: in C++ it would be easy to make the computation of the array of the perfect squares at compile time. Maybe also in C it could be possible (using #defines) but not as easily. 

which can be achieved if you define a dictionary of classes. The code could become even longer, but separates more clearly the logic of your Range class by the information about different Tokens. If these Tokens have other functionality using a class becomes even more convenient. The definition of token is clearly separated and does not interfere in the logic of the application. Also, adding a new token is a matter of defining a new class and registering it in the dictionary of tokens. Similar token could benefit in inheritance. For example: 

this is not a good starting point. Your implementation is very far from being comparable to any database program. What you are doing: 

(this pattern of having the function surrounding your code like this is commonly referred to as an IIFE) Aside: for declaring a namespace I prefer the following form: 

I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

I would modify the rest of the code as follows; please comment if you want me to explain any of it in more detail and I'll try to get to it. Comments dictionary: 

and changed accordingly (and remove ). Instead of and , out the smallest element I have no idea how big of an affect this will have (if any), but I think it would be faster to just splice out the smallest element rather than sort every time (again depends on size of your map). In the meantime there is no benefit to having at the end of the loop rather than right after the sort and caching the lookup into a local variable: 

use a bytecode to store your compiled code. The only thing you need is to replace the brackets with some sort of jump_if statement. No need for linked list... just a buffer of bytes. write a function to compile BrainF*** into your bytecode. Just copy the source code and put the current address on a stack whenever you find an open bracket. Write the jump_if statements when you find the corresponding closed bracket. define a data structure for the state of your virtual machine: data pointer, program pointer... and that's all. write the interpreter as a function accepting the virtual machine. 

This check is non very useful. It does not decrease the algorithm complexity. In particular the check is wrong... you want the function to fail if the arr is not a list, otherwise you hide possible errors in the caller's code. 

I don't like too much the names of these functions. I know that also python uses ugly names (words without any separator) but I think you could improve this... for example: or seem better to me. About the functionality. Managing dates is a quite difficult task. The python library in my opinion makes a great job in distinguishing and datetimes. Your wrapper module simplifies this by considering each datetime as a localtime (if I understand it correctly). I think it is not good to hide this decision in your code. Explicit is better, even if it could me more verbose. Also I think you missed the function, which could be used in your code.