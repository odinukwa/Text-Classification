and contain almost the same code. This should be extracted into a common method instead. In the method there is also a fair amount of code duplication in this part: 

So if the user is not logged in you load the view and then you load the view again unconditionally? I'm not PHP expert but I'm pretty sure can be condensed into 

Is that basically correct? If yes then this smells to me: If you have a member in a class of type then this basically says: "I want a factory which can create objects for me and do not care what they actually do" while in fact this is big fat lie - why else would you decorate with an attribute saying "actually this requires a very specific functionality factory"? If the application requires that object Foo gets injected with a specific functionality factory then express it by making the type rather then - no 200 attributes, no 200 kernel bindings. Now you will probably say "What about unit testing"? 

This should be a simple refactoring on your service class and not expose any more json to the business logic than before. 

I'd prefer the first method because it's making more efficient use of resources (provided the async methods you call are really async and not just wrappers around synchronous methods) and it also looks cleaner. To quote from this MSDN blog: 

It has also the advantage that the application code doesn't have to know what menus exist so they could easily come from a database or other configuration file. When adding a new menu no code has to change. Example implementation could be: 

Even on a 64 bit system the size of an array is limited to 2GB. So if your largest key is in the vicinity of or larger then you will get an . Depending what else you are doing in your program you will get it much earlier. If you are experimenting around with sorting algorithms then there are some interesting approaches reducing the key space. 

Instead of disposing and manually you should use a block. This means they will get disposed even if any of the code in between throws an exception. Similar s are so again you should wrap them in a block. It is not overly clear that the is used for logging purposes until you read the code. I would abstract it away behind an interface which I would pass in. It makes it much clearer the the messages are used for logging and removes the responsibility of managing the log file out of the function (Single Responsibility Principle). In fact you should have a look at log4net which provides a whole heap more flexibility in terms of logging targets and filtering. In case your project should grow this will make things a bit easier. 

That being said, given that your method is called I assume it's only ever going to be called from a UI thread and of that there is usually only one. So your current implementation will probably work but that's largely due to the fact that calls to are going to be made from a single thread rather than your implementation being thread-safe. One issue, as mentioned in the above example code, is that should the expensive operation ( in your case) throw in any way then you have locked yourself out because the flag will never be reset. 

I'm not sure if it will make your query faster but here is my take on it: If I read the code correctly you want to create orders for all gift transactions related to gift ids which are not covered by an order yet. 

You could copy the values back into - provided is quadratic and therefore and will have the same dimensions. Otherwise if the class offers a re-sizing option then you could re-size left afterwards and copy into it. However that is extremely ugly and I would question that requirement. As a side note: It seems weird that provides a static method for setting a cell value of a object. I would have expected that to be an instance method as well like . 

I would suggest to rename the first method to and pass the user as single parameter returning a string and rename the second one to which accepts a string and returns a user object. Alternatively keep the dictionary for the second method but then also pass in a dictionary in the first. You could then have helper methods which convert users to/from dictionaries. You have some magic constants without a unit and therefore had to write a comment of what it means. 

My question would be: Why is it supposed to "overwrite" the left value? This seems dubious from a software engineering point of view. The product of two matrices is: Anm x Bmp = Cnp hence you can only "overwrite" A with C (re-using the same Matrix object) if or in other words if B is a quadratic matrix. For now let's clean up the existing code by getting rid of the intermediate array 

You can reduce some of the indent by checking for the negative condition and bailing out early. E.g.: 

So the states themselves execute the code required for the transition into the next state given the current token. You can also pass around a context object if required. 

Users can define their own node types and associate any meta data they like with it. The internal implementation of how nodes and edges are stored is hidden from the user as they do not have to concern themselves with it - neither should they. 

Another major speed improvement can probably be achieved by not using strings for entries which obviously aren't strings. You are doing a lot of double-to-string-and-back conversion which will be slow. If you can convert the input data into double when obtaining it, perform your calculations and then convert it back for output if necessary it should speed things up a lot as well. 

On my machine which is an i7 with hyperthreading enabled (so going much beyond 8 in parallelism is probably not going to change much) results in this output: 

While it might be ok to be able to exceed the upper bound by up to the maximum number of producers - 1 the same race occurs in . Except on the consumer side it has the nasty side-effect of potentially trying to remove an object from an empty collection. In this case gets returned which the caller might not expect since doesn't accept objects. Based on the check in I would infer that you never expect this to be instantiated on a value type but only reference types. I don't see any reason for it but if this should really not be allowed then add the type restriction to the implementation to make it clear. In the end the bounded capacity really doesn't mean all that much since it's randomly exceeded and one can dequeue randomly from an empty queue. Overall you should use to wrap the which implements the bounding capacity correctly. Just make sure to use the and methods accepting a so blocked operations can get interrupted nicely when you want to shutdown the application.