No! NO! NO! NO! NO! NO!. If you're going to force TLS (a good thing for sensitive information) you need to check the certificate. If you ignore all the validation then someone could give you a self signed cert for a service they don't own and you wouldn't even know. Don't do this. I can't even find words to use to fully convey the amount I've just lost faith in humanity. 

I haven't written raw ADO.Net code for several years so I apologise if the above is massively incorrect. You should explore a product like Entity Framework (full ORM) or Dapper (more lightweight) to simplify a lot of this repetitive code. 

Then you have a nice immutable class for your with consistent equality behaviour... Phew! Edit As EBrown pointed out in the comments, is a perfect fit for being a struct. It's less than 16 bytes, immutable and (0, 0) is a perfectly valid value (i.e. unitialized). 

I did a bit of testing on jsperf which seems to indicate that it would be marginally faster for you to delete the properties you don't need rather than create a new object and replace it. Obviously, your mileage may vary. My test was objects with 6 properties, 3 of which were different. EDIT : Delete is faster on IE. The new object version is faster on Chrome and FF. 

I think you have your separation of responsibilities slightly wrong. For example, why are you tying each instance of a to a specific location? It seems to me that it would be better to pass the location in later. The name is also too concerned with the implementation. The caller shouldn't have to worry that the data is from an API. One other issue with that class is that you do non-trivial work in the constructor. Generally, initialising an object should be cheap. I'd advise that you split this up so that the user creates a and then calls a method to actually perform the request. 

It prints 'action' four times. That's not what I expect from the API (but is what I expected from reading the code). I'd expect the number I pass in to be the total number of invocations - not the number of retries after the first attempt. 

Do you know about radians? (and the other trig functions in .Net) are based on radians not degrees. radians is roughly in degrees. Which is a bit odd... There are radians in a circle so 1 degree is . As long as you use the same value the lines will be parallel anyway but I thought it was worth pointing out. Why do you need the Cos at all? You have a line from (x1, y1) to (x2, y2) with length . You know that you need to offset the line by an amount () orthogonal to the current line. 

Well. I have to say that I'm completely stumped by what you're trying to achieve but I haven't studied Chaos Theory in about 5 years so I'll chalk it up to my ignorance. With that in mind, here's a quick review. Calculating the depth of a tree is trivially easy. 

I like the architecture - it looks sensible, flexible and extensible so kudos for that. There's not really much to criticise with the code either - it's clean and readable. I do wonder what benefit you get with the generics particularly if you're expecting numbers that could reasonably be dealt with using the whole way down. I also think you should initialise the property to an empty list in the constructor for . The only real concern I have, which may or may not be valid, is the order of applying the modifiers. At the moment it's a first in, first executed model. This means that adding the same modifiers to the attribute in a different order result in a different value. Say I have a defence attribute and I can modify it by putting on some armour (+5) and/or by drinking some special purple liquid (*2). If the base level is 2, depending on which thing I do first, I can end up with a modified value of either 14 ((2+5)*2) or 9 ((2*2)+5). Is that desirable, or should you have a more advanced ordering - e.g. additions always come before multiplications? 

I've hinted at it but I'll say it outright - you get very little to no benefit in writing s wrapping the db context. It's just not worth it. I'm not going to comment on the bad naming because I'm guessing that this is actually just an example of your working code. 

Naming should be treated as a single word like in . You should also not name a class the same as its namespace. Which is why this is really not good: 

You can also add in the stuff to get default values but not sure whether this makes sense on an interface or perhaps as part of a base class. You'd want to compose these services in your control: 

Why have you tied yourself to only lists? There's nothing here (apart from the case sensitivity flag) which couldn't work on generic lists. 

I'd also prefer or the unary negation operator over the explicit multiplication. I'd also factor it out as a separate method. 

Okay, you're deep cloning the items (I would guess) - no indication of why and you've made me try to figure out what you're doing. 

is a bad name because it's very general and it reveals the implementation details. The interface could be made more general by working on an which is the more general interface for a sequence of numbers. 

I can understand why you want to remove the clutter from your code - but sharing the instance of isn't a good idea. As soon as multiple threads are trying to use the connection at the same time, things are going to go wrong. The connections are already pooled for you (See here) so you creating and disposing s is cheap and easy. I think you should create a connection factory: 

Vogel612 has already covered the performance aspect. I'd like to make a suggestion that will definitely be slower but has an elegance to it: 

Other comments As I mentioned previously, this isn't gauranteed to be correct (but is in every instance I know of): 

Perhaps controversially, I'm going to say your extension method does have a purpose given a situation where: 

Firstly, the biggest problem is that implements so your class should too as it holds a reference at the class level. 

I then decided to use Manhattan distance because I'm only allowing up, down, right and left (i.e. no diagonal) which seemed pretty standard: 

Your code is easy to read but I think there's quite a bit of room for improvement. If I were screening your code, I'd be looking for: 

Why have you chosen for the Type parameter? It's a small thing, but most people would expect to see . Try to stick with convention where you can. 

On my machine it takes about 20 seconds to seive to which takes just over 250mb of memory (roughly bytes). Any room for improvement, bugs or style issues? 

Distinct Take a look at the documentation for Distinct. A couple things from the remarks should stand out for you: 

I don't know whether you'd consider this a bug or not but consider a wall with zero bricks. Your code will output for the least number of bricks crossed: 

I decided I would treat each point as a 'tile' and have the cost on that tile rather than weighting the edges directly. I chose as the value representing an impassible tile... I'm not sure I like that now so thoughts welcome. 

Dead code Kill it. If you have some commented out code that you aren't using just delete it. It adds noise to the reader and doesn't add anything to the code. Not to mention factorial is an incredibly simple thing to add back in: 

I think you should check that the range isn't zero length and throw an exception if it is. Use the ternary operator where it makes sense: 

You'll find that you need to think about the usage of the function before writing it so you can get the parameter order right for currying. In my limited understanding/knowledge of Elm, I'd say that your code is pretty good :) 

Have you tested this? You've used the words 'quick' and 'SharePoint' in the same question which, in my experience, is almost always a lie :) You have a problem here: 

We all ready have the (well named) and delegates for that. Comments I know that as programmers we're all incredibly funny and brilliant people, comments can be funny. Your comments leave a lot to be desired: