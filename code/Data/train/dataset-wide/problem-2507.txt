That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?" 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

No. Having many small classes is perfectly fine. It's a matter of appropriateness though again. I found it helps to keep things separated and small. However, it also gets harder to visualize the code flow in your head then the more classes you add. 

A good general set of rules to follow is GRASP. Another easy test is to look at what the class does and then check that the name matches that what it does. Your User apparently loads things from the database and checks passwords. Not exactly what I'd expect from a User. 

If I interpret this bit correctly, you're just testing whether there is a second dimension within the array, and if there is, you're looping through the array as a 2d array. Otherwise, you're looping through as a one-dimensional array. Wouldnt it be nice if we could explicitly say that in VBA? 

Note the subtle elegance of the code. I didn't notice the effect this has when I first started writing classes in this way, until I had about 10 different classes and I had the RD explorer open. From top down: 

Now you've really upset the worksheet. It has to update calculations, it has to resize stuff, fix formatting (if in a table), check number formatting, etc. It is a costly operation. If you're deleting a lot of rows...avoid it at all cost. Enter the world of arrays. Not only are they fast but they are easy. becomes . Once you load in the data to the array (Data) you can manipulate, access, delete the values all you want. The worksheet doesn't care. It doesnt see what is happening to the same data it was previously responsible for. Putting It Together I am not going to go through the code line by line, particularly because I already provided in-line comments to help make the code a bit easier to read. This will be a broad explanation of what the code does. 

We could improve this a bit further by employing the use of constant values and such, but overall this will point you in the right direction. Note that, with the improved code, I made sure to use clear variable names. Most users will understand what means in context, but is clear to any user. Even better would be so that, even if your reader was completely dumb to reading code, they would know what that variable was. Same goes for naming s, and s. Best of luck! 

Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

That gets us right back to the first question. If we assume User to be a class holding business logic, then technically, putting the db access into the User is a violation of SRP. However, when the impedance mismatch is small or doesn't exist, then using an ActiveRecord'ish pattern might be practical. So check how much impedance mismatch you have. When you notice your User to turn into a ORM, consider using an ORM instead. The other option would be that your User doesnt have any business logic and is really just a Gateway to the storage engine. Then it's okay to have db logic in it. It just shouldn't be called a User then though. 

Basically there is an input field on the website. When user types an URL in the input field, an ajax request is made and the method above is called with the URL the user typed (He could change 10 times the URL which means it will go 10 times through that method). When I've the data as base 64 I send it back to the browser of the user which displays the image. Then the user can crop the image as he pleases and when he is done he presses OK. Afterward I crop the image on server side with the (that I already have because of the previous ajax req) and save the file. I would have done the process of converting an URL to base 64 on client side if I could but after some tries it seems like it is impossible because of cross-origin issues. Whole code works though. 

The "WHERE p.idpost IS NULL" is removed. Now when I access a child's votes like this : , the size will be 0 or 1. That this method actually gives me the already filtered data even with . My guess is that since I already loaded the data JPA doesn't go ahead and reload it with the data I don't want. I ain't sure about this because of something I'll tell later. So yeah after querying all the result I just deleted all the Post which are replies from the list : 

I made it work a better way. I think I know why it works but I'm not sure though. And it turns out it actually easy. So what I wanted is to keep the Tree structure I had when I was querying like this: 

Somewhat recently I encountered an issue where my projects were simply taking to long to run. A lot of my macro work comes down to taking multiple tables (generally formatted in the same way) and joining together these tables based on specific users. This led to instances of loops that would loop over one table nearly 100k times, searching for a value in a table of a similar size and it would do so repeatedly (10 times or more). I ended up developing the class below for this task, but I am certain that there are things I simply don't know, or could do better. What this class does is basically provide a Dictionary with some additional methods that allow me input tables and return a Dictionary I can retrieve values from. The main reason why I built the class was that I didnt want to keep writing loops that would simply loop over a table and add a dictionary with the only differences being the number of dimensions I needed. I hope this all makes sense. Any advice is appreciated! 

First, it loads in all the data from a (excel Table) into an array. That's the easy part. Once we have the data, we need to know the indices of the headers. This makes manipulating the data much easier. It also allows you to move columns around all you want without breaking the code (just ensure the names are still there). Using a custom we can store all of the data in a defined structure. A is similar to a in other languages. In essence, it is a variable that has properties, but that isnt an object. Thus, it cannot be 'ed up. Loop through all of the rows, and create new records for cells with multiple addresses. Since the cannot be 'ed, it will retain old values. This means we dont need to re-create the entire for each new row. We just need to change the new values, then add it to the collection. Once the collection is loaded with records, we can translate them into a new array that is appropriately sized. No need to add/remove rows. It is just the right size at creation. The method will take an array and a worksheet and it will clear the cells on that worksheet, put the array onto the worksheet, and then turn that output into a table. Point it where you want the output to go, and it will do the rest.