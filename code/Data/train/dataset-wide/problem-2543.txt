Your code goes over all the non-negative integers, and takes counts how many of them result in a prime, until the first non-prime. "All the non-negative integers" can be expressed in ruby as , so we can write: 

If this is what you actually wanted, you don't really need all the temporary artifacts in the middle - simply do it in one swoop: 

For someone who wasn't conscious when he wrote this code, it looks quite nice :) Some observations: Tests should do only one thing This is OK in most of your tests, but you got a little 'lazy' at the last two tests - make a different test for each . You could use RSpec's one-liner syntax, just for the fun of it: 

Meaningful Names A class named does not tell me anything about what it does. This goes twice for a method called , and is simply misleading. Give the method a name which actually explains what it does: 

I like the way you fill the hash, though I wish you had named your parameters better - is an obfuscated choice. Also, you could have refactored it into a method Having is not inheriting - Your class is curious - you opted for it to inherit from instead of having a , and then you override to do something not very Hash-y... The names you chose for this class are very generic and obfuscated... I would have written that class like this: 

I also think that you should consider not save the in your map, but rather a of it. Less boilerplate Your code has a repeating pattern which is something like this: 

Exception Handling You wrap the with a try catch block, but if an error occurs, you simply write a line to the console, and continue... in the very next line you call , which will result in a ... Morale of the story is - if you don't have anything smart to do in your catch block - it is better to let the exception bubble up to where it can be handled, or otherwise stop the application completely, notifying the user what exactly was the problems (that's what exceptions are for...) Documentation The only documentation you have is for the method, and it is full of reiterations on how this methods returns a random number between a min and a max number. This kind of documentation does not help anyone - the signature of the method is self-explanatory. Documentation has a nasty habit of rotting - since you tend not to maintain it as you maintain the code, and it becomes inaccurate and ultimately misleading. Documentation would be needed when the method's signature does not convey what the method is doing (like in ), but I would sooner change the name (and the content) of the method before writing documentation, as suggested in the other answer here, since I believe that comments are a code-smell, and that self-explanatory code is an indicator for better design. 

As for your suspicion about not having to pass to , I don't see a straight-forward way of doing that, or a proper motivation for doing it. Perhaps you want to be able to simplify your block into a straight forward method call (using a syntax like ) - for that you can use proc's method, but it actually results in a very awkward code, which does not seem to be worth it: 

But wait - you are still using hard-coded indexes! True, and are still there, which looks a little "hard-coded", but these indexes refer to the data structure, not the data itself. A more elaborate design would likely use a hash to hold chapter data (), or even a class having two properties, but for the example above it shows the concept of encapsulation - as long as two modules know the language (=API), they can independently change things in their domain (wither adding chapters to the book, or change the layout), without affecting other parts of the code. I also took the liberty of changing the structure of the input, as @Flambino remarked, but only because I assumed the choice of the structure of the input was not an outside constraint, but a design choice (it didn't make much sense otherwise). 

An empty interface is a code smell. In C# you can use attributes to mark a class instead of making it implement an empty interface. As I suggested in my comment, you can use reflection to build your instead of receiving it as input, and failing on discrepancy. With the power of attributes, you can add functionality by marking which properties you want to map, which to ignore, maybe add metadata (like the column index): 

Indenting and spacing Java's indentation conventions are no more than four spaces in a block. Also don't overdo spacing inside your parentheses and between braces. See here for more conventions: 

Edit - this is, of course, wrong (thanks @Matthew) - I got confused with java), the default access modifier for members in C# is private. I still stand by my recommendation to be explicit with , to be more readable, and compliant with coding conventions. Object Oriented For some reason has a property called which is... an ?? What did you intend this property to do? If you want it to hold a , its type should be : 

This is Code Review, so I will not try to find where it doesn't support 2048 bit BigIntegers, but I will tell you what I see in your code: Naming Conventions You should choose your names according to your language's naming conventions: should be , should be (see also below regarding proper variable scopes), should be , etc... Also refrain from single letter names for anything that you use for more than one line of code - , , etc. Proper names Variable names should clearly state their purpose means the number 1/2, especially next to and . Actually it means half the input number. It is used as the max possible divisor, so call it that - . Same goes for - it should be (btw, what happens when you change its value to 2048?) When things don't change If you have data which does not change over time (like the number ) - making is is good, making it a constant () is better: 

Readonly properties This is also recurring in your code - property getters for members which are initialized only upon instantiation. If you replace them with members, you can make your code more succinct: 

More to come...? I don't have a concrete suggestion on how you should implement it, but the solution you have is a little dodgy: 

} Note that in this solution, I've gotten rid of , since is hidden in ... So now the method becomes: