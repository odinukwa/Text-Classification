This approach with a sort of ad-hoc parser is particularly difficult to test, because of the high complexity of conditions. There is a much simpler way to implement it: regular expressions! It looks like the arg is expected to be something like "He7m2". A corresponding regular expression would be . The values in the matched groups will correspond respectively to , and . If does not match the expression, this is a good reason to throw another IAE. Invocation 

I think that this method should be defined elsewhere, because it does not correspond to the functionality of . It's a good idea to use inside it (and even better would be instead of it). Since this is a public method, the validation of the arguments should be done on non-nullability of and . The existence of the files will be checked in , with the respective exceptions thrown. The target object can be created easier with , no need to instantiate a . 

This method does two distinct things: 1) Determine which URL to use depending on the value. 2) Instantiate a object with suffix. Each of these things should be wrapped in a dedicated method. So let's first create the method: 

If you are using Java 8, there is no need to create a dedicated class for this purpose. Lambdas are helpful: 

branches are used to match Strings: this approach is too verbose and not very flexible. is instantiated in two different places, with same semantics. The thrown in block is immediately caught and thus is useless. The catch blocks hide exception details and trace, which is annoying for debugging. Returning is ugly. A better choice would be either to return an or throw the exception outside the method. 

You correctly identified the part that differs among these methods, so next step is to exclude this part. Its role is to initialize the instance to be set on . This instance can just be passed as argument to the extracted method: 

in the private method should also be extracted to a local reference in order to shorten the expression. 

It looks like the good/bad old imperative style. In Scala, and others are functional style replacements for traditional . The for-comprehension is a sort of shortcut allowing to iterate, filter and map (with ). For example: 

Design Improvements Three nested loops and conditionals create too much complexity. Really, too much. The idea for improvement is: 1) Create a that associates a process name with its date. It will help us to know that the process having this name is associated with this date and that it needs to be associated with all the other known dates. 2) Iterate on the entries of the map. For each entry, create a collection of all unique dates and remove from it the date of the entry. Create a new for all those dates and add it to the target list. Here is how the whole solution might look like. is replaced with : 

Indeed, "UTF-8" is one of most common encodings and that would be really surprising that such exception is thrown here. Semantically, it is close to an illegal state of the application: one would hardly imagine that it cannot support this encoding nowadays. Since the chained is a , you will be able to remove it from the signatures of the methods. 

the code will still compile and work: looks like is not really meaningful in this implementation. I suggest to create a dedicated type that will provide a means of evaluation of expressions expecting two args: 

Bug In the constructor, must be initialized before calling , otherwise a is thrown if the folder contains subfolders. Design Constructor I agree with @holroy about the fact that there are too many things done in the constructor. Its job is too heavy, instead of just initialize some things. Moreover, it makes the instance unusable for other parameters, e.g. to search in another folder or with another regex, one will need to instantiate a new . 

Another Approach I can suggest another approach that has more or less the same result of externalizing SQL queries, but can be achieved without the dedicated class, only by using the features of Spring. The fields representing SQL queries can be initialized from property file sources: 

It can be very confusing and error-prone when the instruction that immediately follows a condition is not wrapped in a block. 

Briefly speaking, because is a function that is invoked when necessary. is a constant reference, calculated only once on first invocation. If s were used here instead of s, we would not be able to check the condition from within the method for each particular cell. 

If something breaks, you'll easily find where the problem is, instead of decoding the meaning of or . 

are simply awful and indicate that there is a deep design issue with the definition of the entities used throughout the code. The worst case is when such calls modify the state of the deeply dependent objects, e.g. or . It may be a real hell for debugging. Encapsulation , and should not be directly exposed and should be accessed/modified with getters/setters. Missing Abstractions There are many class casts like or and checks with . It looks like the hierarchy of objects that may be returned by is chaotic or there are some abstractions missing. I cannot say more about it, because the example is not enough to conclude about. 

This class contains two blocks. is too generic. Dedicated per type catch blocks or a multi-catch block for expected exceptions, like , should be used. Since JDBC4, there is no more need to call in order to load the driver. should be able to cope with it. 

Method signature change may be avoided if you think it is possible to handle the IOE inside the method. Keeps only readable folders inside the enclosing . Creates a stream of expected files. Keeps only that really exist. Creates a stream of optional objects for each existing . Fills the map with created instances of s. I'd also underline that this original way of filling the map is not very clean from the point of view of concurrency, but the context is not enough to judge about it. 

Do you find this pollution with generics, spread everywhere in the code, useful, readable and aesthetically pleasant? I guess that what you are trying to do here is to anticipate a probable future replacement of s with s and so on. Update. To reduce this overflow of generics, that may be useful to transform into an abstract class and add a short one that inherits from it with the right numeric type. But I doubt that this is necessary at all. Your virtual space is better defined using integers. Why not just have a class with ? That will avoid boxing/unboxing with in many cases. Similar changes may be done with the other generics used... Genericity is good, of course, but it should be pondered if it's really necessary here. Consider Using Existing API The class seems to have a number of features similar to or . They may be considered for reuse here. p.s. Please change package names to something that respects Java naming conventions. 

Prefer Classes to Multiple Tuples There are lots of usages of , with multiple occurrences of and . Tuples are nice and suitable for various situations, but when there are too many of them, it reduces readability and increases risks of bugs. And you need to remember that is and is . Or vice versa. Or both. So a simple way to improve it is just create an ad-hoc class 

and so on for the other commands. The method should also be put under this hierarchy. There is no reason to make it distinct from others; the arg that it currently receives is used only to control the output, which may be triggered through a dedicated method. Each concrete implementation may also host a method that returns the contents of the help section for the command: this will avoid to have the infinite clause while handling the help output. Finally, is not a very comfortable container for the commands and their handlers. An would suit better, for example 

1) There are too many methods doing very different things. It should be split into smaller ones, by action semantics: user management, sending resources, messaging, etc. 2) Too many arguments for the majority of the methods. Try to reduce them by wrapping things into dedicated objects. 3) There are many methods like: 

But if you need to change the JSON view for this object only, you'll have to override the getter, which brings back the verbosity. Similar approach can be used for JPA annotations if the relationship between entities is not very complex, but there are many pitfalls with them anyway and duplications will not be avoidable in many cases. Other remarks: 1) Why do you use , and fields instead of a single field typed as ? 2) might be too much for field. is hugely enough. 

If repository call times take most part of total execution times, the problem is definitely related with network communications. As for the code you are trying to improve, I can say that there should not be problems with the code itself. Although the style is a bit oldish, it does not look problematic. Here are some suggestions, using Java 8 and functional style: 

For the rest, the code seems quite straightforward, rigid and repetitive, hence difficult to maintain. It contains many clauses that smell bad. Of course, the whole story may be refactored with patterns usage. But I don't think that the state pattern suits well here. It'd be better refactored with the command pattern. All the menu actions (create, remove, rename and their dependent ones) may be wrapped into separate objects, which associate the expected keys (1,2,3..), the text and other necessary stuff and sugar. For example, a (very short) version of class could be like this: 

The use of reflection is the drawback of the choice of s to wrap the data. If you have to keep the s, there might be a simplification, avoiding the brutal method invocation by name. It consists of the following: 1) Create an interface that provides access to the target method: 

Style: the prefix for the private fields violates standard Java naming conventions. There is no need to call to check if the item is already in the map. For s, there is the method that does exactly the same in one line. I'm not sure that and are necessary in . How do you expect values to be present in the collection, if method checks the object to be not null? 

I think that this is not a good practice, but it still may be acceptable in some situations. The reasons to avoid this: 1) methods are not intended to introduce new functionality, but rather to provide backwards compatibility for older APIs. The official tutorial says: 

The interface is a good idea, but it shouldn't be just a marker interface. It seems very probable that all the implementations that you will add later, will contain a value. So, a method declaration like would be useful here. It will allow to access the value when necessary, without worrying about the concrete type behind. Over-engineering But I'm also asking myself if a separate class per BarCode type is really necessary here. Should just remain a basic field within ? 

Do not use full-word names for generic types. can be easily misleading, even for an IDE (for example, my IntelliJ automatically imported , which is very confusing). Use single-letter names for generics: , , ... The two methods differ only in conditional branches inside the while loop, but all the other code is redundant. That can be improved. Using Java 8, we can extract the equality condition check and the value change function into the signature of the method: 

"1" is still there, because checks for equivalence for "true" string value. The logic of the entire method can be thus reformulated with improved readability and simplified: 

It may also be seen as an abstract class, because both the implementors might share some similarities (ex. path validation). will be implemented/extended by both or classes. (former ) will decide, depending on the user's input arg, which entity to instantiate: 

vs The call in the block of look really heavy, especially with a single-case matcher. As per Scaladoc, is the same as . In general, is used hugely and easier to read: 

Now, the main part of the thing. We need an object that will hold all the that we know and provide access to them. Let's call it : 

2) Implement instead of creating an instance of from another. Calls of will thus be replaces with 3) Do not check for strict class equality in , but use : 

may also have a constructor taking directly the array of input data as argument. fizzBuzz(args) Three points concerning the modulo divisions and the booleans and . First, the divisors ( or ) must be validated to be different from 0, if you want to avoid . Second, they should be extracted into a dedicated method, which is easier to read: 

Now this map can be filled with the indices, using a single loop and they will be accessible by the references to the respective s: 

The drawback of this approach that I already see is that map will be progressively filled with references to all the resources that were accessed. Emptying this map from time to time would be a solution, but I don't have an idea of the logic of resources handling in your cache. 

The code you posted is rather huge for all-in-one review, so I suggest to make it in more than one iteration. For this first approach, let's cut more general things from details. InteractionMediator Type. It is declared as . Is it intended to be used in matchers or to be tested for equality among different instances? If not, that should not be a case class. Functions. There are really a lot of public s inside. Are they all called from outside or some of them remain callable from within the class? I think that it should be useful to reduce the visibility of some of them. Moreover, these functions do many different things and this makes me doubt that should wrap all this stuff. There are functions to validate details or templates, load them or generate other entities. It looks that a split is necessary: create an entity that will provide validation, another for loading, and yet another for other useful actions. This will be much easier to read, analyze and test. Wizard This class looks like a big mess of s, s, s and directly executed calls. Really difficult to see what is happening there. Reordering, restructuring and splitting are the first things to do about. Some ideas: 

The redundant logical expression seems to be too complex for this case. And there is probably a bug. You say that the expected set of values for it is ("0", "1", "false", "true"), but if value = "2", it will also evaluate to "true": 

Code Improvements I'll remain in original Java-7 style here, but some of the items might be expressed definitely better in functional Java-8 style. Use Interfaces 

Loading the contents of an entire table using Set is very dangerous. First of all, if the table is rather huge (imagine just several dozens of thousands of rows), this object will squatter the memory and probably consume too much of it uselessly. It also duplicates the data supposed to be stored in the DB and produces too much overhead on each object creation by reading all the data. However, reading just the metadata of table columns and their types could have been useful for your problem. and objects are created, but never closed. Initializing them inside a try-with-resources block will solve the issue. , especially in a constructor, looks very ugly. Either replace it with a more concrete exception type or (even better) find a way to avoid the clause for the constructor. There are no validity checks for and arguments. What will happen, for example, if one of them or both are ?