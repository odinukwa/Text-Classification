In the method, the variable name is confusing, I thought it implied the last value of your . I think naming it might be better. Also, it is confusing as why your returns the previous value. You should comment your methods to explain what they do and what they return. Because in this case I might think it would return the new value. The same problem applies to your method, it isn't intuitive to understand that the returned is the new index. Comments should make this a lot clearer :) You should use over in your comparisons. compared the reference value whereas will compare using the override of the type you are using, which leads to less errors. What happens if I have multiple times the same element. Is it intended that you remove only the first instance that is found? 

As pointed in the comments, is a terrible variable name. Don't do that. :p Overall, your variable names need to be reworked. Why is your named ? Why not ? Then again, what does this dictionary hold? It should be named accordingly. It's a set of dynamic properties, or something like that? Name it ! It might be off, but you get the point, good naming is important. You never check your parameters for . You should. This way you'll catch the problem as soon as possible instead of potentially receiving a at some point in your execution. I'm not sure there's a use to your . All it does is hold a dictionary of properties. Why wouldn't you simply use a variable and extract the and methods to helper static methods? Your bracket style doesn't respect C#'s standard. I guess that's not too bad, but you need to be consistent. Use the same bracket style everywhere (Right now your class's brackets are on a different style). Also, you have useless brackets at some place, don't do that. It's confusing and serves no purpose. EX : 

The way you're doing it at the moment is fine, though it creates a bond between and . I'd consider your constructor more like an helper method than a necessity, considering all the properties are (which is very good in the case of a view). You just need to consider if could ever be built from information that wouldn't arrive from a . Now, I've typed this sentence and realized it makes no sense :p Your way is fine. Instead of you should use which has the same behavior but it's clearer! :) Also, in a case like this : Consider using instead of , it shortens the code and it is okay to use in such a case because you can see what is the type of just by looking at the code. 

Read your comment, read your method name. Does it mean the same thing? No it doesn't. In that case, should be or something like that. is a very vague term. should be or something like that. Because right now your method doesn't explain enough. That : 

In your input you ask how much damage should be dealt. There are much more options that are invalid than valid ones. I mean, I can enter but I can't enter any other number, so there are much more chances I face the error message than anything else. If the only options are the values from 0 to a 100 that are multiples of twenty, you should specify it in your message : 

Doing this, you'll be able to work with what you really want : Numbers. Your code will reflect your intent much better this way. 

The big problem I see here is your method name. I'd expect to parse my object to a but that's not exactly what happens, right? Your method tries to parse the input and returns a default value if this doesn't work. Your method name should reflect that sentence. I'd call it or something like that. It kind of follows the trend. Now, there's another problem. Your intention seems to be to cast an to a , but you actually parse the of the object. The point is, as a user of your method, I'd expect this to return the default value : 

That's the final version in my opinion. I think it looks better. Though there's a final problem. and are terrible method names. I know the idea is to copy the Javascript functions, but let's make an exception. These methods names are not intuitive and overall pretty terrible. Maybe something like instead of and instead of would be better names. 

What do you usually expect? An , or that ? The thing is, if a user of your method inputs something, they want exactly that to be done, not a fallback scenario. Let the user know it didn't work, it's better this way. Don't think about recursion, your loop is a very good way to tackle this problem. Recursion has no easy way in this problem I think. I think your solution is very fine. 

I think there's too much comments in your code. The summary xml doc of your property might stay, but I'd remove the part of it, for all your properties. And you should remove the xml on your private fields, since they are private and a copy/paste of your properties. Also you should keep your private fields on top of the class, or close to the property it is linked to, it makes it easier to follow your code. 

It's up to you to decide which solution is the best between the first and the second as they both have advantages and disadvantages, but both of them should be pretty solid! :) 

I don't feel like you should override and . Fine, it makes the syntax cuter, but it makes your code much less readable for someone who isn't you. Remember, you write code so that yourself in 5 years or someone else can read it properly, not so you can feel it better right now. Follow this guideline, and you'll see that your code will be much cleaner. By using the operator, we loose the advantage of the that the has. Following coding conventions, your generic types should be PascalCased. So = and = . You could make your variable . The main purpose is to tell other programmers (or yourself in 5 years) that this variable should never be set somewhere else than at it's declaration. I'm wondering, why is there a at the end of ? Is it a list of view models? Your looks fine, though I feel like there might be a problem when it comes to . Imagine this : 

This way, I (as a client) can know the severity of an inspection, but I can't it, and it is a good thing, since I have absolutely no clue what it should be. 

At the moment, I have mostly tested the non directional weighted graph, so it's the one I'll put for review. I hav removed the header comments from the class/methods as I have multiple classes to show. 

Could be changed to You have some methods that don't respect naming like . It should be PascalCased, so Finally, your header comments should follow conventions. 

The code's indentation is pretty terrible. Keeping a good indentation is the key to keep maintainable code. With any good IDE, you can auto-format your code! Also, considering the naming conventions, your variables should be , not . So . And holds multiple files, so you should pluralize it! You should import the instead of typing all the time. You do this using (if you didn't know already). Instead of having : 

Excuse the method names, your comments aren't very self-explanatory so I did with what I had! Feel free to correct me. Then you can implement your class 

You should never throw an empty exception. Imagine someone uses your code and receives an empty . What happened? How do you debug this? First, you need a message that explains the situation. Second, you should use this constructor : . This way, the exception you throw will contain the real exception, the one that causes problem. This will help debugging your code. 

In the method there is another magic number, I suggest you put it in a constant too. I didn't have time to check the rest of the code, I hope these suggestions will help you out! 

What is the expected output of this? You'd expect the count to be 8. But no, the output is now 2. Because your method changes the . Then again, your method just uses other LINQ extensions to replace . Because the LINQ's already has an overload that takes a . Overall, your methods add an overhead to simple operations that are already done using LINQ. If you want to rewrite LINQ, don't use LINQ. :) 

I wasn't sure about the and , but I thought it was important to split them since if you ever want to make your elevator even more complex (dealing with multiple calls etc..) you'll need to have them splitted. 

The responsability of a controller is to create and return them. This usually imply some boilerplate code, creating new instances, setting parameters, etc.. Then, you need to return the good view, which also leads to some boilerplate code. Your controllers are thin. Very thin I'd say. I think you're searching too far to refactor perfectly fine code. I know, that's a boring answer, so I'll explain why I think it's the best I can do. What are our options? Extract a method to return the good kind of view ( or ) according to the type of the request? But this method would need 2, sometimes 4 parameters to work correctly. At least 2 parameters to define the view to return (The name of the view) and 2 other parameters to verify if the is null and what view to return in that case. That sucks, right? An "helper" method with 4 parameters where 2 are optionals? Nah, let's forget that. Extract the creation of the perhaps? Ok, so I need a , but what are the parameters? The , the , that other string beside the in your service call, sometimes you'd need to pass the parameters to create too, which is 3 more parameters. That leads to a that has 3 to 6 parameters, sometimes optionals, always looking alike. What's common between those refactoring experiments? No reusability, low cohesion, high coupling. So, it's bad. Plus, those two "helper" methods would serve what purpose? To create and to return the good view? If we re-read the first sentence of my answer, that's exactly what the controller is supposed to do! Why would you take their jobs (South Park pun intended)? So, all in all, that code is really good code. Keep it up. As a little side note that might decrease code's length, here's a tip: 

I feel like you're doing a lot of work for a quite simple problem. Using is kind of an expensive operation and you call it a lot. Plus, you don't really need to remove values from your "original" list. Let's try and "translate" your problem into simple lines of code. 

Then you could print the health bar. I don't want to go deep in details but you could write a function like that would print according to the parameters instead of repeating this piece of code every time. All in all you could remove the whole if/else business (except for your input validation, which is important) and have : 

This answer isn't about immutability since @rolfl has it covered. You should put spaces between your in your assignations, it is easier to spot the so it makes it easier to see the assignation. There is lots of white spaces between your getters from , one should be enough otherwise the code takes alot of space for nothing. You have a parameter that is PascalCased instead of camelCased, is it something java specific that makes it impossible to name it ? Otherwise, you should name it.. ! 

as class members, which would make sense. This would also let you inject the dependancies of your logger at one place, instead of having it as a parameter for each of your methods. You didn't specify your access modifier, you should. It's always easier if they're there, this way you don't have to wonder "Did I forget to make it or was intended?" Your Dictionary should be at the top of your class, in order to follow conventions about the file template! Finally, you've made a method for every step of your "workflow" except for the one where you replace your placeholders with actual values. You could argue 2-3 lines of code don't deserve a method, but I think they do! In the best case scenario, you should have something like this in your method (which, btw, would be named something else if it was in an instance class) 

I think you should space your methods, having them one after another like this is hard to read I think. Also, your methods, constructors and indexers are mixed up in your class, I think you should try to group them (not by using regions of course), it would be easier to follow the class. I have nothing else to say, OOP seems good, same thing for the matrix methods themselves. 

becomes o is DateTime Better eh? Finally, most of the comments are kind of useless. Stuff like can be deduced by looking at your code! :) 

I'm not sure there's an impact on the SQL generated query (you should check with the profiler), but it removes a line of code and is in my opinion better! Btw, you shouldn't use here. I can't figure what's the type of because of it. The guideline is to use only when you can figure the type by reading the code, which isn't the case here. 

Edit : I think you should keep your interface as clear as possible. Your contract should define the minimum you need, which is both methods. The other methods, as you mentioned, might not be supported by your logging framework, which means they wouldn't comply to the interface. Also, these methods have a little problem, let me give you an example. If and you call , you have no feedback that the information wasn't logged, which is a problem. I think your method should deal with this, to keep it as simple as possible. Look at the following approach, I think it is an okay way to abstract your logger. 

Maybe I'm missing something, but you never use your variable, you should remove it as it's an unnecessary call to the DB. Also, since you use , you should check at some point if it's . If it shouldn't be ǹullFirst`. 

It is somehow easier to read and respects the coding standards. Try to keep your constants at the top of your file and keep your order consistent. Let's say you have this template : 

I'll answer your second question first! The fact that one of your your checkboxes needs to be checked is a validation that is more about your class than one of your checkbox. I mean, individually, a checkbox doesn't need to be checked, but your model requires one of them to be. Which is why I would put the validation attribute on your class instead of on one of the checkbox. Then, to show your error message on your client HTML you would need to set in your view. For your first questions, there a lot of possibles way to do what you did, but your way is fine I believe. I'll propose another one though. I think you should make another that would only contains your checkboxes. A or something that is more appropriate in your context (that I know nothing about). Then you could use reflection to get all checkboxes and check if one is checked. It would look like this : 

I didn't check your algorithm, but I think the code could use some object-orientation! You shouldn't have a method in the class that holds your algorithm. Use a class, code your there, and keep your clean. 

Now, in my opinion, we have a solid method signature. We can now look into the code of the said method. You define at the top of your method, but do not use it until you assign it again, meaning you could join these two statements and remove 

Note that this answer is far from the best in a OOP point of view, but I think in performance it would be better since you have a O(n) complexity. 

Boolean used in conditions Let's take the following example : . In a proper English sentence, we'd read : 

Then, averaging (sorry if that's not a word) the closing and opening border, we can figure out where is the middle of the hall, so we can start solving it (in an upcoming question). The jagged array is rectangular, meaning that wether we talk about index 0 or 1732, the jagged array will have the same length. Now, it is easy to seek why I need a review. The function works, it is arguably easy to understand. But I can't stand these following loops.. I'm using Java 1.8. I know I'm providing only one method, but I feel like it is already hard to explain briefly and to be clear about the cases. 

I can't help much about performance, but if I remember correctly the JSON.Net maker has a blog post where he explains how he improved the JSON.Net's performance. Otherwise, you can see how he's done with the source code!