Since the non-default constructor is private, specifying is okay for readability reasons. On the other hand, when I see a slew of definitions where only one is needed is a sign to me that the author of the code doesn't know the language and that I should poke deeply into that code during review. 

There's a huge downside. One is that the compiler does not enforce your units. Your type names are aliases. You could pass a variable of type to a function expecting a . The only way to detect this error is via inspection. Your use of units give a false sense of security. Another is that it invites you to create a plethora of units such as , etc. This will get you in trouble. My advice: Except for input and output, stick to strict SI units. No millimeters or kilometers, no minutes or days, no grams or tonnes. Lengths internally are always in meters, time durations are always in seconds, masses are always in kilograms (except for star and planet masses, which are expressed in meters3/seconds2; see $URL$ Another way to look at it is to look at Wolfram Alpha. Dozens, if not hundreds, of human years of development effort went into this product -- and it still messes up with units. You are not going to replicate that effort. Using consistent units throughout is the easiest way to confront the units problem. 

Minor nit: The name is a bit longish. PEP8 says we should keep our lines to less than 80 characters long. Overly long variable names get in the way of that. Returning a flag value (-1) is not very pythonic. More pythonic would be to raise an exception, or to use an existing search mechanism that raises an exception (and then let it pass). Finally, and most importantly, that's a whole lot of typing. What we want is the smallest array index such that the digits after this index are in non-ascending order. This is easy to find. First imagine constructing a list of all of the indices for which . This is easy to do with a generator expression: . The problem with this is we need the last generated element. That's easy to fix: work in reverse order: 

Minor nit: I would have used a different name for this. perhaps. More important is what's missing, which is the docstring. The docstring is how you document what a function does. 

What this means is that defining the move constructor (or the move assignment operator) as deleted implicitly knocks out the other three. All you need is 

Regarding how you are using views There are multiple schools of thought on what "views" are and how they should be implemented. One is that the thing being viewed should know all about the view. Another is that the thing being viewed should know nothing at about the view. Both can be correct. I'll give two concrete examples to illustrate. One example is JSON. There are seven types of JSON values: An object, an array, a string, a number, and the three special values , , and . The two boolean values can obviously be collapsed to one type, and a numerical value can be expanded to two types (floating point or integral). It helps very much to have different views on a value that implement the details. Most reasonable C++ implementations of JSON do exactly that. Since a specific JSON value can be of one and only one of those types, most implementations contains an enum value that indicates the type and a union of views, only one of which is active, the view corresponding to the enum value). The other example is very large multidimensional arrays of numerical data. There are a number of different packages that address this problem, and in a variety of ways. Very few use standard library containers. A is a phenomenally bad idea. Sometimes these arrays are so very large they will not fit into the memory of the largest of computers. Suppose you have found such an array of interest, representing years or even decades of data collected around the globe, but you are only interested in a couple of days worth of data over a tiny portion of the Earth. What you want is a view on that huge array that easily lets you slice and dice that huge array down to a very small size. In this case, the underlying huge array does not need to know that the view even exists. On the other hand, the view needs to know all about that huge array. You have obviously taken the first approach. Whether that is the correct approach depends very much on what you are trying to view and why you are trying to view things that way. 

You didn't show the value you are using for . Given that you used this in the function , I strongly suspect you are doing it wrong. You either shouldn't have called the function or you should have used a different equation. (The correct value for given the expressions you are using is 1.5.) What you should be using to compute the acceleration of a body due to gravitation is along the lines of 

The keyword has been a keyword in C since C99. Use it! Inline functions are a much better option than macros. Macros are beasts from the previous millennium. Let them rest in peace. The function approach is much better than the macro. Editorial comment: It is now 2016. If your compiler is not compliant with C99 (preferably C11), it is time to get a new compiler. 

Almost all of the wall clock time is reading the file. C++ I/O is notoriously slow. If you need to read, parse, and write millions of lines in a couple of seconds I suggest you revert back to C I/O. And don't use . It, too, is slow. Take advantage of the known format of the input file. Read a line. If the second character is you have a . Otherwise you have a . Parse the integer that starts at the character after the , or the fifth character (character position 4). Update It turns out the compiler and standard c++ library makes a big difference. Reporting only the real times (first item from /usr/bin/time), 

Your function and mine have a similar edge case behavior: The name does not quite agree with the return value in the case the input is an integer power of two (or integer power of the base in your case). The docstring should clear document the nature of the return value in these edge cases. Finally, your function does not return the floor of the log base 2. It returns 2floor_log2(n). Renaming it , 

Regarding -- Don't use that. In a professional code review, that is a sign of a rank beginner who has read the wrong books. The standard idiom for an indexed loop in C++ is (in C the increment is written as instead of .) Anytime I see a indexed loop that is not in that form in a code review, I have to wonder why the author did that. 

There is no need for your function. The problem statement does not say to do that. Your is gold-plating. (Aside: Your implementation has flaws.) Replace that 100 line long function with a simple Edit: On second thought, the problem statement does imply that something along the lines of is needed. However, a good programmer will push back on stupid requirements. This is a stupid requirement. There is no need for your two functions. Those two functions represent another big chunk of code, and they use insertion sort. Your first choice for a sort function should almost always be . Unless you have very weird data, will be much faster than a hand-rolled sorting function. Even if you do have very weird data to be sorted, your first thought should be with a custom comparison function. There is no need for your , , and , either. You chose a poor representation. Sorting dates represented in the form is hard. On the other hand, sorting dates represented as a string of the form or an integer whose decimal representation is is trivial. Just use and you will get the correct sort order. Internally, you should have represented your data in some sort of format. Assuming properly formatted user input, converting from a string of the form to a string of the form is a one liner. Converting back to a string of the form is another one liner. This of course assumes perfectly formatted user input; a professional program would care very much about malformed user input. But the problem statement doesn't ask you to check for that. Those checks would be another form of gold plating here. This is C++. In general, one should prefer one of the standard containers over C-style arrays. (This is not the case when doing numerical or scientific programming. But that's not what you are doing here.) In this case, a or would be just right. 

Even after incorporating those very standard coding practices (the statements that follow , , , etc. should be on separate lines and should be enclosed by curly braces), fizz-buzz should be small, even in Java. 

You have provided a non-default constructor. This means the default constructor is not implicitly declared. You also have a data member that is of a reference type. Even if you hadn't provided a non-default constructor, the default constructor would have implicitly defined as deleted. Bottom line: You don't need to say . There's also no need for defining all four of the copy and move constructors and assignment operators as deleted. The very nice capability of defining a special member function as deleted did not exist in older versions of C++. One insteadhad to use the ugly trick of declaring that special member special member function as private but never providing an implementation. You are obviously using C++11 (or perhaps even C++14), so you have this nice capability available (and you are using it). You should also understand the rules by which the compiler implicitly declares and defines special member functions that you have not explicitly declared. 

One advantage of this approach over is that it detects problems early: It raises on most garbage input. Negative numbers, floating point numbers, strings that that contain non-digits, lists, etc. -- they all bomb. That is a good thing in python. On the other hand, you'll get a ValueException at the end when you try to convert a goofy string to an integer. 

The only logic that's left is reading the input. When I run this on my computer, I get timing results of 

It's not surprising that your serial code is faster than your GPU code. You are not taking advantage of the places where GPUs perform exceptionally well, and you are using the GPU in exactly the places where GPUs don't perform well at all. Regarding the former, GPUs are geared toward floating point rather than integer operations, and on arrays where the same computation is performed on every element in the array. You are using integers rather than floating point numbers, and don't have any arrays at all (but you could if you used a sieve). Regarding the latter, two things that GPUs don't do well at at all are integer division/modulus, and atomic operations. You are using both. There are over 7.6 million primes less than 5123, so you are calling on a global variable over 7.6 million times. This alone is a huge bottleneck. 

The above declaration is incorrect. You need to allocate one more character for the null character at the end. You are adding that null character, but you are invoking undefined behavior by not having enough space in the array for that character. 

Specialized to 3D space. Just as you can only tie your shoelaces in 3D space, gravity basically doesn't work in anything but 3+1 space (3 spatial dimensions, 1 time dimension). No call to . Unless you are using Fortran, it's best to avoid . Some compilers such as gcc and clang know how to deal with . Javascript? No chance. And even and don't know how to deal with 3/2. Fortran compilers not only know how to efficiently compute , , they also know how to deal with things like , , and also . Only one division. In fact, you can do even better than what I did. There's no reason to compute the relation between particles j and i when you've already computed the relation be particles i and j. Using mu (μ) rather than G*M. We are taught in elementary physics that Newton's law of gravitation is F=GM1M2/R2. This is correct, but it is also a lie to children. The masses of the Sun, the planets, and anything else to which we humans have sent a probe are computed by dividing the observed gravitational parameter for that object by G. There's a problem here: the Newtonian gravitational constant G is by far the one physical constant that physicists cannot measure very accurately. It's best to avoid G, and there is no reason to use it. Use gravitational parameters instead. (Or treat mass as a derived unit, with base units of length3/time2. Same difference.) Using previous calculations. Your code is doing a lot of repeated calculations, and they are very expensive calculations. When you're doing scientific programming, it's important to pay attention to look out for redundant calculations. It's acceleration, not force. You made two key mistakes with regard to units. One was the calculation . You mislabeled this . This is not a distance function. The other is your calculation of force. Force has units of mass*acceleration. You are clearly using the quantity you calculated as acceleration. When you are doing scientific programming, it's extremely important to get your units right. While getting the units right does not guarantee that you have the physics right, getting the units wrong most certainly does guarantee that you have the physics wrong.