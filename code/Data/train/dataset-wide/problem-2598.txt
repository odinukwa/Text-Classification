Your solution is absolutely correct and practical. In fact also returns empty array under the hood, just slightly in a different way (they have a separate instance holder class that is lazily initialized). 

I'd rather use the and as primary keys, because your logic ensures them to be unique. In case of your current solution you would still require (unique) indexes on these fields (in order for lookups to be efficient) so there is no reason not to use them as primary keys. Given suggest optimization you don't need to check/insert an author record , just use the merge to insert/update the data in the table, and create a separate SP that will do the same job for Authors. 

I suggest to make non-nullable by replacing usages of with a completed task. It will simplify the code as you can always await on this field, and assume it is the "current" task running. You would need to introduce locking in order to synchronize access to the continuation task, and ensure that the is only called when it was a winning bid. Also, you would need a double-checked locking to ensure that your task is the winner: 

I'm sure this could be optimized even more, but this answer was meant only to illustrate the use of to minimize the amount of code that has to be written. In this case, using just one single function with some prepared data greatly reduces the amount of data that's necessary. Further optimizations would be to use objects instead of just plain arrays to associate the data. 

Generally, when you free something, it's a good idea to null out the pointer afterwards. While in a program this small, you'd be unlikely to make a mistake, when you null a pointer, most platforms will terminate the program rather than have potentially undefined behavior from a dangling pointer if you accidentally reuse it. You should get in the habit of doing this. There is a function called realloc that performs a malloc/memcpy/free cycle for you on your behalf. Some platforms can also resize the memory without moving it (assuming enough contiguous space exists after the allocated memory), which can be a performance benefit. You should use realloc instead of malloc/memcpy/free, because it will always be at least as fast, and often faster. That said, your code appears to be free of memory leaks, accessing invalid memory, buffer overflows, etc. There's a lot of minor optimizations that could be recommended, but this code is at least logically sound. 

The best way to answer this question is to measure the performance and see if it satisfies you. If not - then start thinking about caching results and refreshing them instead of calculating from scratch. 

You have put too many responsibilities in a single interface and class. Your interface knows not only about graph itself, but also about all the possible methods of traversing this graph. It breaks Single-responsibility principle, Open/closed principle (as you'll have to edit if you want to add more search methods) and Interface segregation principle. What you should do is refactor your interface and implementation so that: 

If you want to write tests for this helper class only - they would be integration tests since they touch the file system. In order to make the code unit testable you need to make it independent from hardware and physical interaction with network or disk. If you want to unit test the business logic that uses this , then you should introduce Inversion of Control to separate business logic from file activities. You'll have to create an interface that describes all operations you can do with files, transform this static helper class into class implementing that interface, and reference file operations from business logic via interface only. Example of file helper: 

Avoid Hard-Coding Values should validate the level range. In a real game engine, you'd probably have files in a data folder instead of hard-coding the levels within the source code. For example, you might have files that look like this: 

I'd rather prefer the first method, as you can then add/remove elements in your HTML without having to refactor code. There's plenty of other ways you could do this dynamically, including using to bind to a parent element and then determine which element was clicked. 

This final version, $URL$ works the same as the original code, using just 35 lines of code. Included here is the JS code. 

Load From Data Files Instead of Source Code Once the user selects a valid level, you can then have the function start by loading the level, when repeatedly drawing the map and polling user input until they win: 

Not sure I would ever do smth like this for my own production, but here is the code that (IMHO) would clean things up... Implementation of MyListView: 

Alternative way (how most applications works) is to rely on a business logic inside client application to enforce business rules. It's much easier (and straightforward) to verify that your parent is of a valid type. Also, based on your table I think each type of "posts" should be different enough to store it in its own table. In that case the whole story of validating types is gone, and all the validation will be done by foreign keys. 

When using one of the ORMs mentioned above you will have a notion of "session" (NHibernate) or context (Entity Framework). Both terms refer to the same concept of unit-of-work + repository. These objects are very cheap to create, so usually you create one (sometimes more) session/context per form, and don't share them between forms. 

Using method will have an side-effect if is modified. This is because arrays are passed by reference, and so any changes to will be visible to the caller when the function returns. Use if you need to manipulate id or name, unless you intend to return the modifications to the caller. Example: 

Using this design means that you could literally edit levels into the data folder and have them appear when the menu is displayed, and offer (potentially) unlimited levels. Since we're talking about C++, the files could be simple, something like: 

Under the covers, each matching element will get its own closure, and therefore operate correctly. I'm assuming in this code that one div is contained within the other (there's no HTML here). It's pretty trivial to use other methods, such as finding siblings, etc. In an absolutely worst-case scenario, you can use data attributes on the clickable element to target other named elements, or you could make a named map: 

The code itself looks good, but I would look into providing a single way of subscribing to events, it will make the job easier for other developers reading and changing the code. The first method of subscribing (via injection) requires subscriber object to be created first, so it may not receive all events that you may expect it to receive. Every time you create an instance of subscriber it adds a new event subscription thus causing potential memory leaks and side effects. You might need to add method to if you prefer to leave it. Second method (the one I would prefer) is better suited for application-wide events since it moves the responsibility of subscription to the infrastructure thus avoiding multiple subscriptions and memory leaks (comparing to first option). It is also easier to unit-test since part of responsibilities are taken away from subscriber. Update based on question update: Publishing messages also looks good. In this case (following my suggestion to leave only second method of event subscription) I would remove method from declaration, and refactor it to non-generic interface with generic method . 

This final version allows new .toggleable elements to be added to #parent on the fly, and they will also react correctly (assuming they are styled, loaded into assoc, etc). 

One file per level still applies, though, as it will reduce loading time and memory usage (not that either is significant in a game this small, but the principle is important). 

This design violates first normal form, which is a concept that states that each data field should contain an atomic value (using type and ID together makes this a composite value). This makes certain types of queries more difficult, and you'll use more database space and suffer query performance. Store the type in one column, and the ID in another. If you have many tables, you might consider breaking it out so each module type has a corresponding "likes" table (e.g. and . This uses significantly less space and makes maintenance easier, but makes some queries harder (such as "show me all my likes"). Using a single-table notation is acceptable, but by breaking the type and ID out, you can use an and an instead of a , which will improve query speed on full-table scans, and use less space on disk. 

Other than that encryption/decryption looks properly implemented, and I completely agree with original code writer that initialization/duplicate steps should be taken to constructor. It will reduce the number of parameters in Encrypt/Decrypt methods to one - actual payload. Depending on your specifics you can also expose methods accepting and returning encrypting/decrypting streams for large encryption volumes if necessary. 

Your task falls into ETL (Extract-Tranform-Load) category, and SQL Server Integration Services (SSIS) is the service dedicated to ETL. You can actually implement all the processing described here using the SSIS package (next version of DTS), at it might result in faster and more reliable solution because SSIS uses stream-based processing and optimised interaction with SQL Server. If you still want to use .NET app to do the transfer then suggestion will vary depending on how much data do you need to transfer, and how likely you would need to maintain this solution in the future. 

Of course, you could instead use std::swap. However, given all the alternatives, if performance was a non-issue (e.g. absolute clock cycle count was unimportant), I'd impress simply using std::min and std::max. 

Which basically moves all of your if-else logic into standard library calls. By the way, a popular method for switching numbers in place without a temporary integer goes as follows: 

Where 's' is the starting point, 'e' is the goal, and # are the walls (basically, similar to the format you have now). I'd also include a title, but that's a personal preference. In this case, I'd read the first line from each file while displaying the menu. Alternatively, to avoid reading tons of files, you might just have an "idx" (index) file (e.g. levels.idx) that contains some format, like: