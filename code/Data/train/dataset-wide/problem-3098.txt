Simply use EntityViews like in Svelto. This concept was introduced with that framework. And I really love it. Most ECS frameworks have this dull concept that Components are coupled with engines and every engine should loop all components of a certain type. They should not! Both for flexibility and performance issues! (there are even technical articles from AAA industries that use tricks like skipping updating Systems every X frames because they were basically looping too much). Everything in Svelto is decoupled. Most ECS frameworks have this concept: 

the ObstacleAvoidanceView could be something similiar to (assuming the avoidance is done using a circle or a sphere): 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

This is deeply different. Basically you can select which engines process which entities without having to resort to specialized components or without resorting to usage of Tags or groups. Basically when you spawn an entity, you have to select in advance which engines will see that entity. You can change that at any time by updating EntityViews in its descriptor, if there are missing components a nice error message will tell you that (I think you can implement that at compile time with C++, I done something similiar in past). Basically you may have X entities in your game that have a Position component, but you don't want to process your position the same, so in example static objects should not even have Systems updating them, so they could just have a method that returns the position without allowing to change it (that method does not implement any logic it just returns data). 

This is my first real adventure in writing a thread-safe class. With the above notes taken into account, did I screw anything up in a way that might violate my thread-safe claim or am I performing any unncessary operations? Code: 

Edit: Dunno what PCG is and don't want to read the paper? Maybe this video of Melissa O'Neill (the author) explaining things will be palatable instead. Original: I attempted to answer this question last week and was thrown off when someone mentioned in a comment that my method would show bias. Eager to prove the naysayer wrong I discovered that things were even worse than he suggested as certain ranges will cause things to break down entirely. So I decided to start from scratch, do some more research, and try again. Performance was also much more important to me this time around so I decided to try and find a way to avoid calling to generate every single value. Eventually I settled on PCG as an appropriate modern algorithm. Floating point math has also been entirely avoided while working with integers in order to avoid the sorts of issues I encountered in my previous attempts. Looking for potential ways to speed things up or simplify the code; the branch statements bother me quite a bit but can't envision a better way to include the full range of values without them (the upper bound cannot be generated by the method). Haven't been able to find any bugs so far but that doesn't mean they're not lurking either... 

You have to write a complete parser (a simple one, but too complex for becoming a single answer) to avoid these issues. You can know if you have done everything correctly luckily: 

Let's me make a premise, I'm actually a consultant, helping a small indie team of quitting dependency hell, I'm basically re-writing a small game (30k lines of code). Turning it into a full-fledged ECS game. And I'm using an already existing ECS framework, not a mine framework. Explaining it is the most difficult part. I'm actually learning new things with every-day problems I face, so I'm not speaking to you as "expert", but as person that is learning. Sometimes I ask questions to the author of the framework I use and he is very willingly to help me and find better solutions to certain problems. Believe me, I come from a C++ programming background, so I always struggled to make my custom engine, dealing with allocation etc. I even started a 3D engine once, I would never do that again. What you are trying to achieve already however: 

This allows you to implement entities in C++ directly (prefer always this, even though direct memory addressing of C++ allows you to do dirty things) 

One could get doubles for RGB by using a provider that returns at least 24 bits (such as ) combined with some altered sampling logic: 

There are an infinite number of ways to do this but one possible approach would be to use a dedicated hash function to compress your inputs; out of sheer laziness and convenience I chose to use the built-in for my example. To improve the performance characteristics of your code I hoisted the construction of the hashing class up a level and use so that we only have to instantiate it once per call instead of once per string. I then chose to sample the first three bytes of the hash result in order to come up with values for , , and . 

If you're going to spend the time abstracting things then you probably want to invest some effort in refactoring a lot of your common logic into helper functions. Starting with the very first issue, a hard-coded connection string, we can create a function that'll build one out of components: 

Finally, we can add some helper methods to simplify the creation of commands, execution of SQL, and retrieval of single values: 

By taking advantage of the operation and avoiding the use of and (as suggested by the great answers provided so far) I have come up with a version that avoids having two different algorithms. I was really thrilled by the elegance of the answer given by @t3chb0t but, unfortunately, the state machine turns out to be roughly 5x slower even when I replace the calls with more efficient code. I also loved the thoroughness of the response by @Hosch250 as it gave me the idea that I could collapse the two algorithms into one and a solid foundation to work with. There are some gymnastics being performed in the variable assignment in order to handle the loop direction and but other than that this feels far less "evil" than the original and it performs twice as fast to boot! 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

Over the weekend this article inspired me to write an ASCII string implementation that avoids memory allocation during basic operations like and . It's still a work-in-progress but I think this is a solid foundation to build off of and wanted some help checking my logic/maths. The main method of interest is the overload of that accepts an offset and a count since most other methods are implemented by calling it. 

I believe one can avoid the bias problem by generating a random float between [0..1) and then normalizing the value between x and y instead of clamping: 

I also went ahead and hoisted up the into a static field since there's no real security benefit gained by allocating a new one on every call. Usage in your current function is straightforward: 

Updates: I have refactored class based on a combination of all of the feedback here, on the linked question, and a lot of benchmark results. The current implementation has been split into and and drastically simplified from the original; a change I didn't like when first suggested to me but experimentation proved it to be superior in the end. The compile-time safety suggestions ended up being ignored simply because the original requirement was for based access and one can always add such a helper via a simple extension. Now, about performance. I was quite surprised when I loaded everything up and learned that @MarcGravell's implementation was roughly 4x faster than my own; I knew he'd win but I was shamed to lose THAT badly. It turns out that there were a lot of little details that were getting in the way. I believed that one huge advantage he might have is that he's emitting IL to build a delegate while I was using expressions and so I spent the time figuring out how to emit the IL I needed. The problem? Once finished I only gained maybe 5 ns, he was beating me by at least 20 times that amount! This is when I learned that the slowest part of the entire process is not executing the delegate but extracting it from the cache. I was using and wow is it slow! Really slow, even calling is at least 3 times slower than the normal class. Don't just take my word for it either as others have documented the same experience and I suppose it's not surprising giving the promises that the class has to fulfill. What surprised me more however is that itself is quite slow when compared to the pattern of . Anyways, I was able to refine enough edges and end up with a property accessor that is consistently 3ns or so faster than FastMember. If my math and analysis of our code is correct then this delta is purely a result of the fact that he has a cast to in his IL and I do not. The cast to object allows him to have a single point of entry and exit via a lovely indexer which I was forced to leave out because I wasn't clever enough to find a way to have my cake and eat it too. Benchmark Results: 

Please, resist the temptation to write your own ECS system, I've been in you and it is a no-go. But if you have to do so, do it right! 

The ECS paradigm emerges as a tool as long as you think your logic in a modular and decoupled way. I think you should seriously take a tour into Svelto.ECS (beware, its author renamed "Systems" into "Engines", I believe to avoid confusion with c#'s namespace "System" from .NET), written in C#. To do that you have to drive away from most of ECS articles you find on the web, I'm sad to say that, because I tried to use ECS "the old way" and it simply didn't worked well, it forced use of anti-patterns and made me wasting time. Most ECS frameworks, don't scale. You start easy and when the project becomes big you enter dependency hell, but you don't realize that because the dependency is hidden by components. With Svelto you just need to start, it seems hard (well it is a change of paradigm afterall), but after you get the first 10 engines done you realize how easy and flexible it is. 

but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic).