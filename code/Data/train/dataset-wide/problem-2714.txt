What's up with this member function? It seems like this method is provided only so that you can shove a new set of points into an existing object. But it doesn't really make sense to have a without a point-set; in fact you already provide a constructor 

Your code doesn't compile at all, for many different reasons. For example, you try to use functions and that don't exist in the current context (maybe you meant and ?); you refer to both and ; you try to use without including the appropriate header; and so on and so forth. Next time, you should fix all compilation errors before posting to CodeReview; you'll get better (well, more targeted) answers that way. And certainly the answerers will enjoy themselves more. 

You asked, "How should I factor out a parent class, so that CapSwitch and SimpleSwitch can inherit from some sort of GeneralPurposeSwitch?" — but don't you already know how to do that? 

Your use of curly-braces for initialization of (with things-that-aren't-vector-elements) is problematic. Consider: 

instead of the function? There are valid reasons you might not want to in production code (for example, the append-only version has better efficiency and atomicity, if you do it right — which is not to say that you have), but if your goal is just to make a readable and sensible toy guess-the-number program, personally I'd go with the load/save dichotomy in place of the load/append dichotomy. 

I don't really see why you want all these intermediate entities, if the underlying data structure is simply a . If it were me, I'd probably just write a single function 

Now there's only two lookups. — You might say "only one lookup", but look again and notice (as I missed the first time I wrote this code) that is only ever called with as the hint! So using here is exactly as inefficient as using unhinted . A really good static analysis tool might have caught this bug of mine. So let's do this instead: 

Performance nitpick: I've heard that it is useful to put one cache-line's worth of padding in between your two atomic variables, to eliminate false sharing. Of course if you do that then your class gets much bigger. But if you don't do that, then all this fiddling with memory orders is useless, because your few accesses to the shared cache line in and will effectively all your accesses in those functions. As usual, I advise staying away from memory orders unless you're sure that you know what you're doing. That said, I think you're using them correctly here. 

Having hidden the implementation details and from the reader, we are now free — if we so desire — to replace them with things that are 

I see more than one of the same — that's a red flag, because often the reason we're forwarding is so that someone else can move its guts out, at which point any further use of the moved-from could trigger unintended behavior. Let's take a closer look. The two appearances of are okay, because they're on separate (disjoint) codepaths. The three appearances of are scary. Let's see... the first appearance is the argument to , which always takes its argument by , so there's no bug there — but the use of is redundant and thus a bad idea. The second appearance is as an argument to , which means you're forwarding to a user-defined comparator. This could definitely trash the value of , depending on the user-defined comparator's code. I can't think of any really plausible argument-trashing comparator, but just for the proof of concept: 

Jerry Coffin's answer finally piqued my interest enough to look into it. My first observation is that you can't meaningfully compare a program that does in its inner loop to a program that doesn't produce any output. :) Adding to Jerry's inner loop (inside the ) slows it down from 0.197s to 3.520s, which is at least of the same general order of magnitude as my original program. 

Are you at all worried that returns a completely different map from , even though I might have a and a such that ? 

Looks good to me. As you probably know, there's no point building a "list abstraction" in Python, since Python already has lists that work perfectly fine. You're "building a list out of lists", which is a pessimization. However, as a learning exercise, it's fine. Your function is what computer people call (a term inherited from the Lisp programming language). Also from Lisp, your is usually known as (or ) and your is usually known as (or ). In Python, it would be more idiomatic to do this exercise using as the underlying type of a cons cell, not : 

Probably not. We don't want to give the user the ability to modify or reorder the heap's elements on the fly; that could break the heap invariant. 

When you say this queue doesn't support multiple "writers", what do you mean? Do you mean multiple producers? Because both pushing (producing) and popping (consuming) from a queue are mutative ("writing") operations. And if you don't support the scenario of "one writer pushing items and one writer popping them", then you can't really call it a concurrent queue at all. So I'm going to assume that you meant to support "one producer, one consumer"... and then I'll show where the bug is with that scenario. 

What you've written does work, and you seem to understand all the concepts (e.g., "you can't partially specialize function templates"), and your coding style (indentation and whatnot) seems fine. 

which are nevertheless longer (in terms of number of assembly instructions) than the more "naïve" 64-bit version. Writing an appropriate benchmark for the various possibilities, and writing out the permutation matrices for and , are left as exercises for the interested reader. It would also be supremely interesting to feed these "rotation-permutation" functions to a superoptimizer and see what it produces. However, my wild-ass guess is that the optimal instruction sequence is in excess of 40 instructions, which would (I think) make it intractable for the current state-of-the-art in superoptimizers. But I could be wrong. Anyway, if you find out, it would be interesting to post the results here. 

is 0, and is 10, and there's no synchronization to worry about here (no locks, no s), so we can definitely say that is invariably false. Thus reduces to 

so I'm not sure why you're spending four lines to say basically the same thing. (And the comments aren't adding anything. Kill them.) 

And as Loki said above: don't index vectors from 1. That's incorrect, and will bite you many times if you try to maintain your code for a year or more. (For throwaway code, you could probably get away with it, because there's no maintainer to confuse.) 

Your use of global variables (lots of them) is a problem. Try to move them into the scopes of the functions that use them, instead of exposing them to the entire program. Again I spent a few seconds staring at a line of code wondering if something was missing: 

in your future, unless you take steps now to eliminate those redundant fields. Remember Murphy's Law: Whatever can go wrong, will go wrong. So if you don't want anything to go wrong, you should try really hard to eliminate any element of the system that can go wrong. 

And of course you have no guarantee that the compiler's struct layout algorithm is equivalent to the one you've written. It almost certainly is (modulo base classes, vptrs, bitfields, and most importantly the fact that the compiler can reorder public and private data members)... but technically you have no portable way to know that. 

At this point the code is simple enough that you don't even really need the function anymore! If you're concerned about efficiency, and you have the power to change your input file format, consider switching to single-character flags and fixed-width fields so that you don't need to or your lines. 

Iostreams are slow; don't use if you care about micro-optimizing performance. — But in fact you shouldn't be printing output from within your parsing function anyway! Let's just have the parsing function return the map of headers. Also, your variable names seem confused. I'd try to make each extracted string run from to , since that's how we usually talk about things in English. So: 

Any time I see a global constant string like , that's a code smell. (Especially such a specific string: I immediately smell that it is probably used in only one place.) So I looked a bit closer and found that it was used in only one place, in the constructor: 

The advantage of this organization is that we've put the module boundary at a natural place: the module is now concerned solely with getting the data for a particular month. The notion of "searching a tree" is encapsulated into it as an implementation detail, one that the user of the module doesn't have to worry about. Nor does the compiler have to worry about it, because we're no longer passing a across the module boundary; the compiler is free to inline and optimize our use of the now- data structure. And we're free to change the internal implementation of ; if profiling proves that a linear search in a lookup table would be faster, then we can make that change, without even requiring the client to recompile their module. Using your old code, they'd have to not only recompile , but rewrite it, unless you went out of your way to reuse the same interface. (And a good engineer would also want to rename , since it would then no longer be using an AVL tree. That's a lot of needless code-shoveling, which we could have avoided by using the right abstractions from the beginning.) 

I'm also now vaguely worried about exception-safety. The good news is that node handles are fundamentally memory-leak-proof; if you destroy a node handle without inserting it anywhere, then the destructor frees the node (and its contents) for you. The worrisome news is that can definitely throw (most obviously, if resp. throws), and it wouldn't surprise me if could throw too. Do we need to do anything special to deal with exceptions here? I think the answer is "no, we get the basic exception guarantee that nothing will go horribly wrong as long as you don't try to use those iterators again," but I haven't formally explored it. 

Functionality suggestion: Consider providing a way for a writer to atomically demote itself to a reader, without releasing the lock (i.e., without allowing some other writer B to sneak in and change the value that A just wrote). This should be possible, I think; and it's definitely not possible for anyone but you, the author of the mutex, to provide this functionality. I think it's as simple as this: 

This (a function that blocks, but only for 1 second) is weird and dangerous. Don't do this. If you want a function, write one. If you want a function (that can fail if the queue is empty), write one. If you want a function (that can fail by timing out), write one. But what you did was 

After Harald's questions, it occurred to me that I could have done it with a plain old mutex instead of all the lock-free stuff. But if I do it this way, then it starts to look like "blocking". I think it's fine — this use of a mutex isn't any more harmful than the use of a mutex in the innards of / in the first place — but in a strange way I'm finding it harder to reason about this new version than about the version in the question.