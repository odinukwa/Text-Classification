If you do decide to make it a recursion, the overload of the method with the internal should be . does not actually get neighbours, it gets neighbours' values, and should be named . Don't iterate over values using - iterate over the values: 

There is no reason for your to be , or to be disposed of after every usage - simply put it as a member of your classes. As an added bonus for this, you can declare the table name on the instance, so you don't have to repeat it: 

Of course, a better solution would be not to assume that you know either the username or the password at compile time, and use an external repository to hold this information (even the properties file itself could be it, as @chillworld suggested). String concatenation Using a variable to collect all the lines in your code is not a good idea, as it results in a lot of new objects being built. A is a better type to do that, but in your situation. Close your resources You open a file reader, and then a file writer, but you never them! This is very problematic, since you leave open file handles which may result in a serious memory leak. It is true that java will close all open handles when the process exits, but you should never count on that! Don't catch what you can't handle You have a block, and two clauses, which do nothing but output the exception to the console. A better way would be to declare , and not even write the block. This way, in case of an error, not only will its stack trace be printed in the console (via the error stream), but the console will also be notifies that the command ended abnormally, and the command users will be able to refer to that (looking at the ). 

This is, of course, a bare bones implementation, and should probably be developed further (you can see implementation here), but it enables you to treat private strings like any other string, and only address it as private when needed. 

Method comments vs. naming When the method and parameters are well names, in 9 out of 10 cases, the comment above the method is redundant. For example, - if you call and the comment above the method simply says the same thing as the method signature. Twice. Be consistent and precise , but as well... this is a very surprising result, and might result in inconsistent results. When you get to the case you throw an Exception which states that either or are illegal, although you know that is the illegal one, since you don't even check if is an operator. Magic Constants I find that is much more descriptive than . These kind of constants add unnecessary ambiguity to your code, as they force the reader to go and check their actual value. If you do decide to use a constant, I would suggest a single constant , which will result in these methods: 

So, we could break it down to 4 classes (with inheritance) - , , , . contains the functionality that is relevant to both and (like having texture), and the is used to decide which shape to draw. 

Most of your code is duplicated, what I did is extract the logic to the first code block, and left only the placeholders in the HTML. 

There are a few major differences between what I understand from your code and what I understand from the post you mention. Inheritance vs Nesting Your code suggests that there is a subclass for each tested method, although the post talks about nested classes: 

Or you could use an extension method, which will result in a cool usage syntax, and make clear from where you are extracting the : 

Of course, as @chillworld suggested, both are wrong, as you should check that there is exactly one argument so: 

This is looking more and more like a getter function, and really, since it calls for the state of the instance, you don't need to imply there is ever a calculation, simply call it : 

This ugly code is needed, because inside the loop you don't know when the last element is reached. Ruby already solved this problem with : 

Random access and performance Flambino has correctly remarked that performance is no issue with any container holding a 3x3 matrix, but for the sake of argument, let's say that it might be an issue. A major benefit in a structure is that it keeps a \$O(1)\$ complexity in setting as well as fetching elements in it, no matter how large it is (as long as the hashing function is well thought of). This is what is called "Random Access". An on the other hand has... Random access as well! That is, as long as you know where your item is, reaching that item is done immediately. In actuality, small hashes with a fixed number of elements will always be less performant than arrays, since the hashing function will be much too generic, and since hashes are implemented using buckets (some variants of a tree structure) which are kept in an array... I guess when you said "faster look-up" you might have meant using less code, or maybe having a structure closer to the human metaphor (human player enters ...) - both are debatable, but from a performance point-of-view it is quite clear cut - there is no reason to work with a for the board state - an array (or a two-dimensional array) will be your best option. Class names and motivations Flambino has noted that the prefix is not advisable, and should be removed. Class names should be of actors and not of actions - this is extra obvious after removing the prefix of the class names - and are better names than and . Both of those classes look suspiciously specific, which should make us think are they really class-worthy? Shouldn't the class simply be a method within the class? After all - it is used only once, and you even chose to omit its implementation, since it is trivial... Also, it seems that is an elaborate class intended to maintain the state of the board, I believe that it should either be part of the board's state, or simply make the calculation ad-hoc on the fly. Oh, and forgotten - what does do? Does it do anything? Is it really class worthy? Method boundaries A method should do exactly what it claims it does. For example - looks innocent enough, since it calls , and breaks if , but actually plays the computer's turn! This is unpredictable and confusing. should do just that - check whether the game is over. Any other logic should be done elsewhere. Where is your strategy? In the title of the post you put at center stage that "computer should not lose" - which means that the point of the exercise is to showcase the strategy for playing . But your strategy code is strewn all over the code (some in , some in , and some in ) - that it is impossible to understand in one reading what your strategy actually is. From all the classes you decided to implement, that one most obviously missing is the class (you could call it , as it stands as complement to the human player against it). It should know (or, at least, claim) which are the best cells, decide to score playable cells by (which, I admit, I couldn't thoroughly understand), and, of course, decide which is the next cell the CPU player should play. Be DRY You class is full of cut-and-paste code. This makes it hard to read, and hard to maintain. 

DRY your code In every place where you used copy+paste - you should check whether you could refactor it to re-use the code you've written. Aside from making the code shorter and easier on the eyes, it also makes it more maintainable, as if you need to fix something, you don't need to fix it for every copy of the code. @Simon already addressed the Polymorphism of the classes, but it is not all about OOP, for example, to prompt the user for the second fraction, you've copied the code from the first fraction. Your error handling there is also copied from one prompt to another - since you stop the program after each failure, you don't need to catch each one in flow - one catch at the end of the prompting it enough: 

Consistent style You kind of mixing your styles with curly braces - your indentation is inconsistent, and for two duplicate s with single statement you once omit the braces, and on the other not. Choose a style, and stick to it - it will make your code more readable Magic numbers You made a curious choice to omit the from you start and end indicators, which made you add the mysterious to your calculation. This is a major maintenance issue, since tomorrow you will want to extract with unescaped text, where the will be reduced to , and your code will stop working... Use the powers of the tools at hand Your solution could be much simpler if you used to solve it: 

Proprietary indentation convention For some reason the first line in every method in your code is blank. This might be consistent, but since I haven't seen it anywhere else, I find it breaks the read flow, and makes your code less readable. Use of deprecated code Deprecation warnings are there for a reason - what they actually say is that "this may not work in next versions of this library - be warned, change this as soon as you can". Deprecation warning also generally come with an alternative API you should use, in the case of - it suggests you use Page.getWebBrowser() instead. Naming conventions Generally, your method names are OK, but, for some reason, you've decided to uppercase the first letter in ... it should start with lowercase, like the other methods. Use static methods explicitly To make sure your reader understand where your code lies, it is preferable that you call static methods in a fully qualified way - . This way it is obvious that the method is static, and it not part of the current instance. Missing code Since your code is missing all database-related parts, it is hard to tell whether this design is sound or not... perhaps you would like to revisit us after you complete that part. 

Too Many Classes Contrary to languages like Java or C#, Ruby is not statically typed, but rather duck typed, which means that you can pass any type anywhere, and the objects don't have to inherit from the same base class. For example, the class adds no functionality, and it is not used anywhere in the code besides being inherited by a bunch of classes. It is totally redundant, and deleting it will not affect the code. Furthermore, and don't contain any intrinsic functionality, and according to ruby's idioms, a better solution would be to simply pass symbols ( and ) rather than classes. The last token () holds the current value, but you can even skip that, simply passing the value itself instead. This will make the token iteration look like this: 

You've built quite the object-oriented structure for this quite procedural assignment. Two of your classes are simple structures, which, I argue, are not even needed: contains a and a , but nowhere are both needed - all the outer loop cares about is the position, which it can simply iterate over (from to ) without caring about at all. Given position ( and ), the class doesn't need the object, since it knows where it is, and can simply get the value, so you might as well hold within your grid a two-dimensional array of values rather than cells. You chose to implement as a recursion, which is a curious choice. Why not simply iterate 4 steps in the required direction? Some other minor ticks: 

Either counts on the helper - in which case a will occur and fail the test, or Does not need the helper, in which case there is no need to mock it... 

Inheritance and static members You are asking about efficiency in inheriting properties. I don't know what do you mean by "efficiently inheriting", but static members are not really inherited, you simply get some allowance from calling them in the inherited class...