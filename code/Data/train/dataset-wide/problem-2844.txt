, , , and are only defined if can represent the ratio, and indeed on my system they are not defined. Is there a way for me to detect when those types are defined on the system so that I can provide conversions for those types yet avoid compiler errors when they are not defined? Eventually I plan to expand this library to support additional types, not just . Are there any issues with this design which will cause problems when I add this support? The SI symbol for "micro" is really "µ" but I'm using "u" for simplicity (and since the character type of is ). Since I plan to expand this library for wider character types, is it possible to determine if "µ" can be represented properly for a given character type? 

Note that it's better to use instead of to check if a character is whitespace. If you need to count how many times each character occurs in the string, simply replace with a which maps each character to the number of times it occurs (as shown in @TobySpeight's answer). 

You have an interesting implementation. I like your approach into making it "boundless" (that it could expand as-needed). I also like how you use "streams" to compute the values lazily. And some other minor gems. There are of course some things that you could consider in order to make the design better. 1. Separation of Concerns The most important thing I would do is to keep the parsing and the formatting separate from the "game". For me, these two concerns should be external to both your internal representation (a set of tuples) and logic. For example I would have an object (or a class) and , each with one method to respectively parse and produce a "formatted" string-representation of your object. (Why not just leave the formatting to ? In my opinion is not there to produce complex formatting, much less "parametrised" formatting (as the "living" and "dead" chars are carried around only for this purpose) but to have an useful, but minimal, string-representation of one object instance. The way I see it, is for the developer, not the end-user. Note that for this reason implementations often "cut" or "summarize" the contents of the object. It gives you an idea of what the object is about). You could, then have the same symmetry we see in JSON serializers. There we find readers and writers. You could have something like: 

It's a shorter name for the container. This comes in handy when referring to the container and/or its , for example: is shorter and easier to read than . It's easier to change the container. You may decide later to use a instead, in which case you only need to modify the statement rather than all instances of . 

I frequently design classes which model an object that has multiple submodules of the same type. For example, I have a class for a Printed Circuit Board (PCB) which has multiple subcircuits (I will call them "ports"). The class for the PCB () uses a container (e.g. ) as a member variable to store the subcircuits. Client code needs to be able to iterate over the ports to query the state of each port, control the port, etc, so I need to provide iterators for the ports. In general the board may have multiple subcircuits of different types (and therefore multiple member containers that need to be iterated over). For example, the class might have a for the ports, a for a data bus of voltage signals, etc. Thus I cannot simply provide and member functions -- I would need to call them something like and to differentiate the container of objects from other member containers. Such non-standard names would prevent me from using range-based for loops (which depend on functions named and ). I searched around on Software Engineering SE and Stack Overflow to see if there was a standard solution for this, and I found a couple of interesting suggestions to create a container class that privately inherits from the appropriate standard container (e.g. here and here) and makes the accessor functions like public. However, this seems to go against advice to favor composition over inheritance (e.g. here and here) when composition is possible. Below is a solution for a class that has multiple objects stored in a container called that uses composition instead of inheritance. and are simplified from the actual code, and for this review I'd like to focus mainly on the container class and the related accessor functions for it in . (Note that the first port is numbered 1, not 0, since that's how the ports are numbered on the physical board's schematic.) Board.h 

Once you extracted the parsing and formatting to external functions, you could further simplify their parameters. I introduced this case class: 

5. Case-class or not? To close I want to address another question you had, which I will paraphrase as this: 

The decision is subtle, probably personal, and we enter in philosophical arena. There is of course nothing wrong for this to be a case-class. But personally, in this case, I would not make it so. This is the criteria I use to decide if to make it a case class or not: Case class if: 

Which would only need to be defined once in your main method, and passed as parameter to both parser and formatter (if so inclined, you could go one step further and dictate this to be an implicit parameter). I think just these changes so far would make your design simpler, separate concerns better and let your main class have less parameters. 2. The parsing But you also mention that you are not happy with the implementation of your parser. What do you think of this? 

For the conversions, is intended to be specialized by users if desired for specific time periods. Here is a little demo program demonstrating the conversions and a specialization of for a time period corresponding to a day: 

Not only is this an opportunity to refactor that code into a function, but the numbers and (arguments to here) appear multiple times in your code with the same purpose. Instead, define a constant (e.g. ) and use that constant. This means that if you ever want to change that value you'd only have to change the value of that constant once (the value of the ) instead of trying to find the literal all over your program. Use meaningful comments Your functions are commented as so: 

While it's a good idea to provide documentation on the parameters for your functions, these comments as is are not helpful. They just take up space and are distracting -- after all, I can see the names of the parameters just a few lines below the comments. Instead of simply listing the parameter name, provide some explanation of what values it is allowed to take (e.g. should be between 1 and 12, inclusive), what happens if the parameter value is not valid, etc. 

It is longer and more verbose. Yet it does the same. I tend to favour longer, more verbose code, but not to the point where meaning is lost. 4. Other Points There are some other improvements that I want to mention, which could also be considered: 

Which now only the parser and formatter need to be concerned about. We could then change the function signatures to: 

3. Formatting It would seem that my code is less functional, less Scala-idiomatic, less fancy, more boring and more Java-esque. And, you would be right! It is a matter of personal preference. My top priority when I write code is for it to be as readable as possible. For me, code which is obvious to the point of being boring is something positive. But that's just me. For example, and in case it serves any purpose, here is my refactored version of your : 

Whether the class is immutable, or I need a "quick" way to instantiate it and have getters (additional features of a case class) is irrelevant to me. So, I hope this has helped and gave you some insights. 

I like the way this turned out despite the fact that there's some extra typing compared to the private inheritance solution:1 

You could do the same with the code that acquires the expenses inputs (in fact, you could write one function for both). Don't use magic numbers You've got a lot of repeated code like this: 

Can my solution be improved? Are there any C++11 or C++14 features I forgot to use that would improve it (I'm compiling with Visual Studio 2017)? Is the name for the container a good choice or is it too similar to the objects it contains? Also, I've made the constructor private and deleted the copy constructor to try to make sure only a can construct a and nothing can copy one -- are there any other ways to construct or copy a that I've missed? Is it a good idea to prevent construction/copies or is it unnecessarily restrictive? 

Check the length before sorting It takes constant time to determine the length of a string but is \$O(N\log(N))\$. If the lengths don't match then you don't have to sort.