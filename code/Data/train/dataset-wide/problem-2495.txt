More about this here. Ascii values You are mixing literal characters (like 'a') that are easy to understand and ascii values (like '97') for no obvious reason. I'd rather have the literal characters used everywhere. It makes clearer the fact that we try to convert chars to indices in once case and to numbers in the other case. Using temp variable It would probably make sense to use a temporary variable for in order to make things clearer. Variable names The variable names you are using could probably be improved. Among other things seems pretty cryptic to me. Draft At this stage, I have the following code: 

Presentation I have re-indented your code, I do not know how your code is on your side but you should definitly indent it properly. Also, you should remove useless lines. Naming is not a good function name. would probably be easier for everyone to understand. Documentation Is it a good habit to add some documentation telling what your code is supposed to do. In your case, it could be nice to also tell the reader how it works. 

It would indeed be better than the way you are setting the dict at the moment. However, an even simpler solution could be done : just use a list and generate the indices on demand with : 

List of letters is not required You build a list to contain the successive letters of . This is not required, you can perform whatever operation you like directly on . 

You have a lot of repeated code which does not respect one of the main principle of software engineering : Don't Repeat Yourself (aka DRY). I might be wrong but I have the feeling that the whole code about hazard being High/Medium/Low can be re-written : 

Is this as simple as it can be ? Not quite ? The check for is actually to distinguish "test3" from the other values. It could be easier to just do the obvious thing instead of trying to retrieve stuff from the dict : 

(I took this chance to perform the renaming of the variable) Variable definition I find it a good habit to define variable as late as possible and in the smallest possible scope. In your case, instead of having defined at the very top of your file and then used in a triply-nested loop only to be reset at the end of the inner loop, it is probably a good idea to define it in the relevant place so that you don't even need to re-set it at the end of the iteration. You'd get something like: 

Gareth's answer is correct and shows the real issues with what you are trying to achieve. For the sake of learning more, let's review the actual code. What is good 

Removing useless copies Currently, in the nested loop, we copy an entire vector. This could be expensive when the vector gets big. It is more efficient (but more work for the developer) to perform the copy once and then making sure you restore it to the original content after using it. You'd have something like: 

In the first category, your and are not required : you can get rid of this. This shouldn't change anything from a performance point of view but it's always good to make things easier. In the second category, it seems like you could open once for each . Also, for each , you could retrieve only once. Similarly, you could call once. This is the code I have at this stage : 

Another more simple solution Your solution involves both recursion and mutations of data. This can make things very hard to understand. A more simple idea could be to say that from the rank, it is easy to know which element will be the first of the permatation. Indeed, if your list has elements, you know that there are permations of length and so the permutation will have for its first element the -th elements. You can repeat the same thinking for a smaller list consistent of the remaining elements with the remaining part of the rank. This can be written: 

Alternatively, this can (and probably should) be written using the builtin. most_talkative_state Many comments above apply to which could easily be rewritten using . 

Instead of creating a new list by reversing the return of range, you could just use all the potential of range (or xrange): 

It also helped me to think about the logic you've written and helped me to find... a bug!! Bug Adding a simple test case (I knew it would be worth it) shows that there is something wrong in your code. 

On top of the other very good answers: Code organisation and tests It is a good idea to separate the logic about input/output from the logic computing results. In your case, you could have a function taking an expression as a string and returning a number. This makes your code easier to understand, easier to reuse and more testable. Also, it is a good habit to put your code actually calling the logic behind an guard. All of this taken into account, you have: 

As I am talking about tools, it is probably worth mentionning that you'll find various other tools to check your code. pylint finds : 

I know you do not want to talk about this but your function could be removed if you were to use a proper logging function. If you really do not want to do this, you could at least define a function doing exactly what you are doing but calling the function automatically so that you do not have to do this every where in your code. 

About You are calling many many times on the same string(s). is iterating over at every call (unless the compiler optimises it out for you). Alternatives are : 

Another thing that could be easily improved is the fact that the same thing is (implicitely) defined twice, violating the good old Don't repeat yourself. Indeed, you define the set of vowels in and in . Probably one of them could be enough. You might think that it's not such a big deal because no one will want to change the definition of vowel but Y should it be so easy. 

which led me to think that the blue value was 1 for values bigger than 180 (because the comments talked about wheels, it made sense to apply a modulo 360). I got a bit lucky because I started with the blue color which was the easiest. Now, the blue value can be computed with : 

(This also makes obvious the fact that condition (which would be written in my code) cannot be true by definition of . 

Once all of this has been done, one can notice that the and contain somewhat duplicated information : a node has color if and only if . I have no time to get rid of node_colors but that would be my next suggestion. Also, there might be a problem with the way you add/remove colors because when calling we might re-add a color that has been removed at an earlier stage. I am not able to find an example right now but it might be something to consider. Please let me know if you think I am wrong.