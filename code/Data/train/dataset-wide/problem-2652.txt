I think you should probably also revise who should be in charge of implementing the method. From the names you're using it is quite clear that it is more natural to think at a player that uses an item. That's fine but what your code suggests is that different objects should be used in different ways, hence you need to implement it on the specific instance. Does spreading the logic on how a player uses an item across a lot of different items makes sense in your project? If you don't want to do it you might want to have a look at dobule dispatch as a possible way to retain all the behaviours on player instead than on objects. If you do double dispatch you can have interfaces such as and then have a method in with this signature . should expose a way to determine how many energy is added by the food to the player and the mutation of the state of the player should happen in the specific method you just created. If you show us how you intend to use those classes we can help you find the best way to design them. 

I'd structure your program in a slightly different way. First, instead of passing around two arrays of , why don't you introduce a data structure and work with it? It would save you from checking that you get passed two array of the same length, which looks quite neat to me. I think you could also consider introducing a data structure to hold your pair of slope and intercept value. If you do that it will be much clearer what your function does. Since you eventually want to have a function you can play with, you could create a . In this way you decouple the computation of the coefficients that best fit with your data and the construction of the corresponding curve. This enables you to play not only with the curves you fit from data but also with curves you can define from their coefficients. I think that a nicer way to compute the value could be by putting as much math as possible in some temporary variables you define in the block. That could allow you to separate the high level computation you need to perform with all the other smaller steps required to compute some other intermediate results you need. If you apply the changes I suggested you should come up with code similar to the following: 

I would extract the code which draws a single star in its own function. Also I think it is important that such function will draw a star centered in the current position and leaves the turtle in the same position it has found it. Otherwise I think that the stars you are drawing are not centered exactly around the center of the screen... or at least it is not clear to me why they should. 

It is more clear and less error prone to first make the search in the table and then fallback if you don't find the character. I would use an empty for the search, this might be controversial: 

You should notice that square numbers between 1 and 1000000000 are "only" 100000 and among them you can imagine that very very few can possibly have all perfect digits since the condition on every single digits are probably independent and hence you expect 1 every 2^10 perfect squares with perfect digits. So you could compute them all at once and, possibly, put them in your code (you find they are only 121 numbers). Finally you can find how many of them are in a given interval with a simple linear search. On my laptop, with the worst case input, your code runs in 2.871s while the following one runs in 0.017s. 

You want to detect otherwise the function might hang if there are no left. For this reason always use to get the result of . 

In general you should keep separate the logic of your application from the user interface. So your TicTacToe object should represent the state of the game (player turn, content of the board) and heave methods to play a move (and validate it), and inspect the status. In this simple program I would prefer to keep the input/output code inside main or in some helper function. Since your constructor and destructor do nothing, don't declare them. You spare to write more code, you don't need to comment them being 'default' and the user looking at the *.h file has something less to care about. Your function should accept the output stream as an argument. This shortens the function itself (you can use instead of ) and make it more general. In fact it is good to use only in your main function. The same is true for the getInput function which should have both input and output streams as parameters. Anyway, as already said both function should not be part of the class implementing the logic of the game... In particular is the main loop of the program, which could well be in a function outside the TicTacToe class. The function is actually good to have also if TicTacToe only represents the logic of the game, because it can be used to have a textual representation of the object. However you should implement it overloading Even if your board is very small (3x3) it is better to use loops instead of repeating the code when you iterate over the rows. This makes the code a little bit shorter but is much more maintainable when you want to make modifications. This is true in both and . the name of the variable is misleading. If you represent the number of turns you expect it to increase. Instead you are maybe representing the number of empty cells. It is very difficult to understand if the check of the i.e. is correct or is off by one. the variable should only have values 1 and 0. So you should make the modulus check after increasing the value, not at the beginning of the following loop. This will preserve the invariant of the loop. filling the board with the numbers representing possible moves is something related to the output functions not the logic of the game. Better to have only three possible values for EMPTY, PLAYER1, PLAYER2 representing the content of the cells. You are using the fact that empty cells are different each other in the function. This is very smart, but not good if you want the code to be easy to understand and easy to maintain. If someone would like to implement a graphic interface he will not need to put numbers in the cells, but will run the risk to break the code if it tries to modify it. is a non standard header. The function checkStatus should (this is causing the warning). 

You can read the choice of the user as you did, but you should change how you handle it to use the function we defined earlier. 

I also noticed this comment and it is a bit of a red flag to me. It is the only statement in that method so you should have it to actually return something, not only to make the compiler happy. 

In I'd probably move the declaration of and of in the block. You're not going to use them outside that scope so it could be a good idea to give them the smallest scope possible. 

I think it is a very good practice. As a side note, if you want to design a method like those, I'd suggest you to make the API method final and let the custom behaviors to be injected with the strategy design pattern (if you want to use composition, which is what I like the most) or with the implementation of an abstract method (if you want to use inheritance). In that way it won't be possible to skip, even on purpose, the call to the superclass method. 

I have not implemented the methods , , and but they should be obvious. act as an immutable collection of ships. Once you get all the possible voyages you can just sort them using a comparator and Linq sort. I'm not sure this is going to help much, but it is worth giving it a try. A possible way to improve it is to keep track of the best fleet we generated so far and to just compare it with every fleet we generate instead of doing all the comparisons at the end. This could possibly prune a lot of solutions once you find a good one and it is definitely worth trying. 

Your design is quite good. Reading the code you wrote I have a few notes. What's the point of ? I am not sure that it is a good idea to define an interface and then put almost all the methods you're supposed to used to interact with it in . I think that you want to cover two different concerns. The first is what the client of your library should use, the other is what you need from your logging backend. I'd rename your in and I'd introduce a new class implemented as follows: 

In the first case you would need to produce a new list filtering the source one. In the second you would need to wrap an existing list providing a view that does not show its duplicate elements. What I don't like in this approach is that the name suggests that we have a linked list but it does not follow the APIs in the list interface. Another thing that looks quite bad to me is that you need to explicitly call the method to remove duplicates 

If is the length of the text and the length of the pattern, your algorithm is while this one is which cannot be improved further. 

I don't like too much the names of these functions. I know that also python uses ugly names (words without any separator) but I think you could improve this... for example: or seem better to me. About the functionality. Managing dates is a quite difficult task. The python library in my opinion makes a great job in distinguishing and datetimes. Your wrapper module simplifies this by considering each datetime as a localtime (if I understand it correctly). I think it is not good to hide this decision in your code. Explicit is better, even if it could me more verbose. Also I think you missed the function, which could be used in your code. 

A documentation string here is important. The names of the variables are so vague that even knowing the task in advance is difficult to understand their meaning. 

This check is non very useful. It does not decrease the algorithm complexity. In particular the check is wrong... you want the function to fail if the arr is not a list, otherwise you hide possible errors in the caller's code. 

I think that the data structure and the organization of the code is far from optimal. You are making an interpreter with some sort of precompilation (the function which searches for brackets). The data structure used to store the "compiled" code is bloated. You have a doubly-linked list for something that will never dynamically change. The pointer is never used. The pointer is rarely used. What I suggest: 

even if you plan to keep your EntityManager as a custom class, it would be a good idea to use the same interface as any standard container class. So should be and you should pass to it instead of . 

This answer has two parts. First part to show some suggestion to your code, keeping the same algorithm performance. Second one to suggest a \$O(n)\$ algorithm (where yours is \$O(n^2)\$). PART ONE The function can be written as: 

As said before: mTree should be a local variable in World::update so you make it clear that there is no need to take care of its content while you create and delete entities. This is at present the only functionality of EntityManager: 

The execution is much faster, even if the input is only 1000 names (1sec vs 1min). And gives 5910 as a result (vs 995). 

Dependency injection looks better. It allows you to clearly separate the database and the other classes of your application. It would also help you test your application because you will be able to test your classes without hitting the real database. I'd also try to decouple the classes you're using in your application and the fact that they're database entities. It doesn't look right that an user or an employee know the database they're persisted to. You should consider having a separate class that abstracts away the database and allows you to do all the operations you need to store and retrieve your entities. 

First I feel I should warn you that computation about time are hard, damn hard. You probably want to use a library specifically designed to address it like Noda Time. For instance, your code takes into account weekends assuming a Monday to Friday work week (it is not the case everywhere in the world) and does not take into account bank holidays, which are not working days. Said that, I think that your code is ok but I would rewrite it in this way to make it clearer. I'd like to split the code that computes the working days in full weeks and the code that computes the day in partial weeks. I also don't like the casting you do too much in the for loop. You can avoid the for loop altogether if you think a bit about how you should handle remaining days and do the maths. If the logic I'm following is not clear from the code leave a comment and I'll explain it a bit further. 

I'd change a few things to make your code cleaner. Your method does three different things: it extract the message from the context, it creates the intent and it finally launches the email app. What about introducing a class, a , and an methods? is definitely to arrow-shaped. I'd refactor it to separate the logic of creation of the package info string and the code to retrieve the instance. 

Generally it looks good, at least to an Haskell beginner like me. I find the use of to be a bit confusing. I admit I had to read your comment to understand why you used it. I think it could also have introduced a bug. What is the expected behaviour for ? Your code returns but I would expect . Was your behaviour intended? This solution fixed the issue. 

Once you encapsulate all the logic in that class, you can think at another class to encapsulate all the user interaction. That class should implement the following interface.