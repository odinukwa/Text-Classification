There are global attributes with the access modifier An object is responsible for its valditity. As of that its attributes has to be setted via setters always and the attributes has to have as access modifier either or . 

Recommendation Curly brackets are sometimes in same line as a method header and sometimes in the following For the sake of a good code-reading and understanding code should be structured. Write curly brackets either in the same line as the method header or in the following. 

Script is terminated in the constructor The script should not be terminated in a random class but by an . The type of the exception decides wether the script has to be terminated. Commonly a leads to a termination. Possible Route class 

The code became even better readable and when the validation has to be adjusted it is obvious where to make the changes plus you can validate the Route at any line in your software with the guarantee the validation is up to date. Approach 2: Move the assignment to a respective setter and throw an . 

I'm sure this could be optimized even more, but this answer was meant only to illustrate the use of to minimize the amount of code that has to be written. In this case, using just one single function with some prepared data greatly reduces the amount of data that's necessary. Further optimizations would be to use objects instead of just plain arrays to associate the data. 

Load From Data Files Instead of Source Code Once the user selects a valid level, you can then have the function start by loading the level, when repeatedly drawing the map and polling user input until they win: 

You can bind a single click to many elements using a class selector, etc. refers to the element that ended up being the target/srcElement for the event. 

This final version allows new .toggleable elements to be added to #parent on the fly, and they will also react correctly (assuming they are styled, loaded into assoc, etc). 

And so on. Your selectLevel function could open the data directory and read the list of files (it doesn't necessarily need to actually to read the contents of the files, just a directory list). Use Structs/Classes To Track Data You can make your design simpler by having a struct that contains the game state. You could even eventually add a save/load routine later by isolating the game state from the rest of general memory. Here's a suggestion (feel free to modify as desired): 

As others mentioned the code is not completly OOP. A real OOP application does not contain functions but classes and methods. Well, except of the file that includes the class that initialize the application and the autoloader function - AFAIK function expects a function only. The autoloading part is missing as well which is part of dependency injection. I recommend to get into it. In the constructor of class User you do not validate the email etc. that are stored in the session. They should be a) passed as arguments to the constructor and b) validated. E.g. in the method. Another point is the php closing. To avoid errors never close php. It's hard to figure out a space or another character after php-closing. 

This is an addition to other reviews. Code Quality: include 'home.php';: In the context of your shared script it's not obvious what it does. I recommend to rename it to e.g. . Further depending on the content there are other more beautiful ways to handle "that". require_once 'class.user.php': Including classes manually shouldn't be practiced anymore. Okay, maybe in an application which has like 3 files in total. However, in larger applications you should use feature provided by PHP using . So, when you try to instantiate a class PHP automatically tries to include the class once if it does not exists in the current context. View & Business Logic are not separated: Nowadays view and business logic is separated to provide a better overview. Further it grants a better maintenance if implemented correctly. Check patterns like which stands for Model View Controller. Other header("Location: index.php"); You perform a redirect without specifying the reason like . 

Where 's' is the starting point, 'e' is the goal, and # are the walls (basically, similar to the format you have now). I'd also include a title, but that's a personal preference. In this case, I'd read the first line from each file while displaying the menu. Alternatively, to avoid reading tons of files, you might just have an "idx" (index) file (e.g. levels.idx) that contains some format, like: 

Under the covers, each matching element will get its own closure, and therefore operate correctly. I'm assuming in this code that one div is contained within the other (there's no HTML here). It's pretty trivial to use other methods, such as finding siblings, etc. In an absolutely worst-case scenario, you can use data attributes on the clickable element to target other named elements, or you could make a named map: 

In addition to janos' answer, I'd like to add some additional tips. Avoid Goto Goto simply creates "spaghetti code" that will become harder to maintain over time. Instead, use do/while and break as appropriate. Once the user wins, simply return from the function that should be maintaining the play loop; once the user requests an exit, return from the main application loop (examples further down). Keep Main Simple In a typical application, the main function only calls 1 or 2 functions, usually in the form of Your main function should be close to: 

There are both empty methods and methods that return always true : When a method body is empty it usually means you have not implemented its logic yet. It is possible that one forget to include its logic but calls the method which can leads to a difficult to identify bug at a later time. Therefor I recommend to throw an with message . , : Why does this method returns true/false anytime? Does it switches tags on/off? , : These methods rather append, do they? Or does this word describes appending as well? 

Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

As you notice it is better readable. From here there are two approaches how the code can be optimized further. Approach 1: IsValid-methods should be created. These kind of methods performs a validation. 

You include an autoloader in the test class. From UnitTests I am aware of a bootstrap file. If such a class exists/can be registered for functional tests as well you should move it to a respective file. 

This design violates first normal form, which is a concept that states that each data field should contain an atomic value (using type and ID together makes this a composite value). This makes certain types of queries more difficult, and you'll use more database space and suffer query performance. Store the type in one column, and the ID in another. If you have many tables, you might consider breaking it out so each module type has a corresponding "likes" table (e.g. and . This uses significantly less space and makes maintenance easier, but makes some queries harder (such as "show me all my likes"). Using a single-table notation is acceptable, but by breaking the type and ID out, you can use an and an instead of a , which will improve query speed on full-table scans, and use less space on disk. 

This final version, $URL$ works the same as the original code, using just 35 lines of code. Included here is the JS code. 

I'd rather prefer the first method, as you can then add/remove elements in your HTML without having to refactor code. There's plenty of other ways you could do this dynamically, including using to bind to a parent element and then determine which element was clicked. 

PHP-tags are closed It is not recommend to close the PHP-tag. It can happen that you have an empty space after the closed PHP-tag which leads to error. Not closing them reduces headaches :) 

Each class belongs in an own file It seems to be overhead but remember: Each class has one task to solve and the same goes for files. In small projects it does not matter that much but as soon as a project grows it helps a lot. My namespaces are similiar to the path of the class location. As of this I know where every class is located - everytime I instantiate a class. Namespaces If you have not read yourself into namespaces I recommend it. Namespaces combined with an autoloader are a great way to make your daily developer life a lot easier. When using an autoloader you have another reason for having one class in one file. further aspects 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

Since you're breaking out on the first call to remove, then moving on, you'll never violate this rule. 

Which basically moves all of your if-else logic into standard library calls. By the way, a popular method for switching numbers in place without a temporary integer goes as follows: 

Of course, you could instead use std::swap. However, given all the alternatives, if performance was a non-issue (e.g. absolute clock cycle count was unimportant), I'd impress simply using std::min and std::max. 

Avoid Hard-Coding Values should validate the level range. In a real game engine, you'd probably have files in a data folder instead of hard-coding the levels within the source code. For example, you might have files that look like this: 

One file per level still applies, though, as it will reduce loading time and memory usage (not that either is significant in a game this small, but the principle is important). 

Using this design means that you could literally edit levels into the data folder and have them appear when the menu is displayed, and offer (potentially) unlimited levels. Since we're talking about C++, the files could be simple, something like: 

In general your code is a good start. Keep going :) However the class should be refactored. Issuelist: 

There are multiple returns in one method This makes the code less maintainable. Having more than one return means there are multiple scenarios when the method can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class. 

Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards. 

What you've actually implemented is an unoptimized reverse selection sort; in this case, you've combined a bubble sort with a selection sort, which has better performance than a pure bubble sort but not as efficient as a pure selection sort, primarily because you're making potentially far more swaps than you would with a pure selection sort. You could change it from the current implementation to a pure selection sort with minimal change: 

Using method will have an side-effect if is modified. This is because arrays are passed by reference, and so any changes to will be visible to the caller when the function returns. Use if you need to manipulate id or name, unless you intend to return the modifications to the caller. Example: 

Generally, when you free something, it's a good idea to null out the pointer afterwards. While in a program this small, you'd be unlikely to make a mistake, when you null a pointer, most platforms will terminate the program rather than have potentially undefined behavior from a dangling pointer if you accidentally reuse it. You should get in the habit of doing this. There is a function called realloc that performs a malloc/memcpy/free cycle for you on your behalf. Some platforms can also resize the memory without moving it (assuming enough contiguous space exists after the allocated memory), which can be a performance benefit. You should use realloc instead of malloc/memcpy/free, because it will always be at least as fast, and often faster. That said, your code appears to be free of memory leaks, accessing invalid memory, buffer overflows, etc. There's a lot of minor optimizations that could be recommended, but this code is at least logically sound.