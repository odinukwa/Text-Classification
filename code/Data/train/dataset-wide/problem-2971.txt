All in all, here is the new version (with all the edits I recommend). Yes, it's longer, but it's also more robust, duplicates less, and should likely perform better. 

One note I think you should have: I'm not sure if you realize or not, but doesn't stop the underlying value of the field from changing. It stops assignments from affecting it. What I mean is, the following is perfectly valid: 

What did we just do? We just replaced the entire / blocks, all the manually typing , etc. with a dictionary of string -> function. Where does this benefit us? Simple. I want to add exponential calculation. Simply add: 

No one has yet addressed the fact that you have chosen the wrong tool for the job. What does represent? It looks like you should have chosen an where you chose an . 

So what did we do? We replaced all the strongly-typed calls with some generic ones. We also added a parameter that allows us to specify a certain to build our result. We could extract that out, but I'll leave that up to you to decide. Next, we rewrite the other as: 

These are all fields. In C# we don't make fields public, fields don't support events on , , etc. They don't support any sort of access control, and just allow anyone to read or write that value. This is almost always very bad. Instead, make them properties. It's really simple and easy to do: 

Try to choose more effective variable names. Never abbreviate except for certain well-accepted abbreviates ( for , for , etc.): 

What happens when we're not going back to the main menu again from either of those methods? Now you have multiple places that you have to modify, and in a larger, production application that would mean very possible breakages. So we're going to eliminate responsibilities until each and every method only has one left. Let's start with : We can take the following block and extract it to a new method: 

You should be explicit with your constant types. I don't know if the compiler will always convert to a , you may be seeing slight performance impacts from that. So when you do , you should consider . 

So I have part of a library which deals with scopes in Google+ integration, and I'm curious on the overall view of it. Yes, things are stringly typed in one of the methods, that is because this has to be COMpatible, which does not support enum's. I have (purposefully) omitted XML documentation, as most people think I go overboard and I'd rather not bloat. 

Why? You already put in a variable. Just use that. The next thing I would do is define a list of valid extensions: 

Let's talk about early returns and catching input validation issues for a moment. Generally, we try to return as early as possible, and throw any necessary exceptions as quickly as possible. This means we use what are called "guard clauses" to validate our input. 

The interface requires the method (ASP.NET Simple Membership). The F# portion has two modules: and . 

In that case you should not be using the local constants, they only create overhead on the stack, they're not used more than once, and they're not cached, so in reality they provide no additional value. 

Because we initialize a new string array, it's guaranteed by .NET to be all () strings. This eliminates the need for the three statements, and brings you down to just two conditions. Then you append if it's a fizz line, and append if it's a buzz line. 

So that's more than one, but that's fine, we need to finish our analysis to make appropriate decisions on what to do next. Let's look at : 

This uses the function, which provides the current index and value (in that order, defined by the signature) which we can then match with our (first element to swap) and (second element to swap). If we hit either of those simply return the other element. But then, this isn't enough. What if we have several pairs to swap? We have to call then a , which could have a substantial performance penalty. We could define a function which would take a list of tuples which are the first and second elements to swap and then handle them. 

So here's what is interesting: we have , which represents what the result of the was, and all we're going to do is check , which tells us if the task failed () or succeeded (). From here, it's a matter of modifying and slightly: 

Obviously this is a lot of pseudo-code, but you should get the idea. Then, any time you need , you may or may not actually be reconnecting. Other than that: a lot of your code uses when will suffice. You also have moderately poor naming (, ), that's the biggest issue I see here. 

Let's talk about two major things in this: building a modular API, and Unit Testing. This can be easily unit tested, you should have 7 tests, one for a date in each day of the week. Let's pick a Week (past, present or future, doesn't matter), for this I'm going to pick an easy week. Since is the first day of your week, we'll pick the first week of a month that starts on a Monday. Scrolling backwards in my calendar I found August, 2016. August 1st, 2016 is a Monday, so we'll test that week. The problem right now with your code is that it cannot be tested. You have to reset the system clock to test it. This is not a hard problem to fix. We'll redefine the API a little bit (add a default parameter, basically): 

Absolutely no need for the there. Whether or not you keep it is up to you but the symbol eliminates the need for escape sequences in strings. It's mostly helpful with paths and Regex: as opposed to . 

The distribution has been consistently variant in my testing, and has been predictable within \$[9.93\%, 10.08\%]\$ for \$1,000,000\$ generated numbers. When testing with \$10,000,000\$ numbers, the distribution consistently falls within \$[9.975\%, 10.025\%]\$, furthering the demonstration that no number is favored consistently. (When testing across multiple runs, the favored and unfavored digits varied entirely.) Just for comparison, if the entire method is replaced with a simple the result distribution is roughly as follows: 

Bam. That should be the first line of the method. That will make sure we get set to a valid . Alright, good. So we redesigned the API a little and made it support an extra feature with no effort. Now we need to talk about that return. Generally speaking: robust, modular API's that return a collection should return an of some sort. I may have the user specify a specific and try to find the first date in a give week that is that , so I don't need the entire list (potentially). This is because each caller has different requirements (potentially), and to most closely follow SRP we shouldn't care about the resulting collection. Our API doesn't need to worry about the collection as a whole, only generating each element in it. This may be a bizarre concept to understand at first, but our method should not care what the caller is going to do with the collection itself. We just generate it, so we don't need a list or array, we just need to return each element as it's generated. We do this by returning an so that we can use the statement instead of . This will allow us to make a more modular API that doesn't always have to enumerate everything. It's the caller's responsibility to call if they need an array, or , or enumerate it, ect. 

A lot of times people post PHP here and it's often very ugly, this is not one of those times. Your classes and design are beautiful, and it's very obvious what your intentions are. You've built a good structure, and you've commented clearly. In fact, I saw this comment as was immediately impressed: 

Why? It's fast as hell. And this tends to make it more clear what position each value represents. There's no need to place them backwards as you have to with the Looking at this code, it's extremely easy to determine that each pair consists of the high-byte, followed by the low-byte. With the , the lowest byte must be followed by the subsequently higher bytes. Can it really be faster, with all those casts, shifting () and or's (), and the fact that Microsoft themselves wrote the ? You're damn right it can. Run the following programme: 

Note that we also built this without the pattern, and relied instead on constructors. It's more natural this way, and preserves the original usage. The only downside I see is that the original parent chain may not be preserved, if it goes more than one level. We can fix that by modifying our constructor: 

Anywhere you use can simply by This has the exact same effect but tends to be more accepted. I.e.: would be: . 

I have an application that needs to validate user passwords to a very reasonable custom validator, which is heavily based on NIST-2017 requirements. The validator intends to satisfy the following restrictions: 

Build all the arrays! :) No, but seriously. Build an array of intervals/arrays and then test within the array for the interval you need. The final (or first - your decision) can be the default for 'in lieu of other options' which would be your option. The nice thing about this method is that it's easily extensible, and it could be parameterized. You can supply a array as a parameter where is the start is the end, and is the result. On my phone so a code sample is currently out of the question, I'll try to remember to add one later. 

I have a blog that I occasionally post to, but it's a PITA because of the fact that it has it's own WYSIWYG editor and doesn't support Markdown. So I have to switch the WYSIWYG editor to the HTML editor, and of course the HTML is garbled from the WYSIWYG editor. So, I wrote a programme that I can feed Markdown into, and it will let me see what the HTML would be, and a preview of how it would look. It's all very simple. 

I would take some of these strings and make them constants/variables/configuration settings. This will allow you to change them easier and in one location. 

You can easily use a here. This would be the best-practice in my opinion. Assuming only gets called once (otherwise why would you need a loop in it?), then a can be initiated in this method. This isn't guaranteed valid, compile-able code (I wrote it far outside an IDE): 

Now AES uses only a private key as both encryption and decryption. This is known as symmetric encryption or a symmetric encryption algorithm. What you are discussion requires something else, known as asymmetric encryption or an asymmetric encryption algorithm. These algorithms come it two major variants: those that use the public key for encryption and the private key for decryption, and those that use the private key for encryption and the public key for decryption. The option you pick depends on your use-case. In the case of something being shared from server -> client, you would pick an algorithm that uses the private key for encryption, since the server is entirely under your control. You can keep things on it a secret. You cannot keep things on the client a secret, so it should get a public decryption key. Then to send data back you should have a second algorithm that does the opposite, and uses the public key for encryption. The next option is to have the client establish a connection to the server, then use a public key encryption algorithm (such as RSA - where the public key is the encryption key) to send it's AES key. Then you can use AES for the remaining communication between the server and the individual clients. This is the most common type of scenario with RSA, as it's very expensive to use for encryption and decryption. If you're using HTTPS, however, there's no need to build a sophisticated mechanism to further encrypt your information. HTTPS already provides a secure communication session between client/server, though it doesn't hurt to add more security in general, it can have drastic performance impacts if done wrong or 'over the top'.