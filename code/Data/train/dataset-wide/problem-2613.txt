Generative approach The idea of functionally generating the next value from the current value rather than mutating a location is consistent with good Racket practice. Naming 

Using implies that the domain areacalculator.com is under the control of the programmer or the organization for whom the code was written[1]. The idea is to produce unique Java namespaces by leveraging the uniqueness of internet domain names. It's a convention designed for the age of the internet and a sound strategy for avoiding namespace conflicts. It makes assigning responsibility a more reasoned process: only one or none of the packages can be named correctly. 

The solution exists in the 99th layer of Odersky's onion because it requires 99 moves. With two glasses There are only six transition operations at each level of the onion: 

[whatever the func that is] is called twice with exactly the same arguments. Each time it is wrapped in which adds to the cost. Indeed , , and are defined each returning a data structure that requires reshaping. This can be avoided by either working with their data structure directly in the code under review or redefining the functions to return the data structure used by the code. is calculated twice. Sure in one location it needs to be doubled. Each time through the inner loop increases by one. There's no need to recalculate it in full. It can be passed as a parameter from the enclosing function. [defined elsewhere?] is a constant within the code under review. Therefore is also a constant. Yet is being calculated twice in the inner loop. [ defined elsewhere?] is calculated for each iteration at the each level of the loop. It's a constant. There are probably other places where redundant computations can be avoided. 

Architecture Even better would be decoupling the "business logic" of determining whether the contents of the string contain all the vowels from input and output. Modularizing the code into 1) getting input, 2) inspecting the input, 3) packaging the output provides an opportunity for code reuse in situations where the programmer's understanding of requirements may change (as may be the case here). Design I'm not a fan of performance optimization that isn't backed by measurements showing there is an actual problem. My suspicion is that searching the string once for each vowel is almost certainly reasonable in this case even if processing the list one letter at a time is likely to allow better worst case performance in theory since the list would only need to be traversed once. On the other hand, removing white space from the input string is not consistent with the requirements and is potential source of bugs in code that has to be maintained and adapted to the changing world. Validation 

Because the fastest operation is one that is not performed (but only when performing it is not required). Of course the code is not very interesting in Python. The code for such an approach might be more interesting in a language that provides compile time calculations -- for example Lisp via its macro facility. The cost of more interesting code is often similar to that of execution optimizations: the code is harder to read and to understand. Arbitrary Fizzbuzz By 'arbitrary FizzBuzz' I mean that the values for 'fizz' and 'buzz' can be arbitrary (for some definition of 'arbitrary') as is the case in the question where values for fizz and buzz are supplied as arguments and not hard coded as in classic FizzBuzz. As is the case with Classic Fizzbuzz and problems in general, performance optimization of Arbitrary FizzBuzz requires tuning the code to take advantage of the structure of the problem in order to minimize the amount of work the computer has to do. The underlying arithmetic creates a structure that repeats: 

That's almost human readable! There are some variants on this like but they can begin to be a bit wordy, but the point is that you're implying that the variable is a boolean from its name. Use of and Variables In this context it doesn't make sense to have a boolean variable for each supported language. The reason being is that it is possible that both variables could be true, which you correctly identify as an error. I get the feeling you're procrastinating by leaving the error checking towards the end. My first recommendation is that you create an enum which stores the detected language, and can have one of three possible values: 

Then you can write your program such that it's only trying to guess the input language whilst your enum variable is set to . Of course you will still have to handle the case where your program has determined the input language but then encountered a character it wasn't expected (e.g. thought the input was a Java name only to encounter an underscore). This is an error and your code should throw an exception or do something to notify the calling code that they buggered up. It's not your responsibility to recover from it since that scenario is undefined based on your problem definition. Just to elaborate a bit more on why you shouldn't return "Error!" is that if something goes wrong your function always returns a string. This is ambiguous since your successful value goes in the same variable as an error. Don't make life hard for yourself, throw an exception so you force the calling code to implement error handling the proper way. Consider Using Regular Expressions Regular Expressions (RegEx for short) are a dark art and are very powerful for string pattern matching and manipulation. In this particular case I can't give you any real answers but a PHP framework I have used in the past has an Inflector class whose job is convert between naming conventions. You can find its implementation here. Control Statement Nesting This is a massive bugbear of mine and I see it all too often. Your code isn't especially bad but I think it's something you should be aware of. Control statement nesting is where you have an if-statement inside an if-statement inside a while-loop inside a switch statement, and so on. Doing this increases code complexity. Your for-loop is on the edge of what I consider being too complex, but I think given your implementation, there's not a lot you can do. You want to keep your code as flat as possible because it makes it easy for someone else reading your code (and yourself for that matter), to follow the logic. 

Firstly I don't agree with a particular coding convention being tied to a language, implied by your excerpt. I know this isn't the point of your question but as an aside, coding conventions develop from an amalgamation of best practice, and what your development team is happy with adopting (I've been through this painful process). Naming of Boolean Variables A fairly neat convention I've adopted recently is naming of boolean variables by the name suggesting something is true (i.e. an assertion). What I mean by this is that where you have and , you could have and . Then, when you need to use the variable in an if statement you have: