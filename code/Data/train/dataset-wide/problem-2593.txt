Will have the same effect. Now, are you using the type ? No. In fact, you are iterating over so all you're interested in is that it is . Which is the same as since all classes extends Object. So now we are left with this: 

Performance I don't see any performance bottlenecks unfortunately. Style and stuff You're using a lot of empty lines, I would reduce the number of empty lines you have. You also use way too much lowercase in your variable names. (Although doesn't start with a small character, which it should). It is hard to read text that is only written in lowercase and not space-separated, by using someBigCharactersHereAndThere it can be read more easily. Some simple naming changes: 

JavaDoc You comment some methods by adding a comment before the method, a better alternative would be JavaDoc. Entering and pressing enter in your IDE will probably create a JavaDoc block. Here's how JavaDoc looks like: 

Right now you are mapping cardId --> function name in and then you are mapping functionName --> Actual function. When I started refactoring this to skip the name I realized that you really need it that way, because of the function. A comment about that would be helpful so that I don't try refactoring it again :) One thing I noted about the functions/abilities thingy though is that your only contains one thing: . Why not simply use the directly? always returns a table. I don't see the usefulness of this. You can make it return a single function and viol√†, it will have reduces table nesting. I managed to re-write your FunctionsList code to this: 

Hexadecimal values are often showed in lower-case, personally I like that better because it makes it easier to separate the characters (a-f) from the digits (0-9). If you still want to use upper-case characters though, use this: 

Using is redundant and can be written with a at the beginning instead. (Again, the boolean not operator) Also, I would add a space between and 

This method first checks if the result is for both high and low aces and if it is, it returns a degraded poker hand of only the primary rank. So full house becomes three of a kind and two pair becomes one pair. 

Additionally, I'd again recommend using percent values to avoid the division with stage size. Help pages Your returns a First of all, use the interface to return . However, as the keys for this map are essentially indexes, you can use . In fact, as you don't need any dynamic resizability, you can use , which will allow much easier construction of the help pages. 

Database vs. Application I feel that is OK to let the database deal with this. There is a positive aspect of letting it be handled in the application: If the application deals with it, then you can reorder the elements without querying the database. However, 

Side note: Whether or not a door will be open or closed at the end depends on how the prime-factorization of it looks. Consider the number \$12\$ for example. How to prime-factorize it? \$12 = 3*2*2\$ And the door will toggle on \$1, 2, 3, 4, 6, 12\$. Note that those numbers can be written as 1, 2, 3, 2*2, 2*3, 2*2*3. That's \$6\$ times, which means that the door will end as being closed. Unfortunately, there is no efficient way to prime-factorize a number. What you have built here is very similar to a number sieve, but instead of removing non-primes you are toggling them. Modifying your code to be a real sieve instead would not require many changes to the code. 

Your iterate method returns the same list as is given to it through a parameter, that's not needed. Either create a new list and return that (not recommended in your case), or change it to a method: 

Field Visibility Restrict field visibility as much as possible. Use wherever you can (the compiler will let you know if you can't). 

I don't think that you need the interface, because it only provides methods that can operate on an . I think that to save you a whole lot of code duplication, you need to re-think your approach. Consider the potential differences between and with regards to the implementation, 99% of the code would be the same - the looping and assignments would be very similar, if not exactly duplicate. Put as much code as possible into a generic implementation of it, for the method I think you can have the implementation in , and that it can use the to assign to various fields. As for the differences, I think you should consider the Strategy pattern. What you need to provide is strategies for several operations. Possible methods for the strategy pattern (I don't think you need all of these) are: 

Algorithm Now, about that algorithm... You have a variable called and yet it isn't a stack structure, it's only an array. Using a somewhat real stack structure can be helpful. In the code below, I have used the class to provide this structure (Even though there is also a class, I like the interface and wanted to go with ). In this code, I have improved the variable names, the return type, and I am using a to store all "special" characters in. The method of a HashSet is performing in constant speed, so you should not experience any significant lack of performance. I noticed that in your if-statement, you had hard-coded the values that were put into your , this is what made me want to add the . To make this work, I had to flip the key/values of your HashMap. The key is now the starting character, and the target is the expected ending character. The loop through the string here is pretty simple and straight-forward: 

Generic tile scanning Many of your mission goals depends on a sum of all tiles (when purely counting, the value for each tile matching the predicate is 1) This leads to a possibilty of: 

Public? None of the classes you wrote are declared as , how did you intend them to be used? Additionally, your class is , which makes me wonder how you are testing this? Did you declare this class inside the test class? I see no harm in making this one RatingComparator Your has this field: 

Variable names What on earth is ? What type is it? It seems to be one variable used for all kinds of things. I'd recommend making these separate variables and using more descriptive variable names. Result This will clean up your code a bit at least, to this point: 

I must say though, as I want to give a compliment also, that you're code is quite well formatted. You know where to put braces and parenthesis and you know how to indent your code properly, good! Keep on learning more things! 

There are some abstractions that can be done here. I will try to walk you through it a bit. Extracting methods This pattern is something you do a lot: 

Excellent little interface there, I'm just afraid that with this naming you'll end up with ten interfaces named . Naming it would be better. 

Overall, your code looks nice and clean, I just have a few things to say: Your code is described as "... convert ... into four spaces" which throws me a bit off pace when reading this line: 

It feels like it is the mission's job to mark itself as completed, and then it may return true if it did mark it as completed. 

These variables should be and the should be declared as to allow easier switch to another List implementation. 

Whenever you find yourself using multiple numbered methods that does very similar things, think: Array!! (or possibly if you want to be able to add/remove dynamically) 

You don't need a separate class for it! I don't see any real difference between a Bandit and a Skeleton and a regular monster. You don't add or change any methods in the subclasses, and you don't add any new variables (other than the static ones). The most important change you can make here is to only use one class. And then you'd want different methods to instanciate that class. This can be considered factory methods A current smell of your code is that your call to the constructor is a very long one and it's using many variables and some calculations on them. Factory methods will deal with this. I also think that you are overusing static variables. There are a bunch of ways to deal with this but in this example I will just put them as local variables in a method. A future extension would be to create a class that keeps these variables as fields, then you can create several MonsterConfigurations, and perhaps read some MonsterConfigurations from XML? In your Monster class, add as a parameter to the constructor and remove the keyword from it. 

XML Considering the pattern of your XML files, you might want to create the layouts dynamically, with code, instead of using XML files. I don't really see why you're wrapping all your inner LinearLayouts inside an outer LinearLayout in your I think that you can remove 

So that you don't have to typecast it later on. uses a generic return type so you can make use of it directly. 

It seems to me like what you have done here is to create an entire class to avoid duplicating one line. (Or OK, 5 lines if counting the try-catch statement) I don't agree with the need to create a class for this. Especially not a generic one, since this line of code: 

I hacked together this little query on the Data Explorer The query finds questions where an answerer has posted two or more answers (which in itself is not necessarily a bad thing), it gives you the link to the question, information about which user posted the multiple answers, and how many answers by that user that was posted. 

Optimal solution: Remember all the visited numbers and for each number store the number of visited numbers. For example, for the number 3 the next number is 10. So calculate the Collatz sequence for the number 10 and then add one. Then when your outer loop actually reaches the number 10, you can use the number you calculated before as you already know the Collatz Sequence for the number 10. Hint: There is a good data structure you could use for this 

Regarding the user friendliness of your program, it's not layouted as a typical calculator. This is just a nitpick really. It would also be nice to use the keyboard for the program, but that's just a feature-request :) 

Avoid using "special return values" in code for when errors occur. It should be up to the calling code how to handle the situation. I would let the utility function re-throw the exception: 

I don't think these are any major improvements, but there are many small things that I would change. 

I would expect the generator to seed itself (using the current time) in its constructor. Therefore, I would not use a default parameter in your method. Also, in your current code, you treat all the negative values the same as zero. I wouldn't recommend that. Many random seeders can handle negative seeds as well, if you don't want to do that: Throw an Exception/Error! Therefore, I would use this: 

Additionally, is used for , that will work just fine here but is not required, a normal would be enough. So we can use insteand so that it becomes: 

It is totally fine to do it this way. This is an anonymous inner class. The alternative is to use an inner class (non-anonymous), this would reduce code from your constructor but that code would be added in other parts of the class instead so which way you go doesn't matter much. This is fine. 

Some things about your current converter: can just be . Technically it would be enough to specify it as as is a superinterface of , but declaring it as is fine as well. To support null values (even though you might not need it) you can use instead of 

The code still considers this a full house of both high and low aces. How about something simpler then? 

A or B? How about C? A third alternative, that you at least might want to think about, is using a . Add all the as keys and the return values as values in the dictionary. This will be one line for creating the dictionary, one line for each item to add to it, and one line to get the value from it. 

Oh, and by the way... as I've already introduced more advanced topics, let me just say that by using Machine Learning your problem would be handled even better, and would be how today's real world book recommendation systems work. "Collaborative filtering Recommendation System" is a concept that are used by the big companies out there. "Logistic Regression" is also something that could be applied in this scenario. 

In fact though, if the first if-statement is true, then the inner if will also be true because of your SQL WHERE condition. So your code could be just this: 

Some things that hasn't been mentioned already: SQL INJECTION! Use prepared statements. They are much more secure than normal statements as they prevent SQL injection, which your code currently is vulnerable to. Never use string concatenation to create an SQL statement! 

Hresult in the first part of the code essentially has no effect because it will be overwritten by Hresult in the second part. Now let's see what the common areas of this code are: 

You have already checked for . The string will only be null when the object's method makes it so. And instead of you can use directly. (Although that is implemented as string length 

Let the user whenever he likes create a object, and call the method on it (as you've done in the sample). There is no need for your to know which is the current showing activity, it only needs to know about an activity (or rather, ) when it should do something - i.e. possibly show a dialog or read/write the preferences to keep track on how many times/days the application has been used. When the user of your library wants your library to possibly show the dialog, let it call a method on your library and pass along the current as a parameter. That's it. No need to make things more complicated than necessary. Summary By extending Application as you've done in your question, you have only added a middle hand that doesn't add any value at all. All the things that are done there can, and in this case really should, be done in the instead.