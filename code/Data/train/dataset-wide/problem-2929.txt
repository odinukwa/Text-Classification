That's a pretty concise routine there. If you had to change it, I would add methods to parse the user input so now your program logic is less nested and we get back to the good old principal of each method having a single purpose. Normally in a simple app that has a menu structure I would say use case logic instead of if statements as this will allow you to easily extend the options later, but your cleaver use of the dictionary of functions does away with this altogether. 

See my response to question 1 from a purist point of view your Value Object is a complete package, it has a dependency on Currency, but is easier to lock down with unit tests and to distribute in a utility assembly for reuse. It's up to you to evaluate the cost of developing this solution and refactoring existing code to use it. Certainly follow the advice from @t3chb0t, you've gone to this much effort, implement your own contract definition for the response from CalculateDenominations, a key value pair response is too ambiguous for users know how to use the response, it's the missing bit of "self" documentation. 

Throwing exceptions from the calculation routine is an acceptable method for validation, if this was a Mutable type (not readonly) then I would argue that it would be better than throwing exceptions from the constructor which can lead to other interesting and less than satisfactory implementation patterns. 

For mutable types it's only at the point of execution that the validation matters, the code that interacts with the instances of this class should be free to instantiate the object and react to its state at a later point in the execution. It is hard for example to check the state of a Value object if we failed to create the object in the first place. 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

The new property , which is maintained by the and methods, takes care of saving the current resolved client to the GORM store (database). With that value persisted you can use it in GORM queries: 

Templates Ideally, you'd have two templates: one for the class and one for the methods. That would avoid the clunky JSP-style programming. You can read more about Groovy's template engines here. 

In this example, is an interface with four implementations, (only one of which I coded), one for each of the possible directions. The methods accept a and any other necessary parameters which are not part of the . The implementations can then get , , and from the . Sure, this breaks some object-oriented programming rules, but as the adage says: some rules are meant to be broken :) Note that it still involves passing the current state of the . Alternatively, you can implement as an abstract class containing and the equivalent of the methods as abstract methods. Then, you can remove all together and implement four s; one for each direction. 

In order to resolve the client with a GORM/Hibernate query you basically need to persist the resolved client value. Based on your method I'm assuming your domain class model goes something like this: 

Putting the JSONArray aside (given I don't know the fully qualified name of the class), here's a Groovy-er version: Working example 

On the Groovy side, it would still be best to use the method because the property can get out of sync if changes. 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

Async void should be avoided, but they are acceptable when in an EventHandler so it's fine. Why are you copying the keys of the dictionary into a list? Do you want a snapshot at a random point in time? If you have potentially race conditions, I would change the Dictionary to a ConcurrentDictionary. 

Don't call find twice will save an extra database access which is important and code style wise I would use the ?? operator as you see above. What the View("Error") is doing? Do you have an error view or is it just raising an exception? In both cases I would be more specific. I would also make the view strongly typed as it will prevent errors and give you IntelliSense. 

I would definitely remove the database access from the Category partial view and move it to the Controller (you can add it to the view model or have a separate action for returning them which is even more clean). Views are supposed to be dumb layouts and not perform any business logic. Removing the database context shouldn't affect the compilation of the views. Small refactoring suggestion for the Controller: 

I focused on simplifying the implementation rather than the actual algorithm: Many of the method exposed by your Roulette are just proxies for the Dictionary so you could just inherit from the Dictionary. You could simplify some the Edit by using ConcurrentDictionary, but I don't think you really need it concurrent anyway; your choice. If you have C# 6 you can make the code less verbose. LINQ can simplify most of the implementation, hopefully didn't make the code unclear; but usually it's even more understandable in a functional fashion. I removed some duplication in the constructors as they can call each other. The equals operator between floats can easily fail for the precision so, as my ReSharper suggested I changed it to have a tolerance which you can set. The default of KeyValuePair shouldn't cause any issue unless you have a default of both values in the dictionary. Maybe worth a runtime check. Don't remember if I made other changes, too. 

After loading the parameters into a Map, a Range is created from the start and end values. The added method calculates the fizz buzz and returns them in a list. The method is used to iterate through the fizz buzz list and write it to the output sheet. Finally, the output is saved through the added (and overloaded) method . 

You can use Groovy to generate the Groovy source code. The source code generator Here's an example source code generator. 

This makes use of to handle most of the building, instead of looping and appending to . The only comes in during the case of 3 or more items. Revised It's possible to knock out one of the cases like this: 

If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

With some meta-programming you can add a method to the InputStream class that would allow you to move a line ahead of another using concise code like this: 

You'll see the use of methods throughout. It's a practice common in Groovy that reduces the changes of leaving resources, such as files, open. You'll also notice a lack of for-loops. The and methods do the same thing; and in the case of , the index value is set for you :) Inner classes are also gone because Groovy supports multiple classes per file. The Mixins Here's the magic you can use to make this program clean and simple. 

one to determine what to move and where to move it to, and another to re-write the file with the lines moved. 

If you're interested in creating some Groovy mixins, you can make your Fizz Buzz program quite simple, while getting some reusable Excel functionality out of it. The Fizz Buzz Program Here's the business logic of the Fizz Buzz program: