And just like that all the work put into protecting the state of your apple is out the window. Coders are lazy they will not put up with complications if there is an easy way. Coders want performant code and they are not going to use getters and setters when there is direct access. Putting a sign up "Do not use" ( as the metaphoric sign "private") does not stop use. If you want to control the color of the apple you must make it impossible to change it without the vetting process, or it is pointless, and pointless code is bad code. 

Performance review These code challenges have tight constraints (a very good thing in my view) so you you must be aware of the actual load on the CPU for every line you write. Also these code challenges run on V8, and sometimes that version is not up to date. It helps to have some knowledge of some of V8's oddities, past and present. Looking at your code. The first problem is the parsing of the input. Using is convenient but slow. Rather than parse the input before you process it, combine the processing with the parsing. This will save a significant amount of time. Don't slice arrays if you don't need to, there are better ways to access data in arrays if speed is important. Same with , there is no need for it in this example. Use to convert to number rather than as it is quicker. There really is only one use for and that is to convert numbers from bases other than 10. The commands (first value per line after first line) are not used as numbers, you don't need to convert them. are very quick compared to loops, iterators, and many of the array functions. Its well worth learning to get the most out of your code. You can use a RegExp to split the input. will split on each non digit and a zillion times faster than using and Function calls add overhead that is not related to the algorithm. Avoid needless function calls if you can. That does not mean flatten out your code that means dont create indirect function calls if there is no need. 

The rewrite. The rewrite is as an example only. There are many ways to organised the code for an app, each has it pros and cons. These will vary with the individual, with the best style being one that best suits your way of thinking. Don't let code dogma spoil the fun of writing a game. The rewrite has added some things. I needed to test if it was all working, and being lazy, playing the game to find problems was too much effort, so I added an autoplay that plays the game at many time normal speed so that I could make sure all was OK. Check the to turn off. I also added a few more bricks. I have change all the collision logic to a more robust form that takes in account the object's travel during the previous frame. As there are 4 types of collision Ball / Paddle, Ball / Wall, Ball / Brick, and Paddle/Wall each somewhat different in needs, thus the code base has grown somewhat. I was tempted to add ball hit deviation depending on where the ball hit the paddle, but left that out in the end. 

The results of the test indicate that the function shuffle string is only 9% of the ideal situation. But if you look at the numbers you will see that there is a high rate of hash clashes. Finding a better hash function will improve the score, also I used words from 7 -10 characters long, which puts the function at a slight disadvantage. If you are wondering how I got the ideal score, I did it with the following test that simulated the ideal shuffle. 

Why review My SVG experience is low, and I am not at all sure if this is safe or even practical for the wild. Any comments, suggestions, warnings, or improvements would be appreciated. How it works. It creates XML nodes and returns a proxy of an object holding the node. The proxy and handlers do the hard work of transforming property names and property values between JavaScript friendly and XML formats, and performing the correct action depending on property type. 

Rewrite This is how I would write the function. I would never use degrees, that is only ever needed for display only. That makes the function much simplier. 

The HTML, data lives here Placing the values for the counters inside the javascript code makes it hard to manage. The javascript is a constant, the page contains the data and is unique per view/client The formal way to add data/attributes to elements is via the prefix though this is not enforced and any named value pair you add to an element can be accessed, ensures your data is safe from conflict or misinterpreted by the DOM. is not a valid javascript variable name so you can not easily acces the data using that name you need to use the javascript version created by the DOM. In HTML5 the DOM creates an attribute called that you use to access the variable with. Replace with (that's a dot not a full stop) then the , then replacing any subsequent '-' by removing the and capitalising the first letter following, thus becomes see the code above as an example. 

Design You have created a whole pile of functions, it's a real mess. Put the related functions together inside the main function. Use closure to reduce the number of arguments you are moving about. Don't create variable you use on once in the next line. Deep in the sort you test for empty array, that should be the first test in the radix sort not deep inside. A rewrite This is an example of the same functionality as your code, and by far not the definitive solution. It matches the native sort in speed by eliminating a lot of the overhead you had. It uses 20 bucket so that the positive and negative values don't need to be split 

Are you up to date? There is really not much to the problem and there are a variety of solutions. It is also hard to know what the interviews are looking for. For some it is knowledge of latest language features, for others it may be judged on efficiency. These very simple tests are generally just to see if you can actually write code. You would be amazed at how many people apply for jobs they are not able to do. Assessing the code. Looking at your code as a conservative HR interested in your code writing style, and up to date language knowledge. It is a pass, you can code, you have the job but will have you in supervision for a while..You also need to catch up on the language as you are not using ES6 to the full. General points 

As you are a beginner your time is much better spent learning to use the native DOM directly. This will give you wider, future proof skill set. Direct element reference If you use element ids correctly (they must be unique) you can use the id to directly reference elements in javascript. This is supported by all browsers. 

The trick is the second default parameter needs to set the first argument to 0 and assign the second argument to the first. The only way to do that is to use an expression . The order lets you effectively swap the variables without the need of a interim value. Another example is a gaussian random where the random values are distributed around the mean. A third parameter is needed to define the distribution curve 

Solution Using ms it is then just a matter of stepping over each day until the conditions of the search are met. In this case you want days of the weeks that start in the current month, a inner loop iterated the week days (day 0 to 6) only while the outer loop has the week's starting month the same as the current week's staring month. The results are just pushed to the array as they are found. The function 

How to improve. Can Tail Call Optimisation (TCO) help? TCO basically lets you call a function without adding a new context to the call stack. This makes calling a function almost as fast as running inline code. This would be the single best thing to have happened to the language for decades (and its only decades old), if it happened :(. Javascript ES6 spec has (the very anticipated and needed) TCO but it remains the only unimplemented ES6 feature on Chrome, Firefox, and Edge. Reason?? I believe too many pages are kept running due to call stack overflow error, TCO prevents this and thus a bad recursion function blocks the page rather than throws an error. Don't hold your breath waiting for TCO, for now its not going to help. The only solution In reality without TCO you can not safely do this via recursion. The call stack size is much smaller than the max array size. If you do recursion you would have to limit the array sizes, but even then you can not know how deep you are already in the call stack when you start, so there is no safe way to do this (Yes all recursive functions in javascript are fatally flawed, until TCO) Quick simple and low memory use. 

Modern languages came from a need to keep lazy programmers happy. There is nothing worse than having to repeat the same code over and over. For you typing it, it means you are more likely to make a mistake, it means it takes longer to get a result, and it means (mostly but not always) your code will take longer to run. The worst bit about repeating code is when you have to change it. You have the variables and and for each test you do the same thing , repeating the same code. Do it once event better do the width test only once Rewrite of your code.