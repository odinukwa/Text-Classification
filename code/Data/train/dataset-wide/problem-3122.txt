I think it's a neat idea, because you're indeed using well-tested code, which reduces the chance of errors. Looking at the API, you do need to retrieve all possibles matches using . Even that one is not a gotcha since you're naming your groups yourself. Right? I can't think of anything else. 

First, a few general comments about the 'main function' in Python. The idiom is a way to distinguish between simply importing a module and launching one. You may want to simply import the module you just wrote to reuse the function elsewhere, but you don't want the main function to run when doing that. Some people simply write: 

There's no way to know that out module uses an array internally, but it's still used and allows for very fast code. Benchmarking show that it's as fast as the iterative version, and takes about 0.02s on my machine. Automatic memoization? It turns out that JavaScript: The Good Parts mentions that you can have automatic memoization and uses fibonacci as an example. It can be interesting to try to apply this to our fib_sum, but I'll leave it as an exercise. :) 

It's great that you're exploring different approaches! While applying state machines or say behavior trees to games is straightforward, applying "neural networks" to games does not make too much sense: imagine you were saying "I'm going to apply Python to games": the language is important, but much less important than what you're going to do with it. However, learning as you're doing here is a good way to move forward, so keep it up! You've gone further than many people here. 

Your code is correct. What can be improved is readability and speed. First thing first, don't mix up the computation of the function and the computation of the derivative. I understand that passing to the function to get the derivative can be convenient, but consider doing something less confusing. 

Check your indentation, mostly for comments. While there are a lots of indent styles for C, none of them recommends removing the spaces after and . Using recursive functions is not the idiomatic way of doing things in C, but that's OK. It's generally better to check for error conditions before, and handle the general case afterwards. This is a good idea because the "error condition" is generally smaller. For example, if you check for case first, the reader doesn't have to remember that there is possibly an branch. This will also force you to make cases more explicit in your if/else branches. I think it's a good thing. You can write instead of . This code is too long: 

PEP8 mentions that top-level constructs like functions should be separated by two lines. Hanging indents should have only one level of indentation (lines 43 and 61). Be careful about trailing whitespaces (lines 61 and 89). I love functional style myself but it is often frowned upon in Python, and or will be considered unreadable by some, and elegant by others. Otherwise your code is awesome, well-written with beautiful docstrings and clever ( to drop empty strings, and to the call to ). Thanks for sharing! 

Why don't you ? Comments Your comments are good! I especially liked the comment of the main agent, which helps to understand the state machine. Code Tail Recursion Section 2.2 of the async paper mentions a way to define that is elegant, concise and efficient. You should consider replacing the ugly loops with nice tail recursive functions. :) States I don't like all those "in-between" states, they make your actor look super complicated and don't seem natural. I have little experience with actors, so I can't tell if this is recommended or not. 

Please don't do that! You're not gaining anything, the first reason being that it's going to fail very quickly if you really get or . The second reason is that there's no reason to get null here, why would that happen? You're simply calling this function from , it cannot be null. When not for useless optimizations, this practice is called defensive programming and is only useful in a few specific scenarios. 

If it's really frequent, you may want to check if it's going to violate the constraint before running the query. If it's frequent and you want to tell about it to the user, put it into an and act accordingly. 

It's important to think about the accessors you provide. Do you really want to allow changing the id of a ? 

First make sure the script work: proper indenting, shebang, correct logic. When the user enters 170$, you give him free shipping only because evaluates to which evaluates to true, so it seems simple to just say "otherwise, it's free". You also don't handle errors. I decided to handle the "wrong country" error, but many things could go wrong when inputing the total amount. As other said, first separate printing from application logic: 

Use offsetExists in offsetGet instead of repeating yourself? Consider using instead of null, and instead of true, even if they are case-insensitive. forgot a semicolon? Don't use return if you're not going to check the return value. 

Use logging instead of this verbose check. This allows you to log unconditionally and logging will decide to print or not depending on the configuration. The module is a bit hard to set up but is worth it. 

is not informative enough, try to find a variable that conveys that this url will let you fetch the repositories of an user. Did you consider that could contain a which would cause you to output wrong html? Fortunately, GitHub prevents such things to happen. Declare at the top of your function. Here's why. The way you're building your html string is dangerous. It's also hard to read and easy to get wrong. As Philip suggested, using some sort of template would be a good idea, but there's no way to do this in standard jQuery (jQuery templates have been deprecated, and the way forward seems to be JsRender which is not yet Beta). Fortunately, your code is not big enough for you to need that. Instead, use , and wisely: 

Of course, there are probably other optimisations, like trying to do this in a background thread, doing this only once when the user doesn't mind. If the speedups provided by the above solutions really don't help, displaying a progress bar can make your app feel like it's doing something important, which will be less frustrating for the user. 

If a specific part of the file is supposed to change a lot, then refer to Krzysztof Adamski's answer. You also need to look at the size of base64 images: storing an image in base64 takes more space than in a file since (about 33%). For large images, it can be a problem. This is where CSS sprites can help: you only use one file to store multiple iamges. If your project is going to get bigger, then you should use the module pattern and a tool like RequireJS to manage depedencies. This is explained in the Learning JavaScript Design Patterns online book.