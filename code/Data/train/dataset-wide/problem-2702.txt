Now let's see how we can start refactoring things First of all the blocks all have the same code so we can easily extract those into a function: 

I don't like the name for a class which implements an interface like . I would have named it You have made a named constant but not the quotes you strip of the parameter value. 

However between checking and actually obtaining the delegate the reference could have gone away and now you get a . You could avoid it by doing this I guess: 

As you mentioned the name is not ideal. You tried to name it based on what you know it is specifically doing but the user probably couldn't care less. The .NET framework has the concept which seems quite good - essentially it expresses that you parallelize something in some form or shape and this is probably all the user cares about so why not stick with it? There are two loops but only one uses the - wouldn't possibly benefit from this as well? I really dislike the arbitrary limits you have set on the sizes. What's the point in hindering the user what they'd like to do? The two main limitations are memory and CPU time and it should be the users choice how much they are willing to sacrifice. Memory is cheap, 64bit address space is large and CPUs are getting ever more so parallel. I would prefer the generator to be stateless in terms of the generated output. As such it should return the generated data from instead of storing it internally as a state. The only state the generator should have is the properties required to compute the output. The data generation and the image saving seem to be two different responsibilities and should be separated into two different classes. Taking the previous point into account the user would then pass the generated data to the image saver class. If speed if of the essence then should just put the calculated R, G, B values into the array rather then creating the intermediary object which serves no real purpose. In terms of image coloring it might be interesting to take the alpha channel into account as well and see what kind of effects you could get. 

You seem to have a typo in your enum, it should probably be . is initially hence you can get rid of the conditions because they will never evaluate to true anyway. So for example this makes this whole block useless: 

When adding items to a list one of the most common operations is to add them to the back of the list. Your implementation makes that an operation while it should be - so consider keeping a tail pointer as well. 

You should use descriptive names for variables and parameters. Descriptive names go a long way of describing the purpose of a variable or parameter which can greatly improve readability and maintainability. See them as built-in documentation. You have defined enums for attribute and skill names so why do you use an to add them to your object. They should be using the enum types, e.g.: 

I like that you are treating your rationals as immutable by returning new rationals from all your operations. Your naming conventions are a bit unusual. In most C like languages (C, C++, C#, Java) local variables and parameters are . Specifically in C method names tend to be or . You are using the mathematical terms and for the parameters of you construction function however you use and for the properties of you type which seems a bit unusual - why not stick to the mathematical terms? When someone passes in a which is you just have a in there. 

Instead you should be able to store the compiled delegate when setting up the mapping. Similarly it might be an option to pre-create the instance - either per (becomes a singleton) or per mapping. Given that these filter instances seem like they should be stateless anyway having them as per-type singleton might be a viable approach. In should be restricted with or else your may throw a Since in you currently can't deal with being you should not use but a direct cast instead. 

You are probably right in not using . You should prefer instead. explicitly uses the default task scheduler which targets the thread pool while uses whatever the last used scheduler was. I'm not sure you really need to distinguish the case between "I have to wait before refresh" and "I can run refresh now". The second one is just a special case of the first one with a delay of 0. Yes you may waste a scheduling cycle or two due to calling but will 20ms or so really make a difference? You have a bug: If your application runs when the system clock gets adjusted for DST the time can go backwards by 1h between one check an the next. The result will be that is going to be negative in which case you will wait up to an hour extra before refreshing (we just hit this exact bug in one of our apps recently so the pain is still fresh ...). 

As you are using a singleton which loads the document once, I would say "Yes you will probably see some degradation in performance to service calls if you only load it on demand". If your service is the one and only program which modifies the document then your approach is probably viable. A few notes: 

If all your presenters have a base class your could also add a clause to restrict the types. This would at least remove the dependency out of the presenter class. 

I personally don't like sprinkling all around the place. In generally I've found to use something like as prefix for private class members to be quite effective as a visual reading aid (like you've done for ). At least you should be consistent. It is not obvious what unit or are. You should either use to define these or at least include the unit as a suffix (like ). Generally is used for the methods raising the event rather than the event name. The event name would be without the . In your case , , . Raising the event: You have a race condition here. If someone unsubscribes from the event after you have checked for but before you call the event handler you will run into a . Either you use the new C# 6.0 feature in which case you would call the event handler like this: 

would eliminate any need to worry about this ever again. Given the current data constraints it's not really a problem but multiplying by first could yield in an overflow. It might pay off to store the scaling factor as double instead (in which case it can also be pre-calculated). Using LINQ would make the code a bit bit more concise. 

Let's look at your code from an extensibility point of view: If Sheldon decides to add a new item to the game then you have to go to classes to adjust the comparisons and winning verbs. I usually try to avoid such designs because whenever you require a developer to change stuff in places when something new is added then he/she is bound to forget one place. So how can we change the design? Well, a game seems to be suited for a rules approach especially since the rules are fairly simple and always of the same structure in this case: 

I concur that is probably not all that useful. should be Your class is called but you don't implement any of the collection interfaces. If you want to make it more useful consider implementing , and possibly . 

From a DI perspective anything which needs access to the options just depends on . If you wanted to get real fancy you could make public, add an interface for it and make take a dependency on a collection of s. Then you could register all the options you want to support in the container rather than hard coding them in . 

Modifying the loop variable inside the loop generally falls under the category "Don't do this" because it makes it really hard to see what is going on and can easily lead to very hard to find bugs. Attilio's answer already shows how to refactor this. I just wanted to mention it explicitly because it's a bad habit you should dump sooner than later. Another comment mentioned that you read in a string with but the location you store it at can only hold two characters. So if the user types in a longer string then you open yourself up for all kinds of memory corruptions which will lead to very strange program behaviour. This can be fixed by limiting the length of the string to read: (you should use because will automatically add a terminating byte). 

because it's fairly complex and it's kind of cluttered. Extracting it into a method (which should probably live in if I followed the types correctly) means you can give this an expressive name which will make the whole thing easier to read. I'm not a fan of squeezing property and into one line. I find this easier on the eyes: 

Update: One other thing to mention is that the index access operator has linear complexity. This makes your example loop: 

Can't comment on whether there is a better way or a better place in the framework to do this but some general remarks: 

I think @Maxim's answer should yield a reasonable improvement and as mentioned in the comment you could pass in the object directly saving a call to every single time. One consideration not mentioned: If actually returns all s in a non-lazy fashion then you'd be better off putting the into a keyed by their id and performing the search in a single loop by either using a stack or a queue (depth first vs breadth first) 

I don't really think there is actually a need for the helper class - I would have added the factory methods to the . I don't like that you use two to track two different values for the same key (one for the timeout and one for the actual value). A better way would be to encapsulate that into a member class which is responsible for tracking the timeout. 

Now the bigger picture stuff: The main issue with your solution is that your UI and logic are very tightly coupled which in general is a bad thing as it makes it hard to re-use the current game logic (try making a text console, winforms or web version for that games) and also not very easy to unit test. One very popular pattern with WPF application developers is the MVVM (Model-View-ViewModel) pattern. The basic idea is that you have a model which is completely agnostic of the UI and the UI just observes the model and it's changes. IN WPF this is supported by something called binding where the UI "binds" the controls to the model which alleviates the need to manually push the data from the model to the UI. It's a big topic so I won't spill out all the details and it would be a fair amount of work to re-work the code according to it but I would encourage you to do so (could make a great series of code reviews here). There are heaps of excellent articles on code project and lots of assisting frameworks around (although you don't need a framework to follow the MVVM pattern).