Edit: This is of-course personal taste, but I dislike (what I consider to be unnessary brackets taking up newlines). 

Because the TryParse method returns a bool you can just use this in an if statement which is conditional on the TryParse returning true. 

Separate your main-loop logic from your main menu rendering logic. You should have a main-loop, which calls recalculate, and draw, then in your draw you should draw the appropriate menu, based on the games current state, the logic should stay in its own class away from the main-loop. 

Now the succeeded value is available after the method returns, and will only be true if all values past the test, and now there is no nasty exception throwing, which hurts your application's performance and is just bad practice. You can call the method like this now. WITHOUT a try..catch surrounding it 

Static methods on RPNStack It is odd to write a class like with all static methods and fields; effectively, you have a single global stack, for no particularly good reason. The obvious thing to do would be to make all of those methods and fields instance methods/fields, and then create an instance of within . Output It isn't clear to me why would not be working for you where does; however, you aren't closing or flushing the file, and it may be the case that some subtle difference is causing the file to be flushed in one case and not in the other. I would expect that if you close your at the end of your program, it will work fine. Recognising symbols The obvious and lightweight way to recognise a small set of symbols like this would be to use a statement. If you have Java 7+ (which you really should) you can just use strings directly as labels; otherwise, you'd have to switch on characters (which would still work for your simple language). For a more complex language, you could consider a map from symbols to actions. Error There are kinds of errors which won't be caught by your . But I don't think you need to worry too much about those. The only bit of error handling I would consider adding is that it's possible for the user to enter an expression which causes a divide by zero error. As your program stands, this will throw an and terminate the program. I would suggest either catching the and recovering with an error message, or validating the operands you're passing to the division operator. Minor nitpicking 

Use Statements.... Or not, if not... this is probably as optimized the code is going to get. Here is my rendition of what your code will look like if using switches instead. I just switched the regular flag enums, although you'll probably want to bitwise OR them with the rest of the values as you were doing in your OP 

You could just combine the logic into one statement, assuming there is not other things occurring during your if-else blocks and stuff. If there is, then this won't necessarily work for you, and you should post the real code, because a lot of times these problems are subjective to the code. I guess one lesson to possibly learn from this is just to realize the end result, and build a condition that matches the necessary conditions to do something. 

} And finally we have a model which loads & saves our data from Repository to Database. Here is how would look like: 

Here is the question: As far as my understanding goes, we are directly declaring, that under our expects in it's constructor , which is afterwards used under all functions under that particular class. Currently this model is communicating with the database, but if I wanted (for whatever reason) to change this model to save data in the XML file, I would have to completely rewrite all my classes? Or am I missing something here? If I am wrong and it is easily doable, could anyone show me how to change the code so that we are serializing values into the XML files, please? I am trying to better understand this Repository Pattern, yet for now it's one big chaos for me. Any help / suggestions regarding this matter would be highly appreciated. 

However, now that you have actual code to review, I will also point out that there is no reason to be using a loop vs a loop. I would write that as follows. 

Yes... there is a simpler way. You have two choices, but each about the same. Use an Array, or a Map. The more advanced way of doing this would certainly be with a Map. Think about a map as a type of array where instead of using an integer to index the array you can use anything. In our case here we'll use char as the index. Because chars are ints you could just use a simple array in this case, and just mentally think of 'a' as 0, but we're going to take the larger step today. 

Your program is a bit flawed. Technically just 0 is a subset of {0,1,2,3,4} however you appear to only care of subsets of 2 or more numbers. 

Producing sample output on STDOUT, according to a command-line "count" parameter (this is not nice code, it's just here for reproducibility). Obviously, the performance of the filtering algorithm will depend not only on the number of sets, but also on the number of possible different names from which the sets are drawn, and the size of the sets. Smaller numbers of names make some approaches pathological; larger sets create more work for most approaches. Original program Your original program did not run as-is---it seemed to rely on a few parameters provided elsewhere, and a particular directory structure. So I modified it a little to accept a filename as its first argument, and output to STDOUT for easy testing. I also moved around the manipulation of the variable, as that seemed to either have the wrong indentation or be in the wrong place. 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

Contact and ContactItem should in some way be child and parent, or at-least share a common ancestor so that you don't have to manually copy over all that identical contact information. I'm not certain, but I think you might have wanted all this to be done with the and not the of this contact. You should be using in-case these strings haven't been trimmed or something. As for simplifying your nest of ifs there are two solutions that fit the program as is. 

I am now developing a product, which will use & Repositories when it comes to data management. I will demonstrate on a simple example. What we want to do, is to create an app with calendar control, where user (e.g. manager) will be able to store holidays for his employees. First define our models: We have a class which looks like following: 

Is this a good way how to implement repository in my application? Is it a good practice to do conversion the way I have presented? 

When I started learning Repository Pattern with Unity few days ago I was under impression that the main benefit of this pattern is the separation of data layer from the business layer. In other words, if there is a need to change the way, how application stores the data, it's very easy as only one main model takes care of the communication. This means, that if application currently saves data into a serialized XML files, it would not be very difficult to change this logic to connect to database instead. I have found few nice demos that are also using layer, which seemed very handy. Let me show you a bit of the code I have. 

From the tenor of your question, I'm going to just give some high-level suggestions of approaches you might use to make your code simpler and more manageable, rather than an in-depth line-by-line review. Performance You expressed a few concerns about performance and mentioned design decisions you'd taken for performance reasons. I wouldn't worry about parser performance too much: partly because premature optimization is sadness; partly because in this kind of application, parser input is generally small and parsing is relatively infrequent; and partly because optimizers are generally quite good at optimizing well-structured code. Unless you are using your calculator in some surreally absurd way, parser performance is not something you should be worrying about. So I would suggest that you not make your life more complicated for the sake of performance. Parsing balanced expressions You have a lot of special-case code and state flags to handle being in particular parts of the expression (like , various checks that is a particular kind of character, etc). All of this stuff would be easier to manage with a less ad-hoc approach to parsing. A recursive descent parser would probably be the easiest approach to get started with, but generally thinking about the grammar of your input language and looking at "standard" approaches to parsing should lead you in a helpful direction. I'm sorry if the above seems a little vague---it's quite a large and broad point. But I would suggest you read up on parsing. Parsing numbers Numeric literals (in every context I can think of, and certainly as you have implemented them) form a regular language. You will probably find that the easiest way to parse them is either to use (simple!) regular expressions, or an explicit state machine. There are a number of standard implementation techniques for implementing finite-state machines; the state pattern is one obvious choice, although for a language this simple I would consider a simple conditional/switch statement implementation. Input representation Your parser currently expects to be given a string which exactly contains a literal. This means that you effectively have to parse everything twice: once to determine the boundaries of the literal, and once to determine the meaning of the literal. This has a minor performance impact, but more critically, means that you have to smear multiple versions of your parsing code all over the place. I would expect that you would find things more straightforward if you allowed parsing functions to greedily consume as many characters as they felt appropriate from a "stream" of input characters (either an actual stream, or some arrangement with string+offset, with each parsing function updating the offset). It should not be too difficult to arrange your language such that greedily consuming characters is always correct (although you might need a few characters of lookahead). Evaluation You have a little throwaway comment about an evaluator that takes a String and produces a String. I suspect it would work better if the evaluator took either a string or a parsed representation, and returned some richer object as a result (e.g., a `Literal). Character identification You have a lot of code like "c == '{' || c == '[' || c == '('" etc. I expect that you would find it easier to work with sets of characters, either represented using Java , or, for convenience (with small sets) strings; then you could just ask . On a similar note, a function like that returned for , for , etc. would simplify various things.