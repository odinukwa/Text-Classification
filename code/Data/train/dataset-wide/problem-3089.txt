Your isn't needed - one can interleave reading and writing. Letting take its argument by value, this is just: 

I'm making a fair few assumptions about the internal format that may not be justified, but this works on the demo data I tried: 

I don't see how to speed it up further, but this should be a 2x improvement when staying on CPython and a 10x improvement if moving to PyPy (an extra 5x from the better interpreter). 

First, put everything in a function. This makes the variables local, which makes lookups a little faster. It's also neater. It's worth formatting the comments with line wrapping and putting them in front of the commented line to keep lines short. is never used except to iterate over, so just iterate over instead and ditch . In fact, at point of use it's simpler to just call : 

would result in , resulting in running , which overflows. This doesn't just happen with either. The simplest thing, then, might be to flip to positive after casting to . One can also simplify things by removing , then, in favour of some fiddling with like: 

Then you should split into two arrays, which I'm tentatively calling and . They can be initialized as 

just tracks . Remove it. is recursive but it doesn't need to be. Try making it a , and make it its results instead of saving them: 

Let's fix the easy issues and move it to neighbor the only place it's used so we can revisit it at a more appropriate time. 

I would also personally remove the (and ) prefixes unless there is an actual ambiguity. I would change to . Ignoring error handling, this gives: 

Note that these are very hand-wavy thoughts and I haven't tested them for efficiency or even effectivity. It's possible this algorithm would be rather slow at reaching a solution or would get to a close solution and then stop. It, however, seems like a sensible option. The main problem with fast convergence with the original solution was its convergence; imagine something like 

Checking for prime numbers isn't something ideally done in one particular way. Depending on what you're doing, lots of different techniques make sense. 

Namely, prior movements won't cause unwanted collateral damage since no move will be independent of other point's requirements. Again, just rambling. I've not based this off of any paper nor any trials of my own. It just feels appropriate. 

The second can never run since the condition is the same, but it doesn't matter as the body is the same too. Just remove the . The same thing happens again with . Are you sure you understand what does? This simplifies the first function to 

and your old function is equivalent to . is slow. Luckily we don't have to do it; we can get a random sample by using an array and just swapping the used elements to the end: 

you are doing several non-idiomatic things. For one, you are mutating and returning a list. It's better to just not return it if you mutate: 

since in Python. I suggest doing so since it makes the action self-explanatory. This could be better with formatting: 

Instead of your timing code, I would have used . It's built-in and far simpler to use. For CPython I would also sometimes use , which gives line-by-line timings. In other words, it's the best thing evah. I would use the utility to get a time of the whole code when fine-grained times aren't needed. These get rid of a nontrivial portion of the code. I would be very careful to stick to PEP8 spacing and add line breaks where they help. Your code is too dense. I would extract the grid printing code into another function. shouldn't really be returning things; stick everything under into . will only ever return exactly one solution, so there's no need to return a set. Further, 

where the is represented with . We want to find the collatz number for . The original method would find this list: 

Move things into separate methods. does not need to contain a lot. It seems buttons don't need a call; you can just add an in the constructor. I would consider explicitly making phases where you declare what boxes are where and what contains what. Your is a "confused" function, and its name doesn't really explain its functionality. I would separate the actual core behaviour (which is buggy for negative numbers) from generating a response. This is more reusable than just adding CONSTANTS, and it's cleaner. Here's a cleaned up version: 

Let's face it, what you really want is to know how to write your Haskell code in Rust. You can do a far more direct translation than you've shown. 

This way it is easy to read as " is between and OR is between and ". Even better would be to write : 

Your tests cover the general case fine but they don't check edge-cases; what happens with 0-length inputs? What about complicated patterns? Do you ever check precedence, despite having mentioned it? 

or any other semantic equivalent (take your pick). It's potentially better to just reorganize so you don't have to: 

looks really backwards, though; why not just put this in a simple data structure? Why does it have to be through messy attribute accesses. 

The first two points are not good reasons in Python. See for an example of something that just offers a large number of arguments. The caller does not have to specify them all since most are default arguments. The last option does happen, but it is more akin to typical OO abstractions. And as usual with abstractions, premature abstraction is bad. In this case (in isolation), just offer the arguments directly. 

In , you shouldn't need two checks to determine if the human cheated. Namely, the first seems unneeded. I like the use of a higher-order function with . It's very elegant. However, don't abuse it; should not be running the game; that logic should be in . It's unfortunate that you don't get an indication that you lost, or if you lost due to being caught cheating. This would be easier to sort out if more was in and not in the respective classes. You only use each method of in one place with these changes; it makes sense IMHO to make these functions on tuples of digits to remove the need to create classes. This makes things a little cleaner. It also allows one to speed up further. You don't validate the user's input in . also shouldn't be in the business of saying ; that should be game logic. Using to shuffle in-place is fancy but it isn't good. Just use on another line. This all gives: 

The version taking is clearly the nicest; the version which always chooses the lowest is only really better if speed is actually needed. There's no reason to force at least two parameters. Just use and default to . It's simpler and nicer. is just . is horrible and should be avoided - it's not even more general and it's all stringy. Note that is just is just . Further, you should really have a function, not a comparator, so you can do stuff like 

This is a worst-case total of 118 calls to and 49 array lookups, which is extremely fast even with an inefficient method to calculate the area. 

since files are iterable. This will prevent the need to hold the whole file in memory. Also, prefer to . is a good variable name if it is uniformly increasing by a fixed amount each iteration and its use it obvious. In this case, that isn't true. Something more descriptive like . Note that that would imply reducing the count by 1 everywhere. However, the count is reset every loop iteration so the check is always True. Remove the variable and check. You repeat this three times: 

Thus no allocations are needed, and the user has no difficulty allocating their new merged result or just looping over it if no intermediate is needed. To back this idea up in prior art, we already have APIs for sorted slices. This would just be another, so to speak. We'd really like to write this in terms of a generator. Eg. the Python 

However, Rust does have unstable slice patterns, which you can enable on the unstable compilers with 

This is unfortunate; this argument overrides the others. I would personally instead create a separate convenience function: 

This is a carry-on from alexwlchan's answer, since he fixed some bugs. As far as I understand, this is wrong: 

This would be prettier if your axes were in the other order, as the s and would be implied and you'd just do 

There isn't much more to do to this algorithm because it's just a worse version of the original (I'm curious as to why you thought it'd be better). 

Instead of generating in and , elements sequentially from them. Turn them to lists at call-point if needed. 

Your imports are ordered in reverse. Typically one would have them alphabetical. It seems to me that should abandon and instead , which seems logically immutable, should get a . This way you can use as a more logical alternative to . This does, however, require both a and an method on . can just ; using is overkill. can be a ; I encourage this because it gives free immutability and is pretty convenient to use. I would do an explicit check 

is reserved for constants, and your globals assuredly aren't constants. If you wish for a cleaner solution, you could possibly make a class and pass in instance methods to . Your final seems unneeded. You can use instead of slicing. It's hard to give more detailed analysis without a better understanding of what the code is trying to do. 

You shouldn't inherit from builtin data types - there's a type that's more appropriate. On top of that, you probably shouldn't inherit from either: your code is not a and doesn't fill its contractual obligations. This is a time to favour composition over inheritance. Before I look at implementing this, here are a few quick things I noticed. One is 

The is redundant with the check. Remove it. Further, you don't need any of the checks anyway; the cost of doing them exceeds the benefit, at least after moving to lists of integers. You might need to change to a set. Your 

This will require you to make or arguments to several functions that currently take it from the global scope. Your function (renamed according to jonrsharpe's advice) is badly named: the name tells you little about its functionality. You never use it, though, so just chuck it. Personally I would remove and inline . It doesn't give either clarity or succinctness. When returning a tuple from , you don't need brackets. If is now 

After all of the comments on , I'm sad (happy?) to say there isn't much to talk about with the rest of it. I would remove the comment, though. 

Your will have to change since is not comparable, but it was flawed anyway since the were all initialized as . Since the strings are all of the same form bar the numbers you added to them, you're actually just finding the largest index (although since you're doing string comparisons it breaks for bases larger than 9). just do 

The name should also be improved to, say, . Same with (I chose ). Now in , remove dead comments like 

Namely, we add 4 to A and subtract 5 from B, which means we add 4 and 5 to the difference. We should also check for empty arrays. 

is not a class. That doesn't change by just adding the token in front of it. You could argue a might be a class, but why would you make it one? The sorter has no state! Only the sort itself has state. You might mistake 

For a more thorough review, I'll point out that your functions aren't equivalent. The first strips whitespace and the second doesn't. One of them must be wrong! In the second case: 

So there we have it. Python is over an order of magnitude faster on 75% of interpreters, and under an order of magnitude slower in the worst case... But why is it so slow with ? is a good utility: 

for state, though. This is a very bad idea. is an input argument, whereas and are locals. Pass them around as function arguments, because that's how they're meant to be passed around. Faux-pas globals are much, much worse. Just make functions, doing function-y things. It'll be cleaner and better express the intent. 

in Java can you really call this worthwhile? You end up fighting the language most of the time. A simple 

plz no allocate Using the above means we're stuck allocating 64k for each stream, even if there are many streams or the stream is line-buffered. The first can be solved by passing the buffer into the function. The later can be solved by resizing the buffer up to some hard limit from a small size. DRY Note that there's still duplication between the and branches. One could solve this by writing a wrapping function to extract this functionality. 

does nothing, so should be removed. It's also impossible for it to happen. Now I tidied up the next loop: 

's docstring needs indenting too. Personally I'd use for a circle; it looks much rounded and easier to distinguish. Your comments for 

so you don't need the comment in the first place. Then there's . So I wrack my brain thinking about what word contains . But it turns out you just meant to write . What does that have to do with the letter ? Worse than that is when you outright lie. What would you expect the variable to contain? A node, right? Nope - it contains the total number of nodes. And you write 

should be wrapped; the line is too long. It's very strange you build the result with ; normally I'd expect one to return a of some kind representing the path: a list of s perhaps? It doesn't seem very general to do it any other way. You call a lot; surely the simpler way than generating all of them again is to have the board represented as a graph which is pruned as it is traversed. Each cell in the grid would be a count of how many of its surrounding positions can be moved to, or if it itself cannot be moved to. Since you only need to store up to a small maximum for each cell, this wouldn't even need to cost more memory. Comments about what does would be advisable; as it stands it's completely opaque to someone like me. 

and similar for a few other function calls. You also don't have spaces after the comment hash (). Other than that, the style is reasonable. You use to open but you neglect to do so for . Don't; put it in a . Many of your comments aren't very useful. Consider 

These are on top of 200_success' suggestions because I agree with them and there's no point me repeating them. You don't need to write in the tests if it does nothing, so remove that. I find this very confusing: 

Some quick cop-out comments, since I've not taken the time to actually understand what's happening here: One thing I just happened to notice is the classic 

Note that even this is suboptimal since we recompute the same stuff on every call to , but fixing it is less simple. 

is \$\mathcal{O}(1)\$. Performance elsewhere is probably uninteresting, since it devolves to basic integer operations. Extending to other should probably be done by being generic over the and traits, as well as whatever particular operation is needed to implement. Something like