The details, descriptions, references and specifications you provide with the request is essential if the reviewer is going to give a decent review. On Code review, the process continues with: 

Generics Java by convention uses a single upper-case letter to indicate the Generic type. In this case, should be ....: 

Logging in Java often is tied to the class that the log message is called from. For example, the Logger is created with a name of the class as a constructor/key. This means that the logging of the exception may/will be logged with the name of the ErrorHandler class rather than the class that threw the exception. Depending on your circumstances, this may be a problem. Logic flow in situations like this are often complicated by the return types of the class. For example, your code may look like: 

Utilities You have done things really well, in one sense, your use of try-catch is extensive, and you are closing streams in the appropriate places ... but, (this one will make you cringe)... have you read up on the try-with-resources functionality in java7? Actually, in this particular case, you will likely be well served with the new-in-Java7 class (Javadoc) As far as I can tell, the overwrite flag makes no difference in the saveFile.... I tend to force a charset for all files. This may not work for you, in which case you can remove the StandardCharsets.UTF_8 arguments, and rely on the platform default, but this may mean a file you save on one computer creates garbage on another. Rewriting your Utilities class: 

In general I feel like you are trying to do too much in one class. There are two different parsing systems you have - parsing CSV to strings rows/fields, and then parsing some of them in to numbers. You should separate those two systems out in to discrete places - in the more complicated use-cases, you will guess wrong, and in the simpler cases, the programmer can easily implement the number parsing anyway. By conflating the two parse operations you have lost the value of the generic on the rows, and your API is a lot more complicated than it needs to be. This is a case-in-point, and illustrates all the bad things: 

Now, having stripped the complicated exception handling from the main part of the code, the rest becomes significantly simpler.... A second method would be useful for converting a document to a map of translation elements: 

OK, that's the right way to use the Scanner. Further Improvements As your program expands, you will find that there are a few things that become 'uncomfortable'.... the number of operators will increase, and the complexity of the calculations will increase as well... eventually you will want to enter expressions like to get the percent score if you got 17 out of 20 in a test.... etc. What you have at the moment is great for it's purpose, but I encourage you to try to find ways to expand on the idea. Research you may want to do is in to things like 'Reverse Polish Notation (RPN)' which is an easier-to-parse format for writing mathematical expressions. Then you can look at things that help you convert Infix to Postfix (RPN) notation... In order to do these more expansive operations you will need to find ways to turn operators in to classes (probably an Enum), and have classes that allow you to encapsulate an expression (unary or binary expressions). Good job on this, otherwise. 

Your code uses streams quite neatly and well. The algorithm employed is not necessarily the best, but the logic is reasonably clear. It's common with streams to use vertical white-space to make the steps in code more readable. For example, the line: 

It is still probably too busy, but you can at least see what's going on now. Note how the user is prompted with valid values before they are entered now: 

I am really uncertain about the right-to-left characters.... should they be transformed in the same way as the left-to-right ones? You're the expert on that one. Still, you get the idea.... 

Your assessment is correct, the null checks are redundant in that block. I would recommend that you use the "FindBugs" tool to perform static analysis on your code. It is available as a plugin to Eclipse, and other tools too. FindBugs would clearly indicate and mark all instances where these problems happen, and also a bunch of other things too. Additionally, I would neaten things up by pulling just one final local variable for the too. Additionally, you should be using generics, and enhanced-for (for-each) loops over your . Summarizing this would be: 

There are a few things that are problematic with respect to the actual randomness of the numbers. First up, while this should not make a difference to the "randomness", you should rather declare your instance as a static field. See RandomNumberGenerator This will prevent having to create a complicated construction process each time you need a PIN. is thread-safe. OK, there's a bug in the mechanism because it does not handle correctly (See: Math.abs(...). It would be better for you to do a simple bit-zero of your high-byte to unset the sign-bit: 

The concept seems fine to me. The problem is that you will still need to decide whether to decorate, or not decorate the function, and that is done outside the function. That makes it a once-per-create decision, which is OK, but you may still end up with a lot of conditions in your code: 

Note that I suggest using the class. The Objects class simplifies and methods. I do a bitwise XOR on the hashcodes of the two values, but at most one will be set. Note how this class would be used (a RuntimeException declaration will not need a throws clause, or a catch block).: 

On further reflection, the looping example above (as opposed to the streaming one), will be faster because it does not do the String regex, etc. and does not have an intermediate String value. The same logic in Streams, with 'continue' type logic, would be implemented with a , but we could/should also avoid the toLowerCase...: 

Introducing the allows the simplifcation of other variables too. Now, having said all that, your command could easily be solved with the command: 

Now, whether this improves the performance enough, is uncertain, but it is more readable, and will be faster. There's probably a smarter way to do this too, a better algorithm is normally what's required with Euler problems. 

In the event that you have word of more than 31 characters, you can swap to using long values. In the event that longs are not enough, use a bitset.... but you probably wold not have enough memory for that anyway ;-) 

Edit: Based on the benchmarks for my browser (Firefox), a decrementing while-loop is much faster than alternatives. I would use: 

That will extract just the MANIFEST.MF file from the zip archive, and output it to standard output. You can thus skip the whole temp-dir process entirely. 

This type of practice is common, and works well. The Java JIT compiler will identify the as being a constant, and will know that it is always false, and thus will the logging entirely. There is a slight performance hit on any code that has not (yet) been compiled.... but, once the compile has happened, there is no hit at all. It is relatively common to use a System property to determine whether to log... 

So, I set out to suggest why your solution was a problem, but then found that it worked better than I thought. This intrigued me, so I set about understanding your solution, and, bottom line, you do text-break-processing on punctuation and before-consecutive capitals.... Essentially, you split the word with spaces between all sequences of characters, and then you also add a space before the capital of a Xx combination, and before the capital of a xX combination (or both). The process you are using, though, is really ugly. Regular expressions are a better tool for the job. They may be hard to understand, occasionally, but they 'compile' down to what are called Deterministic Finite Automaton. So, your code does a lot more than the description, since it can deal with space and punctuation separated words (i.e. sentences), but it does it in a way that is slow, and requires intermediate results (a space separated string), which is then post-processed to words. I took this system, and implemented it as regular expressions as an exercise myself: First, I compiled two patterns, one to split the content in to words, the other to split the words in CamelCase, etc. 

Sometimes math can be confusing, sometimes it can help, but, using some math, the solution to this problem is: 

It follows that, to test if any number X is prime, you only need to find 1 prime number less than X which divides in to X without a remainder. There is no need to test non-prime numbers, because if a non-prime divides cleanly in to X, then the prime factors would also divide in to X. So, if you keep a record of the previously calculated primes, then you only need to scan those values to see if they divide in to X. In essence, each time you print a prime, also add it to a list. This will require 'seeding' the prime list with the value 2. A second optimization is that a number X is only prime if it has a factor. A factor is a number, multiplied by another number, that is equal to the original value X. The useful theory here, is that, as the value of the first factor increases, the value of the second factor decreases. There is a point when the first and second factors 'cross over' and the second factor becomes less than the first. The cross-over point is the square-root of the number X. When you pass the square-root of the number, you have tested all the possible factors... there's no need to scan values larger than the root, because, if they were factors, you would have found them already by identifying the small factor that matches the larger factor. Putting these two items together, you should modify your code to: 

I am not suggesting that this is a good solution, just a better/faster solution. The best/fastest solution would not create two string values for comparison, but would leave the values in their native integer format. Secondly, why do you have 4 diagonals? You should be able to get by with just 2 (since there are only two of them). I have not been able to get my head around this problem quickly enough to understand whether there is a particular use-case requiring the 4, but at face value, this means that you are double-checking your diagonals. While I understand that you are trying to get a handle on generators and comprehensions, a more simplistic approach to this problem would be more efficient, and probably more readable. The standard HPC (high-performance-computing) method for this type of problem is to create a logical box that spans the problems space. In this case, the box would be 4 by 4. You then create a cursor that traverses the problem space, where the bottom-right member of the box is on the cursor. You then test that box for a vertical line above, the cursor (if there is space), a horizontal-line to the left, and the two diagonals in the box. This type of approach is easy to multi-thread or distribute. There are ways to make the memory access more efficient as well by splitting the problem on clever boundaries when parallelizing. But, what you want to avoid is generating values for each movement of the box.... 

Your code snippets are interesting... both of them. The second is interesting because I feel it is your better-executed system, you used an interesting bi-directional approach, and it is efficient. The first is interesting because I prefer the in-place solution, but your implementation is kludgey.... and hard to follow. Temp-array solution Notes: