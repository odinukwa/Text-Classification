In terms of areas for potential improvement, reviewing is made somewhat difficult because of the nature of the made-up requirements this code is fulfilling. To demonstrate why, here's my train of thought: It's not very realistic that you always want to get all this information together, so the first thing might be to think how to extract each piece of information individually. The first step in doing this would be to extract out the individual counts into their own methods, like: 

This is a generally good solution. Pretty good adherence to naming conventions, and generally quite easy to read. It's probably just fine as it is, but if you do want to make it better, there are some improvements that can be made: Extracting the outermost method First off, we have: 

Generally, this looks pretty good. There are a few points to make, but it's worth first saying that because this is such a simple problem and solution, some of these may seem a little pointless. I'll try to flag up when this is: even if they're pointless in this extremely simple case, things don't need to get much more complex before all of these are very important! 

A side benefit of this is that you're no longer expressing the business logic that a discount can't count for both all brands and all categories. This method consumes discount rules, so it shouldn't have to be coupled to understanding the business logic behind how those rules are created or validated. That's likely to be expressed somewhere else, so this is a form of repetition. Along similar lines, we can refactor this to follow the Tell, Don't Ask principle by moving these method into the class. That class should have a public method, and the and methods can be private methods on . It makes sense for the rule to responsible itself for saying whether or not a product matches it. 

All of this makes reading the code just that bit harder than it should be. On to the main point: To me, this looks like it's screaming out for the behaviour to be moved out of the current method to the filter class. Classes, after all, exist as containers of related data and functionality, and what's more appropriate functionality for a filter than to do the actual filtering? So I would suggest that you create an interface like: 

Separating Responsibilities As I said before, you have two pieces of functionality. The first is given by these lines: 

The first line matches when a factor is found, the second when no factor is found, and the third when the collection is empty. Note how matching on the collection makes it very easy to recursively loop through it by matching against . This helps avoid your issue of looping by index. Now that we know how to find the next prime factor, it's easy to find all of them: 

And there you have it! Of course you wouldn't really include those comments, those are just for in-line illustrations of how directly each line- in code- corresponds to what you're actually trying to do- in English. The fact that each line so clearly describes what it's doing without comments is a sign that you're on the right track. 

Or similar (apologies for any syntax errors with the above, Java isn't my main language) Expressive names The names are generally good, but there are places where they could be more expressive. In , and seem like they should be the other way around. Once those get passed to , they should definitely be interpreted as the more meaningful . Similarly, in doesn't tell us much. I'd suggest , but this would be a bit confusing between your 0-indexed array and the 1-indexed actual question numbers. So would probably be a good compromise. Magic numbers Another minor one for this particular project, but generally a good habit to get into. Instead of hard-coding magic numbers and into your methods, these should be put into constants with expressive names. In fact, the 8 could instead be taken from the length of , so that you're not expressing the same information in two different places. 

As always, before you ask "how do I do this?", you should ask "has anybody already done this for me?" 

Then you can just call at the top of methods which need that validation. Using Exceptions Your approach, using an exception in the case of trying to perform an action between points of different dimensions, is good. But what you've written about it is actually a little contradictory. So trying not to move too far outside the realm of a code review, here's some advice about how should use exceptions. As a basic review of exceptions, when an exception is thrown from a method, that method immediately terminates and it is passed up to the next method in the call chain (the one that called it), and continues being passed up until it is caught. So let's say I write a method which calls , and I know that can throw a particular exception. My options are more or less as follows: 

Integer parsing It's generally considered bad to use exceptions in normal control flow. That's what you're doing here when you try to check whether the text in is a valid integer or not. An alternative, which you may not have known about, is . This method is designed for this exact situation- where you want to check whether a string represents an integer, but don't want to throw an exception if it isn't. This allows you to get rid of that and clean that bit of code up a bit. Simplifying statements If you ever have an statement which reads: 

The name doesn't make any reference to the fact that it's specifically for a time interval within a day. Why not ? 

Formatting It's important to pick good conventions and stick with them. One guideline is the language. For example, in Java it's conventional to put curly braces on the same line, rather than a new one (like I did in that example). It's also conventional to use variables without too much abbreviation: rather than . Make sure you're consistent with your indentation too, as that's one way the eye quickly gauges control flow. 

Is the comment because it's not clear what "balance" alone means? Then change the variable name to and lose the comment. State consistency The problem description requires being able to do things with both the monthly and annual interest rate. However, that does NOT mean you necessarily need a field for both of them. As it stands, now has a requirement for being in a valid state: It much be the case that = . It's not inherently a problem that your class has a requirement like this. They are referred to as invariants, and as long as you don't publicly expose anything that allows any calling code to break it, it's fine for a class to protect its own invariant. In this specific case, though, it's not just an invariant but also a DRY violation- you're representing the same knowledge in two different places. It would be easier to just store a single version of the interest rate, and have a private method to translate it into the other version when needed. This reduces the potential for bugs, since you aren't always having to update two values when you really only want to change one thing. Note that you do already have bugs of this form: the constructor only sets the annual interest rate, and only sets the monthly rate. Naming Your naming is generally good, but you switch between and arbitrarily. You should drop the underscores. Also don't automatically add "set" when it's not needed to a name. is a strange phrase, and would be more natural as or . I'd also consider renaming . implies it's going to give me back the answer to some question, but actually it's changing the underlying state. Something like or even might be more expressive. Separation of Concerns You generally do a really good job of separating out concerns, the only place this falls down is in the method. This should return a string rather than printing to screen. That way your doesn't care about what kind of IO you're using, and you could just as easily use the same class save that information in a file, send it through a webservice, email it to someone, show it in a GUI, etc. Misc 

Note that now I've removed from the name- it's now the responsibility of the passed in to decide if it's unique or not. I'll leave implementing for your 'color offset' version as an exercise, it should be straightforward. 

Gluing it together So that's a bunch of methods! But now putting it all together is very easy. Let's look at how they'd work in . First, I'm going to fix the thing. This is pretty confusing, as it's never used. Instead I'm going to have the time elements actually passed in and used. 

Note that as well as pushing the logic to an existing .NET class rather than trying to do it ourselves, we also: 

Is bad. is already defined on , so by declaring an abstract version here, you're not overriding, you're hiding. This is far less frequently done, and for good reason- it breaks our basic expectations of polymorphism. You should only do it with good reason, and you don't have one here. Just get rid of the redeclaration, it gives you nothing. 

Now instead of many very similar methods, we have one parameterized method. We've cut out a lot of repetition- all the aspects of the messages which were the same every time were being repeated over and over. This principle of not repeating information is called Don't Repeat Yourself. SRP You know what would make your game great? A graphical interface. Well, okay, maybe that's a more than you want to add at the moment. But what about a menu like in many keyboard-controlled games where instead of everything having a number, you have a current selected item in the menu, and you can move up and down, then press enter to select? Or, I dunno, maybe you want to highlight some words in different colours, or have the player type words rather than numbers or translate the game to Spanish. Maybe (in fact, probably), you'll never want to do any of those things, but the important point to notice is that all of those are to do with how you present the game (get input/output), and none of them have any impact at all on how the game itself works. In reality, the rules and logic of your game are completely separate concerns to how you want to display your game. But in your code, they're so mixed together they'd be extremely difficult to pull apart. Any of the changes I mentioned would require changing almost everything. So with this in mind, let's look at how we might print our club selection menu: 

And at that point, you're done. Again, what you've written now definitely adheres to OCP- there's no situation in which you'll have to change that class. Unknown requirements are kept in the realm of code you haven't written yet, and design you're not locked into: 

While it's much more likely that you'll add to rather than modifying either of those methods, even simple controller methods may be refactored. For example, it's quite likely that you'll want to add paging, which will mean refactoring . Unit tests could be valuable there. Mock commands, not queries You may have heard of the idea of "command-query separation" (CQS). To quote wikipedia: 

What you lose in automagicness you more than make up for in clarity, conciseness, verifiability, and performance. You can of course use a method somewhere instead of a lambda, to avoid spreading the mapping info all over the place. If you really need this functionality (e.g. because there are lots of types, most of them can map to each other, and you don't feel like writing n^2 mapping methods)... well, that seems like an unusual situation, and I'd start by taking a step back and asking if this indicates a broader architectural problem. But if you've satisfied yourself that it's sensible, then I'd suggest using a library like AutoMapper rather than trying to roll this yourself. That way you don't have to concern yourself with how the magic works, and you get something much more mature and fully-featured (and, probably, performant). 

Since strings compare alphabetically, it's easy to imagine a combination of two strings and a fraction which would compare inconsistently. e.g.: 

With this method, there's now no longer any need for the methods, and so now there's no longer any method that needs to be on and so you can remove the class, just using a instead. Renovating JobList The above would be my suggestion, but it's based on certain assumptions. What if is called in multiple places? What if really does perform better and that performance is critical? What if there's some additional logic or validation which that class could usefully handle? In those cases, you may want to keep . So instead of deleting it, here's how you could improve it: 

Let's start with the inside . You have the right idea, but it's complicated because you're flattening two loops into one: looping over the primes, and looping over the factors for your target number. So let's do those one at a time. First, let's create a function that finds the next prime factor: 

This reduces the amount of code to write a bit more, and it helps remind people to use it by being on their intellisense. I'd say it's somewhat a matter of judgement whether this is more or less readable than the helper method version. It is also less flexible if, for example, you need multiple different explicitly resolved resources inside a single factory method. But, as far as I can think, this kind of approach is likely to be the only fruitful way to achieve what you want. UPDATE Another alternative using the decorator pattern, which allows you to deal with multiple explictly resolved services by decorating the kernel: 

Most of this seems good, so the points are relatively minor. Conditional order Your conditional statements are written like or . This style, with the variable on the right, is a trick from C/C++ designed to prevent accidentally typing and doing assignment rather than comparison. However, in Java, there's no need to do this, because if you typed inside a conditional statement, you'd get a compiler error. Using a C idiom in Java is confusing, and means that any Java developer reading your code is likely to have a bit of extra cognitive friction before they can parse what's going on. That extra difficulty in translating between code and what you actually want to say leads to bugs, like: 

Doing the above uncovered something else: you swallow the exceptions most of the time, but somewhat arbitrarily expose the last one as an inner exception if you fail. This does make sense on the assumption that the exceptions will always occur for the same reason (e.g. timeout), but you might consider using an or similar to expose all of them. 

Loop logic There's definitely something strange going on with your looping. Why do you have so many checks on equalling zero? Why do you ask for account number in multiple places? As it is, it's hard to even answer that by eyeballing the code, because it's so bulky. So let's start by pulling some things into methods: 

Plus the repeated individual checks in . So forget all that, we want a super-simple way to ask "do I need to round up my minutes?": 

Notice that by taking advantage of the call stack, isn't needed at all, we just remove the last character from the builder before exiting the method. This means that we can actually get rid of the class altogether and use directly instead! After applying that, the next thing that stands out is this line: 

In this example, I assume multiple jobs can match a category, so would probably be the best option if you want all of them. If you only want any one of them, then would probably fit. I'd also guess only one job can have a particular , so you'd probably want . In a case where you absolutely expect there to be a job matching your search criteria, then you'd want or instead of or respectively. Whichever of those LINQ methods you use, you want to pass the same thing to them: a lambda which returns for an item matching the search criteria, and otherwise. So for example: 

Some of your methods seem a bit redundant. Do you really need a special method? Do you need when you can just negate ? More generally, you can remove both those methods and your overloads which take predicates altogether. Then you can just do, e.g. rather than . This saves you basically having to reimplement the majority of LINQ methods and just add in an extra null check. 

Because that's conflating 3 different questions ("Do we need to round up to the next minute?", "Do we need to round up to the next hour?", "Do we need to round up to the next day"?) which we should answer separately.