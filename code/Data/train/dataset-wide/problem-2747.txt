Some extras The problem states "image" and "pixel" which give a hint that this may be judged on performance. They would tell you if it was. But if you get a similar challenge and performance is important then its best to use good old loops, avoiding any iterators that use callbacks. Also a performance oriented function would swap in place rather than create new arrays. If you had to do that realtime with images for modern displays your code would be making big GC hits (Garbage Collection). An alternative Another way it can be done by rotating 4 pixels at a time can reduce memory overheads and processing time. Destructing lets you swap 4 corners in one go without the need to create temp variables. I would never recommend you submit the following unless there was a clear directive for performance, and thinking outside the box. 

JQuery Do you really need jQuery? I ask this question alot and the correct answer is not a flat "yes". You must justify the cost of all that extra code and why alternative solutions are not better. Rewrite I had to rewrite. The following does the same, in a fraction of the time and a fraction of the memory. It is a saving of cost in all areas. 

Case 1 For case 1 you should avoid adding to the prototype, as you can not trust it. Someone else may have already added that name to the prototype and you clobber their code, or they may run after you and they clobber yours. If you must do it, first check 

As the click events are the only place (currently) that make changes to the task list. This is where you check the flag. If true then update the DOM, remove unwanted object, and finally set the flag to false All the changes to the DOM should be done in one place. 

Loops and function calls A big performance killer is the context change required when you call a function. This is compounded if the function being called is indirectly called from another. Many times that calling function does a lot of vetting to ensure nothing goes wrong so more cpu cycles used for no reason. The arrays iteration methods, , , etc are agonisingly slow when compared to standard loops. your code 

The next snippet shows it all put together, copied from your fiddle (a page needing well over 1Mbyte of javascript to run) to a total of less than 1000bytes for all the code, css, and markup 

I think that is what you may consider better, however it does involve an extra iteration when converting back to the array. To improve on that we would need to create our own with a hash table lookup. To do that in JS will never be as fast as the native code, so we can just accept that the complexity is unavoidable in favor of speed. 

Hard coding Is too easy... The first problem I see is that the sorting has the event type hard coded into the function. I feel that hard coding any type of data into code is bad practice. At minimum if hard coding values is unavoidable the values should be defined as a constant and placed in a common location in the source file. The problem with hard coding is the inevitable need to change or add to the hard coded items. This is a difficult process when the values are scattered in the code, and usually not easy to find as they are not unique. For a simple fix I would add 

No that is not an example of polymorphism as each instance is the same object. Just giving them different names does not change the type. Update. I overlooked the assignment of a new function to the object named . That also does not constitute an example of polymorphism. Super Polymorphism * (*) (not a real term in CS as far as I know) There are a wide variety of ways to define objects and functions for the objects. It is not the object type that determines the behaviour provided by shared functions (more apt than calling them polymorphic) The requirement be only that they provide the correct set of properties and behaviours for shared functions to operate on. In a sense the ultimate form of polymorphism, truly independent of type and thoroughly unsafe as is any super power if you don't learn to use it with care. Examples of polymorphic like JS. Personally I don't like to use the term polymorphic in JS as JS does not really define an interface, however as shown below you could consider polymorphic like behaviours 

So the expression will test if not any of "0123456789-+ ." are in the string, and can be used to vet the input and return undefined 

Decoupled presentation The function is synced to the display, but you are not rendering any content from that function. You are rendering from the timeout callback that is not synced to the display rate. is used to ensure that any visual content that is rendered by the callback function is held in back-buffers until the next vertical refresh. For all other functions content that is rendered is immediately presented to the display upon exit. This will create artifacts like shearing (when content is presented mid frame) and flickering (if competing renders are creating content). Your animation function with comments 

Pseudo random shuffle. Next your shuffle is not working very well. You are not providing enough variance in the selection of which array items to reorder. With very different hashes producing the very same shuffle. 

Dangerous There are so many caveats in this function I would really not allow it in any code base because of potencial unexpected , or misunderstood behaviour. Its just waiting to cause problems in completely unrelated code. Some points. 

A different approch This answer is not intended as a better solution, just a rework to present some alternative coding methodologies to the problem. Some refactoring. I have done a bit of refactoring, more for my own sanity than out of sound reason and can be ignored (just can't be bothered changing them back ATM) Symbol is a JavaScript type and using it (lower case ) just feels wrong so replaced it with (for want of a better name). Rather than instantiate the object with the object named I used . The rules get converted to operators when the object is created. Tonkenised numbers. One major change is that I tokenized the numbers before processing, the convert the tokens back to numbers when done. As you had it the results made it impossible to work out which numerals belong with which. Though I have not included fractions eg 0.2 that is easy to change in the regExp used to tokenize the expression. The code. Rather than go into detail here is the code as I have modified. I guessed at the type of input you expect, so it may well not handle some inputs. The only place I deviated from your logic is highlighted 

Missed 2, indirectly blind, know the rules, & chasing the tail. There are four problems with the functionality. The last one will present you with the biggest challenge, as proxy traps can be CPU costly and adding a check (which involves keeping a reference for each object as you step the path) may well be impractically slow. The two you missed. There are two additional method for modifying an object directly An object can be modified via 

Tips Setup the game using a function so you don't have to use the very hacky script tag. See the rewrite. For games polling IO state as needed is far better than reacting to IO events as they happen. The event listeners just set the state of an abstract controller. This lets you easily change the type of input. See rewrite for example. Use objects to simplify code. For example the snake can not move back on its self so you have a set of four if statements to check. That can be changed to 

The spread operator is a short cut way of turning a array like list into an array. Be wary as IE 11 is still popular and does not support many ES6 features. If you use things like the spread operator you should consider using babel.js so that your code can run on legacy browsers. 

Random numbers, hashes and precision. Good hasher. The hash function you use is very poor with it only producing unique hash values for the first 8 characters of a string. The following words all produce the same hash 

As a function Always use a function to wrap any code. Code running in global scope is inherently slower due to how JS manages variables. The whole code should look more like 

Object properties. If you overwrite the prototype you will lose existing properties. There are other solutions using the class syntax, but it is important to note the following. 

Generally polling for a state change is not considered best practice so there is no idiomatic approch. The code 

Canvas && tile maps First drop the jQuery you dont need it and it will just slow everything down. Canvas Displaying the map is much better done via a canvas. Each canvas pixel does not need an interface and can be a million (no exaggeration) times faster than a DOM element and use a tiny fraction of the memory. Though you lose the functionality of a DOM element it is very easy to implement the basic needs using the canvas. The canvas is a very powerful rendering surface. The 2D context is fully hardware accelerated and can do full screen 2D games at 60fps on average machines and on good machines it just awesome. It can also do 3D via webGL or as a hybrid 2D context and webGL working together. Avoiding the DOM by using the canvas makes many apps fly and is the best bet for game / graphic intensive applications. Tile map This type of linear map map is best as an simple array (Tile map). It saves space, access is far quicker (including neighbours), and things like coordinates can be computed from the index. Each element of the tile map holds the index into the terrain type. The world description object map holds an array of terrain type descriptions. To get the details for a tile you get the map item and use that as an index into the terrain description array. eg if the world is 50 by 50 tiles and is the tile map array. To get a terrain description for a tile 

This is when you hit peek memory use, just before the above return you add another array so you have stored in memory 18 references 

The degree of granularity is the number of functions to source code. The more granular code is the more functions there are. Low granularity (not many functions) is bad for many reasons (I am assuming that is self evident) so breaking down common tasks to functions is beneficial. But there is a point where increasing code granularity begins to effect source code quality and code execution efficiency. In execution the optimizer spends a lot of time working out what functions are not needed, and in-lines them, this is because function calls require CPU and memory above that of what the function does. Function call have a cost, and you can not rely on the optimizer to inline them for you. When reading code for the first time (or returning to code after some time) functions can disrupt the understanding of code because you must follow the function call to its source location. Lots of functions makes reading code harder (a spaghetti of function calls). Finding the balance comes with experience. One liners used once is bad. 

Avoid using more memory than you have to. The array is a duplicate of the data. You can Use the existing and use the second argument to set the start location of the search. Rewrite of you solution As you solved the problem, and the logic is sound I rewrite your code using your logic but with some improvements. 

Vet To fix these problems you need to look at the document content and remove unwanted formatting/styles. You need to check the selection before calling a command and not allow counter intuitive actions. You need to remove empty (thus invisible) tags as they will interfere with formatting and making editing counter intuitive. 

The need to test. At this point I am 60% happy but by just looking at the code you can not tell how reliable it is. You need to test the function over a large set of values. I have created two test. Testing the random number generator. This is a simple test, and rather than test it for standard deviation I do a visual test by graphing the distribution of the random numbers generated. I compare them to the inbuilt random function. It can give a good indication of the randomness. Why? because it's more fun... 

Note. Direct element reference via the global object is part of the W3 HTML5 standard and is supported by all browsers. Many believe it is non standard, eg Quote by RoToRa "It's not standardized" in comments below. As with all variable declarations care must be taken to ensure uniqueness of the name across the scope of the document and javascript context. 

Room to improve. There is an overhead associated with interrupting the execution flow with await though it is relatively minor. As represented in the question there is a little room for improvement. Problems with your implementation. Heaping closure The way you have implemented it can be improved