You're passing corresponding to UI thread so naturally the code will be safe to work with UI. I would recommend using to update/inform UI about changes in long-running task though, since you may want to separate computation logic from UI-related code. 

Note that it doesn't actually test the fact that allows only one thread at a time, it just ensures that nothing fails when multiple threads call this method. There is no way in current design to detect it. What I would suggest is to expose the fact of long process inside of by returning a that any thread can wait on: 

I've seen many attempts to abstract particular ORM from application, and all of them at a certain stage of maturity had to break this abstraction. One of the reasons for that is when you need to optimize certain use cases (like eager-loading related entities, or combining several round trips to server into one) you'll need to use ORM specifics that you're abstracting from. And another (more obvious) reason why I vote against abstracting ORMs from the code is that ORM is already an abstraction, so what you do is an abstraction on top of another abstraction that brings little benefits. There is a very good series of articles that describes best practices for managing NHibernate in ASP.NET: 

So I came up with a solution that should be as fast a "normal" loop. As already discussed your main problem is the function that is called on every iteration. I removed the check (see comments) and instead added a function to calculate a range that is compatible with the size of (see comments). This function is now used instead of just using (see comments). Also: To prevent someone from messing around with the iterator I made the constructor private and added as friend class (see comments). 

The same way you can "prepare" the values of and . If the user wants to be inverted you use otherwise you use for both calculation and output. 

You could and should read the user inputs into variables of types that represent what you are doing with them best. E.g. whether the user wants to invert or should be a boolean. For the operation I would recommend declaring an enum. I would also print messages about input errors directly where they happen. If a user already enters a wrong operation (e.g. "XOR") in the first question, why should you let him enter two additional values before you tell him. Additionally your messages can be more specific. Checking/Comparing user input that is not required to be case sensitive is easiest done by making the user input upper case (or lower case) and compare against the wanted/required values in the same case. This method is also less frustrating if you don't need to retype as you accidentially typed . If the user enters something invalid you can also force him to enter a valid value by using a loop that doesn't quit until something valid was entered. And last but not least you output. You can completely stream line the way you do it by "calculating" the values depending on the user input beforehand and output everything later. E.g. this line: 

Your can also be simplified a lot if you use a device number instead of parsing , I'd also rename it to 

I would definitely rename , maybe to or or something like that. I would also definitely remove , create a new RoleType and propagate an entry. I also think that is a rather bad name and should be renamed to something like or . Get rid of and use instead. This could also simplify your code e.g. you only have to check for the access. But i would use an instead of making the emailAddresse . I think a better name for would be just as a role is not necessarily related to sharing. doesn't really fit into as defines permissions (what and who could do what with the document) for users. But you could create a and merge and but this isn't a good fit either. 

As it seems my intention on what should do and how it works weren't very clear. So here is what the example will do as instructions: 

is used to get the unsigned equivalent of as the function makes use of the modulo operator. Modulo operations on signed types is UB. Next is to get the difference between an and store it in the unsigned type. This is perfectly fine since will only return positive values. Also we are getting the absolute value of step. It doesn't matter if we are going from to in steps of or from to in steps of ... all we need is if we exactly hit when iterating. will give us this value. e.g. when using the last value we hit is which is short of . will give us this . What we need now is the value being signed again in the direction of step. will return if is negative and if step is positve. If there is no underflow we can just return the last we were provided with. Otherwise we need to calculate the next last that can be "hit" with . So we use to find the difference we need and add it to . Example: 

Since you've asked for suggestions to clean up the code, here is my list of what I would do with it: 

call is redundant in the , and you can directly convert to to save on memory allocations and transformations 

method (if applied to ) is O(N) operation, and it's a lazy operation so it will do the filtering while consumer reads the result. 

Having said that, assuming that you are using one of the high-level languages :) and you're developing a long-living solution I would actually recommend you to use one of the ORMs available for your language to interact with the database. It'll take a bit longer at the beginning, but you'll get a more flexible solution in a long term. 

For the next part you should definitely quote as otherwise you won't handle parameters with spaces correctly. There is also no need to compare with as contains the parameter starting at . Instead of specifying environment variables to call your main function you should specify them as a parameter instead. is according to man bash also only set if you have debugging enabled, so it is not portable. I also don't really understand what should be, but you should change it as well. You should also either quote your parameters with or use I wouldn't mix them and there is no need to use as well as . You should also check if the source file is a valid file before pushing calling your function. The function name could also be improved, e.g 

The new function might seem a little bit difficult in the beginning. All it does is to calculate the next step equal or greater than the current in the direction of : 

Comparing the new code to a normal for loop with the same range actually shows us no difference in compiler instructions: 

I was just playing around with some code and had the idea about writing some kind of manipulator to delay the output of characters in a typewriter like style. The focus was mostly on how to use it and was inspired by or . Overall it works pretty well. I just want to make sure that I didn't miss anything that may backfire any time. The code is just for playing around and doesn't have a real use case (yet). 

The code itself looks good, but I would look into providing a single way of subscribing to events, it will make the job easier for other developers reading and changing the code. The first method of subscribing (via injection) requires subscriber object to be created first, so it may not receive all events that you may expect it to receive. Every time you create an instance of subscriber it adds a new event subscription thus causing potential memory leaks and side effects. You might need to add method to if you prefer to leave it. Second method (the one I would prefer) is better suited for application-wide events since it moves the responsibility of subscription to the infrastructure thus avoiding multiple subscriptions and memory leaks (comparing to first option). It is also easier to unit-test since part of responsibilities are taken away from subscriber. Update based on question update: Publishing messages also looks good. In this case (following my suggestion to leave only second method of event subscription) I would remove method from declaration, and refactor it to non-generic interface with generic method .