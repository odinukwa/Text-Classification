Update In lieu of the above answer and comment you made the following might suit your needs a little better. Rather than pass a callback to the series function, that function returns a promise which will resolve when all tasked have completed successfully, if there is a problem along the way the function will terminate returning the error. Also the results stack is passed to each task. Rather than the last results the entire results stack is passed. It is up to the task which results it needs to use. Also added are some options. Stop on error if true will stop on the first error, and timeout is greater then 0 will have a timeout error on tasks. 

And just to clarify Javascript arrays. Javascript only has 1D arrays. In Javascript there are really only 1D arrays. We can simulate 2D to infinite D arrays by adding arrays to each item. But you can not guarantee that each item will be another array, or if it is an array, what and how many items it contains. 

The most important difference between the two is that function statements are hoisted and available in all part of the scope they are declared in. Function expressions are not, even if you declare them as a var (which is hoisted) it remains undefined until it is assigned a value. Function declared as statements are thus the safest form of function declaration and should be preferred over expression declarations. 

Is there a better way? It is often better to embed as much context / semantic specific information in the page. In this example you could have used a map element to define the click areas and used Javascript just to change the image src. Example The example shows it done with minimum required code. I know that the sandboxed page is completely under my control and can thus reliably use directly referenced elements to add functionality. It is done without jQuery to keep it simple. 

Do like JavaScript does Look at the previous section, when JavaScript parses the string value "10.0.0" it does not but rather it returns You are throwing where the better option is . A malformed equation results in a value that is not a number, not a variety of errors that would need to be trapped. Personally I would remove all the error checking and let JavaScript throw if it needed (Dont think it would in this case), for the most part it would return on its own. And Please... ...add the semicolons ';' and reduce the risk of bugs. 

from MDN Classes Using has some major problems, and in my opinion should be avoided as the same and better can be done using standard syntax for objects. A word on code. 

There is a lot of code so I can not address every aspect of your code. First impression. It works, just, but is very unfriendly. Cursors Cursors are a must when doing any form of mouse interaction. When over a draggable item the cursor should be "grab" and then to "grabbing" or "none" when dragging. The CSS standard cursor set is very limited, learn how to create your own cursors and use them. I can not overstate how important cursors are to good UI design. They are the forgotten information provider in may apps. Select drag! One thing I find it very annoying, even professional sites seem to miss this, Turn off "select drag" when mouse is over draggable items. CSS rule and appropriate prefixes if needed. It just looks horrible when a big blue area is selected just for dragging something. Smarter drop Don't allow dropped items to overlap. Move the dropped item to fit in front of or behind items under it. If you drop over an item and there is another after insert the new item after the current and move the next one to give room. Snap to the day the mouse is over (if showing it) or to the day nearest the center of the control. Scale Use the mouse wheel input to scale in and out (if not over item). The current screen is way to wide. You may also allow that when the mouse is over an item that the mouse wheel moves it left and right. (with appropriate cursor) Bits and bobs 

...correct. But all the rest is not helping solve the problem. Step by step. So lets step through the code Set result would be 

Exposed states are bugs. Your code is not at all good. This is an example of a banana in an OOP jungle, gaining none of OOP benefits and amplifying only the bad parts. You have exposed almost all of the object's state which is total against OOP principles. Some notes. 

Is there a better solution? Yes, always... biting my tongue. So first let's look at the function you have. The JS array functions that take a callback as an argument, like , are slow in comparison to standard loops so for more code you can get a performance increase by implementing only what you need in a reduce function. But we can avoid that as well. Using a The function is also a little inefficient. It needs to iterate each item in the new array and test it against the current item. This can be improved by using a hash table. JS has two objects that use hash table lookups and . For this case will improve the search for duplicates and will also serve to hold the unique array while processing. If we are going to use a we can take advantage of the constructor that will create a set from any iterable object. Thus all we need to do is create the set from the array, then convert the set back to an array as it will have removed the duplicates. Thus 

Normalised the results are 18.7, 11.6, 6.6, and 4.2. You can see how the efficiency increases as you change the code. And on Chrome 11.7, 6.5, 5.0,and 3.0. I am surprised this ran faster on Chrome as it has been a poor performer compared to firefox also the variance (error bars) on Chrome are only 1/3rd of FF. Thus functionally identical with a few minor modifications in layout you can get major performance benefits. The 4 functions as tested. Not a runnable snippet 

It is clear that the function is dealing with cells and that you don't need to prefix some names so why prefix others?? And from the code I can not workout if you are using an Id or an index. An id is different than an index and you would not test an id against a count nor would you increment an id without testing if it exists so I think its an index. 

Now you don't have to have the long chain of if else statements. For details on the array methods and go to MDN array jQuery Do you really need jQuery? I have never approved of jQuery for many reasons, one of them being that it encourages bad practices. These days its primary reason for existence (cross browser compatibility) no longer applies and it is a large complex script that your clients need to download, parse, and execute, which is a cost that they must bear. Now I have an even better argument against its use. Using jQuery opens your site to security vulnerabilities see 77% of 433,000 Sites Use Vulnerable JavaScript Libraries Thus I remove jQuery, as it is not needed and can be done with...