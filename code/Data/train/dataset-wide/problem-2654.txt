Note: I removed the last line because you weren't actually setting to anything. Now, you can just do this: 

There are many unit testing frameworks out there. Honestly, I'm not that familiar with jQuery, so my suggestion may not actually be your best bet (although, the jQuery website does make a reference to a unit testing framework: QUnit). A framework I would recommend is Cheerio. My main reason for this is because it allows to easily load HTML into a virtual DOM and perform any normal DOM operations on it. This means you could load some test components, run your sorting code on them, and use Cheerio to read the DOM and make sure they are properly sorted. 

This section is over-done. All you are doing is copying the array into , and JavaScript already has a built in function for that: Array.prototype.concat. You can use this function to copy one array into another. Now, your code becomes this: 

where is a function that takes two integers as arguments and returns a single integer. Then, when setting up these operations, you can use the new class: 

Inside the body of a function passed to , you are accessing a parameter passed in to the function called . However, every time you are accessing it, you are accessing the 0th index of the property of this parameter. Why don't you just store that in a variable? It would make your code a lot cleaner in a lot of places, and it increases readability because it doesn't make someone wonder why you are specifically accessing this value each time you want to use it. Create a variable set to this value: 

Constantly calling the function on these elements in each of your conditionals is inefficient. You should store the result of in a variable, and just use that for the conditionals (I think should already hold the for ). 

You have a lot of repeated code down there. To reduce this repetition, you should store the two players in an array, and then each time loop through the array an do what you need to do with each player. To make it cleaner, you could use comprehensions: 

This is slightly re-inventing the wheel. JavaScript already has a type of loop called loop. It's syntax is this: 

This single method does exactly what those other two methods did, except for two small sections that can be "turned on or off" with a simple argument. Now, your code would look like this for placing first cards: 

Write some JavaDoc! As stated above, I was very confused by your code. However, if your methods included JavaDoc, then I wouldn't be so confused by the names. Here is an example of JavaDoc on a simple method: 

That is an inefficient way of doing that. Instead, make Triads a set and put tuples rather then lists in it. That'll be faster and easier to read. 

Don't use global variables. Instead pass G in as a parameter. Also, I recommend against calling it G. 

Use sys.exit to indicate success or failure of the program. file is a builtin python function, its best to avoid naming your variables the same thing. 

Use for source, dest, value in row: li.append(float(source), float(dest), float(value)) Do you really want floats? Are the source and destination really floats or are they ints? 

You declare draw far away from where it used. Just assign to it in the scope its used in. Multiple assignments on one lined is also frowned upon in python. 

The python style guide recommends lowercase_with_underscores for global function names. The name also suggests its a generic summing function which its not. No indication is given for what kind of data it expects. A docstring should at least explain that. 

Don't catch all exceptions, you'll hide bugs that way. Instead, catch only the specific type of exception you are interested in. Also, you want as little code in the try block as possible to avoid catching other stray exceptions 

Why not use the string search functions rather then having built a newline list? Also, if you need to treat the end of input as a newline, put that in when you create the list not in an exception handler. 

The problem is that if someone passes frequency along with one of the other parameters, this function will go merrily onwards and probably not even produce an error. I recommend having a get_LOS_from_frequency function which takes the frequency and then calls this function. 

Create a list with a single element, putting that in a set, simply to call issubet is silly. Use Edges[i][j][1] in firstgen. 

I'd store these values in a list which makes it easy to pull them from configuration at a later date if neccesary. 

I have to recommend against r, as its not a common abbreviation and I think it makes the code hard to read. 

np.ones, returns an array. There is no reason to pass it to np.array afterwards. If you aren't going to use the ones you store in the array use numpy.empty which skips the initialization step. 

Use the enumerate function. It lets you use a foreach loop and get the indexes at the same time try: cm = next(v for v in cl if v > om) + len(mn[1]) add a line like: start_comment, end_comment = mn, that way you can avoid the indexes are your code will be clearer. 

Now our function is looking pretty good, but there is still one problem: the random numbers. For each of your 4 functions, you generated different random numbers. Now you mentioned that you are very new to this, so this next section may be very confusing. To be able to implement different random numbers, let's create a dictionary that maps a single value to a tuple of two values for creating random numbers. That could be done like this: 

Always use s and . On bigger codes, omitting these can cause really big problems that are not very easy to notice at first. It's just better practice to put them there. 

You must you proper exception throwing; (you have) no exceptions! This is an improper way to throw errors: 

I'm confused by this line: ...document.getElementById('<%=txtCity.ClientID%>')... Previously, you were using JQuery to interact with elements. Why did you suddenly stop using it here? If you are going to "import" JQuery, you might as well use it. 

Don't just throw a string as an error: create your own error object. I recommend calling it as the reason why the error would be thrown is if an invalid operator was passed into your function. Here is what the class would look like: 

If wasn't a function, it's going to go to else. Then, you call . Well, if it wasn't a function, how are you supposed to call it? 

Game design Don't rush me Why do the letters disappear after a few a seconds? What if I need time to think? To me, this seems like a "hacky way" to hide the cards after two were chosen. Also, this even leads to a problem that occurs after a pair is found: the space I click on next shortly disappears, even though I just clicked it. After a pair is found, you should clear the timeout with so the next spaces that are clicked do not disappear. 

You don't need to be so specific with and and ... since your program is all about those, these topics should just be implied in your function names. 

In a couple of the methods of , you catch an event and call to stop it from performing it's default behavior. I'm unsure if this will make a difference, but it might be better to move that function call to the very top of the function; that way (I think) the default behavior of the event is more likely to not be executed 

It might be better/faster if you instead check to see if the message actually has the badge text before you try to replace it. But, that's up to you.