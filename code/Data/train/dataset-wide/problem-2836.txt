And as promised, here is the link to the repository, which also contains formatted documentation on the respective github pages, and a full demo on Heroku. Please be responsible and only make HTTP requests to the Heroku link sparingly, as I have it hosted on a hobbyist plan, which only allows so many hours of uptime a month. I have plans to implement a service worker for it in the future to mitigate this issue. 

I did a little preliminary research and was unable to find a class to create re-usable instances of template string literals, so I wrote my own. Below is the main file (slightly modified to remove exports) written in ES2016, along with a few examples of usage that show the convenience of the class. 

In order to satisfy the O(N) time-complexity, construct a in O(N) time and space complexity, then use a loop which is considered constant time relative to N O(N) as well (thank you, wchargin), since the maximum possible number of iterations is equal to N and average performance of a operation is O(1). Because O(N + N) = O(N), regarding time complexity, this solution is overall O(N) performance in both time and space: 

And though you are forwarding the arguments to the constructor they will still need to convert the parameters as the object is constructed and so I don't think you gain any flexibility. OK. Worked it out. By doing this you only have to convert the parameters once as you create the object. Rather than once at the call site (which happens if you don't templatize the parameters) followed by a copy during construction. Nice but ugly. I would not use a vector of unique ptr. 

To be blunt that is the compilers job. If you are worrying about the low level architecture you are using the wrong language. You should be worrying about the algorithm efficiency not the register usage efficiency. The most common thing done wrong by java devlopers is allocating code dynamically when a normal local object would do. In your algorithm I would worry about space usage. You are using way too much for the current algorithm. For integers you don't have to worry about the cost of moving objects as a copy and a move have the same cost. But in the general case you should prefer to move rather than copy when you can (a move can be a lot cheaper than a copy). Also your code may be generalized in the future and if you have already done the work then your function can be templatized with no extra work than adding to the front of your function. 

You can write concise code without using cryptic variable names. Change to something more meaningful like or even just . One way to resolve pyramid code is to look for places where your logic can be decoupled or flattened. While it's possible to continue to use the dependency in order to achieve this, it's probably much easier to just use since you're already using promises anyway. This will also give you an opportunity to get rid of your global variable : 

Here, we are mimicking the signature of the native API, which has one required argument and one optional argument. We simply expect a property to optionally exist on within this wrapper function. 

This part is pretty straightforward; we're creating a timeout given the amount of milliseconds supplied from or the default , and invoking the callback function in that amount of time. 

One of the things in this rewrite to flatten your pyramid code, I changed the order in which is called, because the way your code accessed the property relied on the usage of a proxy get trap in order to work properly, which is both unnecessary and inefficient. Lastly, I cleaned up your generated text to break it up into a few lines, otherwise it's quite unreadable. You might consider storing that text to an external template file using a minimal template engine (possibly written yourself just for this specific case) in order to avoid hard-coding it in here. 

My advice here is not to use C++ (directly) for this type of job. There are tools out there to help you parse formatted streams (you have to learn another tool though). Personally I use flex and bison. BUT I recommend you look around and see if there are more modern version or alternatives. Flex Rules This converts a stream of characters into a stream of tokens. 

White Space to make it easier to read: Add white space between operators so they stick out (and we don't have to squint to read your code) 

Placement New Your main problem (as described by Jerry Coffin in the comments) is that you are creating objects when you should not be. If we look at your copy constructor: 

You can probably do some meta-programming to determine if the destructor is but I don't have that in my head. Don't mark your destructor as noexcept. 

So in C++ you usually provide unchecked interface (let the user do the checking). If you want you can also provide a checked interface then that is fine but usually not the default. For example look at . Provides for unchecked access to the data. But also provides for checked access to the index. Un-needed work. Do you really need to call delete here? 

Overall, it gets the job done, but your code (especially the area I'd refer to as "pyramid code"), could use a little more organization and clarity. Your statement could be a little more concise, and, at the same time, more canonical about what it's actually there for: 

I'd appreciate any feedback on improving perceived responsiveness for the feature this UserScript adds to the webpage. I realize changing the URL after a slow image load within might make the URL change seem slow, but I also noticed that when calling or within a listener to or events, it appeared to cause the fusion image to load significantly slower. Though this UserScript still functioned properly either way, I'm curious if anyone can come up with an approach that improves responsiveness overall. 

Inside the callback, we're rejecting the constructed promise with a , but keep in mind, if the function has already invoked or in its , this call is essentially a noop because the constructed promise has already locked into its state and cannot be "settled" again. Because of this, it is unnecessary to assign a reference to the timeout and call if those occur first. Conclusion If you've read this far, you've probably realized by now that the suggested code is compact because it takes advantage of a thorough understanding of the promise specification, and is able to safely make assumptions that keeps the code DRY. 

They should be the same. If you have some compelling reason for the difference then I need a big comment about why they are different (you may have a good reason, but you will need to explain it in the code). Personally I would just have an . A negative amount is a debt and positive amount a credit. Getters. Ahhh. horrible. 

This is such a common pattern that in C++11 they introduced the range based for expression. Basically this is a loop that works with an object that can accept and being called on it. It is basically syntactic sugar to make the above loop simpler to write: 

Use the if you are moving an iterator more than one place. It uses the most efficient technique for that iterator type. 

You can compreses the two maps into a single map (and thus reduce the code here) by using a functor or class abstraction as described by (@utnapistim) in his answer. Personally I would go with using std::function rather than building my own class hierarchy (but that's a you say potato I say tomato argument and down to personal preference). 

If you are at all familiar with using promises, then you'll recognize this pattern. While it is typically considered an anti-pattern, this particular implementation is written properly, and is also necessary in this case to take advantage of a convenient implicit race-condition behavior of promises that I'll explain in a moment. 

This line invokes the native method with the wrapper's arguments and resolves the explicitly constructed promise with the fulfilled object, if, and only if, it is successful and it completes before the callback is invoked. The reason this occurs is because of the specification: a promise can only be fulfilled, rejected, or remain pending forever, and if it is fulfilled or rejected, it is "settled" and cannot be fulfilled or rejected again. If it is unsuccessful, and it fails before the timeout occurs, then it will invoke with an error. 

This first checks that is "truthy", and then checks that is a valid, non-zero number. If these are satisfied, then is assigned the value of the supplied property, otherwise it defaults to milliseconds, like in your example. 

So it looks like both my reasons for disliking recursive template functions have been addressed by the new version of the language. But I still prefer the style of the unrolling the argument loop in a function. So I present my version of the same function to show readers how it is done without using recursion (template iterative style). 

QueInfo: Data used and manipulate by each thread. Both the main thread and the owning thread access this object so all access needs to controlled via locks. 

1 and 3 can potentially go wrong and throw. But it will never affect the state of the current object which will always be left in a good state. So re-writting your code it looks like this: 

The need to use is only required if we have shadowed variables. Shadowed variables are dangerous as you can accidently forget to use and then you will be changing the wrong variable (and how do you tell if you should be using a local or a member variable if they have the same name)! Shadowed variables are bad practice and can be detected by the compiler (and thus removed). When you have removed shadowed variables (because you code compiles with no errors) there is no longer any need to use . The use of this only creates problems so don't use it. Only put one statement per line. 

While this is a relatively simplistic and deceivingly elegant implementation, insertusernamehere's solution is admittedly an order of magnitude faster, when using an array as a perfect hash table for non-negative integers instead. 

I would like a review of a library I've recently published. I realize this is a rather large request, but having looked on meta, it seems this is perfectly on-topic. I'll include a few choice samples from the library to demonstrate my approach, as well as a link to the full codebase for anyone interested in giving a full-breadth review. So to summarize, this library, called , is, as the title and tags suggest, an object-oriented approach at designing an educational tool for teaching sorting algorithms, which is why the sorting algorithms use generator functions to introduce interruptions in the control-flow in order to be visualized step-by-step. Here's a few of the classes needed to implement an iterative (bottom-up) merge sort algorithm: 

On Pokemon Fusion, I found it annoying that the webpage didn't automatically update the tab URL to the permalink when the fusion is changed, so I decided to write a UserScript to do that. After finishing that, I thought it would also be convenient to update the fusion whenever navigating through the site history as well.