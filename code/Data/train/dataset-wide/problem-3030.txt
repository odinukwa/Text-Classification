Embrace Python's simplicity! This is a dynamic language, we care less about inheritance and complex data models and focus more on the actual problem. Of course, it has its drawbacks, but that's how it works. The answer your question: no, in Python, we wouldn't derive classes and so on but just write the code you wrote. It's still possible to define an abstract base class A with specific methods and extend it with a few implementations, but really think about the benefits before doing this. Note about the code: PEP 8 is a standard style guide important in the Python word: space between operators and no camelCase in variable names are the two that come to mind while reading your code. Finally, performance is another concern than unit testing (except if you find a reliable way to test for the complexity of your algorithms). I recommend the module. It doesn't say how to test for complexity, but it's a good start to measure time spent in a method. 

This is only one example to show that you should care more about spacing. or . I'd recommend . Use strong enums. I'd recommend for using instead of , but that's up to you. Are you aware that you do not need a comp object, since in would be enough? This means you don't need to expose the priority, but also makes it less explicit that you are going to compare s. Up to you! 

have a real module put your current class (renamed as ) in it add those functions in the module, not the class fix the return type to return what lxml returns 

Sure, you can do that, why not? Isn't it easy to pass a list of Levels instead of a Level in GenerateProblem? Without more details on what you really want to do with that list, it's hard to answer. Unfortunately, as Willem van Rumpt said in comments, we're currently at the ProblemConfigurationProblemLevelConfigurationFactoryFactory level and it doesn't make sense anymore. You need to learn when to stop abstracting things. 

Your code is very good for a beginner! As you have noticed, there are always improvements to be done, so don't worry too much about this. Here's what I feel the other answers have missed: 

This one can also be seen as a way to eliminate cases you don't want to reason about later on. That is, you know after this line that you will have the correct number of cubes, and it simplifies the reasoning and the code. You should keep it. 

You're pretty new to OCaml? You're using OCaml 3.12 features and probably did a lot of functional programming before. Let's see if I can show what idioms I've seen before. I'm not an OCaml expert though, far from it. Empty trie Consider using something like to denote the empty trie. This is better than your hack, and will allow you to take advantage of OCaml's pattern matching. string_of_char is a nice OCaml name, but this is not really , but . Since it's not important, I'd tend to make it look smaller in the code. 

This program may be useful to you in some specific scenarios, but you'd better explicitly state what kind of data you accept and reject anything else. Also, what's the point of this? 

Okay.. got it. Iit looks like that when part of a winning move is done by a player, we add it to the player possible winning moves. Isn't this over-engineered? Why don't you simply check on every move if a winning move as made? You don't need to store wins or chances, just check 8 configurations. (Such a function would also work for larger grids, by the way.) 

If you want Python developers to be able to read your code easily, please follow PEP 8 (using a tool such as pep8). That includes sticking to 80 columns, using and using variables for constant strings. 

You don't need and : is already a float. Context Another thing to consider is the 'context' of this function: is it called only once, or do you call it for every subject and topic? If that's the case, then it would be better to do the similarity search for all topics and questions, and then display only questions with the same topic and subject. You would go from many SQL queries (one per topic and subject combination) to only one. All Pairs Similarity Search The problem you're trying to solve is called All Pairs Similarity Search. There is a scientific paper and an implementation from Google if you're interested in the research problem. The research applies to sparse vectors but it's possible to turn your sentence into a vector of the size of your vocabulary: a cell i is 1 if the word corresponding to cell i is in your cell, and 0 otherwise. Such a vector is sparse because most cells are 0 for a given sentence. Feel free to ask more questions if you want to try this out. 

The choice depends on your application. There are exceptions that you really don't want to catch because your program really cannot continue to work. For example, if your main task is backing up, what can you do if the folder is not writable? You probably want to say so to your user: just fail is it's a command-line app, and explain the error to your user if it's a GUI app. To be able to do that, you must be able to distinguish between various exceptions. The best way to do that is to only catch the exceptions you expect. For example, os.makedirs can only throw an OSError, so that's what you need to catch, as you did in . However, printing the exception is not engouh: if you catch it, that means you can do something about it. 

nitpick: Cleaning at the ElementTree would prevent your filesystem to see two different versions. Say at some point you decide to use watchdog, the callback will kick in before you have a chance to run , which could cause subtle bugs. Answering your questions 

A default constructor is provided by Java already, only use that if you need to put something in there. 

In Python, by convention we have CONSTANTS, variables, and Classes. Since your argument is only a variable, you should name it and not . Actually, for exception is the convention, you could stick with it (). 

It seems you got this one correctly looking at your code. (If not, never leave non-working code in a way that suggests it works.) 

This makes the code clearer, since it's way easier to understand the logic now. One issue is that you still have lots of around. You should replace those in the loop with and those in the call by , otherwise you could confuse them. Define those lengths like this: 

My suggestions won't make your code faster, I focused on idiomatic and clear code. It's already quite nice as it is. :) 

First things first: while this obviously comes from real code, the way you "anonymized" your code doesn't work, eg. doesn't exist. 

"and" is an effective way to say "watch out for mutual recursion". OCaml encourages you to use nested functions instead! As The Structure of OCaml programs says: "Nested functions are, however, very useful and very heavily used in OCaml." 

And so on. This allows to comment the separate cases and maybe explain what they are doing. It's also easy to modify. You can also put things like in a variable to save space. 

You're off to a good start because 1/ you want to improve 2/ you're noticing yourself the parts that can be improved in your code. Congratulations! So what can be improved here? 

Why "A B 1"? When programming, you optimize for reading: reading your code should be effortles. This is not the case when an arbitrary string shows up like this. Also try avoiding setting anything to when possible. Here this means not declaring the right away. Line count and better container 

Your code is hard to review, since one would need to exactly understand the underlying mathematics, then understand your code, then propose meaningful abstractions. I do hope someone will do it, but I can't. I also believe that for complicated code like that, it's OK to repeat yourself, since it's often hard to encapsulate and to modify without having to understand the whole thing. What I can do is provide some comments on the code itself: 

You're trying to do a bulk insert, which is notoriously slow on many databases if you're not careful. Indeed, each call to creates a new transaction, then inserts, then closes the transaction. Instead, use beginTransaction() and endTransaction() to have only a single transaction (the doc explains how to use them with a try/catch block). Up to API 16, it was possible to use , but this is now deprecated. This blog post uses , which is not a good idea anymore. But it has other interesting performance tweaks you could try out: 

It actually should be put in the view. I don't know how RoR implements it, but the submission status should be retrieved by the controller and transferred to your view. The view will then decide which CSS class to apply. You could use a substitution test to know whether it should belong to the view or not. If you were to substitute your current view by an entirely different one (eg. an iPhone app), would get_status_css belong in your model? I guess not. This is not too important when you only have one view or if your views are all web applications, but can help separate concerns. 

Inverted indexes are often implemented using skip lists instead of maps (which are elaborate search trees). The issue with is that even though the complexity is good, for real lists the overhead of the map is too important. Plain vectors are usually way more efficient for small lists, and skip lists avoid the biggest issue with vectors: search in linear time. For an inverted index with a small number of items, I've seen a great increase in performance simply from switching from to in C++. Otherwise, as CashCow said, the [] operator use the default constructor of your value when the key doesn't exist, so it isn't a real issue.