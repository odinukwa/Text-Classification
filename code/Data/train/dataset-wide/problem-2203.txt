EDIT: What should the logical model look like? In your logical model, the issue is that you need multiple discount (or price) rates because they change over time - or just because there may be multiple rules, for example one price for regular customers and one for special customers, etc. What is missing is the notion of a rate table. This is like a header which then has rate details attached to it. What you have in your model now is really just the rate detail. You need to insert the rate table header in between the transaction and the rate detail. In your logical model, the relationship is between the transaction and the rate table header. This is OK because the rate table is more stable than the details which change over time. In your physical model you still need to denormalize make a point in time snapshot of the actual rate used into your transaction because that is the only reliable way to make sure that editing the rates won't restate history. 

Sales/excise/VAT tax rules can be very complicated. There can be different rules about the applicability of different taxes based on things like: 

The bottom line is that you can't define a foreign key constraint that uses anything other than just the columns in the primary key that you are referencing. One of the ways that people sometimes use to consolidate keys across multiple tables is to use a GUID as the primary key. If the in each of your tables was a GUID then you could impose the foreign key using declarative referential integrity without carrying the column in your . Failing that, your options are: 

Why not use a date range instead of a single date for your forecast date (and for your revenue date for that matter)? If you use a max-collating value for the end date of the "current" (i.e. last) forecast then you just have to use a simple between comparison when selecting, e.g.: 

The only sure answer to this question is "it depends". This is a business rule and the organization will set this business rule. Here is how you can go about thinking about what the business rule might be and how you can determine the best way to model this relationship. Think first about cardinality. Is course related to only a single department? If a course can be multidisciplinary and offered jointly by two departments then you know right away that course is a strong entity. Second, think about functional dependencies. What are your candidate keys for course? Do you have a candidate key that does not make reference to department? If so, then you have good reason to presume that course is a strong entity. Do all of the candidate keys of course reference the department that offers it? That may be a strong indication that course is a weak entity. Third, think about the future. Let's assume that you determine from the above that course seems to be a weak entity. Is it even remotely conceivable that the factors that led you to this conclusion might change? If so, you might want to consider promoting course to a strong entity and inventing a candidate key that does not rely on department. This is a matter of opinion and people may have different philosophies about this. On the one hand, some people feel that making key changes in the database is a big, painful process to be avoided if at all possible. On the other hand, some people feel strongly that your data model should reflect your current business rules as closely as possible. 

Over and above the reasoned argument of Mark Storey-Smith and Damir Sudarevic, I would add two points that I think are important to keep in mind. I never say never (well hardly ever) My policy about never is that if it has been imagined then it is inevitable at some point. Don't believe it when users tell you that something will never happen. For your purposes that means that you need to think about the likelihood and the seriousness of a change in your design around phone numbers. All design is about making informed compromises. Do what makes sense, taking into consideration the risk involved should requirements change. Normalization is vital - unless it isn't Unless you have a really good reason not to, your first instinct should always be to normalize your schema. This is because normalization is a great rule of thumb to keep you from creating big data consistency and code maintenance problems for yourself. There are reasons to denormalize. One big one is reporting performance when reading static data. Another reason you might consider denormalizing is if the data in question isn't meaningful to your system. What do I mean by that? Data which needs to be interpreted by your system is meaningful. Data that is going along for the ride but isn't read, massaged, or interpreted by your software isn't especially meaningful. Data that isn't meaningful is much less of a risk when it comes to consistency. For practical purposes in your case, if your system uses phone numbers for an IVR system that is pretty meaningful. If on the other hand the only thing the phone numbers will ever be used for is for a user to read it off a screen once in a blue moon, then maybe you can afford to be a little "sloppy". 

Note that the table allows you to keep two or more versions of a price for a given time of day range. Note also that the table uses effective and expiry dates to link parking lots to a price table by date range. This allows you to set up a price change in advance so you don't need to load new data in the middle of the night when a price change takes effect. You're queries for pricing are going to have to find the version of the price that applies based on the minimum stay length, which is much more complicated than just "What is the price right now?" since it will depend on how long a stay is and which is the best price that the customer qualifies for. Also, the price a customer pays will depend on how long their stay is and it may cross one or more price point boundaries. 

If you're trying to get to the youngsters who've never searched for anything in their life without using Google, then why not try something like this: 

Your design doesn't record "which user submitted which answers". Should there not be a relationship between and ? You have the attribute but you haven't indicated that it is a foreign key to . Should there not be a link between and ? How else do you know which question is being answered and what the value of the answer is? seems like you left something incomplete. 

One of the realities of a solution like this is that you will have to come back to build new code-based rules from time to time as your organization's payroll policies change. Don't be discouraged by this. Even if you had a fully table-driven rules engine, changing payroll policies would entail making changes to the rules data. Business changes entail system changes - that's a fact of life. 

I think you are trying to be a bit too "elegant". Einstein is quoted as saying "things should be made as simple as possible, but no simpler." You are trying to have a single record for something like an oil change - but then you need two other tables that give you the flexibility to apply the approriate price for this service in different situations. Instead, I would suggest that you flatten out your three tables and just have a SKU table which includes a default price. You would have different SKU records for each kind of oil change, for example. The service technician (i.e. user) needs to apply the proper SKU to each service they provide. This way, you are relying on the user to pick the right service/price rather than trying to build a table-driven set of business rules that must be used so that you can "deduce" the proper pricing. I would say, based on my experience, that users would much rather have a short list of SKUs to scan through and to pick from rather than having some kind of interactive expert system that asks them multiple questions about different criteria until the right answer finally pops out the bottom. If you want to allow some drilling down (or some rolling up) for SKUs, you can create a grouping table that groups similar SKUs. If you really feel it necessary, you could even make this grouping hierarchical. Your model might look something like this: 

Note that you want to avoid reserved words for table names, so don't name your tables exactly as shown in the diagram. The way it works is that your groups or Roles have not only a list of users assigned to them but also a list of permissions assigned to them. This allows you to table-drive both who can do what, but also what it is they can do, if you follow me. 

I would think the thing to do is to store the property or properties that are used to calculate the rank and then build an index over them. Rather than trying to force the database to physically store the data in ranked order or using a manually managed linked list, why not let the database engine do what it was designed to do? 

Essentially every time there is a write into the main table, the new main table values are also recorded in the audit table, with the extra columns filled out. In the case of a delete, use the last known values. Sometimes the audit record is written automatically by a trigger, sometimes people write application logic to record this information. 

You should avoid using natural keys except under very specific circumstances. A natural key is visible to a user and in most cases is subject to change or be duplicated. You can deal with a primary key changing, but you don't want to. An exception to this is something which is strongly regulated by an independent body, like country codes or currency codes. In such cases the risk of a change may be worth the reward of keeping things a little simpler by using a natural key as a foreign key. Beyond that, when choosing a surrogate key you should use the simplest and smallest one which works for you. This usually means an integer (IDENTITY). Sometimes IDENTITY is an issue because of insert hot-spots, in which case a random integer may be necessary, but that is a special case. If you create records in multiple (distinct) databases and then need to consolidate these records into a single table then you may want to use GUID as your primary key, since you don't have to worry about key collisions in the consolidated table with a GUID primary key. 

For practical data access reasons, you should use the structure from your first option, but instead keep all versions of your tracked column values including the current version in your history table. The reason for this is that in general, when you want to look at history, you want to include the present and all past versions. When you don't want to look at history, you want it out of the way. In many cases this means going so far as to segregate the history into a separate schema or database altogether. Even if you keep your history in the same schema as your current data, any queries that look at historical data (including the current values) will be much more complex since they have to essentially union two sources. 

Your basic model is fine. It gives you a standard, normalized intersection (many to many) of events of specific types associated with particular users. Without knowing more about your intentions or requirements, it's difficult to offer any criticism of the model. I would make these observations: 

Your problem is not a unit of measurement problem. It's a stock keeping unit (SKU) problem. You can't convert, nor for any practical purposes would you ever want to convert from 8 packs of cans of beer A to 12 packs of bottles of beer B. Your product ("Beer A") is a generic product header. You don't sell "Beer A". What you actually sell are the boxes of cans (or bottles) - of a particular size - of Beer A. This box is what gets a record in your product/item table. You may want to have a product header table that just lists "Beer A" without any actual quantity related to it. That's up to you and depends on your system requirements. What you really need to have though is a SKU table where the actual salable things are recorded. Now if you want to be able to get some kind of apples to apples comparison between SKUs of similar products, you can track an actual, objective unit of measure for each SKU. For example, if you're dealing with beer, then a liquid measure is appropriate. Say you have 6 x 355ml cans of Beer A in your six pack SKU. Then that SKU has 2,130ml of beer in it. You could store that along with the other useful information that it's a six pack of 355ml cans. If you want to have this apples to apples comparison, then you want to have a unit of measure conversion table that has columns such as: 

It is acceptable to have mutually exclusive attributes in a table. If you only have one pair of such attributes, this may be the most practical solution. However, some people may look at your situation as a sub-typing issue. In this view, you are missing the superset entity. You have a collection of (something), some of which are employees and some of which are customers and some of which are also users. Have you also considered what happens if an employee also happens to be a customer? Is that important to your system or is that something that would be considered coincidental? If you think its important to treat all users as a feature of one type of thing, then you need to implement the (something) which is currently missing from your table definitions. Consider the following ERD: 

For a simple solution, you can add a nullable foreign key to an table to your . If you want to know what needs invoicing, just select everything for a given user that has a NULL foreign key. When you create the invoice, set the foreign key to point to the new invoice. For a more complex, but more sophisticated solution, you may want to consider an intersection table between the and an table. This solution will recognize and handle the situation where an item is charged on one invoice, then returned on a credit note, and possibly even re-invoice again, and so on... 

Do you have a reason to store the searches as individual events or are you only interested in recording which terms were used how many times on any given day? If you just need to record how many times each search term is used on any particular day, then the most compact schema would be: 

Don't worry about having too many transactions in your table. Relational Database Management Systems like MySQL are designed to handle amounts of data that would overwhelm other formats, like a spreadsheet for example. You can easily store millions of records in your table and MySQL will find you the ones you want quickly, especially if you define indexes on the fields that will be part of your clauses in your queries. For example, if you want to do monthly reporting, make sure you have an index on . 

Your professor is wrong. The cardinality in almost all versions of crows foot notation is read such that the cardinality next to the entity is the cardinality of that entity. You can also see by the fact that common sense tells you that whoever drew this ERD did not intend what your professor is reading. I will say that I have (very rarely) seen people read cardinality the way your professor is doing it. I think of it as "looking down the relationship" at the other side. The fact is that this approach doesn't make sense for readability in my opinion. It's also just not the way the vast majority of people do it. You're better off to stick with the conventional wisdom on this. If you can't convince your professor, then go with the flow until the end of the semester, but then forget this inappropriate convention and do it the way almost everyone else does from then on. As an aside/pro-tip: when you see many/optional cardinality, I'd suggest you get in the habit of reading it "zero or more", not "zero or many". I think "zero or many" kind of implies "not 1", which isn't the nature of such cardinality. 

EDIT: Based on OP's clarification of requirements: What you need is not like a typical questionnaire model in the following ways: 

Track your achievements in parts. Right now you have some indicative (i.e. descriptive) information and one "business rule" column (). You actually need more than one business rule column. Depending on what you foresee being your needs and how much work you want to put into now, this might be either one or two more business rule columns, or possibly even an extra table or two. In addition to "how many are needed?" (i.e. ) you also want a column that describes how many of what? You have two descriptive columns for this now, but these are human readable. You also want a machine readable column. In terms of nomenclature, I would actually use for the what, and something else, say for the how many. With a column and a column you can then write program logic that knows how to measure each type of achievement. This way you don't need custom logic for different levels. You could take this a step further and normalize this somewhat so that the descriptive information is part of a separate table. This would allow you to have groups of achievements that share certain types of information and logic. This distinction would help you with handling user-specific and user generic logic in a nice, managed, organized way.