"show create view" will provide you the DDL to recreate the view exactly as it is (complete with select statement). 

I highly recommend partitioning your table now. I'd create a new table partitioned by year that looks just like your current table then insert into it. Going forward, you can more easily prune your table. Here are several links to a good partitioning discussions... $URL$ $URL$ I'm not a SQL Server guy - I saw an MS SQL Server 2016 documentation suggests there are some differences in 2014 features - but I can't find 2014 documentation. Here is a link to MS SQL Server 2008... $URL$ Good luck! 

This is an ugly solution that may introduce other issues. It is offered as a means to eliminate the lock you are experiencing. Auto_increment is preferable to managing numbers in this manner. The number could be managed in its own table incremented as needed. This table could be locked at no detriment to the main table. When write locked, other sessions are prevented from using the table, the locking session can then increment the number (and store it in a variable - something meaningful like @next_position) then releasing the lock immediately after the update. The number is then used in your main query - no join, simply "LQ.initialPosition = @next_position". You may still have contention on the position number table - but these locks shouldn't be held too long - only during the incrementation to ensure only one process increments the number at a time. The locking scheme could be eliminated, but this would require knowing the current number first which would then be tested in the update's where clause to eliminate race conditions with other sessions. A loop will be necessary to try again if the update doesn't work (another session made the update first). This complicates the use of the table but reduces the potential for trouble. 

@a_vlad has your answer... create a new table with the same structure without keys and autoincrement (it is faster to manage indexes in batch than one row at a time). Then insert into the new table select * from the old. After population, any indexes (including the pk) can be applied and add autoincrementation advanced to the next value you want to generate. 

I am getting a typical group by error that one would see when a field is not in a group by or an aggregate in the select. 

At my work, I am going to be moving millions of records to a different server, and removing them from the source server. My DBA has set up a backup scenario where change backups are taken every 5 minutes. He had this warning for me regarding deleting the records: 

I have a query that is working fantastically, except that I would like to force some records to appear. I am using SqlServer 2016, and this query will ultimately be used in a VIEW and used by SSRS 2016. If the desired behavior can be done in SSRS, or even changing to a PIVOT or some such, I am open to that option. I will put some DDL down below to mimic the example images shown. The data I am pulling from looks like the below: 

I have a report that is "working" fine except for an issue. I have four dropdown list parameters where I am getting the values from queries. When I select a value from a dropdown list, it selects the next value below what I wanted to select, and "removes" the first value as an option. For instance, one of the dropdowns holds a list of payrolls. When getting the list from a query, it returns payrolls 1 through 121(or so), which is perfect. However, if I try to select any of the payrolls, say payroll 10, it will show me that I selected payroll 11, and the option to select payroll 1 will no longer be available. ALSO, possibly tied to the above, the report sometimes refreshes when I select "view report" and I have to try to choose the payroll again. These are not cascading parameters. The values are all derived from two queries where I am selecting a distinct list of employees for two of the parameters and a distinct list of payrolls for the other two. I am at a loss as to why this type of behavior is even possible. 

However, while only two states are pictured here, there could be 50 states. That part is done and looking good. The trouble I am having is to have the totals across all states at the bottom. At the very bottom of this post is a quick look at my parent report in SSRS design view, if that seems the best way to go. Below is an example source data table and my current query. The ordering doesn't really matter, it is just for ease of viewing. I am using a cross apply, but whether cross apply or pivot, it doesn't matter to me. 

The following is an untested attempt at distilling the problem into its basic components then unions the results together. The last query (with the correlated subquery) can be turned into a join if the introduction of orders does not cause a Cartesian product. I can not test with what is provided to see if this is a valid assumption. 

@rathishDBA has a legitimate point, but sometimes intensive disk I/O must be performed on the database server. My recommendation is to run the job at reduced priority... To start a process at reduced priority (default nice is 0 - kernel runs at -20, +20 gives process lowest possible priority)... 

It seems the most important thing is matching time out with the time in. The query below shows one way this can be accomplished. The approach below attributes time worked to when the individual "clocked" in... there is no attempt to attribute the time to the day in which it occurred (there are other questions on this site that address that need). 

In order to benefit from this in an indexed manner, I would need to know the subnet mask (the number of bits to shift). Otherwise, I'll either be systematically comparing bit shifts (i.e., blindly shift for each possible netmask (from 0 to 24 bits)). I have other sources to optimize, but optimizing the IP2Locationâ„¢ LITE IP-ASN Database found at $URL$ would be a proof of concept. The table... 

Try rewriting the query in different ways to see how the execution plan and times change. Changing the order in which tables are accessed, using set operators, indexing, etc... can make a huge difference. The two approaches suggested below are using the MINUS set operator and using NOT EXISTS instead of NOT IN. In both cases, the queries are driven by the SHU_STUD_TERM_SUM_DIV table. This will reduce the number of rows joined to NAME_MASTER. The MINUS set operator works by filtering the results of the first query with he results of the second. This allows the MySQL tables to be joined directly. The NOT EXISTS will behave like the NOT IN (each row will query the MySQL tables) but does have the potential of comparing a smaller set of values (only those that directly match NM.ID_NUM). Using MINUS: 

After desperately trying everything from restarting and updating SSRS, to clicking my heels three times and throwing salt over my shoulder, the solution is to not use the Microsoft Edge browser. When I switch to using Chrome/Firefox to run my SSRS reports, the behavior is removed. Microsoft Edge version: 38.14393.0.0 

Below is some sample code and data. I am trying to stay away from only using group by because I have ~30 columns that needed to be included, and having 25 columns in a group by seems...unfortunate. In the data you can see that Payroll 0048 has two records, and the column has a value of , essentially meaning the person was paid in two different checks. Conceptually, I need those two records summed up into one for the end result. However, things are complicated by the fact that I am using a cross apply to fill a business requirement that regular/over-time/double-time are expressed in new records instead of columns. The first select statement is without the SUM and GROUP BY functions to show what the data kind of looks like, but without the desired grouping and sum. The second select statement attempts to get the desired sum and group by, but gives the error. I am just having a heck of a time finding my problem. Could be an oversight or just a brain fart using CROSS APPLY wrong or something. I am also open using another method if there is a better way. As a side note, the is just a hack so I do not have to group by that also. 

And here is the results I get in SSRS preview. Not ordered how I want at all :( As far as I can tell, SSRS should support ORDER BY in the dataset query. I also tried removing the ISNULL( ,1000), and the order by still didn't function as desired. Thoughts? 

I have a dataset text query and I would like to have an ORDER BY in it. The issue is in SSRS, the ORDER BY is not working as desired. However, when I run the query in SSMS, the output is ordered as I would like. This image is in SSMS where it is working properly. The payroll = 000004 is just to isolate a specific payroll to make it easier to read. The ISNULL(OrderByNumber, 1000) is just to put the total row down at the bottom.