First I wouldn't name the directive and an attribute the same The attribute can be better named like or . Next, is not defined on your controller. This is counter to the basic MVC structure where View reads from the Model, which is here the ViewModel defined by Angular controller. It works but makes the code fragile and harder to read. Ideally the view should not write into Controller, but rather use commands defined by the controller to update the model. I don't see your filter and its purpose. But normally you would either create a dedicated Angular Filter and put it into the view, or let a dedicated service do the filtering and the counting and anything else. There are several responsibilities here and it is better practice to separate them, rather than put all the logic into one directive. 

Router - Which is the component which takes a URI (or if you're really fancy, a object), and spits out an object that represents the matched route. Route - is an object that represents a single route. It contains information about the URI pattern, the controller and action, and the variables that need to be passed into them. 

This code is 100% XSS proof. And it doesn't matter what has in it. Note that with this method you do not escape for HTML before you insert to the database. Always escape as late as possible. A note: This is about escaping HTML. It will not help you escape things like JavaScript or URLs. The following will not be escaped properly: 

Having looked at your code I can see one major problem - your directive hides but does not isolate its scope. That makes it vulnerable to both external and internal changes. Internally you may change a variable and forget to adjust it and suddenly your directive is using the same named variable from outside! Imagine all the bad things can happen to your directive! That makes the maintenance a nightmare - you can't even use reliable tests to catch the "leaky" variables that you forgot to declare. They will keep "sleeping" quietly deep inside your code until the wake-up explosion :) Your directive seems to be intended as encapsulated drop-in component. For which Angular's isolate scope is the best solution. The isolated declaration inside your directive tells you exactly which attributes are "allowed" inside and how are they named. You see it clearly right at the top of your directive, which makes your code more readable and maintainable. Now you can change the outside-inside coupling nicely inside that declaration. That also would make your code cleaner, shorter and DRYer. As side remark, I would generally try to avoid, if possible, the low-level "system functions" such as , etc. They are used by Angular internally to expose more user-friendly (and reader-friendly) API to you. Such as the isolated scope binding and using filters rather inside your templates (i.e. what it is meant to). 

Some context I've been tasked with supplying an escaping function to arbitrary CSS values that are entered through a form. The goals and caveats are: 

Note that this way the User has no knowledge of where the data in it came from, could have been files, could have been a session or even a REST api. 

Now for the more juicy stuff. Is your library useful? Why would I, a user, want to use your library instead of just writing HTML? Or generating HTML for that matter? The usage code seems a bit over-engineered, too large and "clumsy" to actually be useful. Truth be told, it's a nice project to improve your knowledge with XSS and the structure of HTML and perhaps even OOP, but it's not actually useful in the real world, because generating HTML is simply easier. 

That tells me as reader a lot and leaves vast room for future changes without breaking the rest of your code. Further, if you want to make your code readable for others (or even for yourself after a while), I would recommend to use descriptive names for your functions and variables. When I read 

There is a lot of repetition in the code. and similar after every switch can be replaced by single Every time a data object is created, which deserves to be outsourced in a dedicated service. So is the server request - NO inside a controller. Controller's responsibility is only to glue the data from services, not to do more. has way too many argument, a single object argument makes it more readable. Also usage is preferable. 

And that last snippet the only thing that's specific to your current DOM, so when your DOM changes, you don't need to change all of your code, just the bit that interacts with it. Additional notes for future snippets (just general things I've noticed): 

It's perfectly fine to not reject if there's no error. Yes, there was an error loading the image, but it isn't an exceptional situation, it's not something you'd because of. Your function is actually there to check if the image loaded fine or not. 

Business rule validation - "User chose this city and this country, does it make sense?" or "User said he was born in 2012, does it make sense?" Data-integrity validation - "User already exists in the database" or "Username should contain between 3-20 characters". 

The latter creates a global variable that I have to remember and maintain and carefully watch not to misprint. 

You define as array of anonymous functions, which is a bad practice in itself. You can't reliably test these functions as your index will change any time you update your array. A better way would be something like: 

Also it does not feel right to do DOM manipulation with jQuery-style, maybe use dynamic property instead. If having additional elements in DOM is really a concern, there are also and . Though I personally prefer exactly because this way I don't have to rebuild the DOM. To put this into perspective, I have tried using on my site 33hotels.com, which does rebuild the view every time the route is changed. That felt in considerable delay. Instead I have all my Views inside my DOM at all times and only them depending on the route. The performance difference is dramatic - it now feels instant. Finally, both templates have common fragment, which does not make code feel DRY. Upon any change you'll have to edit each of them. I would simply keep the common part outside any directive, and put the dynamic part inside whatever. Also note that the HTML tag has semantic meaning, not presentational. That is, it marks your main header. Any presentation adjustment should be done via CSS. 

Depends, are the pictures extremely heavy or otherwise take a burden on the server? If you're uploading 100 2MB pictures at a time, that may be the case. If you're only upload 2-3, it wouldn't. Don't generate the thumbnail in advance. Generate it on-demand and based on the requester's needs (i.e. an avatar in a forum is 64x64, but in the profile page it's 128x128). Save the results normally to a file and create a database entry for it, so that next time, you won't have to generate the thumbnail again. It is. It depends on the rest of the application. Personally, I'd go with a more OO solution, but that's because I understand how OO works and how to incorporate it into my needs. Split the code into smaller pieces of work. Either objects or functions, that do small tasks each (get input, do something, return output). This will help code readability tremendously. 

Naming something "current" makes me wonder what it is. From your code, I have no idea, so it forces me to spend time on looking around and getting clues, for what should be made clear right up front. 

Nice work! I presume the complicated way of getting the right element measurements is to cater for many browsers, won't comment on that. 

Since you are loading before , your Angular will have all properties provided by , so this is perfect way to use on top of Angular. This is also how you would wrap a plugin inside an directive, but see also the jQuery Passthrough directive that does exactly that. What would be a bad use of jQuery is using (as you mention) to refer to a DOM element. That would break the encapsulation provided by directive, since the inside of the directive should not know anything about the DOM structure, beyong what is provided by Angulars API. However, your event listener inside the directive does break this encapsulation! The event is not provided by the directive's API! (Which also makes your directive less re-usable.) Instead it is sent via another channel that is not visible from your template: 

Figure out the unique entries (aside from name_alt) Iterate over each "group" of unique entries, and each to a single object push each newly created object into a new array. 

What's wrong with your sanitizing Sanitizing is an important job of the server. It makes sure nothing nasty comes in and affects what your users are seeing/experiencing. Sanitizing is done as late as possible, for a simple reason. When the username is entered to the database, you shouldn't make assumptions on who is going to use that username. It could be your application later on, it could be an API you may or may not choose to provide one day, it could be a desktop application or a mobile application which does not care for HTML formatting. When you extract that value from the database and are about to put it in HTML, that's the point where you should escape for HTML using . Maybe at a different point you may want to output it to a JSON response for an API, in which case, is good, but not as much. 

I would try to split into simple pure functions doing one thing each. Search for Robert Martin aka Uncle Bob advices on clean code. Is this just a helper to display an array: 

This way your data are completely separate and decoupled from the code. You can edit, add, delete your questions without making a single change in your code. Also you don't need to number them as those can change but your code won't break. 

Ideally your code should be easily understandable where you read it. The buttons says "Go to edit", then is better readable as . Also the is not a class, so general convention is not to capitalize it. But what is ? I don't see where it comes from, so I'd rather avoid it there. If it is already on your scope - it is already accessible inside your controller - no need to pass it again. Also it looks strange that the same Button leads to different things - that may be confusing to the User. I would not put different routes inside the same function. Either put clickable links to different routes directly inside your HTML, or use dedicated functions to update the location.