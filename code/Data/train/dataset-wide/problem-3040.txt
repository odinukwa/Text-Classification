My Question: Do you think this is an appropriate design? I believe the biggest drawback to this is that the is mutable. Brainstorming a few other ways: 

It would be nice to have a code review to show me where I can improve on readability (along with other things you may find!). I've been trying to clean it up and refactor a bit, but a fresh set of eyes would be nice. I went a bit crazy on comments because I wanted to make sure I would be able to look at this in a few months and not forget why I did something the way I did. But perhaps putting some of that info in a github wiki would have been better. 

I've implemented the coin change algorithm using Dynamic Programming and Greedy Algorithm w/ backtracking. The description is as follows: 

There is one catch to this idea. The and are mutable (which I believe immutability is strongly suggested by Spring). It's possible that the and/or fields are supplied by the client/UI, or they might not be (orgId will always be supplied from the UI form). If they are not supplied, we query our database for them. If they do not exist in our database, then we throw an error. They almost always will NOT be supplied. To do that, I change the to override the methods and look up the or if they are not provided 

I'm integrating with a 3rd party vendor that has and in it. My tool is a user administration tool that allows us to store information in our local database about the and that we manage in the 3rd party vendor. So the and are stored in the 3rd party vendor as well as our database (we act as the middle man sort of). I'm at a crossroads with some ideas and would like to hear what others thought of the following problem and my solution. Before I dive in, we're using Grails 2.4.4 One use case for the tool is creating a . We create the user in the 3rd party vendor via an API call, and then we store information about that user in our database. There are many uses cases like this and there are 3 fields that are always in common between them, an a and an . These 3 fields are required for just about every API call we make to our 3rd party vendor and most of the result in an API call being made. For this reason, I had the idea to make a "Common" with these 3 fields on it that can be extended by another Command Object. 

There are two cases to consider, depending on whether is even or odd. The easier of the two is when it is odd. Suppose, for example, and , so and is odd. In this case the range can be divided into and . Let be the array that will hold the products. When calculating: 

It remains to construct the method to return an array similar to above. As I've rambled on awhile, I'll leave it to others to cover that. 

Suppose, for example, and are to have and tuples, respectively, and in cases, the first element of a tuple in matches the first element of a tuple in . Thus tuples in have no match in and tuples in have no match in . Then 

Here is an example of test data with 8 4-character words, of which 3 are prepositions, and a sample size of 2. 

where is one member of the hash and is another, but since we are sorting on the keys, and do not use the values and , we can replace the latter with underscores. We could have done this differently, using without a block, had we used instead of for the key for directories without trailing numbers, and chosen so that it was larger than any of the other keys. This is one way to do that: 

I don't know if you really need to create classes for checking each of the substrings in the file name prefix. After all, there are only two types of checks that need to be made: against a list or matching a regex. Consider a simple, straighforward approach like this: 

Again, the block is not used because does not have a key . The third element of is passed to the block: 

Your loop iterates over the whole array even after it encounters a that is contained in . This is not necessary – it is sufficient to terminate the loop once an array element is found to be contained in , which is also known as short-circuiting. The solution suggested by vishva is short-circuiting, as stated in its documentation. 

Overall, I think your code is clear, well structured and easy to follow, and the variable names are informative. However, I found some flaws with it, which I will address first. Correcting (potential) bugs 

As Koekje has already pointed out, using recursion here is inefficient, because for every valid location (x, y), will be called not once, but the number of times equivalent to the number of possible paths leading up to this location. I don't know what the overall time complexity would be, but from looking at the number of method calls necessary for every \$n\leq24\$, which can be calculated by summing the number of possible paths to every valid location for this \$n\$, it seems that it is some monstrosity slightly worse than \$O(3^n)\$. Equipping the recursive method with a cache would be a way to rectify this, but I can imagine that this could make the code a bit ugly. Instead, you could try to fill up the lookup table not via recursion, but in an iterative manner. So you start out with this (let's say \$n\$ is \$6\$): 

Judging by your comment, you already seem to be aware of the method , so there's no need to explain how to chain those comparators using this method. Unfortunately, the forth comparison stage does not fit into this pattern. Of course, you could ditch the nulls-first comparator and write your own generalized version of it which, instead of comparing the two values with , checks a given against the values: 

Diagonal detail It's a small thing, but in you don't need to compute the diagonals of length less than four if only arrays of size four are to be considered. In fact, you should not, as it is conceivable that a diagonal of length less than four could have the greatest product! Revised class definition So this is what we now have (more or less): 

See Array#reverse_each and Fixnum#<<. The following is an optional extra that is not directly related to your question. In the code directly above, the first value passed to the block will be 

but only a fraction of these are shown in the documentation. Perhaps a reader could provide an explanation. In any event, the two methods I mentioned are used as follows (when applied to @Ben's example): 

If we cash out at the end of day , the net gain is . For example, if we cash out on day , the net gain is (). Therefore, if we enter the market on day , we maximize net gain by computing: 

It takes a couple of seconds to generate the hash, then each random string takes very little time to generate. [Edit: Flambino pointed out that it makes more sense to use an array: 

[Edit: I'm not happy with my solution after reflecting on it. Constructing the array is wasteful, as one can just maintain a running count, as others have done.] Here's a slightly different way of looking at it. Let be a car position, west to east. First compute an array , such that: 

Though I am not a professional developer, I will venture one suggestion: learn how to use String methods and regexes to fullest advantage. Sometimes it is necessary to use , , etc. to convert a string to an array of strings (possibly single-character strings), manipulate the array elements, then re them into a string, but there is a lot you can do by working on the string directly. Here, for example, you can use String#gsub with a block: 

Edit Here is a code sample to illustrate what I mean by using an iterator. By the way, I replaced your loop with a loop, which I think is easier to read because it limits the scope of to the loop itself, whereas in your code, unnecessarily lives on even after the loop terminates. 

You ignored my comment asking for clarification, so I'll just assume that I was right in thinking that your code doesn't actually do what you intend it to do. You write that, for a match, the class and model needs to match, but your code compares only the model of the search key with that of the items in the stock. It doesn't check whether an item from the stock has the same class as the search key, it just ascertains that the class of the stock item is one of several classes, regardless of whether this class is also the class of the search key. In fact, your verbal description of the code is very simple, and the translation into code should not be much more complex: 

Instead of questioning whether it is a good practice, it would be more helpful to be aware of what your first code actually does. JLS §15.9.4 has this to say about the creation of an object: 

This a bit more complicated to read than your code, because you have to manually find the element and keep track of the index (which you need to calculate the number of steps), but on the other hand, you only have to iterate over once per character from because the removal is accomplished via , whereas your code would require two (implicit) iterations if you make a instead of an : one for finding the first occurrence of the character, and a second iteration for removing it via (if is an , then would be able to find the element in constant time without needing to iterate over the list, but the actual deletion would, as already mentioned, require all subsequent elements to be moved, which is not the case with a ). Update Inspired by your idea not to reset the iterator over when there are consecutive identical characters in , I've tried to apply this principle whenever the next character in has not yet occurred in during the last iteration over , and not only when the next character in is identical to the last character from . The trick was making the check whether a character has already occurred in cheap enough so that the savings in loop iterations are not outweighed by the overhead of the check itself. I originally tried putting the characters encountered during an iteration over in a , which would be the easiest solution, but this turned out to be far too slow to be worth it. Then I tried using a array that contains a value for every possible character that signifies whether this character has already occurred in , and this did indeed speed up the program, not in a groundbreaking manner, but definitely noticeable: 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

I would take a different approach. First I would convert the number to words using an idealized numbering system, with none of the complications of the tens or teens. By way of example, 413,230 would be . Here would be . (I have shown the results of this first step in the examples below.) Then I would use the hash to correct the grammar. This results in there being relatively little code, but a fair amount of data. Note that the order of the elements in the hash is important. (Insertion order of hash elements is maintained in Ruby 1.9+. This is the first time I have found that change useful, but useful it is.) The substrings must be replaced first, then the substrings (the numbers 11-19) and lastly the substrings. Please let me know if what I have is not quite correct. 

Explanation The problem is to determine the number of pairs whose difference equals . That is equivalent to asking for the number of elements that can be matched with a value that is larger in value by , such that no element is matched by more than one element that is smaller by . The first step in answering that question is to replace each element in the array with two elements, and , where indicates it's the original number and indicates it's the original number plus . We then group all elements on the first value in each 2-tuple. For above, this grouping for the number is as follows: 

And the simpler the design of your code is, the easier it will be to spot opportunities where you can improve performance, which is, after all, what your question was originally about. 

I think the place where recursion is least appropriate is when you advance a queen until it is safe from all queens with a lower index (i.e. the last line of the method ). This doesn't really seem like a recursive process to me, but rather like something that calls for a loop. 

Taking all of the above into account, a final remark about your code in general. I think your code would be clearer if you separated the logic of generating all possible n-size option combinations from the logic of determining their frequency in your input data. Actually, once you have the first part working, the second part should be a piece of cake, since, for every combination, you only have to go through every serial number and check if the combination is contained in the serial number's options. But note that it will only be a piece of cake if the types of your variables actually reflect what you are trying to represent with them. The loop construct you yourself criticized in your question is a prime example: 

Your code is slow simply because it does much more than it needs to. It copies the first half of the original string to a new , but then, you only use this to access its characters by their index, which you could also do with the original string, since the indexes of the characters in the first half of the original string and those in this new are identical. So you might as well omit the variable and use the original string in its place when you iterate over every second character: