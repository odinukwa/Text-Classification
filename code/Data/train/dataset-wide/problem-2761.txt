Use an if-statement to check if you are currently processing the last number. This will get rid of the last for-loop in your current code, which only loops through the array and shows the non-zero number it encounters. There is some things that can be simplified within your algorithm as well. 

private final I think this is not the first time I'm telling you this. The ints in your enum really should be (At least final!) 

Now, to convert from Kilogram to gram, you can lookup the value for and then use . In this case, \$1 / 0.001 = 1000\$ Then, once you have converted to gram, you use your as normal and convert to that specific unit. 

Make that . Whenever possible, make variables final. The same goes for fields in your other classes. Prefixing fields with is something I would not recommend. Although I've seen a recommendation about that somewhere a year or so ago, about prefixing internal fields with and static fields with , it is not something I see a lot in today's frameworks. I would recommend to not prefix those names. Most IDEs today have a code highlighting feature to separate between these. 

The whole thing is kinda weird though, I can't really see a particular use-case for this kind of method. 

It seems that the variable can be replaced with a boolean(?), which in that case would make the function clearer. You could then have each function returning a bool and make the caller even smaller: Given , the caller can be reduced to this: 

This code is very easy to understand. However, you asked for optimization and my code doesn't look all that effective; it is possibly slower than the original. Particularly, we have multiple checks for '\0' all over the place. Note that any truly meaningful optimization requires that 1) we have actually encountered and measured a real performance problem, 2) we have noticed that the compiler is doing a poor job at optimizing that particular problematic code, and 3) we have fairly good knowledge of the target CPU and hardware. It a bad idea to manually optimize code if those 3 above conditions are not met. Still, I'll attempt a manual optimization of this, since it was requested. It may or may not be more effective. Branch prediction may be a more serious concern than the number of comparisons executed, for example. For what it is worth, here you go: 

No, that is very good practice and a good habit. Particularly, there are many dangerous, implicit type promotions going on in C, that explicit type casts can prevent. However, if you want to be explicit, you must actually have quite a deep understanding of what's going on between the C lines. Until you do, you will end up causing more problems than you solve with this coding practice. Also, you do a couple of pointless things that only clutter down the code. 

Summary Overall, I'd go with one of the other suggestions you've received here. But even when you do so, I hope you've learned something from my comments above. 

Naming and interface should instead be , there's no need to keep in the name, there's no need to restrict the interface to only enums either. Your questions Reflection? Yes, this line of code is using reflection: 

If you want to somehow dynamically add items, then an enum won't work well for you, use an in that case. Although I think an enum is good enough for now. 

You are currently creating one each time you are generating a number. objects are meant to be re-used (for "better randomization" - I know it sounds fuzzy but trust me on this one). 

refers to the second element in the list, not the first. Either rename the variable or use . With that change, you don't need to use a list size of 1 as a special case. 

By -ing your results, you won't consume any extra memory at all. There is a lot of magic going on behind the scenes. The point is: When you use yield, your method will be processed on an on-demand basis. It will return something, process that, return something more, process that, return something more, process that, and so on. I hope this will help you on your way to rewriting this method. 

With this optimization we have managed to reduce the number of instructions and the number of branches both. But as you can tell, the code now turned quite obscure. Explanation: The fundament of this code is that one lap in the loop corresponds to one character in the input string. The bool variable keeps track of whether the code is currently looking for spaces or non-spaces. We are only interested in the places in the string where we go from looking for spaces to looking for data, or vice versa. When that happens, we should start looking for data if we were looking for spaces, and the other way around. Also, in the case where we go from spaces to data, we should increase the word counter. The boolean logic truth table is: 

Overall, the code is acceptable and a common way to implement such algorithms. Below I have posted some things to consider: Dangerous programming practice 

EDIT Also, consider adding new line characters after each print, for readable output. Code with the above suggestions: 

Program design The main issues with your program is the overall design. I would recommend to study object-oriented programming on beginner level before even picking up C++, or any other programming language. 

And use instead of your string array. This will open up the possibility of many things, if you would like: You can match up your radiobuttons to an attendingstatus, by using a for example, which could reduce code duplication in the method by grabbing a RadioButtons corresponding AttendingStatus by using and using to get it's string version. I don't know your skill level so this might be a bit advanced for you, but if you are willing to learn, I really suggest that you start playing around with enums. You will love them :) Spacing 

Because of the result String being of a size that can be pre-determined, and you are handling chars on the way, I would use a (char array), and transforming the char array to a String using a String constructor. I believe this is more efficient than using a or any other approach. 

And one major thing: Just because some numbers sum up to 45 doesn't mean that it's valid in a Sudoku group! Consider these numbers: . Do they some up to 45? Yes. Would it be a valid group/row/column in a Sudoku? NO! This is why @Vogel612's solution is a whole lot better. 

I'm not sure what purpose your fills, I tried removing this code and I did not see any change. You also don't provide any way to provide any paint to the circle, and when I tried adding some color to the circle it's probably a good thing that you didn't. 

You should avoid all of these like the plague! Now, I know your specification says "use recursion". So what a professional would do first of all, is to question if the specification makes sense. In this case it doesn't - there is absolutely no need to use recursion here. Others have given you diverse ways of solving this with recursion. Here is an alternative approach which is efficient, instead of needlessly inefficient. 

(To avoid subjective debating and to demonstrate that these aren't just the personal, subjective opinions of a random internet person, I have cited a widely-acknowledged C programming authority as source for each statement made.) 

As others have pointed, out never try to re-invent the C language. It makes the code less readable and more error-prone, for no obvious benefits. Function-like macros in general are incredibly error-prone and dangerous (and a pain to debug), they should be avoided. If you for some reason need to use function-like macros, you need to make them safe, properly encapsulate them with braces and parenthesis. In addition, doing strcmp after strcmp in sequence like this, is very slow and inefficient, growing more inefficient with each "case" you add. This is unacceptable if program speed and random access are important. So as for code review, I'd strongly recommend to forget this whole program as quickly as possible, nothing good will come out of it. The proper way to write an algorithm that stores unknown, initially unsorted and completely random input strings, is to use a hash table. 

Do you see any common things there? is being checked on every . Sure, it is possible that it is alive in the first check and then dies before the second , but that is very unlikely and we're talking about microseconds of difference there. Do the check once, and then check compare with the number. 

(Now I see that toto2 has provided more or less the exact same answer) The important part of generics is that they provide flexibility in what type of data your class uses. If you want to make a KDTree of Points, you can use , but in another project you might want to use a KDTree of Cards, so you have . Then someday you might want to have a list of KDTrees of Points, so you get . 

These two conditions makes it a perfect for This will eliminate the need for a on a . means that it is a mine Once upon a time, I also used a special value to indicate that a cell was a mine. Later I realized my mistake. It is really much better to use an additional for the property of whether or not it is a mine. And you should definitely include a function. Not only does this make the code cleaner, it also allows a future mode where a can be both a number and a mine at the same time. (Trust me, the possibilities are endless!) 

Now you can define a look-up table of functions corresponding to the logic table above. Do this by declaring an array of function pointers: 

I'm sorry for my bluntness, but this code is absolutely horrible and unsafe. To worry about global variables while using a mess of function-like macros, together with /, is kind of like worrying about the paint of your car while smoke is raising from the engine and the breaks are dead. Apart from that, trying to re-invent the C language is always a bad idea. Mainly because it confuses other C programmers. You can implement exception handling in much safer and more readable ways: 

Overall, the program is fairly well-written and clear. One particular good thing is that you have grasped the concept of private encapsulation in C, by placing the static keyword in all the right places. You also use const correctness for your function parameters. All of that is excellent program design, so keep using it! Below are my comments regarding various issues in the code: Bugs found: 

Unlike any code using recursion, this code is efficient. Feel free to benchmark against the recursion versions and note the vast improvement in speed and memory consumption. 

The multiple if statements based on booleans can be optimized in the same way that you optimize digital logic in electronics. Make a logic table like this: