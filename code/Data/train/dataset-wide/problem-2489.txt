I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them. 

The latter is nice because you are certain you won't have any attributes from the last run leftover, messing with your methods, the former is nice because you don't have a multitude of instances (I am not sure what happens with the first application when you create another one, since it isn't stored anywhere). Not exactly knowing which way was the cleanest to do this, I asked a question on SO about resetting classes. It seems that calling or any -methods directly is bad form. We could however move the definition of the class attributes to and do the following: 

However, in most cases, only one of the points of the simplex changes between iterations. So only one point needs to be re-evaluated. Conveniently, this re-evaluation is already done in the previous iteration: 

You don't do this in though. If you have a list of length 4, the call will look past the end of the list. That's a problem. One that's easily fixed by the same checks as above. You probably also want to validate the input for . You don't want a position as input, and neither do you want an input past the end of the list. 

Your code appears to be a simple naive implementation to perform these operations and that alone isn't necessarily bad. However if you're taking too much time for their test cases, you need to reconsider your algorithm, how you represent the data and how you perform the calculations if the naive implementation is too slow. Every operation is an one. Count will suffer the most since you're trying to figure out which quadrant each point belongs to as you come up with the counts. Profiling your code against your test cases will not be very effective as you can bet they will have a lot more to throw at you. You need to find out how you can reduce these algorithms somehow to pass their tests. In fact, you can reduce Count to be with the algorithms I have in mind (the other two will have the same complexity however). Rather than just giving you the answer, I'll provide some pointers. 

Your code looks fine. It certainly works. The only thing I'd say about it is that you are repeating the incrementation in all blocks. You could just move that out of and after them and you'll achieve the same thing. 

The function is an integral function. It's arguments and return type should be integers, not doubles. By using floating-point arithmetic here, it is also probably not as fast as it should be. Also, your loop may start at , save yourself the iteration. :) There's no sense in making in your function a . They should be typed based on how you use it in this case so it is absolutely clear. It would also be a good idea to rename it as it is not a standard function (that only works for positive integer exponents). That assumes you're not intending to expose it for use outside your module. If so, you should probably make it as well (same for ). Also, the similar arguments with your function. There's no sense in making your loop variable a , it should be an integer anyway. With the above two fixes in place, you can easily fix this. Rather than looping through all the terms, alternating between positive and negative terms, it might be a good idea to help the compiler and processor out here and split these up as separate loops to remove the branches. That way the compiler could possibly unroll this better and you're not potentially confusing the branch predictors. Try it out like this: 

In addition to the other remarks: does exactly the same as , so you could either call that directly: 

With advancing insight I have found a few issues with the code. Check for convergence doesn't work properly 

I have been trying my hand a bit at creating a big integer class in C++. This is a continuation of a homework assignment. The class stores a big integer in a double linked list. Each slot contains 8 digits of the number. It is possible to create an instance from an integer or char array. Negative numbers are supported with a bool sign indicator. I implemented addition, subtraction and multiplication, aswell as their operators. I didn't manage to come up with a good division algorithm though. The code: BigInt.h 

I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

I have been refactoring this code myself as well in the meanwhile, so I thought I'd post some of the insights I have gained myself. Class inheritance Instead of passing a instance when creating a , by making a subclass of , I was able to reduce the amount of information that was stored in both classes. This makes accessing the attributes and methods of in 's methods shorter as well. does nothing 

It seems the only two unique things about the blocks of code are the Tables that you are searching/adding to and how the s are obtained (from different types). You could just make your method accept two additional parameters, the table that is being searched and a lambda which selects the . You'll just have to rewrite some expressions. 

I have to apologize, I have changed my review as I wrote this due to some details I overlooked as I was writing. Thank you mjolka for pointing out my mistake. For multiple collections, the new implementations will always be a win over the aggregation. In the aggregated approach, each sub-instersection needs to be determined for every collection. In our new implementations, only a single set intersection needs to be maintained. The new implementations will not beat out the aggregate method in the single collection case however, because the aggregate will simply pass the collection through as the result untouched. The new implementations will always do some bit of processing. However again, I feel that if set semantics were preserved, this difference will probably be cancelled out anyway. 

Do you see the problem now? There's a couple of ways to fix this but let me start with what you should have done always. If you ever have a block that would span multiple lines, you should always wrap the block in curly braces. That way there's no confusion what goes where. It's more forgivable to not include them if it's just a single line (just like you have in your individual statements) but all three of them belongs to the body so they should be in braces. The other thing to about this code is that those three statements are mutually exclusive. Only one of them could ever be hit for a given character, . So you shouldn't have created a series of statements like you did here, but instead a set of / blocks. That way the following statements don't get executed if the preceding one was satisfied. This could have fixed the logical error for the loop too but it's still important to include the braces regardless so there's no confusion. That block should have looked more like this: 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

Because I am new to C#, I am interested in advice/commentary on good form, but I am also interested in the efficiency of this implementation. 

Only during shrinking do we have to evaluate more new points. So we can extend the code where we break the iteration with a modification of the array and move the loop evaluating the simplex to outside the while-loop. 

Length You provide a method to calculate the length of the list. But from the moment of creation of the list, you should be able to track this length. If you add a private counter, increment it whenever a node gets added, and decrease it whenever a node gets deleted, you should be able to instantly provide the length, instead of having to compute it each time the user requests it. Repeated code You provide methods for deleting the first node, the last node, and any node. In the first two methods you kind of repeat the code of the latter method. You could redefine those by calling the latter: 

There is an unnecessary amount of calls to . Each iteration starts by evaluating all points of the simplex: 

is defined, but used nowhere else. Also the use of is bad (was an oversight). Indirectly still iterating over 

Then use regular bit manipulation to set/clear the flags. Do take care in using this if you have values that represent multiple values 

I was debating whether this would be more useful as a or an , considering all the operations you were trying to add to it. A struct would have been a safer bet. However enums are much more lightweight and the way you're using it, it doesn't need to be more complicated than that. 

I think it would be much cleaner to utilize partial methods to create your logging statements. That way you can log wherever you need it and can disable the code my omitting it the logging function definition. By using partial methods, if the definition is omitted, no IL is generated for the method and calls to the partial method are ignored as if it was never there. Just mark the class , define the signature of the partial method and call it like normal. Then wrap the actual implementation in the conditional compilation blocks. 

Note: The calls were needed on all invocations to ensure that the intersections are actually generated. Run on my machine with multiple collections: 

My only real criticism is the variable names. Local variables or parameters should not be prefixed with an underscore. IMHO, it should only be allowed for private instance fields. So rather than using , it would be better off as (though I used for the name here instead). Parameter names are very much part of the documentation as well (especially so in C# and .NET in general). The method is called which suggests you provide a . The parameter name should reflect that. Call it since that's what it is. Personal preference but I also prefer to write out the full/reasonable-length variable names in queries. I reserve significantly shortened variable names (i.e., one character variable names) in lambda expressions. 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

This checks if the minimal and maximal function values of the simplex are sufficiently close together, but an easy counterexample shows that this nowhere near guarantees convergence: Consider the function . Of course this is trivial to minimize, but using this algorithm, we would have a simplex of 2 points. Let those points at some point using the algorithm be and . Then the functionvalues will both be , and the algorithm will stop. Instead, I changed this to checking the value of the centroid of the simplex. 

The second option above only works because you run the entire functionality of the class from within the method (which may or may not be bad form). When the new instance is created, the back and forth prompt is executed right away, so the moment it would go out of scope and get deleted (because it isn't assigned anywhere), is only after you are done with your input and output (and possibly been given anyother option to reset).