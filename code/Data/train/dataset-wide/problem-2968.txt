You're doing a worrying amount with statics. Not only are you holding state in , you're also accessing what I can only assume is some dependency in . While you say multi-threading isn't an issue, over-reliance on statics also sacrifices your ability to take full advantage of OO features like polymorphism. The variable is fixible easily enough by just moving it inside the method, where it should be anyway. But I think more generally you should make sure you're not making things static over-eagerly. 

Let's address these one by one. Seconds As you can see from the description above. Seconds are really simple. We really only need to decide whether they're greater than or equal to 30, then we can forget about them. But look at how much complexity they have in the code: 

Simple vs. SOLID As I'm sure you realise, it would be possible to do a much simpler implementation of this. As a sketch, the main execution method may look something like: 

Notice how I also removed that last check- if we've broken out of that loop, we already know that is true. 

Polymorphism I won't write out a full OO version because Dmitry Nogin's answer already demonstrates this really well. But to distill out the key point from that, if you're going to use an OO solution, you want to use polymorphism. If you're doing code like: 

This goes back to what I was saying about this being difficult code to review, because it essentially exists to fulfill requirement which is already fulfilled so simply by the .NET framework. However, if we go with the fiction that exposing the counts for all those different methods for a single string is something that is done commonly throughout your program, then your approach is sensible. Using the LINQ-style counting above, you can remove the second statement and all the s inside, replacing them with one-liners. You can also remove all the variable declarations and feed them right into the result constructor, since they are so simple: 

(That's just about pushing the complexity of what I'd want in a single line, so depending on taste you could separate that out by first assigning the individual calls to booleans.) 

With the former being the much higher priority. For that reason I chose an interceptor as the trampoline construct, using Castle's dynamic proxies. (EDIT: As pointed out in the comments, the CLR will sometimes optimize tail-call recursion and avoid stack overflows. However, my understanding is that it does not always do so, and makes no guarantee about ever doing so, and so it's generally not reliable enough to avoid exceptions in many situations) The Code 

Finally in addition to that we need a way to indicate when we're done, which is when while bouncing, instead of ascending to another invocation, we get a return value from our invocation. Limitations While this was a fun experiment, it has significant enough limitations that I doubt there will be many applications where it's really appropriate, especially since the alternative always exists of simply converting any tail recursive method into a loop. I'll list the main limitations here mainly so they don't get repeated in answers, but also in case anybody has any suggestions in alleviating any of them (which fit within the scope of a code review, anyway) 

It seems to have 3 possible paths, and only one of them actually does anything (since the other two just set to ). So it looks like this is actually trying to say: 

You know the and need to be in there because they're the ones in stacks. The way I've done it I've replaced the class with an iterator method, which necessitates the being passed back and forth rather than being kept as a class-level variable. From there, it's fairly simple to rework what you have currently to a new version: 

(In both cases, would be a initialized outside the loop) Putting it together And just so you can see how nice it is with all those changes, here's roughly what it would look like: 

You may be able to come up with a better name than . The default implementation would be very simple, with just returning the appropriate , and and passing through to the corresponding methods on the and respectively. Then the repository would never touch the or directly and use this instead. Because this would be so thin, and should pretty much never change, it wouldn't need its own testing, and would be straightforward to mock. For the tests so far, you'd just set up your mock to return for the method, and ignore the other two. It's a bit nasty having to add yet another abstraction layer, especially as all it's doing is just isolating code to not test, but to me it seems like a good way of dealing with the lack of an easy to isolate and . Data builder pattern The post repository test class contains a couple of tests where you're creating a few instances of . It's likely that, especially as the class grows, this is going to be a common task. This can lead to a lot of repetition or near-repetition. It'll be even more of a headache if you start requiring properties to be populated (either by using a constructor with required parameters, or by having some validation like ). It's likely that you're often going to only care about a subset of the properties on , meaning you'll be having to pass in a lot of dummy values. Plus, if you add any new required properties to , it'll break all your old tests, and you'll have to fix them individually. Yuck! So if you have a class like this, which: 

As you already said in your question, your algorithm is a bit strange. Your alternative algorithm is much better. Writing it in the same recursive style, an outline would look something like: 

Like your code, this is technically correct, but is less successful in capturing the structure of what's similar and different between the messages. So trying a more literal interpretation of the first statement, we can write: 

Given this, I'd be a little reluctant to actually use this kind of approach unless I was dead sure that a) the level of repetition for a simpler approach would be too much and, b) the rigidity of which test data I can use would not be a problem. As it is, if you're not planning to write more tests, I think a) is false, and if you are planning to write more tests then I think b) is false until they're done. Alternative Even if you do want to try to cut down on repetition, you might want to look at an alternative, like the attribute. You could, for example, parameterize a test method like: 

Now this reads much more clearly. The tree height is changing because it is growing, how much it grows depends on its initial height and the season, and the season alternates every time the loop is run. There are other options with the alternation too which, depending on taste, you may find more readable. Like: 

Resolving That last problem is the one that screams out most for a particular answer, so let's start out with that. Say we've written a service class with a private method that does a complex query for us. Now we're writing another service class, and though the functionality isn't that similar, we find ourrselves needing the same query that was in that private method. We do the obvious thing and pull the query out into its own class: 

You will minimize the likelihood of having to make changes, and minimize the magnitude and risk of the changes you have to make. With just the information from the OP, I wouldn't create an actual class, because all I know is that code files need to be read and they need to be validated, and without answers to some of the previous questions, I would have no idea whether it's appropriate to group those two pieces of functionality into a file reader class. Potentially it might turn out to be more appropriate for the validator to be used by the code that calls , rather than an actual implementation. But if I did find out more and that seemed appropriate, and it turned out that invalid files were exceptional, the design would probably be: 

Finally a higher-level point. This example mixes together what I'd call presentation concerns and business logic. Usually those terms wouldn't be applied to such a small, straightforward application, but essentially, presentation is how you display and get input from the user, and business logic is the actual logical work that your application is doing. Since your entire application is so simple, this probably doesn't matter much, but it's a good idea to start early with thinking in terms of how you're going to separate out responsibilities. A single method shouldn't be taking responsibility both for presentation concerns (deciding how to ask for the numbers and print the response) and business logic (in this case, doing the number comparison). Refactoring these into two different methods your class might look like: 

I'm honestly not quite sure what your version is doing, so I can't compare very closely. But actually, there's something even simpler we can do. Really all we want to do is merge two lists in a special way: for each value, the number of times that value appears in the merged list should equal the maximum number of times it appears in each individual list. By taking advantage of the fact that our lists are sorted, we can do that very easily: 

OO or not The first thing to do is decide whether or not you want an object-oriented design for this problem. From the requirements you've described, there's a very simple solution that doesn't need any real design work at all: 

Naming By convention, variables local to a method should be camelCased. You seem to have a mixture of PascalCased and alllowercase, making it hard to see at a glance what a variable is. All lower case has the additional disadvantage of being hard to read. Your boolean check variables also seem to be named in the form 'VerbNoun'. This is rather confusing because it's usually how methods are named. It sounds like they're supposed to do something. for example sounds like something that validates a port. A name like or perhaps more clearly states what the variables are. Extracting methods Looking at both of your methods, they have the same structure: Check if something is valid, if it is then change the state of the form one way, if it isn't then change the state of the form a different way. Each of those are basically completely separate pieces of functionality, so I'd suggest separating them out. This would turn , for example, into: 

What's ? I'm guessing this was just a mistake, but don't leave variables lying around that aren't being used. It's worth noting that generally, you should give variables more descriptive names than this, but in purely mathematical contexts like this, sometimes and really are as descriptive as you can be about the role of a variable! 

So of those it's likely to be the second, if any, which is of concern in this particular case. My preference is to avoid the complexity of trying to implement my own hashing algorithm and let .NET do it for me: 

Now you get all the advantages of the rich functionality of , along with the guarantees provided by your original class. 

(The two parts of a "dual rate" would just be summed before being passed in, and either or could be 0) You can then carry around those variables however is most convenient for you. For example maybe you'd put the rates together into some property-bag class: 

How much money, and what the new index changes to, depends on the make-up of the queue (which is constant), and the previous index. This, I think, is the basis of your updated solution in your answer, but I think it can be done a lot more cleanly. From the description above, you can see that what you have is a mapping , so the data structure we're going to want is something like Based on that, we need two things: to populate the dictionary, and to iterate over it accumulating money. The second one is easy: 

Either As Matt H mentioned, it's probably more useful to think of your "Validation" class as an "Either". This is a useful decoupling of what functionality the class provides and what you happen to be using that functionality for. You should also keep that in mind with your implementation. For example, your uses the names and , but in general there's no reason to think that having a value indicates success and not having a value indicates an error. Perhaps you have a ! In the same way that Maybe can be thought of as "IEnumerable with the restriction that there is at most one value", Either can be thought of as "Tuple of Maybes with the restriction that exactly one has a value". So we can do the same process of encoding this in the class via the constructors: 

Generally these would go along with much more descriptive test method names stating the precise expectation which is being tested. That isn't to say there's anything wrong with the kinds of tests you've done, acceptance tests have their own uses, I just wouldn't consider it unit testing. 

The general approach More of an issue is the overall approach of using reflection here. Reflection has three major problems: 

So what's happening, causing both these problems, is that you're trying to do something inside the loop which is actually meant to happen when the loop is finished. That should happen outside the loop. Fortunately in this case it's a simple fix- just move your failure exception outside the loop: 

You're right that this is problematic. What it means is that your class can be in a "not fully initialized" state. Like you mentioned, that means you have to remember to initialize it. It also means that if you ever pass it around, you can't rely on your configuration staying the same- some other code might change the without you realizing. There's a pretty common solution to this- just pass it into the constructor. That way a always has one for its entire lifetime, which won't be changed. I'm not immediately sure which IoC container you're using, but any mainstream one will have support for constructors with parameters- you just need to make sure the dependencies are bound too. 

You'd then just need to implement (which you'd want to make lazy, so that you don't calculate primes higher than you need) and 

Sure, your method is better. It's a pretty straightforward example of some fundamental programming and design concepts: 

Add one if the minutes were rounded up from 59 to 00 Subtract 24 if the hours are greater than 23 Decide whether we should display "AM" or "PM" Subtract 12 if the hours are greater than 12 

For more general comments, there isn't much I can find to fault. There's a couple of times you declare a variable, then only use it once in the next line. Not doing that means you can get rid of the cumbersome name . Also, you should probably trim out some unnecessary comments. If you're just learning F#, the idea that the last expression of a function is what gets returned might cause enough cognitive friction for you that you want to leave yourself a comment, but those shouldn't be in part of a finished piece of code. Generally, though, stylistically the code is good, including both naming and organization. 

As a side note, this is a good demonstration of the power of invariants. By carefully protecting state, we've managed to transform into , and into , just by adding a straightforward restriction to each one. 

Generally, your naming is good. I never like as a name, but sometimes, like in this case, it's hard to see anything more descriptive. Perhaps just . is also not a great name, though since this is testing something so specific, there probably aren't many candidates. or similar might be better, cumbersome as it is. 

Usability None of your requirements actually say anything about looping until the user enters some special quit code. Is this really what you want? Have you considered just running through the process once? Or looping forever, forcing the user to quit out by using whatever means the console provides for doing so, rather than providing your own mechanism? This is somewhat a judgement call, but having to enter a specially defined magic number in a particular place isn't a very user-friendly way to quit a program, so either of the above might be a better user experience. They also mean you now have a simpler program- you want to guard against adding extra code or features that don't actually match any of your requirements. Similarly, do you actually need this question/answer style? Would receiving the information from command line arguments be acceptable? If so, you could cut your entire program down to a few lines.