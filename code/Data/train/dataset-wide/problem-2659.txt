dumping the input string to a ; creating a separate of the reversed input string; based on those arrays, for each index strictly between 0 and the string length less one, finding and storing the odd-length palindromic substrings centered at that index (based on the forward and reverse arrays); for each index strictly between 0 and the string length less one, find and store the even-length palindromic substrings centered between that index and the previous (based on the forward and reverse arrays). 

I take you to mean that you want to tokenize a language similar to the one recognized by the standard POSIX shell (since you tagged [posix] and presented an example), or maybe even that exact language. You posited in comments that perhaps you needed a parser generator such as or for this job. Although these tools can indeed do such a job, code for such a subsystem -- a "lexical analyzer" or "scanner" -- is more often generated via a different kind of code generator; and its GNU variant are the canonical tools for this purpose. These two particular tools allow you to describe your tokens (and separators) via regular expressions, and from such descriptions they generate C code for a table-based DFA that processes the language character by character and splits it into tokens. This is certainly one plausible way you could proceed. On the other hand, depending on the language you want to recognize, it's not necessarily unreasonable to write your own lexical analyzer from scratch, or in favorable cases to use an available function such as to do the job. This affords the possibility of a better-tuned implementation than can be produced via a general-purpose tool (or not), it does not incorporate an additional language into the project, and the source might even be smaller. You ask, 

You are not using tail recursion in , so the compiler cannot easily turn it into iteration. It depends on the specific problem; in this case I would probably do it iteratively. Sure, is useful and convenient. 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

This has the added benefit that the return value increases in (i.e., it returns the of your function). Alternatively, you can actually avoid constants: 

it in . Style Avoid in favor of . is better written as . Avoid mixing and : keep conditions in and side-effects (like ) in . Repeated and Each (and et al) allocates a fresh list, so doing a repeated can waste memory (and garbage collection cycles), so either using 

The second (recursive) version can be made tail recursive using an accumulator. This would help some compilers produce better code. 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

Public vs Private First I would like to note the use of a subroutine along with a function. This basically just means that the subroutine is accessible by other routines/the macro's list. On the other hand, the function is only seen by other code in the same module (so we don't risk the wrong code using it, and potentially returning a bad value). This is a little bit more advanced compared to where you are, but it is a good practice to get into early. Variable Declarations I noticed that you were using Hungarian Notation (HN). I would venture to assume we all go through this phase in the SO VBA community, but the sooner you break that habit, the better. It is far better to properly name variables than to use HN to denote the types. For this purpose, the names were easy. For larger projects it can be a bit more complicated. The sooner you avoid the habit though, the better. The Good Stuff Avoiding Errors Before They Happen Error handling in VBA is not very robust. It works, but oftentimes it is misused. I am of the mindset that error handling (in the line label sense) should be avoided at all costs. The best way to accomplish this is to use logic to your advantage, and to wrap repeated operations in a single function. In this case, the appropriate method was easy. The function takes an input cell, and returns a value based on the contents of the cell. While you initially checked for the function checks for since this will catch as well as anything else that isnt a number (since isn't but will throw an error if multiplied by a number). Why Use Functions? I like to think of functions as magical creatures that really are under-appreciated by newer programmers. Maybe I am hyping them up a bit. Maybe not. What I can say for sure is I used to avoid them. Then, someone came along (cough ThunderFrame cough) and lightly-reprimanded my avoidance of using single-functions for repeated steps (I had the same command in numerous places. He reminded me that, should that command ever change, I would then have to find every single place it lived and fix it. Simple advice, simple reminder, but it changed my approach to using Functions. I tend to ramble, so the point here is this: When you have some operation that needs to be done in multiple places (or on multiple conditions) you should strongly consider a function. That way, should the operation change, you can fix it in the function, and not in all of the places that you are calculating the operation manually. Functions also allow you to return different types of values. Declare a as a and you can return a a a . Whatever you want to do. They allow greater control over the flow of your code. Final Tidbits As I do in many of my CR posts, I recommend using RubberDuck, especially when you're starting out. You can find it here: $URL$ It helps for finding those little things you do without knowing it (Implicit reference to and for example) and help you learn better habits. Over time, these small changes in habits can make or break a programmer. Best of luck on this. 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

Stack overflow is tail-recursive, so if you compile it, it should become a simple loop and there should be no stack issues. However, do not rush with it yet. Algorithm Number of iterations Let us use to see the problems: 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly. 

Doc string (no more than one, but it can be multi-line!) usually comes before the declarations. Please see Syntactic Interaction of Documentation Strings and Declarations: will define a function which has no docstring and return , while will declare a function with a docstring, returning . should be . should not be used if you know that the object is a ; use instead. There is no need to bind and in since they are used just once. is, I think, more "idiomatic" than in your case. It is clearer to use in . 

Note that takes so you can write instead of (you also want instead). Furthermore, is quadratic in length of the input string - it can be made linear instead. is a usually used as a prefix for iteration macros. Also, you call in twice; you can use to remove one call. Your line breaks in are very confusing. You can use instead of in because returns a fresh list. Summary I think your code is overkill. 

I've done my best to refactor your code in such a way that you can use it to learn to improve your coding, but also in such a way that it all makes sense. I'll post it and then explain the process and some tips. The Code 

Know I know **exactly* what my code is doing, and I can debug it much faster if something breaks. Indentation This is a pet peeve of mine, and it is a pet peeve of the community as well. Always indent your code (properly) and never post code on SO that is not indented. We will be cursing your name as we indent it ourselves (or, even more frequently, we just refuse to help). A lack of indentation will make bad code even harder to read. Shameless Plug For Rubberduck Mat's Mug and his team have a tool called 'Rubberduck' that goes a long way towards enabling you to fix these problems. Everything from indentation, to variable naming and variable use, even to Function and Subroutine calls. I highly suggest checking it out: $URL$ . In Closing Whatever you do, don't simply copy and paste my code, throw it into your module, and just go on your merry way. I spent time on this to help you learn, and my hope is that six months from now you will be in my shoes. If you do decide to forego the learning opportunity here, you will miss out on all of the things VBA can really offer. Best of luck! 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

Minor Paren placement Hanging parens are an eyesore. Global var Use instead of to create global variables. Sharp-quote for functions You should do instead of . Unnecessary allocation Since your returns a fresh list, you can use instead of . Major Sum Your function is broken - it will not work on long lists, see . Here are better ways to do this: 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

You are doing fine, other than a few simple nitpicks. You are not using (which is a crazy thing to do anyway), please drop it. You should fix your indentation, it would make your code much easier to read. You probably want to divide by , not , in and you probably want to simplify the code there by dividing by instead of multiplying by the reciprocal; also is relatively expensive, so, if you were not i/o bound anyway, you might want to replace it with multiplication. Function should probably return multiple values instead of a . Global variable should be local to . Function should probably be called (it read the whole list). 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

This is easily handled with a simple function that checks for a potential error instead of triggering an error. Code first, and then an explanation: 

The only difference between the two is that the second is at least explicit about wanting a variant. The first is implicit. First bit of advice avoid implicit commands as much as possible. The reason for this is quite simple, there is a tendency to think that the computer is magically doing something it shouldnt be, but really you told it to do exactly what it is doing and as a result, you have a bug that can be nearly invisible. Consider for example : 

I tried adapting you code to use an array for this (someone probably beat me to the punch). I commented old code so you could see the logic of what is happening: 

Neither of these changes will change the performance of your code, but it will make your code easier to read and understand, and it will start teaching you some coding habits that will be important later. Now, let's tackle that pesky . I must say, there is no habit that must be broken sooner than , , , , and . There's good reason why this is a bad habit. First, it makes your code unreliable. While the ActiveSheet could be the correct sheet, we have no way of absolutely guaranteeing. For example: 

If I interpret this bit correctly, you're just testing whether there is a second dimension within the array, and if there is, you're looping through the array as a 2d array. Otherwise, you're looping through as a one-dimensional array. Wouldnt it be nice if we could explicitly say that in VBA? 

The beauty here is that not only will our code raise an error explicitly related to the source of the problem, but we also have a very modular way of adding additional support. For example, if we wanted to support a worksheet (for whatever reason) we would want to update the error message, and add just a bit of additional code: