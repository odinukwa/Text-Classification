I may be missing something, but how is this different from ? And why would you want to pay your worker to sleep? Looks extremely inefficient in most cases. And surely there are other names you can use apart from ? So you can both avoid using and give a variable a much more meaningful name. "Event" does not tell much. 

P.S. This: smells. I have no idea what this is supposed to mean, but i can guarantee you that you can come up with better property name, than (which should be btw), and with better property type, than . 

Just wanted to mention, that you can do it with LINQ only (without creating additional collections): 

Do not hard-code settings. Store IP, port, buffer size, etc. in configuration file and load those settings from it. (Not that important for sandbox projects) You should not reopen every time you send a message. Instead your class should open stream once and only close it when the client is closed/disposed. should re-use existing connection. Always sending bytes is clearly not the best approach. It bloats the traffic if message is smaller and cuts the message if it is larger. A simple solution is to prepend size to the messages you send. Use when variable type is obvious. Consider using methods (e.g. instead of ) to improve responsiveness of your apps. 

I'll review this in two steps: first the body of and then the higher level structure/architecture. The selection sort implementation Swapping elements First of all, there is a bug (the only one I could find) in the code that swaps two elements that sometimes loses elements while swapping them. The smallest example where I can reproduce this is by sorting which results in , losing the . Looking at this code: 

If you're following along step-by-step you'll notice that the of the enumerated array is now unused, so you can change it to only loop over the : 

This alternative works, if it's a style that you prefer. However, it's iterating the slice twice; once to find the element and once to find the index. To address that I'll use a to iterate over both the elements and the indices at the same time and find the minimum element-index-pair by comparing the elements. Since only the minimum index is needed to swap the elements I'll use tuple destructuring to only reference the once it's found. 

You could consider creating a class that holds the indices for a larger amount of text (for example a paragraph or a section or a subsection in the text). That class would have the absolute index for where in the file it begins and relative indices within the paragraph/section each line begins. Whenever a new line is added or removed only the lines within that paragraph/section would have to be updated and the absolute start index of all the following sections as well. (I don't know what text you write or what you use the line starts for). You could still find a specific line very easily (and probably very fast) by enumerating the absolute indices of the paragraphs/sections and when you find the right section enumerate it's lines. 

I don't think you are going to need a special for any of those options, simple (or any other panel), should work just fine. But it is hard to tell for sure since your code is rather hypothetical-ish. I do not know the actual use case or an actual problem you are trying to solve (if any). 

is not thread-safe and write operation always happen on new thread with zero synchronization. Looks like a recipe for run-time crashes to me. 

P.S. There is also quite a lot of s in your code. Selector is a string, attribute is a string, style is a string, etc. Indeed all of them are technically strings but they all have different domain meaning. Maybe you should consider adding more classes to your domain model to represent those entities. You will gain the safety of strong types, but you will have to write more boilerplate code. So there is a trade off. 

is more than enough. Use actual implementation in your software, mock it in your tests. Done. Introducing another internal abstraction leads to creating even more abstractions (see t3chb0t's point about ) and writing even more pointless tests (if you are obsessive about test coverage). I wouldn't recommend going down that road. 

I am not sure where your input/output classes are coming from, but they feel really outdated. This is definetely NOT how you want to design a C# application. If you absolutely must return a state of operation - use method return value for that. And use or enums for that, not strings. But it is not something to build your application around when you are using an OOP language. 

I see that you're reading the from the array as you're enumerating it and writing that at the , presumably to avoid having to get a to swap the two elements: 

Finding the index of the smallest element I'll make two small syntactical changes to the code that finds the , partly to leverage Swift features but also to prepare the code to be generic (which I'll discuss later). First, I'd like to describe what this loop is doing as "iterating through the indices of the slice of elements starting from the current index". In code I'd translate that into: 

However, with this change the selection sort algorithm can no longer be used because is a method of rather than . It's possible to constrain the to be a mutable collection, but what if another algorithm has another requirement? With this strategy we would end up constraining more and more to the sum of all the different algorithms requirements. A better alternative is to keep as broad as possible, but to supply no sorting algorithms by default. Instead each sorting algorithm would be added as an extension only where the generic placeholder types satisfy those requirements: 

It's flexible in that it works with any mutable collection of any comparable element type. It's convenient in that it will show up immediately on the collection types where it's supported. I also feel that it's "swifty" in its style and conventions – both in its implementation and at its call site. 

This way you do not create any unnecessary collections. It forces you to use though, but in my opinion it is a good thing. 

10) Maybe this is intentional (I have not been following your previous questions), but this does not look very safe: 

You should replace two methods with one. Your first method is a special case of your second method, so one way to remove code duplication is to call: 

P.S. You might want to check out Microsoft's TPL.Dataflow library. It does what your does, but probably better. 

Given that the logic is exactly the same (i did not do a line by line comparision), one of the possible solutions whould be: 

So, basically the problem is that you are most likely lack both knowledge and experience needed to implement logging in a way, which would work correctly in every possible scenario. Same goes for me, for example. That is why I use logging frameworks, which were written by experts and were tested by other developers. You certainly can implement your own logging if you wish to do so. The only thing I can guarantee though, is that you will fail multiple times, before you will get it right. It will be good learning experience, but it will also take time, which you might not have. 

I think its better to use . This way your thread will wake up on cancellation instead of sleeping for 10 ms. 

Consider using more of what Core Graphics gives you. There are methods along the lines of , and that does that kind of basic math for you. It reads cleaner and other coders who are used to Objective-C will immediately recognize them and understand the code. Also, there is some code duplication where you calculate the center x twice and the center y twice. You can introduce two private methods to get rid of that duplication (I've also removed the "get" prefix as it is not commonly used in Objective-C and switched to instead of ). (If you really want to get rid of code duplication then you can create a method to get the bounds of the main screen. I did so in the code below) 

This change is only syntactical. Going even further Realistically I would probably stop here, but I'm going to continue to show more of this process and other implementations. Considering the goal of that loop, what it's really doing it "finding the index of the minimum element in the rest of the elements". There is two ways we can approach this goal. The first approach is by first finding the minimum element, and then finding the index of that element: 

The first is pretty straightforward to address, by making the struct generic over an type that is constrained to be and by using arrays of that type: 

1) You should use instead of . is easier to read than . 2) You might want to remove constraint and create two constructors: one that takes and another that uses . That would be in line with other similar .Net collections. 3) and are poor names for generic parameters. and are better. 4) Your collection claims to be sorted. Yet it isn't until it reaches the limit. This is a pretty big surprise factor. 5) You extend , that has a pretty extensive api. Yet you only override method. And if you call other public methods it will likely break your collection. I suggest you use aggregation instead of inheritance an expose single method, to be safe. 6) Instead of sorting on every "add" operation you might want to do a linear or binary search (hard to tell which is better, it depends), and insert new item in its place straight away. 

Also, what instantly raises red flags is the sheer amount of various tions, tions of tions, dictionaries of tions, etc. gathered in one place. I mean come on 

When implementing equality methods and operators, you should always try to reuse your implementation as much as possible. is the same as , is the same as , etc. For eaxmple, you can implement equality as: 

I don't see the benefits of having both static and non-static API: and . It does not bring any new possibilities, but it does cause inconsistencies in usage (personally I hate it when there are multiple ways of doing exactly the same thing) and additional unit testing. I would remove static version completely and keep only non-static one. However I think that creating an external static class, similar to , and moving any complex math there from class - is a good strategy too. 

The second one is a bit trickier and highlights some constraints in how can be extended to support other sorting algorithms. To make support any kind of collection, it would be natural to also make it generic over a type that is a Swift collection: 

This change was greatly simplified because I had already moved away from the assumption of indices and instead got the index type from the collections associated type (implicitly). In other words, here is of the type rather than . With this strategy each sorting algorithm can be added separately with the type constraints it needs, and a user of this API would have access to only the sorting algorithms that are available for the type of collection they are using. At this point I don't see any value in the wrapping struct, since these algorithm could be added as extensions to the collection itself in the same way. This solutions also has a more convenient and more "swifty" call site syntax 

Don't worry about the temporary variable. The compiler is going to remove that and it helps with readability. If your delete operation is safe to run concurrently on many objects then it may be slightly faster to run it like this: 

The problem is that — because of array's value semantics — this doesn't account for changes that happen to the array since you started enumerating it. In short, you're swapping in a stale value from before you started sorting the array. Now, what you're really doing here is swapping the elements at two indices, and that is best done with . It's also documented to have no effect if the two indices are the same, so you can get rid of the surrounding if-statment: