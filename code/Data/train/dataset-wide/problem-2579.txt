I need to concatenate 3 input fields into a string which is formatted as a date , using or will not work in my scenario because Firebase doesn't allow it for some reason. I came up with a rather ugly solution, but I'm not quite sure how to improve it. is bad for performance, but I think that it is needed because I need to completely remove the properties from the object once they've been used. 

So, I'd suggest it'd end up looking something like (it's been awhile since I've written straight ADO.NET, so there may be some minor issues here): 

From there, any further optimizations would be heavily dependent on your data and would need some example data of the correct relative sizes to profile and test. 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

I'm trying to grasp this whole MVC design pattern idea but I'm in the dark if I'm doing it correct. This is where I need some feedback on what I've done so far. Here's what I'm wondering: 

Is this a property in an object? If so why have you named it ? Give it a proper name such as or something along those lines to make it more obvious what it does. Now it's just confusing. And for the other function you could name it . If you included some additional markup it would help your question a bit. 

Ok, now we have enough to get to refactoring the class. Currently, your class has too many responsibilities - it's showing the menu, tracking the current state, and adding/removing products. We're going to trim that down to just showing the menu and tracking the current state: 

will exit at any key; you want to change your message or change that to to require an . AppCoordinator Your class is a major code smell; it's a (no offense) terrible name that really doesn't describe what it's doing, and is likely to become a "god object". I would rename that to or or something. Since this is your largest class, the meat of my comments are here: 

This might need a bit of editing but you get the idea. However I'm not sure if any of these are actually better ways of doing what you want, but it's other ways of doing it. It might make everything more manageable if the code gets even bigger. Hope this helped. 

To start off, I can't see a single semicolon being used here. You should always close your statements with a semicolon. Also I can't quite understand what you've done here: 

Well, you can certainly make it easier to read by cleaning it up a little bit and getting rid of the extra () loop, and substituting a and for the inner () loop's concatenation: 

I think a plugin architecture would be a little overkill unless you're interested in versioning or deploying the sub-modules separately. You haven't shown the sub-modules (the actual solvers) but I'd probably define an interface for them and then use a instead of the statement. Really, it's pretty minor, but I see a couple of advantages of the : 

Personally I would create loops for this, it's very unreadable at the moment and you are repeating yourself a lot. Remember the DRY rule (don't repeat yourself). Also if you do it via loops it's easier to maintain and change in the future. 

I've written 3 factories as a part of a sign up process in AngularJS and Firebase. After completing them, I thought to myself, would any of these fit better as a service instead of a factory? From my research it's a bit fuzzy when it comes to choosing whether to create a service or a factory. If so, why would they fit better as a service? How can I tell when to create a service and when to create a factory? I've documented the to explain what they do, and the ones that lack a documentation explains themselves in the name. 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

That should clean up the code some. As I started typing that, I figured I'd check for edge cases too - since is filled with them (eg., it includes the negative sign in the length, returns if it overflows, etc.). You're handling the case, but a couple of edge-case values fail: 

That's not going to do a whole lot for performance (basically get rid of a rows iteration), but everything else I see is really context specific that may end up with worse performance assuming your data looks like I expect it does (< 10 , < 50 and thousands of rows). A couple of additional thoughts you can try, though, depending on your data: 

In a bigger project of mine I'm using angular to create a dropdown menu dynamically and then toggling a dropdown menu for some of the menu items. This is why I got a function that toggles the dropdown menus for only the items that should actually have one. However, I feel like I should try to DRY this out a bit since I'll be repeating the same function even more than what I've done so far. How can I improve this code? Should I create a self invoking function or something similar? Here's the functions (they're part of a controller object that I left out): 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload.