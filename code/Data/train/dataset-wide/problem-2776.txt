In a quick test this method was about 3 times slower than shuffling in-place using random element swapping (@Abbas solution). Note that strictly speaking it is not equivalent to other solutions since it creates a new enumerable rather than shuffling elements within existing list. 

Replace / with Entity Framework - that's the biggest change since it will remove all the manual //// processing in favor of typed data objects. Read more on Entity Framework Replace your custom logging class with logging framework (log4net, NLog). 

About method - if this a method is in Controller class, and taking previous bullets into consideration, the code would look like that: 

There is no need to create a copy of dictionary before calling in , and you can use as a parameter type. Also you can optimize the performance of the by adding another constructor which accepts (optimizations shown below). 

it looks like you're trying to separate DI and IoC principles. In fact they are just different points of view on a same thing, because Dependency Injection is the software pattern usually used to implement Inversion of Control. So there is no need to make difference between them, quite often these terms are treated as synonyms, and most IoC containers do dependency injection as a part of their function. knows too much about , as it tries to initialize it with . This task should be delegated to IoC container (or the code that registers objects in container), and should only use the pre-configured instance. Also, either should expose the method that predicts the future and outputs it to writer (so that just calls this method) or should be declared on class (preferably), and then this class acts as a mediator that gets prediction and outputs it to the writer. The line highlights this problem 

Can I try to convince you that you don't actually need such a class at first place? How do you actually use the string value of this class? Do you show it to user? If yes, then what would you do when you need to make it multilingual? What I'm trying to say is that verbal interpretation of "success" or "failure" should actually be done on UI level, and class is not a UI. Also there is usually a single "success" case. You may say that you might want to differentiate several failure cases, but those are best described by a nice technology called exceptions. So, what do we have beside ? A boolean flag. That's what we probably want to return in case if we're interested whether something was successful or not... but wait. What usually happens when something goes wrong? Exception. And it would probably be more useful to let the business code process this exception, as the same exception may be treated differently in different situations. Now let's go back to your code. You class doesn't have a state, so let's make it static: 

Other than that I don't see memory leak from the graphs you provided. Threads may still be alive in a thread pool, and memory may not be collected by GC yet. Here is what I've got as a result (note that it may consume more memory as you need to store all the chunks that are currently being sent in memory): 

It's better to use new asynchronous API since it provides more features for combining asynchronous tasks. Ideally , and should expose asynchronous API if a certain operation is not trivial, so (as you mentioned in comments you wrote them) I would implement asynchronous API for them first, e.g.: 

Note that in this case you would need to spin up a new per request (which I expressed as a repository factory). And finally, assuming that this is a critical path in your application, the best way to optimize the code you're running is to reduce the number of round trips to database server, instead of trying to squeeze microseconds on a .NET layer. For example, if your underlying DB engine is SQL Server, you can leverage the recursive CTE to load full folder hierarchy in one go. It can be optimized even further if CTE returns the depth level for folders, but I'll leave it for you as an exercise: 

Update In comments it was asked if you can extract interface for ColumnDataBuilder. Of course you can :), and the easiest way would be to use "Extract interface" refactoring from ReSharper :). If you still don't use it you'll have to do that manually (move the and declarations out of first): 

It is safe, but can be refactored using .NET built-in class. There can be several solutions depending on whether results of the execution can be cached. Simplest solution is when you can cache the results of the execution for the lifetime of your parent object. In this case the code can be as simple as (move initialization to constructor if is not static): 

This code is simple because it doesn't shut down the worker thread in case when there are no tasks. If you do need this functionality you'll need to add some more thread management code: 

It seems that you are looking for object-relational mapping (ORM) framework. ORM framework is a recommended way to talk to the database. There are several frameworks out there including most known Entity Framework and NHibernate. It will require a bit of learning after direct //, but that would allow you to get rid of manual SQL string manipulations and concentrate on main business logic. 

UPDATE (based on updated question): Your solution doesn't have proper separation of concerns. The class containing method () knows about UI as it handles strings shown on UI (e.g. property), events (even though they are named as a business flow events) are designed specifically for UI interaction. In order to properly separate concerns you should move all the logic related to UI to your user control, and leave only business logic in the . In order to do that you need to decide what is the actual trigger for showing a loading box. I'll stick to assumption that the actual reason to show a loading box is not a "programming" stage, but a long-running process, i.e. if you would add a new stage that may also take a long time to complete you may also want to show the loading box there. The next question to answer is how do you want to detect a long-running stage? I can suggest 2 options: 

Defining the shape drawn is a pretty simple trigonometric exercise: you have coordinates of your starting and ending circles (x1,y1 and x2,y2), and a bunch of similar right triangles. Here is the calculation of your points: 

You're definitely going in a wrong direction. Instead of trying to synthesize some weird generic classes in attempt to find a common general pattern in "I send request and receive a reply, in each case requests and replies are different classes", you should start from designing the interface of your communication, so that other layers of your system are abstracted from technical implementation of COM/Web service/whatever protocol you have to deal with. Based on your comment: 

But the question is still why would you need a string representation of last 3 years, comma-separated. I would consider having a method that will return enumerable of last N years instead... 

will enumerate the enum every time you start iterating on, it, so it is better to capture the result in array. 

You should never generate dynamic SQL by concatenating incoming values into an SQL string that is executed later. This type of code leads to SQL injection vulnerability, and by using your service as it is now it's very easy to get access to any user account without knowing its password. If you plan to develop your service further take your time to learn one of the ORM frameworks (Entity Framework, NHibernate, or maybe one of the NoSQLs like MongoDB or RavenDB) and get rid of low-level DB management code from your service. Alternatively (if you prefer inventing a wheel :)) move DB-related code to separated class and name it "DB repository" so that your service doesn't have too many responsibilities (currently it has business logic responsibilities combined with DB access management). About exception handling - here is a good article that describes what you should and should not do. Basically you should only catch specific exceptions, and only if you know how to recover from that exception in a meaningful way, that doesn't leave your application in an inconsistent state. In case when WCF service has no way to return a meaningful response (e.g. when response is based on DB data and database is not available) you should pass exception to the client. And finally, store your connection strings in the configuration files rather than hardcoded. 

I'll show you how to simplify the code based on DoUpdate method, it includes most of the tasks done in other methods. No DataAccess class usage, cleaner code, better exception management. 

I don't think you need class there, I would replace it with interface and move the implementation to . And you don't need here, just use instead (yes, it will use boxing for most cases except strings, but it's more efficient than dynamics). 

If performance is not really critical I would probably prefer the following solution to randomize elements in any enumerable: