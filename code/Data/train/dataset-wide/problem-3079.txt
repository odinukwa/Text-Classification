How many votes has the post had in the last day? What is the split of up and down votes? Am I allowed to change my vote now? Have I already voted? 

I think it's up to you which one you prefer. I like to think about getting the value first and then rounding it. There is a similar thing here: 

I've noticed that you seem to prefer to use rather than stepping through with a debugger. I'm interested to know why you do that, it certainly takes more time to write the code that way. 

But effectively you are passing the object into a function aliased as a. Then you are not using but the object anyway - a bit pointless. Edit: Regarding the deferred object question: 

You resize the array on every . That's O(n) and unnecessary. You should be creating an array larger than your current limit and then making it bigger (by some factor) when you reach the limit. Also, under the covers, an simply creates a new array and copies everything over. 

If you just used the first, consider what would happen around any Daylight Saving Time transitions. When the clock goes back there is an entire hour of repeated local times. You won't be able to say which instant in UTC that the time corresponded to. Edit The minimal change I'd make to your code is: 

You don't need to call on the in fact, doing so isn't great at all... As far as I am aware, this will make your clause execute in C# rather than being translated to SQL meaning a massive perf hit (I would be happy to be corrected here). You should return directly: 

Little Santi's answer has a bug because it is closing over the i variable in that asynchronous call in the for loop. Here's a simplified version of that code running in Chrome's console: 

Following on from my previous question, I finally got round to actually doing the A* search for the . The changes to the code from the previous question were pretty minor (and no API change) so I won't include the code again. First, I defined an interface for a hueristic. 

Note the use of with . See Stephen Cleary's blog to learn more about why blocking on async code is such a bad idea. 

That's a lot less typing and a bit easier to scan IMO. We also now have string interpolation (this one is much newer): 

The problem is that Entity Framework's is really a unit of work. By newing them up inside each method you lose the ability to do several interesting things in the same transaction/unit of work in an easy way. You should be able to have multiple repositories (Dao in your parlance) using the same context/unit of work. Your code is also incredibly coupled to EF and you're violating the dependency inversion principle. This is the best write up of DbContext lifetime that I've ever read: Managing DbContext the right way with Entity Framework 6: an in-depth guide. Although you're not actually using any of the 3 main patterns discussed. If that is Automapper, that's also the wrong place to be configuring it and is a conflation of concerns. 

Although, I think it might be better to throw if is - that seems like it would be a programming error. Adding doc comments is great but you could add a bit more detail. For example: 

Nitpick - is a ternary operator (also called conditional operator or inline if) not the teritary operator. edit: I am assuming that both and are rather than . As Mug has commented, there's not enough context to go too deep here but let's look at one line: 

Now you have a type that is safe for use with ! AddRange As far as I know, only throws when the collection is null. You don't need to check for items before you call it. That elminates a whole heap of code: 

Let's apply some of these on the change handler to store the focus field. Here's what we're starting with: 

Isn't that better? They type system is helping you and you won't get confused about whether that int is seconds, minutes, days, milliseconds or number of red socks in your drawer. Your code is cut short so it's hard to know what else you're doing. Try to concentrate on making your code easy to read. Once you do that, you'll find it's easier to change. Once it's easy to change, you'll find implementing features easier. 

Update: On reflection, the base case can simply be an empty array. We don't need to worry about the length = 1 case because it would have been counted in the for loop anyway. That means the code can be simplified to: 

Requires it in addition to what? There's also a tag that will generate a link to the given type/member's documentation (in the right tools, e.g. sandcastle). 

An example of actually creating a map is (I only wrote this for CR so not really wanting it to be reviewed): 

You should add documentation comments rather than simple comments to explain what a method does. e.g. 

As Heslsacher says, you could further improve by using named constants for the indexes. I did write some additional stuff about using a method to get a Func but then I realised that is a long so it all went out the window. Edit For posterity, I'll add in what I had written: 

It actually gets or sets a value... There's also the tag that you should add. I use the GhostDoc extension to help generate code documentation - that might help you out too. 

I don't think it makes sense for this to be an event. What you want to be able to do is pass in an additional processing step. An event is something that may happen in the future for you to react to. General code notes: Use of If the right hand side of an assignment makes the type obvious, use to declare the variable. 

Either always put on a new line (preferred) or don't. Mixing and matching is upsetting :( In general, I find your strategy a bit odd. As I said before, if contains your id, it's already been created once so you don't need to track creation separately. 

Note that I've removed the uneccessary check for on the object. Your naming could do with a bit of work doesn't really mean anything. You could also store the Regex as a field on the class to declutter this method. You can leverage a in your method too: 

You certainly can! You're currently coding using the "arrow pattern" it's often nicer to return early rather than keep indenting further and further as you nest conditionals. 

Try to avoid and prefer . The former is local time which can jump around when there are things like Daylight Savings Transitions or even this sort of thing: Samoa and Tokelau skip a day for dateline change. 

As far as the actual code goes, the implementation is clean and I don't really have any comments :) As for the idea, I don't think it's quite right. Settings should be that - just settings. As soon as you start adding behaviour to them, they're not settings any more and you should look at what you're missing. Taking your example: 

Note that I've pretended that you have a class called with a property/field containing the text to prompt to a user. I've also assumed that you have created well named constants for the min/max number of test cases. Linq You should defintely learn some LINQ (Language integrated query). For example, your becomes redundant. I didn't mention it earlier but that's also a poorly named function. It converts the items of a string array to ints - that isn't clear from the name. Anyway, with LINQ: 

You are mostly right. This is a very common pattern but your naming is a little bit different to standard implementations. I should note that in this particular case, this is completely overkill but I'm assuming that this is a learning exercise for you and not something you are planning on using. 

I don't have time for a full review at the moment but something filled me with rage jumped out at me... Naming The code should be readable - you have 2 ways of making that the case, one is by naming things correctly (the second is formatting). So when I see things like this: 

I think that Heslacher is right and you don't strictly need this class, but as you've written it I'd like to point out a couple of things: