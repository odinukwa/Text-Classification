Straightforward, though a bit repetitive. From a UI point it might be useful to just show all (both) conversion results for the given input value, so the user. i.e. if the user gives Celsius, give them both Fahrenheit and Kelvin. 

For a simple routine like this, you could save almost half the source code lines with no lack of readability (but leaving more of the code visible at one time): 

Again, add one, subtract two? Wouldn't it be simpler to just subtract one? But if this subtraction runs on Sunday, you'd end up on a Saturday, right? Should you something after the final ? Now it only returns anything if the test for 1 or 7 matches. algorithm Actually, I can't understand your algorithm from this code, so I can't say if it's correct. Mostly because of the confusing conditionals. I would approach something like this by writing the logic down, in some human language if necessary, and then implement that. (Actually, skipping a fixed number of days is almost painfully simple, since it'll always go from a known weekday to another known weekday. Mon->Tue, Tue->Wed, Wed->Thu, Thu->Fri, Fri,Sat or Sun->Mon, so 8,8,8,8,10,9 or 8 days ahead, depending on the starting weekday.) structure I think this could be condensed to a single function. Preferably one that would take the starting date and number of days to skip. Even if you need a larger class around it, it would be easy to just drop the function in as a utility. 

From a memory management point of view, your implementation is a linked list, that is, all items are allocated separately, and the next item is found by following a pointer. As the theoretical advantages of linked lists lie in insertions and deletions from the middle, they don't make for a very good implementation of a stack, where you only really care about adding and removing from one end. Especially here, when you're only storing a single number, the pointer to the next item is likely to be at least as large as the data stored, and that's not counting the space overhead of malloc. (Let alone the time spent on updating malloc's internal bookkeeping.) I would suggest storing the values in a single array, and resizing it with as necessary. Something to the direction of this quick mock-up: 

Unsupported operations should throw . Catch rather than . Implementations can throw exceptions for reasons that may be out of your hands (like concurrent modification). Idempotent operations may not throw. Implementations may choose not to throw UnsupportedOperationException if they can determine that the invocation is a no-op, such as with , or on an empty list. 

I'm not sure how strict the requirements are. Right now, your code gets two words on two different lines, while the example gets two words from the same line. I've used in the suggestion below, but will work as well. Some comments will help with eyeball scanning. ;-) 

This is good code, because it does what it says on the tin. I do have two remarks: The in isn't necessary. Some people swear by adding it anyway, so it's a matter of style. The other remark is that you loop over twice as many elements as needed because you set to before looping. You can hold off until after: 

I do have two recommendations for your code. When searching for an element in the queue, you can abort once it's found. On average, this will halve your time spent searching: 

Using BigDecimal essentially guarantees we'll follow the specs laid out here. That makes the code a lot easier on us (stripped the comments for brevity): 

...you have no guarantee that those two variables were drawn from the same set of mappings. Another thread may have switched mappings in between. What you do to fix this, is fetch and store the array locally for as long as you can both: (1) not tolerate interference, and (2) can tolerate stale data. 

No. A singleton is never really necessary anywhere(1) and it's usually a convenience hack to prevent having to pass a reference into a method or store it in context; a bypass of sorts. That's not to say that singletons serve no useful purpose, but that the decision to use a singleton should be an implementation choice, and never a design choice. (1) It can even be downright hazardous in server environments with managed containers. 

As for the code itself, I won't repeat what @Loki stated. But, you're not handling errors fully, a memory allocation error will leave the file opened: 

Like @Caridorc wrote in their answer, this is always true. But even you meant , why are Monday and Sunday special cases here? 

That's not bad. I like that the input functions actually check the entered input matches the wanted type. Though in some cases a user might like to be able to abort some action at the prompt, so returning or some default value for an empty input might be one choice. The one thing where I succeeded in breaking it was by entering a divisor of zero. 

I might rename this variable. The code just skipped eight days, it might end up on an , or something like that? (Might want to comment that its eight because there must be a weekend within those six days. This is still pretty clear, but it will get less straightforward if you ever allow for variable skips.) 

Make a function to initialize the struct, esp. as you have fields that are initialized to as uninteresting a value as zero. 

Put the circle drawing in a function, and make , etc. locals to it. As for , you might want to scale it based on the circle's radius. Or make it a parameter to the function. I think you have a sort of an off-by-one error here, as (1) on the first iteration of the loop, you draw starting from (old_x, old_y), but and aren't set yet. And (2) when the loop ends, you probably want to draw a line from the last point (at angle 49/50*2*pi) to the very first point (at angle 0) to complete the circle. Also, decide if you're writing C or C++. You can't define a as just in C, and in C++, you should make the class have a proper constructor. 

No fuss about encodings, file paths, IOExceptions, invalid patterns... Just the bare needs to function. Any other constructors or static factory methods you desire are then for convenience, and should delegate to this one. Specifics breaks with the other methods in that it tries to fix an erroneous input parameter. This leads to the oddness of succeeding but failing. Consistency is king in library usage: should fail, or should succeed.[3] [!] changes the contents of the incoming array. You don't really need to sort this array, anyway: I'd consider it a feature if the columns returned are in the same order that I requested them. is not a very descriptive name. ;-) Consider names such as or . 

Still, you are sorting/comparing strings each time you want to update your map. You could split into two parts: one part that checks whether you have already seen the input before (doesn't need to be sorted), and another that keeps track of your actual duplicates: 

(I think this should also work for IPv6.) Other remarks Consider using try-with-resources (see example above) for your database connections and file streams; it really cleans up I/O code. You don't seem to specify the character encodings of your input and output. Considering the domain, I doubt you'll run into serious trouble, but it may be useful to decide on an encoding like, say, UTF-8. I doubt String.intern() will help you much. Interning helps to reduce the number of copies in memory, true, but since you use them as hash keys, you'll discard duplicates anyway. 

The exclamation mark at is because, while provides access in asymptotically constant time, the actual constant time may be significant, and it depends on practical factors like load factor, bucket sizes, and hash spread. 

flips the bits on as it increments digits. It looks at the difference of prime factors between the digit it comes from, and the digit it is setting (always one higher, except with nine), and flips the relevant bits if their difference is odd. For instance, going from 2 to 3 means flipping 2 and flipping 3. Going from 4 to 5 means just flipping 5, because 4 = 2Â² , an even power. Here's an example implementation: 

This is a bit confusing, since you're testing the date 8 days from now, but printing what the current day is. Why not just test if the starting day is from Monday to Friday, if that's what you mean: . Also, is True for values 2,3,4 and 5, but not for 6, which is probably not what you want. 

I have nothing on the scripting as such, it looks good to me. But given the subject matter, there's one big point, and two small ones: 

Calculate the rate the grains are eaten and just divide to get the result? If a pigeon eats 1 grain in t seconds, then it eats 1/t grains per second, and the rates sum. Though this will result in a rounding error at the end, after there are less grains than the number of pigeons (since they don't actually consume partial grains), so you'll have to fix that if you care about the exact result. Another way would be to find the least common multiple of the time intervals, and iterate over time slots of that length (you know they'll eat a whole number of grains in that time). Though with a large number of pigeons or large intervals that will be unwieldy. Just so there's at least something about code review here, I'll just note that technically your code lets the number of grains get smaller than zero, if multiple pigeon try to eat the last grain. Doesn't matter though, since it happens on a single second, but some of the pigeons could mind. Often intervals are also counted downward, it saves one subtraction on every iteration. 

Do not put functions in header files. Headers are the public interface to your module, so they should contain the declarations of the public functions and (possible) variables. The C source file is the private part of the module that actually contains the implementation. So, 

Yes, if only because you're working with Strings/objects where you don't really need to. But it depends on how far you want to take it. On the surface, there are a number of inefficiencies that you can eliminate: 

Here there be nitpicking! Your error handling is very coarse: does away with stack traces and exception types, both very useful for debugging. Either bubble up the exception, or log the full stack. and have a similar purpose but a different method signature. can leave the balance negative. Consider expanding your query to: 

TreatmentAspirin "If the treatments include aspirin and paracetol, then insuline was injected, because they are dead." I feel like I'm missing something crucial to understand this. 

is usually a red flag in code, especially when used to emulate a blocking call. If you choose a different approach, such as using CompletionService, you can use to wait for an answer. Seeing as a return type in a multi-threaded context also worries me. Who closes the that generated it? Consider offering a callback mechanism that can operate on the result instead: 

try-with-resources guarantees that the local variables are available and defined over the scope of the try block, and that they are closed before leaving the try block. In the uncommon case that acquirable resources do not implement , you can fall back on try-finally, available since the old days of yore: 

In case of many, many catch clauses, consider using on a successful run, and in all other cases (though this is not a common code construct and merits a comment for future readers): 

If an exception occurs after , execution will not reach , but will instead exit the function, potentially leaving the socket in a state where it is no longer reachable but very much still alive and hogging resources (file descriptors, I/O buffers). There are two ways around this. The preferred way since Java 7 has been to use the try-with-resources construct: