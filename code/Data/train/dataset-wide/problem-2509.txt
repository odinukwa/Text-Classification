is a very slow method for doing what you need. You will achieve much greater performance, and avoid the need for complex error handling, by reading the search range into an array, and looping over the first dimension to find the row, then looping over the second to find the column. Edit: Depending upon the number of rows and columns that you expect, or perhaps even after inspecting the size of the search array, you could squeeze out some extra performance by checking to see if there are fewer columns than rows and then check if the column exists, before checking if the row exists. And if there are fewer rows than columns, then check to see if the row exists before checking if the column exists. Edit2: if you'll be calling this function multiple times, with similar sheet names, row values or column values, you could optimize further by keeping s of column names and indexes, and row names and indexes. That would be the fastest approach. 

Refactoring When you see yourself doing the same thing many times, it is time to think again and try to refactor that part because there certainly is a better way. You have very few code that represents repeated logic, but lets take a look at the function: 

The function actually parses the coeficients for each degree term. I won't dive too deep in to this one, but i'll start saying that you do a lot of . And many of them are almost identical, being not only inefficient as well as confusing. Consider this one for example: 

Note how you are constructing the same selector 3 times with the . So this not only repeats the selector construction as it also fetches the element from the DOM multiple times. Save the fetched element in a variable and then use it: 

I assume you're working with a 40MB file instead of a 40GB file. The performance will vary greatly depending upon: 

If you absolutely need to use your Find approach, or if you'd just like to see a centralized error handler, as per you question, then you can use a variable to store the custom error message, and then refer to that variable from the error handler: Also, in you On Error statement, you don't need the trailing ":" as that indicates that the line will have another statement following the ":" 

I don't think you need to activate the cell, or use the selection, just inspect the range directly. I've also made the function volatile so it will update when you calculate. But, for Code Review purposes, you're only getting the interior color, but the cell might not actually appear in that color, for example: 

Don't need to be separated in such a simple statement, regardless whether you use destructuring or not. You can directly do: 

Both first blocks have the exact value you are looking for and will always be an empty because there is nothing to the left. Thus it won't affect the result at all. So you can drop the altogether, and adjust the appropriately. Personally i feel you must rethink your logic a bit on this one. Restating @Blindman67, you should take spaces into consideration to make the structure less rigid. On a simpler level you can strip down the spaces before parsing: 

But do you really want a Dictionary? Using the existing and optimized approach, you'll end up with a dictionary that is keyed by what seems to be an arbitrary index. You may have your reasons, but if you're not going to use the features of a dictionary, you might be better off with an array: This code runs in just 1.56s. 

Have you considered using Conditional Formats as your rendering cathode ray? I've just thrown this together, so it's by no means complete or optimized, but by assigning sprite arrays of values to specific ranges, I avoid the need for any calls to the of a Range. This approach might also solve your dilemma, as you can just write over the top, or you could even to blends! It's fast. So fast I can't tell if it's even rendering on every frame, but I do see lots of movement. It runs about twice as fast if I omit the removal of the prior sprite location. Theoretically, it's 1500 frames/sec with sprite erase on each frame, or 4000 frames/sec if I omit the sprite erase on each frame. Set up the screen Apply 3 different conditional formats for values 1, 2 and 3 

Note how i used instead of . With ES6 you now have both and as other ways of declaring variables. In this case i know i don't want to change or , and with it will give me an error if i accidentally change them. This builds on writing defensive code that gives you errors sooner rather than later. The itself can also be shortened with an Arrow Function: 

Just adding a couple of things to what @Blindman67 already said, and focusing a bit on the code itself. 

Which given what it does, a better name would be . Given that all it does is sort the roots, its even questionable if it should exist, and probably better would be to do the sorting directly in . Considering we are talking about two values, you could easily get away with: 

Clarifying the Form type Access has built-in objects, but also allows the use of VBA . It might be helpful to qualify the type as : 

Also, you're using some nice concise bit-shifting, and you'll have noticed that VBA doesn't have any shifting operators, but you might consider using some bit-shifting functions to make the code slightly clearer (and you can re-use them everywhere else that you need to shift bits. And finally, unless you're certain that will always be a single celled reference, the color will default to if there are more than 2 cells in the range and they have different colors. 

When we look closely to we can see that the code is barely the same, except for the very final returned root. So this leans towards repeated logic and creates all sort of problems. In this case it also makes your code less efficient because you repeat some part of calculations. Better would be to restructure your to return an array with both roots. 

As pointed out by @Zeta in the comments if the color to be inverted is a gray very close to the middle, the inversion will generate a similar color which may not be easy to read. You can try to avoid this by manually checking the difference of all channels to their inverted versions, and if all of them are bellow a certain threshold generate a different color. A simple approach to this would be to generate black if all channels are closer to white and white otherwise. There are also some libraries/micro-libraries that generate colors and their complementary versions with other approaches, such as using HSL. These may be interesting for you to take a look. Here are some of them for reference: 

And why not throw in a factory method too, although some might argue it's a return to the year 2000. In order to get the enumerable features of a Collection, I'll have to use a Collection behind the scenes, but I'll augment that with a Dictionary that keeps track of the keys used in the Collection. Then, when I want to test the method, I can check the Dictionary (and get all of it's hash-tabled goodness) instead of enumerating the Collection or suppressing a potential error by checking the index/key directly. I also want to make the Collection configurable so that it can be 0 or 1 based according to preference. I've made this setting private to the Collection, so it's up to the developer to adjust for the purpose at hand, but it could easily be exposed as property or set in a factory method. Pass the Widget First, we need a class for the objects that we'll put into our custom collection. A will do nicely. Nothing special here - just a class with a few encapsulated fields, and a bonus read-only property for returning an instance of itself.