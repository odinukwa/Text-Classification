I know you are primarily interested in your use of Task. Sadly my remarks are not about that. I think would be better named as . For one, you really haven't scheduled it. Two, the phrase "Pause" is bonded more closely to your method. And three, it seems like a natural counterpart to . You may even consider having be a public settable property. The top of your method has this: 

I would expect to see a in the conditional, or not have it in the true block. And the way your code currently exists, the is not needed there. I think your method does not adequately separate concerns. It does 2 things. It gets a new cancellation token source, and its stops the stopwatch. Perhaps these would be better if separated. Perhaps the cancellation token source should be created when or runs. 

I can't see anywhere that the thread is told which block it is supposed to check. So, instead of starting 9 threads, one to check each block, it looks like you're starting 9 threads and having each of them check all nine of the blocks. You could partition the blocks and then start a thread to validate each block, but this seems like overkill. Simply starting a single thread to check the nine blocks is the smallest change and probably the right one to make, since checking nine blocks is almost the same amount of work as checking the nine horizontals/verticals. With that in mind, you can simply change the code to the following (an achieve the same result with 8 less threads): 

To answer your (1) in a recursive method ... Eric Lippert does it in Producing Permutations series, Part Three , specifically in his recursive method. I won't dive into your (2) only to suggest that perhaps you read all of Eric Lippert's series to learn more. Braces Need Improving On coding style, your use (or lack thereof) of braces could be improved. The C# convention is to put the opening brace on a new line (this differs from Java). More importantly is that you lack braces on so many one-liners. This is heavily discouraged. I would suggest cleaning your code to change a snippet from this: 

The only reason I have and as public methods is for timing them individually with a . The sad thing is this is a nice class but the things that work best and fastest with it - for a reasonable upper limit - are the things that aren’t needed since you can simply output as a . And the things that were put in to address really large upper limits are the things that will still be sluggish. Nonetheless with this class, I can at least iterate over all of the primes without an out-of-memory exception, which is something I can’t do with the other sieves that I’ve seen. 

A couple of things stand out. init Since doesn't take a parameter my assumption would have been that it would take care of initializing the global list. It doesn't, this has to be done first and init doesn't perform any checking to make sure that the global has been initialized / that init hasn't previously been called. clear You clear the list by repeatedly calling . This means that you have to traverse the entire list, remove the last item and then repeat for each item in the list. It would be more efficient to remove from the head. With your existing interface, it looks like you could just call . 

It becomes much more obvious that your variable should be called . Letters for variable names don't cost the Earth In context, you can figure out what , , mean. However, they would be much more expressive if you pad them out with some missing letters: , , . 

I intentionally only want the YearQuarter instance set publicly using the . method. To get the 4 previous quarters, you could use: 

It's a short enough method that there's not much to comment upon. You could shorten these two lines: 

You will note the class and method are both . There are not class level properties or fields. The method contains instances for a and . All moves are handled in one loop, and there is no special check based on move number. Private Nested Segment Class A segment can be characterized as and an . Or it could be a , , , and . Whichever you go with can derive or calculate other properties. I personally like , , , and . Yet below I set everything during and don’t worry about read only getters. This is a tiny bit of bloat on an instance, but since I have at most 6 instances, this bloat is okay by me. If I have a million moves, I don’t have to perform 1 or 2 million getter calculations. 

It looks like it's updating the head of the list as it iterates through to print. It's not of course, it's using a local variable that's actually iterating along the list. The name is a bit misleading, or or something suggesting that it's expected to move along the list might be better. left = !left At the end of your split loop you can do: 

My initial impression is that there seems to be quite a lot of shared responsibility, particularly between the static methods in and the rest of the code. For example: 

or using the expression bodied auto property suggested by @Risky Martin you would end up with simply this: 

Magic numbers In the code above, you're returning 1 or 2 to identify the child type. This doesn't have an obvious association, so you should think about replacing them with a const/#define to make their meaning more obvious to the reader. Function visibility At the moment, all of your functions can be imported into other modules and called. Consider if that's really what you want, my view would be it isn't. Decide on what you think the API to your code should be. Put relevant function and type declarations into a header and mark the rest of your functions as static to indicate that you don't want them exportable. Function order You're calling before the function has been defined. This means that the compiler is inferring the interface, by the way that you issue the call. I'd consider changing the function declaration order so that is defined higher, or adding a function prototype to the top of the file: 

One way to account for these corner cases is putting several conditionals and checks in place. This makes the logic chopped up. Wouldn’t the problem space be simpler if each and every move always has a -3 and -5 away move? It’s not an impossible dream if we have the load appropriately configured zero length dummy segments (more later). I will do just that: load zero length dummy segments when the is created, and this will guarantee that each and every real move will always have a -3 and -5 away move. The collision checking section will be more streamlined by doing it this way. Plus, for each move you will only check 2 segments AT MOST. This scales extremely well. First 3 moves logic bug Your code for the first 3 moves is missing a critical check. You do not check that the distance for a respective move is greater than 0. Optional General Considerations These next items are purely optional and are general in nature. The better CR answers not only address the heart of the problem you are trying to solve but also bring up other issues that can make you a better, well-rounded developer. Class-level variables My solution will not need any class level properties or fields. I see no need for a or . In fact, can be a and can be a method. Given the special nature of and , I likewise choose for them to be and nested classes inside of . The only things that I have exposed as are those minimal things that truly need to be . Even the constructor to or are ; instead I require you to use the method for them, where is both and . This reduces the ‘surface area’ of my classes to the bare minimum. Named constant for output of -1 I also like assigning the index not found (-1) as a named constant: . Sure -1 works but what happens if someone changes the requirement to be some other negative number, e.g. -9? Do you change your code in 4 places or just 1? Plus the code reads cleaner with since its intent is clearly apparent. Flexible method signature Others have suggested it before that you could make the signature to be . If it’s not apparent to you, this signature will accept an as input. Sure you can say that the original problem required the signature be but you’ve already reworded the original problem to make it your own. So you have the liberty to reword the signature requirement. To throw or not to throw The last general consideration is whether or not to an on bad inputs. Understand that I get it: you have an interesting math problem in front of you and you care most about the logic to solve that problem, and not so much in the finer implementation details of dealing with bad inputs. That’s just ‘finishing’ work after the main task at hand. Some could argue that you code works fine in this regard. To complete the topic, however, I think one should on invalid data, and not simply return -1. To me invalid data is when the array (or IList) is , or when any move is . Having less than 4 moves isn’t invalid since I can imagine it is valid to consider that a critter may travel less than 4 spaces, as long as each move is . That concludes the sidetrack. Back to the meat of the problem. First 3 moves – staying DRY Replacing the 2 lists with a single , I could load the first 3 moves this way: 

Again, this may be acceptable for your usage scenario (it doesn't matter if processing is occasionally done multiple times, you only add from one thread, the likelihood of a duplicate input is low), or you may need to think about some kind of locking around read/writes. 

White Space As was mentioned in the comments by @Aluan Haddad, your initial code was missing white space between things like operators and operands. As it stands, your code is still missing standard white space, such as a blank line between methods, a blank line between the end of your section and the start of the code. It makes your code feel a bit cramped. Const If you're not going to be modifying the contents of variables passed into functions you should be declaring the parameters as . This helps the client to know that it is safe for example to pass a string literal into your function. Users are unreliable Even well users with good intentions make mistakes. You're not capturing all of those mistakes with your current code. What happens if the user puts two spaces between parts of their name? Cleanup In , you up a buffer which you never clean up. It may be that you've intentionally done this because you know that it will be cleaned up anyway when the program exits. Alternately it may be that you've forgotten to do it. Generally I'd suggest always cleaning up after your 's because that way whoever is reading the code knows you've thought about it. Naming Some of your names are good and appropriate (, ), others are less descriptive (, ). Good naming makes your code a lot easier to follow. Live up to your promises says that it returns a . It doesn't. Be consistent prompts the user, outputs what they tell the program, then returns the value. on the other hand parses a string, outputs the initials and then doesn't return anything. The prefix really suggests that the methods should be doing a similar level of task. Separate out user interactions could be written in such a way that it took in a name and returned a string containing the initials, then it could be called from future programs that had different user interfaces. At the moment, it has a in it which makes this more challenging. Try to isolate your user interactions (inputs/outputs) from your main logic (string processing in this case). Allocate how much? allocates sufficient memory to store every character from the persons name. Is this really required? Since you've declared a buffer for the persons name as , should this really be a constant that can be reused so that doesn't need to malloc, it can just have a local buffer? Multiple declarations on a single line I don't really like them. I find that they make it hard to locate variables so I would avoid this: