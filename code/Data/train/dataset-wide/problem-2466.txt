There are many SKUs, (around 50,000) which I'm trying to match to around the same number of image files. SKUs contain characters that are not legal in filenames, which must be stripped or replaced. The files we're trying to match to each SKU live on an NFS, so reads are slow. We don't just need to match ABC to ABC.jpg, but also ABC#1.jpg and ABC#2.jpg, and need them returned in this order. 

Rather than repeatedly ask the file system if it has a file called ABC.jpg, I ask the file system once for a list of every file in the given directory, and store it in PHP's memory as an array. (The directory should only ever contain files which are possible matches.) I then the SKU in preparation for a search of the directory contents. I replace (an escaped backslash) and with to match either or which the client may have in the file name. (Example, ABC/DEF13 becomes abc_def13.jpg and I need to make that match.) Finally, I build my regex pattern and run to find the matching files. I then them and then them by a string length comparison method to make sure that they are in numerical order like so: ABC.jpg, ABC#1.jpg, ABC#2.jpg I welcome ideas on how this code can be improved and made to run faster. The NFS presents real speed limitations and can't be helped. 

I am working with Cassandra and using datastax java driver so I have to re-use prepared statements and that's why I am caching it here. Prepared Statement and BoundStatement. Is there any better way of making my method thread safe instead of using synchronized block like that? Any other data structure which might be thread safe for these kind of operations? I am working with Java 7. 

Now in my class in the method, I am using passed from both the consumer to extract all these variables which have been set, do some processing by using those variables. And later on we will get some new variables which I am setting it by cloning the old builder. 

Below are my corresponding validator classes: ValidatorA class This class is called by , basically it's method for validation. 

I have two consumers and each consumer has their own validation logic entirely different from one other so I am using two validator class for that, one for each other. 

You could then sort by . The problem with this is that any time you change a SKU or add a new SKU you would have to re-sort the entire array again, and update the entire index. (Deleting a SKU wouldn't have an effect.) PHP: preg_replace_callback + str_pad I landed on this method: 

In this case, becomes and becomes and becomes . You can then do and it will alphanumerically sort correctly. This even works for more complex strings like In actuality, I've collected all of these padded SKUs into an array, and then inserted them using a (which my indexes in MySQL make possible) in chunks of 500. The column can be indexed for speed, and I can insert or change a single SKU at any time without having to rebuild the whole index. Question Is there a better way to naturally sort in MySQL that supports coming before coming before ? I think that with some complex MySQL I could have it doing this and through MySQL functions on the fly, but isn't it faster to calculate this once and store it as a simple string? (Even if it has to go back and forth to PHP to do that?) 

My question is - Do I need this at all when I already have , class? class just contains all the variables combine from both the validator class and I am using builder class just to set data in both the consumers and then use it in execute method of , and then clone the old builder to make a new builder object again by setting some new variables. Is there any better way to do this thing? Looks like I can get rid of but not sure how. 

I have created a StopWatch class to measure the performance of any code. I use this StopWatch code in any of my multithreading projects as well. 

I am using below class to send data to our messaging queue by using socket either in a way or way as shown below. It depends on requirement whether I want to call or method to send data on a socket. Most of the times we will send data through aysnc way but sometimes I may need to send data through sync way. 

I have a MySQL table which contains product SKUs among other things. PHP powers importing data into this database, managing data through a control panel, displaying the information on the front-end, etc. (For clarity, this is a Magento site.) On the front-end, I need to be able to list SKUs in natural sorting order, however MySQL does not have a method the way PHP does. There are a number of MySQL only solutions, each with their own problems. The simplest that you see is to cast the string with something like but this only works for the simplest strings. Let's look at more complex options: MySQL: ORDER BY LENGTH(col), col The idea here is that is shorter than and will be sorted first. But is alphabetically before so that also is sorted first, giving you which looks correct. However, this doesn't match PHP's method. For example, will come before but will come after which is incorrect. This is because is longer than and the comes after the when comparing and . This should read PHP: natsort I have the opportunity for the PHP application (Magento) to create an Index and either totally rebuild it on command, or update it on a SKU-by-SKU basis. At first, my solution was something like this: 

I am using here instead of standard because if for whatever reason, I cannot send data on a socket (let's say socket is bad or dead) then I don't want my cache to keep growing and ultimately run out of memory so that is why I am using guava cache which can start dropping records if it reaches the limit and my application will keep running. Any better way to implement what I am doing or get rid of synchronization altogether? And maybe we can create an interface for this class? 

So the only difference between those two above methods is - For async case, I need to retry at all cost if acknowledgement is not received but for sync I don't need to retry at all and that's why I am storing more state in a class. is a class which receives the acknowledgement for the data that was sent to our messaging queue and then calls method below to remove the address so that we don't retry after receiving the acknowledgement.