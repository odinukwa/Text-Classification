As for your question about "how to keep a running average": if all you care about is the average number of guesses (i.e. total number of guesses divided by total number of games played), then you don't need to keep a record of how the total number of guesses happened to divide up into individual games-played. Just store those two numbers in your file: 

Four lines shorter, including the comment (although it will get longer if you actually add the s to use the non-standard compiler builtin). The main savings is due to brace style. Putting in the explicit is a good habit because it will silence warnings from some compilers. (Some compilers these days have blacklisted "assignment-used-as-an-expression" to such an extent that they actually warn about — you put two pairs of parentheses where only one was needed, so clearly you've made some kind of mistake!) Parameters and return values in C++11-or-later should never be const-qualified; it inhibits move semantics in general, and is thus a bad habit that you should break ASAP. Note that is a valid synonym for , and in fact so is in my opinion; but then in my opinion is a valid synonym for , and you're clearly not willing to make that assumption yet. 

Notice that I wrote where you'd written . C isn't Pascal or Python; there's no need to jump through hoops like here. Characters in C are small integers, and you can do math on them just as you can on any other integer type. Moreover, you should do math on character types, if it eliminates the need for a cast operation. Type-casting in C and C++ is a code smell; if you really need a cast, something is horribly wrong with your code. In this case, fortunately, you don't need one. 

You've got 21 consumers and only 20 producers. This means your test code will never terminate, right? You can avoid off-by-one errors like this by getting comfortable with the "half-open range" idiom of C-style languages. Every for-loop you write in C, C++, Java, C#, JavaScript, Perl, or whatever, should look like this: 

In general, don't inherit from or any other container class. If you want to add functionality to a standard container, add it via standalone algorithms, such as those found in the standard header. The problem with inheritance is that either you have to abandon value semantics and start allocating everything on the heap and taking references to them (as Java and C# do), or else you have to abandon most of the advantages of inheritance. For example: 

Yes, the way of doing things in C++ would be to provide static member functions of your traits type. Consider: 

doesn't really need to be a template, since its argument can only ever be in the range 0 to 35. I'd just make it 

However, I think your code as it stands is a bit sketchy, because of the overflow issue. should yield , not undefined behavior! To mitigate that issue, I agree with you that casting all of the parameters to would be a good idea. Let's implement that. 

Your class is merely a type-erased wrapper around a callable. We have a name for that in C++11 and later: it's called . Consider: 

Notice that the type in the first two calls is , because the thing we're perfect-forwarding is an lvalue of type ; and in the third call is . If I were designing the API, I'd provide simply 

Stop! I'm pretty sure this is one of your bugs. You're saying, "Carefully load a value from into a register named . Then, without any kind of synchronization, compute and fetch the stored at that memory address." If two different threads do this at once... well, it's actually okay so far because both of them are reading, not writing. But one of them will succeed. That thread (call it Thread A) will update the value stored in , and then return reinterpret_casted to a . Return it to the caller, who can do absolutely anything with that pointer, including write through it. So now we have a data race: in Thread A, we've returned the pointer to our caller and our caller is writing to that memory, while simultaneously in Thread B, we're attempting to read from without synchronization. Undefined behavior and boom. 

There is a simpler and therefore perhaps better thread-synchronization mechanism, if all your threads are launching from the same spot at the same time. Use a mutex which is locked when the threads spawn, and force each thread to "check in" by locking that mutex before it's allowed to continue. For example: 

(My futures also support , , and as specified in N3865 "More improvements to std::future<T>", and also , but those aren't used in this code.) The Concurrency TS's philosophically-incorrectly returns a ready future when called with zero arguments. My version doesn't treat that case specially, and so the natural behavior falls out: the internal is destroyed before any 1 of the 0 provided futures has become ready, and so returns a ready future whose will throw . I'm a little concerned by the apparently necessary use of lock-free programming. Am I missing an "easier" (higher-level) way to do it? 

The other answers make some good points (especially @vnp who caught the two memory leaks — that's a huge deal!). I'll try not to repeat too much. 

Nit: Your default could productively be replaced with . This prevents you from quietly overaligning the buffer of a . 

Your claims to return a value of type , but it's actually returning , which doesn't necessarily correspond to one of the enumerator values of , does it? In particular, it could return (), which I don't think your code handles correctly. I would probably try to deal with this by writing a function that Does The Right Thing no matter what unsanitized errno value you pass in. 

that should be a sign that you're using the wrong type for . Instead of taking a (which can be null), prefer to take a (which cannot be null). In other words, a C++ reference is very similar to a non-nullable pointer. (And if you need actual non-nullable pointers, check out the GSL's not_null template.) Also, remember to -qualify your pointers and references to indicate that you're not modifying their pointees; and remember that should be passed by const reference, not by value. Hope this helps! 

redeclare the same function — so generally we'd like to omit the redundant . Man, so far I've commented on every single line of the code "well, this line is weird, but I guess it's harmless in this context..." ;p Don't worry, the line after this one looks great! 

a good compiler will optimize away the condition (since obviously you can't get zero by adding a positive number to 3); but if you have a bad compiler, it might actually be generating that extra test every time, so replacing that condition with would help in that case. 

Looks good to me, algorithmically and syntactically. What makes you think it's wrong? Stylistically, there are a few things you could improve: 

Well, it does work, as you've shown. But in order to use references instead of pointers, you had to make two awkward changes to the "natural" pointer-based code: (1) You had to invent a object, which is a global variable, and suffers all the problems of global variables (for example, it won't play well with dynamic libraries, a.k.a. shared objects, a.k.a. DLLs, because you might end up with a program containing two variables — one from the main program and one from the DLL). (2) You had to prefix all your accesses with an extra character. Compare your way (slightly reformatted for style and const-correctness): 

Also, to clear up one of your misconceptions from the comments: has nothing, zip, zilch, to do with "not being able to edit" the pointed-to object. What does is give you a weak reference that will automagically "expire" itself when the last strong reference is dropped — in your analogy, it would be like you're giving the Student a ticket redeemable for the real book, but with the possibility that the LibraryManagementSystem could burn the book in the meantime (in which case the ticket would become worthless). If the Student actually did redeem the ticket, by calling , then the Student would receive a strong reference to the book, and could most certainly call any public member functions on the book that he wanted to. Non-modifiability is basically the domain of ; strong and weak references are an advanced concept (unrelated to ) that you should probably be steering clear of for the time being. But heck, see these slides on smart pointers if you really want to learn about them right now. If you use value semantics (i.e., passing s around by value as in my outline above), you do still have to worry about modification: i.e., Students scribbling in Books and then returning them to the Library. This is solved basically by making the Book out of teflon: simply make sure all its public member functions are . Right now the only public method implemented is , so we're all good there. Does that make a certain amount of sense?