I don't see anything apparently wrong with the coding, other than the selection of your index variables seems to be random ( in the outer loop, in the inner one for example). is pretty apparent as to its meaning (index), but things like don't really have any semantic meaning. Like other variables, you are free to choose one that best describes its purpose and loop variables can have more than one character. The other thing I see is that at the top of your file you have this: 

Method Name The method name is confusing, because the word "Log" to most developers means some kind of diagnostic routine that writes data to a file or console purely for debugging purposes. You are using it to take over the console (by clearing it) and output the text graphic of the dungeon to the console. I think a better name would be something like or something like that. However I think you shouldn't be having methods anywhere in this class, let the user decide what to do with it. If a class has a valid representation, you should be overriding the method instead, so becomes : 

You seem to be very much over-complicating this. Here is an efficient solution: Assuming and are positive numbers and the result is a valid 32-bit integer value 

Now the user of your class can decide to do something else with it, such as write it to a file, send it over the network, print it on a webpage, etc. The user is no longer tied to the console. 

which is easier to work with. Anyway, hope these code suggestions help you to write better code and update the design of your code to make the solution work for all data sets. Good luck! 

Reviewing your design, you mention , however you have: - "name": "none", - "health": 100 These lend themselves to player actions and multiple players in a game. The health, for instance, where do you manage the "drink potion" and "being attacked" functionality? It seems like you need a class for the player and two methods, and - which means we also need a property for when (not real code): 

because is the same as etc. When I run your code after making those changes, I do want to ask why you have the file "split" happening. When you perform that, (if I use the smaller example data on pastebin you linked to) I get the following structure as : 

When the program runs, it will load the player data and location data (knowing x and y from each section definition) and start the game. Finally, it sounds like you might want a decent IDE, I'd recommend starting with the community version of PyCharm from JetBrains. Hope this helps with your design and code. Good luck! 

Several issues with your code which is causing you issues (this won't give you the final code but it will help you get there). Firstly, never hide issues by modifying the stack recursion, and never wrap operations in . The errors are there because you are doing operations the computer does not like (and you shouldn't be doing). As an analogy, you could drive sometimes on the wrong side of the road to get places faster - but you don't because it breaks convention. Next, update your code to be more python'ish. For example: 

This shows the power of inheritance a little better. MSDN also has a good example using shapes as well that you may want to read. The take-away here are these points: 

Avoid Mutable Properties Your has a few externally mutable properties that I don't see a reason for them to be mutable. It would be better if these weren't mutable: 

And so on for each one of your cases. This gives you much more flexibility when extending your API or even adjusting what parameters go to what methods (for example, the case). Another thing it gives you is not having to worry about the locale of the text passed in for the statement. You are assuming English but what if somebody tried using your API in Spanish? Using a well-defined API forces them to call concrete methods instead of methods by text name. 

But since we are learning about abstraction/inheritance I'll leave it as a class. Now lets tackle the implementations, I'll do two of them here, you can figure out the rest: 

It is now functionally the same but has less code to maintain. Nullable properties can also be defined shorthand: 

So what is happening here is you know that for every open bracket there must be a close, so if we count all the opens, and subtract all the closes, that resulting number must equal zero. 

You may be over thinking this, all the types have a common implementation and you can use to parse from a string. 

I see quite a lot of repeating code, repeating the same activity: get request, build string, query string, return result. The Single Responsibility Principal can help to clarify your code here. As a suggestion, you might want to turn something like get_products (and similar) to: 

Admittedly I actually wouldn't do the last line, purely because it's not clear coding, but it demonstrates the ternary and that you can utilise functions in such a fashion. The while loop is removed, the exception is removed, and the input isn't converted. An extra line is printed explaining what happens if any other key is pressed (you should trust your users will know if they hit the right key - don't over engineer it - plus also as they have to hit [ENTER] to complete the input, they have a chance to fix it, if they do actually press something other than intended). Hope this helps, Good Luck! * code is wrong: Not wrong per-say - but a failure to express the instructions in an easy to comprehend fashion. If I cannot read your code and understand what you're trying to do - then you've wasted time writing the code (obviously there are always exceptions to the rule and there are times when a comment is necessary). 

having them all send a sql string into a single function. That way, you separate the database functionality from the business logic of each activity. For and , three things. Personally, I don't use double underscores for functions, a single one is sufficient to advise other developers that the function is intended for private use. Secondly, the string building process, you should attempt to use list comprehension to build the strings rather than a loop, this will result in much simpler code (and no "last param won't have..."). Thirdly, both these functions are the same, and only differ in their use of a or . You should have both refer their details to another function with a parameter. Something like (not functional code, just a typed up demo for the concept): 

Actually I'm going to go ahead and say that neither one are thread-safe. The problem is the method. Really the should return the value as well: 

You are saying its a "tax id scan copy" but then you are loading a "photo" and displaying it as an avatar. What is the difference between and ? I'm assuming one is a physical file path and the other is a web URL. If that is the case, I would suffix the first with , otherwise a casual observer would expect it to return the binary image data. 

So now we can look at the method of your class. It is doing way too much. Let's break that down a little bit. Your program needs to do 3 things: 

The other comment I have is that you are starting a with an infinite loop and no way to (gracefully) cancel it. You should read up on cancellation tokens and how to use them. You also have an extra indentation level in your method, while it doesn't affect the performance or operation of your program, it is nice to get them lined up. 

Now let's suppose we want to validate this class, but we need to support quite a few types. We don't want to have to modify the validation logic each time we add a new type, so lets create a validation attribute: 

Also notice I changed the name. Also notice how I left out the method. This isn't a good way to do that, what if you wanted different text? Or only the number? In a different language? Try not to be too specific in implementation, leave that up to the "end" user. Actually instead of an class, I think this would be better off as an interface, this is what it would look like: 

I would narrow down your try:except to only the statement(s) which could throw the error. Having such a large chunk of code in a try:except block could result in many exceptions thrown, none of which would be caught as you're only looking for IOError. Also, for performance, you should build the statement and the data set from the loop, then throw the statement against as a single database call instead. Regarding construction, your code is just one huge blob. It's important that you refactor each operation into its own function, this saves on tracking down errors, and if you make changes in the future, your changes only affect one function. If the change is not liked by the rest of your code, it's easy to back out. Can you imagine if you made 5 or 10 changes in your program as it is right now, and then it stops working? Which change was the breaking change? How would you find out? Why did it break? etc. Also, I'm not talking just simple syntax errors, I'm also talking about logic errors or data errors. These can be hard to track down if you don't have any tests validating your code. Good luck! 

I can see the following problems with the above block: Redundant comment, redundant brackets, using a while loop and throwing an exception to control program flow, converting the input into an integer (you're not doing any math, so there's actually no need to convert it into an integer) and assignment with an unused variable (). I'd do something like this instead: 

The first thing I would say is that the API is not well-defined. The upstream code should be calling the specific method. The fact that you call a single method based on multiple names is fragile. It seems like you are trying to stick an entire API into a single method. It would be much better if you exposed one method per "childCollection", for example: 

The only reason I would use the intermediate variable in the method is to do debugging inside the method. You could add a breakpoint on the line and debug the value. If you are confident in the operation of the query and the results, shortening it up helps with code maintenance. 

I would advise to not have a list of "variables used" in your program. They really don't serve any purpose (pretty sure you can figure out when reading the code that writes to a file, etc). This only serves to add complexity to your code documentation. The problem is that if you change your variable name in your method, then you have to find it in there and change it too. Some automated renaming tools are good at renaming variables, but don't (usually) find it in documentation unless it follows a specific format (like Xmldoc). The other thing that I see is that you have a lot of "thinking" in the code in the form of comments: 

This keeps your database layer separate from your data layer and separate from your presentation layer. The more separation you can do here, the better off you are going to be when it comes to updating and maintaining this code. I would recommend a good read through SOLID principles to get an idea.