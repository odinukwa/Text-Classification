Try to avoid parallel data structures. They make the system more fragile, as you have to maintain the relation. If you need a parallel structure, try to keep the name consistent. Here you seem to be calling it both and . Why not make a field in ? Then you'd be guaranteed to associate the right with the right . Consider renaming to something like or that is clearer about what it does. You could be modifying almost anything. It's hardly better than . Also, any time you find yourself naming variables something like one and two, there's a good chance that you should be using a . Possibly a in this case. 

What you do here is run a query based on the string and then return the first row of the result. However, you now have no way to get subsequent rows, as you throw away the query result handle. You take care of this situation with a in 

Rather than echoing the result, it would probably be better to it. That way you can display it or check for invalid values or whatever. This can also be seen as a violation of the Single Responsibility Principle: you are calculating the hash value; don't display it as well. If you really want to display it, consider changing the name to something like . 

This kind of check is risky. What happens if you change your battles so that there is a \$1\%\$ chance that you do double damage? Then it would be possible for your to go directly from \$1\$ to \$-1\$. Your army might win with negative troops, since once it goes negative it can't get to \$0\$. If this happens to both armies, you may continue until you go out of the integer bounds. 

Note how adding the function saves the extra in that you used. Note how I get the string sizes first and store them in variables. This avoids the overhead of function calls. Your version had at least two function calls per iteration. Mine only has one, and that one allows for simpler code (that avoids two more function calls). I also avoid doing a subtraction for every iteration. On the bright side, in your version the function calls probably get optimized out. Mine won't be because I use a loop in that function. C You use the C . If you wanted to use the C string functions as well, you could say: 

You could simplify that by declaring a CSS class that covered those four cases. Or possibly a different element, e.g. an . Hiding 

The single quoted string will also be slightly quicker to interpret, although I don't know that the difference would matter in this case. I also changed the order. It's not uncommon to see the constant on the left in C-based languages. This is because would give a compiler error while will happily evaluate as false and continue. Incidentally, you don't need this statement, as the later loop and count check will handle this case for you. There's an argument that the code is a little cleaner without this check. It certainly would be a little shorter. 

That will also save you a level of indent. This works because the else ended with a return, so you don't actually need to invert. You can just move the check before everything else. A return statement in a then clause makes for an implicit else. You don't have to add an explicit one of top of it. 

Note that calling setCalibratedValues with both 762 and 763 will give each the same Calibrated object. If that's not what you want, you could give Calibrated a copy constructor and make a new one each time. Also note that this method requires creating all the calibrations at the beginning. This can be wasteful if you only use one per program invocation. Not so bad now, but what if you get more calibration sets? It would be possible to put the rules into a file or files and then read them into the objects. That would eliminate most of the constants. You'd have to make sure that you read the file by the first time that you needed the values. Perhaps put them into a Singleton object? At worst case then, the Singleton constructor could read the file the first time that it was needed. Or you could prime it earlier. Some things that I don't like about setCalibratedValues that you didn't mention: 

If there are any values other than , then you can look them up more specifically. Also search for a few values that you construct, e.g. for a of where , , and are disallowed, should be in the list. Also should be there. 

This code is unnecessary. We already output the decimal point and then any subsequent digits. Also, we eliminated the variable. 

I'd call this for readability. Otherwise, one might guess that it reflects the overall indent rather than a value that changes over time. 

I also added some whitespace in the because I find it easier to read. I changed to a single quoted string and used a different regular expression delimiting pair. Another problem is that this will match some invalid emails. For example, is valid in this pattern. So if those five characters appear in the field, it will be recognized as valid. Note that you don't restrict characters that appear before and after that sequence. 

This allows the user to not know what the various types are, just how the user would describe them. Also, this allows the underlying implementation to change without impacting the user. For example, if we moved from a 32-bit operating system to a 64-bit operating system, the second case might change from to . 

The entire / structure is unnecessary. The expression in the returns a Boolean value, so pass it directly. You don't even need the intermediate variable, although it does make the logic a little clearer. Second, this doesn't track properly. You set it to in both cases even though it should be in the first case. If you're not going to use it, you might as well get rid of it. Third, why create an empty list and pass it to the constructor? It's a constructor. Make it create its own list. 

Finally, if is greater than or equal to , you return . We can now say that what this function does is: it sets a global variable to the number of times that an element of the array is greater than all the members to its right; it returns the largest value from the array; and it produces output. That's three things done by one function, but the usual preference is to only do one thing per function. You mention that you are worried about efficiency. So apparently you put these three responsibilities into one function so as to maximize efficiency. I'll accept that decision. Perhaps someone else wants to argue it, but I think that there's some things that I can tell you within the parameters that you set. There's basically two things in this function that eat up time. One is that you do a lot of print statements (up to one less than the number of inputs). The other is that you are doing the recursive call. Presumably you have to do the print statements, so we're stuck with those. We don't have to do the recursive call. 

Now I have a declaration block, an initialization block, and the start of the coding block. I changed the declaration of . Instead of being of type , I made it of type , which is the interface name. This is why we have things that implement interfaces, so we don't have to care what the implementation is. You happen to be using a , but if you change that to an or any other implementation, it shouldn't matter. I added an at the beginning of the . When I first ran this, I didn't know what the various outputs were. Now I do. Avoid code in You put a lot of your code in the method itself. As a general rule, there should be very little code in main. Process the arguments, perhaps initialize variables, and then call methods to do the heavy lifting. This allows you to reuse those pieces that do actual work. If all the code is in , then you have to edit to use it. Further, you can't just add your class to another project; you'd have to copy the code itself. 

If the comments are correct, change the to . You can also use an / to get rid of the extra check on . This review is relatively long, so I won't try to review and directly (I've made some comments along the way in this code). In general, you should prefer to work with interfaces rather than implementations. A good search implementation should be independent of what it is searching. For example, you might have a search that worked with any type that implements . Then you could move all the game logic out of your class. You might put a little in and a lot in and . As it is, you'd have to redo your class almost entirely to work with a different kind of search space. Even another game would be mostly differently. Incidentally, if you'd included your class, I probably would have tried to run this. As it is, I haven't run any of your code nor my modifications. I also didn't try to figure out if this was a valid implementation of A*. 

You don't need those statements. The return is sufficient. You use both kinds of strings for the same purpose. Since you are not using variable interpolation, I'd suggest only using single-quoted strings. 

I also added additional whitespace for readability. Since this is only supposed to work for valid day and month values, I added some basic checks. Even with these, it will still allow dates like the 31st of February, but this restricts the range somewhat. I just return an undefined value implicitly, but you could explicitly (which would do the same thing) or do something like throwing an exception. Note that this also handles if the month or day is given as a string (e.g. January) rather than a number. Handling zero values with different returns than a value of one is possible: 

As has been expressed in other answers to this problem, the critical insight is that $$LCM(1..1) = 1$$ $$LCM(1..n) = \frac{LCM(1..n-1) * n}{gcd(LCM(1..n-1), n)}$$ From that, you can build up to an arbitrary \$n\$ by applying the second formula repeatedly. 

I personally avoid using the single statement form of . I always create a curly brace block. This helps if you need to add additional statements. This is especially true because in the same set of clauses you later do use the block version. I would never put either whitespace or a comment between blocks. This makes it look like your structure is finished, so the next person may read it wrong. This is another advantage of the block structure, as you can put either or both in the block. 

Now there may be a reason why the no-op right shift is better than an explicit cast, but if so, tell me. Also, this would be a great time to define a unit test that shows me what can go wrong. That way if someone optimizes the right shift out of the code, then at least it will fail unit testing immediately.