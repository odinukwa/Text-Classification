Now to be fair, I don't know what the bottleneck in this code actually is, and I'm sure your application probably doesn't call for such niggly optimisation, but I still think it's interesting. I'd wager that the third version is the fastest. 

Notice how as soon as the grade matches the range corresponding to something in the Enum, the method immediately returns. Now an example of how you might use that : 

What we're doing here is creating a new typeclass called Prop. We need the syntax because we need to define the behaviour of an instance of the class. If we don't introduce a symbol for it, then how will the compiler know what we're talking about the in the typeclass definition? For example, the line says that for every instance of typeclass , there must be a method called which maps to a boolean value. Likewise, there must be a similar method for . Now the line may cause some confusion because appears twice. It's important to understand that , being an instance of a typeclass, is a type. There are no "objects" as in object-oriented languages. Remember: is a type which satisfies the typeclass contract given by . The Java equivalent would be a class implementing an interface . What we're saying here is that for type which implements/is a part of this typeclass , there is a method called of comparing them. And its type is meaning that it takes in two expressions of type and returns a boolean indicating whether or not they're equivalent. 

A few. Sorry it seems boring, but there's not much better you can do. The biggest change might be to make this into a generator function, which may be a tiny bit neater. 

The statement can be removed, also, since it's really two generators. But that's being really fussy about performance. 

There's no real way to speed up the brute-force enumeration of all possible 3-letter passwords. Perhaps you could use the dictionary. There's a finite list of 3-letter English words. They may be slightly more common. Also, if you google for "most common passwords", some kind of 3-letter version of that list could be tried before anything else. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

2. User cancellation is not an error condition I'd consider this section to be an abuse of the error handler: 

...makes it immediately obvious that the array is 1 based without having to scroll to the top of the module or remember that the base is non-default. Variable naming: and are about as meaningful as and . Something like and would make it a little more obvious what your code is dealing with. Worksheet references: You are currently using magic numbers to locate the worksheets that you're operating on, and the indexes are based on the ordinal of where the sheet is in the collection. If this is intended to operate on two fixed worksheets, use their class names instead. This has two benefits: first, you aren't using 2 procedure calls ( and the implicit ) to get a reference that you already know and have access to . Second, your won't break the first time you add a new worksheet. For example, use (or whatever it is) instead of . Binding: There is no reason to late bind to the scripting runtime. The interface hasn't changed in this century, and is unlikely to. This is a pretty good performance hit in exchange for absolutely zero upside. Add a reference to Microsoft Scripting Runtime and declare it explicitly: 

Your use of the dictionary seems to be a way to allow the numbers to arrive out-of-order. Rather than sort them, you seem to be trying to use a dictionary (and associated hashing) to maximize efficiency. This doesn't really work out perfectly, since you wind up doing sequential searches for a given value. Hashing a low:high range (a dictionary key:value pair) to avoid a search doesn't help much. Only they key gets hashed. It does help in the case where you're extending a range at the low end. But for extending a range at the high end, you have to resort to searches of the dictionary values. What you're really creating is a collection of "partitions". Each partition is bounded by a low and high value. Rather than a dictionary, you can also use a trivial tuple of (low, high). To be most Pythonic, the (low,high) pair includes the low, but does not include the high. It's a "half-open interval". Here's a version using a simple of tuples, relying on hashes instead of bisection. A binary search (using the module) may perform well, also. It would slightly simplify adjacent range merging, since the two ranges would actually be adjacent. However, this leads to a cost in restructuring the sequence. You start with an empty set of partitions, the first number creates a trivial partition of just that number. Each next number can lead to one of three things. 

Third, turning off screen updating is your friend if you are going to be writing values to a lot of cells. Again, I don't know the use case here, but it is a good habit to get into especially because of... Finally, performance. There are some things that VBA does well, but in general the built in Excel functions are going to be much, much better regardless of your algorithm. I have yet to find a function that I can outperform Excel with if a native alternative exists. First among those functions are look-ups and sorting, which Excel does extremely well. I took the liberty of testing your code with the numbers 1 through 10,000 in D3:D10003, 5000 random numbers between 1 and 10000 in column A, and 3000 of the same in column B. Your code took about a minute and a half to execute (in my resource starved VM). The code below took 10 seconds: 

The first thing you should realize is that in Haskell, typeclasses are basically the same thing as Java's interfaces. They define a contract of behaviour which instances of the class must obey. In this case, the typeclass I'm calling promises the user three methods: 

I'm late to the party here, but I thought it'd be interesting to consider some more optimisation you could do. First let's consider the number of 'modulo operations' your code does per 15 integers: 

Alright, this is the first time I've used Typeclasses so someone feel free to slap me with a tuna if I mess something up. First of all, I don't understand why the use of "FlexibleInstances" is necessary, and it scares me because these kinds of warnings are usually put in place for a reason. With that out of the way, I'll go through the code. 

These correspond to three questions which we could ask of any proposition which is a function of any number of propositional atoms. In case you're unfamiliar with this terminology, an 'atom' is one of the inputs to a proposition which is a function taking some number of atoms and itself evaluating to either or . Typeclass Declaration The name for the type class bears no meaning for me, so I changed it to short for "Proposition". 

Don't reuse to be the index of the loop. It's confusing. It violates the meaning of start. The lengthy parameter parsing is good, but can be made more clear. Don't waste time on checking for or . Just use the statement. 

You still have the calculations. You're just giving them names and keeping them separate. Giving them separate names makes them more reusable, easier to test and easier to find. The most important thing here is to avoid creating a (nearly) useless class who's only job is to contain a bunch of functions. Your code uses no instance variables and simply uses another function that happens to be in the class. Both of these could be method functions. There's no reason -- in Python -- to create a class unless you have instance variables and a change in state of some kind. [In Java, you must often create "all-static" classes because there's no other place to put stateless math like this.] You can simply put these functions into a simple module and avoid the class definitions. 

Alright, so is valid if and only if it evaluates to for both arguments! That's what we want. Now for : 

It says that a boolean function of one boolean is valid if and only if and are both valid. Of course, the validity of boolean is just that boolean. So in this case, can be thought of as being a bit simpler: 

to check if the proposition is logically valid (true for all possible inputs) to check if the proposition is false for all possible inputs. to check if two propositions of the same number of arguments have an identical truth value given the same inputs. 

Not that you need these grade messages, but that's an example of the power of holding on to the type rather than converting the grade directly into a . Sorry if I've made syntax errors as I've not used Java in a while. Edit: Just realised that you might like to put , and into the itself as static methods. 

If you get more than one cell in the , it will never return , because will be a containing an array of (empty) 's: 

Second, enumerations should only have one member for each distinct value. The only real point to using them in VBA is to make your code more readable (there's no strict type enforcement), and it isn't immediately clear when you see something like this... 

3 - returns a , which is an . When you make tests of the return value, you are implicitly cast it to a , then comparing it to an (), which implicitly casts it back to an : 

Don't become an casualty. Determine what your business rule is for an "empty" cell, and test that instead. In your case, it would probably be . 

Fourth, IMHO the statement delimiter is if not pure evil, mostly evil. It's much more natural to read code with the statements arranged vertically than it is if statements are arranged horizontally. This is much easier to process at a glance: 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

Do not use a database for this. Use files. A single file with one tweet per line showing User Name, Tweet Text and whatever other information you have. You need to sort the file by user. Use the OS-level program, don't write your own. Once the tweets are sorted by user, you simply read and count. 

It extends an existing partition on the low end or high end. The number is adjacent to exactly one range. It creates a new partition. The number is not adjacent to any range. It "bridges" two adjacent partitions, combining them into one. The number is adjacent to two ranges. 

This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way.