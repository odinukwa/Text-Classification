That's not necessary by the way, you could have defined a function inside of , check whether the "local" key is and then start over: 

The code snippets in the comments also get tested by , but we can also add some more tests to check that our functions work, for example: 

Those names don't have any meaning. What is ? What is ? Naming is hard, but it's important. You're going to use them as numerator and denominator, or as dividend and divisor, so call them appropriately: 

Prefer pattern matches instead of boolean guards In , you check whether the list is . That still enables us to accide 

All those small improvements were reported by . Use if you know how many elements you will have For your main algorithm, you should use if you know the number of characters you want to store: 

Then, we use that function to get those three lines, calculate the area and the volume, and then print both values: 

That's probably not what you intended. Use instead here. Furthermore, all your functions are fixed to , but one can implement all functions from for any number type. The following interface encapsulates that: 

will generate a single vector due to fusion, not three intermediates. Depending on the used version and optimization level, you might even end up with a single loop and no generated vector at all. So immutability doesn't prevent optimizations. Quick Sort on the other hand really needs mutability. So a variant ( or ) is more appropriate. Interface Now that we know that it's fine to use an variant, let's have a look at your code. First we look at 's type: 

Compare the following two lines. Both do the same, but which one would you rather see if you need to change your code drunk in three months, with only 5% battery left? 

to ease the use of those, but that's an overkill here. Speaking of overkills, did you notice the above? Many of your functions use . But what do those 's mean? Which one is the value? Which one is the bitsize? And is as bitsize really a good idea? Therefore, try to add some documentation at the type level, even if it isn't a new type: 

Any veteran will tell you that the first version is more readable. They will understand the latter, but after all, both versions do exactly the same. 

Note that we use a as pattern, not a . works with both, but this variant shows our intend to match only a single character. Ownership It's not necessary to take ownership of the given in . 

Somewhat, because the error messages lead to long lines and doesn't like that. However, keep in mind that while is great for developers, it's a system that should be used for unrecoverable errors, bugs that you cannot handle or anticipate. When you , you generate an error message that's helpful for programmers, but not for users: 

Naming isn't true to its name. It just returns the first prime number in the given list or otherwise. So might be more apt. Efficency At the moment, you check \$ n \$ candidates in . But that's not necessary. First of all, if we found a divisor , then we also found a second divisor, . We also only need to check up to \$ \sqrt{n}\$: 

You can hide your original function as a closure in there, but I'm not sure whether that counts as best practice. 

Your implementation is fine. But it is a little bit ironic: In your SO answer, you start of with "you can use better functions", yet you rewrite via . If this was a real module, you would probably want to export both functions and , and implement the former via the latter: 

Another variant of Let us start with the finished product first, and then I will show you how to get there: 

While your program only uses a single large , where it doesn't seem to matter, it's tremendously helpful if your program consists of multiple functions. for example, you could have split your functionality into several, reusable functions: 

A character goes in, a character from the key goes in, we use the function to shift and create the result, and then we continue on our other words and keys. Here's at once: 

Your code is fine, except for the stray method. at that point isn't valid, and you will try to connect to a server called . Just try your call with , you will notice two connections: 

That's because the parameter in your is a phantom. Therefore, we can even use from to change vectors into arbitrary other ones: 

Before we have a look at the profile, we already see that something is amiss. For twice the maximum, your code takes almost 7 times the time: 0.375s for numbers up to 1000, and 2.297 seconds for 2000. That indicates that your algorithm doesn't have the right complexity to begin with. Let's check 4000: 

I'll add an exercise for you at the end of this review. But let's have a look at your code. A review of your code You're not using , which is a great plus. However, you include , which isn't necessary here. You don't use any of the standard exception, instead, you throw . However, is in . You should include that one instead. Next, naming. 

Which, in my opinion, is rather readable. Note that your wasn't necessary. After all, we're going to overwrite the values in with the next input. 

Use if you want a namespace You use your only as a way to have and not in the global namespace (and inlined). That's not necessary. We can just use a : 

And last but not least, I would use the same promises as the usual C#/F# functions: either throw an exception when the value has not been found, or return an . That way, if we got an , it's valid, so we don't have to check for an invalid position. I've choosed : 

Now, let's have a look at your functions. isn't optimal because it traverses twice. However the result of is as long as the shorter of the two lists. We can therefore simply write 

Don't use . It's considered bad practice. Consistency Use a consistent coding style. You use and , and and . first, last This is a matter of personal preference, but you are usually more interested in how you can access your class. That's why the section is usually put first, and the section is usually put last. Minimize IO in your functions Your needs user input for setup. But that's hard to test. Instead, try to provide an interface that's easy to use: 

Now we remember that a while loop will not even get entered once, if the condition doesn't hold. So we can get rid of the and we end up with simply 

Use pattern matching to your advantage You can match on multiple elements in a list at once. That way, you can write without a helper that skips: 

There are more tests one can come up with, but those are left as an exercise. User friendly interface You use quite a lot. However, that leaves a user with unhelpful error messages: 

Don't. Repeat. Yourself. That's an essential principle. You repeat the "do you want XY" cycle over and over manually. That's not only error prone, but also hard to maintain. For example, let's say you want to ask the customer how many items they want. Then you would have to add or change your input handling for every single item. Maybe you want to use 

That's not going to end well. Your minimal interface should include a method. You can add , but that's not necessary. Also, you have to think about the empty queue a little bit more. Returning isn't possible if I have a queue of . Indeed, won't even compile if I use a . From my point of view, on the empty list should throw an exception or return nothing. That's how it is specified in . There removes the front (if it exists), and you access the actual front with . After those two comments, we end up with the following : 

Just for completeness, have a look at the inclusion-exclusion principle, and try to solve Euler1 in Haskell (or another language). 

and we really want to keep the number of low. Luckily, unless you want to allow for some , there is no need to use a layer of indirection. Just use 

in my own old Snake game, but I'm not sure whether that's best practices, to be honest. My old Snake game used a single-linked list, too, by the way. Overall Your code mostly suffers by missing consistency and global variables, but apart from that, it's just the length of the individual functions that tarnish the overall experience. But that's just nitpicking. Keep in mind that you've just completet your very own Snake game. Well done. But keep on pushing and eating those fruits. Good luck! 

If we have a close look at this code, we'll notice that the very same lines for , and so on follow later in your code in , and so on. That's repeated work, and if you ever find an error in , you also have to fix it in . Instead, use the already defined functions: 

If you want to use the method, you would have to write , but to just get information, you use (which is the default when you don't transfer any data). Also, you should specify the protocol: