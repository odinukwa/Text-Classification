If your application runs on one instance, your repository would be okay. But since it puts all database entities in cache (your collection) and never returns to the database unless you specify it, you have a problem. Example : Client A (On an X machine) loads the database in cache, Client B (on a Y machine) does the same then adds a to the repository. Client A calls , what should be the expected output? Client A wouldn't have the new . And if Client B calls the new State was never persisted, so it is lost. I don't think you should use the , each of your call should go to the database, so you are sure you have the latest version of your data. If you remove it, I don't think you need to handle thread safety anymore. 

I'm starting a project in which I'll generate random graphs and use algorithms to solve them. The first necessary step is obviously to build a graph. My graph has the following characteristics : 

The advantages of using such a solution is that you don't need to write down every property in a , which could lead to errors (if you forgot one or wrote one incorrectly). Also, you don't need to use since the target of your attribute is the instance itself. I'll review your current code too, because there is three points that I see could be "better" :) By convention, attributes should end with the suffix (which I changed already in my example). You won't need to write when you use it (as shown in my example, which compiles!). Also, your brackets are following the Java standard, not the C# one. You should put opening brackets on a new line. Finally, instead of doing this : 

Now, let's get real. isn't an efficient method. It's very slow. I don't have your class, which is sad because it'd be helpful at the moment. The question is, what defines the identity of a ? If the identity if defined by and (meaning that if two services have the same ID and service date, they must be the same ), you could override the and methods of the class. Then, you could use an data structure inside your class (Instead of ) to use the method, which is far faster. Since this is all hypothetical, I don't want to go in too much details. If this sounds unclear to you, I recommend reading on data structures. Each structure has pros and cons when it comes to its data. For example, the is very fast to see if it already contains an object. This is all I can do with the information that you provided. 

A unit test is split in 3 steps. Arrange-Act-Assert. Usually, to make it clear what is being tested, you write as a comment in which step you're at. 

In Java, the convention wants that methods are written in camelCase. Which means should be and so on. The indentation is a little off with the declaration of the . Instead of this : 

When I finish writing code, I usually ask myself : "Okay, do I think I'd be able to understand my code in six months?" If the answer is no, it means I'm not done. My code needs to be clearer. I 100% think I wouldn't understand your code in six months as I don't get it now. Naming Crudely put, the variable names are terrible. What does mean? Why is 19, 11, 21, etc there? As I said above, I don't understand your code so I can't propose better names, but you should name your variables accordingly to what they do and use variables for all those "magic numbers". "Six months in the future" yourself might thank you if there's a bug in the code. I'd also rename the method to . 

This answer is based on what @Matt said. I thought the idea was very good and it could be pushed a step further. Using @Matt's idea, your code wouldn't contain nested , but you still chain . Of course you could use a , but you still have the same problem. Lots of code in the same method, and we don't like crowded methods. The solution? (Well.. my solution) A dictionary! Now, I don't know what your doing inside your ifs, which is sad, because I can't help you much further. But it would look like this : 

I got 2 comments, so this'll be a small answer. You have a potential . All your methods receiving a don't check for null! So either you should return 0, or you should throw an . (You could argue this might not happen a lot since you're using extension methods, but compiles very well ;)) Second, your unit tests should be self explanatory. I think the code within the tests is good, very explicit. But the names of your test shouldn't be specific to the unit tested, but to what is tested within the unit. From a book I read (sorry, I don't have the reference :p You can decide whether or not you like this idea) this is a good way to write tests : 

With the idea of gathering the biggest hockey's individual stats dataset ever, I've started with the big league, the NHL. Using Selenium, I've been able to scrape this NHL's statistics page. To explain the workflow simply, I extract the data from the standing's table. It's basically a big string with a lots of to split the data. Then I "click" on the next button, redo, until the whole list is passed. Afterwards I change the NHL season with the URL and redo the steps above. Everything works fine, but I have some concerns about readability/maintainability. 

First of all, the variables aren't named properly. and aren't intuitive at all. Don't hesitate to write longer variable names, it will be very helpful if you ever want to understand your code easily in the future. Same goes for your method name, isn't clear enough. Your method removes all occurence of a in another . So you might want to consider or something like that as a method name. Next, as @200_success pointed out, your code has flaws. Whenever you see that you wrote 2 (or more in this case) loops with the almost same code, you should wonder if there's another way you could do it. I'm not sure my method is the most efficient, but I think it can lead you to a good path. 

Maybe you wonder "Yeah but I'm not dumb enough to change that value by myself". You're probably right, but if someone else was to get in your code. Let's say you win a million dollars and quit your job, the next guy might not have the same wisdom as you and he'll break everything. Your method and properties should be PascalCased and you should always check your parameters for in your public methods. You don't want a to be thrown at a weird moment that you won't be able to debug properly. Now. All this : 

Instead of filtering through your array 3 times, you could use a single loop and increment counters. This makes for less beautiful code but it is much more practical. Otherwise, you could simply filter twice and calculate the last by substracting the two filter results from your total count : 

I have absolutely no explanation to this, but I have a guts feeling it'd be better if you threw the exception outside the statement. A should do as little as possible, so I think you should throw outside the . I'm no threading expert, ok? But this also feels wrong : 

I've created a wrapper for the SimpleCrypt library that allows to easily encrypt/decrypt a string. The application is used this : 

You're using for nothing, since is defined by the . The value will always either be a or . So just checking for would be good. These are all readability issues. I really think your code is more readable this way : 

I ran benchmarks of this class versus an "assignator" that uses reflection and mine quickly becomes much faster, which is good. But for sure, if something could be made faster, that'd be great. 

It's clean, and looks a lot like your previous class, but notice there is no base class between the and this and it didn't create much more code (We use the variable which might have been used in another subclass, or not!) Now, you'll have multiple sub classes of . Wouldn't it be great to have one entry door where we could give a configuration and get the corresponding problem? Oh yeah, that would be neat. That's where the Abstract Factory comes in! Consider it a wrapper class around all your "sub" factories. What's cool about it is that it can implement the same existing interface! 

Validate the command If invalid, return the view with the errors If valid, handle the command If command handler can't handle, throw exception (Which should be very rare considering you just validated it) If invalid, catch exception and return view with the errors It works, great! 

First of all, you really need to space that code, it is hard to read when there's no space. Also, because of the block, the indentation is messing with my eyes. Try to keep it in one line, it would be easier to read, even if it is a little long line. Appending strings together is never a good idea, it is heavy in terms of performance. You should use a StringBuilder. In fact, why do you keep the string? It doesn't seem to be used anywhere. You should remove this line as it might be expensive on large files. Also, I don't think you should catch the . How do I know what happened if is returned. Was it the file that was locked, non-existant, was there no in the script? Let the exception be, so people can catch it and do whatever they want with it. Catching it now seems irrelevant to me. 

You handled a case that your scenario didn't ask you to support. Usually, this is something you want to avoid. Stick to the requirements! If your , you decided to add that element at the end of the list. But is this really the wanted behavior? You should consider throwing an exception instead. Think about it : 

I stripped the comments because they aren't clear. You should explain why you do the recursive check with the instead or stating you do a recursive call. We can see that by ourselves! :) Finally, does implies you could have whitespaced IDs in your database??!?!? If so you have so many problems bigger than.. every other problems you might have. That'd be the biggest problem ever. PS : I already wrote a comment on your question, but you should return instead of ! Warning!! (lol) The following is rated M for mature isn't about code review but about OP's question which is where this code should belong. I realize there was a question hidden under all that text :p You're wondering where to place this method. Let's see our options : 

Talking about success (eh eh), what does it mean. What succeeded? Your boolean answers the question "Is the user input valid?" so I think it should be named . Also, you have a problem. You assign (now ) twice in a row, but never use the first assignation meaning that if your input wasn't a valid integer, your application will process as if the user had input the number 0, which isn't good. What you wanted to do was probably more : 

If I understood properly, is used to verify that an answer is valid. So would be much more appropriate. 

You could capitalize only at the end of your method, assuming that it'll always be the first char that'd capitalized. Then, you could use string interpolation for more readability. You have 2 variables that start with a capital letter, that's not good according to naming conventions. Your check about the reference can be simplified alot using operator since can be casted to if . 

Could be changed to : And while we're there, I know many people in this community values the use of brackets every time it is possible, as in this case. It might prevent a bug someday, but yeah, I think it bloats the code. Now that's your call to make :) I don't know if performance is important in that piece of code (I'd guess it is), but that : 

We need to check the condition before incrementing the in order not to have a separator at the end of the code. Also, note that I used the keyword as @Abbas proposed, it is a great keyword to use when it is easy to guess what is the type! This last step might not be a good idea, but I decided I was gonna share it with you anyway. You do not need the 2 arrays, thanks to the ASCII table. As you might know, . Now, as I wrote before, using hardcoded values in the code isn't good, and I'm pretty sure you don't want to introduce constants like : 

The main problem with your code is that it's very hard to understand. First of all, I'd expect to return . After all, the smallest multiple of 10 is 10, right? That's how your code reads, when it's not really what you want to do. Maybe your signature should look something more like this : 

Now, let's get funky. I don't know if this'll suit you, but you could make a kind of dictionary to match your conditions with the corresponding text. Which gives us something like that : 

This is pretty simple, we'll get the first that has at least one validation error. And then we get that error. It might not be the most performing algorithm, but it is at least equal to what you're doing at the moment, and that's not bad at all. What's the next step? We'll remove those statements. How? Using a ! You have a binding between some property names and some other values, that seems like a perfect fit for the dictionary. Note : I'm not entirely sure is the good class for the value of the dictionary, but it depends on what's done in the method, which I don't see at the moment. It would look like this : 

You should init your with the length of your . This way, you'd be sure never to hit the . Also, it seems to be on purpose but you don't support other characters in your string? I'd expect to return . This line : is maybe a little hard to understand at first glance. I'd suggest creating a variable for . It wouldn't change much but it'd give you an opportunity to have a more meaningful name. From experience, I'd say that code that parses strings is never elegant and even though it's a generally accepted fact that are ugly, they are most necessary and I think you should keep it this way. Two slight nitpicks : 

Compared to the , is mutable. Meaning you don't really need to multiple times, you could just replace the characters from the original : 

You can then reuse this constant everywhere in your code without fear of breaking something if it happened to change. This : should be extracted from a configuration file (Like the ). What if you had to change the port or the host of your application? You'd need to recompile your application. This isn't good. It might be a mistake when you copied your code here, but your indentation is off : 

I believe you understand the problem, there is no relation between your and . You should have a constructor for your class that would only take and as parameters and you should calculate the . You could use a that could give you values for faces (Apologies if I miss something important, I know nothing about BlackJack). In this example I initialize the dictionary in the static constructor, which is called only once. 

There's also a small problem with your code. When asked if I want to play again, if I enter an invalid command, I'd just restart the game.