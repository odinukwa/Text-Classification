I'm tryng to set up a new Slave DB by copying another Slave DB. Normally I would simply use to dump the Slave and create a file, then import that into the new database. However, as our new server is a Linux (Debian 7) server (the slave I'm copying is on a Windows server), I figured I would try to pipe the dump straight into the new database. This seemed to go well, until my putty session expired and it all stopped. I tried it again, this time using . But still the dump stopped as soon as my session expired. Is there a way to make this work? My full dump command is: 

But from what I can tell, max_binlog_cache_size is and the maximum for a BIGINT is so it should fit, right? But it gets stranger. 

But as far as I can see the 'referenced table' is The 'referenced column' is , and is the so automatically has a index, right? I checked the documentation, and as far as I can see I meet all the criteria: 

This statement updates 1000 rows. However on the slave I have removed one, so replication breaks and I get: 

This may be a daft question, but on the MySQL release notes, a lot of them are followed by BUG Reference numbers. But most of these BUGS don't exist when you search for them at bugs.mysql.com. example: Bug #13651665 Despite my best efforts I can't find out where to find these BUGS. Can anyone point me at the right location? 

Have I missed Something here? I am installing the Percona Audit Log Plugin (MySQL 5.5). I can install it fine using: 

In other words, get the value for all entries per minute for the past hour. However, in some cases I don't have an entry for some minutes, but I still need to know that there were 0 results for that minute. Is there a way of achieving this in MySQL? so I might get something like: 

Could you move the admin field to a separate table which just holds the current admin id (or list of), and then you could update that with the trigger. (of course if your admin is always id:1000, then you probably don't need the trigger to start with) You would also need to consider whether to fire this AFTER INSERT and/or UPDATE. An example trigger would be: 

There is no sign of it. If I run then there is an entry for it. But If I run then it tells me it doesn't exist. I know the file is there, because there are two databases on this server running under and it installed fine under the other one. The server is 5.5.54, the server is Debian 8 (jessie). Is there anything else I can do? Can I simply delete it from the table without causing problems? Restarting the server isn't feasible as it is my master database. 

I checked the Slave databases, and it was on present on there as you'd expect. I have a monitoring system which records (amongst other things) the processlist, and it shows that for that query it was perpetually stuck at . I also checked the to see if it was in there, and it wasn't. My understanding was that a query couldn't be written to the until it was on the master, so can anyone explain what has happenned here? There was a knock on affect in that once out test system tried to connect at 8:38 this morning, the first query also got stuck, and then it refused all connetions. So I was forced to restart the database. At which point it ran crash recovery, and carried on as if nothing had happenned. It is MySQL 5.5.47 and using Statement Based Replication. 

On your Slave issue the , commands to stop / start replication on Demand. If you want to run it to a schedule write a batch file / cron to and at the required times. I'm assuming you have a good reason for doing this? 

But if something happens, and the doesn't run (and the session remains open), that row will, in essence, be locked from any further updates. Hence the reason I presumed the timeout was there? 

I've been looking to experiment with Perconas Audit Plugin, as it sounds like it could be potentially very useful. However it appears that it is a very blunt (ALL or NOTHING) tool. From my perspective, I am simply interested in DDL statements (, , etc). Is there an way to limit what it logs, or is it really just ALL or NOTHING. I fear I already know the answer, as I can't see any mention in the documentation. 

This may seem a bit strange, but I am trying to get a to execute on both Master and Slave. I have two databases set up in a Master (A) to Master (B) replication environment. Master A is Master B is I create a user on both Databases: 

They all use the same table. The s are identical queries, and have a couple of joins to little used tables. The is a simple with no joins. THE is a simple . The top one () should have started about 48 hours earlier. The about two minutes before the . I can understand why the would block the , but can't see why the would block the . And if it really had been running that long, it should have blocked previous (we about 250 times a minute on average). So I'm just trying to figure out what had happenned. 

Most likely problem: there is an error in the relay log. Usually this is the result of a sudden database shutdown (e.g. server crashed). The fix for this is to simply tell the database to discard the current relay logs, and start again. To do this: 

I have also tried stopping at (the equivalent of) pos 104627, 104628, 104629 (e.g around the previous ). But each time, replication continues until the start of the next relay_log, when it stops. Am I missing something? 

I've tried every possible combination of I can think of, but it still doesn't work. What have I missed please? 

High Availability (HA) is a very generic term that can be applied to a whole range of different scenarios. There is no “one size fits all” approach to delivering High Availability (HA). Unique application attributes, business requirements, operational capabilities and legacy infrastructure can all influence HA technology selection. And technology is only one element in delivering HA: people and processes are just as critical as the technology itself. At it's most basic it simply means ensuring your entire system (of which the database is a part) is available to meet your required SLA, whether that be 99% availability, or 99.999% availability, or somehing else. The above link gives the official definition from MySQL. Your use of a Slave database is one of many good reasons for using a MySQL slave. And at it's most basic level, if your master fails, the slave could be manually promoted to be the master. Then you would set up the Master as the new slave once it had been recovered. The below slide presentation gives a good overview of the main MySQL HA offerings. MySQL HA Solutions 

Do you use statement based or row based logging? If it is statement based then you most likely have set in your replication filters e.g. so that only queries where the database is are written to your binary log. e.g. 

is a global variable that is set at runtime. It determines if binary logging should take place, and (if set) the basename of the binary logs. It cannot be changed without restarting the database. $URL$ is a global OR session variable that can be set after the server is running. It's main use is as a SESSION variable to prevent statements from the current session being written to the binary log. Use as a GLOBAL variable is not recomended. $URL$ 

If I understand correctly: You have two DB's in a Master <-> Master setup, but one of them has the replicate-do-db rules meaning they are now (potentially) out of sync? At present the DB with the replicate-do-db options is only replicating (processing) statements where the database concerned is in the list (the precise rules vary depending on whether you are using Statement Based or Row Based Replication). $URL$ Unfortunately the option has only just been introduced in MySQL 5.7, prior to that you will need to find the set of entries in the my.cnf file for your database with the statements. You will need to remove / hash (#) these out, and then restart MySQL. After that the DB will replicate all statements that are passed across from the other master. The final thing you will probably want to do is run something like to check the consistency of the two DB's. If needs be you may need to dump/recreate the second DB to make it consistent with the first one. 

I am testing out MySQL Delayed Replication. But it's not working. I have a Master DB (5.5) and a Slave DB (5.6) both set up as a normal master/slave setup with statement based replication. On the Slave I then do: 

Am I missing something here. I'm looking at using to allow two applications to co-ordinate which data to wok on. From reading the manual it suggests that I need to apply a timeout to the command. e.g. 

I checked the permissions are the same as all the other files in that directory. Does anyone know if I need a different version for MySQL 5.5.47, I assumed the Percona versions matched the MySQL versions, or any ideas on it why it wont install? 

1) Any , , etc type Query executed on the Master will be written to the Binary log, causing the to increase Furthermore, if the Master is receiving updates from another Master (in a Master to Master setup), AND if you have enabled these will be written to the Binary Log as well. Each time you restart the service, the Binary Log will be flushed, incrementing it by 1. 2) On the Slave, Run , and make a note of the . Now check, does this file exist on the Master still? If it doesn't then you have a problem, and will need to rebuild the slave from a copy of the master (e.g. MYSQLDUMP) Assuming it does exist you should be able to just issue a command, and it will start catching up (hopefully) Next run again and check the and . Are they both then all is good. Look for the to give you an idea of how far behind it is. If either of them is look at the Error ( or ) to get an idea of what the problem is.