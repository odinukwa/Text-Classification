One way to write a client which uses a specific protocol, eg http like in this case, is to create a base class with the basic socket handling functionality with virtual functions which can be overridden with an inheriting derived class. But it is more flexible I think to be able to get the socket handling class to call a function specified by the client. Hence, the tcpclient constructor takes three arguments which are calling client callback functions to handle the asynchronous connect, data received and exception events. But the callback functions are straight functions. It would probably be more flexible to allow member functions to be called somehow. I wasn't sure how to do that. Anyway, I would appreciate any comments on the code. tcpclient.hpp : 

I am preferring to remove all the printing stuff from the class interface and use the operator<< overloading idea in 200_success answer like this: 

Is that the standard way to do function pointers to member functions in C++? Any comment on that would be interesting. I guess it could look a bit daunting to someone not familiar to std::function. I won't change the code in the review at this late stage. 

Please review my ini file parser (and potentially some general config file formats). The data structure used is a section, see below. Does that seem a good approach? I was wondering about the name. It will parse ini files ok, but unix config files are so variable that calling the class config might be over selling it a bit. I don't support mid-line comments. Only comments on a line on their own are well just ignored. All values are stored as strings. I thought that only the user of the config file will know if a value should be used in his or her application as a string or integer or whatever and onus is on user to convert. Any comments would be much appreciated. Its intended initial use is for Windows ini files. Parsing the configuration into sections. config.hpp 

I need to create a protocol for sending data of various types over a socket connection. so I need to serialise the data to a byte stream. I only need signed and unsigned 32 bit integers, 64 bit integers, string and binary. It is only a start but if anyone can code review this I would really appreciate it. 

Question 1: functionxxx_as_string() is used below. How else could it be more elegantly named? Question 2: Is the static char* array method adopted below the only solution? Best solution? Any suggestions? Generally, I have this issue where my list of enums will be from 3 - say 50 items, mostly less than 20 items and they are fairly static. 

Here is what I came up with after applying the above. [Also available as a git clone-able gist with changes made a few at a time so you can see some intermediate alternatives.] 

since the rename is redundant. As already mentioned, it's more common to be a bit more explicit with error handling in Go and let utility functions (such as your ) return any errors for handling "higher up". In addition to Effective Go, I suggest looking at the Go project's Code Review Comments page. Although the later is only what the Go Authors use and isn't necessarily more widely applicable, I find it a good starting point. Among other things, with respect to naming it suggests (again as previously mentioned) using , , , etc instead of what you use. Also, while on the subject of naming, I personally subscribe to Russ Cox's naming philosophy which suggests vs , versus , and vs for identifiers used within a short span (as opposed to file or project wide identifiers). When it comes to marshalling to/from JSON, use of struct tags allows you to not only map Go style names to JSON style names but also apply other attributes (notable things like "omitempty": ). In particular, without this if you tried to marshal your stucture back into JSON I believe you'd end up with your JSON fields capitalized (as Go's package can only deal with exported fields). The code review comments page also recommends applying caution/restraint to the use of named result parameters. They can be useful for documentation via but I try and avoid them just to save a variable initialization line in the body. Your tastes may vary, but if you use them be careful of shadowing the named returns (e.g. with a named and inside an if/for having something like ). Instead of using something like to pre-read all the data I find it useful to look for "streaming" based alternatives. For programs that process large data inputs (e.g. reading from a large file) piece by piece this can make a big difference. Here, provides a type for this purpose. In this specific case I don't know if it makes any memory/performance difference but I find the result of using it (and combining your send and parse functions) seems to simplify the code. Back to marshalling, it can sometimes be helpful/useful to create your own thin wrapper types with custom (un)marshalling rather than limiting yourself to basic types. For example, in the code below I've added a type that unmarshals from the way StackExchange API is documented to do all time/dates. You could easily add a method if marshalling was also required. The difference isn't that important here, but for example, it allows easier use of all the methods/functions (e.g. , changing the output timezone, etc. In several places you do things like: