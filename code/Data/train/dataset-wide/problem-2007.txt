Is there some sort of configuration that needs to happen to track failed events or I do something wrong? 

I've got setup extended events that tracks all failed queries by specific users. We have identical SQL Trace running side by side and expect things to work identically, however XE sessions seems not to capture failed RPC statements that are deadlocking or are calling functions. 

And when that fails, I expect to capture XE event of with (failure) but it comes with My procedures look like that: 

Ideally I'd like to use Data Flow task in SSIS, but looking at performance comparison, it looks like Linked Server wins. I'm doing it that way: In SSIS I do the following 

So the final step is pretty much to transfer whole table data from Source into Destination and I've got two options now: 

That's the execution plan I've captured: $URL$ Normally I'd know where to start, but not this time as I've got no clue how to tune these kind of queries, so I'm asking to help. 

Is it possible to configure SQL Server user so that he doesn't have access to DDL statements but has access to run commands. I know that behind the scenes it's a DDL. I wasn't able to find this on search engines. 

None of the above. If the 5 new subscriptions are initialized with a snapshot then by default all subscription database objects will be dropped and recreated from the snapshot bcp files. So the data from the week offline will appear to be deleted. 

You may want to look into Publishing Stored Procedure Execution in Transactional Replication which can provide significantly better performance for large batch operations since only the procedure execution is replicated, bypassing the operation being sent to Subscribers as a large, multi-step transaction. If you have anymore questions please let me know. I hope this helps. 

Adding tables (or articles) involves adding the article to the publication, generating a new snapshot, and synchronizing the subscription(s) to apply the schema and data for the newly added article. See Add Articles to and Drop Articles from Existing Publications 

You have probably read that you are able to deliver the initial snapshot via FTP. This is covered in Deliver a Snapshot through FTP. It is possible to replicate two SQL Servers across a VPN. This is covered in Publish Data over the Internet Using VPN. Once the VPN is setup, you should be able to connect and authenticate as though the servers are on a LAN or WAN. If you have anymore questions please let me know. I hope this helps. 

I have 2 replicas running SQL Server 2016 Enterprise Edition in an AlwaysOn Availability Group. One replica is primary and other replica is secondary and readable. I have a business requirement that should allow one database replica to be taken offline and back online after a period of a few minutes by a custom developed APM monitor. The database replica to be taken offline can be primary or secondary. The database replica has to be take offline and online via transact SQL When the database replica is offline it should not be possible for it to execute requests. All existing connections must be moved to the other database replica or fail, so that the client can reconnect using the IP listener to the other replica. I can do a suspend or a planned manual failover but neither seems to support what I need. The suspend & manual failover only works on secondary database replicas. The suspend allows existing connections to execute requests. The manual failover just switches the primary to secondary role and vice versa. How do I do this ? 

We are running sql server 2016 enterprise edition. We have a linked server configured to db2. We do a distributed transaction between mssql 2016 and db2 using MS DTC. SQL Server controls the distributed transaction. Application is running in Java using JDBC. We are using MS JDBC driver. Java does nothing in terms of distributed transaction. From Java's perspective, it is only a local transaction with MSSQL. Everything works fine and has been running 2+ years. Transactions are started and committed, or rolled back on error on both mssql and db2 However we now experience a weird problem. If we run into a duplicate key (or any other error from an SQL statement), an error is thrown in the form of a SQLException (java exception). When this occurs, it seems the transaction in progress is paused and a new transaction is started. The new transaction commits, however everything that happened before in the paused transaction does not commit (nor rollback). It just hangs. When this happens enough times, the tables lock, and we can neither read nor write from them. There is nothing done in the application that will start a new transaction at exception. The reason for why we have not had this issue in 2+ years is because this is the first time we expect an error to happen (duplicate key) and we therefore do some logic and continue. Previously we would always rollback immediately on exception. I'm not sure how to troubleshoot this. Is this a documented behavior ? Where can I see the "transaction id" so I can confirm the above ? How do I proceed ? --- Update --- xact_abort is on and therefore the duplicate key error rollsback the transaction (but the rollback is not complete, somehow the transaction is left hanging). This explains why the commit works for the work performed after the error. Also this is relevant: $URL$ The question now changes to, how to deal with statements that may throw an error but should not roll back an exception 

It's hard to say exactly but it looks like something went wrong during the reinitialization process. Transactions are flowing from Publisher to Distributor but the Subscriber is requiring a new snapshot. I'd recommend generating a new snapshot and then it will be reapplied by the Distribution Agent. At that point you should be back in sync. 

If you change a user's permissions to a particular table BEFORE a Subscriber has been initialized or reinitialized, if the article property Copy permissions is set to true, the permissions will be copied to the Subscriber when the snapshot is applied. If you change a user's permissions to a particular table AFTER a Subscriber has been initialized, the permissions will not be replicated on the fly, unless you generate a new snapshot and mark the Subscriber for reinitialization. Note that the article property Copy permissions must be set to true. What is typically done is if you need to change a user's permissions to a particular table AFTER a Subscriber has been initialized, and you need the permissions to be present at the Subscriber without reinitializing the Subscriber, the script to grant permissions are posted to the Subscriber using sp_addscriptexec. I have a post detailing sp_addscriptexec located here at Executing scripts with sp_addscriptexec.