I have a query that is selecting some data out of a table. The execution plan shows that an INDEX (FAST FULL SCAN) is used and the cardinality is 22. On the running the query it gives 227,652 rows. I understand that query optimiser relies on row count estimates instead of actually counting rows. So I run a And it gives 910,087. So why is the cardinality estimate in query plan off by such a large margin? Query as request in comments: 

Oracle TDE features comes with various limitations such as not being able to encrypt columns which are used in foreign key constraints. And probably is available only with enterprise edition which costs upwards of 100 thousand dollars. Why would one want to pay and use TDE instead of simply using file system encryption with the OS? This is free and byepasses various limitations regarding FKs etc. Am I missing some advantages that it provides? 

Even though we are using "innodb_file_per_table = 1" from day one. The ibdata file still continues to grow. Total size of our database is around 800GB and the ibdata file is currently around 50GB. All our tables are innodb. How can it grow when we use innodb_file_per_table? Could it be blobs, mediumtext or these kinds of columns? Is there a way to shrink this considering we already use innodb_file_per_table? 

With mysql 5.7 you can consider moving your undo logs to separate files: $URL$ This will also give you the option to truncate those logs when you like: $URL$ In my.cnf this setting should do the trick: 

The error seems to be misleading and I suspect something else is the problem here, because the users table has only some 1000 users or so and the tablespace in question has 2 GB allocated to it, all of it free. Furthermore trying to copy just a single row also gives the same error: 

The requirement to specify a directory object is only there with the new utility. The older tool allows specification of an absolute path. I was able to take a backup using without having any special privileges and without creating any directory objects, just using my username and password. Though succeeded by , is still included in recent versions of Oracle. For example an dump would look like: 

Is there a way to separate memory allocation for databases in mysql on the same server? Say for database_1, we would like to allocate 20GB RAM, and for database_2, 10GB RAM. Is there any way this is possible. 

$URL$ Let's say our database "concurrent insert" parameter is set to "Auto" (1). And we have a MyISAM table with a gap. When we insert new rows and fill those gaps, does the table "immediately" get ready to accept "concurrent inserts" for future insert queries? Or do we need to run "OPTIMIZE" before the table knows there are no gaps? 

Just updated to MySQL 5.5 and this issue is resolved. Tried it with files as large as 10GB and MySQL is not affected at all. 

Given that natural join here is implemented using inner join why the multiple rows? Update: Running same join with table aliases has different output: 

I have a query that has been several minutes in waiting and is not running at all. In the SQL Developer monitor session view it shows that query has been waiting for 667 seconds? 

I'm using following PLSQL loop to delete a large number of records from my table. However it is giving me an error that loop exit condition is not correct. 

I've seen this referred to using different terms: inline views, WITH clause, CTE and derived tables. To me it seems they are different vendor specific syntax for the same thing. Is this a wrong assumption? Are there any technical/performance differences between these? 

If we query for "WHERE receiver_id=5", partition pruning will not kick in, right? It will need to search all partitions. But if we were to search for "WHERE sender_id=5", then we would immediately know the result is in p0. So for a table where two columns could potentially be individually important, partitioning might not be the best solution since now we lost the benefit of a full-table index for the secondary column(receiver_id, for this case) in the columns parameter. Is that right? 

Before setting up a replication within MySQL, the data first needs to be transferred to the slave. Since MyISAM tables can be copied as files. Would it be okay to copy MyISAM files, .myd .myi .frm, to the slave? Would this be enough to start the replication? 

I had to modify Ren√© Nyffenegger's answer to make it more generic and easier to see space usage for all indexes in a schema. Thought I'd share the modified code here, in case anyone else finds it useful: 

So a natural join can be a shorthand way of implementing inner join if both tables have a common column. Consider following table: 

I'm trying to understand the performance characteristics of SQL statement that does DELETE cascade on 4 linked tables. When I do the auto tracing of the statement it only shows me the DELETE statement executed on the table. It does not show details of deletes done on other tables. Why doesn't SQL Developer show cascades in tracing?