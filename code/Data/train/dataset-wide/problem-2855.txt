Your x/y loop can be replaced using The function will do most of the heavy lifting for you in terms of neighbor counting &c 

How to approach this in a game? Well, you have some of it already. The and are fine. I would say that the top few items (resort, mountain, starting point) are a series of text prompts. What you really have is a graph. When the player starts, it is at a central node on the graph. This is the "big decision" that will decide the rest of the decisions: "What resort do you want to visit?" From there, you can change resorts (which is slow and time consuming and expensive, but might be necessary for game play, or might be a "level up" feature- you can only change resorts as you get better). Or you can head for different starting points by taking different ski lifts. Or you could head for a different mountain by taking a van over, then a ski lift. Etc. Finally, you get to a starting point, pick from a small set of runs. You reach a point at the end if your run, pick from a different small set of runs, reach a different point at the end of that run, etc. Eventually, you reach an ending point - the bottom of the hill. You can call it a day, or go back up for more runs! I would reverse this for climbing. There are some places to start, maybe some "trails" that take you to the bottoms of a few routes. When you climb up, you reach a point that you can change routes. Then eventually you reach the top, or some other ending point, etc. Update: So you have a climber traversing this graph of starting/middle/ending points by various routes. So the nodes (points) have various weighted edges (weights = difficulty, cost, etc.) and they all have names. Your climber will need some kind of "current node" or "current location" indicator. Your graph of routes should have a common "node" class, with various "routes" connecting the nodes. 

Usually the logged in user and it's common used information is stored in the session. And the session is usually wrapped in a class (like itself). This is done because you can decouple your code from the session or from the servlet api (or whatever api you're using). It also makes it easier to test. Most of web pages do show your user information when you're logged in, e.g. your avatar on this page on the top. So for every request you do not have to look up the user's information. I'd introduce a class which provides a and method. Beside that: 

First: WTF? (You know, the best measurement of code goodness is WTF's/minute.) Second: Those files shouldn't be in src/data. It's not source code. 

Not writing a test case is a huge part. Because, as a software developer, I say, that test code is as valuable and as important as production code. The other stuff can mean, that you're very inexperienced, never worked with other people on a project, or never did a code review. And you do not know the basics of the SDK. Other tips: 

The keyword is usually a sign of bad inheritance (Liskov's substitution principle) and I do not recommend to use that. Beside that, I do not understand that data structure of your stock information. Why not something like this? 

I really think the 'only select data you need' paradigma is quite out dated. The management of the 'choose what columns' thingy, the 'be careful because its not null in the backend but someone might not have loaded that column' and the inconvenient increase of execution plans on your backend - which has to be managed, too - is in my opinion much more expensive compared to just select all (= upgrade the switch or add another cpu to the backend server) 

Nah, don't do that, it's much harder to understand than if else statements. Also, I only use the ternary operator if it's a plain if-then-else-that statement. Everything more complicated will be like sentence with too many subclauses; plain stupid boolean conditions can still be way too complicated to understand a few lines of code and are a major source of errors. Hope that helps,... 

In this design, your has-a collection of objects (or , or , or whatever) that are created while parsing the input file. The knows the starting tag either because it was the first in the file, or because it was explicitly specified in the file, or because it is a parameter to some method. The knows how to convert a tag into a by some kind of lookup: could be an array, could be a map, could be ... whatever you like. Finally, the knows how to print itself on an output by choosing links and telling the various pages to print themselves. I have suggested the as a constructor parameter, but you could certainly configure it separately, or pass it as a parameter to the method. (I don't recommend this.) The objects hold text, and they hold links to other objects using some kind of type, as mentioned above. They hold text labels to be used when choosing which link to follow. They know how to translate an input choice into a tag, although this may be a coupling flaw (you could refactor in an input-to-page-link translator, but for now a string to tag method seems easy). As a special case, the objects know if they are a valid END page. (If you wish to continue past an optional end, that seems doable without too much hassle.) Finally, the knows how to print its text on an output stream. 

Similarly, don't build a list and return it. Instead, your values when appropriate. And since they aren't indexed in a list, provide a timestamp to go along: 

Your default constructor currently has nothing to do, since you have done a good job using default member initializers in your class declaration. Kudos! I would suggest adding an istream& and ostream& member to the class to use for reading and writing. This would let you write tests using string streams. As mentioned, your function basically says "There is a game board." The constructor is not the place to be implementing game play. Better if you wrote a method or something, so that main could say, "There is a game board(that reads from cin, and writes to cout). Play one game on that board." 

I have some "readability-issues". It usually helps to name your methods with a verb and a noun, so, would be , for instance. and are not named correctly, in my opinion. If I call , I do not know what this method will do with the two parameters, it feels like, the method adds the listener to the consumer. I also have no idea, that the is used for unsubscribing later. If I call , it feels like I pause the listener, and can activate it later. and would have been more clear. Also, since we're talking about publishers and subscribers, I'd recommend to use the terminology of this pattern. , (well, is given by the jdk), , and . Well, it's a bit smart-arse-y, but, since I'm here,... By definition, or at least by the definition I know/remember, one thing the publish/subscribe pattern wants to achieve is, that the subscribers have the ability to subscribe to specific messages types, e.g. : You subscribe to a news feed, but only the sports part. So, I recommend to rework the terminology, because a user of your API can have different expectations of the API. (Yes, I'm one of them :P) 

I'd provided additional methods like in the base class. But since it's a home work assignment doesn't target real world problems, but wants to teach you something, I won't go into more detail. Hope this helps, slowy 

Looks good, except: activateObject/passivateObject method: I don't see any usage of the running variable? Beside that, you don't need to do anything in that method anyway, that will be called, before the object will be returned, I don't think that is needed for a Cipher instance, isn't it? But why I'm actually answering: I'm fairly certain you won't gain any benefit by using a pool for Cipher instances. The management of the pool, the synchronizing, the maintaining of the code and the additional library will use way more ressources. A general rule is, "by definition": More code means less performance. Of course, that's not entirely true - what I want to say: If you want to improve performance, you have to measure, before and after your changes. And not only millis, but also cpu, memory, gc, io and so on. You have to be sure, you're changes actually did make an improvement and not the opposite. Hope that helps,... 

If returns you'll see that the s and s (all s) will be fetched into memory by two queries. Also, the is executed in memory, not translated into SQL. With , the whole statement is translated into SQL, making it far more efficient. (Assuming, of course, that both repos receive the same context instance). Finally There's always much discussion about the use of generic repo/UoW on top of EF's / that implement the same patterns. I wouldn't use them just because it's a "good pattern". In most cases they're only a thin wrapper around the EF objects. Maybe you have to reevaluate this. 

I don't understand why repositories insert, update and delete themselves. For example in the method, you have: 

It's not necessary to set the return string all the time. You can first look for occurrences of with an incrementing parameter of the function. Only after no (new) occurrences are found, or when the required max number of occurrences are found is it time to set the return string: 

All other pieces of code that wrap this part can be deemed redundant. As the ultimate (over) simplification you could even write this code directly in an MVC controller's action method. No added layers involved and the job is done. Useful layers? Anything added on top of this base line should be carefully considered. Additions should be useful, not restrictive. Your proposed architecture is restrictive because it is "vertical". You seem to have a column of abstractions for each entity: , (as ), with subclasses like . Then there is a class, maybe part of a similar column. This architecture has the same drawbacks as Data Access Object: it will lead to multiple isolated queries and repetitive code. Alternatives? This columns-per-entity setup defeats the purpose of an OR mapper like Entity Framework, which is to work with object graphs that map to a relational data model. When you need orders and their related customers you can get them in one LINQ query. Likewise, when you want to save orders and customers, you can add them to the context and do one call to save everything in one transaction. This has made me move to API-oriented architectures. I usually create services that live for the duration of one web request. Each service has a number of methods that execute some business case, like creating orders. For this, the service has one context instance that can pretty freely be used inside the service methods. This works best in combination with dependency injection (or Inversion of Control, IoC), but that's not a prerequisite. This is, very briefly, what it could look like: 

My understanding from a builder is a bit different. In my opinition, the User should not have a dependency to the Builder (you have a bidirectional dependency which is usually bad anyway). With that said, use the User as member variable within your builder: 

The is a plain static Factory which actually creates 's and 's which use 's and 's - pretty straight forward. You can call it overkill. I call it super sexy! :P Hope this helps... 

Change behaviour during runtime Decorators provide a flexible alternative to subclassing for extending functionality. 

It makes perfectly sense to make that not cachable. You want the result based on the actual exchange rate, and this changes every second. What I really don't like: Your interface has a HttpClient and is therefore coupled to implementation. This should be moved to the actualy implementation. The next thing: You're caching is also coupled to the technology. So if the backend changes, let's say you get it from a database, the caching mechanism is not reusable. I think it's okay for your case, and I wouldn't bother too much,... but, if you consider testing, you actually can't unit test the caching. 

Method names should have a verb in it. And about what it does: It initializes agents and reads a csv file. The correct name would be . And if a name has an in it's name, it usually does too much. I should only do one thing. 

I really like the small test methods. But without seeing the actual implementation, it is very hard to tell, if a test case makes sense or does what it should do. Small improvements: 

That's it, isn't it? That's three things, you have to verify for this class. All the other dependencies, well, their implementations, have to be unit tested in separate test cases anyway. Potential improvement would be the , I think this can be decoupled to a separate service. Instead of creating a worklogServiceContext using the worker key, and then call it with the inputParameters, you could wrap and in one method ("Tell, don't ask", $URL$ With that said: You might want to let us review your test code. Hope this helps, slowy