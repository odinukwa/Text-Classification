You can replace by For the rest of the code, it would help if you explain the algorithm you are implementing, or if you name it (if it's a known hash algorithm) 

And then you can use to find the content of the groups. There is still one thing missing : the fact that the numbering of the original pattern is lost. For that, you can parse the original pattern string to extract those numbers, to create a mapping table. When you convert your pattern string into a Pattern, be careful to escape the substrings between the using . I don't know if this solution would be an improvement of yours, but it's an alternative to consider. Edit The implementation of my solution : 

First of all, the Conversation class does not provide any events for chances, so nobody has a chance to get to know if something changes. This is already be implemented within an (Sorted)Observable collection, but unfortunately you publish this private field as by the Message method. So the notification abilities of this collection can not be used. Furthermore methods should always be connected with a action, so would be a more suitable name. But the best way is to make it a property. 

So now some observer might register for changes in Messages (add, delete) and also for changes in the single Message instances. For more info, look at Microsoft documentation: 

Furthermore you can use the second solution without points, if your are using the client profile which does not support unsafe code. You should test the code really hard when using unsafe code hard, because .Net will not help you at run-time. By the way, I heard you can simplify the last example by using loop unrolling capabilities of the compiler. 

Warning : I never played this game, so I might be wrong. Syntactic nitpicking There is quite a bit of syntactic noise, that you can catch by using . For example : 

As lists are linked lists, and indexing will traverse all previous elements. Profiling shows that this is the most time consuming function. I would suggest one or a combination of the following solutions. Using the monad The ST monad is a strict state monad. It is pretty useful for encapsulating value-mutating algorithms in referentially transparent functions. Basically, you would write algorithms the way you would in C, and the resulting code should be quite efficient. The type might be a good candidate. Using a library known for its performance A library such as or , both are known to be able to generate crazy fast code when the right rewrite rules fire. is probably overkill, and hard to understand. You can alter vectors in the monad too. Change your representation The function takes most of the time. It has an implementation for a single case (), and all other cases rotate the board, run a , and rotate it back. It might be possible to either have specialized implementations for each case, or, perhaps better, to use function composition / modification to skip the rotate / rotate back operations. 

@Ocelot20 already give a good start for optimization. You should first implement his/her solution, before consider mine. If you want some more boost, there are more possibilities. There is an article about this topic, but unfortunately in German. The result: 

This system offers you the possibility to exchange the game loop behavior at run-time. So If you decide to implement a game loop that offers statistic information(update count, update time, render count) for debugging purpose, you free to exchange this, without altering your code. The separation into two *behavior interface provide the possibility to implement completely independent strategies, for this two functionality. But if you wish to, one class can implement both interfaces and can make the functionality dependent on each other. So while implementing your engine, you don't define what kind of game loop and update/render behavior is finally used. For example in XNA, you can switch between fixed time steps and variable one. All this is easily possible with the strategy pattern. 

This doesn't help too much here, but might make things more obvious in the long run. Now, considering performance, the choice of a list of integer will make your program hard to optimize. Functions such as this will be really slow : 

I believe the intent here is not properly encoded, as you might modify one of the two lines, and have both branches (or none) executed. I think that the following makes it more obvious : 

It is a lot more complex now :) Here are the main takeaways : An interpreter This is a major technique in Haskell : transform an effectful computation into a pure computation that is then interpreted. You can use the or packages for that. You now have the game logic running in the monad, that can run effectful instructions encoded as the type. Those instructions are then interpreter by the function. You gain several things from that move : 

I think sourcing the game-loop out is basically a good idea to improve separation of concerns. But I would go farther: I would implement a strategy pattern which makes the behavior of the game loop exchangeable. Futhermore I would source out the loop itself, too. 

I totally agree with Guffa, but I want to add some things: I don't like so long methods, because they are really hard to read, especially for other people which might maintain you code in the future. So I would create some private methods with meaningful names. So everything within the try block, I would change to something like this (pseudocode): 

So you have three short instead of one long method. The query text ("") seems to be constant, so I would like to make it a private static constant class variable. Furthermore, don't use any prefix like my, our and so on, as far as they don't have a special meaning in the context they are used for variable names. Simply call them ifxCommand, command or better: deleteCommand and insertCommand. By the way, why don't you use a updateCommand? If the affected rows are 0 after a update, you know you have to insert new stuff. But in most cases you have only one database query, instead of always two.