I made an re-implementation of your elevator simulator. I change the methods elevatorUp and elevatorDown to one unique method, to avoid code repetition and to put off some ifs. 

So it will run both the programs asking by 3 numbers, that will be: 50.000.000, 60.000.000, 70.000.000. I put a time counter in your fillPrimes method to compare it with the time taken by the entire execution of Solution program. If you run this version of DivisorPrint you will get something like: 

This is my code review. I don't read others much of others answers, it's likely they have point almost the same issues. 

What could be improved in this implementation? I think I could eliminate one of this methods: getLastNonWhitePosition, getFirstNonWhitePosition using Java 8 and functional programming, but I cannot do that. 

Please, review my code about any aspects you think is relevant. One question about performance: these object creation whenever user change a property is a risk to performance? I like this way of doing things (creating objects) I think in java this is not so problematic anymore. In Android maybe. thanks in advance 

I bet you copy-pasted it for the second time you wanted to write it. Well, this is good indication you need to factor this out and put it somewhere where other classes can access it. I normally make a Singleton class for a situation like this: 

Then I can call it from anywhere like this . Now I eliminated the duplication. Again, I'm not including Color prefix to any of the names inside the class, because it is pretty obvious that a class called ColorReferences surprising enough, contains references to colors. Another thing which can be a personal style but worth mentioning is that place your methods according to how you call them. Something like this: 

I haven't looked at your implementation, but simply from the title itself I can tell you're doing unnecessary work. Event and Delegate are C# build-in features for Observer pattern. Here is a tutorial: $URL$ 

You could use the CrossFadeAlpha method of the Image component for changing the alpha. It's been design for this purpose. 

This way you can read the code easily. So, I suggest to move your method and put it below method. Also in unity you don't have to make a member variable public to see it in the inspector editor. You can simply put before any variable and it shows up in the inspector. In terms of Inheritance or Composition, use none of them in this case. Don't make your code more complicated than it should be. Your list managers don't have any client, so no need to use any of those polymorphic technique here. You might say, how about code reuse or maintenance. Your code is not big enough to worry about those right now. Always go for simplicity. Sometimes, simplicity means using inheritance and composition, but that's a big topic and there are also many opposite opinions about it. Just a quick side note. Unity3D has a component-based architecture. Try to have that in mind when designing your app architecture. 

Name conventions: you have to pay attention of Java widely used name conventions: Java code conventions 

So... the Solution.java algorithm solve the problem in about 2 milliseconds. Your optimized method alone took 12 seconds in the first iteration. Even if in the subsequent iterations it taken about 0 millisecons if the subsequent inputs are all covered by the numbers in map, it would only tie the game after about 6K iterations! The problem is what this type of optimization don't work very well in this context: in the Solution.java code the programmer has used only primitive types and keep the calculation very simple. That map and lists you've used and the related operations, all the autoboxing and unboxing needed, are to much expensive compared to the use of the purest java. 

your implementation is to much procedural. You do all in the main method. You should put the logic in Elevator class and call it via main method, after instantiating the Elevator object. You should avoid static members, too. your implementation have to much ifs, that let your code bigger and polluted. see anti-if. elevatorUp and elevatorDown methods are almost the same. you should avoid code duplication. See DRY. 

Some extra tips: Never create an object inside loop. I'm referring to this . By doing so, you're allocating memory(on heap) every single frame. This is very bad. Try to minimize the computation by storing its value and reusing it over and over. You could move this part to . But of course, you need to declare as a class member variable, so it can be accessed inside . Try giving more meaningful names. Readability is very important. In this case, as you can see in my code, I changed to , because it delivers the intention more clearly. 

Here is my thoughts: Cut out 'Manager' from the name of all those managers. becomes . The job of an object is to manage its state and behaviour, so you don't need to explicitly say it. The same way when you create a new list, you don't call it ListManager, you simply say List. When you're inside a class like you don't need to mention the class name over and over. becomes , becomes . It's pretty clear who you're referring to, the class itself. The same way when you have a list of integers you don't say . You simply say Let's have a look at this code: 

ps. ListPreference, CheckBoxPreference, PreferenceFragmentCompat and other misses classes are Android SDK stuff. 

I made this password generator I'll use in a simple Android App. I want that it generates a password using a truly random number source, but I don't have idea how to do it by now, so a let a seed parameter to generator class that will be created by that numbers source. I used the decorator pattern to compose the source from which the chars will be picked up. So if I want a password in which the chars will be picked up from a source of numbers and lower case letters I will decorate it with NumericDomainRange and LowercaseDomainRange, but there is no warranty that the password generated will be composed of number and letters. It must calculates the password entropy based on some algorithms, I have not implemented anything yet. Please, review its overall design. root package: 

It's a implementation of Transformation from Picasso library looks for the first different pixel color in both sides, in the vertical and horizontal, and crops the bitmap from there. Here is the Bitmap class doc from Android library.