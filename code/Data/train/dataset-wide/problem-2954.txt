even if you plan to keep your EntityManager as a custom class, it would be a good idea to use the same interface as any standard container class. So should be and you should pass to it instead of . 

for performance reasons. Does it makes sense? More context: is guaranteed to be non negative. The code is used to fill a circular buffer of length , is first incremented and then the check is performed. depends on user input. The code is an interview exercise so there is no clear context. 

Here the complexity is too much... we have four variables plus the three of the enclosing function: very difficult to keep track of all of them. is repeated. should be the return value. 

For your use case (an AI for playing minesweeper) it could be more appropriate to have an approximate fast algorithm instead of an exact but slow one. So I will suggest to develop some sort of Montecarlo method. By your previous question I understand that you have a complete understanding on how to enumerate all solutions each with its exact probability: you just distribute the mines randomly on every FieldGroup. So you are in the position to write an algorithm to extract a random solution with equal probability among all possible solutions. If this is done, Montecarlo method is straightforward: extract N solutions at random and compute the resulting values for your random variables (i.e. the number of mines in the neighbour of a field) and estimate the probability with the ratio: positive_cases / total_cases. The good point about this, is that you can evaluate all positions at the same time with the same random samples. Also you can decide how much time to spend on the computation: the more time you spend the better are the approximated results. 

Your code doesn't run in parallel at all! Locking the mutex at the beginning of means you are always only run one instance of at the same time. You are passing a copy of the same random number engine to each thread. As this is only a pseudo rando number generator, all threads will operate on the same sequence of numbers (you are doing the same work multiple times). 

For some time it has been bothering me that there is apparently no way to directly initialize variables from input streams (something like ) My solution is this: 

In response to the comment about multithreading: You can (more or less) trivially parallelize by letting each thread generate the new cells for a slice of the world (e.g. a quarter of the rows on a 4-Core machine). There are many parallel loop implementations out there that can make that Task even easier. Obviously this is only sensible for very large grids. 

even if you have only a single option it would be good to write your code as if there were many. This could be simpler to understand and easier to extend. I would keep the options (in your case which you could transform in a boolean variable ) as global variables, and parse them in a dedicated function. Once you have extracted that code from the main function you will feel more eager to add other options (for example --help to print the usage message). You function is definitely too large. Extract the arg parsing code. Put the logic into a separate function and let main just be glueing code. Here you are reinventing the wheel: 

As said before: mTree should be a local variable in World::update so you make it clear that there is no need to take care of its content while you create and delete entities. This is at present the only functionality of EntityManager: 

The general push/pop logic of the stack looks fine. The memory management however is somewhat flawed: Missing Destructor From the perspective of the unique ptr, the stack doesn't contain Nodes, but uninitialized memory (effectively a char array). So at destruction of the stack object, it won't call the destructor of the individual nodes, which in turn won't call the destructor of . In order to correct that, one could write a destructor for that traverses the nodes and manually calls the destructor on them. Assignment into uninitialized variables 

First of all, as DarthGizka mentioned, your code is mostly easy to read and understand and except for the memory leak I mentioned in the comments I don't see any errors. I can't really contribute on the general question, of how effective skiplists are or what would be the best algorithm to determine the height of each node, however, I think there are still a few things that can be improved in your current implementation: General Interface I believe this is more of a proof-of-concept, but on if you go on with it, you should probably strive to make a interface more similar to STL-like associative containers. Meaning in particular: providing iterators, template the class on the member (and key type), providing the typical typedefs and functions (e.g. ) etc. As mentioned by others, this would also make it easier to compare it to other data structures. Making a nested class Skip_Node is an implementation detail that should not be visible outside of the class, so you can just make it an nested class of . Const correctness and static member functions You have a few member functions that should be specified const (, ) or even static (, ). Structure It seems that you assume, that you will never add an item to the container with the same key as the key. If that is the case, you should probably document and assert that. However, this also means, that there is no need to treat the node in a special way. More to the point: The main reason for using dedicated and nodes is so that your member functions don't have to care about empty lists, or whether a new node is the first or last node in the list. If you embrace this concept, then you can e.g. make a one liner that simply returns the size of the vector. Also, insert and erase seem a little long to me and share a nontrivial amount of code, so you might want to refactor the common functionality in a separate function. Finally, seems to be a pretty heavy member for the list nodes (due to the size overhead and the additional memory allocation). If the maximum level is a compiletime constant, you could try e.g. a member array instead (possibly using multiple different node classes of different sizes, as suggested by DarthGizka). Dead Code With the above in mind and when you carefully think, about what invariants hold at each line of code, you might see, that there is a lot of test that always evaluate to true or false and code that never gets executed. Comments Nice to see a thoroughly commented code. Personally I would write the function documentation at the point of declaration (in the class definition) and I also try to avoid to write comments basically repeat the code the code. After reviewing and refactoring your code, I ended up with the following (some of the changes are just personal style): 

You should notice that square numbers between 1 and 1000000000 are "only" 100000 and among them you can imagine that very very few can possibly have all perfect digits since the condition on every single digits are probably independent and hence you expect 1 every 2^10 perfect squares with perfect digits. So you could compute them all at once and, possibly, put them in your code (you find they are only 121 numbers). Finally you can find how many of them are in a given interval with a simple linear search. On my laptop, with the worst case input, your code runs in 2.871s while the following one runs in 0.017s. 

This answer has two parts. First part to show some suggestion to your code, keeping the same algorithm performance. Second one to suggest a \$O(n)\$ algorithm (where yours is \$O(n^2)\$). PART ONE The function can be written as: 

A documentation string here is important. The names of the variables are so vague that even knowing the task in advance is difficult to understand their meaning. 

I know, there are a few implementations of immutable strings out there, but my focus seems to be a little different. My goal was to have a type that provided value semantics, but didn't incur the cost of dynamic memory allocation when constructed from a string literal which is already guaranteed to exist during the whole program runtime. After refactoring, I ended up with two classes: 

Aside from general advice of how to improve my class (I bet, there is a lot), I'd especially like to know if 

I don't think there is anything wrong with your general approach (or at least I don't have a better suggestion). On an implementation level I've a few suggestions 

As mentioned before, I'd replace the class member with a local in and pass the array as a const ref parameter to . This gets rid of the mutable problem and might even increase performance. I'd write the function a little different: 

I think that the data structure and the organization of the code is far from optimal. You are making an interpreter with some sort of precompilation (the function which searches for brackets). The data structure used to store the "compiled" code is bloated. You have a doubly-linked list for something that will never dynamically change. The pointer is never used. The pointer is rarely used. What I suggest: 

For each token you are describing a triple of sets (pairs,suited,off_suite) which are parameterized over a value. It would be nice to have a code like this in your : 

is a thing I would avoid. Since the program is so clean and self contained, I would keep it as abstract as possible. Maybe in 5 years there will be an OS which could run python happily but which does not have a 'clear' command... what a pity if your program will break for such a triviality! And if you insist in using a system call, wrap it in a function, don't write it twice! 

I also made the deliberate design choice, to not provide a virtual destructor due to the overhead it would incur and the fact that I don't see any use case, where I would want to destruct const_string via a pointer to . Still this goes against best practices and might be suprising for other people using that code - would you accept such a code in your codebase? I haven't finished documentation and the unit tests yet (I hope the code is readable enough), but here is some sample code to play around with: 

The only thing you share among the codes is just define it as an atomic (). Even Better: Don't share anything: Let each task use it's own hit counter and sum them up at the end (easiest way to do this would be to use std::async). Create and seed a separate random number engine for each thread 

Using STL algorithms If you want to advance an iterator by a certain number, you can use std::advance instead of a loop: 

You are using the float value -1000.0 as a sentinel to represent null values. In a real project this is a very dangerous design choice! Your program will give unexpected result if -1000.0 is a value coming from the interpolation or from user input. To overcome this issue you could use two varibles and to mark the interval of non null values. Otherwise use a FLT_MAX instead of -1000.0 as a sentinel. This is very unlikely to cause problems. 

I would extract the code which draws a single star in its own function. Also I think it is important that such function will draw a star centered in the current position and leaves the turtle in the same position it has found it. Otherwise I think that the stars you are drawing are not centered exactly around the center of the screen... or at least it is not clear to me why they should.