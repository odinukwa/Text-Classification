You don't gain much by doing this but you won't go through all the cookies to check if one of them is equal to (Well I mean, it is possible you'll have to but this would be the scenario where the cookie is the last one in the list) Otherwise your code looks pretty good, but there are some things that are hard to review considering that you are using "domain objects" (The class which we don't have). If you want to get funky you could switch your dictionary implementation to this (there is no real gain except if you want to get to learn more about Linq): 

Note : The base class is used in the algorithms, but it is not used anywhere in this review. The is used in case of a non directional graph, it is used to see if two edges are from the same... association ( and ). 

When you write code, it is very important to make the said code as clear as possible. Methods named and aren't self explanatory. Think that when you read code, you should be able to understand what a method does without reading the code of the method. To show you a good example of what I mean, I wrote a really long answer about the method being about selecting difficulties but I found out at the end of my review that it wasn't the whole point of this method. I'll attack the method for now. It's sole responsability is to prompt the user for a number. Meaning a better name could be , or something like that! When I name my variables/methods/classes etc, I think about what my method does, resume it in 2-4 words max and that is my method name (works most of the time). In this method you currently have 3 parameters, is quite good, though I might have named it or something like that, just to make it even more clear, but that might be nitpicking. The interesting point is about your two other parameters, and . In your cases (prompting for a difficulty and for a guess), you only validate if the number is within a range. But you might need other kind of validation in the future, for example any number greater than 1 (which is a little excessive I might say). In this case you'd have to tweak your code to make it work. My solution for this is to use . I'm not sure if you have seen those before since they are a little bit more advanced. This would give you the opportunity to let the caller of your method define the validations to be made on the input. For example : 

So I started Python this week, and I never programmed a game before. Even though Tic Tac Toe is probably the simplest game ever, I had some challenges while coding the game rules. I split my project in 4 files : , , , . I think my file content is self-explanatory enough that I don't need to explain the purpose of each of them. 

This factory is used to create or wrap an object and attach the method of the controller to the created object. Here's the controller's interface : 

You know what, I won't write it. It's super long and you got the point! :p This is an \$O(\phi^n)\$ operation, which is pretty super slow. The performance of such an algorithm get's terrible real quick. (Check out the comments to see the mistake I made! :p) 

Well, why don't you create an exception that works with this? Something like (You might have a more appropriate/domain-specific exception name!) : 

Your time format should be a constant. After all, it isn't dependant on any other code in your method. 

I'll be 100% honest, I'm not sure this solution is better, since the tuple initialization can be long on a single line. But maybe this can guide you to a better idea! There are things I didn't talk about because other answers did explain it very well. 

and shouldn't be class members, they should be declared in your method scope. That is because they are specifically used for your method implementation. This way, you won't need to reset them afterwards. Some people already pointed out that you should use the C# code conventions ( should be ). You don't need to use loops in this case. You want to do an operation X times, and the is all designed for this. Also, there is no need for the 2 loops, only one could do the job. and are quite confusing variable names, I understand that they are in fact and , I think these names are clearer! We see the int used alot in the code, what if I wanted to change it to... . I'd have to check all the code and change all the instances of for . This looks like a good scenario to use a constant! Your method should have one simple responsability, to generate a code. So, this method shouldn't worry about the nor the . This method should return the generated code, and your method should take care of the rest. It is a good practice, if I recall, to use a variable, in order to have a better... randomability (I just invented that). I'm not sure if this is a best practice or a personnal preference, but I like to see the visibility modifier indicated, even if by default it is . This way I can make sure it is intended to be private and that the developer didn't simply forget it. So right now, this is what the code looks like : 

It reduces noise in the code, I think you should use it in your class since you don't do anything particular in your getters/setters. Also, you don't need to specify the parameterless constructor. If there is no constructor specified in C#, it will assume there is a public parameterless one. The C# naming convention implies that method names should be in PascalCase, which means should be (same for all the other methods). Try to be consistent in your private field naming, some of them have underscores at the beginning, some don't. There's no official documentation specifying you should use the underscore, so pick the way you want and stick with it. Finally, I don't know if it is because you had trouble with formatting your code here, but pay caution to the white spacing of your code! 

What is printed? Is it ? Nope, because your instance constructor resets the field. The field shouldn't be static. Each should have its own number of stones. Maybe the number of stones could be customized with a parameter in the constructor? 

Now that is great, your prompt method doesn't need to know how to validate, it just uses the . Now, this is how we use it : 

I would change to , it is way more clear what your property is in charge of. Finally, I don't think you should have braces around one liners if it is to put them on the same line as your code. What I mean is either do this : 

I've written this infix to postfix converter using this website as an helper. At the end of the web page, there is the procedure for the algorithm. 

Finally, your application will crash if the user enters anything that isn't an in the prompts for the scores or the number of players. You should validate your input and maybe re-ask the user for the score/number of players until it is a valid input. 

Delegates syntax are a little bit too much C#2.0. It's confusing for inexperienced developers and a little bit too ninja in my opinion. In C# 3 or 4 the and where introduced. This remains a matter of opinion but I believe you should use instead of your . Your method and are not very intuitive. What do I add a delegate to? When will it be executed? Why not name this and . I know, it looks silly, but look at what it looks like in code : 

should use brackets, just to make sure you don't introduce some nasty bugs. And hey, you could reverse your condition to remove some nesting : 

Adding to @SimonAndre's answer, you could use a reversed for loop to go through your array to remove items you don't want. It remains an O(n^2) operation because of the method. So this approach isn't any better, but it's a different way to do it. 

Before worrying about , there are some very basic notions we should review! :) Never, ever getting back together expose your fields. They should be . Use properties like you did in your class instead. This pattern is called encapsulation and is an important practice in the software development process. In general, an instance (like ) shouldn't deal with fields. Why is that? Imagine the following scenario where you have 2 quarries. 

There's wayyy too much things in that . Locks need to be used cautiously, you don't want to bottleneck your application with a . Try to remove everything that's not related to the thread-safe operation from the . And well, looking at your code, nothing needs thread safety here. Maybe your "write" operation needs to be thread-safe so you don't write in the same file with two different threads, but that's all. And even there, in such a case I don't think a is the good solution. You should use the operator instead of comparing types like you're doing actually : 

From what you gave us, there's nothing you can do to optimize your query except changing the way your data is stored. Having is a big code smell. There's something wrong in the implementation. Though, you could change this code to be a little less repetitive. Most code is duplicated in there, so let's refactor it : 

There's already the implementation. This could lead to some confusion. I'm pretty sure that exposing only the implementation would be enough! If you're worried about needing to cast your and not knowing the type, I'd need to ask you : When would you need to cast your from outside the (Which knows the type of , thanks to )? The message could be clearer. After all, explaining that isn't that much of a long message and it's much clearer than . I'm not sure you're using the best design pattern to deal with your problem. After all, and share absolutely nothing. is dependant of . Since isn't created via the factory, we'll start by removing it from here. After all, why would a need a as a parameter? Argument #1 : If the class or the doesn't need a class, it means the is an implementation detail. Interfaces/abstract classes shouldn't show implementation details. To show my point, here's an example. Imagine one day you have two child classes of . One which uses a and one that uses . Will you add to your ? Would you add parameters like this for all the child classes? The class would end up being a mess. Argument #2 : If is a property because you didn't want it to be a parameter of the method, what would happen if you created a problem that didn't need a ? The method would throw . But is it really invalid? No. The child class didn't want to use , and shouldn't need to use it, as it isn't a parameter of the method. So now that you see why the property isn't the best move, let's see the solutions : Either you completely remove the property from the class, because it is an implementation detail; or you add the as a parameter for the public method. If you think will be used for every problem created, it should be a parameter of the method, otherwise it should be left out from the base class. Right now, I think should be a parameter of your method , let's check all that out. First, we create an : (Note : I think would be a better name than just , it's less confusing! And for the following examples, I will apply the review I made above) 

Your code looks fine, but you could pull the delegates out of your class, since they have their own reason to "live" and are not linked to your class and you should remove the modifier to your constructor, this doesn't compile. 

And you repeat twice. You should first check if their modulos are equal, then check for which is bigger. Which gives something like this : 

Now I'd expect as an answer. The thing with algorithms is that they can indeed be hard to read, even if it's just a brute force. To counter this, you need strong variable names and a logical flow in your algorithm. (Meaning that just by reading the code I can understand clearly every step of the algorithm) For example, the code below, if I got it correctly, will find one common multiple (probably not the smallest one) of the multiples. Meaning that, for multiple = 10, we'd have : 10*9*8*7*6 

You don't check your parameters for ! When a method/constructor is , you need to check that because it is assumed that anyone could reuse your code. If your class was , I wouldn't mind but now you do have a problem that a will be thrown at a moment that isn't expected. You use a lot. Which isn't bad. But I think it's useful for readability to use only when you can guess the type by reading the code. In such a case : 

This way, there's no loop and we join the strings only once. The problem with your code is that it's, as you said, not the most efficient way to do what you want. When you write code, always try to be conscious of the "cost" of the methods you use, and the amount of loops you use. Though I guess it comes with experience! Lastly, I don't think is a good method name, considering the method doesn't only join strings. It's kind of hard for me to come up with a better name considering I don't have the context of your application. But you should try to find something more representative! 

You're right that having redundant code is a code smell, but creating another class to keep encapsulation is most of the time a pretty good thing to do. I wanted to address the comment stating that you could use interfaces. I feel like it's not a bad solution, but I don't think it's the right one. Implementing an interface is kind of a "is a" relationship. But, could you say : " is a ? I don't think so. Though, saying " contains " seems pretty logical to me! Sure, readability and serialization are good points. For the serialization, well.. APIs are good, you'll have to write a little bit more code to deal with that. Readability itself isn't that affected. But are those points valuable than : 

Semantically, HTML button tags are supposed to represent a user's action, whereas the link tags are supposed to take care of the navigation between pages. That said, as @user1320170 pointed out in comments, your tag should be a link (< a > tag.) You'll notice it's much clearer this way. Apart from that, your code is good, using is a good plan. 

Also, is there a reason why you don't use your method in your method instead of providing a parameter? I think it would make sense, but I don't have full knowledge of your needs.