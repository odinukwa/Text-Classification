In Addition to what @Mast said. You DON'T implement the rule of three. This needs to be fixed (especially since you have resource ownership). Missing Destructor. I think you can simplify some of your code by moving it from into and using some simpler functions that do specific parts of the task. There is an extra default constructor in that I think is superfluous. When are you going to create a node with the value undefined? You should be using rather than . Its 2015 the standard has been out 4 years and every modern compiler now supports it. It is more standard to use an initial capitol letter for types (to help spot them). And use an initial lower case letter for objects (this includes functions and methods). Thus => and => I don't like your delete it is overly complex. You should never need to find the parent of a node when doing tree manipulation. You had to pass it to get to the current node. As a side note. This can be trivially templatized to handle any type. insert You don't check for equivalence. I presume this is bug (because the second one will never be found anyway). Can be simplified like this: 

Does this even work? It seems that i is getting smaller and smaller then goes negative. It is easier to loop up and subtract in the range: 

I don't think there is anything inherently wrong with nested namespaces. I also disagree that it is rare. It is just not exposed directly. 

You could also add Move Semantics. (I did this to some old code and got a 30% boost in speed by doing nothing else but recompiling with C++11 on). 

Which as I noted above can lead to race conditions and crashes. But if you do lock it then the the application may never quit. Also your code locks the code so long that only one thread may ever execute at a time (so there seems no point in using threads). Sorry that was over blowing it a bit (you release the lock while waiting on the conditional so that is not completely true). This is an indication that too much of your data is shared. In my description above I explained how to remove the queue from the shared part of the structure (so each thread only sees the queue) and how does not even need to be shared with the threads. Re-writting this is a major task and will require some work. Thus you only need a lock when adding/removing work from the queue associated with the thread. 

Everything Jamal said (so I will not repeat) Plus: The normal idium in C++ for passing ranges is . For those not mathematically inclined end is specified one past the end. If you follow the C++ convention you make it easier for other C++ devs to keep track without having to think to hard about what you are up to. Personally I think it also makes writting merge sort easier. 

The main difference is that the C++ version puts the types correctly in the namespace rather than the global namespace. These types already seem to have the same names. 

You did not provide the implementation of your constructors or assignment operators so its hard to tell if they are good or not. Also nice to add easier access to const iterators: 

The trouble is this seems to work and compiles if val1array is a pointer to an array. Unfortunately in this case sizeof(val1array) will return the size of the pointer, and sice you can not pass arrays as arguments to functions in C (they decay into pointers) there is no way to determine the size of the array on the other side of the function. So (Rule of Thumb) if you ever pass an array as a parameter then you should also pass its size using the trick above and pass that information forward with the array at all times. 

I would always throw an exception in preference to exiting the code. In the best case this causes the exact same behavior and causes the program to exit. BUT it also unwinds the stack forcing a clean termination and resource clean up. Also if you code is part of another program (ie this is just one of many games that can be played) you want your game to exit but you don't want the control program to go down. Using an exception allows this as the control program can catch the exception generate an appropriate user message log the error and allow the user to choose an alternative program. ###Switch should have a default: 

Do you really need these macros. If you must have them then why not name the variable copy and use the macros TRUE/FALSE 

Your low level make file in the top level directory. You only have one object directory (so you can only have one type of build) I have four types of build debug/release/coverage/size(built with size optimization) You use explicit commands where the makefile internal rules will work just as well. 

The just hides errors. You still want this to fail. Make has a special prefix that makes it ignore errors and continue. The following has the same affect: 

The other thing you don't do is validate your input. What happens if the input is bad? You should at least attempt to detect bad input. Otherwise your code will go haywire when it sees something it does not expect. When you use streams this is easy; just set the badbit on the stream. Any other input operation will then just silently do nothing; and any test you use the stream in ( or ) will auto convert the stream to a false value (technically a value that will convert to false) and thus not do that code (see my above for an example. 

No this should not be quicker (but always time things). NRVO (Named Return value optimization). The old C++03 compilers can easily see this as a value that is not used in the construction function and will actually build the string in place at the destination (rather than build it locally and copy it out). You can test this by rigging up your own version of a string and seeing if the copy constructor is called when you return it (if you have optimizations on it does not). With C++11 we introduce move semantics. The return value of a function is an r-value reference (may be some other complex names for it). Basically if the compiler can not use NRVO/RVO then it can use move semantics to move the object out of the function (rather than copying it). Short story don't bother to pass output parameters. It is much more logical to use return values. The compiler is going to do a bunch of optimizations that make it as affective (if not more so). Better approach. Try and use algorithms: 

Unless you allocated the memory in some other way the used 'Placement New' you should not be calling the destructor manually. But nothing in your interface indicates that. So this should be a normal call to delete. 

BUT There is no actual need to cast a char to an integer. This will happen automatically (as a char is an integer type the conversion is automatic) with no loss in precision. Is there a need to put the largest first. I don't see you taking advantage of this in the function above! 

Using a for loop is easy. But sometimes it can be simpler to use the standard algorithms to accomplish simple tasks over short containers: 

Move the declaration of outfile to the point just before you tart using it. In C++ because of constructors/destructors the side affects may allocate resources. If you don't need them don't use them so wait until you need them. It also has the benefit of making the declaration near the code that uses it so it makes it real easy to see the type of the object you are using (as it is just there with the code). Encapsulation 

I hope that inspires you to simplify the rest of the code. The next section is a classic example of when to use an array: 

A lot of this code can be removed if you use . As part of the format specifiers you can set a maximum input length size. 

Maintainability is an important part of coding. I see where you are going with the name of the function. But if you go 80% there you may as well go the whole way. Name the function for what it does (don't chop the words). 

According to the documentaion atoi() has been deprecated in favor of , and is equivalent to So you should probably use that. And another point to check for errors. 

Not sure why you specify a function. The problem is that a lot of code in C++11/C++14/C++17 uses lambdas (which are functors (probably)). So your handler should be a template that allows any generalized code to be executed. 

Prefer to std::endl; The only difference is that performs an extra flush. Forcing a manual flush is usually never the correct solution as the libraries will do this for you when required. Main and return The function is special. If the compiler detects there is no return it will plant one for you. 

I would say that is the perfect way of doing things if you were programming in C. But since you tagged this as C++ I would say you are doing it wrong. Rather than having a pointer to a function I would set an animation object off your sprite. Then you can call the animation step method on this object. Since it is an object it can hold state as required. Change: