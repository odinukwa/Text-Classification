The first thing I notice is that you have two static fields, and that they are public, and not final. Static fields should be uncommon, and, when they exist they should be final. If they are not final, they should at least be private.... In your check to find the pluginFolder, that's almost OK. The from the main method is not what I would expect, though. If there's a problem, I would expect a non-zero exit code.. , or perhaps an exception. The Port number check is more concerning: 

Trick 2: The precision of standard integer data types are not able to accommodate the size of factorial numbers up to 20 or so. You need to adjust your calculations to do manual overflows, and so on, when you calculate this way. I would consider using a long-form arbitrary precision multiplier for it. Code Style note that it is no longer good practice in C to pre-declare your variables at the top of each method. You should be declaring them where they are used. Additionally, capital-case single-letter variable names are not friendly. and should be and or something. 

64! is exactly Long.MIN_VALUE.... (coincidence?????) 65! is also Long.MIN_VALUE 66! is 0. After that, anything times 0 is 0,. EDIT2: OK, the reason for this, is that any time you multiple a value by 2, it is the same as a bitwise left-shift.... for example, (1) multiplied by 2 is . With this factorial, any time you multiple by an even number it is a bit-shift (because all even numbers are a multiple of 2). Also, because any time you multiply one value by an even number the result will always be even. (3*2 is 6, etc!). So, after you have 2! (1 * 2) the factorial result will always be even... (only 1! is odd) and thus every successive loop in the factorial is a bit-shift to the left. After 64! only the highest-bit is set in your long value..... and then, multiplying by 65 (because it is an odd number) is the same result.... finally, multiplying by 66 (an even number), is another shift, which shifts all the bits out of the long value and you are left with just zero . You can see this using the following adaption of your code: 

In general, you have not given enough context to evaluate the concurrency handling. What you have shown hints at there being other problems too. 

I really like the concept of this system, but it has some.... issues. The Code Style is pleasant. I am sure there are some nit-picks in there, but, it is certainly clean enough to make reading it easy. The issues I have are more with what you are timing, and some use cases that I think would break things. First though, what is good is the idea of having the two input functions, the one to time, and the other to generate the timing inputs. The problem is that your timing function also times the generation time. The other issue is that you reuse inputs for both the warmup, and the actual timing process. Timing the generation is... awkward because you don't know whether to blame the time on the actual function, or the generator. The instance reuse is also awkward because I know instances where rerunning certain values may cause failures, or unreasonably-fast execution. What I would recommend is that, instead of doing what you do with the warmup, you change your reporting system, and you time each function call individually, then throw out the 10% fastest runs, and the 10% slowest runs, then average the remainder..... (perhaps reporting the statistics like the 95th percentile as well, etc.). I would probably have a timing function like: 

This will never generate the digit . If you want to be generating digits 0 through 9 inclusive (that is 10 different digits) you need to do: 

Doing the same for and will reduce six calls to just three. Additionally, I would consider wrapping the entire replace function in a call, that matches any of the patterns you are searching for, so you only need to do the full replacement call stack on values that actually require it. A large matches for all replaced values will, depending on how often values are actually required to be replaced, save time. 

Just reviewing the method since many of the Node and other constructs have been reviewed in other questions of yours, and there's not much changed since then... 

Other you are using the grid-size 10 as a magic number in a lot of places. You should probably make it a constant..... Alternative. C++ is not my primary language, and this is hardly a good example of a C++ program, but I have re-written your program as.... available on ideone as well ... This is the code that you should really be reviewed on .... 

Additionally, there should be an empty line after the closing and the start of the next method declaration. Threads You are using swing, yet I cannot see any places where you are accommodating work that is done on the Event Dispatch Thread (EDT) vs. your game thread. This is likely to lead to inconsistent gameplay, irregular timing, and other problems.... especially during the manipulation of the Graphics objects. Terminology I am not seeing a Finite Automata here... this looks pretty open-ended, not finite. Magic Numbers These are everywhere. There must be a better way to centralize them. Integer Arithmetic This line: 

don't select columns you don't need (the is bothersome) you should restrict the data much further before you start. The Oracle schema views are slow, and you should limit your schema selection in the first CTE, and then join that to the views for subsequent selections. order-by clauses in the CTE are often unnecessary. 

Frequency The good thing about Frequency is that you are using it. You are correct when you say it is better than the autoboxing system (keeping an Integer in the HashMap). I have to question why you felt it was necessary to add the intermediate class Token though. There is no need for them both. Choose one, and merge the other in to it. For example, there is no reason why you can't add the String value to the Frequency class. As it stands, the logic is a little bit too abstracted. Map efficiency The code 

With that, there's no arrays, and the extension is the last part (or the whole filename if there are no '.' values in the file.... you need to check for that case too. There's also the possibility that a file may end with a '.', leaving an empty-value extension.... you need to check that too. inotify Currently you have a number of problems with inotify: 

It is very, very unlikely that running multiple files in parallel will go any faster than running them all sequentially (your bottleneck will be 'internet' bandwidth regardless). Is there something wrong with doing something like: 

Note though, that the above implementation has horrible handling of issues that may come from invalid input. Still, the entire implementation is significantly simpler than yours. 

I think what you're missing here is an algorithmic change to improve the way you load data, ranter than the way you compute the results. One way to do this would be to build a tree to store your Records. A tree is really not that complicated to do, but, there's an in-between thing you can do which will really help. Create a as part of the constructor of your class. Call it for want of a better name. Then, each time you add a record, ensure that the tree is modified as well. Here's your current method: 

It is my experience that blanket/policy DENY for outbound traffic requires a signfificant effort for maintenance. Are you prepared for that. Altough it is not the most secure view on the world, I don't think there is much point in restricting out-bound traffic. If a 'hacker' has gained enough access to your system to enable outbound systems you were not expecting, then the chances are that they can just open up your IPTables anyway. The frustration is not worth it. Ping allow ping from inside and from outside 

or ... 153 combinations and permutations..... in total (154 if you count the empty-set). Now, with 15 members in the input set.... you are looking at.... say, 1307674368000 permutations for just the one combination where you have all 15 input members..... Then, there are 15 combinations with 14 members, so, that's another 15 x 87178291200 permutations. and so on..... As you can see, the results are getting quite 'large'. You have to scale back your expectations.... But, there are ways, with both combinations, and permutations, to produce the valid results in a 'streaming' or 'yielded' fashion, where you do not need to output all the results in memory at once. Even with these mechanisms, the time required to calculate so many results is substantial.... so, practically, you would be limited to at most 10 or so members in your set. Even then I expect it to take days to calculate/output all the results... For your interest, I have written a Java program that calculates the combination members as an array for an arbitrary number of inputs. It 'yields' the result in the form of a Java iterator. You should be able to read the code, and apply it, if you want. Have a look at the main method for the usage..... This just solves the combinations part of the problem, not the permutations. For each of these combinations, you would have to permute the results too. 

The above loop will process any/all available names from the source (until it is closed), and will then send values to the channel. Then, in your main loop, you can have a channel to send CSV parse results to: 

Which will produce the values 2 through 6 (but never 1). Using random numbers is surprisingly easy to get wrong... Part of the problem is that works in the domain from to I strongly recommend using the class which has some easier methods to use which at least are closer to the domain of values you want, . 

you need to solve it for where is prime. The first value to use is 0. is , thus, in order to process any values, it is clear that needs to be a prime number (and not negative either...). Thus, you should rearrange your loops, and your outer loop should be on the first prime numbers in your set, where the k'th prime is < 1000. There are 168 primes less than 1000, so that will reduce your loops from 2000 'b' loops to just 168. Similarly, when you loop on only those 168 primes, you are guaranteed that the result is prime, and you only need to test on the condition. Further, when is 1, the equation becomes: 

In , replace all non-digits with "" (i.e. remove any non-digits). Your code will still fail with an exception for input like "Hello", which has no digits, because the call will fail. Values with multiple characters will also be interesting... Additionally, your code does not support negative input values. This can be a trick to accomplish, but, again, using regular expressions, it is not horrendous. Finally, I feel you should only be parsing the first set of decimal-like digis in the input, not all of them. Putting this all together, I would have: 

as the very first line. The rest of the script looks fine enough. The script has a duplicate declaration: 

Although your question indicates that you are using a functional paradigm, you are not. You are using a procedural paradigm. Functional programming is about declaring functions, and then passing those functions in to other places to be used as modifiers and manipulators for other processes. Terms like 'lambdas', and 'closures', 'optionals' or 'monads' are required. Procedural programming is the act of defining a process to follow, sometimes returning a value, but "I take this data and process it following this defined routine, and I get the results I want." Procedural programming often has functions declared, but the functions are not used as parameters to other functions. You do not pass any functions in as parameters, you are not using a "functional paradigm". You are using a "procedural paradigm". See Wikipedia's comparison between Functional and Procedural programming. Your code is a very poor implementation of a Functional paradigm. On the other hand, as a Procedural implementation, it is actually quite good, except for the method, which is implemented on a single line which is too long, and makes it hard to read with all the nested braces on one line. 

I feel your logic should mostly be pushed to the base class. Additionally, I feel it should have a generic type of return value. I don't like the raw return at all... Additionally, is a poor name, I would go for a name like which makes it more clear that there was a problem, rather than a potentially null value which is null, but still present. You have some static generic methods that have unconventional generic typing... 

This can be easily done using a two-phase approach, one to shift values to the front that you want to keep, the other to sort the remainder. Note, for sorting, use the native functions in the libraries... in this case, It would also be much better to wrap this up in a function, taking 2 arguments, the number to put first, and the array to sort. 

Dates and Date handling in Java have been a problem since the beginning (check out all the deprecated methods in version 1.1). You appear to be running in to the same problems that may Java developers have encountered, and then there are a whole lot of issues that you have not yet encountered. Unlike other questions in CodeReview, I'm going to deviate from the norm, and tell you to give up.... A lot of people have taken a kick at this can... people smarter than you, and me, and the bottom line is that, even after three attempts, the base Java implementation for Date and Date-like data is still not right. On the other hand, JodaTime has somehow managed to be a library that is well maintained, accurate, usable, and just 'gets it'. It is licensed under the Apache2 license, which means there is effectively no restriction on how you can use it, and with few restrictions/requirements when modifying it (not that you would want to). At this point in the Java ecosystem, there is absolutely no point in building your own Date library.... it leads to weeping and gnashing of teeth.