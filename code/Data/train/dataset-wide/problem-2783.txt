As for testing its correctness, I'd use unit tests, and instead of printing to screen, you add the strings to a and return the list. Interesting cases are empty string, single character string, and a regular string like "Amy". 

The whole point of creating builders is to be able to make objects that have different values. Like "make me a small orange", "make me a big orange", "make me a fast orange", "make me a slow orange". The builder takes the default values of the orange, applies the requested changes to the input, then creates the object. What you have done is created builders for fixed values. In that case, you're better off applying the Factory Pattern - Like a vending machine, I push a button and I get my object. . To that end, you could have made the following: - A no-args constructor for each Fruit to set default values - A all-args constructor for each Fruit to set custom values. By doing so, you remove the need for the class and the . All s can be again. Don't worry about repeating yourself too much if this repetition can be created via the IDE by just generating code. 

When you have this many parameters, you have to know that you're doing something wrong. You still need all of them, of course. But individually specifying each of them causes huge method signatures like this one. You already encapsulated some of the parameters - contains a host, port, username and password. That's good! But it can be taken further. Consider making a class whose only goal is to be a wrapper for some of these parameters. For example, a which represents , and . You can have static methods that take each of these parameters and return the wrapper objects. The end result will be something that you pass server settings, a template, a project, and maybe something else (for the rest of the parameters) into. By doing so, you can reduce the mental load by a huge factor. Because as it is right now, your public API is unusable. Semantic disconnects Additionally, is throwing and why?! How is sending an email going to databases? It turns out this is because you retrieve a list of users in the function. is a poor name; a better one could be found if you simplified the arguments list and it's responsibilities to something more manageable. Similarily, here's : 

Don't just duplicate code like that. Define a nice constant somewhere like or something related to why only 5 should be altered when clicking and use that in combination with a loop: 

Why would you first check the sign, and then perform parameter validation? It's a waste of cycles. If you reorder the code, you can migrate your checks to a separate function: 

You'd think the second if-block is on its own, but it's actually the of the first statement. Don't add blank lines in an chain. 

This section of code is duplicated. I think you could extract it into a separate function, as well as merging the two conditions: 

If you retrieve the iterator, then call on it, it fails. To fix this, you should set current to . Consider returning no iterator for empty arrays too. 

Your factorial function enters an infinite loop if passed a negative integer. Since the entire program seems to take 1 input and then exit, I think it would be best if the program gave an error message and then exited. 

I think that if you're in a rush, you should make use of automated helpers as much as possible. I get that if you don't have a lot of time, you can write code with 1 pass only, and that's it. It's not a sustainable practice, but if you need something done TODAY, so you can ship it, and then improve the code whilst the release is being "tested" by customers, well, that could be a viable business practice. However, that (in my opinion) does not excuse you from using something like an auto-formatter and whitespace. Whitespace is free - provided you place all the braces, you can insert spaces and newlines where you like. So lets haul it through a formatter. 

Apparently, non-rented cars cannot drive. But yours don't notify the caller. They'll happily report the trip as having taken 0 liters of fuel. I want to buy one of those cars. Not having to pay for fuel would be great. 

As for storing the applied ingredients... we can use a to store the quantity. I think the order of ingredients is not important. If it is, we can just use a . 

Now, in spirit of the course, I'm not going to give you the answer. However, the lines you changed are relevant: Old Lines: 

Duplicating the comment here might be bad, but to be honest, when you have comments like this, I rather like that both x and y mention the origin as "top-left". I feel I spend too much time trying to get my IDE to give me documentation on various combined variables, and this alleviates this partly. Using Random 

It still looks messy and it's not cleaned up all that much. I'd roll this one back; the duplication is gone but the code is twice as messy. It's harder to follow, now. I left it in the answer so that you might get ideas on how to clean it up; I think if you could somehow supply the person and remove the change, it could be easily wrapped in a function. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

The auth token is weird. Your class can't protect itself against reflection as far as I'm aware, so all this is doing is covering up a bad design. From the documentation I can sort of see it's supposed to guarantee thread safety - I don't understand why you'd go to such lengths; there are better ways of handling thread safety. Synchronizing on a comes to mind. The function names are also weird. 

By just applying , what used to take 5 seconds (and then broke, on ideone, after hitting 40000 characters), now runs in 0.14 seconds. Another performance improvement would be to add - check if it's going to fit BEFORE you fill up the lookup table. 

With something like that, you can get rid of the duplication of numbers. You can also use this to combine the menu printing functions into one function which takes a menu to print and then prints it. Like that, adding a new menu would be easier. As for your Savings class, you can make use of and to shorten to . 

Huh... There's no need to store to here, you can just say . But that looks weird, game-over if not collision. It's because you've made more of a function, but it really checks for collisions and then negates the result. So you'd be better off by removing the negation: 

You're a bit inconsistent with how you handle large argument lists. The large argument lists also make your code unreadable (or at least hard to read). I have trouble discerning the parts where your code does actual work and the parts where checks and logging happens. 

Less duplication, same output. You can refactor after that - like, are always handled if is not null, so the variable can disappear... 

Your code starts halfway. Presumably inside a do-while loop. You return output, then the function continues with more code. 

I merged the "second card already picked" and "can't pick same card" messages because technically you're picking a card that's already picked. 

This will include the name of the argument in the stacktrace and makes debugging just that tiny bit easier. 

Stop omitting braces. Understanding what that break does is harder when there's no braces, and it's easy to eventually screw up like this. This because most of the time, a statement being executed outside of some conditional block is not a syntax error - it's just a logic error, also known as a bug. 

These aren't questions, I guess. See this whole answer. Overall, you did pretty good; I question some of your methods and program behavior, but if you wrote this to learn then it is fine. I might be a bit harsh here and there; that's so that you can learn, rather than that I say everything is fine when in fact it is not. 

Starting at 0 and ending at . Why don't you start at 1? You don't even do anything with the index, so it's not like it matters. 

Well, at least I know I did something wrong with the template name. That's a lot better than "your settings are wrong!". Detailed specification of the input parameters would still be nice, though. 

Which I guess saves a few comparisons. You've got a weird sorting algorithm here too, a version of selection and insertion sort... which seems to have some flaws, in my opinion. 

There's other minor cases you should watch out for; there could be extra spaces between and . Also, , and could have a space on the end. Lines containing like could also cause problems if they have a space on the end. I suggest you trim excess spaces. 

Alternatively, accept that sorting sheets is likely to be fast already, and don't spend time on this beyond adding the two simple improvements. Maybe store and in temporary variables. 

Lastly, you could consider using a to prevent needless copying of String contents. I also recommend putting spaces around operators to improve readability ( instead of and instead of ). 

That's REALLY bad for performance. If you have to make 4000 characters, you'd iterate through the first 1000 characters at least 3000 times. Not only that, you'd also use , meaning you'd be making ((1000*1000)/2)+(1000/2) or 500500 character comparisons in order to insert the 1001th character. That's REALLY, REALLY, REALLY slow. You'd be better off doing the following: 

... Wait, it prints a few things and then returns whether it's running. So why the double call? I'd just return the result of in these cases. It'd be more correct too; what if a service stops between your logging and the return statement? You'd log that it's running and then return that it's ... not running. Good way to have logs showing "everything is fine" whilst things aren't doing what they're supposed to do. 

You could use a here. , or better, . Then you just have to get the Tile from the map, and ask that for the image. And if it's null you can return a blank. 

This simplifies your code and prevents you from going really far with your indentation. Alright, so here's your code now, for the function. 

You might want to give a more descriptive message, like "n must be positive", or "expected positive n, got ". 

That in the argument list is called "varargs". It's useful if you have a number of arguments but don't know how many. In this case, I'm making it possible to give you a three player game. 

You need to pass in , , and a message. The first two parameters are always the same. I'd try making them less pronounced: 

You ought to format your code properly. This is hard to read for me. Here's the recommended formatting: 

Did you mean and ? Actually, your method naming could use some work. Let's go over some of them. But first, Java convention. It's Java convention that your function names are . So, let's look at your method names: 

I had tagged your question reinventing-the-wheel, because you're recreating a , and Java already has one. @200_success has removed this tag for some reason, allowing me to post this answer: Use Java's built-in LinkedList. There's no reason for you to be writing your own implementation. Using Java's own (full classified name: ), you can use to remove a node. If you only have a reference to an object that is contained in the list, you can use . As it stands right now, you expose your nodes to the user of your class. You make THEM manage the LinkedList, whereas the LinkedList itself is nothing but a wrapper. If the user messes up and accidentally points the last node to another node, then makes a clone and compares them with or , the program will get into an infinite loop. If someone inserts a LinkedList which has the last node point to another node into something like a , the program will get into an infinite loop. Searching for an element in the list requires the user to built their own implementation of a search function. In fact, doing anything with the list (other than removing an element) requires the user to get their hands dirty. But lets say I wanted to use this LinkedList for a valid purpose. I can't even remove the last node from the LinkedList. That could significantly limit my options. Actually, removing itself is rather dirty because you've called it . This gives me certain assumptions - namely, that the object won't exist anymore after I have called the function. I call and surprise surprise... the node still exists! Except it has different values now. This means you're altering the objects I'm holding in my hands. You're even altering the objects you're holding in your own hands - in the and fields. There's another bug related to that: When I make a list of 2 Nodes, and I remove the first one, you end up having a LinkedList that contains 1 node... double! And if I were to add another node with a different item in it, wouldn't even point to the proper node! When you combine all these reasons, you should see that it is a bad idea to reinvent the wheel. Just use Java's and the methods they provide. That way you don't have as much bugs, you don't force the user to make their hands dirty, you don't have to test whether your list works, and you give your user more freedom in how they can use the list. 

It's the same... but inverted? I think you'd be better off by having a method which returns a boolean and then calling it from these two functions... 

Design: You have an insert (enqueue) method... but there's no way to retrieve an object that went into the Queue. could return the object. This drastically cuts down on the uses of such an object (it's useless now). 

I have many, many, many more words for those that make games to learn. I like such exercises. However, I think that this is enough for today. I hope you get more answers and use these in your learning project to post a follow-up question. Questions like these are fun to answer. 

You migrated the and out to a separate file. Why not do the same for , , , , , ? How are the other choices special? I don't really see how I can review the rest of the code, though. What you have here is largely a data model... and without seeing code that will use these objects or the domain knowledge what this data model represents, I can't tell you whether your data model is good. ... I wonder, though... do you really need to turn all your links into classes? Would a table structure really be so bad? You can have a class that manages that specific table... I imagine that you'd use some of the collections classes that your language provides.