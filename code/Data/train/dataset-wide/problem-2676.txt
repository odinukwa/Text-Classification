Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

The clause is very similar to the one discussed previously, only this time other than checking if has a index, the author also checks that the value is larger than zero. That's an unsafe check, because at this point we don't now what the type of the value in is, and if it's anything other than a number, there will be automatic type juggling involved, and the check is completely unreliable. From the name and context, I'm assuming the variable should hold an integer (if anything) that limits the search. If the variable doesn't hold anything, the limit is set to zero (), curiously using a string form of zero. I'd rewrite that check as: 

If you call this function multiple times and want to benefit from pre-compiled regular expressions, you could create a new class that compiles the expressions in its constructor and reuses them: 

The second one contains a lot of redundant code: is already the answer, it could be just something like instead. So the second one does not compute anything, it just prints the answer, while the first one can be used to find an LCM for different values of , not just 20. 

there's no point in making a field. It can (and should) be just a local variable in the method. The same is true for other 's and test methods. Class design I don't think that the is a good name for your class. I would expect a calculator to be able to be instantiated once and then evaluate results of different expression. Something like this: 

The name here: is misleading. This variable represent just one neighbor at a time. I don't see why would you make it plural. 

It's split into several smaller functions so that it's easier to read. A few more technical details: I used here to implement a generator. It's useful if the number of combinations is huge. Not storing them in a collection helps to save a lot of memory in this case (stack overflow is not the only possible issue: you can also just run out of space to store all combinations). Note that this implementation handles corner cases properly (like ). There're a few more things you might want to add, such as parameter validation (it makes sense to throw an exception if or either of them is negative). 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

Very good question. I'm pretty sure this can't be done within the selector. However, instead of checking the every time it's clicked, the collection before applying the event listener: 

In the regex above, we're looking for any characters in the string that are not in the bracket group. If none are found, will return 0 (which when negated will result in ). If any of those characters are found, will be returned and negated to . 

Use & . They're SO MUCH faster. Since you call every time you instantiate your plugin, you should probably move the call into your constructor instead. Public functions should be assigned to the prototype, so that we don't create a new function every time we create a new instance. Likewise, define a private function outside of the constructor, in the parent closure. Again, we don't want to have to re-create the same function over and over again. 

It's correct, but it's ineffiecent. It uses time in the worst case (for instance, if the input's ). You can do better than that by iterating over the input string and keeping a stack of brackets, pushing opening brackets to it and popping when you encounter closign brackets, checking that it's not empty and that the top bracket matches the current one. 

It looks like you are not confident in your code. It is a good practice to test the code in a systematic manner(using unit tests) to be sure that it works(of course, tests cannot prove its correctness, but they can help to ensure that it behaves properly for specific cases. It is much better than nothing). 

It looks like a bug. For instance, when you erase the 0-th element all other elements get shifted, so the new element at position 0 will never be deleted. You can just iterator over the vector and clear it after the loop. I don't see the point in removing the graph edges after the vertex is processed. I'd suggest to create a separate vector ( or ) to keep track of processed vertices and leave the input graph unchanged. If the graph is sparse, you can improve the time complexity from to or even using an appropriate data structure (like a heap). I'd also suggest to create a separate class for an edge instead of using . It's hard to confuse with . It's easy to confuse the and the elements of the pair (it's not easy to keep the meaning of the and the elements of the pair in one's head). You can make the code more readable by naming your variables in a more meaningful way (for instance, what is ? It's something like , isn't it?). When you need to iterate over a container and you don't need elements' indices, you can use a range-based for loop. For instance, this: 

As this is a learning experience, you should be concentrating on learning the language and its quirks. Java <> PHP, in quite a few ways. You shouldn't limit yourself in copying the Java interface, it's a good interface to clone but now that you've done that you should explore enhancing it with native PHP functionality. You should take as much advantage of native stuff as possible, the performance difference is noticeable. I have to admit that the ArrayObject was an off hand example, my primary intention was to point you towards the SPL. I did base something similar on an ArrayObject, but the requirements weren't exactly the same. Still bits and pieces of your code could be rewritten to take advantage of native functionality. For example, this: 

and avoid the costly call to . And do return something, tell the user if the operation succeeded or not, regardless of what the Java interface does. 

Everything seems to be working as expected (repo, with a simple demo). Since this is my first plugin, I'd be particularly interested in critiques of its structure. That said, as always in reviews, any aspect of the code is fair game for criticism. The plugin code: 

The code parses and validates the command-line arguments. I'd make a separate method for it. It reads something from a file. It's a good candidate for a separate method, too. After that, it generates a random word. I'd make a method to make it more clear and easier to change in the future (if you ever need a change). After that, the game loop starts. I'd recommend to refactor it into a bunch a small and simple methods (for reading user's input, comparing it to the word she should guess, and checking if the game is over). 

I'd suggest using a loop here because it would make declaring the counter outside the loop natural and the number of iterations is not known beforehand (which is a common use case for a while loop). 

There's a simple linear solution. You don't have to check all substrings. If an substring is a palindrome and , so is . Thus, it's sufficient to check only substrings of length 2 and 3. One can do with a single pass over the input string: 

You can't use binary search on an unsorted string (it can return an incorrect result). If you decide to sort the string, the complexity would be , which is worse than a linear search. So I'd recommend to stick to a standard "pythonic" way to do it (using the operator). 

Just keep in mind that this will query the DOM on every single !! Are you sure you can't somehow do this differently? 

Your variable is declared without a , so that it's leaking into the global namespace. Don't do that. As it stands now, your isn't used anywhere in the code. I'll assume it's not applicable here. Instead of manually keeping of your iteration, use the % (Modulus) operator to calculate your rows. jQuery's method doesn't deal with code fragments the way you seem to think it does. actually appends a whole table, not just an opening tag (that's not even possible). Access to the DOM is not free. Every time you hit the DOM you incur some overhead. Try keeping DOM modification to a minimum. Unlike others, when dealing with a simple HTML construct such as this, I prefer to build my fragment from a concatenated string since it's much faster. 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

Since , you should consider using interfaces instead of classes, for object dependencies. And as the "hidden" dependency of : It highly depends of what the framework is for. You've gone for the common practical approach instead of the academic one (injection). There's no right or wrong here, it highly depends on the framework's purpose and audience, the academic approach may not always be the educative approach. 

at the top of your (external) script, and then use instead. Do it for all your objects, even if you're using them once, it will stay with you as a (good) habit. Avoid inline CSS Consider moving all your style declarations into an external CSS file. Other than a slight performance gain (similar to external JavaScript), you'll have all your style declarations in one, easy to find, place. 

Doesn't really belong to the Controller as well. The easiest approach would be to have all your database specific functionality in functions in a separate file: 

checks whether the value is an integer and whether it's a string that only contains digits (thus a integer in string form), any of the two is acceptable for the following check, . I've also moved out of the check, I'm initializing it to zero and will override if and only if there's a need. But let's see what happens if the check is true: 

No need for all that. Just use one bracket group, negate it (be prepending a ), and use the return value directly: 

The method will traverse the DOM all the way up the chain. Rather use the method, which will stop at the first match: 

While using a closure to prevent polluting the global namespace is a good idea, you shouldn't be passing in random data like that. The way you are doing it, you are forcing the reader to scroll to the bottom of the function call before reading the function body - that's just plain confusing for no good reason. Instead, declare the variables regularly within the closure, and assign their values right then and there. That way, it's much easier to read (and maintain), while still keeping the global namespace intact. 

Sane Selectors - There's no need to add all those selectors by hand. Simply use an attribute selector to select all elements that start with a given string. Selector caching - If there's one thing you can do to your code to keep it fast, it's selector caching. $.each - We're using jQuery's helper to loop through the array, since it also supports older browsers ( is not supported in IE < 9). 

is a strange name for a function. It's name doesn't give any clue about what it actually does. Even something simple and generic like would be better. It's a bad practice to use one variable for two different things. and stand for the user's input as a string and then they turn into integers. I'd rather create two separate variables for each of them (one for the input and the other one for it's integral value). 

It does the same thing as your code did, but no "unnecessary" variables are created. Computing the roots and checking if they're looks sort of confusing to me. I'd rather compute the discriminant and find complex roots if it's negative and real roots otherwise. can be simplified to . Comparing the values of boolean variable with constants is considered to be a bad practice. I also do not the point of creating local variables are , and . They are never modified, so I suggest using the method parameters directly. The fact that the output looks slightly differently ( vs ), but has the same meaning seems strange. Is it deliberate? If yes, then it's fine. But I'd rather create a constant format string (for instance, it could be ) and use the method to get rid of inconsistencies and make the code more readable.