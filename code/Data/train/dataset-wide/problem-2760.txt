if I asked for I would get because is a method in the inheritance of Proxy. With this would instead return and add an entry for in the proxy object. One other nit to pick, I would add an underscore in front of and . Putting an underscore in a method is a clue to other programmers that the method is outside the normal operation of a class. In this case it will help prevent name collision with the object you are going to proxy to. The truly paranoid would actually call a method on a separate object to count calls leaving the entire namespace unused. Think what would happen if you tried to proxy a instance. :) 

EDIT2: Here's my implementation packaged within a reusable function. I know this is an exercise and that it's probably not meant to be reused, however it's worth knowing how to do it ;) 

EDIT: Here's another way to create the map without using reduce. Like pointe out by @JanDvorak, the reduce construct might affect readability, however I like it since it allows you to define the map in a single statement, which is quite useful when you advocate using a single statement. 

EDIT 3: Actually I've created a performance test that compares different solutions and it seems that using a map isin't the fastest way and it's actually slower than performing a double replace. I must say I am quite surprised. Anyway, here's the fastest implementation I could write: PERFORMANCE TESTS (includes @200_success solutions) 

Note two things: 1) I do not refer to any special forms, 2) the use of Syntax for hygenic forms. This is a piece of code from Write yourself a scheme in 48 hours: 

I would like to know why one choice might be better then the other, and what is typical in real-world implementations. Reference: My definition of the data type: 

sepp2k's responses are all good, I would add one more suggestion. Your Proxy class should derive from BasicObject (if you use ruby 1.9.x). At the moment any method defined on is by definition not missing. For example given: 

I think you are mixing up different concepts here. Presentation logic is quite different from domain logic and both shouldn't be mixed together. I'm having trouble understanding what you are trying to achieve (what does the checked status means in your domain?), however in my opinion a should be expressed in domain terms and should not have any knowledge of specific ui data such as visible, checked...etc. I strongly suggest you to read about MVC. There are lots of MVC, MVP, MVVM... flavors in JS and that's why we mostly categorize these as MV* rather than MVC now. 

This method could then be called with . Refactoring like this will also encourage you to be consistent in how you build you params hash, and allow you to reuse code. Finally, your question asked about better ways of dealing with hashes. I don't think there is. You will find code very similar to this living in most popular gems. AS you say, it is kind of clunky, and therefore and excellent candidate for a code redactor. 

Background: This began with James Colgan's Lisp-Dojo for Ruby. My implementation can be found here. I then moved on to Write yourself a scheme in 48 hours. This question has to do with one of the implementation decisions. Code: My implementation of 

One of the simplest and probably fastest way to do it would be to store the keys to ignore in a fast lookup structure, such as using an object as a map. First you need to build the map, which takes O(n) time based on the number of keys to ignore, but allows you to ignore keys with a condition that will take O(1) time to compute. 

I guess this plugin could be useful, however I think you can drop the async part since it's not any harder to call directly. Also, I am not a huge fan of error swallowing or ignoring invalid calls since it makes the code harder to debug. If there's a call to without providing a callback, you should let the developer be notified. I also like to allow defining the value for the callback function so that you do not need to use for that purpose. Finally I allowed to return a value from the callback to change the target object for the rest of the chain. However I am not so sure about this feature since it could harm code comprehension but I am leaving it there as an idea. Basically it would be as simple as: 

This code looks pretty clean to me. Here are a few thoughts: I'm not sure what your ORM is (or even that is database backed), but most have a way to fetch more then one record at a time. Making a single call will save time and Database resources. Another thought is that you are inducing a lot of local vars: , , . What about trying to build up the array of ids in ? e.g. 

The code above doesn't seem very DRY because it has all this stuff. If you do things like this a lot (your question makes it sound like you do) factor the operation out into a separate method: 

Something like this perhaps? I've used an object as a map for quick vowels lookups and took advantage of the fact that the function takes a replacement function. The whole transform is done in a single replace operation. Note: I assume that we were only replacing lowercase letters, but it would be easy to handle all cases. 

I would strongly advise you to modularize your code to make it testable an reusable. Since you are using jQuery, you could use the widget factory. I have created an example for you, perhaps it will look overkill and it might be, however it's just an example. Also, I strongly advise you to read how to write testable javascript. HTML