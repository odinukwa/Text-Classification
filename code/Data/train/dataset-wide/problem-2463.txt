Of course, if you created a variable to store the ship position (at start of game), and a single variable to store both the guessed row and column: 

I'll go one step farther than @AndrewAu's suggestion. You dedicate a lot of code and time to iterating rows, columns, and squares. Since these are "fixed" for a cell, why not build some shared data structures and link to them from each cell? That is, in the cell object, create: 

Connecting to other parts of Python Finally, I'll point out that your code doesn't "connect" to other parts of Python. Python's string formatting provides extension points for this purpose. You could create your own subclass to add a conversion flag. Likewise for logging. There is no "locale" support in your code. For example, if the current language is French, what do you do? Also, there's a difference in UK vs. American English with respect to "milliards" and Large Number handling - can you switch? Should you abort, or fail, or ...? How about (im)precision? If I give you 1000000000000020, can I pass a flag that allows you to skip the 20 and just truncate it to the nearest billion? Or perhaps the nearest 10%? How about access to internal data? If I pass a number, can you give me just the largest power-of-1000 word? So I can get "trillion" and print "1.2 trillion" myself? 

Remember, you are writing code for the next maintainer, not for the compiler. You have this while loop that is unclear: 

This is automatically wrong in almost every case. If you want to iterate over the possibles, then iterate over them! Watch the talk, and then write: 

Deleting the 1 node in a 1-node list produces an empty list, which is stored as shown. But now consider a two node list where the last node is deleted: 

Also worth noting: when you invoke with empty parens, it doesn't mean "return nothing". It means "return a tuple with zero items". The expression (note: expression) is an empty-tuple constructor. This is consistent with calling a function with no args, since positional args are a tuple: 

In I think I would have used a multi-line string, so that I could just . This lack of laziness on your part is common - there are a lot of shortcuts, such as list slices, that you aren't taking. In you are using recursion rather than a loop to handle errors in input. This is probably okay in a game for yourself, but in more advanced code this is a no-no. It's possible to exhaust the stack by typing in stupid answers over and over. It's not possible to exhaust a loop. You should prefer that approach. In you repeatedly compute . This is many possible sources of error. Instead, just perform the subtraction one time, and move on. In you have the global board, which I have mentioned. Also, you are not being lazy in your checks for winning combinations. Instead of this: 

If you take a look at the definition of , you would do well to be inspired by that function. Obviously, someone thought about how it will work, and also there's the "principle of least surprise" to consider: why should two search functions have different argument types or return different results? Or even pass their arguments in different orders? Let's change the parameter names, and compare: 

Which got the last of the symbols actually used by Room. Problems in I found the same problem in - the . So I deleted it. A similar solution applies. And at this point we come to an impasse, because your won't compile: 

The problem you are having is most likely due to your code being O(n²) on the size of your dataframe. (It's possible you have a small df and a really bad implementation of , but I'll ignore that.) Let's strip out most of your code: 

Try instead of . If typing speed and such are not an issue, then is a file. Treat it as a file- try reading the entire contents, or using or using . 

Here we have a comment after the code in question, which is annoying in its own right. But what does it do? It explains why some other questionable code is alright. You had written: 

But a better approach is to used named or named-only parameters in your function definition so that the caller spells out some or all of the parameter names: 

(Please note: there are lots of ways to do ownership. There are owned pointers, shared pointers, reference counting pointers, weak pointers, garbage collected memory, and probably a dozen other ways. I'm giving you this suggestion to help you solve this one problem at this particular time. Nothing more.) Enumerating Objects Several of the extra credit items require or would benefit from having a number associated with the rooms and/or objects in the game. The load/save assignment practically requires it. There is no requirement to support deleting rooms or objects that I can see. It seems reasonable then to attach an integer id to each object, and let the class manage them. Similarly, it seems reasonable to have the class maintain the master lists of objects (mentioned above). The only time you would delete objects would be during the shutdown process. It's worth pointing out that the index of an object in the master list is not likely to be a good id, since objects can be dropped in different rooms. Better to track the highest id assigned, and then give new objects an id that's one higher. User class Once you start adding support for picking up and dropping objects, you might as well just create a User class. I think you'll find that much of the code you write for User winds up moving into the class mentioned in the assignment, and then User is a subclass of . Or perhaps they both share a common parent class, since the user won't be loaded or saved (I think?). 

: You are computing a dictionary on the fly, then looking up a tuple in that dictionary and returning the result. If you ever make the same call again, you'll recompute the dictionary and repeat the lookup. Why not cache the results? Build a dictionary of dictionaries, one time at startup, and then just look up values: 

Instead of making an , what if you make it a class? You can then have return what you want without having to cast it. What's more, consider what you are doing: you immediately decode the direction into an X or a Y offset. You then either adjust the variable or . Why are those two variables different? What is ? What is ? Aren't they part of a greater whole, called (or or something)? If you had a type, you could just have instead of and . You might have to adjust and , but probably not, because should be a vector. If is a Vector defined as then you can define addition of a and a in the obvious way (x+δx, y+δy) and then simplify your code: 

Separate your concerns One of the core values of OO programming is "separation of concerns." If your code is trying to manage user input and trying to do something else, then your concerns are not separated. All those try/catch statements for parsing integers, and loops for validating input are potential bugs. Push all that into the class, and write the code one time. If your doesn't have a method for doing "X", then write a method! Maybe you'll see that two slightly different things could be merged together. The idea here is that you should be able to simply call a method and trust the result! If you don't feel like you can trust the result, you get the kind of code you have now - a mishmash of concerns. Wrap that untrustable stuff in a method that does what you need, and then trust that method. The same is true for your other subclasses. When needs a character created, it should be able to make a call and trust the result. If there needs to be drama, or dialog, or uncertainty, try to get that taken care of before you call the factory method. (Hence, a method to talk to the user and then create the character.) If your code is only doing one thing at a time, you'll find it much easier to write. 

Consider the first two comments: "Imports randint function" and "Creates global board list". Those comments are garbage. Of course the statement imports the randint function. It's defined to do exactly that! There is no value provided in your comment - it doesn't explain anything to anyone. Get rid of those comments directly. Never write comments like that. It would be different if you were doing something like 

Looking at your profiling results, I'm a little confused- what order do you have these sorted in? Regardless, let's focus on total time. Pretty much any value that doesn't start with 0.0 in the total time column is a candidate for improvement. The obvious biggie is IntegrationField, but let's look at some of the small values first. One theme that seems to repeat itself is that you can trade space for speed: 

So I'd suggest You hard-code the whole 1-9 thing. I'm not sure that there's much value in pretending to have any flexibility on the size of the board. 

Why does a 1-player game have a function, but a 2-player game is in line? Either create a function that can handle both versions, or create two different functions. You want your code to be "balanced." You shouldn't zoom from details to highly abstract in a single function. So, if you are going to abstract the single-player game (yes!) then abstract the 2-player game as well. Make your code DRY: Don't Repeat Yourself! You say this a bunch of times: Maybe you need a function that reads in a number. Maybe it should take optional min/max parameters. Something like: 

The setting of the array leaks implementation details out to , which should not know them. Instead, I suggest encapsulating the grid construction in a function, (or whatever you like) that just returns the appropriate value. This will let you change how the grid is implemented (see below) without having to know about it in . Change the grid implementation Your grid stores both separator characters and cell contents. Worse, it also stores white space with the cell contents. It would be better to handle the formatting of the grid in the actual function (since that is its job!) and leave the grid data structure to just store data. Get rid of and You maintain two variables that supposedly describe the termination status of the program. You do a bad job of checking them: 

We can use this in reverse: If K=10, as above, then K/blocksize == K/3 == 3 (remainder 1). So the 10th value in the sequence would be 3 blocks plus one non-block number. That is: 

This kind of thing comes back to bite you when you're refactoring. Or, worse yet, when someone else is refactoring. (Imagine you changed the to a , or something. Suddenly the code stops working.) The Task description would (almost) make a good function docblock. Note: s/list/iterable/: 

Once you have put something other than a simple in the code, a future maintainer will be tempted to "just write this inline here" rather than creating a lambda or a named function to encapsulate their code: 

You create a and then throw it away after getting the stats. Why? Why do you keep the but discard the ? Aren't the criteria (and the stats), in fact, attributes of the I suggest that you merge those objects into the interface, and let it decide what or who to dispatch to. (This goes back to me not understanding what a is, and not understanding why you need one.) Laziness is a virtue In your class method you make some web calls. This is a bad idea, simply because creating an object doesn't guarantee using the object. This is demonstrated later in your method. The method sets by calling: 

Depending on whether you want to test or really use it, you just pass a different generator. Edit (responding to changes in the original question): First, note that etiquette on CodeReview is to append your updates, not edit them in-place. When you make in-place changes, that invalidates the answers people posted and makes other readers confused. That said, this version looks considerably better. My main suggestion would be to remove the from (let the display code handle the enumeration), and move into as a method rather than a free function. When you do that, of course, you realize that you could just let the caller access directly, which is fine. ;-) One other suggestion is to make the an incoming parameter for , like: 

It doesn't seem like much, but over time the useless reduction of every operation to basic getters and setters can drag down your code, making it hard to read and/or modify. Don't be afraid to write the methods that you actually need, rather than some basic set you learned in class. (On the other hand, is a good method that does this. So, keep doing that!) 

and get the correct result. Alternatively, you could store your words as strings rather than lists. This would make it somewhat awkward to manipulate them, since Python strings are immutable. But it would again let you simply say, 

Implement a blind method. This method doesn't know anything about the other entity, but it does know it's own type: 

I vote for the latter. (Of course, see my comment about the operator above, and you won't have that line of code at all.) 

You have a very non-specific loop, but a highly-detailed set of operations involving your output stream. I'd suggest that you find cases like this - where you are really drilling down to handle some very fiddly detail - and abstract them into a function whose name reflects what you are doing. Like this: 

Note the changes to , but I kept the subdirectory %d separate to allow Path's operator-/ to do its magic on Windows/Unix paths. 

Your structure seems adequate, but there are a couple of mistakes, and some new language syntax in 3.3 that will make things even clearer: 

This is "interesting" because it appears that you determine that the player has won the game by adding up the index of all the correctly guessed letters, 0 + 1 + 2 + 3 + 4 ... and matching the sum against a pre-computed value. This is so bizarre that I wonder if you copied your solution from a different language. Perhaps in C, or Pascal, or assembly, or just any language with bad string support? Also, of course, it won't work: you start with zero, and you use 0 as the index of the first character. This is a bug.