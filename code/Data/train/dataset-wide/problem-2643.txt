I believe your code doesnt work. If you swap N elements pairwise you end up with the identical vector right? You should only loop until n/2. Do not use It is a bad practice that you should stop sooner than later. Use descriptive names. n, k, np are not understandable by themselves. Finally, c++ now knows std::iter_swap, which directly the values of 2 iterators. so you might wanna use that. 

The obligatory "Do not use "It is bad practice and will hurt you in the long run. So start typing when you need it. Whenever you pass data that should not be modified, pass it as , so that you actually cannot modify it. Also you are passing the data via a copy here, a reference would make more sense. So for example your function should look like this 

Do not use namespace std It is considered bad practice and doesnt save you anything A class with only public members is not really usefull, you might use a struct for that. Also you have open coded the constructor of the node: 

So the obvious hack for digits is to actually read the number into a string and then walk over the characters of that string. You can write your own lambda functions that do the correct thing for a given char and use std::accumulate with them. 

This is most likely responsible for some of the performance problems you have as you are always calculating pointers on the fly. As an example: 

Your bst_create_helper is buggy, as it doesnt do anything if root is not the nullptr. Maybe you just misplaced the curly brace? 

The idea with the offset is okish but not really smart. Why store the offset between two iterators, when you can remember the iterators themself? Then you can simply check whether the second is equal to the first. If not print the element and increment. If they are equal, increment the second iterator until they are not. 

That way you get all the nice things about the container for free. Also note that the container is passed as a const reference, as you do not want to modify it. However, there is still the problem, hat the types of the iterable and the vector might not match. 

What is generally less efficient is iterating over an unordered set. This is because the set is actually a hash table of the keys. So whenever you want to iterate over the key-value pairs, a std::map is generally better. Also what i apparent is that there is one function to do everything. This makes the code rather hard to follow and oversee. You should rather create one function for every functionality you want to implement and build your algorithm from short but clear functions. In your case there are at least 4 natural subfunctions that occur on the first glance. 

If your user provides false input, you should tell him so and not silently assume some default value. 

Generally i would strongly recommend to split keys and values. One possibility would be to create a std::pair 

There are 3 dereferences and one multiplication here and the braces are just hard to read. What makes it really bad is that it is completely unnecessary. 

For the provided sample file this takes 2.6s on my machine. However, there is a much better solution Solution2 The underlying problem is, that we have to traverse the edges on after of the vertices. This is highly suboptimal, as there are generally many more edges than vertices. The solution is to store the pointer to the vertexIndex in the map rather then the vertexIndex itself 

I would definitely suggest to put every name onto its own line and add the explicit type. Its not that you are saving trees here. Do not use else after an early exit. 

I cringe inwardly. In that setting it is really easy to miss the first clause for C >= 2. So why not do 

Every container has a method. I would consider it bad practice to use rather than , as it can have really performance implictations for lists and maps. Please post complete code. You are missing any headers and also the dubious That one you should really ommit in your code and start using proper namespaces. 

That way if you look at the code some time later or when you have a lot of those one character variables you do not have to always look up what it means. It is generally beneficial to sort your includes alphabetically, so one can easily check if a header is included or not. Also double includes do not happen that way. Also try to use the c++ headers aka cmath instead of math..h More in detail regarding the code. 

In your merge function you have an overlap, as i->parent = j; Is set twice. Once in the first else for !(i->rank > j->rank) and once in the second. For clarity i would suggest to use an else if 

Note that I have made the array one larger to avoid the cumbersome off by one of the question. Sieve the leafs array, by walking all the multiples of your caterpillar lengths. 

What happens when unsorted_vector is empty. You check for maybe turn that into Stuff like this is hard to read: 

I encountered a very similar problem and believe i found an efficient solution, that is even better when done repeatedly. In my case we wanted to know the k largest values of an array without changing the array. The approach you took was that you copied the data then sorted that and searched agaion in the original data. What is better is to sort references to the data 

I have to say, that my compiler hat home complains about make_unique. In any case this should work too Now you have to add the links between the houses 

There are some common errors you should try to avoid: In you sort function you already know the size of the vectors, so you can reserve the memory for them beforehand. This prevents frequent reallocations. 

The real beauty about this approach is that it is not only more efficient if you do it once, as you can ommit the second search over the array. It gets even better once you have to repeatedly search, as you can allocate the dataPtr array once and save the allocation/copy of the temporary array during consecutive searches. If I borrow from @Emily L. 

EDIT2: The of a std::set only takes the key as a value. However, one can use and overload the comparison operator. The solution is as follows 

If you look at this code in a year, you will still understand most of its meaning, without having to search for documentation. 

Also you might want to check whether the provided values are actually reasonable if (width < 0) { throw std::runtime_error("Invalid width provided!"); } if (height < 0) { throw std::runtime_error("Invalid height provided!"); } is the same as Declare variables, where you need them. For example is not needed outside the loop. You already know the size of the matrix so reserve the memory to avoid reallocations