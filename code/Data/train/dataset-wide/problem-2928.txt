If you expect your code will ever be used from C++ (which a lot of C code is) then you should not use any identifiers with a double underscore. 

Since we are using a loop we can say lets try and use a standard algorithm. This case we are just measuring the number of items from beginning to end of the stream so the easy one to use is . In this case the loop can be replaced like this: 

Not only can all the "stuff" by factored out into its own function. But those three loops can be combined into a single loop. 

First this means you need to look up RAII to make sure these members are correctly deleted. Second you you need to look up the rule of three (or 5 in C++11) to make sure they are copied correctly. You have owned RAW pointers in your structure. This means you need to correctly manage the object as a resource. This means constructions/destruction/copy (creation and assignment) need to be taken care of correctly. Either do this manually or use a standard container that will do it for you. I suggest a standard container. 

The destructor for that object is also called. This allows you free resources for non trivial resources (say T was a ) not calling the destructor means you are effectively retaining a reference to an object that could be freed. It is perfectly valid to manually call the destructor of an object (In fact this is very normal when pared with placement new operation). 

This is usually an anti-pattern. What happens if the readLine() fails? You should check for that. The normal pattern would be: 

So on first call you are using one past the end. But on all other situations high is the actual end. The idiom in C++ is to use one past the end. So prefer to stick with standard conventions and use one past the end for high in all situations. This simplifies a lot of your code. This is definitely wrong: 

Second this relies on sideeffects of the expression. This is usually not a good idea. Let expressions by simple (with no side affects). Use the result of the whole thing to do the assignment: 

Think about 10 years of maintenance on this code. The code now covers 5 long pages. Try and find and update all usages of . This becomes a pane as will appear in nearly every other identifier in all the comments in lots of places etc. So try and use variables that can be easily searched for. In your ConvertXXX() functions. You are saving integer values into the string. This is fine. But you are then extracting those char values and converting to int for printing. Why not convert the values directly into the characters you want to print. 

The pthread library is a Library. As such it only understands the C ABI. Therefore pthread_create can only be passed functions that have a C ABI which means they need to be declared with . This means you can not portably pass a template function! 

Your descent of the the chain is manual and repeated in any every class. This should be automated in the base class. Each derived class should simply perform the action that you wan them too. This will remove programmer error when a new developer creates a chaining task. Your creation of the chain elements is not consistent. It would be easier to have a method then force every new task to join the chain rather than force every class to have a boiler plate constructor (that can be done incorrectly). You do not always want to chain all the way to the end. On of the handlers should be able to say I have done the final processing stop searching the chain. No memory management (but that was covered by @Mantosh Jumar). Also note using smart pointers helps you with another design pattern (Separation of Concerns). 

What it does do is try and queue an item twice then in a tight loop try and queue it again. I assume you only want an item queue once in one of the lists. Thats not what is happening. Maybe if you tell us what you are trying to achieve (the final result/not what the code is trying to do). Then we can provide help in achieving that. Code Review. Global state bad. 

Both NODE and Stack contain RAW pointers. Yet they do not obey the rule of three. This is very dangerous. The simple rule is your classes should never contain RAW pointers (all pointers should be wrapped in smart pointers) unless you are writing a smart pointer or container. In this situation NODE would be easy to implement using smart pointer. Also you do a work handling node inside stack. It simplifies the design if you move this work to the constructor of NODE. This makes the code in Stack much easier to read as it just handles the stack and the NODE can handle itself. The Stack is arguably a container so it can have a pointer but you must implement the rule of three. This means you need to implement the Copy Constructor/Assignment operator/Destructor or make these methods private. The reason is that if you do not then the compiler will automatically generate these methods. And the compiler generated version does not plat well with "OWNED RAW pointers". 

Does not provide the strong exception guarantee. Learn to use the copy and swap idiom it will save you. Stop using 

WVector& WVector::operator=(WVector x) { //x is constructed by either the copy or move constructor as appropriate Not sure I believe the comment here. You can do this: 

It works. But it is very awkward way of writing it. Thus every maintainer that comes across this code will go "what?". and need to validate that it actually works Your copy constructor calls which calls which relies on the array being already initialized with . This is not the case. Thus this will result in undefined behavior. 

If you are using then is not the correct type (should be ). You would need to make that a wide character. So you are probably looking at another macro to create the correct type. Also the function is for use with char (not wide char). There is a wide character variant called so you may need to use another macro for that. Most functions are in 

A trick that is illegal. Also I am not convinced this does not break the underlying priority queue. As the top value when popped is unwound out of a heap using the compare operation that inspects the internal members of the object. Its not until it is removed from the heap that it is removed from the underlying vector. Really not much else to review. I am not sure what performance things you expect us to find the code here has very little to do with performance. 

You can't call virtual functions in constructors and should not call them in destructors (you may have already destroyed state that the virtual function relies on). You can use the PIMPl pattern to help you out though (like the c++ stream, they use a wrapper class and a buffer class that does the work). 

You are putting the largest element at the beginning. The result is that the partition does not work optimal (you basically are always getting the worst case scenario thus converting an O(n.ln(n)) algorithm into O(n^2) algorithm). Minor things: One variable per line. 

Its not valid. The code will not work as expected as the requires the comparator type to generate a strict weak ordering between elements. 

In this case it makes no difference. But when using class types (like a lot of iterators) the standard way to implement post increment is to do a copy (as the return value) then call pre-increment. Thus it can be slightly less efficient to use post increment when loop variable is a class type. The problem with post increment comes not when you write the code but when you maintain it. If sombody converts the container to a standard container and then converts the loop to iteratos etc you need to spot and change the increment. By being consistent and always using pre-increment changes to the types have less affect on changes to the code (ie it help when types are changed (especially when the type change is a long way from the type being used). You are using as a boolean. Declare it as such and use appropriately. 

From the previous 2 versions: Sign an EC2/S3 URL Version 2 I fixed the comments from the previous version. Most of the code remains the same (so I have split out the new code for review). The main body of the code is provided as reference. The main addition is allowing six flags to be used. Four of these flags allow the addition of more headers and/or query parameters from the command line. One allows you customize the expirey time. The last one allows you to pass the authentication info in the headers rather than query parameters. I think that is all the features I need. Enjoy. 

The other thing to thing about is if the pre conditions fail then how do you report this error back to your called? Also you need to check that malloc() actually worked. If it fails it will return NULL. 

This makes the code hard to read. There is also one corner case (with pointers) were this will not work as expected for beginners. As a result this is usually banned in most companies coding standards. You are using as a boolean variable. Treat it as such. use TRUE/FALSE. I would change the into a loop. Then you can remove all the increments. 

Note: Not all iterators support as an operator. Prefer to use Why erase all then put at the back? You break up space locality in the data if there are lots of pieces being allocated and deallocated in a random orders. 

Prefer to use local variables and pass the board as parameter to your functions. A tiny bit of extra work (but by using encapsulation this work is removed see next comment). Encapsulation This is indicative of not encapsulating your code into a class. 

Now that I have cleaned up the function I can understand what you are doing and it looks like it should work. But it requires the input sections to be already pre-sorted. I am not sure how your double loop in achieves this. 

But if you manually count it. You will find that it happens 9 times. Writting in C++ style I would have used an object to encapsulate the gene fragment. 

In the function entab: You don't detect and thus compensate for '\t' characters in the middle of a string of spaces Thus "A \tB" is encoded as "A \tB" it should be encoded as "A\tB" In C (unless you are explicitly using C99) you should not use // style comments. A lot of C compilers are not C99 compliant but a lot are not C99 compliant and support //. You need to be careful on this usage if you want to be portable. Then is easier written as: 

Though there is nothing wrong here. It is a bit messy. Source is designed to be human readable. So make it easy to read. 

Your code uses a head to specify an empty list. The problem is that your code basically has two versions of every function. Code to handle the empty list situation and code to handle the non empty list. There is a technique that uses a sentinel object. This is a fake ListNode object (with no data). That is always in the list (the sentinel). This simplifies the code tremendously as you no longer need to check for the empty list when removing or adding elements. 

So I can call two different functions and get different results. I see from this interface I am supposed to interrogate the and then choose which function to call? Also those are not functions they get a result without changing the state of the object. You should store your temperature in a single unit (Lets pick Kelvin or any one you like). Then you can compare objects of type temperature quite easily (as they will be on the same scale). When creating a temprature object you can convert the input numbers to Kelvin for starage and convert them to the appropriate form when retrieved. 

You are forcing a move of all the iterators in the vector. Rather than erasing it just free the memory and set the pointer to nullptr. That would be a much better test. You should use exactly the same code for both tests. The only difference should be the allocator used. You should have one test that uses your custom allocator. While the second test uses an allocator that simply calls new/delete underneath the hood. 

I don't think I would have used a class hierarchy to represent the different types of temperature. In the end they represent the same thing (the amount of energy in a system). You should pick a unit to store that data in then covert all types to this global unit. 

Memory Ownership Your code is littered with pointers. This is not a good idea in general (but hard to tell without more context in this case). RAW Pointers are very rare in C++ as they do not convey object ownership. Usually pointers are managed by some owning object that manages their lifespan (as a result you never interact with them directly but via their owning object). You should be using containers of object (not pointers) or if you have object hierarchies then use "pointer containers" that understand their content is a pointer and can act accordingly. If you don't have pointer containers available (they are in boost) then you should at least be using smart pointers to maintain the concept of ownership. Looks like an error: 

While we are taking about types. The and the are part of the type information so they go with the type not the object. This is the inverse of how programmers do it. 

Basically the RAW string can contain the newline character naturaly. So it is easier to write and format as you would expect. 

You are exposing the name of the Saw just so you can sort. I think it would be easier to define the comparison operator rather than expose the internal works of your Saw. 

But in C++11 we introduced move semantics which is potentially faster than copy semantics and Veridic template also allowing you to build the object in place. 

Random numbers Random nmber generation. NEVER call srand() more than once in a program. Call it on entry to main and never again. Don't reinvent the wheel: 

That's a bad comment as I can read the code and see that it loops over the array I don't need the comment to tell me that. Bad comments are worse than no comments. So best to write (this just means your variables and function names should be descriptive so I can read the code and understand what is happening). Code Review. Don't need the {} to default construct an empty table. 

Here you present a trivial case. But not all error checking is trivial. I think a more realistic case (that will happen more often than you think); 

You can use a simple test if you want to do things locally. throwing exceptions is what you do when you want to indicates an error that goes beyond the public interface of your class and thus you can not control how it will be received. Internally you have full control and thus exceptions are not expected. But here you do want to throw an exception and let it escape your class. You do not want the user to be able to construct an invalid object. If the input is bad throw an exception. Force the user of your class to catch and deal with exceptions. If they do not deal with exceptions then the program should exit as you would be running code with an invalid object otherwise. Printing is non mutating. 

Looks like this loop is trying to reverse the string in place. Which will fail as by the time you overwrite the first half the second half is a copy of the back half. Luckily it completely fails because you don't actually use the variable. 

Here you are potentially leaking . At every return point you need to make sure you clean up any allocated memoty. 

You don't need to read the whole program into memory. You use a stream to represent the program. Reading a character automatically moves you to the next location. If you need additional control of the stream you can use seekg() to move around the stream a bit more. Rather than multiple . This is the perfect situation for a : If there is an error you should return 1 rather than 0 so that the inclosing shell notices there was an error. There is a small bug in your back seek: If you have code like this: 

I can't see anything in the sort that other have not already commented on. But lets have a look at your main: Prefer to use and rather than member functions. This will keep your code generic so that if you switch to using C arrays for the code will continue to work. 

You have to note that the "MOST" important part of C++ is the types. and knowing which identifier is a type and which is an object is very important so this naming convention helps you see when a type is being used.