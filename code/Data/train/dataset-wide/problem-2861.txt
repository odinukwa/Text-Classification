Types Given the description, I would assume that the return value is supposed to be instead of .... ... but, you are not using the more general value, but instead the . Always use the most general class type for your interfaces. Also, by keeping the data as Integer values, you are doing a lot of boxing, and unboxing in the loops. Really, you should keep the calculations as Java primitives (), and then box the results if needed. Conditions Your code has a special-case for row 0, where it returns . By preference, I recommend not having special cases, although it is a rule I bend often. Still, after the special case, you then check to see whether it is . This does not make sense because the case returned from the function, so the other condition is useless. Well, not quite useless, it avoids an error condition for negative values. But, the negative-value condition should have been checked at the method start. Basically, it is a useless check. Consider this restructure: 

Your code does not work in O(n log(k) ) time because it uses a PriorityQueue, which has O( log(n) ) time-complexity for add(): 

In general, I am impressed with the test coverage, the attention to detail, and the overall structure of the code. It is easy to follow, and understand. Having said that, there are a few places where it can be improved. processing You code uses directly to set up the help mechanisms, and also for the count parameter. You should consider driving a FlagSet directly. Your code: 

As for the merge method, it is OK, but it is done as a 'pull' mechanism.... it pulls the values in to the final array by comparing the values from the source arrays. I find it easier to use a push mechanism.... Again, hard to describe without code: 

It would be better if, instead of three separate methods, you had just one method that set all three maps.... if you did, the code would look simpler, like: 

Looking through this code I feel that there must be something missing? Does it work? Does it even compile? For example the onClick() method all the places I have marked are 'dead' variables... variables you declare inside a block and are not visible outside the block: 

Separate answer because this is taking a completely different tack. Instead of the knee-jerk reaction to the , consider the following other issues... Logging in Java has been a complicated area for the past number of years.... there's so many different Logger utilities, all with slightly different interfaces: 

Function 2 (and 3) Right, here's your input issue.... you have a big loop, that plays each round, and inside that it has a user-input loop. The conditions on that loop are... confusing. What you have, is a prompt, some validation, and if everything is OK, you . If there's a problem, you loop again. Again, extracting a function with an early return value, would be useful. As an aside, when it comes to user input, it is almost always better to inform the user what input would be valid before requesting the input. Telling them they made a mistake afterwards is great, but telling them what their options are before, is better. Consider these two functions, the first function computes what would be a valid input, the second function uses that information to prompt the user: 

The algorithm you have used has me a little confused. You have sorted the data in-place in the input List. Don't get me wrong, this is a useful thing to do, but I am not sure it is in the spirit of the question.... though, it can be interpreted that way. Assuming your data is sorted, consider the following: 

In essence, you now have a Texture pool, with a clear, and always-safe open/close pairing, and reference counting. Hope that helps. 

At no point in this process have you actually tested that the values you think you changed on the object, actually did change. Additionally, you never tested whether those changes were persisted to the database/store. What I would expect a test like this to do, is to: 

communicate with the server-side developers and try to create a better API for accessing the data (perhaps direct read-only access to their database even?) Decide whether the mobile application is really worth it.... if the data is available on the web, can you not just browse to it using your device's web-browser, and not do anything: 

Right, cool programming challenge. It appears, by scanning your code, that it does logical things in a relatively well structured OO way. I have written code similar to this a few times in the past, and it seems somehow familiar. On the other hand, when I mean 'in the past', I mean before the advent of the API. That API changed much of what you are doing in a way that is far more predictable, and neater. There are some problems.... There is no synchronization on the method. If there is an exception and the copied variable is set to -1, it is possible that the reporting thread will never see the -1 value, and will report the size of the output regarfless. The use of the copied variable needs to be synchronized. Additionally, your code will be significantly different again if you were to use the Java8 streams/lambdas. So, as a review, I would say that using raw threads and runnables, and using simple calls on threads is a real problem here. Rewriting it using Executors and Futures would be highly recommended. Personally I would be happy with an Executor/Future implementation, but a Java8 parallel stream implementation would be recommended by many now too. Because the work is long-running work, it would fit well with the concept of a . Using Concurrent API I am not about to rewrite this code, but let me go through some of the things you should be using: 

In the recursive method, note how it expects there to be invalid values. This is a recursive technique that makes it the responsibility of the recursion to check it's bounds. The alternative is to check the bounds each time before you call the next recursive level. By doing it the way I suggest you can reduce the amount of code you write, but at the small expense of recursing one level more than you need to. The output from the above code, when I run it, is: 

If you want, you can put all the JButton creation code in a new function too, but that may be too much refactoring in your case depending on how much other code is in your method.... 

That way the code is still logical (the product exists), and is also efficient (only one call to the DAO). It is even better if you use functional extraction for the work: 

you identify that a client handler has completed a task (using a blocking queue, and a separate thread?) you register the socket for OP_WRITE with the client handler attached. you get the Write-ready notification, and copy the data on to the socket output. you return the state to Reading 

Your code is asymmetrical.... You open your inside the using block, but you close it outside in the final block.... anyway, the Close is completely redundant: 

This problem is easier to solve with a lookahead combination than with a "match all possibilities" combination. Consider two zero-width lookaheads before the first character. One ensures that each 1 has a following matching 1, and the other ensures that each 0 has a matching 0. if you can guarantee that there are only 1 and 0 characters in the code then you're set. So, your issue here is that you are trying to count mixed up bit values, but separating them makes the logic much easier: 

If you think of that in binary terms, notice how if the bit is set in the first value, we get the respective two-power of the right-value and add it. As we shift the left value, we determine whether it's low bit is set, and we multiply it by the doubling right-value... until one of the values is zero. 

There are no strings in the above, the loop iterates one time for each decimal digit, and well, just works. A second issue I want to point out is with your line-by-line algorithm. You read an entire line, split on the spaces, and from the list of strings, you create a list of numbers with . You then iterate this list, and sum the reverses. A much neater solution is to do a map->reduce operation: 

With the amount of comments in there, it's really hard to understand. Even for the mathematically superior folk (which I am not), you need to supply more information about what your constants are, why they are needed, and how the function works. Given the constants you have, and the way it is hard-coded, I would almost go so far as to say your code could be improved by simply: 

For the most part, that's nice code. I can read it somewhat easily, and for the most part, it is logical, and structured. There are a number of issues in your code, though, some style issues, and some functional issues. First up, the style issues. Using the existing libraries There's a nice feature in ThreadLocal in Java8 that allows you to have a supplier for the structure. Consider a method like: 

For your performance problems, taking nearly an hour really is a problem. The reality is that your code is not the biggest problem, but the overall algorithm.... Making parts of your code faster will not do much, but making your code do things in different ways will help. Non-performance problems 

If this is true, you have to start from the source. Database performance is almost entirely related to the amount of data that gets moved around, how much space you have to move it around in, and how fast that space is.... (memory being the fastest space) If your data is more compact (i.e. you do not use fixed-length fields unnecessarily), then: 

The methods take some input parameters that are not part of your specification. This is to ensure single-responsibility is maintained. The exception handling is still not great, but would need to conform to your overall system. Consider the methods... receiveFile: 

scan the matrix cell-by-cell if you encounter a 1, use recursion to follow all it's adjacent 1 values mark all visited cells as 'seen' consider that process a 'hit' for an island scan the remaining unseen cells for the next unseen island. (go to 1). 

I am aware that heuristic approaches to the N-Queen problem are faster, but answers that rely on heuristics to solve it are not as interesting to me as solutions which improve the brute-force approach. 

I like how the Functions have simplified the enum, but, you have put logic in the implementation class that belongs in the enum.... The code: 

So, it is unusual to make the recommendation I am going to make here, but, in this case, is Python the right tool for the job? I took your code, and looked through it, and also ferada's version. Really, they are pretty good. I suspected that there is a problem with many writes to the file, so I 'batched' the writes up in to 1000-at-a-time IO operations, expecting that to be where the real time is spent. There was not any change in performance (I tested by using just 5 character wide outputs). Using the 5-char wide output, I calculate about 5.778 seconds on my computer. times that for 8 chars, and that's more than 28 hours to run. As an experiment, I did the same in Java. Now, Java is not the fastest compiled language, I know, but the process is compiled, not interpreted, so, what could it do? 

The above line is critical to your program.... but, it does not check for errors.... Did the pbcopy succeed? So: 

Well, your code is hardly a bash solution, is it? You use , , , and .... Additionally, your code is dumped on a single line, and it makes it hard to read. Why not put it in a script, and have separate commands on separate lines.... like: 

That code takes an input value , multiplies it by 10, adds 4, and then divides it by 10 million. Consider an input value . Take that, multiply by , and add , to get . Now, divide by million, to get . Now, round that value to 6 decimals, and get: , right? Then multiply that by 1 billion to get Unfortunately, the actual result is: 

do you need to do the transfomation at all? is there a native implementation that can help - perhaps one which uses a lot of parallelism to process the data in different chunks? I am sorry I can't be more helpful in that aspect. Can you do things a pixel at a time instead of pulling the whole int array (I tried this in Java AWT, and it was slower....). I used this code: 

Note that this creates only two int values.... and it loops once per digit. I tested it, and it is about 4 times faster than the String version. 

TDD A TDD strategy starts with the tests, and I don't see much evidence that the tests came first, in your code (not saying that it didn't come first, but that the evidence is absent). A good TDD strategy will identify the anticipated issues early, and I don't see these cases: 

Now you have a small table with just a few years in it, instead of 3,000,000 records. You have scanned the table just once to do that too. Now use that table to build your SQL select clauses.... 

Finally, about the algorithm. I am not convinced that it works... I have not run it, but I am pretty sure that the compareTo methods are the wrong way around... they should be and not ).... 

Target frames-per-second is 60. Now, 1000ms / 60 is 16.666 milliseconds, except, it's not. It is 16ms because you are doing integer division. So, your frame period is set at 16ms... with 16ms frames, you get and actual FPS of 62.5 FPS. But, later on, calculate the current time in milliseconds as: 

Now, it is much easier to see the structure. Java code-style guidelines put the opening brace on the same line as the control statement, so, for example, the code: 

Your code here is pretty mixed up and is not representative of a decent test of concurrency. It will work and give you the results you expect, but the reason is a bit polluted. The internal code for looks like: 

Note that there's no longer any magic numbers. You get the number of quotes from the actual number of quotes, not from a hard-coded value. if you have 10 quotes it will work fine, if you have 1000 it will work equally well... Now, if you take in to consideration the comments from @tim, you will also be able to extend the actual String quotes in to Quote and Attribution Objects, and make the program more object-oriented. 

Now your class can have just one data store, and you can save each IDRole twice, once with the ID key, and once with the Role key. 

I can't see a way to simplify the logic further, and easily keep it readable. The performance impact of the multiple boolean checks (even if the early ones set to false) will be small. There's no real reason to go to extraordinary lengths to prevent it. 

Now no other thread can lock, or unlock that instance, and will just hang. You should instead use a private monitor: 

This function may, or may not, do both. The JavaDoc indicates that this function will return the value that occurs more more than half-the-time, and that if there is no such element, the result is undefined. This makes the method useless, because anyone calling the method will then have to re-scan the entire data set to see whether the method is returning a right answer, or an undefined answer. Since repeating all the work to check whether the method produced a reliable result or not is required anyway, you may as well do it in the method itself, and then return a result which removes the non-determinism. 

Why do you need the function? To measure the distance (in miles) between two points? Then you want to select all points of a certain type and order them by distance from a given origin. With a CTE (common table expression) you can simplify things a lot too. But, the real issue, is that you should use the functions already available in the geography datatype: STDistance. This STDistance function returns the 'LineString' distance, which is 0.25% accurate to the geodesic distance. Additionally, this is better than the 0.5% accuracy of the Haversine distance. So, by the sounds of it, you have horribly overcomplicated this process. Consider this (SQLFiddle example here too):