In your case, you should write instead of . A bit of scafolding In order to improve your code, it is a good thing to split it into different parts. Here I have splitted your code into functions. I took this chance to move the part calling functions behind an guard. Also, I have hardcoded some values to make testing easier. To make things better, the different functions should be documented but I can't be bothered. 

This is pretty much all I have to say about the code. Now, I think it might be worth commenting the algorithm a bit more. 

Other comments have been given about the code you actually care about :-) Likely to be a bug Once probably wouldn't expect neither , nor to be affected by your function. However, might get updated. This is definitly something you should try to avoid. You could write something like : 

Optimisations : different algorithm You are using some kind of cache to remember the different numbers you've checked and this is a good idea. Also, you are using a quite efficient way to check if a single number is prime, stopping at . However, the best way to do this would probably be to implement a Sieve of Eratosthenes : we build it once and for all and we don't need to compute things later on. This is especially convenient here because we know that we will not need to check for any number bigger than one million. This is already much faster : 

Iterations The pythonic way to iterate is to use the keyword, usually without bothering about indices. I suggest you have a look at the presentation : Ned Batchelder: Loop like a native: while, for, iterators, generators (PyCon US) (video on Youtube/text with slides). In your case, most loops can be rewritten. For instance : 

Your code does seem to follow PEP 8 which is a good thing. Also, the logic is splitted in different small functions which is even better. If you want to make your code portable, you probably shouldn't hardcode in your path but use os.sep or even better os.path.join instead. In order not to call multiple times, you could use writelines. Now, from a functional point of view, it might be a good idea to create temporary files with tempfile for instance. If you don't want to use it, it might be better to use a hash of the original url or of the content and use it in the name of the new file. 

Good reviews have been given and I have nothing to add. Edit : additional details for what it is worth : 

It doesn't get any more concise that this. String formatting Instead of using string concatenation, you can use string formatting : 

Code organisation and other things well done You've extracted the algorithm in a function on its own. Also, you've written you code behind the "if name == main" guard. Congratulations on this, these are two good things beginners usually don't do properly. This makes your code clearer, easier to maintain and easier to test. Also, I'd like to take this chance to congratulate you for using as a name for a throw-away value which is quite a nice habit. Finally, you did notice that there was not point in looping over the whole string once you've reached the middle. Getting rid of useless things 

I'd suggest having a look at Why Your Python Runs Slow. Part 1: Data Structures as it seems to apply to your code. 

Style You probably don't care much about this but your style (spacing for instance) is not very consistent. Making things easier to improve You'll make your code much easier to improve if : 

Python gives you an nice and efficient way to do so with List Comprehension : . In your case, you could write : 

User experience From a user point of view, it would probably make sense to stop amendments when ig given as a line_number. Having 2 questions asked to exit is a bit un-natural. Separation of concerns It is a bit weird to have the function to ask the user for a file name. Also, we have the logic in 2 places. A better idea would be to have the file name given to the function. Performing simple substitutions, we have : 

From the function, you probably don't need to call as the loop from the function should handle things properly. 

On the test example, it seems to work. On other cases, I obtain different results than your code so I don't know which is correct. I've used a dict to map characters to a list of position but a mapping from characters to number of positions would have been enough. This corresponds to using the Counter collection) 

I am not quite sure which variable(s) is (are) useful but let's try to improve this in such a way that code looks easier to understand but it really does the same thing. First thing : the can be factorised out of the two branches in the block (you might want to use the keyword for this step). Once this is done, you have a test with an empty block, it might be better to negate the condition. We now have this : 

I am not an expert in network so I will comment on the part that doesn't interest you that much. On top of that, your code is pretty clean, well documented and seemed to work properly when I tried it locally so there is not too much to say. You should try to avoid magic numbers to keep things maintainable and any other kind of hardcoded data in the middle of the code. You could put server and client in the same file in different methods. You have unused variable. An easy way to notice it is to try to put declaration as late as possible, in the smallest possible scope and as close to their first use as possible. Also, compiler warnings might help you. I am not sure you are cleaning ressources (files for instance) properly. This needs a lot of re-writing to do this properly so I'll leave this for you. After a bit of tweaking here and there, here is the code I have on my side : 

The right data structure The way you build , it might contain the same value multiple times. It is something we might want to avoid because it will not bring anything except performance issues. Instead of using list, you should use sets. 

Try to extract the different pieces of logic in functions to make things clearer. In your case, you have defined little functions but the place where you are using them is a bit in the middle of nowhere. Here's what you could do : 

My point is to just take into account the fact that a time is just a value and a unit. We store the value in the easiest format and we convert it on demand. No conversion is actually required for comparison. Adding a new is straightforward (assuming there is a constant factor to multiply - month and year wouldn't work because they do not always last the same time). 

Documentation You should add comments at least to describe the program and the different main functions. 

Tests Your tests are complicated because of the amound of calls to , in particular testing a random number of times. I'd also suggest using a real testing framework. It would be a nice youch to also test explicitly edge cases : empty list, list with one element, list with the same elements multiple times. Finally, instead of calling multiple times, you could use . 

Trying to generate the actual string representation is interesting to understand the problem but you do not need to keep all that complexity in your code for problem 26. Indeed, you are only interested in the length of the cycle for . Thus, what I did was to : 

Simple mistake The function takes a filename as an argument but doesn't use it. Instead, it retrieves it from . Also, would be a better name for a filename than . 

Your code seems to work fine and it somehow well tested (even though one needs to compare function outputs visually). A few details can be improved anyway: Indentation and spacing The indentation seems to be a bit off in a few places. Also, a few blank lines seems to be in places where it is not very relevant/helpful. Naming Function names such as are not very easy to understand. It would be easy to find names more meaningful such as . Useless temp variable Using variables for printing does not add much. You could just use . At this stage, the code looks like: 

This looks good but there is still a major property that we probably want to check: there should be nothing but 'IVXLCDM'. We could add a condition . 

Yet another way to get the best results Another approach could be to start from the same element than previously and to try to reduce it. At each iteration you keep elements that are still valid: 

This can also be reused in other places but I'll let you deal with the pleasure of doing so. Do not repeat yourself Do not repeat yourself. Do not repeat yourself. Many things look wrong in : 

Your code does not do anything in the request method is not GET, is this normal ? Should it raise an exception ? 

Here, 'len' is called only a few times. I'll keep on working on the "slow" versions because it is a better starting point for your investigations but you know what you can do when it works. Rewrite interval checks Computing is slow because we'll compare to many values. What you want to know if just if i is bigger than 100 and (stricly) smaller than 1000. Python has a cool way to write this (you won't find this in all programming languages) : . 

Split your logic into smaller functions. In your case, one can easily see that and are good candidates. 

Once, this is done, it seems quite clear that the first list comprehension is not really required neither as it could be : 

It is quite hard to understand what your code is supposed to do. Let's try to progress little by little. I've based my analysis on the test cases you have provided. 

Realistically, you could use a proper test framework or just but this is enough for the time being: we have the base cases tested and we have a small, well-defined function with a clear input and a clear output. It is now much easier to improve the code. Boolean conditions Instead of writing (or ), you could/should write (or ). Also, it would make sense to re-organise the checks and conditions to write/compute a minimal amount of conditions. Also, this makes obvious the fact that we never reach the end of the function. 

You could also write this as a single set comprehension. Set comprehension is a convenient way to define set (you also have list comprehension and dict comprehension and even something called generator expression but this is out of scope at the moment). It usually goes like this 

It is the time I realize that I shouldn't have inverted all conditions at the very beginning as the whole thing can be rewritten : 

First step : functions and tests The very first thing you probably should write is a function computing what you really want : a sum of primes. Also, a value is provided as part of the problem, use this to write a test : as soon as something goes bad, you might notice it. 

Your code looks very nice and is well documented. Also the intent to avoid boilerplate code while keeping it understandable is both notable and successful. Here are a few details I would change anyway. Consistency For some reason, this particular piece of code 

Do not repeat yourself The check appears in multiple places. Maybe it would be easier to move this into a function. Also, this could reuse the constants like the other parts of the code: 

You don't need a class I wanted this to be the first point but it was easier to find details first. So let's make the point clear : you don't need a class. Having a structure containing the name and the url adds complexity for no good reason. Also, it makes code hard to reuse if was has to create and instance. Plain old functions passing data around are more than enough for you : 

On the other hand, many functions are much better when written in a recursive way. This is the case when it's easy to see that we call the function on a "smaller" problem. 

Style You code does not follow PEP 8, the usual Python coding convention. You'll find tools such as (or its online version), , or to check for this and other points that might make your code cleaner, more idiomatic or more correct. I can't be bothered to break the too long lines nor to fix typos in the comments but I did perform the other changes so make happy. The result is : 

The very right data structure In order to use to implement efficient algorithm, you'll need to preprocess your data into something relevant. Mapping user names to the set of users they mention is likely to be required. Here's a piece of code to do so : 

Now, let's have a look at . First thing I noticed is that it has a quite confusing name as it can make one think that it will be about computing hashes. Also, it returns a dictionnary for no obvious reasons : a set would probably do the trick here : 

I don't really understand what your code is supposed to do but I can see some room for improvement so let's go! Style Your code looks good and PEP 8 seems to be respected. I find the spacing in the argument lists a bit unusual but he... Also, your functions probably deserves some documentation like docstrings for instance. Improvements is not needed here. 

Using the right tool : at the moment, you are using Lists for and . Lists are fine but in your case, you have better things : 

Another thing that could be changed but might not make the code clearer to every one is the way you get the n-th element of the reversed string. You can use like you did but you can also take the most out of Python's index handling : negative indices are taken from the end of the container. So that you can write instead (and the same principle applies to ). 

A different algorithm could be written using a different data structure like a dictionnary or a counter. 

and no more small functions. A more Pythonic solution/option Using properties, you may be able to implement a solution computing values when you try to access members and they are not set yet. 

Use enumerate Enumerate does exactly what you are trying to achieve : keep track of the index while looping on an iterable. Just use . Remove levels of nested logic Using , you could make your code a bit easier to follow. The inside of the becomes : 

Now, to comment on the style, you should use to compare to None as per the style guide PEP8. After changing these and many other details (provided by the tool pep8 checking for various style issues such as spacing, line length, etc), I end up with : 

You don't need a class (again) At the end, the class is not needed anymore. Everything can happen from the function. It would go like this : 

You can easily see what are the partial lists we are working on by removing the call to max. (To be fair, I first wrote that piece of code and then tried to reduce your code to this). Once you have this, you have an easy solution that you can use to compare results while implementing a different algorithm among one suggested in the comments. 

Style A few things are unusual in your code regarding style. I suggest reading PEP 8, the style guide for Python code. Among the things I'd change: 

You could also use some recipes to iterate over consecutive pairs. Then, you'd get rid of the boundary check altogether: 

In , the loop is very unpythonic. The very point of the loop as it is defined in Python is to prevent you from having to deal with indices. 

Usually, splitting your code into different smaller functions is a good idea as it makes things easier to read, to reuse and to test. However, this comes at a (cheap) price as far as performances are concerned because functions calls are not for free (nor are function definitions). Now, for additional advices, whenever you want to compare performances of functions, it might also be a good idea to return what they compare. It's not good having a fast function if it doesn't return the right thing. By using , you could ensure you get notified quickly whenever something goes wrong. This being said, I'd like to run and comment your code but I don't have a python3 handy and it seems that it is the version you are using so I'll try to do this later :-)