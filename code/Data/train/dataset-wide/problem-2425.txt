The first should round down to 12012345.0f; the second should round up to 12012346.0f. It's not necessary for the function to perform extensive calculations on the input string; it would sufficient for it to observe whether there are any non-zero digits past a certain point, but the logic to handle all the cases is apt to be tricky. 

I would suggest that the outer routine should receive a delegate which is called when a problem is detected, before an exception is thrown by, or allowed to propagate beyond, anything but the lowest-level code. The code within that delegate can hopefully receive as parameters whatever information is needed to proceed sensibly from that point; the caller of the delegate can then--based upon the return value from the delegate--either retry the operation or proceed as well as possible without it; alternatively, the delegate may throw an exception to cause the outer-scope action to be aborted (possibly after recording somewhere information about how or where the action should be restarted). 

Is a object supposed to represent a kind of card (e.g. "spade jack" or "diamond six") or is it supposed to represent an entity which can only be in one place at any given time? For example, if you shuffled together two decks, and the top two cards of the shuffled-together deck are both "club queen", should those be represented by the same object, or should one card object represent "club queen which is at position 0 in a particular deck" and the other one "club queen which is at position 1 in that same deck"? I would suggest that you define a concept of a "card container" [used for hands, decks, etc.] and then define a "card" to be an object which has a suit and rank, and always sits in some sort of card container, but can be moved from one container to another. Each container should have a means of identifying the cards which occupy it, and each card should have a means of identifying the one container which contains it. Moving a card from one container to another should cause it to be removed from the former and added to the latter. 

Interesting design. Performance could probably be improved by allocating a couple of large buffers, and reading large blocks of input alternately into the two buffers until EOF is encountered. At that point, count backward through the two blocks until the proper number of newlines have been found, and then print everything from there to the end. If the input happens to be a disk file, one could seek to a spot near the end and count the number of newlines from that point on; if there aren't enough, seek back some distance and count the number of newlines between that point to the previous seek point. This would allow "tail" to operate efficiently even if the input is a multi-gigabyte disk file. 

Of these, perhaps the first would be most justifiable if one says that degree-polar objects are unequal to any xy object except when the angle is a multiple of 90 degrees, and radian-polar objects are unequal to any other object except when the angle is zero. Even though the closest to the polar-degree object's x coordinate is 1.4142135623730951, the actual x coordinate is closer to 1.4142135623730950488016887242097, so it won't quite match any point whose xy coordinates are specified using a . Unless there's some particular reason for using polar coordinates, I'd suggest having the type explicitly encapsulate an and , both of type . Use fields for those and set them in a private constructor. Even if you have other methods which can construct a point for a given radius and angle, or report the radius and angle associated with a point, make it clear that reported values are not inherent properties of the object, but simply calculations based upon its x and y. 

Deleting an item from a singly-linked list requires finding the previous item. There are two approaches one can use to deal with this: 

It would be nice if there were something "between" a and an , which would be recognized as having an integer type as its underlying representation (like does) but could also control what operators should be available and how they should work. One could, for example, specify that it should be possible to add an integer to a day, but not add two days together. would allow both with casting, and neither without casting; a sensible type should allow the first without casting, but not the second. 

Class properties have significant advantages over class fields, and a class which exposes autoproperties rather than fields can easily be changed to use "normal" properties later without affecting any of the calling code. Structure properties do not offer those same advantages, however. The only times a struct property has a real advantage over a structure field are when the property is defined as doing something that could not be accomplished by reading a field (in which case an auto-property wouldn't be suitable), when the structure needs to implement an interface that exposes a property, or when the struct has to be usable with code that accesses properties via Reflection. A structure is, fundamentally, a collection of independent variables stuck together with duct tape. Given variables and of some structure type, the statement will mutate X by overwriting all of its instance fields with the values of the corresponding fields in Y. This mutation is done without regard for whether any of the fields are public or private, read-only or mutable, and there's no way the code for a struct can do anything about it. If a structure allows all its fields to be read, and allows the creation of a struct instances with any combination of field values, then the structure will be semantically equivalent to a structure which simply exposes its fields, and it may as well do so. Only if a structure has private fields whose values cannot be observed, or imposes restrictions on the values fields can take, is it helpful to do anything else. Otherwise, the fact that struct fields may be overwritten outside the struct's control limits the value of making structures pretend to be immutable. 

There are only 120 possible permutations of five items; if one starts by ordering items 1 and 2, and items 3 and 4, that will leave 30 permutations, which can then be sorted using five more comparisons. If you're worried about speed, use explicit operations on the five items rather than using loops. 

I would suggest using an immutable class rather than a structure or, if you'd like something whose default value is rather than , use a structure which wraps a reference to an immutable class object (and say that it's undefined if the reference is null). Although this will entail some object-creation overhead when performing math on rational numbers, it will allow the code to avoid having to call after every operation. Suppose, for example, that one wants to add together the fractions (1/12)+(1/12)+(1/12)+(1/12) and output the result. Although it will be necessary to simplify the result before it can be displayed, simplifying the partial sums will be not only useless but counterproductive. Since all the denominators match, adding all the above numbers should require three additions and zero multiplications or divisions to yield 4/12. If the first sum is simplified to 1/6, it will have to be converted back to 2/12 before the next addition. If that's simplified 1/4, it will have to be converted back to 3/12 before the last addition. A lot of extra work. I would suggest using an externally-immutable class with fields for "originalNumerator", "originalDenominator", "reducedNumerator", and "reducedDenominator"; the latter two would be initially zero, but could be lazily computed from the first two when required. I do not recommend overwriting the original numerator and denominator, since immutable classes are generally expected to be thread-safe; if the object had held 3/12 before simplify was called, and another thread examined it at that moment, it might erroneously see 3/4 or 1/12 depending upon whether the numerator or denominator was updated first. Having separate fields for the reduced value would mean that if a thread which sees either field as zero (when originalNumerator and originalDenominator aren't) calls , then two threads which examine the same non-reduced value might call simutaneously and end up doing redundant work, but everything would still behave correctly. An advantage of using a class object over a structure is that if repeatedly performs operations on a non-reduced structure, the code performing each operation would likely receive a copy of the non-reduced structure, reduce it, act upon it, and then discard the reduced copy. By contrast, if each operation is performed on a class object, the first operation would perform the reduction and subsequent operations would then be able to use the reduced form. 

The general form of the problem as stated is NP-hard, since any 3SAT problem (i.e. $URL$ ) can be easily reduced to a problem of the stated form. Simply use one column per variable, have a line of all "2"'s with a score of zero, and one line for each predicate with a score of 3, using a three ones or zeroes for the variables of interest and twos everywhere else. Although many problems of the stated form may be solved in reasonable times using a combination of heuristics and backtracking, such approaches are unlikely to be effective on a problem which was designed to be difficult. I'm not familiar enough with Project Euler to know how hard its problems are designed to be, but would not be surprised if a program which could small problem nearly instantaneously might be unable to solve the larger problem in less than a century. To solve problems of this size, I think it will be necessary to draw more extended inferences by identifying rows whose numbers are related. Toward that end, I would suggest that the data format for your rows include the ability to specify a range of scores, and for each space within a row identify any combination of possible digits. I'd suggest probably using for each space a bit-coded integer. For example, if a column had a value of 18 (2+16--bits 1 and 4 set) that would indicate that that column should add 1 to the score if that digit was a one or a four. To see how this would work, suppose you were given the rows: 

Allowing code to derive inferences like the above is likely to go a long way toward making these puzzles solvable. The tricky part is knowing when additional inferences are likely to be useful (and should be added to the list of constraints), and when they become redundant (and should be removed from the list of constraints so the code won't waste time with them anymore). Note that development of inferences goes far beyond checking off possibilities as inconsistent with constraints. Since the starting set of potential 16-bit numbers is humongous, building upon constraints is the only way to reduce the problem to manageable size. 

If another line of the file was 1111111144444444 3 one could infer from that that since at most one of the first 8 digits could be correct, and at most one of the last 3 digits could be correct, at least one of the five digits between had to be a four. 

What are people going to want to do with , and are they going to have any expectations about how it should behave if the underlying data changes? If the intention is that code which reads isn't going to use it after the next time anything changes, you could have each instance of your self create (or lazily create) an instance of , which holds a reference to its creator along with a "change count" and possibly the number of items in . Methods and properties of would ensure the wrapped object had not been modified, and would then use that wrapped object as a source of data. The indexed getter might look something like: 

If a class is supposed to serve as a data holder, two instances which report themselves as equal should have the same properties; further, values corresponding to constructor/factory parameters should match the values used in creating the object. It would be possible to have a polar-coordinate type whose properties were the rho and theta values, or an xy coordinate type, whose properties were x and y, or perhaps even an abstract coordinate type with subtypes that hold degree-polar coordinates, radian-polar coordinates, and xy coordinates (each of which would store a different set of properties). Defining how the latter should work, though, could be tricky. Consider what happens, for example, if one constructs a point with polar coordinates (angle=45 degrees, radius=2.0) and then constructs another point whose xy coordinates match the first. Any possible behavior by the class is apt to be "surprising", since the xy-constructed object will have a radius of 2.0000000000000004; this means that either: 

Contrary to what some people say, there is nothing fundamentally wrong with having an inheritable immutable class provided that the inheritance contract dictates that if two or more instances are ever regarded as equivalent, they must always and forevermore be regarded as equivalent; further, the class must work correctly without complaint or visibly altered behavior if some or all references to an object are replaced with references to a object which is considered "equivalent". A class won't be able to prevent the definition of illegitimate derived classes that violate its inheritance contract if its methods aren't declared , but since it won't be able to prevent the definition of illegitimate derived classes even if its methods are , so making the methods doesn't particularly matter. What does matter is that the inheritance contract specifies that all derived classes must be fully immutable not only in their inherited fields, but also in all observable characteristics, inherited and otherwise. If a derived class doesn't abide by that contract, code which uses the derived class might malfunction, but the fault will lie entirely with the derived class that violates the contract. It is probably a good idea to make immutable types if one doesn't want to specify exactly what will be required and may be expected of any derived types. There are, however, many situations where it may be helpful to have an abstract base class or interface which specifies that all legitimate derived classes or implementations will be immutable. For example, one might define a class or interface with members to get the dimensions or read the cell at any (row,column) coordinate. Although the most common implementation might use a 2d array as a backing store, there are many different ways that derived classes might store information. If were a class which used an array as a backing store, then all objects that were usable as type would have to have a backing-store element for every cell even if 99% [or for that matter 100%] were blank. Making it a non-final class would make it possible to define derivatives like which could use a much simpler backing store.