This is a very nice routine that totally succeeds in using a direction flag set to 1. I've seen others fail at this. Some observations: 

I don't know what happened here, but I think the compiler ought to give you the sign-extended version of this instruction automatically. Bytes 83h,C6h,60h. 

Extensibility I wrote these programs with extensibility in mind. If the number of test cases increases, the versions that use an elimination process or a binary tree, rapidly become more complex. The version that uses decrementing counters can be modified easily. But the version that uses a lookup table needs very little change indeed. See how I gracefully didn't use the , , and registers so they could easily be used for the 4th, 5th, and 6th test cases? Why then not try your hand at FizzBuzzGoYesWeCan (dividers 3, 5, 7, 11, 13, and 17)? Using prime numbers guarantees every tag will show up by itself at least once. 

Using is certainly not wrong, but the optimal way to check for any inappropriate counter value would be to use the instruction. 

Avoid redundant operations. In your most inner loop you keep checking if CurrentPrime exceeds 2000000, but you forget that the value of CurrentPrime does not change within this inner loop. Best move the test above the next_prime_test label introducing an additional label MAYBE_next_prime_test. 

The part where you copy the filename can be much improved by using the string primitive instruction. You load the desired amount in and then repeat () the operation. The direction flag (DF) is cleared beforehand to force the CPU updating the and registers moving up in memory. 

We always strive to get the smallest code without loosing readability. I think next snippet does a good job (it's 2 bytes smaller and well commented): 

You can easily address the 2 previous array elements by adding offsets -4 and -8. This liberates the register that also no longer needs to be preserved. 

You didn't initialize the register because you know it has the correct value from the code above. That's fine but given the separation between setting it up and using it, and considering the note you've included, ... 

This console application uses the Rich Edit Form Input procedure for which you can find the source here. It presents the user with a dialog that has 5 input boxes and 2 buttons. The dialog is drawn differently depending on screen width. You use TAB or SHIFTTAB to switch between fields. ENTER and ESCAPE have their usual meaning. The program supports both input redirection and output redirection. 

In code like this there's no need for an explicit as the preceding already defines all the necessary processor flags for correct operation of the following . 

A simpler way of converting follows. It uses less labels which is a good thing for readability. It uses less jumps which is a good thing for speed. 

You would better move the instruction below the . I don't believe there's too much guarantee that api calls keep interrupts disabled! I get it that you're trying to write compact code, but it's a bit back-firing here. In you only write the low half of the register because you cleverly know that the part is still empty from the code before. What you forget is that the single instruction only requires 3 bytes whereas your pair of instructions requires one byte more. Because by now you're committed to using what's already in , you write a somewhat obfuscating where a simple would have been so much clearer. 

With so many open issues I was at first reluctant to start reviewing this program. It's certainly a good thing that you know these issues exist, but I would like to advice you to not defer implementing at the very least checking the error status that you obtain from selected BIOS system calls. Disk systems are delicate enough that we should not ignore reported errors! As per request I've focussed my review on the matter of robustness. There's a BPB_BytsPerSec. The fact that your program is "hard wired" to use 512 bytes per sector speaks by itself against robustness. The BIOS Parameter Block has a field that tells you the count of bytes per sector {512, 1024, 2048, 4096} 

Does your assembler requires you to write this redundant mention of the size? Do you get an error if you write it shorter? 

Note that I didn't use the register like you did. Because the pushall and popall macros don't actually preserve it, this could easily become a death-trap! Although using macros to push/pop registers is easy, it also brings about pushing/popping too much, like in this code the register that isn't used at all. 

The optimization The most important optimization that you can apply to your program is making sure that the qword value that you write is aligned on a qword boundary, so a memory address that is divisible by 8. The extra alignment loop will at most iterate 7 times. 

Given all the things you want to do, and all the devices you want to interface from within this 512 bytes bootloader, you should take more steps to reduce the footprint of this error reporting routine. 

This is a misconception. The following only depends on and for its operation. It will leave a result in DX:AX, but does not have to be initialized beforehand. 

Check out The program that you wrote only uses 8086 instructions. Perhaps this in intentional. But if you're interested, x86 has a very powerful instruction that 

I don't see how this comment relates to the control variable being 6. It just by-passes the output, which is wrong because the number 6 fulfills the conditions. 

You've used the register to set a bit in a stacked number. This can be optimized by writing . Although this instruction requires 2 extra bytes (ASP prefix and SIB byte), you gain 4 bytes from dropping the , , and instructions. There's a trade off here. If in a similar situation, you were to manipulate several stacked values in a row then using would be shorter. 

I found it remarkable to see the directive so far down in your program. I would have expected this almost at the first source line! 

All of these instructions are correct. When the first instruction is being executed the PC is at x3001. Adding x001F to it will correctly address location x3020. When the third instruction is being executed the PC is at x3007. Adding x001B to it will address location x3022. From the manual we learn 

Conclusion As you can see it's possible to optimize this code a lot, but I think the best advice I can offer is that all these macros really should have been written as subroutines. In this form the program is simply too long for what it does. I tried to not repeat comments that I made on the previous (shorter) review. Obviously they still count. I'm pretty sure that if all these modifications were applied correctly, and thus shortening the program considerably, more advanced tips (especially on program flow) could be given. 

In its present form your program entirely depends on the values in and having a permanent meaning. If your program were to become longer and more complex, this would no longer be a desirable approach. Then variables would be in order. An example on how to use these: 

Not only does this clobber the registers , , and , it also uses the instruction variant that produces an 128-bit result. Intel advices against this form when the upper 64-bits of the result are not needed which is the case in your program. A better multiplication then comes from using the 2 operand form of . 

It's practically never needed to zero the registers prior to using them. And if ever it would be useful to wipe a register clean then -ing that register with itself will produce the same result more efficiently. e.g. 

You load your boot program at linear address 00500h. That's fine but stay aware that BIOS has its PrintScreenStatus flag here. That's why so many Operating Systems start at linear address 00600h. 

When the counter in is smaller than 8, you jump to SetupLessThan8Bytes where you just make a convenient copy of the counter and then jump again to SetFinalBytesLoop. If you move the instruction that makes a copy of the original counter to right before where you compare the counter to 8, you can save yourself from writing 3 lines of code (a label, a , and a ). Moreover the program becomes clearer. 

I would definitely choose adding 444h to in such a specially crafted routine. Relative addressing is so much more flexible to work with. 

In a construct like this most programmers will try to save some bytes by using the opposite conditional jump and else fall through: 

You are obviously free to choose which register to use for what purpose, but since the beginning of (programming) time these few registers have had their own dedicated uses. It would therefore increase the readability of your program if you respected this ( Counter, Data, Pointer): 

A second optimization will be to get rid of all of those direct console outputs for CR and LF. You should incorporate these in the messages that you will print. Doing so will also remove the need to copy AL to BL using (you specifically asked this): 

A directly above a can safely be replaced by a . But since the target immediately follows, you can just not write the . 

The solution I've presented above will work out nicer if you add a single CR code to the message at start. 

Another optimization this time on compairing. To compare with zero, you can equally test the value with itself. So writing . This shortens the program. 

What about overflow? Finally, because of the exact test data (a=4, b=15, c=86, d=155, e=8) that your program uses, there's never any risk for overflow on these calculations. In a realistic program however (e.g. one that uses user-inputted numbers) you should always check for overflow. Consult the manual to find out about when the arithmetic operations produce overflow. 

I'll use the triangle code to show many opportunities to shorten the code. was moved to the top to avoid reading the tw variable twice. 

there's also no benefit in calling the ADD32 proc (that also can do without the check for a zero increase as commented by Fifoernik). 

When I first saw this use of string primitives I expected to see a range of addresses to be compared, but you only process a single word. Next code then uses less instructions and is a few bytes shorter. Note the use of the Segment Override Prefix. 

Bypassing when the counter is zero is fine, but perhaps a negative counter value should rather be considered an error and handled accordingly? Don't loose yourself in jumping around 

As you can see I combined a pair of settings in a single instruction. This saves space, can be a bit faster, and the comments make it absolutely clear what is going on. The same applies to drawing the gray bar, although it's not clear: 

From this comment I understand that numbers in the range [0,9] will be shown with 1 leading space and 1 leading zero. Wouldn't you agree this to be ugly? The version I propose next will show 2 leading spaces on such numbers.