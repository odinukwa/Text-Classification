This means that the client driver is going to be re-pointed to this address; if the address is not reachable then the driver won't be able to connect and you'll have a problem - which you happened to run into. 

Don't use sp_msforeachdb. If you're dead set on using it, though (given the many known drawbacks and issues) then you'll need to set the database context before attempting to run checkdb without a database name, or use the database name parameter. Assume: The output of this will be 'master' however many times as the number of databases that reside on the instance. Simple put, the stored procedure gives you the database name and will run it (hopefully for each database, though known to skip) but not set the context. Output: master, master, master, master,... Assume: The output of this will be the names of the actual databases (again, hopefully it didn't skip any) on the instance. If you'd like to run CheckDB this way, you could use: 

Depends, does you application require a specific collation or options? The advantage is for the application to sort and display data properly. 

For now this counter is 0 so I'm not risking any mysql crash. However it is stuck, and thanks to @jkavalik suggestion, I could see what is the query causing it: 

I could reproduce the issue with this new script. Handler read next counter went up like crazy and it's been stuck on the query for more than 10 minutes now. I saw that while this is not normal, this doesn't necessarily crash the server. What does is the rise of the semaphore wait time counter: see the rise causing a crash (the 11pm restart of mysql was mine): 

Each parameter is documented with SO question/answer, bug or links to the MySQL doc. As you can see from said linked question, I've also had a lot of crashes. I've monitored the result of : 

So that's indeed the md5/stop sequence generation. What puzzles me is if I'm doing the same query without updating the trips table, it goes nicely: 

Add a column to as a or a (depending on the risk of md5 collision) Fill this column Fill a temp table with these values to generate IDs (auto increment) Put back the trip type ID in the table. 

Always On Availability Groups does not inherently need larger log files. Generally it ends up being the cause because most databases are in the simple recovery model before the change is made to Availability Groups and thus log managements is a new concept to that database. If the database was in the Simple recovery model and the log grew to X GBs, then the minimum log size will be X GBs regardless of recovery model, Always On, etc. However, since log management isn't automatic anymore a random number (generally 30 minutes or an hour) is arbitrarily chosen and log management happens on those intervals. Now the log will need to grow to accommodate the changes in log management automation. Much as @Shawn Melton and @RDFozz have stated in the comments - if you don't want the log growing too large and all of your replicas are properly in sync, then have your log management happen more frequently. 

Technically, now, one of the drawbacks is that they aren't going to change their connections strings... when, say, they should be adding in connection specific keywords such as . You'll also have a ton of DNS items to regulate, which sounds easy - and in general, it is. I do, though, tend to see it lead to network name duplicates though. 

I have done some benchmarking to improve the query: create an external (non temp) table to store a mapping between trip IDs and trip types ( of used stops) 

Fifty seconds. It was stuck for about an hour, but ran manually it was done in seconds. From my various reading online, here are the customisations I made to : 

It seems that would be the #1 hang generator. Well, I don't know what to do with that :) So here's my issue. I've been wondering and thinking what I did wrong and what I could do to fix this, but now I'm stuck. Any ideas? 

When used by the application, the trip typed is used in a statement. Joining the external table and grouping made the performance drop by a factor of 5x to 10x. I have successfully optimized the trip type generation though, by computing the stop sequence only once: 

Do it again, by hand: This block is invalid, as it is related to my mistake in the query. Please see edits of this question to fully understand. I didn't have any new occurrence so I can't run it again to see how fast it is. What's sure, is it's faster. Also, on the next occurrence I'll try the explain on the active query, to see what exactly happens. Stay tuned! :) 

That table originally had only 2 indexes: the Clustered PK index (that this shows it doing the Key Lookup on) and another FK index on a column not referenced here. Given that this heavy query always needs these add'l columns (DateForValue [datetime], CurveValue [float], BTUFactor [float], and FuelShrink [float]), I thought a covering index was the obvious solution here to remove the (slow) Key Lookup being performed here. So I added the following covering index: 

I'm working with each of the 3 portions of the UNION ALL independent of one another and the other two parts are nice and speedy and executing this third of the unions either by itself or in the union performs similarly (i.e. ~30 seconds). So the UNION isn't a factor but I included it just for thoroughness sake. 

It only tuned ~9k out of ~530k queries It recommended I drop a ton of indexes (in fact, most of them) It recommended I create 0 indexes 

As expected, this index gets fragmented pretty quickly so we have to be on the ball with keeping it rebuilt. However, this is where we have a problem. My maintenance script that goes through and rebuilds all indexes over x% fragmented with always hangs forever on these indexes. I've tried to let one run for over 3 hours without success when the database was mostly to completely idle. Just for kicks, I even put the DB into single user mode and nothing changed. I also tried with , again with no change. However, I am able to simply drop/create the index and it completes within ~15 seconds! Just to make sure there's nothing funny with my maintenance script, I've manually tried rebuilding these indexes with no success. The script I use is: and it seems like it will never succeed. Given that I can drop and recreate it in only 15 seconds, 3 hours is WAY more than plenty to see this succeed on an idle database. For now, I've altered my maintenance script to filter out indexes with "GlobalID" in the name and then have a follow-up script that drops/creates these indexes. This gets us by until we start having naming variations on these types of columns (i.e. we need a uniqueidentifier for some other purpose). Any idea why rebuilding such indexes would never finish within a reasonable amount of time? I see this happen across ~12 tables, all with essentially the same column/index on them. 

While I have no clue at what exactly happened and how to solve this issue, I have found a workaround: 

I want to identify identical trips in terms of stops taken. Here, trips #1 and #3 share the same stop sequence: ABCD. Trip #2 uses the same path from A to D, however it's not the same trip type because it doesn't make the stops at B and C. 

In the hours/minutes before self destruction, the server dumps , which I failed to interpret. I just see that it's waiting for semaphores created at various places in the code. I've had a look at the source code but I don't have the knowledge to understand what's going on. Here are the code lines that generated most of the semaphore waits (1st number is number of occurrences): 

Finished in less than 3 seconds. The other query is still stuck, now it's been stuck for 15 minutes. 

The server crashes a lot. At least once a day. It seems it gets stuck on semaphores, and gives up waiting and crashes itself. Here are extracts from () 

We have a number of tables (~1M records) that have a column on them defined as: that gets auto-populated with . We use this ID for synchronizing data across multiple systems, databases, file imports/exports, etc. For this column, we have the following index created: 

We have this complicated query that I'm trying to make "better" until we move it to pull from a data warehouse. I need a solution that's "good enough" for now and I think I'm about 2-3 indexes away from making that happen. I'm stuck on this part, however. I'm specifically targeting this part of my Execution Plan: 

The BlitzIndex tool that @JMarx suggested is working great! However, I'm also finding this additional script to make some good suggestions as well. Not necessarily using all or even most of its suggestions, but cherry-picking from the top is proving very useful! 

How can I mix boolean logic with bitwise and/or operators in SQL Server, specifically SQL Azure Database and/or SQL Server 2016? To demonstrate what I'm trying to do, consider the following script: 

However, even after adding this index, it seems the query is still doing the Key Lookup. Am I missing something obvious here or is this the right idea and I just have a problem elsewhere? Note that all statistics and indexes have been refreshed and this isn't THAT highly dynamic of a table but it is approaching ~1M records. A simplified version of this query, focusing on this table of interest, is as follows. Nothing I removed references the PrimaryTableOfInterest. 

What's weird is that currently the server is failing hard and it will be stuck for hours. However if I kill the query and stop the script; then run the query again it will be gone much faster: 

Basically a is a collection of (+ time of departure, hence ), ordered by . I want to compare identical trips regardless of the time of departure, hence I'm comparing the ordered list of stops taken. My goal is to have an in the table that would indicate the trip type (list of trips taken), so that I can differentiate trips just using the column: 

So my script does this in two steps: compute md5 and store in temp table, then fill back into . I had an optimized query for computing the md5, however my SQL client crashed and destroyed my work :) I'll have to do it again. I'm just saying, because I think there is room for improvement in these queries. Now I have read some documentation here and there, including this blog post that describes an issue that is very similar to mine. I have plotted similar graphs from my server, here's one occurrence: 

The script works fine as-is but the moment you uncomment out that second , all hell breaks loose. I understand this is invalid syntax because I'm mixing boolean logic with bitwise operators. But what is the right way to get this logic in there? Without going crazy with statements, is there some way to do this? 

My background: I'm a dev/architect, not a DBA. Sorry! So we have a ~400 table 75GB database. I ran Profiler for ~24 hours ("Tuning" template minus ) and have ~7GB of usage recorded in a trace file. I then ran the Database Engine Tuning Advisor on this trace file (no partitioning, keep clustered indexes, PDS Recommend: Indexes) against our production database (after hours). I gave it ~4 hours to analyze. And here are the summary results I got: 

(source) Another piece of info I've discovered is that both BlitzIndex and this script are worthless after a few events happening: 

Redgate SQL Compare appears to do this decently well. I'm still nailing down the settings to ignore certain thing (like ) but at a glance, this seems like the tool I want. 

Store trip ID + trip type as is, in a field (sequence of stops: ) Store trip ID + trip type as md5 of the stops sequence, in a 

I have worked on these, I think they're good. If you see something stupid, please point it out! As per the query, here's the temp table : 

I did not reproduce either of the issues with these two modifications (the issues being the query hung and a self crash of the server). 

As you can see there is a very intense use of Pool requests, as well as MySQL handler read next. As the doc says, either my query or my table design is poor: 

I'm having a strange issues for the past few days. I run data updates at night that shouldn't take more than a few hours. Several weeks ago a single script took two days to complete. I ran it again when the server wasn't processing anything and it took minutes. I figured this is some kind of race condition, or something triggered when the server load is high. It is indeed reproduced every night, but not on the same step. I mean I update a lot of databases that are similarly processed. It won't fail on the same database every night, but it will fail on the same specific query. Here's the specific query: