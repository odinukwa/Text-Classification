Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

A good general set of rules to follow is GRASP. Another easy test is to look at what the class does and then check that the name matches that what it does. Your User apparently loads things from the database and checks passwords. Not exactly what I'd expect from a User. 

That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?" 

While your code doesn't leak right now, it will leak as soon as you replace as a value type with a more complex or generic object type. Then for example in lines like this: 

There are already and friends for . Avoid inconsistent state Instead of keeping track if your rng is , seed it in the constructor. Follow standard naming conventions I find some of your names to be too verbose and far away from common naming schemes (stl, boost). Especially . For instance . I would think is just fine. Avoid indirection if you don't need to Why do you manage the by inside ? This has negative performance impact. Use such an indirection only if you need to move the objects around often but cannot cheaply do so. The same argument applies to , but it requires more careful reasoning because the object is more complex. Is it required to often move around es in operations? (I don't think so) Is it expensive to move a object? (Depends on ValueType.) 

Your documentation is out of sync with the code. That is very bad, worse than no documentation. ("Creates a new vertex with specified id and returns it", "We use a std::list instead of an std::vector") Your documentation is missing the most important information: What is your actual graph? directed? multiple edges? values at vertices/edges? It should always be clear for all methods what failure conditions are. Also make clear when failure doesn't mean exception but return flags. 

exceptions can occur and you will leak memory. This is subtle and difficult to get right. Therefore always* use smart pointers to express ownership, in this case . *: unless absolutely necessary and you know what you are doing. Otherwise follow the advise of Edward which is much more immediate. 

You don't use it consistently. Sometimes you use instead Don't use an array there. Seriously. Why would you introduce so many ways to shoot yourself in the foot without need. 

In general your reasoning is ok I think it is very valid to try to optimize the time complexity for certain operations if you do not know the size of the structures beforehand. That said, of course it helps to have actual use cases for performance comparisons. Provide the full code It's hard to provide feedback without the actual implementation of your methods. For instance I would think your implementation of is probably inefficient based on your data structures. Improve your documentation 

Vertex "type" What actually represents a vertex in your graph? Do you really want to have separate ids for vertices? Or is a vertex uniquely identified by it's value? In any case you should use a to identify your vertices in method paramters, similar to how is used. Return by value or reference instead of by input reference For instance your always requires an unnecessary and potentially expensive copy operation (from the internal to the outside variable provided by the caller through the reference). Consider implementing and instead of and . This is also more consistent with common interfaces. For example in your current - what happens if there are already elements in the provided vector? It complicates things and is more difficult to use. It requires to user to define a variable first and then passing it into your methods rather than defining it directly from a return value. If you have multiple return values use a or . Take s by value instead of If you pass small types that are cheap to copy, it is preferred to take them by value. Note: if you do not know the type in generic code, a is just fine. Allow for in-place construction Currently a user has to first create a vertex and then assign it a value in a second method call. This is complicated and error prone. Instead allow for in-place construction (emplace) or at least copy construction of new vertices. 

It has meaning but the functions that rely on being the correct type () will fail. In JS the mutated box is still an and to be safe you would have to vet each property in turn. Not at all a practical form of polymorphism. 

Or dare I compound the ternary, i find it much more pleasing to the eye. Warning some will not like this. Note that when you compound ternary expressions it is best to wrap sub expressions in (...) to clearly mark out each condition. 

If we marked all traveled then 3 would mark link as traveled and thus block solution 4. Note: that the solutions include as many links as possible without repeating. The following is not a valid solution as is repeated 

Testing Technically your question is against rules as it is not a working example, and I wonder if you ran it at all See what happens when you run it. 

The is redundant does the same with less complexity. see note (*1) Functional similarities You have four almost identical functions that contain the following 

25,793µs ±1,853µs. Using strings 30,418µs ±1,346µs. Using arrays and array.join 79,534µs ±1,142µs. Your code 

This only gained a slight advantage, ahead of 82%. I then looked to see what code gave the best result, it was almost identical???? Code from leetCode best answer in terms of performance. 

The test is of 1,000,000 shuffles each starting with the same array. As you can see the first item has a good random distribution with the difference between the highest and lowest position of 1.06%. But all others had terrible bias. If it were gambling this level of bias would bankrupt a tote in a few dozen shuffles. Look at the center one , it is 27% less likely to be in its starting position than in the position one down, and approx > 50% chance of being in position b,c,d. To improve. Using the algorithm you have can get better results by just shuffling the array more than once. This of course increases processing time. If we look at the distribution range between the lowest position count and the highest for each item, we can see that the number of shuffles make a big difference. Just by shuffling twice reduces the distribution of the last 8 items from the 27% to < 2%, but compared to the first item the distribution is still not even across all items. Shuffling 8 times brings all to under 1% distribution, but the problem remains that the first item will alway have a distribution that is lower than all the other items. Remove select bias You can instead randomly select both items for the swap each time and shuffle the array 4 times. This reduces the distribution of all items to around 1% for 1,000,000 shuffles. 

No you should not underscore. Underscore has no meaning, and thus makes for a bad variable name. It is just noise that makes the code harder to read. 

Then is , and but the destructured argument named has the value If you did this in purpose may I suggest that you use an alternative... 

tim's answer covers the most important issues, but I would like to put a bit more emphasis. First of all you mastered the first step towards secure code. You obviously know that you need to sanitize user input, that is already very good. Input sanitation However, while your code may not have sanitation issues right now, it probably will not be once you extend/modify it. Arbitrarily throwing sanitation methods at input is not the solution. The solution is to use clean abstraction interfaces for output (e.g. template system) and database (e.g. prepared statements) and sanitize at the input to the abstraction. This way it is more feasible to actually get it right for non-trivial sites. Randomness / hash is not suitable for security-related randomness. This, and suggested alternatives, are also documented. Note: It seems the alternatives suggested by the php manual are not easily available... [insert php rant here]. The arbitrary restriction to ~30 bits (1,000,000,000) is certainly not helpful. There is also no reason to hash this value here, and most certainly not by chaining two weak hash functions. Remember that hash functions map arbitrary size data to fixed size. They do not generate entropy. You can use a hash function if you have non-alphanumeric random data. So lets say you generate a random token of sufficient entropy (30 bites are NOT!) and send that token to the user. Then you can store the hash of the token in the database. This way, when an attacker obtains a database dump somehow, he cannot reset passwords. This works the same way as with passwords, although its more important to apply it to passwords. You can use . Protect against phishing Emails with links are in general problematic, as both links (what is shown to the user vs. where the link goes to) and emails (sender address) can be easily manipulated. If you send an email to the user, especially when it contains a link to click on, it is customary to personally address him by name. This is at least some assurance, that it is not a phishing mail. It is of course not perfect as the name can often be devised from the email address. An alternative to sending a link, is to send only the token (in your case hash) by mail and redirect the user to a form where he can enter the token directly after he requests the email. Code structure As Tim mentioned, your code structure should be improved for clarity. This also has security impact. SQL efficiency If you do not intend to use the result of an SQL row, don't it, but instead. Use example.com The domain is reserved for this very use. Use it instead of a domain that is actually owned and used (domain.com). 

First: you leak memory. Terribly. Never use unless you know what you are doing. Use smart pointers, or in this case just objects on the stack. The visitor pattern is meant for separating algorithms from an object structure. There is no object structure / composition / hierarchy in your code, so there is no use for the visitor pattern. Following your example, there should be a class with an method, that iteratively calls accept for all elements in the cart. Also the visitor pattern is supposed to prepare for unknown algorithms operating on data structures that should not know about the algorithms. So it does not make sense to use a return value here. If you want to accumulate a prize here, you would have to do it in the state of the visitor. Also: Use consistent spacing between etc. Use consistent capitalization of methods (). Avoid redundant newlines.