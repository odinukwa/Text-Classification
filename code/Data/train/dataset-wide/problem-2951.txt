Firstly, these should fail to compile because the variables and are not in scope. Secondly, you should be zero-checking the division to ensure there's no division-by-zero. All in all, I think this code is non-functional..... 

Observations In general, date processing is hard. The daily, and weekly schedules are managable, but the monthly and semi-monthly schedules require more smarts than what you have coded so far. It also requires more of a specification than what you have given. Should monthly be the first day of the month? Should it be the last? Should it be the 30th, except for Februaries where it should be the 28th, or 29th? Should it be the same day-of-month as today, but adjusted for february and other months if our day does not exist in those months? For the semi-monthly system there's the same problem. Your specification is too loose for us to go further with this implementation. 

The above code will always work, but for larger files will be slow. For practical purposes though, I don't believe you will run in to problems, and you should be fine. I worked a little Java 8 in to the following code as well. Consider the RingBuffer class which allows you to collect the data in to it: 

Your question is surprising in the sense that you use the somewhat obscure method (not many people are aware of that one), yet you do not use the similar method. Using that method, you can remove the second loop (as you suspected). It also answers the second question - there is no need for a StringBuilder, or the int conversion: 

Let Java work for you: This code throws lots of potential exceptions which you don't handle... and there's a lot simpler ways to do things....: 

I have thrown in a few things there. First up, on our one machine at work, we really do have the directory /opt/OSS-EVAL/ which we use to install/evaluate OSS software/libraries. The above will break your parsing because it has the embedded in the name. Next up, is 'POSIX-style' commandline arguments can have quoted values, and also values with an in the value. So, things I would recommend to you: Locate the source of your command-line values. It will likely be available as an array, not a single string. Keep the data as an array! Second, with the array, it is easier to look for stand-alone values that are , or, if the input is then you look for values that start with -E. Finally, when you split the key/value on the , limit the split to 2. 

Late answer to this question..... There are a few things which should be considered when implementing a solution like this, and best-practice comes in to play here. 

do you know these are static data members (you are not changing their internal values)? The arrays may contain numbers just so long as the result for the array is consistent? do you trust the array members to have reasonably-well distributed hash values? 

All in all, I think you are getting ahead of yourself, and have not fully understood how the native implementation can be adapted to solve the problems you think you have. 

Expectation Setting Your algorithm is an incrementing index, which you then convert in to the radix of your charset. Your charset is what, 95 characters? So, there are the following possible permutations for passwords: 

This static class removes the need for the back-references to entirely.... The new iterator is called simply with: 

They are not essentially 1-line statements. Your assumptions are incorrect. An is a statement, and a is another statement. Thus, you have two statements there... now, the code segment: 

Now you have the complete poem in a single variable . Now, a paragraph is identified by an empty line (or more) between texts. In Regex terms, this is two or more newlines and other whitespace: 

The concept in your code is fundamentally good, but there are a few things I would recommend you change. Static initializers First up, I like static initializer functions when the static component is non-trivial. So, for example, this code: 

EDIT: About the variable substitution. The possibilities when doing variables in bash are remarkably powerful. I recommend looking at the document Parameter Substitution for details, and the man page for bash is good as well (but does not have the examples). The token indicates that there should be a pattern search backward from the end of for a space followed by any characters (the - this is a "glob" expression, not a regex). This pattern essentially looks for the first space, and removes it and any charaters after it. The man page document says: 

But, 27 is actually 128. At this point, I figure a vote-to-close, but, FYI: Picking apart the core method .... This is your code: 

Now, I have tried to list why there are problems with this, but, it's easier to actually show you a different approach, and explain why it is better.... so, here's a different approach, which reverses the logic. First thing, we are going to make the interface a generic interface... why does it always have to return a String value for each URL? Also, why is it a ? It is not really a client, but it is a . This is not the full Client, but a part of what it does when it talks to the server.... so, let's rename the interface, and make it generic.... Also, while we are at it, you need to declare that you throw some form of exception... my preference is for a new checked exception type, but maybe you can borrow an existing exception. What you have is not best-practice. Here's a decent exception to throw: 

Finally, when there is just one member left in the array there is no need to do the random lookup (it will always return 0), so you can just use as the limit of your loop and simply append the last remaining Integer from your List. Taking the above things in to consideration, I would recommend the following (which has a couple of other differences that I 'like'): 

Now, that's a long line, and as a result, it took me a moment to discover that this is a ... this makes a big difference. So, let's use that to our advantage: 

On the other hand, your variable names are great, and the basic concept is sound. Here's my version of your code: 

An often overlooked feature of a builder is that it is reusable as well, so, the above code can create many cars (it is a template of sorts)....