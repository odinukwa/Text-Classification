Do you plan to extend this class? If not, I would mark it as . Given its nature, inheritance can open a Pandora box. 

How do you know the method you're looking for will always come up first on the list returned by ? If you only expect one, use . But indicates you consider the possibility that more than one method matches your given criteria. So, do we have some guarantee it would always be the first one in our way, or are we just "feeling lucky"? :) This looks pretty fragile to me. This is subjective of course, but I have to say that since this method is actually less functional than and the implementation is rather brittle, I would personally veto this extension in a peer review, since I don't believe whatever readability improvement it brings to the table justifies the trade-offs. I think this is a textbook example of what Jon Skeet calls evil code. It's not wrong as in "doesn't work", it's sort of clever, its "magic" can even have some appeal to it, but it's fundamentally unclear and dangerous. I highly recommend this talk: $URL$ If you really want such syntactic sugar, I'd ditch generics and reflection-based approach, and replace it with hardcoded extensions for , , - come on, it's not like there's dozens of use-cases anyway. Oh, and have them return a to distinguish between input actually converted to the default value, and not converted at all. Like so: 

here is equal based on the if it was converted to string size. also, will be always equal . i don't think you need it here. use where it is possible you have few candidate for it like , and . also in for-range loop it is better to consider it for optimizing purpose like so, for since you going to use it often in your code, it will be nice if create std::string object for it. 

i inspired of @MAG alternative solution, i re-implemented it in recursive way by providing template parameters. as following: 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

By convention, parameter names in C# should begin with a lowercase character. Name of the method is unclear to me, as it doesn't seem to actually "filter" anything. It performs more than one responsibility: asserting whether the code is valid, and providing a default, fallback value if it isn't. I'd move the "lg-3023-1335..." out of it, possibly passing it in as a parameter (, or ) 

Not always. It can also return an error. Exposing crucial request settings as public properties (rather than eg. method or constructor parameters) is questionable too, in my opinion. It doesn't enforce calling code to supply the necessary minimum of information required for the request to succeed. So it's not a particularly friendly API, if I the burden of remembering which properties need to be set is still on me. Your method doesn't even validate it explicitly - eg. if is not set, I'll just get an exception from complaining about the lack of , and you're leaving it up to me to figure out that it translates to the not being set. Same with . Such mutability also introduces an inherent lack of thread safety - what if someone changes one of these properties (from another thread) while is being executed and is half-way through? We don't always need thread safety, but it's one thing not to implement it at all, sort of ignoring the issue altogether, and another: to throw it out of the window by design, for no good reason. Other things being equal, I'd say prefer stateless/immutable objects to stateful/mutable ones. Naming: if the class is named already, there's little point in naming all its properties , , etc. (with curious omission of - why not , then?). It's known as Smurf naming convention anti-pattern. 

Based on previous question i implemented most of suggestions. also, i have added Alpha-Beta pruning to minimize the calls. and making the game more generic to accept the board to be any value like 4x4 or 5x5 etc, every thing looks working fine for 3x3 board but it becomes so slow if i choose the board to be 4x4. how can i improve it further? 

thanks to @screwnut for suggesting to instead of for-range while the for-loop is bit clear and simple. but std::copy_if will allow us to use lambda instead of calling function, that might be helpful if you simply write it like this: 

I'm not sure about this condition. There are other states where connection state isn't Open, and yet it should still be closed - see $URL$ I would err on the safe side and try to close it anyway. You could test it, but I don't think anything bad's going to happen if it's closed already. Or you could make it instead. Since there are other possibilities (, , , ), this is not the same thing. 

That's probably not a practical problem, but for what it's worth it wouldn't work properly if prefix and suffix overlapped. I'd use a regex... I would also include and the expected (but not matching) prefix or suffix in your messages. The more contextual info in an exception message, the better. Otherwise if you don't catch it red-handed, you'd be wondering what exactly went wrong. 

i have rewritten a vector classes similar to the glm library which is used mostly in opengl application. i would like to know how can i improve it further ? Types.hpp 

I have implemented AI to tictactoe game by using Minimax Algorithm. The game looks working okay and AI is intersecting the player moves to block him from winning the game. I would like to know if I implemented the Minimax Algorithm correctly. if so, how can I improve it further. 

I wrote simple generic function to check if any STL container has an element. It seems work fine. I have tested it with VC++, GCC and Clang compilers. It works perfectly. How can I improve it further. 

We're not overwriting now, but when I look at it, I feel it sacrificed too much readability just for that, and what's worse, it got error-prone in process: you now have to remember to always use the last variable so as not to skip a step. If another parameter was to be added, there's a risk of a bug slipping in: 

Beware of a lesser known gotcha. This may not work as expected for that's not "really" a (it's not in s inheritance tree), only has an explicit cast operator defined allowing it to be casted to . In that case while would return a instance, won't even be called because your check would prevent this from happening. Other than that, I'd have some remarks related to naming and code style (rather subjective, so treat them as suggestions or food for thought more than claims your code is incorrect) 

I'm currently studying data structures, I have implemented simple single linked list as shown below. I would like to know how can I improve it? 

Your code looks so good, it is quite impressive of you were learning c++ few days ago. i'm sure you will get a decent code-review but here my humble attempt. It always preferred to pass the by const reference if you don't modify it. also, std::vector is preferred over std::list. here link for more details In your read function. It redirects all input into this container until EOF is received. However, the used container might need to reallocate memory too often, or you will end with a exception when your system gets out of memory. In order to solve these problems, you could reserve a fixed amount N of elements and process these amount of elements. here an alternative example to your read function by using and like so, 

Error handling or the lack thereof. Sending an email can fail for a variety of reasons, and you don't handle exceptions or failures. In you're sending emails in a loop - what if there's 10 managers, and sending it to the second one fails badly, shouldn't we try to ensure that the remaining eight would still receive their notifications? You don't handle edge cases either (such as an inexistent recipient: it would result in a once you tried to retrieve from a null , if didn't contain any entity under a given id). 

Ad 1. Yes, it's reasonable to refactor it the way you did. It's consistent with Single Responsibility Principle, and as such it makes it easy to eg. add some new formats without having to meddle with the base routine. Ad 2. It's questionable in some places. a) No exception handling. You may prefer it to be caller's responsibility, but at the very least you should ensure that the file stream always gets closed, even if an exception is thrown (with a or ). b) The names and its derivatives are misleading. It's a ( etc.). It's obvious that it doesn't represent a file itself, it represents a way of dealing with a file whose contents are passed from outside. Ad 3. Your new implementation lacks the part that associated appropriate file processing method with a given . This could be implemented with a class taking a instance and returning an instance. Calling code doesn't need to know whether it's etc., that's the point: such nuts and bolts are something left for the factory to worry about, and caller is only concerned whether the factory returns something that matches the interface. EDIT: Here's a suggested improvement. 

Here my attempt solution, it works as expected, i have slightly change the input to make it interactive. All inputs are guaranteed to be valid and correct as well as the result. How can I improve it further. 

I have created mini-opengl program that draw simple chess board on screen by using SFML windows model only. The program runs fine. The main purpose of this program is to keep it as simple as possible and it is not rely on any of OpenGL helper functions like or for converting coodinates. Also, it is not using any external library for loading textures. I would like to know how can I improve it? 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: 

Naming Unlike in Java, constants in C# aren't normally named with all caps and underscores (). Methods names shouldn't be lower-case (). Names such as are way too long, and they don't describe the method well. A method should be named for what it does, not when or why it does that. A method doesn't know who calls it and in what scenario or context it happens. That's not its responsibility. A method knows what it does itself. The calling code knows when and why to use it. That's how responsibility is dealt. A pickaxe doesn't need to know it's in a coal mine. When a method's name starts with "if", it's already very suspicious. Structure is a class field, and yet methods are passing it to eachother as a parameter. This is confusing: every method has access to all class members by itself, they don't need to piggyback on other methods for that purpose. Redundant clauses