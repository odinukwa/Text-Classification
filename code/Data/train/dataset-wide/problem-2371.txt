The tool assumes that it must create the database (and won't work with an existing database). There isn't a utility that migrates data like you're trying to do. You have multiple options. One is to use one of the replication schemes (ER, HDR, RSS, etc) to create a clone of the original database. Another is to create the relevant SQL yourself and run that via DB-Access or another tool. You might find external tables or HPL relevant for getting good performance on the loading. What do you do with the data that already exists in the target database? Delete it before importing the new? Save it in case the new doesn't import cleanly? Do you have constraints — primary key, foreign key — that will complicate any data loading? Do you need to defer those constraints while all the loading takes place? Do you want to rebuild the tables from scratch? What size of database is under discussion? Megabytes, gigabytes, terabytes, petabytes? How many tables? How big are the biggest tables — row size, number of columns, number of rows? 

A given receipt is associated with one contract; a single contract may have multiple receipts over time if it is a pawn contract (buy and sell contracts will have a single receipt). Even if a new receipt is not issued when a pawn contract is cancelled, there'll need to be a database update of the contract or the receipt (or both) to indicate that the contract is cancelled. Is there anything that I'm missing here? 

In an Informix database, there is not a lot of difference between the table and index created by loading an empty table in pre-sorted order and creating a clustered index on the table in the same order. Thus, the net result is basically the same. Further, there are no long-term implications for either method; Informix does not maintain the clustered index in order after the initial clustering operation. The performance benefit from a clustered index with Informix is a second-order effect; there is a small benefit when you are selecting the data in the clustered order, but it is not a huge benefit. However, there are considerable practical advantages to using or using . These include the fact that you don't have to drop the table (and thereby destroy views selecting from the table, or lose permissions granted on the table — though I suppose you could do a full table delete, or even truncate the table, instead of dropping the table), and you don't have to explicitly store the data in a file, and you save the cost of transferring the data from the DBMS to the application for saving the data and the cost of transferring the data from the application back to the DBMS when you recreate (reload) the table. So, unless there are reasons for wanting a copy of the data outside the database, there's no point in using the UNLOAD and LOAD mechanism; you are better off using a clustered index because it is easier to manage the operation that way. 

'Tis curious that both this question and the cross-referenced one have anonymous tables — it is one of the common flaws in questions about databases on the Stack Exchange family of sites. 

I'm not immediately sure how to interpret the 'nativecode=08004' part of the message shown. In decimal, error -8004 is about 'Illegal FLOAT constant' and is for one of the Informix SQL compilers. In hex, it corresponds to 32772 decimal, but that isn't a known error number. If it is an SQLSTATE value, then … hmmm, I'm not sure how to find out the interpretation of it. I did a rather specialized search and came across: 

I suspect, but without much actual evidence at the moment, that the second bullet point might be applicable. There is some information missing from the question which I regard as crucial: 

This will give you a directory containing a file with the schema, and a bunch of unloaded data files such as . You can move the contents of that directory to the new machine in any way you like (compressed tar file plus FTP or or similar). You'll have to process the schema to translate any Informix-specific data types to MySQL equivalents, etc. Then use the appropriate MySQL tools to create the database. Note that DB-Import, the tool used to import an exported database when the target is another Informix system, creates tables and loads them before indexing them. Any stored procedures in the Informix database will need to be rewritten in MySQL stored procedure language. You'll then need to find a way to load the data. Off-hand, I don't know whether MySQL has support for the Informix UNLOAD format; quite possibly not. You then need to know your Unix tools to find a way of converting the data files into a series of SQL (INSERT) statements, for example. Then you create the database in MySQL and load it. 

Incidentally, if the PostgreSQL tools simply export the data from one table and import into another, then that can be done with my SQLCMD program — a program which pre-dates Microsoft's johnny-come-lately program of the same name by over a decade. SQLCMD has two aliases, and . You could use: 

(When the expression is quoted, you get the error .) You have some curious types in the table — DECIMAL(2,0) is not a common type (consider , for example — though I suspect you mean ). The other problem is that you've passed 26 arguments to the procedure, but the you created only takes 22 arguments. You're also trying to pass where the procedure expects a . In fact, after the second argument, the alignment of arguments given and arguments expected goes haywire; I can't work out what is supposed to be what. If ever you needed an argument against huge parameter lists, this code is it. This mismatch leads to the error because functions in Informix can be overloaded based on the argument list, so your call doesn't match the function that is defined, so presumably you were attempting to call a different function that couldn't be found. When you get past those issues, by editing the EXECUTE PROCEDURE statement, you then run into problems with the notation: 

I'm not sure which is best. If the relevant file is in the ILS, then that's simple. Copying a locale file is mostly straight-forward, but you need to consider what will happen if that's not available. 

This uses the fact that the flag column contains either or and sorts before . So, if there are two rows for a given key, the value will be selected, else the value will be selected. 

That's probably clear as mud, but 'unable to load locale categories' probably means that , which defaults to on Unix-like systems (and something like on Windows systems IIRC) is either not set correctly or is pointing somewhere invalid. In particular, locale categories are stored in . That's the easy part; the hard part is knowing what you need to set. Have you checked the SETNET32 setting? Have you checked the OBDC connection configuration? I believe SSRS is a Windows-based system, and I'm by no means a Windows expert, so there's a limit to what I can do to point you in the right direction. But having more detailed information about the error than 'unknown system error' may help you. You could also look at the Informix manuals on the IBM Informix Information Center 12.10 web site. 

If you have support for your Informix product, you should probably contact IBM/Informix Technical Support. If you don't, you might do better via the IIUG mailing lists. It is free to join and you can choose which lists you receive. You probably want the 'ids@iiug.org' mailing list. Failing that, over time, and possibly with increasingly fiddly diagnostics, we might eventually get to the bottom of the trouble. But to do so, I'll need answers to at least some of the questions above. 

Using means 'the table called found in the database ', whereas you want to refer to the table owned by user in the current database. For that, you need a (not a ) between the user name (schema name in standard SQL) and the table name. When that's fixed, you get the error: 

If you are aware that this might be a problem in the future, you can create your procedure with a SPECIFIC name, which must be unique across all procedures in the database. If you aren't aware that it will be a problem when you create the procedure, then you can't officially go back and add a specific name, and you do have a problem. The UPDATE of in the selected answer should only work if the user is connected as (or, in the case of a private server, the server owner). 

Since the file is not anywhere near 128 MiB, I wonder if you were successful in adding that dbspace. One might be forgiven for thinking that in fact you were unsuccessful since the database server doesn't think it exists. Use 'oncheck' or 'onstat' (or both) to check whether the dbspace exists and is intact. If not, arrange to drop it, or simply remove the file and try again with the command. 

And there can be file transfers, etc, as required in between the unload and reload operations. If you need to truncate the new table before loading, that's a separate operation: 

It looks like one (or more) of the shared memory segments already exists; there wasn't a clean shutdown. Use — it should clean up for you. When you restart, consider using 'verbose' mode: . It will report what it is doing until the server is up and running. 

The will be converted from string to DECIMAL(9,0), but omitting the quotes would be clearer. The quoted expression is just a string; it is not a date-time literal, and cannot be interpreted as one. Frankly, I think you'd do better with: 

There is an answer on Stack Overflow to the question Show a one to many relationship as 2 columns — 1 unique row (ID & comma separated list) which demonstrates how to create a user-defined aggregate in Informix that functions more or less like the GROUP_CONCAT aggregate in MySQL. You can then easily use this to solve the problem in this question: 

The answer may depend on the DBMS which you're using. However, in the DBMS I'm most familiar with (Informix), when you start a transaction explicitly as shown, I would expect that if there is an error in SP2, then an exception would be raised in SP2, and since there is no exception handling in SP3 either, the error would propagate back to the caller — and the COMMIT in SP3 would not be executed. The caller would need to know that the transaction was started and decide whether to commit or rollback. If the caller didn't make that decision and simply exited, the transaction would be rolled back (because it was never committed explicitly). As a consequence of this, the actions completed by SP1 would not be automatically rolled back, and neither would the actions completed by SP2 (but the SQL operation that triggered the error would be treated as if it was never executed). I observe that the lack of exception handling means that the stored procedure SP3 is not very well written. Since it starts a transaction, it should handle errors and ensure that the transaction is rolled back if an error occurs (or committed if that is deemed to be the better course of action). It should never leave a transaction in flight as there was no transaction in flight when it was called. I believe some other DBMS take the (to my mind) draconian view that once an error has occurred in a transaction, all further operations also fail and the transaction will be rolled back. That seems overly intolerant. If I understand their manuals correctly, it means that if you try to insert a record and find that the record already exists, you can't do an update instead. I hope I misread that book (or that the book was mistaken). But it does emphasize the importance of stipulating the database you're using — different DBMS may have different answers to the same question.