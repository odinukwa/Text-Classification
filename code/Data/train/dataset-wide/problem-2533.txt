This needs to be synchronized so no thread can mess with the list while another is checking the length to see if one needs to be removed. 

You'll note I added to various points in each pattern, This lets you ignore the whitespace that may surround the operators. The in a Pattern means a word character. If you only want alphanumeric +undescore then you'llneed to replace each instance of it with 

Add a buffer length parameter and then use to avoid overflow. Your testing code hides the usage of the function. It's clearer to put it on a separate line: 

I would store the value to write directly in the . That way you don't need the if-else in . Instead it's just an assignment. 

This will loop over the data at most O(log n) times and puts the elements in heap order. However for pulling out the data there is no way to only look at the affected elements in O(log n) time. Which means that you can't sort a linked list with heapsort and still be in O(n log n) time complexity. Instead to sort a linked list in O(n log n) time you would use merge sort. This requires that you are able to be able to split the list up into separate linked lists in that you can merge. std::list has this functionality with it's member function. (It also has a member function that will do that built-in) 

Same in stack don't expose that it deals in nodes and don't let calling code access them. That way you have more control over the lifetimes. 

If $statement contains a huge amount of data I'm assuming the 6500 records are in the $statement iterator, and that the $statement iterator somehow will fetch data from a database. Just removing the iterator_to_array statement in the first line can increase the speed a lot. If it's coming from a database query, it will first load ALL queries into memory, which you will read afterwards in your foreach loop. Since you don't actually use the array for anything other than doing a foreach, this might speed up the results, because the data will only be fetched per-line in the foreach loop, rather than first fetching everything, and then looping over it. Watch out with your array_* methods You're using the array* methods heavily. While this is nice and short, I think you're missing some complexity going on in using the methods. You're looking up all values in the array of $items for every item in $statements, while looking up all id's in the array of items. This is a worst-case complexity of [Amount of statements]*[Amount of items]*2 Which you could easily reduce to a single associative array lookup. Since $items is not changing inside the loop, you can safely make a single version of $items: Here you're trying to lookup if the id exists in a property of statement: 

Keep in mind that key lookups in PHP are a lot faster than in_array or array_search lookups (they're the same in this case). Basically in_array is this: 

The way to solve this would be to not advance in the outer for loop so you can keep it pointing to z after the insertion. This also means that you can use the same insertion strategy in both cases 

Failing to open a file is common enough to use an explicit and print an error message instead of ing (which won't do anything when compiled as a release version): 

Or you can simply seek to the end of the file (with ) and use Besides that files nowadays can easily exceed 4 gigabytes which will overflow the int, both posix and windows have (differently named) variants on ftell that returns a 64 bit number. 

This way there is only 1 point where you need to handle the exception at the cost of an extra indentation level. 

The fastest way is to give each thread its own RNG seeded (and sometimes reseeded) by a master RNG in a thread-safe manner. 

you also have some code duplication when creating the arrays, you can put that in a function and call it twice: 

Some won't let you seek to the end (stdin and socket streams for example). You should check the return value of and fall back to the classic then , rinse and repeat method on error. A single is more efficient than the repeated ; so you can replace the while with: 

naming + all lower case makes it hard to parse the difference between the prefix and the name of the function, instead either pick or . returning is not ideal instead create a opaque (incomplete) struct and just let the use pass pointers to that struct around: 

You can also cache this information if you're calling this method multiple times. And then checking inside your foreach loop: 

You could optimize this by first creating an associative array of all keys (once, outside the foreach loop): 

The cost of a lookup in $idIndex will alway be 1, and worst-case scenario of the lookup cost you're doing now will be 2n the amount of items in $items (e.g. ), because you will iterate $items twice each row. Watch out with your array_* calls, part 2 Exactly the same principle applies to this part: And here you're trying to look up if an id exists in 

Since this a simple lookup, I would really recommend building an index of all balancedPerAccount once, and then checking with if it exists, rather than looping over each item in a doubly nested array. I would recommend doing an exercise of writing all array_* methods by hand using foreach or for loops, then it will become obvious what these methods are doing. Unsolicited advise: Style, comments, variable names, reusing variable names This will not affect speed that much, but I generally recommend overwriting variables with a different kind of Object. For example: 

Are all horribly generic in this case. If there are very clear comments on what they contain, this may not be a problem, but I would try using a bit more descriptive variable names. 

PHP Doc Also, depending on the objects, there's a lot of undocumented coding going on (documented by debugging). It's almost impossible to figure out what's happening without actually debugging the code. Make sure to use php annotations to describe what's inside the objects or arrays. Variable naming 

note: I use underscores in the hexadecimal literals to make it clearer (they are legal in java 7 I believe) however in java 6 you will need to remove them. 

Keep the updates queue as a ; you don't care exactly what it is only that it's thread safe. is kinda cryptic as a function name especially as it doesn't actually set any object. I suggest instead. 

I think the major part of the slowdown will be applying the style. Otherwise you can pregen an array with the possible phases: 

If you have a destructor you should also have a copy constructor and assignment operator (and the move variants). For a container I expect a set of and functions so the classic STL for loop can be used with it. The iterator type could be a struct with a pointer to a and a int for the passed to on . I would expect and to be const as well. 

Iterators may not be random access iterators which means the length calculation and the advance by half won't compile. For this there is the and functions available which use the random access if it is available but fall back to counting and repeated incrementing when it isn't. You never use the type def. In the recursion step both branches are equally likely and equally important, that is best signified and made more readable by using an branch rather than letting it fall through. you can also implement as a loop to minimize recursion overhead (micro-optimization admittedly because automatic tail-call optimization would do the same).