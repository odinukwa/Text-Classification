Have you considered using an , Hibernate for example? You shouldn't append strings to do build queries, use instead. This is the mistake number 3 in the list of top 25 most dangerous mistakes. You shouldn't hard code database information in you business objects. 

Note: I don't claim to be an expert in principles, I do understand a bit though. Back to , violates the principle (The most frustrating concept to me). That is, when you add a shape you have to go and modify the code by adding an , this can easily solved by using , 

Because you have decided to declare as a , then you have to make it , because mutable structs are evil, and thats a good read if you want to know why And it's not that hard 

As you can see here no static methods anymore, static usually presents a global behavior, and I need to force users to go through the constructor so I make sure weights are computed properly. I suppose that what you using is algorithm (not sure though), where your class name is , that's a bit misleading because is not the only algorithm and it doesn't work with negative weights, and you need something like Bellman-Ford for that.If you don't want to support negative weights for now, it is fine, but you should be able to add this functionality in the future.And this leads for extracting the Route finder to an interface 

Here you try to dereference , which you previously checked to be . Dereferencing the iterator invokes undefined behaviour. Since I guess these lines are debug output only anyway, just remove that part. 

Again the input is one word each instead of lines. Data which includes the word would trigger the end. 

Your algorithm is of time complexity in . If your current code needs for , then one could estimate the time for to be roughly . Even an improvement of the most inner block's execution time by a factor of would yield an execution time of about . I guess this is not good enough. So you should better try to improve the algorithm itself. However I do not really understand the problem the function is trying to solve and I couldn't come up with a better solution on the spot. Also I haven't looked at numpy approaches, because you seem to have no vectorizable calculations in there. Nonetheless I tried to make improvements to the code as is. I came up with the following: 

The operator will read one word at a time, not a whole line. If you want to read whole lines, you should use . 

You have field that you mutating in a multithreaded code, this field can be cached and might ignore you changing it. You can declare it as to avoid this behavior. 

You might have notice that I called it instead of , because a map is a collection that holds things and things are plural. Note: If you need to iterate over a map, don't use iterator, use instead. 

What makes your abstraction leaky is the fact that is not abstract enough, that is, Manager and client shouldn't be there. 

Or implement Guava suppliers anonymously if you running java 6 or 7. You can add an interface for convertable things that your classes can implement. 

Looks fine for me, but such a class should be , because it does not make sense to be able create instances of this type. 

And because their values are known at initialization, its good practice to declare them . your method is not , use instead. Some validation on the parameter is needed as well. 

Threads??? Once you have threads in your code, your code becomes obsolete even if it was written 2 seconds ago. are the way to go, and you can easily replace your code by a single Task that keeps running and a function that accepts Tasks 

In order to use you need to . What is the purpose of the at all? It stores the s as keys and s as values. The only difference between the two is that has an added. Why do you need to save this? You can append the each time you have a new . This would be much easier to read and much faster. If you are trying to minimize the number of calls you might want to store all the opened s in the map and access them as you need them, closing all at the end of the function. Notice however that is not copyable, so you need to store references to them in the map, instead of the objects themself. If the input files are not that big, you might also consider saving all the parsed data in memory first and then writing it to the output files in one go. While parsing you can use a string-string map to save the data for each file. You are lacking any check of syntax errors in the input file. You probably should add code that reports back if the syntax is not as expected instead. 

Follow up on HungryBeagle's excellent answer: The generalization of excluding factors of 2 and 3 (and so on) from search is called Wheel factorization. In my opinion the best is to do it for 2,3 and 5. It has a period of 30 (relatively small), and exactly 8 jumps between prime candidates: (6,4,2,4,2,4,6,2). You see the appeal: only 8 candidates out of 30 are tested, and 8 is perfect for iteration (for binary reasons). You output 2,3,5 as primes, then start jumping (testing 1+6,1+6+4,1+6+4+2,...). If you include 7 or higher you have a bigger jump table and less and less improvement. The formula is: , where phi is Euler's Totient function. So for 2, your trade-off is 1/2, for 3 it's , for 5 it's , and for 7 it's which is slightly better, but requires BIGGER jump table, which also isn't of size 2^n. It's true, when you are doing primes sequentially from 2 up, you can use full sieve (remember all previous primes) but usually you need a test for a specific prime. Here's quite a fast and short code in c: 

Check if I messed it up. The main question is: do you want from the flow to be apparent which one is checked first (in which case just use switch statement) or you want to avoid duplication of calls. You can also go take the hybrid way and just set flags in the main if block and then just conditionally call them at the end. Like this 

suit and rank fields should be declared private, no need to share things and deal with infinite number of states. 

Code duplication is not a nice idea, it's a massive indication of code smell. You can create a helper class for your common code, ex: getting db connections, creating data tables, etc... 

What are the functionalities expected by the users of this class What are the things that users shouldn't care about What shall I hide so users don't break it. 

When you see yourself going and editing the same function again and again to extend its functionality then thats a code smell. The problem is that whenever you add a type you have to add an if condition to your converter. So the conversion could be the class responsibility. in Java 8 you can use for that and if you don't have Java 8 then is your friend 

You need to be concerned about thread safety in web applications, HashMap is not thread safe so you can use the version. 

This code here is a bit dodgy, you shouldnt never trust values you getting from the , so you got to handle the exception and refuse the request if the value is not parsable to 

Instead of assigning the array elements to , , etc., use them directly. Since later comparisons are not executed if earlier one already return this might save array lookups: 

What is the purpose of this stream? It is opened (multiple times!) in the code but never written to. 

The whole purpose of a map is to be able to access the values via a key instead of iterating over them. You should use this functionality: 

In summary: Your code will likely not do what you expect it to do in many cases. You should generate more diverse test cases. (try instead of in your example file and report what happens). Several parts of the code are redundant (all the map-iterating loops) and at the same time they might be very time costly for large input files (since the map might grow rapidly). 

What is the purpose of this loop? You just inserted the key into the map and now you search it again. Why not simply access it directly: 

Since you do many index lookups on these arrays turn them into lists. Numpy is not good at single index lookups.