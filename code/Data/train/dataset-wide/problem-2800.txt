Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

returns the price plus the tax. If it's going to do that, I would name it . There's also a lot of repetition in the method. Find out the part that's not repetitive, and do that first: 

I'm almost alright with not declaring local variables though. The function names are descriptive enough, especially knowing we're traversing a tree: 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: 

The compiler can complain if you double declare, is strongly typed, ... Cache sizes of containers while iterating Depending on the container, calling GetSize() and operator[] can be expensive. Cache the size up front or use a range based for. 

The same happens in your where you create a temporary and then push them on . Why not add them directly to ? You know the size beforehand, so you can call on and acces the elements using the operator. (This way, the vector has to reallocate only once) Use namespaces You have some places with generic names, such as , which might collide later on when you include some math library. Use namespaces from the beginning to prevent issues later on. Prefer the compiler over the preprocessor If you can, prefer a const variable over a preprocessor define. 

Remove unused headers For example, in you include but it's not used. If you would only use it in your cpp, move the include there to save some compile time. If compile time is really important you can even predeclare in your header. Use initializer lists for all constructors For example, your zero-argument constructor in the class (the one defined in the .cpp) doesn't initialize it's arguments, and you might up reading garbage memory. Mark const methods as such For example all getters can be marked as const, as well as all other functions that do not logically alter the state of the object. 

Just pick one. Here I just return void, keeping with the semantics of the rest of the parameters (pass by non-const reference): 

The algorithm you used is the way I've always seen it - flooding the matrix. I think my sister had this question at her first interview, and I think she did it the same way as well. 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: 

I changed the logic a little, because seems to neglect to grab the item to the left of the current item. Also, in the for loop skips the entire row above the current item. I would add the enumerable in the traverse method into the for loop: 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

I removed because I don't think it's necessary. I would also check for malformed input, as can fail with an error, and can be something other than , , and . Before I got into the industry, I had flaky UIs that worked if you used it how I, the programmer, intended. There were quite a few ways to misuse it and break the program. One of the first things I learned on the job was that that was not going to fly. Ewan's answer is great for the OO principles, so I'll neglect to cover that. 

The comments from the other answers are valid as well - try to avoid copy pasting. If you ever have to copy paste something try to think if it can't be made into a function, macro, class, ... 

180 is an integer, not a float. So you'll get a whole devision instead of a floating point devision if is an integer as well. This is not the case, but it is dangerous so I recommend you change it to Clean up a little Remove empty functions, don't pollute your main function. So either remove or transfer some of the logic that's currently in . Polling versus events In your function you're polling the state. This means that every single frame, you're requesting state. In this case, it's about a few keys but if you have support for multiple players and controllers, this method is going to get computationally expensive. Responding on events is a little more complex, but worth considering for larger projects. Have a look at events in sfml. Use parenthesis They're free, so why not use a few extra. Take a look at this piece of code: 

Do nullptr checks In some functions (e.g. ) you pass a pointer while you're never checking if that pointer is actually valid. If the pointer cannot be invalid, pass a reference instead. If the pointer can be invalid, get some logging (use some form of asserts). Watch out for integer divisions 

In , you do a lot of the same as in the else. Also, has an overload for a format string. Use that one instead of concatenating a bunch of strings and variables together. Also, it's hard to read when it's all on one line: 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

You could take a page out of functional programming and shorten the visitors for the multiply, divide, subtract, and add: 

Sure, they could still pass bad values, but they have to try harder by explicitly creating an invalid enum value. Also, making it a scoped enum provides extra type-safety and prevents naming clashes. Either way, I think it makes sense to throw out of the constructor immediately if the key length is wrong instead of waiting until the function. If you want to enforce a valid value at compile-time, you can use a , or you can use a smart-enum pattern. This is an example hacked together real quick: 

It's also a little confusing that you return from to indicate that you want to keep running the program. I would probably change the name to and return to indicate that you want to continue. Float literals have an on the end of them: 

Since update is inside this loop and render is not, it is possible that we do not update and render the same state of the game again. The other way around: it is possible that we update the game twice but only render once. Both of these scenarios are wrong. The first one because we are going to render the exact same scene again, the second one because we're going to calculate how the scene should look like and then do nothing with the result, but rather calculate it again. For starters, try to replace this second while loop with an if and place the functions inside of it. 

Another tip is to use lowerCamelCase for variable names. Try to avoid useless comments Comments such as inside of a constructor don't say much - the syntax of the language and/or name of the function should be good enough to describe simple actions. Comments are very valuable, so feel free them on places where they are useful (in complex methods), but don't add any that add nothing. Use nullptr over NULL NULL is defined as a zero, which can also be considered as an integer by the compiler. This can get some weird issues when you have a pointer and integer overloaded function. Pass arguments by const reference where possible If an argument has a complicated copy constructor (e.g. if it has to copy memory (such as ) or has to do atomic operations (such as increasing a refcount))