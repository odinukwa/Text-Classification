Notice the funny syntax in the constructor. That's called a constructor-initializer, and it's a good idea to initialise your objects that way when possible -- it might be faster, and it makes it more explicit. Notice that the string is passed by const reference. This means you don't copy it, but that you also can't change it -- you don't want to change it, so that's okay. It has another benefit, but I'll show that later. Finally, we make const so that you can call it on a const instance of . Not very important in your minimal code, but it pays off to be as const-correct as possible. 

I had to replace all instances of scientific notation with fixed point, and wrote a Python script to help out. Here it is: 

I'm looking for all-round feedback and criticism, suggestions for features, and any correctness concerns that may be present. Suggestions for an automatic way of determining and are also welcome. I'm also curious about what extra assertions I could be making to make the code fail in clearer ways when used with unreasonable s and s. EDIT: I found some significant bugs, so the code has been updated. 

You instead could use a list, but then the indices would start at 0, which I don't think you want. Thirdly, although your functions are all short and fairly self-documenting, I would suggest adding docstrings to your functions, as well as comments whenever you feel like you have to make an important decision. Even if you don't expect the code to be read by anyone at all, spotting similarities may be simpler in text than in code. You may also want to name your constants -- the aforementioned 100 is a good example, as well as the point you use in (why did you choose that point?). Speaking of which, may be better-named , if I understood the purpose correctly. In general, you may want to have function names start with a verb. 

In this code, I'm overriding the sorter and matcher for Twitter-Bootstrap's Typeahead functionality. The reason for the override is to allow state (technically Jurisdiction) abbreviations to be used to match the full state name. I've reduced the length of the source array in this example for brevity, but a full version is available on this fiddle. I also decided to make it so that duplicate entries could not be made. I went out of my way to make JSHint like my code, but I'd basically like any suggestions. This is my first time doing something like this and I'm relatively new with Javascript anyway. The only things I'm not interested in is white space as I simply formatted this based upon JSFiddle's TidyUp function, the css (as I didn't create it), and suggestions to override highlighter as I don't see the need. Note: In production the number of inputs is dynamic, which is why I am selecting them each time. If you need to view the Typeahead source code to understand my overrides, you can download it here HTML for Example 

I know names aren't hugely important but my 2 cents in addition to having already written some of what @tomdemuyt said (which I editted out): 

I wish I had a suggestion on how to improve your loop, but as you said, it's much trickier than you might think, and I'm probably not smart enough. ;-) Only suggestions I can think of here: 

which I would argue is closer to how the fibonacci sequence is actually derived as will always be (n-2) and will always be (n-1) instead of repeatedly trading places. 

Also your variable names could use some work. I actually don't know what is supposed to stand for here. 

Your comments are excessive. Commented out code helps no one. If you remove code and want it later, that's what version control is for. Your method is too long. You should break it into smaller pieces. Use loops instead of very similar repeated code for instance: 

The way you're implementing a read-only object looks fine, except for being mutable. Are you sure you want it that way? It seems counter-intuitive with the rest of the class. Seeing as it is a private member anyway, why not make it just like ? Other comments: 

If this is C++, you do not need to typedef enums; will do. There's also no need to place at the end of a function that returns , or in the parameter list of functions that take no parameters. As Loki Astari remarked, you should not the joysticks unless you have a good reason to; even if you do, though, and don't use smart pointers, you should make a destructor that deletes the two pointers, and should either implement or make private the copy-constructor and assignment operator. 

I presume you are aware of all the standard issues with , and that C++11 fixes by far most of them. I'm thus going to assume you have no C++11 support; if that's not the case, most of this doesn't apply because the whole thing should be rewritten with different semantics. Comments in order I see things: 

Indentation is generally done in powers of two, and should in any case be consistent. I'm switching to four-space indent everywhere, as you don't seem to be following any style. This is also a great chance to use pointer containers. Each node owns all of its children, so use something that will enforce that. (In some cases, an of s would make more sense.) You do not need any of the globals you've defined, and are definitely bad practice. You should also strive to be more const-correct. 

I am primarily interested about the way the regex is used (can it match something it can't replace?), but comments on code clarity and features that may be simple to add are also welcome, as well as any further nitpicking . 

I'll admit to being new to this concept, and can't think of a real-world application for this method. Regardless, here's my thoughts. Issues #1 and #2 are directly results of your use of Object.Assign which seems an acceptable limitation. Issue #3 is stating a fact of how Object prototypes are set up. The prototype of Object.prototype is by definition null, so #3 is technically a given. However, your questions make your meaning of #3 more clear. 

For reference, here's the code I used to find that your program doesn't handle intervals the way I would expect. Add a break point at the commented lines and inspect your locals to see what I mean: 

This has the benefit of treating null input essentially as if it were not provided, which would seem a more expected result. You could still have an error thrown, but I don't see the value. If you choose to have an error, at least make the issue more obvious. "Prototype chains are assumed to be delimited by Object.prototype." is confusing and unclear what the issue is to me. I would go for something like: "Cannot appendToProto of null." In general the error message should indicate what is wrong with the input instead of the codes philosophy regarding what its input should be. 

Not if I understand what you're doing correctly. So essentially each image has itself, and then some other element that should be before it as a buddy? Assuming they are all siblings, you should utilize some of jQuery's functions that support working with siblings. Here's an example, though I'm sure it could still be better: 

Euler2 is a confusing variable name. It has the disadvantage of resembling Hungarian notation, so those exposed to that may read it as booleanIsHigher which makes no sense. Rather than trying to find a better name, you can actually factor out the need for the variable. You get the same result from the following: 

I've been looking at ways to use asserts in programs that must do some kind of cleanup on fatal errors, and have arrived at the following pattern (PROJECT being replaced by the name of the project): 

That's obviously not recursive. The way you'd do it recursively is always swap the outer two characters of the string and then pass pointers to the beginning and end of a substring along. Apart from that, you're initialising but not , which makes little sense: both will be 0 initially anyway, so at least be consistent. You're also not using , so you might as well get rid of it (if C allows it). You're also not checking for a being passed in. 

I would go with the third, with the second as secondary choice. The first mixes addition logic and comparison logic: it's not immediately clear that the zero is meant to exclude those objects, as opposed to giving a default for . The second is better, but it hides the point behind a lot of unnecessary syntax. The fact that you're working on and not gets lost. The third is even better. It can be conveniently read left-to-right, and all the information is grouped near what we're doing (condition is after the where, sum elements are after the sum). Personally, I would use 

What are the possible problems with this approach, and are there any improvements to be made? One part I'm not sure about is defining in the assertion. Seeing as this is an inner scope it should always hide out values, shouldn't it? Could this lead to unexpected warnings (maybe glue to it?)? EDIT: With suggestions incorporated: 

At the very least, you should place the second statement in a block. As things stand, the code is not generally correct from a purely mechanical perspective. I would also phrase it as: 

Scope your variables. Change your code to target all instead of one element with the id . Use when events are triggered to make sure you have the correct element. Remove the added elements instead of hiding them. Remember to call using the smallest possible parent container. Possibly a or ? Use short circuiting where appropriate. Use to get the appended elements parent. 

I agree with tomdemuyt that requiring this to be used with jQuery seems to contradict your description of it being "lightweight". Most of the code doesn't reference jQuery, I'd look into factoring out the jQuery dependence. 

Did you start out code golfing? Use variable names that mean something. The only variable you used that has any meaning to the reader is . This means that unless you remember, every time you hit a variable you have to scroll up to find out what it is. This almost looks obfuscated. (It's not, but it is painful to read.) I'm not even reviewing the logic itself. You need to use meaningful variable names or no one else will ever want to touch your code. 

Not a full review, but: is completely unnecessary. Because Data will be null if you didn't set it within the If portion. Just add an to the previous if and have it . 

There's not much here to optimize mostly because there's very little here. A few things you could do: Store your selection to a variable outside both functions (bad idea if you may have multiple notificationDivs). 

Do not use multiple statements to check the same variable. Either use an block or You do not have to post all of your project, but you should at least post pieces that are whole. If we must go to a separate site to even properly review what you posted, it probably isn't going to happen.