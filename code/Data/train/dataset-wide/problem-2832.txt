I guess if you just want to validate, you could write something like the following, though i'm not sure if that really answers your question. 

To the outside world, this function is accessible through , however inside the function, I can access it through . Another thing to note, would be the that you can assign properties to functions, which can be handy sometimes, in our case, to assign it with a counter: 

This doesn't interact with the request at all, at most, the user will see something on his screen, however the response will still be running, and your code may eventually react on it, so you are pretty much unsure if it really worked. But don't forget that any callback you create should be canceled in the end (through (see PatrickRoberts comment below) or ), so that there is no need for you to check if a response returned ;). I personally still prefer the and methods to do that. Suggested rewrite ES5 

I am really unsure why you have a access modifier for the method. I don't see any reason from the code why you would need it, and I think it should be at most , but preferably . For the and members, I don't see why they should be members, and why you should be able to assign a value from outside your class. I think the should be private fields inside your class, cause nobody except the current would care if they are loaded or not (and if they would, even then, I wouldn't allow it to be set from the outside) To the outside, I would tend to give out only , and keep the implementation of it hidden from the users. WPF will detected the interface, and will update on any changes (as long as you don't reassign) I am also unsure if the of the TreeItemViewModel supports updates to the UI, if it does, it seems a part of the is not yet implemented for it. 

This is really one of the best examples that should be refactored to a method, and that could even be split into several methods. You have to ask yourself, what is variable, and what is fixed in my piece of code. Well, if you look at it closely, both parts of the condition seem to check if a keyword exist in a certain array, and in case it does, it will take the found element of the array, and split the words, and then it will check if these words are specific words, and if they are inside another array already, if not they will be added. As a side note, this part of the code I have the most questions about, simply because I didn't actually step through the program yet, and I cannot seem to match the code with your specifications, yet, so I won't change the functionality here, I will just show how it could be extracted to one or more functions Lets take a single statement to begin with, like this one: 

This example may be used when the method this code is executed in does not declare to throw a checked . But it all depends on the case at hand. 

I think you are really thinking well about what is going on, what potential up and downsides are. I am not really familiar with card games, but my initial guess would be that it may be a bit long stretched to find a unified interface for all types of card games. In general you have cards, hands and decks, but the similarities can pretty much end there. I also like that you used good descriptive names, private fields, and final where possible (though you are not entirely consistent with it). There is quite a bit of code, so I'll comment on the major code wise things that spring to mind: 

Your question about only changing state through the public interface: definitely yes! It is a really good principle. It makes sure you are in control. Finally, this is me, but I am not much of a fan of using the prefix. Apart from implying it always is a simple field acces (which granted, in this case is generally true), for me it feels superfluous. Apparently, it also has a name, namely the . There are some interesting reads about this I think. 

Not sure if I should review it as a programming challenge, or if I should include design remarks, I'll just say what comes to mind. I'll first note that I would make the fields , and add accessor methods. Them being immutable makes sense I would say, and methods help for using them as method references with the streaming API and others, as I will show in a second. For , I would really refrain from using and , at least when you do not know the implementation. Depending on the implementation, the performance of these could turn out to be quite horrible (e.g. could traverse the list up to the index each time in case of a ). Also looping and mutating a collection at the same time is a lot of times error-prone or worse. Finally, you mutate the collection passed in, which is also a point to think about twice (though not necessarily bad). For , I like this implementation better. It is a smarter implementation for given problem. First, I would like to note that since Java 8, has a default method implementation for sort. Next, with the method, you can specify which property of the type to use to compare with. If you add accessor methods like stated before, this would make the sort look like (with a static import of ): 

Update2 Above: Runtime test without powerfunctions and with Justin Peels recommendation to use return list(a.values()) 

This is a simple repeatable question regarding the usage of Python3's comprehensions: Could the Python3 syntax be used in another way to speed up the process, further so the gap between Python3 and numpy would be reduced? (see chart below). The results & code: 

Now we just miss one thing to pass all your test: The bulk loading method where you map N keys to M values. This is a "cartesian" product, which is a fancy word all N's maps to all M's. In Python this is a walk in the park as we can iterate over both and reuse our method: 

We have now implemented the INSERT STATEMENT in our database. Now it's time to worry about how to delete records and relationships. For this we hack the function to both take a key and a value. Why? Because otherwise we won't know whether the user wants to delete a single relationship only, OR all entries associated with the key I thereby choose that: 

A dictionary can hold 1 key to N values, but not N keys to 1 value. Fortunately the reverse operation of N keys to 1 value is the reverse of the dictionary, so we can trick around this by creating a class: 

In test03 I need to pack the value into a list, because iterload needs two iterables. I could made my code much harder to read by accounting for many different cases, but I think the programmer should build a function for one thing and make it clear for future recall of what the function is supposed to do. In test04 - below - I have added the usage of the update function. 

Now we can add and delete. But how about bulk updates? They constitute a special case because can't see that you want to propagate your update onto multiple values. So we need to tell it WHAT to update. Here is a proposal that uses the relationship between the key, the old value and the new value that should be accessible to all keys that other would have a relationship with the old value: 

This is a very basic relational database. So the first piece of feedback is that new programmers often start coding with poorly defined test-cases or non-normalised test-cases whereby they get lost developing their test portfolio. If you would have started with clarifying your case, I'm sure you would have cracked this problem. Let's start defining our operations from examples Sometimes we will have the database maintaining links: 

I think this implementation is really too confusion for the problem at hand, although I think it is quite an interesting solution. As you said it yourself, integer division loses the fractional part (rounds down towards 0). You can actually use this for your solution! Because if a number is not evenly divisible, multiplying with the division result will not give you back the original number, it will be smaller! So a way to do this would be: 

I'd like to give some thoughts which spring to my mind when I read your given code. Now, you have an implementation specific for primitive ints. A more advanced step would of course be to implement a generic like the one in the JDK, just mentioning it. First up, I like that you use clear variable names, and that you reuse methods like \ . Kudos for that! As an aside, you do not need the variable, as it is the same as . It is a fixed size stack, so it does mean you have to know beforehand how much elements it would take up, in order to not waste space (or run out of it). Perhaps for a follow up exercise you could try and make it dynamically resizable? Now, for the method. I would not let it silently succeed if the stack is already full. Seeing as it is a fixed size stack, I would probably opt to throw an , because to me it looks like a programming error. A possible second idea could be to return a , signaling succes or failure (though I don't think it is the better solution). Same with peek. It now silently succeeds and returns , which is very well a valid value which could reside in the stack ( exists by the way!). The solution would not work here of course. Also, I personally do not think the extra new line is an improvement, on the contrary. Finally, to me means taking off the top element of the stack. So why not return it? 

The reason for this is that now we only flip while it is necessary, because if the bottom of the remaining stack already contains the largest pancake, we do not need to flip. Meanwhile, we are also keeping the implementation clear: you first look for the largest pancake in the remaining to sort stack, move it to the top, and then to the bottom of the remaining stack. Using clear variable names makes it so other people can understand your implementation more easily (and even for yourself, if you would come back later).