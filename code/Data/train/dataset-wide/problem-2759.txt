This is a pretty radical rethinking of your algorithm, so it's not a proper code review. Assembling a string with separators is simpler in Python. For your example of ","-separated strings, always think of doing it this way. 

It extends an existing partition on the low end or high end. The number is adjacent to exactly one range. It creates a new partition. The number is not adjacent to any range. It "bridges" two adjacent partitions, combining them into one. The number is adjacent to two ranges. 

This can't work unless you stipulate a specific size for the partition and do not grow it. You can't discard any value from the input sequence or you won't get the actual maximum. The fact that you're popping a value means that you may be discarding a proper part of the solution subset. Consider a slightly contrived example where X = 0.25. The initial state is to process 1/X items (4 in this case) of which 1 is maximum and 3 are discarded. The values were 100, 99, 98 and 97. You keep 100 as the 25% maximum and discard 99, 98, 97. (You could try to keep all 4 or even the first 25 values. It doesn't matter how many you keep initially, the logic problem will still arise as soon as you pop a value. I think the contrived example makes the logic flaw easier to see.) At some point, you've seen 7 values. The maxima subset has 1 value (100); the remaining values (99, 98, 96, 95, 94 and 93) have been discarded as not part of the maxima set. You get value 8, it's 92. You need to append this to the top set. Yet, sadly, you discarded a value larger than this. When you get to value 12, you again need to expand the maxima subset. However, you will have discarded values that may be larger than the 12th value in the sequence. You cannot do a from the maxima subset unless you can prove the value being popped must be less than all future values which may arrive. 

If we have a sorted slice of the power of 10's, we can use binary search to find the power of 10 for our input number. However as this slice is small (~10 elements), it is faster to just loop over it in a sequencial way. The total number of digits of all numbers having the same width (same amount of digits) are also constant values. We will precalculate these and store them so we don't have to repeat this constant calculation. For the first 8 digits: 

Your code looks ok to me, but here are a couple of points to improve: You used the package to obtain the arguments to your program. The original intention of the package is to process optional, named arguments to your program and store their parsed values into variables (designated by pointers). Using it just to obtain a list of arguments is somewhat "overkill", better would be just to use a simple variable in the package: . holds the command-line arguments, starting with the program name. Since you don't need the program name, skip that by re-slicing this slice. Your new function: 

I would not place logic to prevent the code from executing multiple times. The function itself does not operate on static data, but data passed as arguments. This makes it a very reusable function. It is simply a function that can configure a Windor container, but the function doesn't care about which container it is. The application does however care. The application desires to only have one container. Thus it is the application's responsibility to only create one container, and calling the function once for that container. Lets say you later want to create an automated test verifying that this function initializes the container correctly. That test would create a new container, call this function with that container as argument, and then operate on the container, verifying its state. If this function by itself prevents from being initialized more than once, you would be at a serious disadvantage in creating such tests. You could however do something else. If the function could examine the state of the passed container, it could determine if that container has already been configured. The function would then be able to make sure that a specific instance of a container is only configured once. But personally, I wouldn't bother in this particular case. 

If we look at it, is the negated value of (if they are equal, no need to swap). So we can rewrite the rule; swap elements if: 

I think both your solution and your testing are fine. A couple of test cases I would add (but your solution also passes them): 

Using a constructor-like function is the idiomatic way in Go. See Effective Go: Constructors and composite literals. Also relevant: Effective Go: Package names: 

By doing this we also got rid of the package dependency (so it won't have to be added to your compiled executable; and was already used, so that's not a plus). Next on to your utilized as a Set. This is how you check if something is in your : 

2. Convert the first to raw bytes Compare slices () We may choose to convert the text checksum back to a which holds the raw bytes of the checksum (NOT the bytes of the UTF-8 encoded hex representation). We can parse the hex representation simply with . Or even better: since we have the text checksum as a , we can use which takes input as a . As an extra gain, we don't even have to care about lower or upper case: handles that for us. And we can convert to by simply slicing it. Once we have 2 , we can use to compare them (in Go slices are not comparable unlike arrays). 

It's (often) slightly faster in Python to avoid the statement. After measuring that with , you should rename the variable . That's a poor name. 

These aren't "utility" functions. They appear to be central to your app. There are rarely "utility" functions in any app. What we used to call "utility" functions are almost always part of a standard library. 

This may be better than a list. A list where the order of the arguments is critical is a bad thing waiting to happen. Code like is utterly opaque. It should be replaced with so that the meaning is obvious. Also, once you have an class, your separate function becomes needless. You can subclass like this. 

You still have the calculations. You're just giving them names and keeping them separate. Giving them separate names makes them more reusable, easier to test and easier to find. The most important thing here is to avoid creating a (nearly) useless class who's only job is to contain a bunch of functions. Your code uses no instance variables and simply uses another function that happens to be in the class. Both of these could be method functions. There's no reason -- in Python -- to create a class unless you have instance variables and a change in state of some kind. [In Java, you must often create "all-static" classes because there's no other place to put stateless math like this.] You can simply put these functions into a simple module and avoid the class definitions. 

Your type is a struct, and 2 values of the same struct type are equal if all their fields are comparable and are equal. So you will find a value in the map if they match by and . is an interface, so a different comparison rule applies here. At runtime interface values can hold values of different dynamic type. Both the dynamic type and the value must match in order to claim 2 interface values equal. (You can read more about the representation of interface values in blog post The Laws of Reflection: The representation of an interface.) The dynamic type of the values stored interface is a pointer, a pointer to the unexported type . So now we need to apply the comparison rule for Pointers. 2 pointers are equal if they point to the same variable. So 2 values of will match only if the pointers stored in them match. You used to obtain the slice of s, and whenever you call it, it creates new pointers and hence they will never be equal, meaning the wrapper interface values will never be equal, meaning indexing the map with these values will never yield any results. 

Besides that, the place where I would clean up would be the actual objects that you are querying for data. You have a lot of casts, and a lot of .Value lookups to get to the real data. This results in the code that uses those classes reflects the design choices made when implementing those classes, And that is the real reason why your code looks awful. I would change those types, so you would be able to write: 

I have inherited a node-js project, and I am completely new to it. Fortunately, it is already covered by unit tests. The class under test, , has the responsibility of sending HTTP requests to a remote server. My first refactoring was to extract the HTTP behavior into the class, to allow testing that an operation requests the correct url with the correct data, without actually performing the http request. The class did not previously exist. I am looking for feedback on the unit test from a perspective of best practices. In particular, how do I best avoid the duplication of calling the function through the different tests? 

Add +1: (this is why we stored powers of 10 -1) Multiply with the digits count: Add the total number of digits of all the numbers having less digits: 

Also it's just a matter of taste, but I find it easier to read if you use the index instead of the length (which is ): 

Implementation Things to note: To determine which power of 10 preceeds the input , we may use a loop always multiplying the previous number by . These multiplications (the powers of ) are constants, we don't need to do this in the function, we can precalculate them and store them in a slice beforehand. Note that for practical reasons, I will store the power of 10's -1. See below the implementation for details. 

Compare manually (byte-by-byte) We can also do the comparison manually, it's relatively easy and straightforward. But first to do it manually, let's create a simple helper function which tells if a hex digit (the text representation) equals to the raw data: 

Now an explanation why your original didn't work as the key. When you want to find an element in a map by key, Go uses the comparison operator to test for equality of keys (hash code is generated and used under the hood to speed up the lookups, but that is irrelevant now). This is how the spec defines the terms and the result of the comparision. Quoting the relevant part from Spec: Comparision operators: