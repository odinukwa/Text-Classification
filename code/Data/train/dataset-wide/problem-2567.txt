I was debating whether this would be more useful as a or an , considering all the operations you were trying to add to it. A struct would have been a safer bet. However enums are much more lightweight and the way you're using it, it doesn't need to be more complicated than that. 

You have the right idea, but you didn't quite know how to get there. You don't need that function to operate on the left or right lists. Just bind them to separate variables through a simple expression and you can add the items to each of the lists. 

Note: The calls were needed on all invocations to ensure that the intersections are actually generated. Run on my machine with multiple collections: 

Don't parse it through string manipulation, use the XML libraries in the framework. I'd recommend LINQ to XML. Parse it and make your changes. 

I would avoid performing linear searches through this as you'd be looking at O(n*m) performance when you could be doing O(n+m). Use set operations if you can. Use if possible too. 

The function is an integral function. It's arguments and return type should be integers, not doubles. By using floating-point arithmetic here, it is also probably not as fast as it should be. Also, your loop may start at , save yourself the iteration. :) There's no sense in making in your function a . They should be typed based on how you use it in this case so it is absolutely clear. It would also be a good idea to rename it as it is not a standard function (that only works for positive integer exponents). That assumes you're not intending to expose it for use outside your module. If so, you should probably make it as well (same for ). Also, the similar arguments with your function. There's no sense in making your loop variable a , it should be an integer anyway. With the above two fixes in place, you can easily fix this. Rather than looping through all the terms, alternating between positive and negative terms, it might be a good idea to help the compiler and processor out here and split these up as separate loops to remove the branches. That way the compiler could possibly unroll this better and you're not potentially confusing the branch predictors. Try it out like this: 

I have setup agenda tasks to periodically retrieve and possibly insert new SE sites and tags in my MongoDB database. Some things that bother me in particular: 

I don't like that both filenames and extensions are in the same array. If you have 1 extension and 5000 files that have to be excluded, it will iterate over 5000 files (if you have bad luck) for no reason. 

If you push these two changes through to the several places they manifest, you'll find that your code has shrunk a lot and is a lot more readable. 

Conclusion Overall the code is very well written and easy to follow. Some styling remarks that can be solved by following the conventions and some code that can be written less verbose but I couldn't find anything that struck me as potentially performance hindering so you're good on that aspect. It's fine to use the parameters, nothing wrong with it. The naming of your methods are all in the form of whereas convention dictates . This results in "IfSubscriptionExpired" vs "DisplayRenewSubscriptionDialog". I can see where you're coming from with the scheme since you are basically building a flowchart so I would be okay with it if it makes things easier in your case. 

Helper methods Are they really necessary? The concept of helper methods is that they perform some tasks that can be used throughout multiple places in your project. You have one class so it's in fact impossible to have that situation. But even if you did have multiple: these methods are all specific to that one class so they belong as members to that class. Exceptions This line with invalid input, will cause your program to crash. You should add appropriate exception handling: 

Throwing the contents into a dictionary will lose any sorting you may have had. Dictionaries are unordered collections. The cleanest way to deal with this really is to implement your own custom comparer to compare the columns and reset their order based on the ordering. I believe this would be more or less logically equivalent: 

Looking at this at a much higher level, what are we doing here? We're adding up the sizes limiting each size by some factor (a maximum). Write your code to do that. This is how I'd write it: 

Do you see the problem now? There's a couple of ways to fix this but let me start with what you should have done always. If you ever have a block that would span multiple lines, you should always wrap the block in curly braces. That way there's no confusion what goes where. It's more forgivable to not include them if it's just a single line (just like you have in your individual statements) but all three of them belongs to the body so they should be in braces. The other thing to about this code is that those three statements are mutually exclusive. Only one of them could ever be hit for a given character, . So you shouldn't have created a series of statements like you did here, but instead a set of / blocks. That way the following statements don't get executed if the preceding one was satisfied. This could have fixed the logical error for the loop too but it's still important to include the braces regardless so there's no confusion. That block should have looked more like this: 

I am not great with datetime styling but I am 105% sure you are reinventing the wheel. Take a look here (standard options) and here (custom options) for all the different ways you can create your own date and time representation. 

Your code is not extensible to more (or less) than 3 parameters even though this shouldn't be so hard. Below is an example how I would do it with 3 hardcoded parameters: 

I am not a PHP developer so I can't give you an expect implementation but I do notice some things that will make handling the API easier. 

You're constantly locking the result set. It's probably faster to just omit the parallellism altogether since we're not doing that much work anyway but if you really want to have it, I would suggest looking into splitting the to-generate dataset beforehand, computing the data and storing it in separate collections and at the end combining those collections. Though that might be slightly overdoing things. 

I'm about to watch Vikings so here are a few quick pointers: Naming Your code contains variables named , , , etc. This tells me nothing about what that variable does. I'm not experienced with but I assume refers to an invocation. Such a variable could then be rewritten as , for example. This tells me a lot more about will also read easier when done everywhere: 

It might be useful to have options for multiple parameters (similar to how the tuple is). Though it might not be feasible to have all combinations of multiple (im)mutable arguments. 

On a side note, I would move the null and positive id checks into your "checkId" method. In fact, I think in this case, these checks are redundant and unnecessary. You're just checking if an id is in an existing list that you're maintaining. If it's , it's unlikely it will exist in the list (if you are preventing arbitrary values from being added). An id outside of the range of expected values will just not be in the list in the first place and therefore is unneeded as well. But, if you must perform these checks, do it within the method instead. 

I'm not sure how you did your testing but even with your implementation, I still get much faster results, even in the single collection case. Tested in LINQPad with optimizations enabled: Your implementation: 

My experience with Javascript isn't quite as developed as it is for other languages, but here's what I have to say about the code. Why use and ? You'd use those methods if you wanted to call a function repeatedly. Since all you do is set it and immediately clear it, there's no point in really using it. Better to use instead. I'd consider rearranging your parameters so the was last. That way you can make the delay optional, possibly provide a default delay instead. Also consider making optional too. It could be possible that you don't need the callback so you're forcing yourself to have to provide one. I don't think you'd want to put a delay of the first invocation on the first item. So probably should remove that initial timeout and just call the directly. 

Update In response to your questions about retrieving the ID I made a little sample project to confirm my suspicions and it's like I thought: the original object's ID is being updated when inserting it into the database. Take a look at the following code: 

You're interested in a which, coincidentally, actually inherits from . Additionally I would also suggest adding a constructor so you can initialize properly (and it should be a requirement either way). This would result in code like this: 

So, I've created my first Chrome extension! What this does is it highlights every post on Reddit that comes from a source of dubious quality. It provides a few sources by default and allows the user to add or remove from this list. The user also has the choice between either highlighting the offending post or hiding it altogether. All settings are stored in sync storage which allows them to be used across chrome instances. 

This is not my forte so I'm limited in the review I can offer. Something that jumps out though is this: 

Keep the indices in ascending order -- it's what everybody expects and you won't have silly mistakes because the arguments passed in expected 0-1-2-3 instead. 

Explicit visibility I don't like relying on standard visibility; explicit declaring takes away all doubts. Instead have this: 

You've already placed a constraint on the first parameter that it should be , so the methods of that interface is available to you. 

Or alternatively, use the class to do your logging. As long as you have no listeners registered, you will not see any of the logging messages. When debugging, add a to the collection. 

There are many improvements to be made. If you think of the months as indexes, it will simplify everything. You shouldn't have to loop n times just to figure out what the n'th month is after January, a simple addition should be enough. By doing this, this will allow you to remove many of the redundant operations that you currently have. First let's start with the extensions: 

Consider using data binding to create your tree instead. I don't know how it works with ASP.NET so I can't really give you tips on how to do it. But doing so should make this step unnecessary as the framework will generate the tree for you. You'll probably have to create a class to represent the topics organized in a hierarchy but you could use the above code to create that hierarchy. 

I have to apologize, I have changed my review as I wrote this due to some details I overlooked as I was writing. Thank you mjolka for pointing out my mistake. For multiple collections, the new implementations will always be a win over the aggregation. In the aggregated approach, each sub-instersection needs to be determined for every collection. In our new implementations, only a single set intersection needs to be maintained. The new implementations will not beat out the aggregate method in the single collection case however, because the aggregate will simply pass the collection through as the result untouched. The new implementations will always do some bit of processing. However again, I feel that if set semantics were preserved, this difference will probably be cancelled out anyway. 

You're not using any form of globalization. Intended? Adding a resourcebundle isn't much work and you'll finally be able to support Swahili. 

I don't know what this does exactly but I do see a problem: right now you're directly linking the presentation of your application to the codebehind. It's obvious why this is a problem when you're thinking about multiple languages: suddenly the same menu but in a different language might not work as you expect it to (I don't know the actual code that uses it). What I would suggest is the following: since you have to work with the limitations of the lack of and your content is displayed on the same page instead of spread over multiple pages, you need some centralized way to display what is shown when the selection in the menu listbox changes. I agree with your current approach but right now you limit yourself because you can't change the presentation without having to change internal workings. I propose the following solution: 

Concerning OO principles: perhaps create an interface that defines a method . Now your can implement this as receiving console input while the implements it by taking a random value from its stored text. This makes sure you can just call for both objects and introduces some inheritance structure. 

First let me point out that you shouldn't name this extension method as you have named: . The name already exists and will return the intersection of two collections. Your method is intersecting a collection of collections with each other. It should must be named differently. I would suggest or possibly . I feel your implementation for the case of a single collection is wrong. You are performing a set operation here. You need to ensure that for all cases, you maintain set semantics. You assume that for a single collection that you may return that collection. But what if that collection contains duplicates? You would need to filter out those duplicates. The aggregated version should as well. 

If you want to optimize for speed and possibly memory, just use regular loops to build up your dictionary, though it may hurt readability. The idea is simple, scan the string for keys and values simultaneously. Don't extract substrings until you know what you need. Scan each token until you hit a delimiter and add the corresponding keys and values to your dictionary. Assuming none of your keys or values do not contain any of your delimiters and everything is well formed and you have the same amount of values as you do keys for every string. 

You don't have to specifically create intermediate collections once you dropped the : you can just insert them inside this method. Note that even if you go this route, at least define them as to loosely couple your code a bit more. Don't repeat the "list" part either: we already know it's a list. 

This is basically one method where you provide a standard option. There are two choice you have here: either put the implementation in one method and create an overload like this: 

You're declaring your viewmodel as . This indicates encapsulation abuse because a single viewmodel instance should be tied to a single page. In fact, you often want a specific viewmodel for every page (where appropriate) so there isn't that much re-use of the viewmodels in the first place. This should become unless I'm missing a critical piece of information. 

Your code doesn't work; executing it will return and , not . This happens because you don't set the property of the nodes that are passed in to the constructor. 

If you want to make it easy for your user, you can hardcode these different methods into properties: 

and indicate a return type of and respectively. Choose naming that indicates you are receiving their input.