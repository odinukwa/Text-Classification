And similar for the other one. This also allows for a little better file handling as Python keeps track of the file handles, and you don't need to. :-) Assign tuples to variables Another point related to readability would be to do something like the following: 

So in general, always try reducing the number of subprocesses started, as they are quite expensive. And calls usually triggers subprocesses as well as the . 

Out of these I believe the last one, dedented multiline, or the implicit concatenation (with internal ) are my favourites. (But it's also kind of cool that you could use to get the docstring of the function, and possibly use that!) The two first multiline options fails either on outputted indentation, or not so nice looking code (the code indentation is disturbed). 

Performance is important, correctness is usually even more important. In your case I would possibly opt for a combined solution of transformation detailining and performance issue. Build one block to handle all standard cases, that is for when the has good values. This will give you a bulk case for the primary part of your data. Next build a special case for when it is , and handles this in a case by case basis like in your first example. Experience usually dictates that 80 % of the migration work, takes 20 % of the time, whilst the remaining 20 % of work, take 80 % of the time. Once you realise this, you can focus on writing good, precise and fast migration of the general cases, but make sure that you have routines and procedure for all the exceptions which will arise. 

As stated my main issue, is that the actual commands are hidden within the class structure, and I would rather make them separate classes. And I would focus on making the various options clearer. One way to do this is to change into a structure like the following diagram: 

Disclaimer: Please note that code is untested, it is more for giving a gist of the idea of using a linked list. 

I profiled version 4, and found that finding the common start was the slowest part of my code. Then it hit me, why don't we skip comparing byte for byte, and instead do a string compare on current instead? This leads to version 5, where the code around has been replaced with the following: 

When timed (without the statements), this ran about 33% faster than the original. It does kind of reuse the random numbers slightly, but it shouldn't affect the overall randomness too much, I think. Other possible factors Just for the fun of it, I also tried exchanging the with a loop, but that only had a minor effect for the larger number of runs. NB! If you was using Python 2.x, there would most likely be a massive effect out of changing into . The could be eliminated, and the could be moved into the block. This also, has little to no effect in my tests. Lastly, using various python implementation will also effect timings. Using PyPy, IPython, C-Python(?), or other variations could change the time usage. I've used $URL$ which reports the following on : 

A better solution related to MongoDb However instead of doing a busy loop with some code which I don't fully grasp, I believe you should look into the monitoring of the mongodb. This would allow you to get notified when commands are executed against the mongodb. At least, that is how I read the documentation, with little knowledge of mongodb. And this pattern of adding a listener, and then waiting for it to respond is a bettern pattern rather than busy waiting and changing stuff to check if it is alive. 

Just turning some of the comments into an answer, more specific I'm going to address these issues in your code: 

Most of the solutions provided so far is hard to read, and you need to really think before you understand what is happening, so I would like to propose an alternative approach as a response to a more straightforward algorithm: 

A final important suggestion, I would strongly consider splitting up your into multiple function. Now you have code which does: 

Variant over the same theme If you don't want to use logic in the class you could also add a property to your viewmodel, using something like the following: 

Notice how the 'dots' have changed to include an , and that the line names that is was the in the class which has failed, and you get some details as to what failed. If the test is well written you should now easily see why it failed, and hopefully understand what went wrong. 

It is hard to review something when you can't test whether your reviewed code actually works, so with that disclaimer lets see what we can do with your code. Regarding style issues, your variable names are not good, and doesn't convey any useful informations. But leave that as it is... Here are some elements I've incorporated in the refactoring below: 

Here is another view on your class structure, in an attempt to make it both more readable and more pythonic so to speak. Let us start of with a yUml diagram of your class structure (somewhat simplified): 

Other than these your variable and function names are OK. Regarding improvement on your algorithm here are some other comments: 

The other answers has mentioned good and valid points regarding how to get the different dates, and handling of these. I would like to focus on your date arithmetic, which should be done using date utils to avoid strange cases. One issue that you've locked all of the months to be 30 days. What about Febrarury with 28 days (when it's not a leap year), or all the months with 31 days? Similarily adding 12 to the does end up with a non-legal month in some cases, although it does somewhat work for when you calculate the difference afterwords. But this kind of arithmetic on dates can lead to various strange results. You are usually better of using real dates, and doing date calculations using either builtins (like datetime, or external library specialising on this (like labix dateutil. Some other style comments: 

given that both and inherits from the class. In other words, now you can do for any enum value inheriting from . 

Code alternative I haven't commented too much on your chosen algorithm, as I find it a little confusing, so I thought what is he trying to achieve and what is an alternative approach. I then came up with these demands for the code: 

In the table below I've listed the length of text with corresponding number of points/words, and how many characters are needed to store these words. As can be seen these number increase quite fast. The last line is memory usage in megabytes when using memory_profiler on the original code. 

Performance issue One option I believe could hurt you performance wise is the search in for any translated resource. This will all the time do an \$O(n)\$ search, and thusly render your entire code for merging to be \$O(n^2)\$. If you instead had made a dictionary of all the old strings, the search could be more like \$O(1)\$ (or some low cost for checking the dictionary) at cost of a prerun through . This would render the merge process to be \$2\cdot O(n)\$, which is similar/counted as \$O(n)\$. Where \$n\$ is the number of strings to be translated. In other words, if using a dictionary for the old strings, you would most likely get a much faster merge operation when the number of strings to be translated increases. PS! As it is a little late in the night in my part of the world, I have not written any new code. Please tell if some of the comments are not understandable or you don't know how to correct it 

Notice in this output how I've connected the table to , and to , and so on. Therefore when adding this line: 

I'll have to agree with some of the other that I don't see the need for using a class in this case, although you get a little credit for using the naming scheme for public and privat methods. But what I would focus on is your & co methods. You say that you're happy with them as they do just one thing. In my book they are too localised and specific. They are not very reusable, and you would be better served with one general method: 

Alternate Solution Most Euler problems have at least two major solution: The brute force solution, and an optimal solution. You've implemented the brute force of testing each and every number to see if it matches the criteria. In some cases the brute force can be improved somewhat, like skipping all the odd numbers, check for ending of 0 or 5, verify that the value is dividable by 3, and so on... This will usually lead to a somewhat faster solution, but when tackling the higher Euler Problems that'll not be enough. Therefore it is a good idea to start looking for optimal solutions, and what is really asked for. In this case what is the number , and how have they derived at it? So what we now about that number: 

On the bright side, your code is nicely indented, and you are pretty consistent with bracing style, and other stylistic elements. And it does what it is supposed to do! Alternate algorithm In the comments I suggested to use split and join, which has been commented upon by another answer afterwards. In the answer by janos, it's suggested to keep as is, but here is a faster alternative where you only traverse the text once, whilst building the result string. Code follows: 

An alternate version, not using dict's, can be made when noticing that the binary version is simply the letter position in the alphabet. If one in addition makes it a little more generic, so it can handle longer text you could end up with something like this: