You should insert a once you have determined is . This terminates the loop immediately since you know can't possibly revert to again for subsequent iterations. You may also want to look into the algorithm used in the Sieve of Eratosthenes, which filters out non-prime numbers from a sequence. Sounds good for your usage. For other Java-related suggestions: 

Picking out only the values 1 and 4 () is understandable, how can one check that we have both 1 and 4 in the end? I went with a operation and then counting that we do not have both values... 

Short (and hopefully sweet) advice: Are you able to modify to throw a (I assuming you're talking about the linked one) if its argument is ? Something like: 

Each step can be a smaller method in itself. The developer benefits of having smaller methods in your case is that it clearly isolates what fields/properties are required for each 'stage', which in turn allows you to better understand how you code works or can be rearranged. The JVM benefits of having smaller methods is that the JVM can decide when and how to inline method calls optimally to enhance the overall performance. My suggestions below are going to be Java 8-based, primarily because I like to use such opportunities to showcase how much simpler can external iterations be done using s. If you happen to be on older Java versions, the conversion shouldn't be too hard in any case, and I'm quite sure a quick check at StackOverflow should offer some help. ;) Let's start by starting from the end of the steps covered in the pseudo-code... 

I think it's fair enough to use one for printing some output and using it for the message. I will now present the full suggestion: 

Short answer: You need the Java Collections framework. Instead of eight standalone variables , you should put them into a so that you can easily iterate through them: 

And if you will like to make it even more 'generic' and cater for non- types, you can specify a to do so: 

Convert to via . Convert to via . Convert to either a or . Using the former because... Setting the time via is arguably more fluent, which gives us a instance with the desired time in another 'step'. Finally, call to get the instance. 

An alternative - and often recommended - way of checking for a collection's size is to use . It is slightly easier to read than . concatenation When you are using a with or -style concatenation, you are using the wrongly. :) Rely more on its method, instead of constructing 'sub-substrings' and then passing the substrings into the instance. 

The numbers and are not only hard-coded, but they have an important relationship as well. If you decided to change your to , you'll need to remember to change your output above too to say . It is better if your class has a field to mark this: 

You can even opt to daisy-chain the entire thing, from to calling . Just two more things to highlight from my code above: 

These methods should return a , not an . This is because method callers should only know that they are dealing with a implementation, instead of an specifically. On a related note, you may want to reformat these lines to follow the standard Java convention, as you have done so almost consistently elsewhere (hint: your loop constructs are missing curly brackets). Superfluous methods I have no idea why you need to roll your own implementation for : wouldn't returning be good enough? Java 8 concatenation alternative If you happen to be on Java 8, the implementation can be fluently replaced with a stream-based approach: 

Next, think about 'converting' each desired condition (whether the character is , ... a space or a symbol) into a 'place' in the array, i.e. the index. For example, you can count s in index , s in index and so on (ignoring case sensitivity for now): 

The implementation for local/remote primary/secondary addresses all look extremely familiar... to the refactoring machine! 

If you are going with the (i.e. approach "2.2") way, you will need to call . This reuses the instance throughout the method: 

If you can post a follow-up question by answering some of the above (say with more code from other parts), then I think there's a lot more that we can help you to improve on. edit: Let's attempt to break down the actions into some steps. 

Do you mean users when creating a new must append another inside this method body, instead of the implementation itself knowing how to update the ? Are you referring to are the number of implementations that the users choose to in the when you mentioned 'all processor types', or everything loaded by the classloader (which I infer from your reflection solution)? 

You have just defeated your purpose of making a constructor... and not only that, it makes it possible to create an instance with fields. Even if this should be possible in your codebase (as used in ), then I will suggest simply sticking to two constructors - one with the arguments, and one without. The then becomes unnecessary. I am also unsure about the viability of ... unit testing should be asserting the behavior of your class's features, not the visibility of its constructors and methods. 

To retrofit my suggestion into your example, I suppose that somewhere in your users' codebase contain their required objects, such as the ones they are already creating now. Thereafter, they can pass them into your 'factory class' so that it can construct the mapping. For example, using a setter: (-loops) 

Naming and style convention On a related note, can be better named, and you should standardize where your braces are. In fact, use them even for one-liner statements, as the following looked odd at first glance. 

This looks like a good use case for a supplementary 'key' class that will allow us to grouping objects with the same account, product and data source. For example: 

You can literally use the builder pattern for your Builder game here. :) See, you have group of buttons that must be assigned a same color. These buttons have a corresponding pair of button label and a implementation. Therefore, it's not hard to imagine a implementation that lets you chain these operations: 

What are ? Global variables? Any reasons why they are not a of courses? What exactly is the relationship between , and ? Is some form of user input indicating the desired period the course should go to, to be set for one of ? The reason why I ask this is because clearly you are only checking whether is free for period . How is calling related to adding a course to one of 8 periods? 

Do you really need to invoke when updating effects? Since the maximum number of elements you can have in your is bounded by the number of values (BTW, you may want to switch to an ), I think the overhead of doing a concurrent access on your is not required. Also the operation can be done using a method reference as well, in this case: 

I meant that partly in-jest, but if we really need to avoid any loops, we can also call each value one-by-one to print them: 

We use 's shell keyword to collate our conditions together. Helpfully, supports the use of and . is quite a useful (IMHO!) construct in for implementing a logic. The only thing to note is that you can only specify one command each for both branches. As such, we can 'inline' our increment of and do an always comparison to simplify our branching, namely to either () output the line to the output file, or () increment our . Otherwise, it gets slightly longer due to the required use of compound command: 

Your log output shouldn't also be detailing the code that failed, because the JVM is going to generate a more detailed stacktrace, and you should print that instead. 

Exception handling Your current approach of exception handling looks like it's just the default option that any good ol' IDE provides. You should be more careful though, for example when the program fails to read a file. The current implementation simply prints the exception stack trace at the constructor of , leaving all its variables as the default values, which makes it easy for errors to be thrown to users of the object. A object that fails to read a file should instead propagate the error to the user. 

This takes each element of , it into the required object, and then each of the result into a . With these two methods, you can already replace the -loop as such: 

The main advantage of using is so that the textual representation is available for use by users of your class easily. Getting to the crux of your question (which I have also somewhat answered above): 

More importantly, I will suggest decoupling the lines that handle the creation of your domain objects and those that handle the Hibernate persistence. That can greatly reduce/eliminate the nested error handling you have to do in your code currently. More importantly, it makes your code easier to recover from errors. For example, if it's only the Hibernate persistence failing, you could potentially cache your non-persisted domain objects first before feeding to Hibernate again. 

Unless the SDK explicitly discourages the reliance on the ordering, usually it's reliable enough to do so as changing the ordering will potentially have other complications (e.g. iterating through an or will change too). That means it should be possible for you to derive the appropriate mapping by: 

BTW, you have a spelling typo too: it should be , not in . Also, seems to be an unnecessary instance field, as you are operating directly on the object. Therefore, you can probably just stick with: 

One small change you might notice is that I rely on instead of an implicit unboxing using arithmetic operators. Ideally, you'll want to check against values too. Using it will be: 

This is a personal preferences thing, but I'm not a fan of prefix in variable names, since this is not exactly a recommended Java naming convention. I understand your usage here is to let you conveniently name your values as numbers, so it's really up to you whether to stick with it, or go with , , , etc. You also don't really need a field for it, since you can always return (or , shorter due to the implicit casting of ) from . One more thing, types' names are usually singular, but since you have consistently used the plural form, I think this is fine too. Generally, consistency over convention, over chaos. 

The good Let's start with something (unfortunately) short: Making a class is a good start. Interfaces over implementations It's highly recommended to declare variables or method return types based on interfaces over implementations, as users of the variables/methods should not need to know how the object works, but what they can use it for. Simplifying logic You can use to simplify the seemingly complex-looking chains inside to: 

To just . This is related to the previous point too, since I do not need to rely on your array. Use s to represent the various types A great deal of your 'calculations' and repeated method calls can be easily avoided with the right implementation of an , e.g. .