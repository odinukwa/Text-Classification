The reason is that it completely bypasses all of the few legitimate reasons to (see Setting objects to ) because it allows VBA to auto-instantiate one for you: 

The first thing that jumps out is that you're testing with 6 times per cell. VBA's doesn't short-circuit like other languages, so you'll test every single one even if the first condition is true. You can use for short circuiting by checking conditions against . So, your condition... 

My rule of thumb is that Windows COM calls are generally expensive, and are best avoided if alternatives exist. This should be finishing on the order of seconds not minutes, and the majority of the processing time should be coming from simply opening the Word document. 

While you probably could come up with an algorithm in VBA that does this fairly efficiently, I would doubt you'll match a relational database engine in performance on this. The take-away here is that if you're looking for the best way to skin a cat, make sure the cat needs to be skinned first. 

I'd get into the habit of using the built in constant. It's easier to read at a glance and doesn't require a memory allocation for an empty string. 

OK, went through the code and gave this a bit of thought over the past couple of days. As far as the implementation goes, I don't see a whole lot that I would change (that you didn't identify in the answer above) other than a couple nit-picky things. First, is the use of the variable identifier. I couldn't find anything that justifies the naming and data structure other than imitating a .NET keyword. The keyword (as ridiculous as it sounds after writing C# for a while) is obvious to a VB6 programmer - is not. I would personally stick with individual member variables instead of the , but if using the I would name it something like . The fact that you were compelled to explain in the post what refers to in the class is a red flag because it isn't immediately obvious. The second nit-pick is also related to using .NET metaphors that do not directly map to a VB6 context, but this one comes from the opposite direction (and falls into the "errors being raised" category). A .NET programmer will expect assignments that are not type-safe to fail at compile time, not runtime. For example, this snippet in VB6 compiles and runs without complaint: 

As far as your specific question goes, this actually looks like it would be quite a chore to maintain. Adding a new name to an existing advisor is easy with your set-up. For example, if John Cusins decided to change his name to Jim Nasium, all you would have to do is add under his in and change his in to . But, this points to the next issue - your isn't really serving much use as much other than a place-holder. On the one hand you could change the element to everywhere in your code, but this kind of defeats the purpose of having a named identifier. On the other hand you could leave it as , but this now means that it isn't appropriately named - why should the element associated with a person be different from their name? If I was only looking at the function and not the entire module, I'd be wondering "why is the SarahCotter case returning ?" This also points to the main issue in maintainability and extensibility - to add an advisor, you need to change the code in 3 different functions and add a value to the enumeration. At the same time, you need to make sure that those changes are all consistent with each other. The urge to copy and paste will be very hard to resist... ...which leads to the last point - you're repeating code all over the place. This gives me a whiff of code smell. Wouldn't it be nice if you didn't have to type again and again and again? It would be much better to approach this problem with the mantra Don't Repeat Yourself in mind. This is a problem begging for an OO solution. You have 2 distinct things you care about - advisors and names. So make an advisor class and a name class. Make them responsible for the things that advisors and names care about. I.e.: Name.cls 

...makes 3 cell reads (two are the same), but if is , it doesn't just stop there. You can either nest the statements... 

There are a couple helper functions for managing the array indexes - the first skips matching substrings in the 2 arrays: 

This blog post by Eric Lippert explains this much better than I can, and probably a little more diplomatically. 

First thing first - if your else condition ends with a return, you don't need nest your if statements. Just reverse all of your test conditions and return if they are true. This also makes your code much more readable, because the condition you are returning is next to the test in your code, not the reciprocal of it's distance from the top of your nest: 

That saves the next person who sees the code from doing the mental gymnastics of trying to remember that and are 2 entirely different things. That said, if you like the UDT, I'd at very least name it something else (like maybe or ). C# programmers will be grateful. 

...appears loop over the same set of cells repeatedly when their values aren't changing. I don't recommend this often, but you might be best served by a completely different strategy. If all of the values are unique, there isn't any reason to update column A until you are completely finished (or add your check-marks for that matter). This is the part that doesn't make much sense to me: 

Internal Functionality: Just a couple of helper functions to convert the enumeration values into the command line options: 

Style comments were covered by other posters, although I'll add a couple more. First, you have some conditionals that don't do anything. For example on this one... 

This illustrates the second issue - you are not actually benchmarking the code itself, but the performance of each of the underlying compilers. Assuming that the syntax is analogous between the two languages doesn't mean that it compiles the same in the C# compiler as it does in the VB.NET compiler. In fact, the different warnings between the two compilers make this quite obvious. Remember, just because the IDE is the same doesn't mean it does the same thing when you compile it. A proper benchmark has to be compiled under the same conditions. This is essentially like comparing benchmarks between identical C code compiled with gcc and Visual Studio. I am curious how similar the compilers are though - try removing the return instruction (or adding one in the C# code), ignore the warnings, run the benchmarks again. EDIT: Finally had time to look at the IL, and the recursion doesn't have anything to do with the performance - both of them have exactly the same IL: 

DateRange() function Array handling You have a bug. The first element of will never be populated, because you give yourself a single element on this line... 

If that's your , change it. and are both VBA keywords. If it isn't your , fully qualify the members both to make it easier for the reader to see what you mean and to avoid any potential that they would inadvertently conflict with the keywords: 

General 1 - The first line in is setting the return value to its default. At this point in the function it is already : 

So if the intention is to enforce type safety, the better meta solutions would be to not use Variant types if they can be avoided or to use an IDE plug-in to make sure your assignments are type safe. If the intention is to simply replicate the functionality of the .NET List object, this is an entirely different matter (and one that is both useful and well executed, BTW). Nit-picking aside, let's get down to the "better /more efficient" side of things. Given that the object in VB6 isn't much more than a glorified array (4 methods - seriously?), I would just skip it entirely and just wrap an array directly. The vast majority of the class just uses the for storage space, and the fact that the intention is to ensure strong typing makes the memory management a lot easier. Note that I am not recommending an array of Variants, and am at risk of getting into StackOverflow territory. VB6 is based on Window COM, and uses a SAFEARRAY structure to store all of its arrays internally. This (vastly simplified) defines the size of each array element, tracks the number of elements in each dimension, stores a couple COM flags, and holds a pointer to the array data. Since VB6 is COM based, it also has a couple of undocumented functions like for pointer resolution and manipulation and can directly access the Windows API. This gives you the ability to do inserts and deletes into the middle of arrays with memory copy operations instead of iterating over the array or the a . You can get the underlying data structure like this: 

User Interface 1. doesn't display appropriate errors If the user simply hits "OK" when the is displayed, Excel shows this error dialog: 

Using a Set is problematic. First, as pointed out on the original question in @Vogel612's comment, it restricts duplicate values. Second, it also makes your code a lot messier, as you're now grabbing an , calling , and testing in a loop instead of using more concise syntax. I'd just use a , get rid of all the casts, and use a for-each style syntax instead of using the . Finally, and aren't very meaningful as variable names in the context of this snippet. If they are meaningful in the wider context of wherever this came from so-be-it, but I find something more along the lines of and much clearer. Something more like this: 

I'm not sure what you mean by "This does the trick but not very efficiently". I don't really see a way to make the algorithm more efficient, as it is just making a single pass over the array and exits early when it gets the answer. If the input is really long, you could convert it to a byte array instead of splitting it to cut down on the casts, but then you would have to nest the loops, add a subtraction to convert the ascii codes to numbers, add multiplications to keep track of multiples of 10, etc. This would likely be a lot slower than the current method unless you were working with strings on the order of kilobytes. That said, a couple of observations about the code. I'd personally use a For loop instead of a While loop to prevent you from running outside of the array bounds for inputs where the target number you are looking for is higher than the sum of the complete array. For example, with the input string of "6-7-7-10-7-6", a target higher than 43 will overrun the array bound and throw an error. You'll get a similar error if it is passed an empty string (Split will happily give you an array with an upper bound of -1 in that case). Also note that you are not returning the zero based index, you are returning the one based position of the token in the string. If this is the desired behavior, I'd rename the function to make it obvious that you can't use the return value to index into the array. About the only thing that I would do to make this a tiny bit more efficient would be to use a String array instead of a Variant and use explicit casting so the run-time doesn't have to resolve the Variants for you more than once. Even this improvement will likely be unnoticeable on any reasonable sized input (you'll overflow an Integer long before you'd notice the performance increase anyway). Maybe something like this: