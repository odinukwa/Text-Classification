Theory Fist of all check this article about memory management, it will help to find leaks if any. Look closer at this part 

UPD: With single attribute you should create singleton, which will handle synchronization. I had try to draft singleton, but it is not so easy for me. It should be responsible for removing duplicates from task queue and watching on data consistency. 

Garbage timeout Look at dummy example of garbage timeout at fiddle. I'm creating array of 30M elements of , that are binded to root object - window. 

Also, You should consider adding function and for Your library user not to mess with and directly and handle errors properly there. Generic rant There is a memory leak in Your example ;) 

Naming You should consider renaming or removing Your function, all functions from Your library does have a prefix , and this one does not. Also, it's kind a misleading. For user of Your library it might look like something related to . What does , , mean? Please, consider using proper names for Your variables. Verbosity Just returning in case of error usually is not verbose enough. I'd suggest considering proper error codes and/or proper error logger, for example something like this: 

should be and in new classes you might want to use namespaces instead of underscores in your class names. See PSR-0 As non of your is optional and there are only 5 I would recommend the use real method parameters instead of this array. Otherwise some validation and documentation of this array is missing. Furthermore you could refactor your ifs to real guard conditions and skip the else branch. This makes the code more readable and you get rid of a indentation level. There are also no braces on one-line-ifs. Edit Sample for guard conditions 

Also, I would really comment parts like this. Doesn't exactly trivial to get, what's actually happening beneath. Generic On line #109 You have despite the fact You never use this value afterwards. Why wouldn't You use proper argument parser (i.e. usual ) instead of writing Your own cumbersome parser? You're not sanitizing any of Your inputs. I imagine this piece of code being used as a library. User of that library might pull his/her hairs off trying to debug his/her code and pin-point the location of some pointer being passed on. include is unused in Your code, as far as I see. Why would You cast pointer while the memory? 

field has standard $URL$ for it's numeric value. class property can make some troubles if future, when you'll need to make some manipulations with this list. But in this case it is acceptable solution. there is library called cities_light, it has states and some additional properties. Cons of using it - it require to download it's database (about 400MB) during migration. overuse of property. You should use boolean field and then adopt data presentation on form. Also, you probably wish to separate this huge model into few for performance improvements, but this require some profiling workaround. 

Instead of having a static array of You could just use ASCII values from to . If You still insist having a static array, please consider marking it as a . Leaving Your without any return value --- sign of the bad taste, to say the least. Consider having some proper error codes or at least on proper exit. Your index of chars (, ) can't be negative, so why would You use instead of or ? Same applies to and variables. In case of single char, is way faster then . 

Your code might not be OO but Service Oriented as you are injecting the database(-service) to your objects. 

Of course you can take advantage of all the arithmetic power of BigDecimal and define a specific rounding mode etc. EDIT: Just to prove that the float approach will fail (tested in Java 6): 

. Digging deeper it seems that either your Color or your Token is redundant. The Token is only wrapping one Color. If you test an Exception with try/catch (or better with rules etc.), I recommend to also assert the message of the expected exception. E.g. maybe your are extending your later, or will have a message for the lower and one for the upper bound, it is not enough to just check the exception class. Your mixing of arrays and lists is not that nice. It is totally valid to use both here. This is no high performance application so Lists are fine, but on the order hand the grid is pretty simple so I would prefer using only arrays here. As you don't have different heights per column, your abstraction seems to generic, maybe a two-dimensional array would meet your needs, too. As mentioned above, modeling the game flow with Exception seems wrong to me (but there are other opinions), but if you do so the should be a and needs to be part of the method contract. Check $URL$ for an idea of merging the column into the grid. 

Consistency Spacing and indentation is inconsistent. You should decide, how many spaces do You put between functions, how and when You separate , , arithmetical operations, etc blocks from each other or other logical parts of Your code. Or even better, use already defined C coding style, for example Linux kernel one. Input verification Rule of thumb, user of Your library is going to be dumb. And/or it will get messy debugging bigger project with Your library included. So, really, verify ALL the inputs. For example, Your segfaults. Generic practices Back to , in general it's quite common to provide iterator function which calls some callback with every single element of the structure as a parameter instead. It's way more versatile. It's common to suffix include guards by some randomly generated gibberish or hash, especially for such a common names as . Also, for compatibility with some compilers it usually defines it to some specific value. For example: 

But, as you saw before, you have to optimize frontend and backend in different way. How to solve it is up to you. 

About code style, I highly recommend you to read angular code style even if you have no idea what is it. It contains a lot of sanity approaches about how to make HUGE classes clear and smooth. About comments: they needed only if you have no idea what is going on, or it is hard to understand. Don't overuse them. UPD: I always met problems of bad design when I have no idea how should I do something. Fist stage - write you code, code that will do what I want. Second stage - refactoring. Take one piece of responsibility and move it into separate location until all code is rewritten. As I see, you already have such pieces, that can be placed in separate location, e.g. plugins like they are really tiny, but there are no need to write ugly comments, that make code unreadable. Move it into single file, and configure grunt-contrib-concat for glueing all pieces together. Then I'd start refactor . There are a lot of thing that you can do from covered code style above. Firstly make constructor for your plugin, and move there this code 

In general it is a good idea to replace ifs that covers the whole function by a guard condition. So you get rid of a level of nesting. 

Edit - Just a draft how I would structure your class if I wouldn't use PDO and create my own database abstraction: 

If there are now performance constraint I always prefere a readable solution over a compact one. So I would go with the following: (assuming is sorted and there are no gaps in the months) 

Based on this statement, I don't get, how you want to use your code. You definitely don't want to start programming in a string (see "evil eval"), nor is it getting less messy with the nested calls. What about a more -approach. Just wrap the stream and add your methods. With some formatting, your are getting pretty close to your layout. 

Note: it is not final or most optimized version ever, I have tried to show you set of approached you might want to know to optimize your code even further. Benchmark using browser Just open console in your browser and paste following code 

Nodejs and preallocation Lets start with this test where we conditionally switches allocation from static to dynamic. 

... where did they come from? Proposals IMHO: following blocks should not be part of view, it's can be some util that implements needed behaviour. 

Performance improvements related to approach Interger base For better performance we can split number not by every digit but by set of digits with given base. Look at Number.MAX_SAFE_INTEGER and some math \$ max\_number = 2 ^ {53} - 1 = 9007199254740991 \$ \$ digits = \lfloor \log_{10} max\_number \rfloor \$ \$ base = 10 ^ { digits } \$ Note: base will be lower by one if logarithm gives interger. What I want to say? \$ max\_number \$ can hold \$ digits \$ digits to be able to handle overflowing during additions. What meaning of \$ base \$ ? Currently you are using algo with \$ base = 10 ^ {digits} = 10 \$. Here you are performing modulo operation with base equals 10. Which means you are storing array with numbers that consists of single digit. But allows you to store up to 15 digits. Execute in you browser to find this value (do not forger to take floor of resulted decimal). Look at c++ example at e-maxx.ru for idea how to implement this. I have not found good enough english article, but you can use google translate. Benchmark base \$ 10^1 \$ vs base \$ 10^{15} \$