My first reaction is that your click handler is doing way too much work on its own. You should break up the code into smaller methods to make it easier to maintain. 

It is then up to MainPresenter (or more appropriately, other classes MainPresenter uses) to figure out how to handle threading. MainForm itself never has to know or care that you are using separate threads. 

I would first suggest logging the database operation to see what SQL is executed. EF may not be running the SQL you think it is. The red flag I see is that you call ToList before the Skip and Take. Generally in LINQ statements, ToList forces execution immediately. This suggests your EF code is pulling every record from the table up front, building a list, and then applying the Skip/Take to the list. If that's the case, the logged SQL should show a select statement without any filtering. I suspect what you really want to do is run the ToList after the Skip and Take. This should apply the filtering inside the executed SQL, but the logging will show you for sure. 

Additionally, is not a very descriptive name for your entities. It seems something like would better indicate what it is. Similarly, is a dictionary storing the types of time-off requests, and it is a field, so I would call it something like . Finally, the class name itself, reads more like the type contains a list of possible time types that fall outside a standard set of types. However, it's telling you the aggregate number of comp, bereavement, and jury duty hours requested for a particular user over the current year. I'm pretty bad at naming myself, though, so perhaps someone else can come up with some good alternatives. Design The first thing I see is that the dictionary only seems to exist as a way of identifying the int values the database uses. This would actually be much simpler as an value: 

Implement IEquatable<T> Generally speaking, whenever I find myself writing overrides for and , I also make the type implement . It's generally pretty easy to do so by calling the method from the override: 

If you call the method, it returns all directories and files in one call. The upside is that it reduces the calls to the filesystem, which are generally going to be your bottleneck. The downside is that you get a base type back, so some type handling may be necessary. 

Here's my new sequencer code using IEnumerators. It works as it should, but honestly I suspect this code is kind of bad! The basic idea was to store an enumerator that always references one of the sub-tasks. If a sub-task is succeeds, the enumerator moves to the next one and we tick it immediately. If a sub-task fails, the enumerator is moved to the beginning. And finally, if a sub-task returns we don't touch the enumerator and we just back out. Next time the composite is ticked, it will tick whichever subtask is referenced by the enumerator. Here's the altered Sequencer composite task that I rewrote using IEnumerators: 

Conclusion Anyway, that's about it. Both of these "sequencer" composite tasks work correctly now, but I'm not convinced that the code couldn't be a lot better in both examples. The first code is just a brute-force reference comparison of the saved task against the current sub-task, but it's relatively clean and simple. The second code is based on iterators/enumerators and feels like it's on the verge of being the right path, but it's also a bit messy and it probably shows my lack of experience in certain areas. I'm alright with that, as I'm here to learn and improve! After all, I don't have many opportunities for code review! My main questions are: 

All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

Dispose all the things While you have a using statement for your connection object, there are a few other objects which implement you missed. Both the command and reader objects need using statements. Naming The method doesn't set anything. It would be more appropriate to call it , since you are retrieving information. Your variable names could use some work as well - they are somewhat inconsistent. Some have prefixes, while others do not. Some are camelCase, while others are PascalCase (the convention is camelCase). I left these changes as an exercise for the reader :) Use well-defined data objects I also noticed that returns a which contains various user detail properties. It would be better to create a data structure to hold this and return it instead: 

Personally, I err on the side of the above, but I generally find it acceptable to omit the braces when the expression leaves the current block (e.g., , , , ): 

Then, I would move the logic for retrieving the data and aggregating it into a static method that returned the data object, along with some helper functions. First, you can extract a method for calculating the hours in a particular : 

(It was thrown together quick just for quick turn-around sake.) I then provided 3 ways of loading. One loads the data much like you did above: 

and an appropriate suffix so the overall query is valid SQL, it would return all users. Other injected strings could do worse like modify/drop tables. Instead, you want to use a parameterized query by replacing your format specifier with an @-prefixed variable. Then, you can add parameters to the collection: 

The benefit is that if you ever rename text, your refactor tools will update the second example, while commonly, they will miss the string in the first example. by default As a general rule, I seal classes unless it has been specifically designed for extension. I could go into explanations why, but smarter people than I already have. Final code: 

It was suggested that I move this to an answer instead of a comment: Since you're using .NET, why not just use ? It already performs validation in its constructor - it will throw a if the address is invalid. This is particularly useful if you intend on using the address to actually send email, since you'll likely be using for it anyways. This does not get you the regex, but I think a better solution is to avoid regex in this case for the reasons stated in the comments and other answers. 

Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: 

This worked fine, but it felt a bit messy and brute-force. So I thought about other possible ways to do it. Thinking back to some of the C++ code that I've written, using something like an iterator came to mind. After a little research I found that IEnumerator seems to be more-or-less the same idea in C#... Second Attempt: So, going back to the drawing board, I tried rewriting my code to make use of enumerators. Now, instead of storing a reference to a task, my composite now stores an reference. I've used foreach loops and IEnumerable objects many times before in C#, but this is the first time I've ever needed to deal with IEnumerators alone. Honestly, I went for a kind of 'lazy' approach to calling instead of doing so in the constructor because I figured that tasks might be added and removed dynamically at various points in time. I added some small convenience functions for controlling my IEnumerator to prevent cluttering my code in other places. Here are the changes to my CompositeTask abstract base class: