Changing the way your store the dialog A more maintainable approach would be to store the salient bits of your dialog tree (the questions and possible responses) in a traversable object. 

This allows you to use a defined question as a followup question for any number of responses. It even allows you to jump back and forth between bits of previously traversed dialog. Here's an example where I've converted three questions into reusable functions: 

To use that in your code, you'd need to change the string to an array and sort it, as in the code below. 

On thing to keep in mind is that certain inputs that you might not consider to be numbers will be considered numbers by the and functions. Potentially Unexpected Numbers: 

I'm working on a page that shows groups of users. The following JavaScript function is used to show more details about a user (such as email and login) when you click on their name. But there's a twist: clicking on one of those pieces of information will highlight it to make it easier to copy. This is accomplished by adding an in-line onclick function to each span element containing the user info. 

Since JavaScript variables are function-scoped, this essentially creates a new scope in which your code and functions can refer to variables defined within. Code outside the scope (such as elsewhere on the page) can then use the same variable and function names without running into any collisions. 

These aren't complete examples (I didn't want to rewrite your code), and I'm sure they could benefit from additional code reviews, but I hope it gives you an idea of how you might approach the problem from a different angle. 

In the CAML query that we pass to SharePoint, we can specify filter conditions to retrieve only the items we want, so that SharePoint can efficiently give us that one item we're interested in. We already performed that query; this code is even inside an block that verified that we found the item that matches the desired 

Efficient Looping in JavaScript Many browsers will see a performance improvement if you make a slight modification to your for loops. Take a look at your for loop in the function: That loop requires that the browser check the length of the array after every iteration. Since you know the array's length isn't changing, you can cache that length at the same time that you initialize your iteration variable. 

Note that you might also want to consider which lets you append any HTML element by its reference, such as the reference obtained when you create an element using . That approach is more versatile (you can retain references to the elements in code and attach event handlers to the elements programmatically) but will be slightly slower than . 

I'll also second James's suggestion to rename those arrays to and to reflect their plurality. Capture Element IDs and Min/Max Values in a Data Structure Currently, you have the min/max values and element IDs directly in the code wherever they're needed. You can make the code easier to maintain by moving those values to a separate, dedicated data structure. I recommend using an array of objects. Then you can loop through the array to perform the necessary operations, which makes adding more elements/images/links almost trivial. 

This is useful if there are multiple entry points for the function, such as if you were to invoke it from the window's event. 

It looks like your code is essentially converting military time in number format to 12-hour time. Suggestions 

If you know there'll only be one element with the class, you could improve its efficiency a step further by using the native method. 

That object can be used directly for most applications, with a big benefit being that you can now grab an array of datetimes directly by using the date string (which saves you from having to iterate through an array, checking property values with each iteration). If accessing datetime arrays directly by date is not sufficient, and you also need to loop through the dates, you can loop through the keys using the syntax like so: 

It's also worth noting that using bitwise OR assignment you end up with a number rather than a Boolean; it'll be 0 or 1 in this case, which JavaScript nicely interprets as false or true, respectively. With that said, you could accomplish something visually similar by just breaking up your comparison into its components with line breaks. In your example code, I see no reason to have two different IF statements leading to ; the conditions could be combined like so: 

If your main concern is making it more human-readable, one approach may be to use the bitwise OR assignment operator like so: 

Using the 'const' modern language feature If you don't need to support older versions of Internet Explorer, you can take advantage of the keyword (introduced in ECMAScript 2015) for any variable whose value never changes. This not only makes it easier for you to detect any inadvertent logic errors introduced by overwriting those variable values, but it allows the browser's JavaScript engine to optimize its handling of those variables since it knows they'll never change. Your and variables could be defined as constants at the beginning of your IIFE, as could your references to HTML elements. 

Avoiding polluting the global namespace As pointed out in a comment, you can wrap the code in an immediately executing function expression (IIFE) to avoid polluting the global namespace. Variables declared within the scope of a function expression can only be accessed from within the expression and from functions that are also defined within the expression. 

This saves you all the processing that would take place within the loop. You would also need to update your function to accommodate the new format for the parameter. 

Using Function Expressions Now with all that being said, sometimes having to define multiple functions just to insert logic farther down the execution chain actually hinders readability. A function that's only ever referenced once, and only because you need to pass it as a callback, isn't doing anything to keep your code DRY (Don't Repeat Yourself), and can make it more tedious to debug or map out the chain of execution events. For these reasons I'll often use inline function expressions instead of defined functions for callbacks. Inline function expressions can replace your globally defined callback functions, such as , and . I mentioned at the beginning of this answer that I dislike polluting the global namespace with variables. Using function expressions, I can refer to variables defined in the containing function without needing to attach them to the object. (Read about closures in JavaScript to understand how this works.) This is definitely a matter of personal preference, but I prefer the code reformatted into a single function with nested function expressions for the callbacks, like so: 

Caching references to DOM objects One simple way to optimize is to identify places where you're querying the DOM for a specific element multiple times, and replace those with variable references. 

Cleaning up the Arrays I second JamesBodgan's suggestion to store only the image attributes and link attributes in your arrays instead of storing string representations of the HTML. This will change the way you consume the values from the arrays. You might want to create a couple functions that create the actual HTML elements from the given attributes for you. 

This way your script is almost good to go if you decide to have another sale that spans a different number of days. You'd just need to update the array to reflect the elements on the page (and update the of course). 

Appending to To append to innerHTML without forcing the DOM to reload with every change, you can use . For example, instead of use : 

Some variable naming conventions use ALL_CAPS for constants, which I've shown in the code above, but internal consistency is more important than external convention. Eliminating unnecessary variables You are only using the variable once, for the one-time assignment of the event handler. You can therefore bypass storing it in a variable altogether and just directly assign the event handler to the reference returned by . Similarly, and are each used only once after being defined in the event handler; you can eliminate them altogether. ( can be replaced with or .) 

This simulator visualizes Conway's Game of Life and other lifelike cellular automata rule-sets. Features: 

is not supported by Internet Explorer. If you don't care about supporting such browsers, then don't worry about, but if you're coding for a public website it's worth noting that IE still represents about 4% of the global browser market share at the time of this response. Despite not being an array, the HtmlCollection object returned from will still have a length property, so consider instead using a normal loop or loop to access the set of elements. For example, instead of this... 

I find that the native equivalents to jQuery wrappers tend to be more explicitly and precisely named, making it easier for me to recognize mistakes and intentions and making my code more maintainable in the long run. 

EDIT: Efficiency Suggestion(s) Caching DOM Queries You can make the code in more efficient by getting all the necessary DOM operations out of the way beforehand. If you want to reduce the number of DOM queries (which are typically expensive operations) you can cache an array of references to all the relevant elements and then reference that array in the function. I know you're hoping for the "shortest and most efficient way", but this would be for efficiency at the expense of brevity, since you'd need to set up an extra variable to track the index of the active image. Using this index would save your code from having to read the current classLists of the images, requery the container element to get the active image, and traverse the DOM for the next sibling or first child.