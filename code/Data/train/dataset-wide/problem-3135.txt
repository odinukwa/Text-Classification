You can, of course, keep the type to (you have to change back to ). Now to . Let's use proper types first: 

Whoops. The doesn't get checked, and you don't get a warning (in older compiler versions; new ones do warn about possible whitespace issues). If you declare your variables later (e.g. C99-style), errors like that cannot happen (although it introduces possible shadowing): 

The important part about however is, that there is no function(*). That's what keeps pure and impure code apart. Either way, as I already said, your code is fine (except for missing type signatures). Note that you've only used "guards", though, not pattern guards, since you do not actually use a pattern in your code, just boolean expressions. (*): well, there is one, but you should only ever use it if you know completely what you're doing 

We lifted the part out of the function. Also, instead of a list, we return a pair. We really want two and only two values as a result. Not arbitrary many, which is modelled with a list. The implementation doesn't differ too much from yours, apart from the pair and some removed magic numbers: 

Alternative variants Truth be told, that looks somewhat silly. We can just use instead of , or even : 

With , I'm somewhat sure that your logic isn't 100% correct. According to the documentation, you check with increasing counters, but will take the last element for which holds. Since , you will end up with the last element for which does not hold. Either way, if you look for the first element that holds a predicate, you can use from instead: 

but that's just a remark (Exercise: try to guess 's type. How would a valid implementation look like?). Next, we head over to . Let us assume for a second that the key is longer than the text we want to encrypt. We want to encrypt each character on its own. So if we have a string, we can pattern match. We start with the easier case: 

Your first loop uses an optimization, your second doesn't. That's asymmetrical. Use the same trick for both loops. 

While the list for prime factors might come in handy for other challenges, you're just interested in the largest, so it's fine to return just a single value: 

Note that this prevents some errors that were possible before. For example you could have missed to set and accidentally returned instead of , e.g. 

That's a lot easier to read, isn't it? Use a \$\mathcal O(1) \$ data structure with low constants for jumps We can decrease the time tremendously if we use a instead of a . We sacrifice a little bit of memory, but that's almost not noticeable. s are implemented as B-trees. Trees always have some level of indirection: you have to traverse a tree structure and compare keys or values. But and differ on a fundamental level: has do do additional comparisons to find the correct value in a local array, whereas only needs to find the correct . The additional cost in isn't noticeable if we traverse the whole tree, but it gets annoying if we look for single elements over and over, especially in a small data set. So let's use a instead and employ all other suggestions while we're at it: 

Exercise: Try to rewrite with or even (the latter only needs an additional constraint). Bottom line Other than that your mutable code looks fine. I would change slightly so that there is only one temporary element, though: 

By the way, whatismyip.org seems to be up for sale, so you might not get your IP in another few months, or the format might change. ipecho.net has a strange whois entry too, but at least its mentioned in a highly voted answer and returns your IP without the need to extract it from the HTML. 

This will probably be the last one in the Zombie series. Motivation Zombies! The dread of any barbecue. The grilled brains are sticky, their odour is icky, and they never stop talking about crossdead. But that is not the kind of Zombie we suffer from. We are looking for easy-to revive question Zombies. Questions, that have at least one 0-score answer but count as /unanswered. A revival just needs a single click in those cases: an upvote. We only need to find those Schroedinger questions and cure them. The first cure accidentally included closed questions, as did the second. This query remedies this fault and only looks for the Zombies that haven't been thrown into jail. It also includes an activity index (see below). The goal The previous questions have shown that the requirements on the query were not really communicated well. This time I'll try to list all requirements for the query: 

Your code uses names from your imports. is a function defined in , so it makes your instance slightly hard to read. You use only once, so it makes sense to inline it. 

I've renamed and also let it ask the number, so that again everything that is concerned with getting input from the user resides in a single function. All in all, well done. Don't be afraid to split your functions, make sure to enable compiler warnings, and use (it suggested from , by the way). Exercises 

This would fix the problem shown above in the example. You have to decrease the variable of course if you use , and you need to add it to your member variables. But both of them are left as an exercise. Naming Your naming was fine, however, if you prefix or postfix your member variables, you can drop . That way, you can also simply call for example. But that's personal preference. The only real naming-nitpick I had was instead of in the destructor. We know that it's a pointer due to its type, it's much more interesting what it points to. Other You should add a copy constructor, copy assignment operator, move constructor and move assignment operator or forbid those operations explicitly with . 

Note that I've used the properties of again, just as in Caesar. Everything is the same. Except for the modification. In , we subtract the key, and in we add it. So let us move that into another function: 

You could add a proper error message, but that's left as an exercise. Note that if we have an at that point, we know that it's also a valid one. That's a big win compared to the previous situation where we had to check whether the was valid in every function. 

But that's error prone. First of all, Bob might not know how long the binary number is. Try to check whether is 14 or 15 characters long. That's a trick question, those are 16 characters. So instead, just let Bob write anything and then check how long it is and whether it was really a binary number. Prefer to Instead of , we will use a . This makes the input a lot easier. However, to handle the input easier, let's write a function. Actually, let's write two: 

I think the last lines in both functions showed why I moved to be the last argument. You're off course free to change back to your pattern matching variant. Time for some exercises Now that we have something that's easier to read, it would be time to refactor. So here are some exercises: 

Type signatures Good job on providing all type signatures. Unfortunately, you forgot one: . Always include type signatures on top-level functions. Remove unused imports You use neither , nor . Prefer character comparison instead of In , you compare characters by their values. That's not easy on the eye. It's a lot easier to read if you just compare the letter with characters: 

Other than that we could argue about formatting, but your code is fine. It works. Note that you should add more test cases though. A generator might come in handy for QuickCheck, but that's left as an exercise. 

Ah, but we don't like to suspect. Just as our compiler tells us that we're missing a semicolon, our profiler will tell us where we lose time. Let's add a first: 

This one is guaranteed to sleep at least seconds, although it may sleep longer. Either way, a busy-loop is just wasting resources. 

Better names The variable names are too short to be meaningful. It's common to use as an index in -loops, but doesn't really tell us its purpose. Names like are self-descriptive, so we should use those. Unused variables We never use in , therefore we should remove the parameter altogether. Strictly speaking, we also never use . If is '\0'indx[i]11` otherwise, so we can replace 

Note that this solution only needs C features. However, it uses the non-standard function , which might not be available on the target system. Luckily, C++11 and C11 provide their own ways to sleep, e.g. 

This will be a list of "don't"s, since your code is very readable, but contains some code smells. It doesn't actually solve the puzzle, but more on that later. is not a hashtable I just want to get something out of the way first: isn't a hash table. A hash table needs a function \$\text{hash}: A \to I\$, where \$I\$ is some finite, bounded and integral set with \$|A|\gg|I|\$. An efficient hash map/table uses buckets and provides a best case \$\mathcal O(1)\$ access if implemented correctly. only provides \$\mathcal O(\log k)\$ access, since it's implemented as a tree. That's why you need the constraint on almost all functions in . However, it's still a nice data structure for this problem. Python's dictionaries on the other hand are based on hashable functions. Don't give names to things you won't use 

Don't repeat yourself You print the sorted number twice. And maybe you want to print the digits at some point, too. Create a function for that: 

I'm not kidding. That's the whole logic behind your , written in a double-ended queue. Note that this is still not optimal, since you will usually only change a single element. I guess that a with an additional index will be more cache friendly, but that's up to benchmarking. Either way, now that you have a container, you can use all algorithms, iterators and other nice things. Be aware of global state I get it. It's just Snake. So there's no harm in using global variables, right? Wrong. Here's a little experiment: let's say you want to save and load all necessary variables for your game, so that a player can save it to disk, and continue later. Can you identify all those variables without scrolling in your code? Is it likely that you forget one of those variables? Remember, make your functions easy to use, but hard to use wrong. For your game, I recommend you to create a small class that handles all this data for you: 

However, there is still one thing amiss. has to handle every , although that shouldn't be necessary. There are only four actions: add, show, remove and quit. The latest does not actually act on a todo list, so let us focus on the first three. We should model them into a type: 

In we traverse the list too often. Since lists are just forward linked lists in Haskell, we have to walk through the list four times, once for , once for , once for and once for . That's a handful. So instead let's do that only once: 

That's mouthful and hard to maintain. Since this isn't the performance critical part, let's change it: 

Don't use for compile-time constants You define , but you never undefine it. It's a common word in code, so it's possible that you accidentally break something. Furthermore, it's not in the same namespace as and , as the preprocessor does not care about s. Instead, use a : 

Header guards Your code contains undefined behaviour since the underscores are reserved for the implementation: 

That's why I changed 's type, to ensure that the conversion has to be explicit by the user before they apply . Overall, good ideas and implementation, but try to keep the parts in your own code to a minimum. By the way, if you're interested in predicative types, have a look at Liquid Haskell. 

I've also added some whitespace. Keep in mind: you write code both for the machine and the human who's going to read that code later. That human might be you or your supervisor. Make sure that it's easy to read. 

Overall, still well done. Naming and (time) complexity Let's start by looking at the types. Well, you have type signatures at every top-level binding, which is a great start. I think that the name is slightly misleading, since you call the variable for . But naming is hard, so let's focus on other parts. 

can be expressed with and vice-versa. If you use both and , use to get both at the same time. You can pattern match on two elements in a list with . That way you only need a single . is . can be written with , but that might be a little bit too advanced. 

Depending on whether you write ANSI-C or C99, I would defer declaration of variables as long as possible. For example, at the moment it's easy to accidentally change to some bogus value, or forget a and accidentally check the after the loops or similar: 

Good code is written for humans and machines, but the latter are second class citizens. So let's try to get rid of some noise: 

*ahem* is an overkill for this program. It needs the package. Also, if a number is divisible by \$k\$ of your \$K\$ divisors, your algorithm is \$\mathcal O(K + k \log K)\$ (*), so worst case (\$K = k \$) you will have \$\mathcal O(K \log K) \$. This is due to the definition of . Compare your with the following variant: 

Unfortunately, also contains , so you'll be able to multiply time values, which doesn't really make sense in this case. Alas, there is no other way to get otherwise. However, let's have a look at the wrapper, and . The type of is a little bit too general. It allows you to do stuff like this: 

We're missing the four consecutive digits. This is now tricky, since it's not clear whether the hyphens are part of the run. If they are only invalid four 4 character groups, we can simply check whether the current character is the complete group: 

Further remarks Search some of the modules whether they provide the functions you're looking for. And have a look at . You've used after , which is provided as a single function (see above). For completion, here's how I would (probably) solve the challenge: