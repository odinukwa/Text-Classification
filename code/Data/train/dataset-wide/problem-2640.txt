If you don't mind me asking, any reason you want to register the DbContext directly? I know .NET Core seems to want you to do that, but I don't like IoC containers deciding when to leave open or close my DB connections. Insetead, I'd just do IFooDbContextFactory and have that use a "CreateAsync" method. This factory can take your IAppSettings or IDbContextSettings or something to get the connection string. Then you can call the provider async just fine and in your specific code you'd just do: 

Validation uses ?. here so that the second part isn't run if there is no rule. .NET Core changed the way translations work, so I had to IoC inject a reference to them now, which is why you see that. CreateCommandRepository 

Since we can route the different verbs to different classes, we can focus on only 1 method at a time per class. I'm using Mediators everywhere so the code looks the same across all classes. I thought this was really the Service Locator anti-pattern, but it isn't because you still know the mediator dependency. I also use async through the entire call stack because Task.CompletedTask, if needed, has very little overhead and not blocking threads is the way to go. ResponseMediator 

After months of going back and forth, I broke down and ended up returning IResult or IResult< T > from all commands/queries. The IResult looks like this: 

Validation The validation decorator will run validation on multiple threads (if you want) and async will not block. I didn't use expressions since a lot of times validation involves multiple properties and has a lot of overhead. The BrokenRule() parameter is the "Relation" and it can be used to tie the rule somewhere on the UI. 

You are letting components be built up by other components. This is completely SOLID and is a good approach. What I would like to warn about is returning . This is fine as long as the query handler is used by other query handlers (since this enables composible queries with good performance), don't return an to the presentation layer. This makes the system unreliable and hard to test. This means that you will have to implement sorting and paging inside your business layer, but this is actually quite easy. Note that your components should not dispose any dependencies that are injected into him. The reason is that such component doesn't own the dependency and has no idea what the lifetime of the dependency is. Disposing that dependency can make the application break, and this is something you already noted in the comments. As a matter of fact, you are violating SOLID by injecting a dependency that implements ; you are violating the Dependency Inversion Principle. This principle states that "abstractions should not depend on details", but is an implementation detail. If you prevent having on the abstraction, but instead place it on the implementation, you'll see that it becomes impossible for the consumer to call (which is good, because it has no idea whether or not it should call it), and now only the one who created that dependency can dispose that dependency (which is your composition root). This makes your application code much simpler, because you will hardly ever need to implement at all. In your case however, you can't remove from the , because you inherit from . But injecting a is itself a DIP violation. Although not all DIP violations are bad (and you will always have DIP violations somewhere in your application), I rather hide the from my code, for instance by using an abstraction with a single method. Advantage of this is that the can be resolved at runtime, instead of injected into consumers, and it allows to easily wrap the with some sort of security decorator that filters the results based on the user's rights. Do note that the part of the system that created a disposable component typically holds the ownership, and is therefore responsible of disposing that. Although this ownership can be transferred, you should typically not do this, because this complicates your application (I think you already noticed this). So you composition root creates this dependency and should dispose it. In case you use a DI library, the library will create that insance for you. In that case, the library is also responsible of disposing it for you. Although you can view this as 'something magical', IMO it's simply a basic feature of the library you are using. You should understand the libraries you are use. In the case of Autofac, you can be pretty sure that Autofac handles this correctly for you. In case you would switch back to Pure DI (formally known as poor man's DI), your code will obviously again be in control over that dependency, and you will have to implement this disposal again manually. There's no design smell here. But that said, although disposing is not the problem, scoping might actually be. Please read this answer of mine. Although the query handler pattern might seem over-engineered at first, if you read the article closely, you'll see that it is simply an implementation of the SOLID principles. IMO, you should always strive to adhere to the SOLID principles in the core parts of your application. Querying is obviously a core part of every application. My experience is that query handlers even work well on small projects. They allow adding cross-cutting concerns with such easy, that it can really boost the productivity and flexibility in smaller applications. Using instead of injecting s directly has some downsides, such as the fact that handlers get resolved lazily at runtime. This makes it harder to verify the complete object graph and it makes it hard to see what queries a component executes. On the other hand, it makes your code cleaner, because the generic types and often long names for query classes can give some noise in your code (that's more a limitation in C# than a limitation of the pattern). In that case the can help. Since your implementation will be part of your composition root, it is completely fine to have a dependency on the container, since the rest of your composition will have a dependency on the container as well (although it would be good to call it ). It is incorrect to assume that this is a implementation the Service Locator anti-pattern. This is clearly explained by Mark Seemann here. In case you are swapping your DI library, you will have to change your complete composition root, including the implementation (because it is part of the composition root). There's nothing wrong with that. It is no problem that your container is stored inside your graph. Although you could try making the process generic by injecting a Func, that would still mean that the injected Func would depend on the container, making the container still part of the object graph. This is actually what dependency inversion is all about. Components can use other components and code at runtime that they don't have a compile time dependency on. 

This way, I don't have to handle any exceptions to change the flow of the code except when a truly exceptional thing happens. It is caught like this in the top level exception decorator handler: 

Edit The last point here is that Exceptions actually are pretty slow. When I throw an exception, it ends up taking around 150 ms to get the result back. When I switched to not throwing an exception, it would get around 25ms response for the exact same check/data. That is 6 times slower! Thus, avoiding exceptions seems like a really good thing to do! :) 

That way, the rest of those scenarios are being handled by the other decorators so returning an IResult doesn't become cumbersome. At the UI level, I created a ResponseMediator instead that returned IActionResult items. This will handle the IResult and return the appropriate data/status code. i.e. (ICqsMediator is what IMediator used to be) 

I find if you do this in chunks together (all these classes, minus the controller) are all in the same folder as they are all related, that coding the mapping by hand isn't that big of a deal. Though, I made this generic so you could setup your own that just used AutoMapper or whatever instead. Invalidate Cache 

If you know the queries you affect, you just have to give it the query type and it'll take care of the rest. I made it async in case it took some IO to figure out all the types. Decorators The most important decorator I wanted to show was the exception handling one that is at the top of the chain: