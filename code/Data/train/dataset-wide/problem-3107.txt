Also note that you can have more than one class defined in a file. Thus personally I would have put the and patterns in the same file (they are tightly coupled anyway). 

Making the size smaller is easier. You don't need to re-allocate. You can just reduce the size value and manually call the destructor on all the objects that don't exist anymore. Same but slightly different in reserve() 

Again you are providing to access the member and retrieve values that you then use to perform an action. Geter methods break encapsulation and expose the internal types of the object. You should never use them like this. What you should do is ask the class to serialize itself to the stream. There is even a standard idiom for this in C++ and it is called the output operator. 

Use a Sentinel Value. If you add a fake value to the list. So the list always has one node (the sentinel can not be deleted). Then you make the list circular so the head points to the tail and the tail points back at the tail. Then you can get rid of all the checks. This makes the code much simpler to read and write. Pass by reference. You pass your parameters by value. When they data type is an integer this is not a problem. But sice this is a templated class the data type can be anything. As a result when you pass by value you generate a copy of the object. So pass the parameter by const reference to avoid the copy. 

This tightly couples the print method to a particular output method. It would be better to allow the user of your object to define what the output method is: 

Type 1: FAIL Type 2: OK Of course with good coding standards that can be avoided (always use '{' '}' on if). But every now and then people can be lazy (or just careless) and the second version prevents accidents from happening. The best solution is not to use macros. Use functions and let the compiler work out when to inline. Edited: For billy: (Type 3) no do while 

Problems I see: My problem with your code is that you are newing a lot of stuff that should just be objects. 

Since C++11 we have had move semantics. This (move) is never more expensive than a copy and usually much more efficient than a copy. None of your intermediate arrays are re-used. So there is no need to preserve the data in these intermediate containers. So you should be using move semantics when moving the objects internally. Use standard algorithms were they are available. 

These are basically global variables and anybody can access an mutate them (not just maliciously but accidently). C++ has the ability to encapsulate all the parts of a class and protect it from accidental misuse by only allowing certain functions (methods) to access the raw underlying data. 

I main issue with this code is that it is not C++ (it's more C like). But you asked for a C++ review. So here it is. ========== Overall Design: You don't encapsulate you list. 

Encapsulation: My first question is why are you exposing ? Would the class that implemented a tree not be represented by class? The is an internal data structure that is completely private to the tree. Interface My second question is what are you trying to achieve with the tree. What you are trying to achieve defines your public interface to the tree. Currently your public interface to the tree is the which allows a user to directly manipulate the tree. This is not a good interface. User of your tree don't want to maintain a tree (that is why they are using your class so your class can maintain the tree and they don't need to worry about it). So what is your tree going to be used for, once you answer that you can define the user interface to the tree. Implementation Why are you using . Is there really going to be shared ownership of nodes? A tree has a very well defined structure and there is no sharing of nodes each node has children (that are not shared but are owned) and a parent (which is shared but not owned). So there is no need for shared pointers in the tree. Are you exposing the to the user of the class? That breaks encapsulation (exposing internal details of the tree). So that's not a good idea. Also your need to use is a result of sharing the structure externally (exposing implementation details). If you don't allow accesses to the internal structure you don't need to track if a node has references after it is deleted. So at worst these pointers should be ; but personally I would make them all simple pointers (as long as you wrap up the interface and hide the from external users). Code Review Copy Issues (Move?) Currently your tree is not copyable or movable. Copy I think is an issue. 

Also I would say that pivot is really the value you are pivoting around. Not the location of the value you are pivoting around. 

Before I do a C review I just want to do a literal translation of your python so you can compare it. Personally I think you can make your C look identical to your python (a small amount of extra work required for memory management and the array like container but otherwise the same). 

Use the copy and swap idiom to provide strong exception guarantee. This will also solve the problems in the last two points. Provide Move Semantics. This interface provides the standard copy semantics. 

Since C++11 (and it is now 2016 (so that is 5 years ago) and we are on the verge of releasing C++17) the ifstream can also take a string for the file name. So we can update the function again. 

Just use . Use of is discouraged as it means you are trying to force the compiler to resolve a particular variable that is shadowed which means you are using a bad naming scheme that is suitable to shadowing. Shadowing causes all sorts of problems. One way to get around it is to force the use of on all members (which is fine until you accidentally miss one). The better option is turn up your compiler warnings so it warns you about shadowing. Then treat all warnings as errors (your code should compile warning free on the highest warning level). 

The parameter is not mutated by the function nor should it be. I would expect it to be passed as a const reference as part of the documentation of the function that you are not going to mutate it. This also helps in future maintenance as it stops people from accidentally mutating the object in a way that later code would not expect. My final thing is I did not see any encapsulation of the concept of a car. You treated it all as lines of text. If you had invented a car object you can define how cars are read from a stream and written to a stream etc. Thus you encapsulate the concept in a single location. I would have done something like this: Probably still overkill. 

Now a piece on a board can fill in the cBoard without the user of the piece actually knowing what the piece is: 

Not sure I like all those lined up like that it makes it hard to read. I have tried to make it more readable (at the end). Weather it works is a matter of opinion so I would not say mine is any better just an alternative. You also need to watch open()/close() on a file. You should always call close() even if the other functions fail. Otherwise there is potential for you to run out of file descriptors (though unlikely). In short it is a resorce leak and that can be a problem. 

I would not do that. It is a very inflexible format thus hard to update in the future. Also it makes debugging hard as it is not always human readable. Pick a format that is easy to parse both by humans and computers and is extensible. JSON springs to mind. 

Move Semantics You don't take advantage of move semantics. To put something in the list you still need to copy it into the node. Sometimes this has to happen. But sometimes you can move an object into a list and save the cost of a copy. 

This makes it hard to do comparison move forward backwards etc. I personally just store the number of seconds since midnight. 

More barely readable code. A nice alignment would be good. There are also other constructs that will help: 

Constructor You don't obey the rule of three. Bsically if you define one of Destructor/Copy Constructor/Copy Assignment you should probably define all three. In your case you don't define Copy Constructor. As a result you will get a double delete if you every copy your string. 

You implemented a "ForwardIterator" this means you need to fulfill the requirements of "Iterator"/"Input Iterator"/"Forward Iterator". The things you missed Iterator $URL$ One of the requirements of an iterator is that it is . You don't seem to have done this part: Input Iterator $URL$ 

But you forgot the rule of 3(or 5). So you need to define (or undefine) the copy constructor and assignment operator. 

You are not saving anything be doing this. But you are making it harder to read fot the next person. Anyway when you get a job (sorry I assume you are in college (forgive me if I am wrong)) no company coding standard will let you get away with it. So best not to get in the habit to start with. Your detection of bad input is spread over two print statements. Do all the tests that make the input bad in one place then use one print statements. Whose normal content is a description of usage. If you want to be fancy describe what they did wrong. But most people just do it wrong in the first place to see the useage comment. 

Everything @Jerry said. In addition I echo the view of @Bizket but disagree with the better solution. C++ emphasize the use of concepts (the exact type does not matter, the interface of the type is what matters when designing). You loop over an C-array and Bizkit says you should update to specific C++ container types. I would suggest that you update to use generic C++ container types (as long as your input acts like a container) that support the interface you need (then let the compiler verify its correct). Also C++ tends to use to define ranges (or containers). This allows you to be more flexible issue. Also why are you constraining your algorithm to ? Just make it generic then you don't need to write it again for other types. 

There are other functions that query the file system to get the size. But You should note this does NOT do a scan of the file it just moves the descriptor to the end. So its not like reading the file. You could just wrap it. 

By the point you execute: it has already decided what needs to be re-built (if you change the dependencies from last time this will not be picked up until your next run now). Looks relatively good. Here is a link to my generic makefile: $URL$ One thing I hate about C++ compilation is seeing all the command line arguments. So my Makefile hides all that and you just see the basics info: 

Here you are using for two different tasks. You are using it to count the number of currently open handles and to decide if curl has been initialized. This is going to result in multiple calls to and . Not what you wanted! I would put global init/cleanup into its own class. Example: 

I see no testing of or for so they can't be so there is no need to pass them as pointers. So you should be passing them as references. Since neither value is modified by the function you should also probably be passing them as const to prevent accidental modification of the original value. 

Why not make the first parameter a stream. That way if it is already in a file you pass a file stream. If it is already a string you pass a stringstream. You are not checking for errors. So we can assume that each line has been validated and is known to be correctly formed. So rather than reading a line at a time. Just parse the values you want. 

prefer to return by reference. If you want to keep the object immutable return by const reference. Depending on usage it may be worth having two version a const and a non const version. 

Since your four functions are identical apart from one method call you could write a generic version and pass that method as a parameter: 

You should strive for the strong exception guarantee (also known as transaction exception guarantee). 

I would rather see the consumer grab a single item from the queue then release the queue (so the producer can continue to add work while the consumer is processing a single job. 

I am not convinced your benchmarks are representative of what you are code would do. That looks like an awfully simple test. Also the order you do things can be important in benchmarking so putting both tests into the same executable is not a good idea. Build separate executables for each benchmark then run the tests independently. This way you know that both systems start off with a clean environment to test in. Rather than use the allocator object directly why not overload the new/delete operators for the classes you want. Then you can turn your allocator on/off as appropriate without searching the code and modifying etc. Code Review