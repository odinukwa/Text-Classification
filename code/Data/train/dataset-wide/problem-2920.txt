Disclaimer : I have very limited skill/knowledge for anything related to np. Also, I haven't run your code to identify bottleneck which should be the very first thing to do before trying to perform optimisations. Common ways to make things faster are : 

Naming On top of the snake-case point mentioned above, a few things could be improved in the naming. Naming is a difficult part of programming so what I suggest are just personal, far from perfect, suggestions (from a non-native English speaker). In your case, I'd call the function so that it conveys the fact that: 

is usually an antipattern in Python. This usually corresponds to something that can be written with straight-forward iteration. In your case, I guess (but I haven't tested), you could just do : . 

Types It's a bit weird to compare the content of the maze to every time. It would probably be easier to define the type of the content as a boolean. As a drawback, it does make the definition of mazes more tedious. The method you've defined that takes and as parameters should/could take coordinates. At the end, here's what my code is like : 

Not a proper methodology nor a code-review but I'll try to explain what I've done. First, I've put your code in a function returning the tuple. Then, I wrote a tiny bit of code to find the different values taken by the different colors : 

At the end, my script is like this (I've changed other details but it's mostly personal preferences) : 

Well, I gave you a solution assuming you had a solution. How do you get such a thing working ? You just need to iterate over the string and for each string position, you keep track of the number of combinations that can be generated using characters up to that point : 

Then, if you want to make things more concise, you could use the builtin and use the fact that True is 1 and False is 0 to write something like: 

After introduction of 0 in the first slice expression and a bit of mathematics, in the condition check and in the second slice expression, the code is now : 

Setting check You retrieve 3 different settings and check if there are not false. I am not sure if this is intended but for , you perform a conversion to int before the check. I'd probably perform the conversion after the check (also, sleeping for 0 seconds seems to be valid). Consistent return value In , is initially a list. Then, there is: 

Duplicated code In order to remove duplicated code, the key is to identify the parts that are identical/different from one place to another. In your case, you could add a filter parameter to your function (which would then deserve to be named differently). You could write something like : 

(This code could be written in a more concise way but this version corresponds to the fact that I've progressed by handling one color at a time). This seems to be working for all tested values as per the assert added to the loop I originally wrote : 

Docstring The purpose and arguments for your functions should be documented using docstring. Local declaration You have habits of languages requiring variable declarations but there is not such thing in Python (even in languages requiring it, I consider it is better to declare variables as late as possible, in the smallest possible scope). Style Python has a style guide called PEP 8. You have various points that need to be changed to be compliant, mostly related to spacing. On the other hand, your are properly following the naming convention. First draft Once the comments above taken into account, the code looks like : 

Your is a nice touch but I am not quite convinced that this is necessary : if you are to play with the length manually, you might as well compute the power from the index manually. Also, if you were to handle the negative with a minus instead of the plus, you'd be able to get rid of the brackets. On the other hand, you cannot use anymore which is a bit of a pain because it is a cool and efficient function. Anyway, here's my try : 

Please note that this solution does not seem to handle very well lists with repeated elements. You can easily enhance your test suite to show it : 

appears to be 21 times faster than the solution provided in my other answer and 141 times faster than yours. 

Add tests For this type of exercice, it is easy to write simple tests so that you can have a quick feedback when you break something as you write/rewrite your function. If you do this as part of an interview, it'll show you have good habits. You could use a proper test framework or just write simple code: 

This seems confusing to me. Now, instead of always being a list, either empty or not, it is now either a non-empty list or None. It make the function harder to use properly while making it more complicated. This could simply be: 

amon's comment about the names of your variable and the way you format your code is quite interesting. If you want more details, PEP 8 is a style guide for Python code. It is definitely worth a read if you want to write code considered pythonic. You can find automated tools to check that your code respects the guideline such as pep8online. 

Main You've written the code actually using your class behind the test which is very good. A few minor details can be improved though: 

I think the right way to do would be to have a map associating keywords to their color and them to go through your text, split it in tokens and for each token, apply the color if relevant. This wouldn't be as good as a real syntax hilighter but it would probably work as good as your current code with better performances. 

It is now time to have a look at , a much bigger chunk. First thing I'd like to point out, you do no follow this part of PEP 8 : 

Your code looks great and I can see that you have put some thought and time into it. Also, you've used pretty fancy concepts that I didn't know (which is not so hard as my Java is pretty rusty). However, it looks slightly over-engineered to me so I'll try to make things more simple. 

There might be a short/more pythonic way to do so but it works... Edit : I must confess that Jaime's comment to this answer surprised me but I've just tested this code : 

Disclaimer : most of my comments might be irrelevant as far as performance is concerned but should make your code better on different other aspects (readability for instance). Listen to your compiler Compiling your code with gives me the following warning : . I guess you know the first thing you can do :-). Making things easier to follow Splitting your code in small chunks is usually a good idea. Unfortunately, I am not quite convinced by because what it does is quite complicated and it makes it hard to give it a simple name, to test it out of the algorithm or to reuse it later on. Thus, from my point of view, it's easier to just remove this function. A good habit : defining things in the smallest possible scope It is quite common to try to define variables as late as possible and in the smallest possible scope. It prevents whoever reads the code to try to keep in mind the value of irrelevant things and to find what is used for what and it allows one to find easily when a variable becomes unused. It makes even better if you use as you can them define indices in for-loops. Also, you can take this chance to define things that go together (such as and ) together. Consistency You should try to be consistent in how you write your code. You should define a way to put space in your code and try to stick to it as much as possible. Consistency is relevant also for braces (you did good), line breaks, incrementations (you used and ). 

This would make your code more modular, easier to test and would put different independent things (device creation and file handling) in different places. I'd also like to point out that at the moment, your constructor does create a non-properly-initialised device when the file does not exist. It would probably be much better not to create it at all (and return ?) if we don't have the required information to do so. Also, and this is not relevant to your question but there's not real need for 2 variables and if you are always going to call them together. It might be just as easy to have "XML_PATH". 

A quick look at your code tells me is probably somewhere around O(n^2) which grows "very" fast. I have designed an algorithm which seems to be faster on the various inputs I have tried but I might have forgotten edge-cases. In any case, the principle is the following : 

it seems like you are using the wrong data structure. You want to iterate over domains only and only once and then process the corresponding urls. It would be better to define a dictionnary mapping domains to list of urls once so that you don't have to call many times in many places. You have different ways to do this, the best involves : 

Handle the prev, not the next This is mostly a matter of personal preference but you could make you do not need to handle indices by working with the previous character instead of the next. You'd get something like: 

You don't need a class In your current version of the code, it is hard to see what is stored in an instance and how the data flows around the different methods. If you do write a class, I find it clearer to have an init to define the different members but in your case, you could stop writing classes. Removing the class, you get something like : 

A bit of Python cool syntax Among the cool things in Python are generator expressions. Using generator expressions and , you can write in a concise and fancy way : 

Small function It may be a good idea to write a wrapper around so that you do not need to rewrite so many times. It may also be nice to have it add the and automatically. You'd get something like: 

Avoiding the additional array A different way to write this without an additional array is to see that the different indices of odd values are substracted, then added, then substracted, etc. Also, you have to perform as many additions as substractions. We could use a simple flag to handle both the alternance of sign and the check that we've performed the same number of additions and substractions. For instance (highly not tested): 

Also, your dict initialisation could be done with a dictionnary comprehension. Then, your whole function would become: 

I do prefer the solution with the boolean. Also, a third possible variant would be to fill every other from left to right and remaining rows from right to left In any case, they way you are supposed to handle arrays where size is not A*B might help you to pick the best solution for you. 

Also, the name of is not so great as it doesn't tell us much. Correctness When you write two functions to perform the same thing, it can be a good idea to check that you get the same result on a big set of inputs. Here's what I wrote : 

On top of @Quentin's comments, please try to avoid repeting yourself too much and declaring useless variables as it tends to make things harder to read. 

An optimisation for values under 10^6 (or if you want to ignore the conjecture) Primality tests can be expensive, especially for big values. At the moment, you often perform the same primality check on the same value multiple times. For instance, with the same "base number" 199933, you'll: