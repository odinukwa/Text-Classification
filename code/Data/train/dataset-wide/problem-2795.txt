The returned from the setter method can be used to set your 'factory class' internally first, which will be returned by . The other suggestion I can give is to use an instead, as it is a more efficient implementation for s over . 

Usually, that's code for using to purposefully let parts of your code fail (e.g. when determining an array index), and then remediate that in the . Makes for a 'fun' academic exercise such as this, just bear in mind this should strictly be only for fun, and not for writing clean, quality code. :) Commenting and hard-coding 

I suppose you have this line/chunk of code because you're still on Java 6, since Java 7 can do on literals. Therefore, at the very least, you can consider putting this inside a method e.g. so that the refactoring can be easily done in the future, when you migrate to newer Java versions. In fact, you should go further by having a separate class that can 'map' a into your object, and the logic to convert e.g. into a of will belong there too. Don't store password in plain-text :p Can't help but notice this in your method: . I hope this is only for an academic exercise, not something to be implemented in a public-facing Fortune-500 company's web portal. :p User types in another table? (database design) (suggested by @Vogel612) This is not about your code, but the database design. Perhaps the reason you are storing user types as a column in the table is because it works well for your existing use cases. Still, you may want to re-evaluate your database design to see if it can/should be in its own table, so that you can use foreign-key relationships in your favorite Relational Database Management System to represent their associations with users as such. 

Here, we are mapping the values into s, and the number of occurrences. Following the same idea, you can call , i.e. to stream on 's entries, to: 

It's only being used when is not empty. In addition, the only thing that code block seems to be doing is to eventually have be the final (following the example from the previous section) after splitting the class name. This suggests that we can convert this block into a method: 

Longer answer... It is not known how these lines are being run, but you can also consider writing event listeners, which is the typical implementation for checking if buttons have selected. For example, to use an : 

I'll leave it to others to for the GUI review, I only have a suggestion for your class: Constructor arguments positioning It is sometimes recommended to order constructor arguments by their requirements, e.g. 

Using is therefore unnecessary. Initializing values and array references You treat differently from a multi-valued array when it comes to printing the value, but with some adjustment to how you initialize and , you don't have to do so, e.g.: 

The return type of the method - a here - is useful to also indicate whether the move was valid or not, and to keep re-prompting the player: 

E.g. with the method name . Use interfaces such as instead of the implementation () so that your code is not too restrictive. Your method can then be (using so that you are not limited to just two arguments) : 

This showcases how the object reading from (or potentially other sources) is taken in as the input, and returns the output of . 

You don't need that. :) You may want to pay attention to commented code (delete them as early as possible?) and also to redundant empty lines. 

The changes above does not call the , ditto for the s specified in and , because I can move that to my code to 'compose' invoking the argument with calling too. This means I have to un- the method itself. 

You have the duplicated code block above in a few places, it's probably better to put them in a method. 

On the topic of testing, you probably have good reasons for just using , but for the sake of any beginners who may have stumbled upon this question while they are learning about unit testing, may I suggest something in that vein instead? Sample implementation (I'm using TestNG and Hamcrest matchers below): 

Understanding Since cannot be overridden, it is safe to just test that the entries' value is a . In other words, you only need one check. Iterating the smaller loop Now, now, this smells a bit of premature optimization, but if you are certain that one of the is significantly smaller than the other and is likely to stay that way, you can consider iterating on the smaller loop. 

If I have to implement an alternative solution, I will consider storing the numbers seen inside a so that I avoid traversing the full twice. The inner -loop will always start from the next index. The method to create the and the method to print the entries of the are shown below: 

Over here, we map our conditions using the as the key, so that it can read something like: 'with the key to , given the condition '. 

Since Java 7, using is recommended to safely and efficiently handle the underlying I/O resource for : 

These can be better renamed as //, to follow Java's standard method naming convention. Arrays are typically declared as , and you have some slight inconsistencies there. Standardizing to should ease readability as well. Also, on the topic of inconsistency, I will also suggest sticking with the use of curly braces throughout as missing out just one of them may be ripe for a huge mistake/losing an hour of sleep while debugging. 

Since you are using a Swing-based UI, displaying such errors through the console breaks the user interaction. You should consider displaying error messages using the appropriate dialog boxes too. Comments I'm not sure if your comment about using Nimbus (with a reference to Java 6, when you are clearly using Java 8 already) really belongs there... Also, 

First, I'm not too sure how your code works... your timeout starts after you begin to read the of the spun object for non- lines, but if you read the Javadoc of again: 

For what it's worth, the method signature to over-ride should really be (with the necessary check for the correct type), and you are also recommended to over-ride the method. 

The should be on the same line as the first closing . To reduce an additional level of nesting inside your method, you can invert the case for your statement to return early first: 

Here's a different suggestion, would it be better for you to rely on to do your parsing? If so, the class's method accepts a implementation, which you can supply with either a or (or in my case, I prefer wrapping my in a ). Something below is workable Java code, and you can start off from there... 

Generic type inference Since Java 7, you do not need to make the duplicate specification of the generic type on the new object: 

You claim " stores references to the elements that are interactable for the given product and attempts to build an in-memory representation of that product by scraping the page using ", could the lag simply be due to the time it takes to scrape the page then? Is this web scraping taking place over the public Internet, or can you set up a simple caching mechanism on top of your application to reduce load times? An internal web server just to facilitate testing should work too. Ideally, you should have a stub version of that you can test without having to perform the web scraping. The one final minor optimization I can think of (a really minor point, if I haven't emphasized enough) is to make initialize to the size of first, so that there is definitely no need to resize it later. Otherwise, stick with @Marc-Andre's answer, and look towards tackling the web scraping mechanism. 

If that is the case, and without delving too much into further refactoring the logic for this step, it may be more convenient, or easier, to pass as an argument to a generic method: 

Instead of dealing with array indices, you then deal with values, which depending on your perspective may look a little better. 

simply 'converts' the default value for, e.g. , to . As mentioned above, method chaining gives us a more fluent approach to specify the types of that one is immune, resistant or vulnerable to. in your main class can now be simplified as such: 

TestNG Eclipse's TestNG plug-in has an even better display of test parameters and results. The implementation is simpler too using method annotations, and you can specify multiple providers for multiple methods. Note: is the same as the snippet for JUnit example above. 

can give you an of the string's characters, as long as we're talking about Western-based encoding. A that lets you apply some processing on a to return some form of results, e.g. a in your case. Converting an to by calling . 

I did some formatting myself and shrank your code down to 48 concise lines. From there, I can see that the calculation for the phone and TV costs are the same - so you definitely should consider creating one method for each to wrap them and call them in the relevant places. This will also make future updates easier as you only need to modify two methods (which can be as simple as a one-liner method) instead of potentially six different lines. Why is there a need to cast the number of days as a double type? Also, as pointed out by @ChrisW, the first if-condition has a nested if-statement that doesn't make sense - a bug from copying-and-pasting? 

A character value minus the character '0' or the number 48 gives you the number to pass to your String array (because has an integer value of 48 in ASCII). I'll also advocate over at the very least... it's easier to read. 

No comments on the time complexity, I do have a bunch of other comments: Code to interfaces, not implementations It's better to use (side note: guess you're not on >= Java 7, since you can use diamond operators otherwise) so that users of do not need to know that it actually is a . This is just good practice. The lesson here is that it allows the programmer to replace the implementation with another in the future when required. Does not , then to a In the following code block: 

Alternate modeling When you have two enumerated arrays where there's a close relationship between one and the other, you can consider representing them as an . This lets you reference one value with the other, almost like a relationship. For example: 

You can combine both methods with varags so that you can pass in one or multiple cards without having to make an array explicitly: 

The check for is not required, as the method for any class should return for . Hence, in a similar manner, enabling can be done as such: 

If you want to cater for -specific conversions, there are methods for that too. Last, you need a much better name for your print (?) method... what is it supposed to do actually? The returned object doesn't appear to be used in any way. edit further explanation for an -approach Say you have a and : 

Regex Now onto the big one... your regular expression is ideal for simplification by applying the following rules: 

And since you have to split from a single first, you can use a wrapper method in addition to the one above: 

has to be called before , else there will be an error. When is called twice in succession, is returned from calling , skipping the first element. When we have a new , it starts from where left off, which bizarrely returns since that was stored as the final element of the internal array - is this expected? Regardless, calling twice returns the same value, when it shouldn't. Finally, calling the pair of methods triggers the error as would have iterated past the contents of the array. 

Instead of -ing for an , we can just handle for the case where gives us , a special case only for the first day. Look ma, no loops 

There is an alternative implementation if you are on Java 8. Instead of keying on your , you can use a to key by the scores after the values. Getting your result is then just one more call to : 

These two implementations are pretty much the same, you can consider passing within the method to the method to reduce code duplication. :) I also don't think your implementation is doing what you think... ultimately, there is still one instance of your persisted objects in . If you are thinking of returning immutable copies of your or objects, then you actually have a bit more work to do. I'm not sure what your two new methods are doing in your class, care to explain? Actually, it'll be better if you can submit a new question for further significant changes, so that the history and answers for this question can be largely consistent... Finally, onto your original question about searching for different generic types right within your class: I don't think that's possible, and this is where I hope other Java experts can offer their advice or solution on this...