I am writing an application that either mirrors a file/directory into another location or creates a zip file "snap shot" of a file or directory and stores it in another location. The user is able to create "rules" where they define the source file/directory, the destination file/directory and if they are archiving how many archives to keep. The user is also able to exclude files/directories if they so choose. Now this service class is a lot of code and I am wondering if there is a better way to do this. Of course all of the methods that can be called by the interface are called with a BackgroundWorker.RunAsync() method. Any feed back on how to make this more efficient would be super appreciated. 

Now the "exon" starts at 4 and ends at 12, and starts at 16 and ends at 21, making the data look like this 

This seems like a desperate attempt to find a use for closures, and I believe your problem would be solved much more simply by making an object, perhaps even a object that lets you overload indexing Some observations: 

so they are and , forming an intron . The calculation in your program, and in my code that produces the same result, gives , which is fine, but , which I don't understand. It is the last character of the intron and the first character of the exon Can this be right? I have put exactly the values above into your code and mine and get the same result 

Feedback #2: Angular provides a filter for formatting numbers, $number, so no need to write your own. Feedback #3: Use proper camelCase for function names (i.e. instead of ). As well as don't mix your snake_case and camelCase. Use snake_case for CONSTANTS (of which you have none) (i.e. instead of ). Feedback #4: Remove unused properties. You never set nor call , so get rid of it. Feedback #5: You're making a request without having all of your . If I change the value of the first select, but haven't changed the value of the second you are firing the promise each time. This can easily be fixed with a simple statement: 

There is absolutely no point in asking for a code review of a translation of a non-functional program 

Here's my Perl solution to this problem, for comparison. It simply iterates through every non-empty substring of the original and sorts the characters of each one. The hash keeps track of the count of equivalent substrings Once the counts have been established, the problem requires that the number of possible unordered pairs be calculated for each set of equivalent substrings Because all of N items may be paired with N-1 others we have N (N-1) possible pairs. But a pair like N0 N1 is the same as N1 N0, so we must divide that expression by two, so the number of possible unordered pairs of N items is N (N-1) / 2. That expression appears literally in the code below 

Feedback #6: You have no error handling around your request, but on an app this simplistic that may be by design. 

I have one entity that depends on another however in my API service class I would like to just deal with the dependent entity. Am I doing this correctly and is there a better way to go about this? Post Entity 

I am attempting to create a stored procedure that looks at one table and imports changes in that table to another. This stored procedure is going to be preformed on multiple source tables and will dump out into multiple log tables. The way the data in the log table is stored looks like this: 

Assuming this makes the arithmetic much easier, because there is no off-by-one error to account for, and the start and end of the intron are 12 and 16â€”the end of the first exon and the beginning of the next. Furthermore, numbers can be fed directly into without any offset, except that the last two characters of the intron are clearly at (6-2) I've modified my code below to take this into account, and it makes it much clearer to read 

I have altered your program, following the guidelines above. I hope you agree that it's preferable this way 

The stored procedure requires you to pass it the log table, the source table and the primary key that ties the two tables together (usually the source PK). And is a temp table created before this is executed in the stored procedure that simply stores column names that match between the source table and the log table (not all fields from the source are being logged). Now this code behaves as intended, the problem is the query takes about 10-20min to complete (just this part of the stored procedure). The heaviest query this is used on is looking at 48 fields in a table that only stores 300K records. There has got to be a way I can make this query faster. 

I would personally choose to set up a hash that converted suffix strings to a multiplying factor instead of using a chain of statements. Like this 

Update As usual, the solution was staring me in the face. I am confident that the values you extract to and are not character positions but offsets, that may be passed directly to . It was your comment "subtract 1 from end of exon because its 1-based index" that threw me So it is the gaps between the letters that are numbers from zero at the start of the string. Like this