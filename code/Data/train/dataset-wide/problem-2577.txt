So I'm not going to show you what a interface is (since I am at work) but I can show you a small blurb of what i'm talking about. Note that the number I put into this are not meant to be accurate, they are just to get you started. 

So moving on. This would mean that I would have to test the StudentInfoTableAdapter and because I don't have any of that code, nor the Microsoft Access database you have I won't be able to test it. Hopefully with the hint that I gave you about trying out a testing framework will allow you to get the TableAdapter under test and then you can slowly start isolating all the methods and find out what is the slow one. Remember to do this is small progressive steps. Happy Coding. 

that sure make it much nicer at the top most level, but the middle man I'm concerned if I should still use a enum. I feel that it would much more clean if I would just put a region at the bottom or top of my code with a few private constants so that things like the RATS command would switch from 

You'll notice it is 19 of the same thing. The problem with Random is that it isn't truly random sometimes, and you just ran across this. simple fix for me was to move the creation of the outside of the method now when I run it. 

that probably is not the exact code I would end up at, but it is the first step. I use the Repository code to connect to something (in your case MySql) parse through all the information and give me the important parts. If there is an error somehow while getting those fields I can easily just return or show a notification or something. All of that bit of code is easily seen as the try/catch is around very little code. (another tip). since I instantiated the fields to be an empty array if something did go wrong the wouldn't cause any sort of problems for me as it wouldn't execute any code inside of it. Small Try Catches I like the phrase I heard on here the other day about Pokemon catching. We don't want to just blanket all our code with a generalized Try/Catch. It tell us nothing, and just adds a larger level of nesting. Typically you only want a try/catch around the small bits of code that you expect to throw an exception now and then. This is the reason why I have fields instantiated outside of the fetching of all the fields, and program against knowing that potentially there are no fields. Ending notes there are a few other things, but I have to get going, so I will end on this note. If you use C# or Vb.Net design patterns in your code will help you encapsulate things in such a way that is easy to understand both now, and later when you have to change the code. Look into a few (such as the flyweight, or the builder pattern) as they could help encapsulate a different portions of your code into much more manageable sizes. 

Two things come to mind when I see something like this. Both boils down to encapsulation though. The first idea would be to make a class that has a Flower, and a Bird property on it. You can then simply make a list of those States and filter appropriately. 

the IntegerCalculator class is still a little bit from being complete, and the GUI itself as it stands right now can't add numbers larger than 1 number, but you get the jist of it. 

Since I'm not sure what you are asking by if you are doing it correctly I decided the quickest and easiest answer is to put your code to use. I created a method called Yates and put your code in it. I then called it 19 times in a simple for loop noted the output. (I limited my output to the first 5 numbers so it is more clear here) 

If it wasn't so late I'd go back and clean it up some. But i want to point out that i can continue to add tests now that Loader class is mostly complete and the similar code in the Player file could be replaced with it. And to test if i broke anything I can just re-run my tests (which all 3 tests run in under 1 second on my computer) 

Obviously this has some compile errors which means the test automatically fails. To make it pass I have to add those 2 methods to my class. A few quick "make this method for me" shortcuts later and now I have: 

any single letter variables are bad name choices. (with the exception of i, j, and k used in for loops, but even there sometimes it is better to not use a single character variable name) you could have made public and in its own separate file. As Jakob mentioned it would be for testing purposes. Why bring up unit testing in two (potentially more answers) because of how useful it is. There are a few frameworks available, both have their pro's and con's, but as a whole they should not be ignored.There are tons of blogs, posts, video's, tutorials out on the net to help you get started, but I will give a simple example to show the error that Jakob found so lets pretend that I made Calculator public, and removed the dependencies on anything WPF (IE... the TextBox) 

but that results in a compile error because structs can't be null! which means that by you checking for null you are wasting cycles. so delete your null checks and cast the as a leaving you with 

In the fail for the second Assertion it says Now granted this last part is personal preference. Find your niche and stay consistent. EDIT So based on your mention of using WinRT and the mention of compilation errors when passing in a null for a string parameter leads me to believe that your best bet is to either use string.Empty or my preference is to see a field with a meaning behind its name: or something to that effect. Then when you use it in your test it reads clearly . Granted it is a little bit of a workaround and looks weird, but at least it states its intentions clearly. and now that I've typed out btvConverter a few times it is annoying me. using the first letters of the converters name is silly. your test is specifically for a Boolean to visibility converter. converter is is clear enough of a name in the context. 

IGameView.cs You have a method called Release with the comments of Release as Releases all the resources allocated by this IGameView. This is the purpose of the interface IDisposable in the System namespace. I would recommend changing to that instead of Release. IGameController.cs You have a method called Start, but your comment says that it initializes the instance. It's not until I go GameController do we see that you do both an initialization AND a start. This is a violation of the Single Responsibility Pattern (SRP). In short it says your class should be responsible for one thing, your methods should only do one thing, and your variables should only mean one thing. It would be better to use your constructor to initialize all your variables, or to make a method in your interface called Initialize(). The context would say that you should use a method in your interface. Your method MovePaddle takes a player ID and a direction, and uses that to move the paddle. Your method Refresh is a good idea, but when I look at the implementation I feel like you lie about it's purpose a little bit. You have a GameTicker that calls it... I think it would be better if PeriodicTick had a instance of IGameController instead of the other way around, and then put the Tick to call the refresh command from IGameController. Although it does the EXACT same thing, this would make more sense to put that in the Ticker because I have to ask my self...well what does this do? I can't tell by looking at PeriodicTick. all I know is that it can be cancled. Last note about this too is that it is not a good idea to have a interface depend on a class. Rather it is always a better idea to have a Class depend on a interface. GameController.cs there are 2 instances where you have a constant defined in the code. MOVE_MODIFER being one, REFRESH_RATE being another. Nothing wrong with having these, but as your comment says it critically affects the performance of the game. Things like this should be put into a config file, or a setting that can be edited from your form. It may be a good refresh for your computer, but what about mine? how about all 4 of my computers? In General Try not to expose your variables in your classes. Expose your methods that act upon your variables. And example of this would be something like this.