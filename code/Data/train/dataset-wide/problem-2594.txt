This problem is a lot simpler than you think it is. The printf() isn't saving that much time because the printf() is only executing once per program run. Where the code should be saving time is in the calculating loop. First it should only be using stream input and output, the code does not need to do the conversion from string to int, this will be handled by stream input and stream output. This will speed up the algorithm a lot. 

Check ALL Possible Errors The function read_certificate_file() should make sure char *file_location is not empty before using it. Never depend on input being the proper value. This function May Not Work for Binary Files As forsvarir points out fseek() and ftell() may not give the results expected in all cases. See this reference. 

Semantics In the languages that implement , and the scope is generally larger than a single function. The scope of the exception handling is set by the block and the block. The C is limited to the current function, to jump outside of the current function you need to use and . Your implementation does not seem to use and . Maintainability Using a is generally decreasing maintainability, hiding a is a bad idea. If I have to maintain code that contains a goto I want to be able to immediately know that there is a goto and I want to be able to find the label immediately as well. Performance A reason to use is to improve performance. When goto's actually degrade performance that is another reason not to use them. 

All of what I'm suggesting here will be done by a good optimizing compiler. Some of what I'm suggesting is computer architecture dependent so you should depend on the compiler rather than doing it if you can. Generate assembly code and look at it to better optimize. First, register assignment isn't guaranteed, it is only a recommendation to the compiler. You want to move your register variable declarations up. The compiler ignores your register allocations when it runs out of registers. 

There are coding standards that apply to symbolic constant names, this link is one, but there are others. It doesn't do as much good where it is defined in checkWin(). Code which may lead to possible problems: Your switch statement doesn't have a default case, generally switch statements should contain a default case which handles all cases not specified and can be used to provide error messages. 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines in procedural languages like C as well. The KIS(S) principle simply states Keep it simple. Some possible functions that could be added std::vector inputBrands(); std::unordered_map mapBrands(std::vector brands); void inputPrices(std::unordered_map> dict, std::vectorbrands); The for loop above can be broken into at least 2 functions, I'm just not sure what to call them. Another benefit of breaking the program up into functions is that it can be profiled and you can find out where the program is spending the most time. 

While this C coding standard is for a specific class at a university it gives some good tips. The Use of typedef Might Help The typedef declaration provides a way to declare an identifier as a type alias, to be used to replace a possibly complex type name. By using typedef in the struct declarations the structs becomes types similar in some ways to , and . An Example Using typedef 

The other answer by @chux provides some good input on this as well. Global Variables It's best to avoid global variables whenever possible for a number of reasons, and there is a good discussion of this on stack overflow. Some of the problems associated with global variables are that they are hard to debug, they can be changed anywhere in the code, and it is hard to track down where they are changed. They make writing code more dificult and reading code much more difficult (in the case of this program, you need to look through 661 lines of code to find where the values of the global variables change). If the program is larger that this one, and in multiple 1000 line files, it can be really difficult to find where a variable is being changed. They may be redeclared in other files and the problem will show up at link time. It's better to have as few global variables as possible and pass by reference or value whenever a variable needs to be used by a function. Pass by reference will prevent certain kinds of errors such as changing a global value when the change should only be local. Reduce Complexity, Follow SRP, and KIS(S) The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

The previous declarations reserve memory for the globals in each object file, in essence this is creating a separate variable in each oject file. This should be: 

A collision is when 2 different functions have the same name, the same arguement types and a similar functionallity (this is why they have the same name). Someone developing software may want to override a function such as , or they may want to override the functionallity of a class such as std::vector or std::stack. Namespaces allow these constructs to be overriden. The use of the programming statement: 

First, Welcome to code review, and a very nice question for a beginning self learner in C++. user1118321 is correct about a everything he says, I'm going to emphasis one or two items and provide some references before I mention a few other things. Use Functions: Functions allow one to break up their code into smaller, easier to understand logical blocks. When designing software it is often easier to break a complex problem into smaller problems that are easier to program. Some people use flow charts to map out their program, and high level flow charts will only contain the functions. These will be followed by lower level flow charts that map out the logic of each function. Using functions allows one to decrease the amount of code written in some cases. The function should be primarily used to set up the environment for the rest of the program, call a function to execute the rest of the program and catch any errors. If you find yourself repeating code move that code to a function so it only needs to be written and debugged once. This is actually a programming principle generally referred to as Don't Repeat Yourself and you may see it referred to here on code review as DRY. Both functions and classes should follow the Single Responsibility Principle (SRP). The Single Responsibility Principle is that a function should do one thing, and one thing only. This makes code easier to write, debug and maintain. It also makes the function easier to reuse. The Single Responsibility Principle may also be a reference to Demeter's Law (I may be wrong about them being the same principle). Another programming principle sometimes mentioned is Keep It Simple (KISS), although this isn't just for programming. You may want to look into SOLID programming as well. A more comprehensive list of programming principles can be found here. Use Existing Classes A long time ago when I started using C++ the Standard Template Library (STL), sometimes called the Standard Library, had not yet been defined or implemented. We had to create our own strings, queues, vectors, stacks and other container classes. Using the C++ container classes and the standard library requires A Lot Less Code and makes it much simpler to write correct software. Two great website to become familar with if you are going to write C++ code are CPlusPlus and the C++ reference. These websites are better than using a book as a reference because it remains up to date, and documents the C++11, C++14 and C++17 standards all in one place. The string container class provides one with much more functionality then cstrings. The follow is new content not previously mentioned. Magic Numbers The term is sometimes used for numeric constants in code that are not obvious. By I mean that it's not obvious what the number represents. Non-symbolic references to numbers should be replaced either by named constants, or enums (enumerator types). An example of a named constant is: 

Boolean Values The original C specification didn't specify a boolean variable type, and conditions returned integer values. Many programmers defined constants TRUE and FALSE as 1 and 0. There has been the addition of stdbool.h in later versions of C that defines a boolean type and the values and . It's possible that cs50.h either includes stdbool.h or it defines true and false, but it would be better if stdbool was explicitly included in the code. Global Variables @Kerndog73 is correct that using global variables is a bad programming practice. It is very hard to correctly write code that uses global variables, and it is even harder to maintain. One may have to search thousands of lines of code in multiple files to find where a global variable is being changed. Global variables aren't needed at all when all of the code is in a single function. Magic Numbers The code contains the number 26 in two places, this is obviously the number of letters between and , but in many cases that wouldn't be as clear, and it is defintely less readable than ALPHABET_COUNT or SIZE_ATOZ. 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and stackoverflow question. Don't mix printf() with std::cout It would be better to choose just one output method, either printf() or std::cout. In this case since you are using it might be better to stick with printf(). Generally in C++ printf() is ignored in favor of std::cout. The output to std::cout can also be formatted. You may be able to use an errno.h that gives you the correct string and use std::cout rather than . 

While this is primarily targeted at classes in object oriented languages it applies to functions and subroutines well. Inconsistent Indentation The contents of the struct Vertex are not indented and they should be. Inconsistent Naming Conventions The naming of variables and functions is inconsistent, there are well named functions and variables such as , , id and color, and then there are names such as and . It might be better to name as verticyCount or maxVirtecies and as depthFirstSearch(). Inconsistent Initialization in Constructors The constructor for Vertex uses C++ initialization for it's variables, but the Graph constructor does. It might be better if Graph was written as : 

Decrease Function Complexity Another software engineering principle is the Single Responsibility Principle. A function should only be responsible for one action, this makes each function easier to read, write, debug and use multiple times. It is much better to write smaller more concise functions() so that the can be used in multiple places and only need to be debugged once. The functions and would both benefit from applying this principle. General Comments The program should guide the user better. It's not clear what the input should be, there should be prompts for each input. The program might be more fun if the user could enter colors rather than numbers. 

Name Spaces A most common practice is to preface types and functions supplied by the Standard Template Library, sometimes known as the Standard Library with rather than ignoring names spaces by the statement 

Use the Features of the Container Classes and the Standard Template Library You may find this website useful for learning all of the features a particular container class or the standard library. There are definitely some functions you could be using, such as , , std::count_if() and that could definitely shorten the code. It might be wise to investigate std::map as well for counting words. GOTO There are almost always ways to avoid using in C++. In rare cases may be appropriate for error handling, more so in than in because has try{}/catch{} and exceptions. In the following code there is really no reason to use a : 

Fix the Typos: Game.cpp: wether => whether, agian => again. Model View Controller: Generally a MVC design pattern has a set of classes for the Model, a set of classes for the view and a set of classes for the control. The classes in this implement contain elements of all 3. What you really need to do is separate the logic of the game from the display mechanism. An example, Game contains both game control and display. The reason for this is that it allows your model classes to be reused on different operating systems using different display mechanisms (console text as you are now or graphics). Amoung other things your controller should contain the code whether or not to play another game (remove pause() from Main.cpp, add playAnotherGame() to a controller class. The controller class should call both the model and view classes. The view classes should only handle formatting the output, the model should have all the internal game functionality. Let the Compiler do more work for you: In Game.h you have Game(); and ~Game(); and in Game.cpp you have 

A common practice these days is to make all array indexes for example std::string::reserve is defined using . Inconsistent Use of Constants In the function The buffer size is 1024 while the read uses the defined constant , it would be best to define buffer in terms of as well. It might be best to use a system defined constant for the buffer size to improve performance. Some systems may have a 4K, 8K or 16K file buffer size. Reading the file system block size and then processing the block with in the program will definitely improve performance. Inline The inline keyword is now only a recommendation and the compiler might ignore it. An optimizing compiler may inline every one of these functions as well. Deleting an Allocated Array In std::string BinaryBlob::readString() the line 

One goal in programming is to reduce the number of lines of code in a function so that the entire function can be viewed at one time. This makes it easier to write and debug. Prefer Local Variables over Global Variables When I first started reading the code I thought that it was declaring numeric constants in a strange way because of the following: 

Constant Values The value for MYHEAPSIZE is 2000000, however the comment indicates this is 2MB, and it's not. The difference is important when writing this kind of code. Two Mega Bytes can be expressed as 2097152 in base 10, 0x200000 in hex or 1 << 21. 

which is causing the bug @TobySpeight mentioned. Functions in Header Files Obviously putting function bodies into header files works, however, it is more common to put function prototypes into headers and function bodies into cpp source files. The reason for this is that if the header file that includes function bodies is included by multiple files, the functions are now multiply defined and the user runs into multiple definition errors at link time. One way around this is to make the functions in the header file static, but it is much better to just have the prototypes in the header file and link multiple object files together. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility.