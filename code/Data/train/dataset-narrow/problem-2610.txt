This ensures that the body is properly removed, cleaning up the contact points. Then it's shape is changed and it's re-added. In order to generate the each chunk must maintain a (doc). This is essentially two byte buffers. One with the positions of the triangle vertices and the other with the indices for constructing those triangles. This vertex array must be maintained as the does not make a copy of the data. Using all the built in Bullet physics classes is likely faster than anything I could write, and it does indeed run very fast. I haven't see any slow downs after implementing this new strategy. 

Well, looking at your steering code, it is a little strange. There's no point in your arrival where the acceleration will point away from the target. That's fairly critical for slowing down. You can easily test this by manually taking some values and plugging them into your code, calculating the values by hand as you step through your code. You'll find that currently your code just decreases your acceleration more and more as you approach the target. You need to go negative at some point to stop your entity. You need to define a distance at which to start slowing down. You'd likely want to decide this distance based on the entity's max speed and max acceleration. The distance it starts slowing down is the maximum distance required to stop with full acceleration away from the target. See the pseudo code below to get an idea of how to implement steering like that. The difference is that the below only uses speed, not acceleration, so you'll need to update it accordingly: 

I did some searching around and found that people occasionally launch a second Kickstarter campaign for the same project, often with success. However I wasn't able to find this situation with a game. The projects I found were for Kickstarting a project to some significant milestone of completion, or to complete to project. Then the second Kickstarter project was to expand the first or add additional elements to an opensource or free project. People may feel like they're not contributing to much if they're not even donating to help finish a project. If the first Kickstarter were to be solely for art, it may not be successful. Perhaps create it for reaching beta level, perhaps where you can start charging for access and fund yourself to reach your goal of completion. I've found that people like helping other people get to the point of self sufficiency. 

You can find more excellent steering examples here. Including the arrival behavior. Finally, this paper has more information on how to actually implement these algorithms. 

This gives you the benefit of gradient noise, while also constraining the output to three tile types. 

While I appreciate Kevin Reid's answer, it was at a level that was higher than what my question was asking. Understandably with out knowledge of Bullet Physics, it'd be hard to answer this question. I got this working and have an answer that is specific to Bullet Physics. Along with extending the class like I mentioned in my question. I also needed to extend the class. This is mostly to override the function. Inside the function (which takes the two colliding bodies as arguments), I was able to create a cube shape and appropriate for the cube that my entity was currently colliding with. Then just let the default collision happen based on the entity and the specific cube/cubes it's colliding with. In order to use the newly extended , I needed to register the algorithm to deal with the shapes I want it to handle. In this case that's pretty much the terrain type against everything else. For that I used with my . So for those following along in the future: 

This is just using regular old sine and cosine to step around the circumference of a circle and place points. You just need to know the center of the circle, the radius and how many points you want. The following pseudo code will output a set of points that make up the positions of dots you need to make a circle of points: 

As you can see, they have identical components. However, the components have different data. You could expand on the information component, but it's likely going to contain common information for all the entities of that type. So it's probably better to just have it stored someone common and just have a reference to it in the component. I would recommend keeping your components more general and use a different data structure for querying your entities, something outside of your entity framework. When you create an entity you can store its ID in a table for that type of animal. Then when you want to look up all the animals with teeth, you only need refer to your table and you'll get all the entity IDs that have that attribute. Alternatively, Artemis has a tag system for entities you could utilize. Which is essentially what's described above. It allows you to add tags to entities and query all the entities that have those tags. Though, last time I looked at the source it wasn't implemented. So you may have to implement something yourself. 

If each body does this, they will spread out away from each other. This combined with a cohesion algorithm keeps the bodies grouped, but not on top of each other. 

If you look at the Farseer Physics Engine 3.3.1 Testbed XNA code, you'll find an example called . Inside this test is the code required to create Fixtures that act in the manner you're requesting. Essentially, you override the function in the following way: 

This will depend entirely on the license applied to the art assets. The number of open source licenses is always growing, so attempting to provide a list here would be pointless. You will need to research the specific license that's applied to the art. Some of these licenses will allow you to reuse the art. For example, in the link you provide, a majority of the art is licensed under CC BY 3.0 which states you're free to make commercial use of the work (as long as you attribute the author). If you're unsure what your rights are, you might try contacting the owner of the rights to the art and ask about your intended use. You may also ask for permission to use the art beyond what the original license states or work out a deal for such permission. 

More likely to be placed towards the core than towards the arm tip. More likely to be placed closer to the center of the cylinder than the outside of the cylinder. 

Without a fairly substantial change in your code, your options are limited. If you take a look at the functions provided for you in the class, you'll find a function that will allow you to draw an image instead of using the existing function. Even this simpler change is going to require more changes to your code than just one line. You'll need to add image loading, storage and selection. I recommend you find a tutorial for tile maps using images, instead of attempting to modify this code to work for you. 

Attempting to remove an item from a list while iterating through that list will give you a concurrency exception. Instead of add the item to remove list. Then after your for each loop, loop through the remove list and use the call. Then clear your remove list. Like this: 

Forums or social media sites. There are already sites designed for that purpose. The type of places you want to go are the ones where these gamers are. Search the web for similar indie RTS games. Find out where people are talking about those games and start with that community. Don't spam. Just partake in the discussions, and inject your own questions when appropriate. Without paying for anything your options are limited. But, if you're allowing people to play your game for free, you'll likely get feedback from those willing to play. Ensure the players have a place to respond, and ask them to share their thoughts. There are a number of free blogging sites, a Facebook page, Twitter, etc. 

I think you are mixing up your logic and drawing code too much. Separate your node linking and line creating. Basically it looks like you want to draw a "thick" textured line between two points on screen. Here's some pseudo code that shows you how to get all the vertices for doing just that: 

Assuming a game running at 60 fps, each frame is about 17 milliseconds. Highly unlikely someone could press and release in that amount of time. If you can click fast enough to get about 60 clicks per second, then you'd be pressing and releasing fast enough to beat the frames. 

That code could be used from something that had a minimum and maximum firing range. The image below was not produced by this code, since I'm away from my dev machine. But it gives an idea of the two types of shapes produced. 

Your script is attached to an object that doesn't have an Animation component. That's why you're getting a when you try to run this line: You probably need to add a Animation to the game object "CharacterLamp". Or your script needs to check if the component is attached before using it. You can check to see if the component exists with: 

does not alter . See here. So will always be false. A simple fix is to change your input to only trigger once. Instead of you can use . You can alternatively add your own flag for when the weapon is active. This additional flag would likely be useful for the animation and other time delays to keep the sword from swinging too fast. 

This will find all the hexes within a certain distance of the center hex, if you want to consider obstacles, use the breadth first search from my other answer. 

Yes, you can leverage the noise algorithm. Use your attempt so far as a baseline. Then, using a single dimension perlin noise function, use the x axis as an input to add noise to your baseline function. You can either do this at every point along the axis, or you can do it just for the peaks and valleys and interpolate the values between. This will be pretty unrelated to your terrain height algorithm. The only similarities being that you're using perlin noise for both. Another algorithm available to you is midpoint displacement: 

Your technique will be sufficient. Since you seem to understand how to do it and what needs to be done, for this situation, it's the best way to go. As it is with many decisions like this in programming, you'll have to consider your requirements and see what your budget allows. Your budget is the time you have to complete the project. You know your requirements better than anyone here would. So if storing an integer for each unit and building meets your requirements, and you think you can do it in the time allowed, go for it. It's not a bad way of doing things, and I don't foresee any major problems with doing it that way. 

You can see it in action here and get some details on its implementation. You'll do some minor tweaking to include applying a force towards the mouse pointer. 

The author suggests a change to the code above to make it usable, since it's currently an example of how you can have constant bad precision. Change to a double: 

This example also shows making the player into an extension of a character object. This means you can use this same method for other creatures in your game too. Plus it puts things in a common place, so for example the function can do the following for characters: 

The primary difference is how they're used and how they're expected to respond. For example, AABBs do not rotate, rectangles are allowed to. You're right, they're very similar and you could use a rectangle like an AABB if you applied some restrictions to it. AABBs are essentially rectangles that are always positioned to be aligned with the axes of the world. When you can make the assumption that none of your bounds are rotated, this makes many things simpler with algorithms for collision detection. The reason for the way the properties are named is because of the way it's used. AABBs are used for bounding, thus the properties describe the bounds, and so are called and . Yes, they're points. You need two values to define bounds on any given axis. The contains the minimum values for the x and y axis, and the contains the maximum values for the x and y axis. The reason for naming the two AABBs and is just preference. Typically in these scenarios, you just have two objects, where (usually) the order you compare them isn't particularly important. and are arbitrary names. Typically the does equal the x and y of a rectangle and equals the x+width and y+height of the rectangle. As long as the width and height are positive numbers. 

The internet is full of feathers of information in blog posts, tutorials and communities like this one. Collectively, I'd say that's a pretty good wing to be under. Basically the dangers are not severe. You might do things the "wrong" or hard way for a while, but you'll learn eventually. You appear to have plenty of programming experience, so I think you'll pick up on the function part quickly. The mistakes made in game development and "regular" development overlap a lot. Your experience will help you avoid many of the common issues the befall new game developers. I think you'll do just fine. Good luck. 

These names vary by region, company and developer. Most of them are made up and are often just synonyms for "thing". Create names that describe the purpose of the code. A frame rate clock is called a frame rate clock. There's no dictionary for these things. You can't have a dictionary if the objects you're describing don't have a firm definition. The objects used in game development change from game to game. It depends on the game being developed for what functionality needs to be implemented. The objects being created are frequently specific to that game. Just call them what makes sense. 

Only trigger the event if the mouse was up before and is now down (all over the same element). Meaning you only trigger when the mouse is clicked on the current widget, and not by dragging a clicked mouse across multiple widgets. Means you need to keep track of the mouse state. Keeping track of which widget the mouse is currently over would likely be very useful to you if you're not doing it already. When a mouse press is detected it can be picked up by whatever your GUI controller class is. The GUI controller will then send the event to the currently selected widget. The currently selected widget gets updated something like so (this code is run by your GUI controller): 

The can range anywhere from a few hours for someone advanced making something very simple to hundreds of hours for someone very amateur making something very complex. The will vary depending on the number of developers and their wages. include things like pre-built solutions, libraries to support certain functionality and so on. Unfortunately only you will know the details of the variables, so only you can compute .