We know the amount of new tiles needed to fill the column so we simply generate new values and set the free spots to these values (you can do this from bottom up or the other way around ). You then simply create your visuals and tween them to the right position. The position is calculated by the tile width and height. For example if we take 32x32 and index column(x) = 2 and index roy(y) = 4. The position = 64, 128. When creating tile objects, it's easy to just store their position in them. So when you click on them you can just request their grid position. Don't forget to update this on every move. If you set all these values into variables ( including the size of your 2D array ) you can easily resize your grid, visually and structurally. Keep in mind that I'm trying to keep the actual data separate from my visuals. Eventhough they are in a way linked by their grid position. We simply have the sprites to click on them and request their position. ( you can do this without sprites though, by calculating the mouse position and converting it into a grid position). But the actual logic is done trough the 2D grid. We then simply call functions to move our visuals and set their new grid position. I also have to mention, you need to do bound checking as you traverse trough your grid. You don't want out of bound exceptions ( going below 0, or above the capacity ) Hope this helps. 

Unity is a very popular engine/WYSIWYG editor which allows programmers to expose easy to modify "components" which artists/designers can attach to entities to give functionality within the game. A bunch of components come standard which provide a lot of the basic functionality for games. From the Unity site: 

While doing a BS in CS at a California State University there was only one game development course which was group based where each group was to deliver a complete game from scratch in 10 weeks. Each group consisted of 4 programmers. This single game was worth 100% of the grade. It was straight C++ and OpenGL with weekly deliveries from all groups. One of the hardest classes I've ever had but at the same time we learned everything about how game engines really work. Rarely do students learn this anymore since most are spoiled with engines or frameworks that abstract all the "hard" stuff away. My professor published a paper about the class in 37th ASEE/IEEE Frontiers in Education Conference 2007 Student Teamwork: A Capstone Course in Game Programming The game my group created Images from my Portfolio Video of the game from another teammate 

Now you could write your keybindings to a simple text file. And just set those variables when you read them. ( havn't tried reading text/xml/json files in Unity but im sure it's possible ) The idea here is that the keys are stored in simple variables. Which you could easily change. It should be trivial then to read/write them away. So making an interface in game where you can set your keys shouldn't be a problem either. 

Perhaps you could check if there is a group of 4 tiles. For example the left top tile group is invalid because you have a passible tile. Then you check whether if there is a possible group in the vertical or horizontal alignment and keep resizing the box until no solid tile is found. In case there is a group of 4 you check in either direction whether 2 of those tiles can form another 4. If not then you stop looking in that direction and keep the rectangle as is. For each grouped tileset you also mark them as checked to make sure your algorithm does not check them again. So in sequence: 

Well there are certainly copyright trolls around this topic. If you ever try to use the word "Edge" in your game title, prepare to be sued by Tim Langdell Bytes: Tim Langdell & the IGDA 

The Mario AI Allows you to implement an AI Agent to control Mario. Different levels of map details are available to allow a simple implementation or implementations with near engine level map details. The API is a server/server type implementation using Java. Additionally a Level Generation API is provided for creating user generated levels. 

If you use triangle picking, you only need to solve for a line/plane intersection test to find the point on the triangle that you clicked on. Use the raycast as your line and treat the triangle as a plane. 

For a game like you described you might consider going for a full Planner based solution. This allows you to describe simple transformations of the world state the AI can perform. Essentially the AI plans a number of moves ahead of time to reach its desired goal. This approach is computationally expensive but for a turn based game it's a great fit over classical min/max and alpha/beta pruning techniques. The issue you run into with the Rule Based System you described is having to constantly tweak conditionals and re-prioritize the list. When the list of rules grow larger they become nontrivial to fix small issues without affecting everything else. Utility systems have similar issues when a large number of utility functions constantly struggle between themselves. STRIPS is a well known planner algorithm that was used very effectively in F.E.A.R $URL$ Jeff Orkin's paper on his STRIPS implementation for F.E.A.R is a great starting place. A SDK to F.E.A.R is also available to take a look at some of the AI implementation details. $URL$ 

Now if we were to apply the Pythagoras theorem on our new dx and dy value you will notice that the length is 1. Meaning that we have a direction, and a magnitude of 1. To change it to our speed simply multiply each component by it. 

2: We first create a vector ( 2D in this case with component x and y ) by taking the difference from both positions ( mouse - player ). 3: We then Normalize it to create a so called " unit vector ". Which means to bring the length of our vector to 1. This is done by dividing both x and y component of the vector by the length/magnitude. We need this because this is our direction vector. It simply tells in which direction we are heading for the x and y axis. 4: Now we have the direction we just need to multiply it by a scalar ( or simply put by your speed). Since the length is 1. Any number we multiply with will result in a new vector with the length equal to your given speed. Just remember that a unit vector represents the direction of your vector. Basically the red dotted lines is how much it moves in the x direction and how much it moves in the y direction per frame. So recap: Unit vector = direction Magnitude/Length/speed = steps to move per frame on x and y axis. (The lengths in the drawing are just for visual aid, they are not meant to be accurate ) Hope this helps. 

You can kill two birds in one stone. USC Interactive Media Division or USC Game Development The Princeton Review rated USC as the number 1 Game Design school, Digipen rated 2nd. $URL$ 

So typically Havok works best with normal human sized objects with a gravity of 9.8m/s^2 and dealing with everything in meters. In my Game though there will be a large variety of scales from millimeter sized objects to meter sized objects. Typically this rules out running a standard Havok setup and dealing with things in a meter scale. Would it be best to increase everything by 10x or some scalar like this and increase gravity likewise? I understand this would also decrease how far objects can be away from the origin but for the sake of this question assume everything is relatively close to the origin, a hundred meters max. Issues of concern Object penetration - Havok usually allows some object penetration in the 2-3cm range in the meter scale. Floating point precision - Issues dealing with distances of objects etc, typically physics breaks down at the kilometer scale in Havok. Unseen - other unseen issues that may result with such large differences in scale. 

dt (delta time) is the time between each cycle/render frame (or any time stamp you desire) of your loop. With this delta time we can stretch certain values over time. Just like in the real world we measure certain physics properties over time. Let's say we run our game 60 frames a second. If we want our our player to move 5 pixels per second we do 

If you keep iterating through each adjacent node this way the costs will logically add up. And thus also give you an easy solution for comparing open nodes with new nodes and determine whether or not to swap parents. 

Here is a link that might be handy for you. Assuming you are a beginner. Edit: As for your question in your comment... ( Not tested and it's just to give you an idea ) Let's assume we are using our own created Sprite class. It contains a Texture2D you need to pass through the constructor and a position vector. Which will be both used in the draw function. 

As you can see the edges are rough and full on opaque. If I do use a texture with softer edges the pixels with alpha will just smear the black away. How can I achieve the effect of pixels in my texture with an alpha of 0 < x 1 to only affect pixels with alpha 0 in my buffer?