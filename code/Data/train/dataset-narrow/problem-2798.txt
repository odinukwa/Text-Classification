Having done both courses, Bachelors in Information Technology (more like SE) and Masters in Computer Games Technology, I find the difference in curriculum is profound. Just like what Ken had mentioned, SE covered topics that were close to designing software and how the systems worked, while CGT was geared more towards SE for Games. If you're looking for a career in games, CGT would be the way to go as you get to learn (in a concentrated manner) the stuff required for games. It would also give you a better chance at getting a job in the games industry. I say better because it's not necessarily the degree that decides if you get the job or not. But when it comes to game development basics, you'd already be well-versed at how things fit together in game, while a SE student will have to go through the extra learning curve and learn graphics/AI/physics for games on his/her own to prove their worth to game companies. I should warn you about the downside though. As good as the game industry sounds, it doesn't always provide a lucrative career. For those who've settled themselves in a well-paid job in games industry, two words, WELL DONE! You're living the dream! But it's not an easy task. You've to work your mind off to prove your worth before they even consider to keep you in the company. And typically, you'd first end up working in a start-up (or self-found) game company, which doesn't provide you any form of job security and with basic salary. Trying for a big-shot company usually ends up with them telling you that you don't have enough experience. Not only that, if you do manage to get through to a big-shot company, they usually don't pay you as much as what you'd earn as a Software Engineer. With that warning, if it's your dream to be working for a game company, GO FOR IT! But beware of what is to come and be prepared for it. In the end, when all your hardwork pays off, it's the sweetest achievement of your life. If however, you're not sure if you'd like a lifelong career in games industry but still like to dabble on the idea of working with one, I would suggest first taking up an SE Bachelors degree, try to get internship in a games company based on your degree and progress your career from there. Failing to find any, you could go for Masters in CGT and try for a game company after that. If all fails, you'd still be able to get into software companies based on your Bachelors degree and the fact that you've got a Masters degree related to CS (they don't usually care if it's CGT or not) as long as you can prove your worth. 

I was able to solve my issue. The second revision of my gist has the solution. In a nutshell, this was what I did: 

Create a camera Set the view matrix of the camera to identity so that there are no view transforms made to the children Set the projection matrix of the camera to be of an orthogonal matrix with width and height equal to 1 Set resize policy on projection matrix to be fixed Set render order to be (I previously had this as and that didn't work. I still have to dig into why). Create a textured quad with width and height of 1 unit Add the textured quad to an instance of and add that geode to the camera Extract the first window from the camera. Set the graphics-context and viewport of the camera Add the camera to the scene and you have a background image 

I know that the image is getting loaded because the logs says so The log says that it managed to add the camera as slave to the viewer 

To make it clear. Use can use Photoshop or any other image-manipulation or image-editor for 'mock-ups'. This helps you decide the color of each element of your GUI and the look-n-feel of it. To actually design your UI, you will need a custom application, i.e. not Photoshop, to create your GUI and save the 'layout' (and associated images or sprites) to a file, which can be loaded by the game you're targeting the UI for. 

If I were you, I would question myself about 'What do I enjoy doing for a game?'. Do you want to be a graphics programmer or a game programmer? Do you enjoy fixing those odd pixel in the screen that doesn't fit with the rest of the screen or do you enjoy building the game and don't want to be really bothered by the graphics implementation? If you're more into graphics, learn a high-level graphics API first, like Ogre3D, Irrlicht, Horde3D, etc. Once you grasp high-level concepts, take your time and dive into details. If you're looking to game development, learn to use game engines like Unity3D, Unreal3D, etc. They've done the hardwork of getting the engine implementation right and you can concentrate on the building the game itself. 

I know you've already accepted Zhen's answer but I'd like to put another out there just in case it helps anyone else. To reiterate the problem, the OP wants the ability to keep the rendering code separate from the logic and data. My solution is to use a different class all together to render the component, which is separate from the and the logic class. There first needs to be a interface that has a function and the class uses the visitor pattern to retrieve all instances, given the list of s and renders those objects that have a instance. This way, Renderer doesn't need to know of each every object-type out there and it's still the responsibility of each object-type to inform it's via the function. Or alternatively, you could create a class that visits all GameObjects and based on individual condition they can choose to add/not-to-add their renderable to the visitor. Either way, the main gist is that the calls are all outside of the object itself and reside in a class that knows intimate details of the object itself, instead of that being part of . DISCLAIMER: I hand-wrote these classes in the editor so there's a good chance that I've missed something in code, but hopefully, you'll get the idea. To show a (partial) example: interface 

I was unable to find a good working code for this simple thing. Luckily I got this working. I hope this helps someone else who's trying to do the same. P.S.: If you want to displace the background image on the screen, think of doing that in relative values; [0, 1]. So if you want the background image to be on the top-right of the screen, create the like so: 

Spotlight shadow maps are created by projecting the scene with a perspective frustum. This allows the light to radiate out from a single point. This perspective frustum is built using: 

Somewhere in your engine, you also have some sort of abstract factory that is able to create all of these concrete implementation objects for you. When initializing the game, you pick which API to use and set up your factory to create the objects that conform to that API. Your high-level code can now work with objects like meshes and textures without needing to know which specific API you're using. 

The next step is to write the vertex and tessellation control shaders. Despite the name, control points are sent through the vertex shader as if they are vertices, and they may store the same data. In a tessellation pipeline, the vertex shader's job is simplified quite a bit, as it only needs to pass on the control point data, possibly applying per-instance attributes and/or transforming them into view space. In our simplified case, we will only be passing on the position of each control point. I will use GLSL to implement the example shaders. 

Nodes can be implemented as a collection of its adjacent nodes and its data (position would be relevant to pathfinding). 

Assuming that there are only going to be a small number of FSM classes (one for movement, one for AI, etc.) then I would make each state a component (or part of a component). For example, if an entity has Walking, Climbing, Melee and Ranged components, in these components will be encoded the Walking, Climbing, Patrolling, and Attacking states of two different FSMs. Although you will have to have a separate place for each entity to actually keep track of which states it's in, such as an additional AI component, this will make it relatively simple to extend the mixin philosophy to your FSMs. 

EDIT: It seems I didn't read your question thoroughly enough to realize that you've already tried the deferral method. Keep doing that. 

Since this is the case, I wouldn't keep using a hierarchical scene graph. I'd break down the world using an octree. The benefits of using an octree are that you get your frustum culling and LOD determination without needing to fit every object into a hierarchy. If you want, of course, you can still have object hierarchies like in a traditional scene graph. On the flipside, octrees are a little more difficult to maintain, especially considering objects whose bounding volumes may lie inside multiple octants, but they integrate much more easily with physics simulations. Just remember to choose an appropriate maximum subdivision level to avoid having a lot of objects in more than one octant. 

The tables are loaded into client code as a tree. It's easy to get and set values on the client side, but changes on either side need to be synchronized. The native code does no caching and instead directly reads from/writes to the Lua state each time. Possible performance issues? 

As you can see, the action takes up both the and slots. The action takes up only the slot, so both can be performed at the same time. If there are two pending actions that use some of the same slots, you can sort them by priority, so a action would be more important than a action when a powerful enemy is around. 

Edit: Here's a method I'm now considering. Hopefully I can program the systems to make use of this layout while still avoiding memory problems. 

It sounds like you're making an RTS, so let's say you need to have a building that automatically attacks the nearest enemy within 100 metres. 

Call of Duty was most likely programmed in C++ and DirectX. Unity should be enough to "make your own version". 

This is not to say that everything is being allocated naively using something like . Everything will be kept contiguous and cache-coherent. It's arguably easier to make your memory access efficient if you don't have to worry about paging in and out manually anyways... 

You should use the D* algorithm, which is designed for this exact scenario. Specifically, the D* Lite implementation is the most efficient and simple variant. 

One thing I liked about the backtracking in Super Metroid is how your new powers allowed you to get through the areas faster, but in a more challenging way. Another way is to place items such as health upgrades (or obvious switches/breakable blocks) in plain sight but out of reach until you come back in possession of another item. The best example of this is the first part of the lower area of Brinstar, where at first you have to take your time carefully jumping through waist-high water and avoiding invincible enemies. When you come back to that area, you have the Ice Beam which allows you to freeze the enemies and use them as stepping stones to quickly traverse the water, and of course you eventually get the Gravity Suit. A different game that makes backtracking interesting is Dark Souls. The difference with Dark Souls of course is that you aren't usually locked off from areas, it's simply that the enemies are too high-level and thus will be hard to kill. When you first come to Anor Londo, there are a bunch of Sentinels standing around that don't get easily aggro'd, although some guard chests. At that point, most players won't be able to really take them on, so they are ignored. When you come back to go to the Duke's Archives, you can take on the Sentinels and claim the treasure. The same goes for Blighttown when you need to go to the Demon Ruins: it becomes much easier to explore the rest of the swampy area and you can find the Great Hollow. At the same time, power players (like me) will have already explored these areas and removed the need for backtracking by enabling warping to the areas that are weren't opened yet. There is of course also the optional revisit to the Asylum, in which the area is repopulated with tougher enemies and a heinous trap is placed. 

Although the eggs and the Piranha Plant are clearly resting on the ground, the flower tiles continue behind them, out of the collidable tile. I know that it would be simple to do by hand, but extremely time consuming. Using an auto-tiling algorithm would save me a lot of time and boredom, but I'm not sure where to start.