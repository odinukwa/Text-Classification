Basically, the code just looks consistently written. That being said, it's not really organized. The Bad 

If private variables aren't all that beneficial, or the property is meant to be public, I'll just declare that as part of the prototype: 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

Instead of defining the rules outside of the class, it might be a good idea to sub class and set the rules inside the constructor. Create public methods specifically for each kind of validator. 

Separating things into these layers makes them testable. You could write Jasmine or Mocha tests for your controller and repository layer: 

The hardest part of managing HTTP requests is that there are a million ways for these things to die. Any assistance you can give for error handling will be appreciated by all who use this class. 

Your code looks so good, it is quite impressive of you were learning c++ few days ago. i'm sure you will get a decent code-review but here my humble attempt. It always preferred to pass the by const reference if you don't modify it. also, std::vector is preferred over std::list. here link for more details In your read function. It redirects all input into this container until EOF is received. However, the used container might need to reallocate memory too often, or you will end with a exception when your system gets out of memory. In order to solve these problems, you could reserve a fixed amount N of elements and process these amount of elements. here an alternative example to your read function by using and like so, 

here is equal based on the if it was converted to string size. also, will be always equal . i don't think you need it here. use where it is possible you have few candidate for it like , and . also in for-range loop it is better to consider it for optimizing purpose like so, for since you going to use it often in your code, it will be nice if create std::string object for it. 

Push it higher in the source code Save an unnecessary as module namespace is assumed and you don't expect the command to vary per instance 

Finally, thanks for not making an artificial singleton of the Micron class. Not that you might have, just that some would. 

I concur with dmeister. Jobs are treated too opaquely by Micron and therefore have no access. A crontab entry is highly structured and a good Job class would allow inspection and modification of its elements. This leads me to think that you have focused on the container (a crontab) while ignoring the item of interest (a Job). You did code a goodly amount of care into handling exceptions. Is there a higher level fall-back (that is, "first, do no harm" as you really don't want to stomp existing entries)? Does the crontab(1) command preserve the prior state on errors or is that something a top-level except ought do? It is not clear what happens with non-MICRON tagged jobs, you should expect that they will exist. One nitpick. CRONTAB_PATH is ambiguous where CRONTAB_CMD would not be. You could also put the definition of the command path at module scope which would 

This way all of your rule classes are hidden. All of the validation rules are portable because they are created inside a model specific class, and it's easy to use an IDE's auto complete feature to discover which rules are available since the RuleBuilder class has strongly typed methods encapsulating each rule. On top of that, the IRule interface just accepts a value and not a model, making each rule unit testable to ensure your validation library is functioning properly. And for those who do some .NET/C# development, this pattern probably looks familiar if you've used the FluentValidation NuGet package for Visual Studio. Say what you want about .NET development, but there are some gems out there. I do like the pattern that FluentValidation uses. 

If using actual private variables in my class, create get/set properties for those I want accessible to the outside world: 

I tend to gravitate towards making everything public, and part of the prototype. As a personal convention properties and methods prefixed with an underscore are not meant to be called publically. Some people force encapsulation by using private variables, but this always feels like I'm trying to fit a square peg into a round hole. Unless you jump through hoops, everything in JavaScript is public. Embrace it. It makes unit testing your JavaScript code easier as well. As an added benefit, most browsers have optimized the Constructor Function + Prototype code by generated classes behind the scenes for your JavaScript "classes", making property access in JavaScript almost as efficient as native code. Browsers haven't done much to optimize Constructor Functions that use private variables --- which is not to say that kind of code won't ever be optimized. It just isn't optimized very much right now. Edit #1: From OP's comment below: 

thanks to @screwnut for suggesting to instead of for-range while the for-loop is bit clear and simple. but std::copy_if will allow us to use lambda instead of calling function, that might be helpful if you simply write it like this: 

i have made a simple sudoku solver which is a puzzle game where the player has to figure out the empty cell and checks which numbers are absent from the corresponding row, column. how can I improve it further? 

Based on previous question i implemented most of suggestions. also, i have added Alpha-Beta pruning to minimize the calls. and making the game more generic to accept the board to be any value like 4x4 or 5x5 etc, every thing looks working fine for 3x3 board but it becomes so slow if i choose the board to be 4x4. how can i improve it further? 

@Incomputable provides a comprehensive answer i would add small alternative approach by using std::stringstream as shown below, in order to make it accept a delimiter rather than whitespaces and escape characters, it needs to covert the given delimiter to acceptable character to std::stringstream object. 

Permissions are better handled by a service, so that you can more easily unit test that layer, plus the permissions logic becomes portable between presenters to promote DRYness of your code (Don't Repeat Yourself). 

This breaks the relationship between and because we assume is the document object that contains . Instead, we want to create delegate properties for and so we can maintain that relationship: 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

The form would need to instantiate the user permissions service with the proper user object before the method gets called. 

I know this is a lot to throw at a code review, but this does allow for loose coupling, plus all the functionality is componentized and reusable. Since each class has all of its dependencies as public properties (like the ) it becomes easy to mock up those dependencies for the purpose of unit testing.