When checking the diagonals, your conditions are not mutually exclusive, so there is no need for the . Also, you are returning true in both cases, so you can combine both conditions to a single expression, and return the result of the expression. 

Comments should tell why something is done, not what is done. What is done should be told by the code. 

What is ? What state can a lock have? The one state that is meant here is whether it is locked or not, so just call the parameter instead. Instead of defining that variable , whose name does not really explain what it is for (probably something like "delta", so might as well write ), and than only using it to subtract it from another value, just assign the result of that subtraction: 

Don't write the type into the variable name. The type should be able to change without the variable having to be renamed. already tells you that it is a collection of subfolders. might be better, to make clear that it contains the folders' names, not wrapper objects for the file system. Removing the backslash from the beginning can prevent you from having to read up the code to make sure where the backslash is, at the beginning or the end. or implies just the name. So add the backslash wherever you concatenate the strings. 

There is a way to ensure that: Sorting. Sort your points locally within your hashcode method, first by their x value, then by their y value. 

You can further improve it (in terms of performance) and reduce redundace by first checking the middle cell, because it is required to be set for both diagonals. However, the performance gain is negligible, and the readibility arguably is reduced. If you do it this way, I recommend putting it into another private method where the method name tells you what it does (e. g. ). 

Put the opening brackets on the first line of the block, not at the beginning of the next line, since it is common practise in Java (even though I find it prettier if it is on the next line, since I code C# more than Java). Other Java developers reading your code will be used to it. 

lies about what it does. It suggests that it does almost the same as , just maybe on a different output than the command line. A better name might be . 

Method names should be verbs (in most cases), so is better than . Even better: or , because is not explicit about what a result of means. All of these variables you assign in the first 7 lines of the method are not needed. Your is not even used anywhere else, so a local variable (without ) would be enough even if you needed the variable at all. In some cases it can be good to save values from method calls into variables in order to not have to call the methods multiple times, but if the method is just an accessor to a member variable, like , the overhead from the method call is negligible, and readability is much more important as long as performance is not an issue. And instead of returning a boolean value depending in the result of a logical expression, just return the result of the expression instead. Checking whether the position is the same () is obsolete if you then check with a threshold anyway. By the way, you have a bug here: occures twice in the expression, perhaps on of the minuses should be a plus. And since and are combined with I assume that you have another bug leading to false collisions in some cases. Here one of the should be a . You can simplify your collision detection logic by just checking whether the absolute distance is lower than your threshold. Optionally you could define the threshold somewhere as a variable or inject it as a parameter. Simplifying the method, I get this: 

Naming is a bit generic for a class name. It could basically mean anything, because almost every algorithm has some kind of solution. A better fitting name would be . It tells the reader (you, but also others) what it means. has two problems. Firstly, it doesn't sound like a method name, because methods are usually verbs. Secondly, the convention for methods and functions in Python is , also called snake case. My suggestion is to name it , or even just considering you rename the class to . has the same two problems as the previous one, but additionally it does not really tell you what it does. If it is a helper, maybe it should be a class, but it does not do enough for that. If it is a method or function, what does it help you with, i. e. what does it do? A better name might be , and you could consider making it an inner method of the other method, since it will not be used outside of it. That way the user of the class does not need to think about which one of the two methods to use. OOP You might consider making all that code (after the suggested changes above, only one short method) part of the tree class. After all, it depends on the tree anyways. Of course this does not apply if you did not write the Tree class yourself, or if you want to make a more generic traversal class for different types of trees. In you do not need to specify a parameter for . Since it is a member variable, you can just access it via . 

Just call it then. You probably will find an even better name, if you think about what kind of helper functions this class contains, but never abbreviate a class name like that. And most importantly, never make it depend on a comment to be understandable. More idiomatic names might be or , even better if you add what they are for. You can also omit the , since it is kind of obvious, and the class represents the thing which is a or . For Example . As statet by Timothy Truckle more explicitly in a comment, the Helpers do not need to be static, and it actually hurts your attempt of good object oriented design. This is what I wanted to imply by "the class represents the thing ...", which means you better treat them as objects with a certain behaviour. So the classes are more than just a set of functions. That whole class is actually your , not just some . Your should abstract how and what exactly is being written out, and have an interface with methods like (which comes close to what the first 8 lines of the main loops are doing) instead of the whole code being put into the class. 

Your parameters are not named very well. When calling your method, how do you know which of the strings is the substring and which one the containing string? I suggest the method header . Style Your use of white space is very unconventional. Usually you would have spaces around operators for example. 

After finding the first occurence of the first letter of the candidate in the containing string, the next improvement would be to check whether the last letter of the candidate is at position . That allows you to quickly find situations, where only a part of the substring is contained. Then you can check the middle part. 

You are using a lot of parameters and variables, so I won't list all of them, but basically all should have better speaking names, that tell you what they contain. In C++ names are often kept short, but for example your is actually your . The others are very cryptic, but we probably won't even need most of them. We will get to that. Logic and Bugs There seems to be a bug, or maybe just a redundancy, in the function . 

I shortened the call to hide some of the parameters. You are passing the variable by reference and changing its value, which can easily lead to hard to find bugs, especially when there is an easier and more intuitive way of doing it. Furthermore you have different variables for both players whether they have won or not, and still the function is returning boolean whose value always seems to be -1. If you changed your function to return the number of the player (1 or 2) if the player has won, and return 0 if none of them has won, you wouldn't need most of the parameters. Even better, if you only check whether the current player has won after he placed his symbol on the board, then you could just write the check in like this: 

In , and should better be and . The same in , however there they (as well as , and ) should be written in , because they are not constants there. 

Your initialization of is redundant, since you assign 0 at the start of the loop anyway. So just declare it before the loop, then assign it in the loop. Performance Expecting the likely case that your string does not contain the substring candidate and returning early can improve your performance in many cases, so check before looping whether the candidate is longer than the containing string. 

How can you have an array of being poisoned? I don't quite understand what these 2 values represent, but if they are different things related to being poisoned, better use two variables. Also, implies a boolean value, so better not use it for int values. 

You are using many C constructs, while you are writing your program in C++. But even though most C code is valid in C++, there is often a simpler or better way to do it in C++. For example, you could replace your array of pointers, which you use for the board, with a of s. That way you don't need as much pointer arithmetic (which is error prone) and also you don't have to pass the array size every time you access the board. 

This should ring alarm bells, because it leaks the internal state of an object, which means that you could also change it from the outside. Instead you should always access fields (class variables) via accessor methods (and only have these if you really need to). That way you can add a getter method, that allows to read the value, without anyone being able to change it. Inside of the class, instead of this: 

The second one is actually how you write formulas in maths. So when implementing a function to represent that formula, go the same way. (Hint: Maybe this code should be a function.) Using Functions 

The return type suggests that the method returns a collection of s, but is named . It should be called , if that's what it is actually doing. If not, then the name of the type might be chosen badly. 

This can be done clearer by concatenating the output and do one single println call. Don't forget to add newlines (\n). 

Built-in functions You don't need the function, as Python already has one. It is called . Boolean expressions If you return a boolean value based on an expression, don't write 

Saving intermediate results of calculations like this is good, when you need them more than once. But here you don't. So is more readible if it is inside of another formula than . 

You have the in the class. Shouldn't that be part of the ? The Game can't score by killing NPCs, and neither can the NPCs score by killing the Player. So the score is an attribute of the Player. 

The loops are obsolete, and do the same checks multiple times. Because your board is just 3x3 big, I suggest to just do the 8 checks, which would just be 8 more readable lines. If you do want to use for-loops for the rows and columns, you only need one for each, so two sequential loops, not nested ones. For the diagonals, as you did correctly, there is no reason to use a loop. I added suggestions at the end of the answer for how to implement the loops correctly, for when the board size is not known or might change. 

Using for exponentiation is faster and looks cleaner than using . Note that and are local variables here, even if they have the same name as the global ones. Use the function like this: 

Add blank lines between blocks of code, e. g. between for loops. That makes your code much more readible. 

You are setting the score to 0, then printing the value 0 as the score. What if you decided, that the player starts with 100 score points? You would have to change the value in two places. Since you already have the value in a variable, it is better to print the value of the variable. Like this: Note that I also removed the newline from the output, because reads much more naturally than 

Being pedantic about the terminology: Not the class, but the IDE, complains about the unused value. As hinted by markspace, I agree that first creating an instance of the game and then starting it is the natural way to think about it. Don't add to many side effects to the constructor that the user might not expect. To get rid of the warning about the unused value, don't assign the instance to a variable. Just do or . Here is my recommendation, with fixed formatting and changed class name (since sounds like a method name). I also removed the constructor from the main class; I don't think you need it, since is static. 

As others have already pointed out in the comments, in order to get help with the performance problem you need to add more information and code (e. g. the classes and ). However in my opinion there is still a lot you can improve in the already available code to make it worth a review. Please add more code to get further suggestions as performance improvements. 

This would look much clearer as a statement. Note that this did not work with strings before Java 7, but you should be over that. 

In the second block, you are first initializing a variable , but then you continue using the variable that you used in the block before. This way you are changing values that you already set, and not changing others that you expect to be changed. I think all occurences of in the second block should be instead. However, if you were using functions as I explained above, this problem would not occur and you would be less likely to get this bug, which is probably caused by copy-pasting code and forgetting to change it. 

Design You have implemented the class as a singleton, but made the constructor public. That makes the use of the singleton pattern kind of useless. Since you want the class to only be instantiated once, which is inside the class itself, you should make it . 

You are returning strings that are named errors. However it is not really an error. An error is something more severe. You might call it an error if the ATM cannot connect to the network. But that's not the account's job. What the method returns is actually an . Like with the PIN, this could just be a private field, because the method does not really do anything. Making it a field also enables you to change the message more easily if you decide that a different message would be more appropriate. Also the account should not really know about the message that is displayed when the customer inputs the wrong PIN. That is also the ATM's job.