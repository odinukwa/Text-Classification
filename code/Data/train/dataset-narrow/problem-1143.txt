Rant You hadn't tried much to be functional. If you had, then not even a single , mutable data structure or loop would have turned up in your code, but all 3 did, so... Most programmers hate global state, and for good reason. if there were any s in your , it would have been a mess in the making. Thankfully, it is just a declaration of constants, so no problem there. My take on your code The final code, which is very functional and handles errors using (real error handling should use to retain error information, but AFAIK it's provided by , which I don't have), follows. I put it all into one file, as Scala allows that. 

What's this piecemeal approach to functional/imperative programming? It makes code difficult to understand. In a particular part of a program, try to stick to a particular paradigm (I can't believe I had to say that. Multiparadigm languages have come a long way!). You seem to not have noticed the glory of . The glorious at the start of would make all the tail-recursion annotations in your methods to simply . should ideally be a . That would give you proper, compiler-implemented , and methods, alongside having easy pattern matching support, and not requiring to instantiate them. By the way, did you know that is a ? You seem to be using as a replacement for . IMHO, it complicates your code. Just use if you have to. You're implementing the singly-linked list in classic reference/pointer based way after all. Don't get me wrong here, using is definitely better than using , but I think it overcomplicates your code. Do take a look at cons lists. I guess that's what you actually want. Finally, a reference based list is not idiomatic Scala. A cons list (as above) is. Try to use that, it's not too far from what you're currently doing (I do hope that you want to do it the functional programming way, as you have not stated otherwise). As this is already not idiomatic Scala, you could go the full imperative route with loops and , as Scala allows you to do so. Or you could go the functional route with full immutability and cons lists. The choice is yours, but in this case, I and most other Scala programmers would recommend you choose the latter option. But whatever you do, keep this Frankenstein's monster imperative/functional hybrid from most people. 

This answer is mostly an addendum to @Peter Taylor's answer, so I'll not address previously addressed points. First things first - you ask us to reduce your code without changing it. That, obviously, isn't possible. So you'll have to settle for changing your code. Others have suggested minor changes; however, I'll go wholesale with my recommendations. In fact, I'll even show you a way where your code becomes just 3 to 5 lines long! (Warning: Java 8-fu ahead!) Method names Your method naming is plain horrible - it lies to the reader and API user (and that's after ignoring the typos - you probably meant instead of . As to why it lies to the reader of your code - that's usually you - and other users of your code - that has been already been clarified by Peter, so I won't bother with that here. Whitespace Whitespace is free, and makes intractable sections of code more readable - here, space around operators and before opening braces is the Java convention. Bracing Style Use a consistent bracing style for blocks - the Java convention is to put the opening brace on the same line as the declaration, and the closing brace on a new line at the end of the block. Try to always use braces even for single-line statements - it lowers confusion originating from wrong indentation and makes it easier to add code later to that block. Method visibility When you don't want a method to be exported (you don't, usually, for methods that are implementation details)(that is, to be available to anyone for use and abuse), you want to use the visibility modifier instead of or (the default if you don't specify a visibility modifier). I'll cut you some slack on this as it does not look like this app will ever present an API, but recommended practices are recommended for a reason. Method Signatures It's easier probably for your formatting purposes to return or - but that's not what one would expect. In the case of , it should return (for ease of use) or (for performance reasons, not that that should ever be your primary concern). , (which should be (or to satisfy my tastes), by the way) should return . However, you've probably noticed by now that is already returning the sum of the factors (shouldn't it be named ?) - so why not just use that in , excuse me, ? 

Observations Your code is beautiful (proper naming conventions followed, proper whitespace usage, very readable. I particularly like the type-aliasing, which helps make the whole thing that much more readable than a or ). I cannot personally think of any more ways to make your code more readable, however, I do have 1 suggestion. The algorithm you currently follow is standard and ideal (you even have proper masking of higher-order bits); and in my honest opinion any other algorithm would be tantamount to obfuscation; but if you assume that the code will only ever run on a particular architecture, you could probably unroll the loop. Suggestion 

This will result in for Windows and for a POSIX system like any Unix derivative, including Linux. Using the above data, you can decide whether to use or . You might then consider renaming the import to something other than , or not renaming it at all (like I showed). Reduce the number of unexplained "magic numbers" in your code. You hardcode 10 for stuff like the number of rows or columns, etc. Replace these with declared constants or function parameters, and follow the PEP8 naming conventions. You hardcode a lot of checks, preventing scalability to larger grids. Using loops and boolean accumulators for checking conditions, especially for can be helpful for this purpose. Loops can also be used to generate the necessary format strings for output. Maybe you should include some sort of command-line help (especially about how to play)? 

However, the inverse Ackermann as defined by Wikipedia is supposed to be a two-parameter function, and as such you cannot imitate it using a one-parameter function. Also, you want a loop here, so that the loop runs at least once even if the constraining condition is false at the start, as well be for my suggestion below. I don't think the return should be instead of either, as you can potentially return 0 if it remains as-is, which is not a legal value. What you could try, as the ending paragraph of the relevant section of the Wikipedia article mentions, is setting the parameter to a constant - not , and especially not making \$n=m\$ - although that works too. Here, I'd suggest choosing \$m=0\$. Such a choice helps with golf-ability - you can get rid of the division and the in one fell swoop - \$\lfloor\frac{m}{n}\rfloor\$ is always \$0\$, regardless of \$n\$ (assuming that , when converted to integral type, is , as it is in Java). So the loop condition basically becomes \$Ack(i, 0) < log_2(n)\$. Note the less-than (\$\lt\$), not less-than-or-equal-to (\$\le\$): this is the proper negation of the condition greater-than-or-equal-to (\$\ge\$). Mathematically, how about a constant function, which is in fact the slowest growing function as it doesn't grow at all? Why not just return a constant and be done with it? I think the PPCG question's rules forbid submitting a constant function, so let's not dwell on that any more (but it does make for a cheap trick, doesn't it?) 

I did promise some Java 8-fu, so here you go! I won't bother explaining this too much, it should be self-explanatory once the concept of higher-order functions and lambdas are understood, along with method references. Reading up a bit on Java 8 would help a lot more than me trying to explain this. I'll also sacrifice a bit of good design to keep it short - it'll all be in the method. 

and . Primitive to Object boxing costs time! Plus, a only has amortized constant lookup time, not true constant lookup time. What you want here is a pure old array, somehow indexable by s. That's possible, pretty easily, in fact. Plus, you are reinitializing the on the turns of your test counter loop. You could just call on it, if you end up using it at all. For an array, however, reinitializing it is the way to go when clearing it (reinitialization is amortized constant time (including GC), not linear like clearing the array. It's linear time in both cases for the , and there's additional GC overheads). Lots and lots of I/O in a tight loop. That's always a bad idea, as I/O form most performance bottlenecks. Maybe you should take the input in separately before you do the processing? (2) brings us to using separate methods. Now that your I/O and program logic have become loosely coupled, you can easily separate them into 2 functions. Trust me, a function call overhead is not too much of a problem here. (I don't do this is my "Improved (?) code below" as it's mostly a stylistic issue, but you should). uses pattern matching and regexes under the hood. Those can be pretty slow. For faster I/O, you want and family. 

Improved (?) Code My implementation will trade time for space, which means that more memory will be consumed in exchange for faster execution speed. With the test input available on the UVA online debugging portal (the one for the UVA Online Judge), this code takes ~100ms ( on PowerShell) or ~180ms ( through on WSL) to cover all test cases, including JVM start-up time. I use Java 1.8, like the UVA platform. The run times are safely much lower than the 1 second of runtime offered by the Online Judge. 

I have left off the return types of non-recursive functions as the compiler can infer them, and they are not unintuitive enough to hurt readability. Edit: In response to @leoOrion's comment about pattern matching and value bindings, i think I should explain what the following piece of code actually does. 

Extract out into a variable. I think ES6+ gets you and - use them instead of . As far as I remember, the former gets you proper scoping and the latter allows you to declare a named constant. I think my point (1) should have a declaration. 

It is fair enough to close only the outermost stream - the close request will be propagated by the stream to any enclosed ones. You should make reading and writing as 2 different methods, and . You may even want to parametrize them to take into account different files (file paths) and contents to be written. Your variable names are good and descriptive, nothing to fault there. Note that Java convention states that project names should be unique and involve a package structure involving the reversed domain name associated with the publisher of the software, i.e., your package structure should be something like . This ensures uniqueness in qualified names to a great extent. Another place where your naming scheme falters is in the naming of the exception objects. If we go with the scheme as object name = lowercase initials (first letter of each camelCased word) of type name, it should be for and for - but see point 9 below. I don't recommend the use of , as it may lead to namespace pollution, especially in an I/O oriented app like yours. I would really suggest you take a look at - that very C-ish loop is not really considered good Java. will automatically keep track of the line number for you - otherwise, it's just a getLineNumber()` method, however, note that the line number returned is 0-based. You might have to add 1 to the result to make it work like yours currently does. You really should look into (JavaDoc linked above). It has utility methods for a lot of stuff - writing and reading files, file and directory management (copying, moving, deleting), etc. An exposition of the Java 8-enhanced properties of this class has already been provided by @mtj, and this answer's already pretty long, so I won't get into it here. Suffice it to say that most of what you've done is redundant and Java does indeed have a simpler and probably more efficient way of dealing with files - and subpackages therein. Please don't change the current directory for the reasons specified by @RobAu - it's very disorienting if your current working directory (CWD) gets changed if your app has been run from the terminal (using, say, , where is in the CWD of the shell). If launched separately from the IDE using a terminal or console, the application's CWD will be the same as that of the launching console. If you absolutely have to do it, though, you can try , where will be whatever directory you need to be the current working directory. If you just want to use a common relative root for all paths, you can rely on 's objects' method. They'll kind of do what you want - resolve the provided relative path string with the specified as the root. If you're handling all s the same way, then you might was well keep only the most general , (thanks @slowy!). Don't Repeat Yourself! 

This runs in about 0.01 seconds on my system (CPython 3.6.0 Windows x64, Windows 10 Pro 1703, Intel™ Core i7 6500U (Dual Core), 8GB RAM). I cannot believe that on your system it really took over 10 hours to run - do comment with details of your system like I did above and let me know how much better this version does! 

Note that the method is now obsolete. Also, the number is used twice in the above code, so it appears to be a magic number. As it doesn't change according to your use-case, you could refactor it into a constant, say , as @mdfst13 said. However, in my opinion, this should actually be a parameter of , as follows: 

Suggestions You have written pretty good code already, and your describe your methods with comments just before them. You could make those comments into property JavaDoc comments, see the Oracle JavaDoc tutorial here. 

Introduction This code was part of one of my projects where it was used to generate boolean input values for truth tables. I have since generalized it for combinations of variables with only 2 values, and added a dash of general Scala-isms. This has been unit-tested with ScalaTest, and has proper documentation. I rewrote my original code which used bitmasking and shifts because I thought it was too "magical", i.e., difficult to understand at first glance. The bitmasking method also does not give a proper ordering of the values as I would have liked it, which this method does. This also embodies the concept of a multi-line expression-bodied method. Notes My IDE (IntelliJ Idea) recommends not using superfluous parentheses, but I leave them in for clarity. I would like reviews on any and all aspects of the code and documentation, including but not limited to performance (not really important over clarity to me here, otherwise I'd have used the bitmasking version instead), clarity and idiomatic nature of the code. Running Just copy into a file with extension and run it in the Scala REPL as a script. Example usage: