Pretty simple. We start at the root, and based on some evaluation, choose 1, 2 or 3. We choose 3. Then we do some other evaluation and choose B or B... Well I reused the graphic from below, sorry. Pretend the B on the left is magic B. Behavior trees have a different evaluation. The first time they are evaluated (or they're reset) they start from the root (parent nodes act like selectors) and each child is evaluated from left to right. The child nodes are ordered based on their priority. If all of a child node's conditions are met, its behavior is started. When a node starts a behavior, that node is set to 'running', and it returns the behavior. The next time the tree is evaluated, it again checks the highest priority nodes, then when it comes to a 'running' node, it knows to pick up where it left off. The node can have a sequence of actions and conditions before reaching an end state. If any condition fails, the traversal returns to the parent. The parent selector then moves on to the next priority child. I'll attempt a graphical form here: 

Additionally, if you need more than just the events provided by default, I'd suggest instead attaching a to your game object. This gives us access to the object returned from the event, telling us stuff like the object that created the event. Then you can do something like: 

You have to ensure the target entity has a position component. This is a simple check you can perform when assigning the target. It's pretty likely that the entity will have a position, otherwise it wouldn't make sense to be targeting it. But, it's just a simple check to make sure it has a position before assigning it as a target. When saving and loading the game state, you need to ensure that entity IDs are assigned in the same way they were before. You don't want to save the game targeting one entity, and load the game with a totally different target. 

There are multiple types of Splines, Bezier curves are one of them. Beziers aren't required to pass through the points that define them. From the looks of it, you want a regular cubic spline. It will ensure that the line crosses through the points specified. You can find some interactive examples of different types here. Also, I know you're busy being an 80's guy, but get that boneitis checkout ASAP. 

Red dots are nodes in your path finding algorithm. The orange lines define their conectivity. The Green agent wants to go from its current location to . If finds a path along . The Blue agents wants a path to , it finds its path along . The grid is still useful for placing your nodes, as it keeps the spacing for regular sized buildings, helps the user make straight lines and so on. But I wouldn't use the grid for path finding, use the nodes that have been placed. Nodes are created at each end point and each intersection. Agents not on a road can find the road nearest to them. Likely you'd want to force them to be connected to a road at some point, and may even want to create additional "minor" nodes for each connected structure or object that can contain agents. 

This is not practical using the current GUI system. Ideally you'd wait for the new GUI system coming in 4.6, which supports animation and a number of other features. However, if you need to get this working now, don't use the GUI system. Add a textured quad to your scene and interact with it the same way you would a GUI element. The textured quad can be rotated easily. The easiest way to create the textures for your quads is to use a paint program. Alternatively you can create a custom library for adding textures of individual letters. This can get pretty complicated. There are some existing libraries on the asset store for this purpose already if you'd rather use those. 

Disable the render component, and delay the destruction of the grenade until the sound/(particle/visual effect?) are done. Destroy takes an optional parameter for a time delay: You can create a new object in place of the grenade that plays the sound, does the visual effect, does collision checks for damage, etc. This explosion object would destroy itself when the sound or effects have come to an end. 

Since you don't mention if the racing game is realistic or cartoony, I'll assume cartoony. Yes, have a health bar. The engine should slow down and make coughing noises when it's very damaged. 

That's the situation you're in. You are very good at one of the core concepts required for graphics/physics/AI programming. But you don't know the language (programming). If you don't know the language your audience requires, then you'll never be able to apply your skills to that audience. So, while you might be able to find a job in the games industry, that company would essentially need some interpreters to work with you. Converting your knowledge into workable code. You'd be far more valuable if you spoke the language too. 

The main issue I see here is that you're using a Windows system. This OS works best for simulating things like windows and doors (non-organics). You need to switch to a Macintosh computer, these are exceptional with simulating apples. The latest version of the OS not only simulates apples, it has additional support for large cats, particularly mountain lions. However, if you want to continue using your Windows system, you're going to need to make some changes. First download the Visual Studio, it's primary use is for visualizing code. In your case, it will visualize your apples. Next you need to code-plant a binary tree to get your apples to properly mature. Make sure to add plenty of leaves so that the tree grows strong (also make sure you give it a big root). To test the apples for ripeness you can take a byte out of one and pass the bits through the function. Now, you've got apples! But, you said you wanted them to be like paper right? You'll want to port them to a flat file to achieve that effect. Don't use a database to store the apples, they won't be flat enough. Finally, to get the apples to float down you're missing one critical step in your code! You forgot to add: 

If you're providing all the information for the bones, then really this is more of a importer isn't it? The code is not really generating any content, it's simply displaying the content you provide. Start with the simple case of a single bone. Make sure your code can read the bone specifications and draws the bone correctly (starting out with simple lines would be easiest, perhaps colored differently at each end?). Then move to two bones, ensure they line up the way you want. Then try adding bones that are to be drawn symmetrically. You could probably define these bones to have specific properties like what kind of joint they have, and if they are mirrored across the body. You could do some things to help visualize the data, for example drawing ball and socket joints as a sphere, and elbow joints as a cylinder. If you're planning on animating this, you'll need to do a bit of work there. Likely you'd want to use inverse kinematics. The book Game Programming Gems 8 has a section on creating a "Non-Iterative--Closed-Form--Inverse-Kinematic-Chain-Solver" a mouth full for sure, but nevertheless helpful. Even with a IK solver, you're going to have a very difficult time creating procedurally generated animations for walking/movement. As @Patrick Hughes mentioned, Spore is a great example of this challenge. There's a nice resource called Real-time Motion Retargeting to Highly Varied User-Created Morphologies that should help you start to understand the undertaking you have ahead of you. Make sure you take a look at the PDF linked on that page. That being said, if you created an animation system that could do this, you'd have no trouble getting a job :). EDIT I'll add more details on the actual drawing of the bones. First, let me define some of the details you'll have to keep track of, for each bone. 

You have a few options. You can double up cases on switch statements. Remember if those s aren't there, the execution just continues along: 

Effort will be specific to your simulation. You could do something like the sum of the distance each agent traveled. Or the sum of all the direction changes each agent had to make. It depends on what your definition of fitness is. For either of the two above, you can just keep a running total for each agent, then add them all up, just as you do for distance: 

While I couldn't find and examples of that function specifically, we can look at the parameter modifier to get an idea of how this function might work. In the example: 

If you're using and to index into your array then they indeed will be out of bounds rather quickly. Since the and have nothing to do with how the tiles are indexed. You can index into your array with the following: 

That would give you the opportunity to choose between two valid triangles. Perhaps the tie breaking being which center point is closest. Considering your update, while more complex, my solution will only result in a tie when you have two valid triangles. Using this method your second example image would produce the result you want. 

Yes, you'll need to use a third party library to add the support, or you can write your own (not recommended). Which library to use is up to you, find one that meets the requirements for your platform and works with the hardware you want it to. 

Now I know what you're going to do. You're going to copy and paste this code, and tell me it doesn't work. Don't do that. Just look at the code and see how it works. Then implement it yourself to fit your project. There are improvements that can be made to this code as well. Like checking which way to rotate to be fastest. Check this class to see how you might do that.