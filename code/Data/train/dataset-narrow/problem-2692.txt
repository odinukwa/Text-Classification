It's almost always better to change a state's object instead of changing an object's state. Mostly for readability, as thats how GL is expected to be used. Even if you have multiple attachments in common between FBOs, I would still suggest binding them to each FBO. As for performance, its implementation dependent, but framebufferTexture is likely slower due to it having to compute the mapping for the fragment outputs into the texture, while a complete framebuffer already has this mapping computed and just needs to load it. 

From what I understand you are trying to render a scene many times from many views into a tilemap. To do that I would make each tile a layer of a Texture_2D_Array, and bind to a 3D framebuffer. In the first phase, render your scene instanced with view per instance, then in geometry shader (only place you can set it) set gl_Layer = instance. In the second phase simply render all layers of the array onto the tile atlas. By using a framebuffer you eliminate the need to cull using discard, which would have a severe performance impact. It will also make the code much more readable than doing all of this in vertex stage. 

Nowadays, most music seems to be prerecorded, but that means they are rather static and take up a lot of space. I wonder if MIDI is still a viable option (especially considering consoles or iOS) and if I can expect General Midi 1 to be available everywhere? (Note: Referring to the software instruments for sound generation from notes) Alternatively, are there vendors of embeddable software instruments that can generate the desired sound at runtime? The whole point is to re-create a dynamic soundscape in which instruments can change their volume, speed or pitch - this can be partially simulated with individual tracks, but it doesn't offer the same flexibility. 

When writing a C64 game in 6502 Assembler and loading the game using , I can choose the address where the game is loaded to. The most popular address I saw is , closely followed by , but I also saw and used a lot. Why would I choose one over the other? I understand because it's close to which you have to write the instruction to, but the other addresses all seem arbitrary. Can someone shed some light into this? 

VBO created and loaded with data VAO is bound Vertex attribs are set, vertexAttribPointer points into the current ARRAY_BUFFER, attribs are part of the state of the VAO Program gets vertex attribs from the current VAO (which may be the default VAO 0 if you never bound one) 

For my font renderer I store all characters in a texture_array, which eliminates the need for atlas mapping and worrying about uv float precision. For drawing use pointsprites and give each vert only a single attrib for character id, while the vertex shader tracks the spacing and scaling, you could easily adapt it to render multiple lines. Afaik this is the best way to maximally take advantage of gpu for rendering text. 

[s 0 0 x] [0 s 0 y] [0 0 1 0] [0 0 0 1] And multiply it * your modelviewprojection However this only works directly for ortho, for perspective, you'll have to w divide manually then apply this matrix. 

Generically speaking, how would you handle a huge 2D Map of which only a part is displayed? Imagine the old top-down racing games like Micro Machines. I would know how to do something with a tile-based map, but I want to create completely custom Maps. Target Devices are iOS, Windows Phone 7, Android, Mac and PC. Assume the Map is too big to fit to fit into a single Texture. Would I have multiple textures, 4096x4096 each and load them all into RAM? Seems wasteful, and if textures are uncompressed I might actually run out of graphics memory. Would I only load the max. 4 Textures that I need at any given point (when I'm at the intersection)? Or would I have one huge image file and load parts of it? In that case, are there any image formats that make it easy (O(1)) to find the file offset and length which I would have to load? Or is there a completely different algorhithm? Are textures the wrong idea? How would you implement a game like Micro Machines? 

Looks not too bad to me. Only thoughts are to consolidate your camera to have a setMVPUniform(GLuint uloc, matrix model) or similar function. Likewise make similar classes for Lights, textures, VAOs, etc. Wrap anything you find yourself copypasting into a function. As long as you keep your things public you'll still have low level access where needed. Definitely make a renderer class for each group of objects which share the same program. 

Double check if you are truly using viewport correctly. You're not rebinding the texture to the FBO. That SHOULDN'T be necessary, however the spec makes no guarantee that glTexImage won't screw up any attached framebuffers, so assume that it can. If that doesn't work then its the way you're sampling from it. For simply allocating a texture with undefined content, use null as the data pointer, much faster. Absolutely never use mipmaps with a framebuffer unless you know for sure you will be minifying it, otherwise you'll use a ton of memory. 

The ContentManager in XNA 4.0 only has one Unload() method that Unloads all Assets. I want to have some "global" Assets that are always loaded, but then I want per-Level Assets which should be Unloaded when the level is changed. Should I create a second Instance of the ContentManager as part of the Level.cs Class? Or should I use Game.Content and then call .Dispose on the Assets I load? Or should I create my own ContentManager on top of the ReadAsset function as outlined here? 

Your language looks like CSS, but it isn't. It's your own Domain Specific Language. Ask yourself this: Do you really want to create your own file format, for which you need to write a parser. This parser needs to be fast and robust. You also need to document your file format and teach people how it works - after all, it's a customized language. You then need to be aware that you may run into issues you never thought of - maybe someone thought it's a great idea to create a 50 MB file and your parser crashes, corrupting a savegame or so. Or you decide you need to add a feature that can only be implemented with a breaking syntax change, thus breaking all the existing files. The reason why formats like XML are so popular is because XML has these problems solved. You can find many great XML parsers that are proven to be robust, fast and leak-free. Also, many people know XML files and how to edit them, and because it's such a generic but well defined syntax you can be sure that you can extend later. Your motivation seems to be easy editing by hand, which is common in community SDKs. Now, the reason people edit those files by hand is that they don't have the tools the Game Devs use. You can assume that a company developing a game for several years has some graphical tools for editing such files - they may not be great and bugfree, but they edit the files for you and developers only rarely edit them by hand in order to tweak something. Those tools are rarely released in 'Modding SDKs', so most modders edit by hand. So my initial reaction would be: Instead of spending time developing a new, unproven format that is easy to edit by hand, I'd rather use a battle-proven format and spend the time writing tools that make editing easy. But blanket statements don't work like that. It always depends. If you spend 3 or more years writing a big game with a sizable dev team, then you can spend a lot of time developing, testing and finetuning your system. If you have 15000 files to parse, then finding ways to reduce memory usage becomes important. But for small/medium/indie games, I'd go with a known and well-supported format like XML and a nice tool to edit it. 

glBufferData reallocates the VBO in VRAM, use glBufferSubData when updating data. Generally each mesh has its own VBO(s); and own VAO if not batched. There are optimizations where you use a single VBO for all meshes with the same attribs, etc, but don't worry about that. The relation of these things is 

If you're worried about optimization then use vectors more, the optimizer may or may not do that for you. Avoid conditionals, all branches of them will be executed. But the major bottleneck on modern GPUs is from samplers, pow and log are pretty negligible. If possible then just use sRGB internalformat in your framebuffer, most gpus will do the conversion in hardware. 

You only truly need a separate class if you're multithreading, so you can have separate constructors, one ran in the render thread. Even then its up to you whether or not you want to do that. The big reason is just organization. More important than anything is to make sure your textures and render programs are static. You also want to render all of a single type of renderer at the same time to avoid render state changes, possibly even rendering everything of the same type in the same draw pass. 

I'm trying to figure out the basics of C64 game development past BASIC, and I could use some advice on something very basic, but important: What is all that stuff on the screen actually, and how to draw it? Take a look at Katakis/Denaris: 

The C64 only supports 8 sprites per horizontal scan line, so I don't think that everything in the middle of the screen can be a sprite? I would assume that anything requiring a collision would be a sprite (since I can get hardware collision detection with sprites), but even then I quickly hit the limit of 8 sprites. Also, my weapons can fire much more than one projectile - my ship, the satellite and 6 bullets would already be 8 sprites on a row (look at about 50 seconds into the video). Also, which graphics mode would a game like this use? The Programming Handbook lists Bit Map Mode which essentially modifies screen memory directly. Is this the mode I should usually be working in? How would I compose all the non-sprite elements together to get them on screen? A lot of the stuff in the score and status bar is static ("Area: 01" or the "frame"), so I guess I'll just populate them once when the level starts. Things that need updating - the score, the charge bars at the bottom - would be updated by filling the screen memory with black and then drawing the new score every frame? Or do I have to draw the entire screen on every frame?