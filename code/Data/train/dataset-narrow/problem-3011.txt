Java is close enough to C that transition to/from it is manageable, while being safer (no pointers) for people starting out. I also prefer a strongly typed language. I will offer the following anecdote: This year I gave an assignment to my students to write a simple program in assembly language just to have an awareness and appreciation of the differences between low and high level languages. (Print out a number being incremented by 1 in a loop starting from 1 and going to 10.) The code for this in assembly was over 130 lines of code, while the corresponding Java code was a few lines. This exercise was enough! to give them a deeper understanding of how a CPU executes code -- programming. They liked learning about how registers and memory locations are used by CPUs. They came away with an understanding that a variable is really a named location in memory. It should be noted that in some curricula students are expected to know the definition of high- and low- level languages with clear demarcation . 

Disclosure: I did variations of assignments 1, 2, and 3 for a data structures course I just finished teaching + made them multi-week partner projects. They went reasonably well, though #1 may have been a tad ambitious. 

Details: Changes in Java 10 The changes landed in Java 10 are comparatively smaller (which makes sense -- Java 9 was released about two years after Java 8; Java 10 was released about 6 months after Java 9). You can find a full list of changes at the following two documents: 

Firstly, I think CS degrees vary widely in how "theoretical" they are. Some try to teach you about programming languages and even vendor-specific products that you are likely to encounter in the real world; others focus much more on teaching the fundamental principles. Personally (as someone who has always worked in industry) I would much rather have people who know the principles and the theory, because that knowledge will remain useful for much longer. But whether your background is theoretical or practical, on your first real project there are going to be a dozen technologies or tools you have to master that you have never seen before. Secondly, I think CS (and even Software Engineering) courses find it very difficult to teach the things you will only encounter on large projects: how do you grapple with half-a-million lines of code, how do you work on a team with 40 developers? Then there are the non-computing aspects of the job. How do you handle a boss who has made an incorrect decision? How do you handle customers who try to make design decisions for you, and do it badly? How do you handle an experienced and respected senior developer on the team whose knowledge has actually become rather rusty? How do you manage conflicting demands on your time? One of the things that I think you can only learn with experience is to acquire a mature attitude to risk. Many of the decisions in programming are concerned with risk. Should we release now, or write more tests? Is it wise to use a new open-source library that has just become available? Should we move forward to the latest version of X? We know the customer's stated requirements, but how likely is it that they will change? How much should we invest in extra resilience or security? In the end, these are the judgements that make a project succeed or fail. 

I'm currently preparing to teach a course on data structures and algorithms. In my past experiences helping teach similar courses, I've noticed that many students find it challenging to "hold multiple layers of abstraction" in their head. This problem manifests in several different ways: 

I have no idea how effective these policies will be, though. I'd welcome both suggestions for encouraging pair programming in general as well as feedback on these specific ideas. Note that this is for a university-level class, and that due to time constraints, all homework needs to be done outside of the classroom (so I can't watch them pair program and offer suggestions or really enforce anything). 

I have also followed a similar path in learning. I am also often asked where to start. My response has been to start with a language like Java. This is for very practical reasons from an educator's as well as a student's perspective. 

Don't forget to mention what information is not available when they choose between certain looping constructs: foreach loops lose position data (index, relative locations (i and i-1, etc) for(int i;;) loops lose the index variable (i) upon completion of the for loop foreach loops are designed to work with collections & iterators. See Teaching the humble for loop Also from a AP CS A exam perspective, the trap is usually that you don't have an index value. The advice I give to the students taking this exam is to avoid the foreach when writing exams because in the majority of cases they will require the index. 

Version control isn't that challenging to learn (assuming you know how to use the command line). It's something you can trivially understand by following a few tutorials online -- I'd argue the hardest part is actually finding the right tutorial (there are tons of garbage "how to use Git" tutorials out there, and surprisingly few good ones, for example). Despite that, it can be hard to find time to fit in the command line and git. You'll probably need to spend at least 30 minutes talking about both things, and if you have a lot of material you need to cover, it can be hard to squeeze that in without compromising on something else. In particular, it's worth noting that you can't necessarily just add in new material somewhere and shift everything over. You need to make sure your change maintains the overall tempo of the course, make sure no topic "overlaps" oddly over a weekend or a holiday, need to make sure students are still being taught the material they need a sufficient amount of time before you make related HW due... If the original course was competently designed, it's probably a well-tuned engine where every minute matters, so adjusting it will require some degree of effort. If your university didn't find time to squeeze in version control, you'll be told to learn it on at least day 1 of your first internship or job. (And they'll probably do a better job of teaching it! It's hard to teach the value of things/give students the opportunity to practice things like branching, rebasing (if you're using git), using specific workflows, etc. in a university setting -- those sorts of more advanced operations are really only useful in larger teams working on a long-term project.) You mentioned that your intro course covered git on day 1. I can see an instructor considering against that approach if they want to prioritize moving to programming as soon as possible to try and "hook" the students in with instant gratification. (If you're completing new to programming, I can imagine learning to use tools like version control would be relatively dull and sort of a bother -- you don't really get to see the payoff until you start tackling more complex projects later on.) 

Some personal experience. I have a PhD in computer science and have had a very successful 40-year career in software development. But often, when presented with a new concept, I have had great difficulty "getting it". I think the problem happens when you build an incorrect mental model of what is going on. I think the first time this happened was on first introduction to algebra: with x=3 and y=4, I was convinced xy had to be 34. There's nothing stupid or ignorant about this, and it doesn't mean the pupil will never overcome it: there's just a misunderstanding that has crept in somewhere, and I think it can be very hard for a teacher to discover where that misunderstanding lies, and correct it, because the teacher simply doesn't realise where the faulty step in the reasoning occurs. Later, when introduced to programming, I remember I found it really hard to understand function calls. I don't know now what the problem was, just that I had great trouble with it. (I also found it hard to grasp that xy was no longer 34, or even 12, it was now completely unrelated to the values of x and y.) In recent years I've taught a good number of XSLT courses. One of the areas where I find students really struggling is with recursion. The main frustration in teaching this is that you don't know why students are finding it difficult. Sure, it's a very abstract concept but it becomes so second nature that you no longer see the difficulties, and that makes it hard to help the students overcome them. 

One idea might be to borrow SQL-related exercises -- find problems asking the reader to come up with some sort of SQL query to find information, and rephrase the problem and ask students to come up with an equivalent query using only Java's functional interface and lambda expressions. (I wouldn't bother telling students these questions were originally about SQL). Translating basic SELECT queries would be pretty straightforward, I imagine -- implementing things like JOIN or GROUPBY would be a little trickier, I imagine. (You can do join by doing something like and group-by using . The API isn't as elegant as it could be here, but I suppose that's Java for you.). You can make it even trickier by asking them to translate the equivalent of nested queries or asking them to extract information from multiple lists at once (e.g. multiple 'tables'), instead of just one. Stepping away from data manipulation, something else you could do is to introduce students to GUI frameworks or webserver backends or anything else that's event-driven -- event handlers are one example of a place where lambdas and method references shine. My last idea is a bit of a stretch, but you could perhaps ask students to invent (or use) a mini-DSL involving lambda expressions in some way. This would be a bit more involved -- the exercise would be less about using Java's already existing interface, and more about writing their own. (It's a shame that Java doesn't have anything like C#'s extension methods, otherwise this would be much easier since you can trivially augment the existing API, which can be pretty handy). If you need ideas for DSLs, you can maybe take inspiration from functional languages like Haskell and how they use higher-level constructs like monads and functors to build quite interesting abstractions and simplify things like error handling. I wouldn't use the word "monad" or "functor" at any point though, and you'll probably need to be careful to avoid accidentally making your exercise more about manipulating generics instead of lambdas. 

There are lots of great answers here. I am adding this answer to preserve it outside of a comment. If you are new and learning the course material yourself try to apply more structure to the content to assist yourself and your students. A good tool for this is to develop scaffolding for your exercises that your students work within. This will help contain the material and limit the types of issues that you will need to prepare for. I have seen that one of the biggest challenges for new CS teachers is "debugging" student code. This can be time intensive and distracting. Scaffolding can help immensely in this area. Another technique is working backward on an exercise. Provide answers that are flawed in some manner and have them correct them. This kind of backtracking can avoid the many paths students can take if they were to move forward through some material. 

Something I would also consider doing is motivating anonymous functions by introducing basic Linq before moving on to GUIs since it gives your students the opportunity to practice writing code that both creates and uses anonymous functions. That is, show students a for loop performing some mapping or filtering operation, teach them how to abstract that, then explain that C# already provides two methods that do this: and . You can then talk about how the and types and so forth work fine for many cases, but that sometimes you need more descriptive signatures (especially when doing things like GUI programming!). Enter delegates. This can feel a little backwards because you're presenting these language features in basically the opposite order they were added to C#, but the students don't have to know that.