For a great intro to Android, please consider Mark Murphy's books. He sells a subscription service for his basic Android book, advanced Android book, and tutorials. Mark updates his material with every Android release. He also hosts several chats per week for his subscribers. Mark's site is: $URL$ 

There are a number of algorithms and approaches for creating 3d contours you can find by searching for "3d contour algorithm". As written, your question gives us no information about the number of points you want to handle, about how frequently the contours need to change, or about how the user/app will interact with the contours once you've made them. Lacking those requirements, below is a quick-n-dirty heuristic you can use to make a "contour map": 

Here is a good article that lists several alternatives and pros-n-cons: $URL$ Also, you should read the comments for community "what worked, what didn't" kind of feedback. I've successfully used 99 Designs for my icons and graphics in the past. 

Since the game world is endless, I would chunk in up into regions. When the player moves close to the edge of the region in one direction, you can generate the objects in the next region in that direction. As the games runs, you can adjust the level play by controlling how many "good" and "bad" objects you place in the upcoming region to keep the player engaged. For example, if the player's "health" is slipping, you may want to adjust the number of "bad" object down or increase the number of "good" objects in the next region he encounters. David's answer is great for spawning objects. You may want to adjust it slightly so that you don't put your game objects too close together or too far apart. Instead of testing for intersection, just test a bigger area around the potential location. Consider having a few dozen or so predefined regions that are "fun" to play. 

You want to compute the convex hull of your point data: $URL$ I'd recommend the qhull software written in C: $URL$ Here is their licensing info: $URL$ 

Under this assumption, and that other non-slope tiles won't have strange variations, the simplest solution I can think of is the following. 

So if you use RGBA (8-bit per channel), you can use use each channel as a different layer, and up to 256 types of tiles for each of them. Would that be enough? Or for instance, one of the channels could hold the rotation for the tile like you mentioned. Besides, creating a level editor to work with this format should be pretty trivial too. And the best of all, you don't even need any custom content processor since you could just load it into XNA like any other Texture2D and read the pixels back in a loop. IIRC he used a pure red dot on the map to signal an enemy, and depending on the value of the alpha channel for that pixel it would determine the type of the enemy (e.g. an alpha value of 255 might be a bat while 254 would be a zombie or something else). Another idea would be to subdivide your game objects into those that are fixed in a grid, and those that can move "finely" between tiles. Keep the fixed tiles in the bitmap, and the dynamic objects in a list. There might even be a way to multiplex even more information into those 4 channels. If someone has any idea on this, let me know. :) 

But your character only had a limited set of points of contact. For instance in the article I remember there being only 3 pixels near sonic's head (one on the left of the sprite, one in the middle and one on the right) that would be used for collision detection when jumping, 3 pixels near sonic's feet to detect collisions with the floor, and 2 near the middle on each side to detect collisions with walls. I'll just do a quick mock up of what I recall. Something like (don't rely on the accuracy of my pixel placement, I just made them up): 

Not really. If you want the origin to be the center of the sprite, and since you're using source rectangles, your origin should be: 

There is a good and relevant article on Android.com : $URL$ This reference helps you sort through screen size, screen density, and resolution. The goal is to use the Android APIs to achieve "density independence" so that your user interface components and graphics can look good on various devices. Remember that you can also create different configurations of Android Virtual Devices for the emulator while you're testing layout and appearance: $URL$ 

Yes, yes, and yes. I work on embedded stuff during the day and games at night for fun. Your background can give you some advantages. For example, you're used to writing code that has to meet tight timing deadlines within very limited resources. Also, you should be able to pick up GPU programming, since you've worked with similar hardware. Good Luck! 

Are you using the Rect class? $URL$ If so, some simple comparisons will left you know which side collided... From the Rect class, you have attributes for the top (or North), the bottom (or South), the left (or West), and the right (or East). For example, this test will determine if rectB's left side crossed rectA's right side: 

I would recommend attending any game and/or mobile development meetups you can. There you will find more than a few folks that have the opposite situation...they understand the programming end of things, but can't wrap a story around their pixels. Talk with them (and listen!). In the meantime, develop a storyboard for a game. Start with your favorite genre (tower defense, 1st person shooter, whatever) and write a concise description of the world/environment, the characters and objects, and the game play. Think of this as your "elevator pitch", something that you can use to quickly show a developer in a 5 minute read what you are able to do. 

You can now add the GUI and/or game components to the frames you've created. This can be done either from Java code or in your XML layout (recommended). For an example of both ways, please see this tutorial: $URL$ 

In Android, anything you can do in XML layout file can be also be created via Java code. For example, instead of using the XML tags you could have your code that initializes the level create one: 

And I agree with it. Instead of drawing directly from the Gleed2D classes I think you should be using them as a bridge between the level editor and your classes. This gives you more flexibility in deciding exactly what to do with the data from your level. And that's really not hard to do, so I'll give you an example that I just wrote from memory (i.e. it's untested). But that's all it is - an example - and you should be writing something specific to your game. Usage Example I'll start at the end and show the interface I aimed for. This is the only thing you will need to do on your game for loading and rendering the level after you implement this: 

As you can see, I created a class called which took care of both loading and rendering of the scene, through the and methods respectively. But before going into the implementation of the class, I'll show another class that is required. The Sprite Class The first step I did was create a class which stores the texture and all properties that were relevant (in this case I settled for only the sprite's transformation, but you could store other properties too) and which knows how to itself using a SpriteBatch. Very straightforward implementation: 

Now, as I explained earlier the view matrix works by doing the opposite of the world matrix. Look at the image below and imagine that the red square outline is the camera. The job of the view matrix is to transformeverything so that the camera is placed at the origin, while maintaining all the relative proportions and positions between the camera and the world. The example shown is the correct transformation order for a view matrix. 

Using the usual (x,y) notation the answer would be (0,1) - the letter d can be found on the first column of the second row (remember, zero based indexes). But you could also index your matrix like this: 

Okay, I gave it a quick test run and it seems to be working on my end. Here's my solution. Imagine your entity has the following members, and you'd like to make the entity follow whatever path is currently set to the member variable: 

The Android Canvas drawBitmap method uses the matrix to transform the image as it is drawn. See this URL for the details: "$URL$ android.graphics.Matrix, android.graphics.Paint)" [sorry, the link is breaking at the commas, cut-n-paste url] There are several drawLine methods on the Canvas object, but none take a matrix as a parameter. See "$URL$ float, float, float, android.graphics.Paint)" [sorry, the link is breaking at the commas, cut-n-paste url] Your best bet is to use one of the Canvas's rotate, skew, and translate methods. See $URL$ 

Remember that rectB could collide with two sides. Image rect B's lower left hand corner crossing over rect A's upper right...rect B would've crossed over rectA's top and right edges. Remember that if rectB is completely inside rectA, that would look like it crossed over all four sides of rectA! 

I'd recommend running Doxygen: $URL$ Here is a list of the features: $URL$ Doxygen's uses the Graphviz tool kit to generate include dependency graphs, collaboration diagrams, call graphs, directory structure graphs, and graphical class hierarchy graphs. I find these types of diagrams helpful when trying to understand a large codebase. 

You can call the getDensity method on your Canvas. This will tell you what Android is doing. To test performance, I would try your app on a couple different phones. I'm in a Android development Meetup group, and we help each other out by testing apps on difference devices. If this isn't possible, you could setup different AVD targets with differing densities. While this won't show you the performance, it will tell you what Android is doing with densities. There is a good article on the Android developer site that talks about supporting multiple screen sizes & densities: $URL$ 

Have you tried initializing your std::vectors to a large size when the program starts up?? If the frame rate hiccup is related to a vector resize inside the game loop, this may help identify the issue. You could also log your vector size, calculated frame rate, and a time stamp to a ring buffer in memory as your program runs. The goal here is to see if there is something "magical" going on within your game loop when you detect the drop in frame rate. 

But I'm still not sure if this is the best way to implement it, or if I need to lock (not too used to multithreading). Can something go wrong with this / am I missing something? 

I would have stopped there since almost everything I needed was already working, except for one thing - calling and yielding on Unity3D coroutines deep from within the recursive interpreter. In order to solve that problem, I had to get rid of the recursion, and turned once again to the book. This time I ended up adding: 

Short Answer Look into depth peeling. From my research it seems to be the best alternative, although computationally expensive because it requires multiple rendering passes. Here's another more recent and faster implementation, also by NVIDIA. Long Answer That is a tough question. Most books I've read skim over the subject and leave it at: 

There's a way if you don't mind using a bit of reflection, but I'm not sure I'd recommend it, especially since the title mentions efficiency. But I'll describe it anyway. I'll assume there's a subset of keys you want to cover, and not the entire enumeration. If you want to cover every key, iterate directly over the enumeration values instead of using the array below: 

The library already has an example, but it uses and streams the audio. But I wanted to load it all at once into a regular object so the process was a bit different. Step 1 - Decode file First create an instance of and initialize it with your file: 

Details like that that are easily recognizable instantly give it away that you're just repeating the same tile. Check this article which has a lot of useful tips on the subject. In particular, using Photoshop: 

The Basic Framework Here's my solution to this common problem. First let's choose a name for an action that spans several frames, such as an animation. I'll call it a which is the terminlogy I found in this book, but don't mistake it with the processes on your OS, it's a different concept. In this context, a process is anything that needs to be updated, possibly several times, before it completes. I'll start by defining a base class for our process. Something as simple as this is enough (I kept the name as Process for consistency with the discussion above, but since .NET already has a class named like that, you might want to give it another name):