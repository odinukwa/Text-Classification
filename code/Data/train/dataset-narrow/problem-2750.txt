I am creating a game in Monogame (XNA extension). I draw to a render target to display menu items for my game. Everything works fine, however... Whenever I set the render target back to the back buffer of my graphics device 

it takes a long time (more than a second). This would be fine if I just needed my menu items at the beginning of the game. However if the game resets due to player input I have to re-initialize some of the menu items using the render target this lengthy process gets annoying. Before I try to debug this, has anyone else experienced time delay with setting the render target back to the graphics back buffer? It works just fine when I set the render target to a created render target. 

I'm a programming newbie. I have a Quadtree. I created a TreeNode class that the Quadtree will use as nodes. I have spriteNode that inherits from TreeNode. However, I also have several sprite types inheriting from a Sprite class that I use to instantiate specific sprites. When I am creating spriteNodes for example I have to cast each specific sprite type to it's parent Sprite class. When I put spriteNode into the quadtree I have to cast the spriteNode to be of type TreeNode so I can generalize the quadtree as much as possible to take different types of data. I'm not sure if this is a great way of storing all your sprite / map data inside a quadtree, because setting it up requires a lot of explicit casts (even though cast up a level are safe). Is my OO design approach to storing sprite / map data inside the quadtree the correct way to handle a large quadtree of data? Or is there a better, more standard way of doing things? 

Note: old android gpus don't support multi context. So the opengl context is lost when you switch to another application => no solution available (You can hack to preserve your context on screen pause). Note 2: HoneyComb function is setPreserveEGLContextOnPause 

Do you want to synchronize on vsync ? There are differents solutions depending on your platform. Search vsync on google. On directx, you can limit on fullscreen app with D3DPRESENT_INTERVAL_ONE or use WaitForVerticalBlank on windowed app. Look this article 

OGRE_NEW is just an overload of the operator new. Try to replace OGRE_NEW by the normal operator new. If it compiles, there is a problem in the declaration of OGRE_NEW. Otherwise, just find the problem and uses again the OGRE_NEW operator. Ps: if you use OGRE_NEW, you need to use OGRE_DELETE to remove your allocated object. 

Please remove the MipMapping flag for your texture... You need glGenerateMipmap because you use MipMapping and OpenGL need a smaller texture. On bad cards(INTEL), GenerateMipmap is a costly operation. This operation must be called one times. Add this instruction when you load your texture after glBindTexture : 

Edit: The OPs comment has been skeptical about the efficiency of the suggested negative circular bound check to improve the algorithm in order do checks whether an arbitrary 2D point lies within a rotated and/or moving rectangle. Fiddling around a bit on my 2D game engine (OpenGL/C++), I supplement my answer by providing a performance benchmark of my algorithm against the OPs current point-in-rectangle-check algorithms (and variations). I originally suggested to leave the algorithm in place (as it is nearly optimal), but simplify through mere game logic: (1) using a pre-processed circle around the original rectangle; (2) do a distance check and if the point lies within the given circle; (3) use the OPs or other any straightforward algorithm (I recommend the isLeft algorithm as provided in another answer). The logic behind my suggestion is that checking whether a point is within a circle is considerably more efficient than a boundary check of a rotated rectangle or any other polygon. My initial scenario for a benchmark test is to run a large number of appearing and disappearing dots (whose position changes in every game-loop) in a constrained space that will be filled with around 20 rotating/moving squares. I have published a video (youtube link) for illustration purposes. Notice the parameters: number of randomly appearing dots, number or rectangles. I will benchmark with the following parameters: OFF: Straightforward algorithm as provided by the OP without circle boundary negative checks ON: Using per-processed (boundary) circles around the rectangles as a first exclusion check ON + Stack: Creating circle boundaries at run-time within the loop on the stack ON + Square Distance: Using square distances as a further optimization to avoid taking the more expensive square root algorithm (Pieter Geerkens). Here is a summary of the various performances of different algorithms by showing the time it takes to iterate through the loop. 

Thanks to Adam and Sean for helping find the most likely cause of the slow load being large frame buffers and the regular buffer can't both sit in video memory, so when the buffers switch the large buffer probably has to be copied into main memory and the device back buffer copied from main memory back to video memory. 

That works just fine. Edit: I tried debugging this (C# is not my greatest language), and reached the line GL.BindFramebuffer( GLFramebuffer, this.glFramebuffer); inside ApplyRenderTargets inside GraphicDevice.cs of the Monogame Framework (Not my code). The delay is occuring when you are trying to bind a framebuffer to a specified frame buffer target inside the OpenTK library. Debugging further requires I get OpenTK. I have to go out right now, but when I get back I'm going to test this on an XNA project (I have tested this in another monogame project with the same results) and attempt to debug further. Edit 2: The problem Setting the Render target back to the device back buffer after drawing to a large render target ( 8000 X 8000 ) causes the delay. I don't know the reason why I thought the buffers just swapped out. Edit 3: I am going to have to look into how setting render targets actually works. For now the time delay is fine, since I will have loading screens / asynchronous loading as the player progresses in the game to deal with these delays. In the end the the render target swapping the render target from a very large one causes a small delay, this seems to be expected behaviour. Edit 4: Looking into a better solution than using a large render target. Edit 5: Check answer 

So, it is like a new platform; but, if you know Java, it is very easy to develop on Android. Download the SDK and try to play with provided samples and customize them. You can use good IDE as Eclipse and Idea (Android plugin will arrive in Idea 10 Community editions). For C/C++ geeks, you can use NDK (Native Development Kit) but you need some Java bootstrap code and JNI knowledge. 

I'm working on a game which can't run at Full speed on some devices. On Tegra2, with many optimizations, performance is near 40 fps. The framerate is stable but animations aren't smooth enough, so i need a vsync. With 2.3 Android SDK, we can use EGL library natively. So i try to use eglSwapInterval but no success. In this GDC Paper, it seems that Tegra2 can do it. Ps: Thread.sleep() to force a constant FPS is not an acceptable solution 

If your land is fixed and predetermined when your game starts, you could store all information on adjacent tiles for each tile in a vector (or better a vector of vector, such as in C++, during the game initialization stage and before your actual gameplay starts. The elements in the list contains information on all adjacent land tiles (e.g. for your 46th tile, the adjacent are 45, 47 etc.) Hence, you don't have to check the same thing over and over again in your gameloop. Secondly, store the size of each vector too in a vector for each tile during your initialization. Thus don't have to check how many there are adjacent tiles for each tile (e.g. by size()) within your gameloop when you iterate over your adjacent tiles, for example if you want to show where your characters can move to. 

You can use a static VBO to send these data one times. If you need advanced physics, this is probably not the solution and you must use the CPU. With Neon instructions, you can have a great speedup. Warning the Tegra2 (available on few android tablets) doesn't support this instructions set. 

For 3d physics, you can use 3D Physics Engines as Bullet, Newton or O.D.E. It is probably at first sight overhead... but you can use it for many great effects or add physic in your gameplay. You can use PAL to abstract the Physics Engine. 

Did you use my port of irrlicht for android ? For 2d sprites on Android and iphone, i use the same tricks as you: batching. I try many solutions in OpenGL ES 1.x and 2.x: 

One last word, if you are developing for mobile devices, keep you fragment very short and don't use branch. 

Where trend is a random number between - 4 and 4 that remains constant for, let's say, 50 iterations of i. You may wish also to have int(50/aPower) iterations and pow(trend, aPower), where aPower is a random number 1, 2 or 3 to have the mountains a bit less boring and occasionally very steep. And finally, you may play with going an iteration back for a few steps by a small random chance to have an overhang. 

I guess there are many feasible design approaches. For me what has worked best is that I created two classes: GameCamera and GameInit. GameInit holds all possible resolutions and is fairly technical, but passes the essential stuff, such as the best available screen resolution, monitor ratio etc. to the one and only instance of GameCamera. Now, you may now (perhaps rightly) say: "Are you kidding me?? GameCamera, a singleton?! Nope, I dare to say there are actually few things where a singletons can be useful, and that is if you know absolutely sure that you will not need a second instance of the class and you provide an additional 'initializer' and 'updater' functions for your game objects that will collect the essential global data from the singleton(s) (and where inheritance would be rather cumbersome to implement as you just don't want your bullet to be also camera or mouse...! To make things work, you gotta be careful though. I use in all my other classes two essential functions: Simplified that's which is called only once after all classes have been initialized, and which is naturally placed in the GameLoop. instantiates all the static global data for your object. In this function, you will instantiate your member data by copying all the essential stuff from GameCamera, e.g. etc. The advantage is that, (1) if you break my rule and dare to create a second instance of GameCamera, you could exceptionally help yourself by calling again the function or its overloaded instance where you only update the new camera stuff, without worrying that somewhere in line 14291 in your collision algorithm of your 12th .cpp file there is the need to find again the edge of the universe; (2) all access to this singleton and other global data is clean and tidy in that one function and thus easy to find/modify if you ever revisit your code. The other, copies all member data that is dynamic, such as, Zoom, Scroll etc. They get updated in the Gameloop, although GameCamera may return prematurely if there is nothing to update. Hence, your collision objects that bounce around access dynamic members of GameCamera through a pointer call in UpdateData() and update their own member data through that. For example, GameCamera holds stuff like Zoom(), ScrollEdge() etc., so the bullet's object own private member myZoom is updated when needed within . Note that there is no other call to GameCamera anywhere in my class, except by the power of those two functions--tame your singletons! However, I felt this is also not an ideal design when dealing with different resolutions on different computers when we have to deal with static "HUD" (head-up-design) objects like radars, message screen, messages etc. I thus added secondary screen-percentage units as a member function of GameCamera (going from 0 to 100) for positioning of HUDs. For example, I want a radar always to be on the top right corner (=90,90) and no matter the resolution of the screen. Now since the screen is probably more wide than high, x units are automatically adjusted by this ratio, but not the radar size (10 units) as it would appear stretched. Naturally, in my class, I have the aforementioned function that initalizes through that the necessary members, but no , as I do not need anything dynamic like Scroll, Zoom etc. from GameCamera. This ensured me that I have the same design and same game feel, no matter the prevailing screen resolution etc. I have faced no issues so far in terms game design (currently 35k lines code) and can reuse my code in other projects, as I just refurbish my UpdateData() and InitAllGlobalData() functions. But, to be honest with you, I have not plunged into networking yet, and Update() may need some additional thoughts when coming to synchronizing at runtime, but I will update this post once I get to that stage. 

This program draw a triangle with a smoothing of colors defined for each vertex. For a better tutorial, look this wonderful document. 

You can use OpenGL ES 2.0 simulator on windows to try your code. ARM (Windows) or Imagination (Linux & Windows). On OS X, you can use iPhone simulator. 

In the vertex shader, you can use Texture too. This is the "VTF" tricks. This is used in GPU Particle engine. Look this document: Nvidia VTF Introduction 

For beta test, you can host your own APK on your webserver. Just send an email to your users with the link. That's the eaysiest way todo. If you don't have a webserver, you can use Dropbox to host your APK and create a public url to download it. If you want a private beta, you can use Dropbox to share with your trusted users.