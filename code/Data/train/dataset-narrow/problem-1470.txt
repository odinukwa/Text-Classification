Here is another way of doing it. (I have omitted comments on your code because I have nothing to add to @Uri's excellent answer.) Code First define an class. This allows us to keep intervals as single objects in the main class, without having to fuss much with end points of intervals. 

I don't know if you really need to create classes for checking each of the substrings in the file name prefix. After all, there are only two types of checks that need to be made: against a list or matching a regex. Consider a simple, straighforward approach like this: 

See the doc for Enumerable#reduce (aka )1. When you are unsure what is happening with your (or someone else's) code, insert some statements. Here that might be as follows. 

As you have not indicated whether you are looking for a quick and dirty--possibly one-off--solution, or production code, and have said nothing of file size, I decided to suggest something you could employ for the former purpose, when the file is not humongous (because I read it all into a string): 

Again, this is pretty much self-documenting. Notice that I've written the argument as , rather than some variation of . That's because the method applies to natural numbers generally, even though we will only use it for triangle numbers. You could of course also write this as: 

Let's try it out. First, write some words to the dictionary file and to the file containing the prepositions: 

This module contains the validity checks that could not be done from the information in alone. The following is executed in the main class, when it is parsed: 

Another way uses the form of Hash#update (aka ) that uses a block to determine the values of keys that are present in both hashes being merged: 

The latter solution is relatively inefficient, as we make three passes through the unsorted list each time we move one or more values from the unsorted to the sorted list. That's mainly because I wanted to illustrate how the sort could be done without using indices. This is a sort of "fake" recursion, because it doesn't exploit the power of recursion; we could have simply put the code that transfers the in a loop. I don't see how recursion can be used to advantage here. 

Diagonal detail It's a small thing, but in you don't need to compute the diagonals of length less than four if only arrays of size four are to be considered. In fact, you should not, as it is conceivable that a diagonal of length less than four could have the greatest product! Revised class definition So this is what we now have (more or less): 

I suggest that you only introduce instance variables when you really need them. For this problem, I don't think you need any. This problem concerns natural numbers, so I think is enough. (Nobody will ask, "What if is negative, a float, a complex number or a Roman numeral"?) You could instead calculate each triangle number from the previous one, but this is a quick calculation relative to the other work that must be done, and stands alone, so I think that's fine. Calculate factors Next up, . You are doing that calculation in two steps, so again, keep the method short to give the reader the big picture: 

Edit: I've made some changes to try to improve the readability of my answer. You could just create a few simple helper methods. Here's an example, based on the assumption that ordering is not important. Rather than the usual approach of presenting the code and then showing how it is used, I have reversed those steps, as the code is so simple that most readers will be able to glean it merely from its application. There are two helper methods, and , The variables , and refer to "first name", "middle name" and "last name". The first, middle and last initials are: , and . The constants should be self-explanatory. (The application of the code is best appreciated when one of these is playing in the background.) Application 

Here's how the answers posted to date compare in execution speed. [Edit: I updated the results to include another method. The methods 

Explanation The problem is to determine the number of pairs whose difference equals . That is equivalent to asking for the number of elements that can be matched with a value that is larger in value by , such that no element is matched by more than one element that is smaller by . The first step in answering that question is to replace each element in the array with two elements, and , where indicates it's the original number and indicates it's the original number plus . We then group all elements on the first value in each 2-tuple. For above, this grouping for the number is as follows: 

where is one member of the hash and is another, but since we are sorting on the keys, and do not use the values and , we can replace the latter with underscores. We could have done this differently, using without a block, had we used instead of for the key for directories without trailing numbers, and chosen so that it was larger than any of the other keys. This is one way to do that: 

is the given positive integer. For any , the hash contains keys , where , being the minimum number of steps from to and being the previous number on the shortest path. initially has keys , then is added, then , and so on up to , at which point the shortest path to is available. The shortest path is determined in the code that precedes ; the remaining statements merely extract it from . 

so that this code needn't be changed if you rename the class. (Note that is the same as .) However, you don't need a class method to create the instance. Instead, just write: 

I have drawn attention to the fact that the argument was not used in this block calculation by replacing that variable with an underscore (which is indeed a variable). Some Rubiests might write instead. The remaining calculations are similar. 

Enter market on day 0 Suppose we entered the market at the beginning of the first day. Then what's the best day to cash out? Let's say day is the first day. We first compute: 

It remains to construct the method to return an array similar to above. As I've rambled on awhile, I'll leave it to others to cover that. 

This is a variant of @Flambino's second suggestion, which starts with an empty hash, to avoid the step of deleting keys whose values are zero. 

but that would be wasteful of CPU cycles. First observe that this array could be computed as follows: