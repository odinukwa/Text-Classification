This is obviously incomplete. The outer check is simple enough, it's whether is empty or not. If it's empty, nothing happens, if it's not, the inner check is on whether has a index, and if it's value is . If that's true, something happens, but who knows what? I'm assuming one of the things that would happen would be to set a proper value to . Anyways, if the check is false: 

for brevity, readability and to not have redundant checks. is not that expensive, still no point in calling it more times than necessary. I'd advice against having HTML in your classes, as you do in . Simplest solution would be to create an array of your database results, return the array and construct the table when it's absolutely necessary - at the script you actually show it. Moving on to , is called every time is called, and that's absolutely unnecessary. Not really an expensive database call, still redundant, you can safely move it into , it's a call that only needs be done once, just after you connect. In general, avoid functions, they are essentially obsolete, kept around only for legacy reasons. Their use is discouraged in the manual: 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

One immediate, fairly significant improvement that I see would be to calculate and outside of the loop in . This provided a 30%-50% reduction in time in my tests depending on the computer and Python version. 

I don't really understand what this function is doing, but it seems messy and could likely be improved. Then your function can be greatly simplified. 

This does not seem to be the intention of the code. Assuming you want to check all lines in either and you may want to use the following code: 

Here, the "inc" and "dec" operations were abstracted into a dictionary of . This is slightly more complicated than it needs to be (one could simply invert in the "dec" case and add the result to the register), but allows for other operations to be easily added. The end usage would look like: 

Or, as suggested in the other answer, test the number modulo 4 to figure out which path to take and avoid recursion all together. 

Finally, we want to create a decorator which will do the following things: (a) create all of the objects, (b) generate and enter the required contexts, and (c) execute the supplied function. 

We can't increment the because we can't decrement any of the 's. We can't increment the right-most 's because then decrementing the would lead to a number less than the original. Thus, we have to increment the first . We would reach the same conclusion if we considered the number instead. From this, we learn that trailing 's should be ignored. 

Well, more of a factory method now, which is silly. But not as silly as . If you absolutely need to keep the class's signature as it is, go for it. If not, a PDO wrapper would be the better approach. 

You need to add another css class to any of your paragraphs You need to change a css class to any of your paragraphs You need to convert a paragraph to anything else You need to change the text of a paragraph blah blah blah (there are a lot of other likely scenarios, but I think the first 4 are enough to illustrate my point) 

The clause is very similar to the one discussed previously, only this time other than checking if has a index, the author also checks that the value is larger than zero. That's an unsafe check, because at this point we don't now what the type of the value in is, and if it's anything other than a number, there will be automatic type juggling involved, and the check is completely unreliable. From the name and context, I'm assuming the variable should hold an integer (if anything) that limits the search. If the variable doesn't hold anything, the limit is set to zero (), curiously using a string form of zero. I'd rewrite that check as: 

With this one change, you've gotten rid of half of your code and now can work with five-grams, six-grams, and so on. Making some small other changes, many of which are noted above, cleans up the code pretty well. 

I don't see why you want/need three functions to download the different quality videos. There is a bunch of repeated logic both in the functions and in the main loop. Then, I would move all of the specific code into the section because that's the purpose of that section. 

Per Graipher's answer, I extended the chance of victory to accept an arbitrary number of regions and number of wins required. 

Note that this creates a new list object rather than altering the original word list in place. Your current code isn't terribly inefficient â€“ it iterates over the list twice rather than once, but both are asymptotically linear. If you were to keep that structure, there are a number of small things that could be done to make the code more Pythonic. Compare the following loops to your own code: 

I echo both of the previous reviewer's sentiments, but I'd also like to add that regex is overkill for the parsing here - will work just fine. Implementing this and some of the other suggestions might produce code like: 

at the top of your (external) script, and then use instead. Do it for all your objects, even if you're using them once, it will stay with you as a (good) habit. Avoid inline CSS Consider moving all your style declarations into an external CSS file. Other than a slight performance gain (similar to external JavaScript), you'll have all your style declarations in one, easy to find, place. 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

Your code is just fine, exactly how I would do it. There isn't much to discuss really, it's kind of simple. It's as effective / efficient as it could be, and fairly readable. 

To address the recursion depth error, you could either change , or you could rewrite your initial solution to use as an argument to avoid the global variable. 

Notice that this isn't contained within a because there isn't really a need for one; a method does the job better. Also, I made some (bad) changes to make the algorithm less readable. This new regular expression counts the number of 's that occur successively starting from the second-to-last digit backwards and replaces the old loop, the at the end absorbs the original . Now, if we really want to make things unreadable... 

Sure, you could remove the global variable by moving the memoization to a decorator and adding a base case scenario to the function. 

The code itself is rather concise, but the weird data-flow out of the function makes it difficult to understand what's going on. This is complicated because the function is recursive and so you then have to keep track of the calling stack when figuring out how is being changed. I don't think the module is really necessary here, I bet that it is heavier that just searching for strings and doesn't seem to offer any benefit. I've kept it for now, but I might offer another solution without it. Here's how I would approach the problem: 

The first clause, essentially checks if there's an "old_keyword" index in the array (and whether it's or not), that's a pretty typical check for arrays. The second check, that executes if and only if the first one passes, checks whether what's in is not the same as what's in . I'm assuming that the author had some reason for that, but can't imagine what that reason is. Summarizing what happens here, if: 

This is my first foray into the wild world of jQuery plugin development. The plugin "ajaxifies" forms, which isn't particularly spectacular: 

Everything seems to be working as expected (repo, with a simple demo). Since this is my first plugin, I'd be particularly interested in critiques of its structure. That said, as always in reviews, any aspect of the code is fair game for criticism. The plugin code: 

and avoid the costly call to . And do return something, tell the user if the operation succeeded or not, regardless of what the Java interface does. 

I would suggest returning instead of when element not found. It feels a little more natural and expected. 

As this is a learning experience, you should be concentrating on learning the language and its quirks. Java <> PHP, in quite a few ways. You shouldn't limit yourself in copying the Java interface, it's a good interface to clone but now that you've done that you should explore enhancing it with native PHP functionality. You should take as much advantage of native stuff as possible, the performance difference is noticeable. I have to admit that the ArrayObject was an off hand example, my primary intention was to point you towards the SPL. I did base something similar on an ArrayObject, but the requirements weren't exactly the same. Still bits and pieces of your code could be rewritten to take advantage of native functionality. For example, this: 

First, note that this is all untested, but the ideas should hold up. I tried to abstract a lot of the logic by distilling the object creation to a dictionary containing the data, but it turned into a bit of a mess. To start with, consider the following structure for your object data: 

I'm going to expound on this answer later (when I'm on my Python 3 machine). To begin with, there's a lot of repeated logic, especially in the , , ... methods. You can avoid this with a class method to generate these instance methods. 

Now you don't have to register each effect in your dictionary after the function declaration and this should clean things up a little. Additionally, if you import this object, you can add functions anywhere, easily see what effects are registered, and you can add logic to the class itself if you want more complex behavior (i.e. address the case where an invalid string is entered). 

We can't increment the because decrementing any other number would result in a number that is less than the original. We can increment the , because we can then decrement the . From this, we learn that the right-most digit should not be incremented.