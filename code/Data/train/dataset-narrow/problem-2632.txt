Here's the relevant logic I used on the pong on my homepage: (please go play it before reading, so that you know the effect I'm achieving with the following code) Essentially, when the ball collides with the paddle, its direction is completely disregarded; it is given a new direction according to how far from the center of the paddle it collided. If the ball hits the paddle right in the center, it is sent away exactly horizontal; if it hits right on the edge, it flies off at an extreme angle (75 degrees). And it always travels at a constant speed. 

The genre that the entire game industry seems to be most "atwitter" over is the casual games market. I think it's largely due to the success of games like Bejeweled and Peggle, combined with all the Facebook games and recognizing that the audience of Facebook games are people with a lot of time on their hands but very little desire to play a typical hard core or skills-based game. If you acknowledge that the casual games genre is the popular one today, then it follows that "today's target platform" is the browser. Flash is still extremely popular, Java applets not so much, and some Facebook games can be simple HTML. Browser games are typically the most compatible and require zero installation for users (given the user has the Flash plugin in the case of Flash games). They're not terribly difficult to write from a game developer's standpoint, since you can often avoid the game loop (especially, again, in the casual game genre) and simply respond to user input, like a traditional business app. And with upcoming technologies like HTML5 and WebGL, they can still have decent graphics and other capabilities. 

Irrlicht provides a bit more than Ogre3D, and at the same time is a bit more hands-on (e.g. it doesn't feel like you're just "starting an engine" and watching it run, it feels more like you're the one running commands, as it should be in my opinion). I think it would be great to start with! 

That absolutely makes sense. You should not have any constant path in the string you pass to your Get function, or else it ties you down later. For example, if you decide to package your assets into some sort of compressed/encrypted archive, you would then be locked down to create an useless Media folder in the archive and then put all the assets inside it, when really the archive itself is something of a Media folder. Your resource manager should know where to go to find the resources, whether it's the file system, an abstraction (archive), perhaps a distributed file system, or even the network or internet. I personally also think might be redundant; doesn't the "ogg" extension establish it as a sound? Again, if this is the case, you could just use and the resource manager could look at the extension and know to go into the Sounds folder. But it's totally up to you. 

In order to set up continuous integration (e.g. CruiseControl.NET) with a project, you need to be able to build the project from the command line. From this page: 

That would make the WebView the entirety of the screen; then you would just need a loading message. Or a better option is to load HTML in the WebView so that the app can be used offline; examples of this are on the API page for WebView. 

Of course! Java has a built in Java 2D library which requires no OpenGL or DirectX knowledge, and I highly recommend starting with it! In fact, it has pretty okay performance. The essential starting point is to define your own class which extends Frame (or Applet), and then override the method and use to draw to the screen. 

You need to use a Stencil Buffer. This is specified by passing a DepthStencilState into your SpriteBatch.Begin method call. 

You could issue multiple requests, but you certainly can't keep up 30 HTTP requests per second (unless you were operating in a LAN environment), nor should you, because the overhead would be ridiculous. So then you could look into something like WebSockets or Flash sockets or long polling to stream those frames. But then that begs the question, why are you doing the 3D rendering on the server? Essentially it would be an exercise in futility, or purely academic, or useful for a dynamically-rendered web adventure game. So yes, it does seem like a ridiculous question, but the answer is yes, you can "port/rewrite/whatever" a graphics engine to run in any language. 3D graphics is just math, it's matrices and vectors and... well, at its essence, that's about it. But realtime 3D graphics will not be possible in pure Ruby in Rails without the assistance of something client-side like WebGL. And you would certainly want realtime 3D graphics for a first-person shooter. 

Here's a slightly different take on the matter: Of the users who would bother to crack your game's data format or decompile it and change it, how many do you think are actually willing to pay for these things? In other words, if these users were to try and fail to cheat your game, do you think they would then give up and pay you money for the items? Furthermore, are these people going to influence other users elsewhere? If this is a game where users interact with each other (e.g. a MMO), and these paid items give users an advantage over other users, then the items, purchases, and player interactions need to be tracked on your server, so that your server can verify all interactions involving items, that the items were paid for and not yet used. The client side cannot be trusted; there's no way to definitively prevent hacking. If this is not the case (e.g. Temple Run), why waste your effort trying to stop users who probably wouldn't pay you anyway, and who aren't affecting other paying users? 

Or you could always take a spare computer and run an emulator (ZSNES or Snes9x) on it, and then get a USB SNES controller or a USB SNES controller adapter (plugs into USB and has 2 plugs for any SNES controllers). If you have a Game Boy or Nintendo DS, there are a number of homebrew cartridges that will play SNES games as well. I have been extremely pleased with my recent purchase of a DSTWO as recommended by Lifehacker, and the Nintendo DS gamepad layout is extremely similar to that of the SNES so it hardly takes away from the feel of playing the games. Remember of course that it's only legal to play ROMs of games that you own. 

MAME is exactly what you describe for arcade games. I haven't seen a general-purpose one though; Steam and OnLive are the closest things I can think of, if you were to maximize them on the screen and somehow restrict the player from closing them, not to mention keep the player from tampering with your account and so on. 

They are typically called mobile games, which covers a game that runs on a mobile device. This is distinct from console games (Xbox, Wii,...) and PC games. In addition, most mobile games (but not all of them!) are casual games. 

The Journal of Game Development was established in 2003. It's hard to find any information about the issues but at four issues per year, I estimate the last issue was distributed sometime in 2005 or 2006. It had a good editorial board of college professors and a founding editor from Ubisoft. The list of articles looks good. The price was reasonable. So what happened to it? Its website recently went down but you can see the last Archive.org version. The editor-in-chief is a professor at my school so I intend to ask him in person in a week or two, but I thought I'd see what you might be able to dig up about it first. Of course I will be sure to add an answer with his official word on the matter at that time. 

I highly recommend taking this approach. However, it would also require a different server technology; which is a good thing, but it is a change and depending on how advanced your server is, that could mean a lot of lost time... Oh, and there's also WebSockets coming soon. So if you use one of the above libraries and adapt your server to use socket communication, then you can just swap in WebSockets as it becomes more accepted! 

A top-down space shooter like Galaga is pretty easy and teaches collision detection fairly well! It can also vary in difficulty, from a level with stationary enemies, to multiple levels which weapon upgrades and enemies that move in special patterns. 

Your images still need to go in the Content folder of your content project; and they have the same names as images in your GameState project, so I presume there will be a conflict there and you'll need to remove or rename one set of the images. I don't think you need to modify Content.RootDirectory, but you do need to make sure your GameState project references your GameStateContent project. Instructions here. If I may ask, why do you need the separate content project? 

Make sure you actually need a sophisticated GUI system for your game. If you're making a computer RPG then obviously it will be a requirement; but for something like a racing game, don't overcomplicate things. Sometimes just rendering textures (custom button images) and having some "if" statements with hard-coded coordinates in your input function can get the job done. A game state machine (FSM) helps with this simple approach. Or, somewhere in the middle, forget the complicated hierarchy and scene graph approach and just have a "Button" class which packages the above-mentioned texture and input checks into simple function calls, but doesn't do anything complicated. Nailing down your requirements is important. If you're unsure, just remind yourself YAGNI. 

Again, that might not be exactly correct ActionScript, but that's the general code for what you seem to be asking for... 

Once a game is ready to be released (either final or a beta), or it is noticeably slow, that's probably the best time to profile your app. Of course, you can always run the profiler at any point; but yes, premature optimization is the root of all evil. Unfounded optimization, too; you need actual data to show that some code is slow, before you should go try to "optimize" it. A profiler does that for you. If you don't know about a profiler, learn it! Here's a good blog post demonstrating the usefulness of a profiler. 

I believe you're mistaken; Vector2 and Vector3 both have extensive functionality. Note that this functionality is exposed as static methods to the Vector2/Vector3 class, rather than of the form . So for example, for the dot product of two s, you simply write . In addition, the same set of methods has existed since XNA 2.0, so I'm certain we are not talking about different versions. Here is the list of Vector2 Members and Vector3 Members from Microsoft. The pages default to the latest XNA version, but you can view prior versions by clicking on the "Other Versions" dropdown at the top of the page, right under the title. You will see, though, that the class does not implement rotation and projection. Of course, the projection operation is simply so you can write a small function for that if you use it often. For rotation, you should make use of Vector2.Transform and feed it a rotation matrix; I definitely recommend writing a function for that. Overall, I recommend using the built-in Vector2 class, and I think you'll find it suits most of your needs. The rest, like I said, are very short functions which you can port. But no need to duplicate the entire class, right? But if you feel the need to rewrite it, I don't see a strong reason why you shouldn't, as I can't see how XNA may somehow implement it better than you can. 

You should definitely implement it as either a Finite-state machine (FSM) or a Stack of states (sub-menus), depending on the exact requirements. Whichever sub-menu is the current one in the FSM or the top one on the stack, draws to the screen and handles input. And then when it detects the user clicks a button, it switches the FSM or pushes onto the stack the correct state to go to that next screen. In your case I'm thinking a Stack is best, but if you had a more complex menu system that jumped around menus arbitrarily then you'd want to use a FSM.