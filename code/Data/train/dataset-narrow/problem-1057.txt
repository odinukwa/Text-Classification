OK, these two vectors (along with the count variables) are used to implement stacks. Here's the thing though, why not just make them ? You can even have the stack implementation use as the storage medium. That way, you don't have to worry about managing the stack variables as you do here. 

The makes it clearer that all the cases are based on the value of . An / is more flexible. Final Version 

You aren't setting neighbors. You're just adding one. You don't need to use here. You only need it when you want to disambiguate the object field from another variable. That's not the case here. 

The first insight is that you want to swap the visibility settings for and . So use the normal swap format with a variable. The second insight is that your image paths have the same start for both cases of each image. So the beginning can be a constant value for each image. The third insight is that your image paths have the same ending for all images in a particular case. So based on the value of (arbitrarily chosen as the shortest variable name), change the ending. I also normalized the indentation. It was inconsistent in your original functions. 

You don't need a in the last clause. You can just let it fall through after a clause. Factory Method You have this tagged factory-method, but you aren't using a factory method. The factory method is when you have a method that can return different results depending on the exact class of the object. So you might have 

Which of course is the answer. Some of the other answers may have written the code to generate this list in general (i.e. for values other than 20). They don't seem to have commented the code in a way that's making it clear to me what they're doing. 

This makes a more regular use of move semantics. If there is an assignment function that uses move semantics, this will just work. We also enjoy the speed advantages of working with a reference when dealing with the recursive function. We don't have to worry if move semantics get used or not, as our function always passes a reference. We don't force the caller to use , which is more commonly used with an assignment or copy constructor. At the same time, I added the starting row and column numbers back. I don't think that the code will work without them. It looks like they got lost in an edit. Recursion The normal advantage of using recursion is that it allows for a more elegant solution. However, in this case, I don't think that it does. Your iterative solution traversed the grid smoothly and understandably. The recursive solution is more complex, as you have to transform the grid into a one dimensional object. It's also problematic in that the caller has to understand more than it should about what's happening internally. It has to call and add the initial row and column numbers. You can sort of fix this by providing two functions. The first function for use by the caller. The first function then calls the second function with the right arguments for the recursion. The second function does the actual work. Note that it makes sense for the second function to use references. The first function could pass by value. Calling with would trigger move semantics on the copy constructor. The problem with recursion is that it works by making use of the stack. For each function call, you have to push the current state onto the stack. However, most of the state doesn't change from call to call, so saving it is redundant. Further, since this is tail recursion, we're done with the current state by the time that we save it. A good compiler will optimize this out, but why not go ahead and do it yourself? Rather than relying on the compiler to fix things, just write the iterative version. Tail recursion will have a natural transformation into an iterative solution. In this case, we can do even better. The recursive solution maps the grid into a vector. An iterative solution can work with a grid directly. 

The entire / structure is unnecessary. The expression in the returns a Boolean value, so pass it directly. You don't even need the intermediate variable, although it does make the logic a little clearer. Second, this doesn't track properly. You set it to in both cases even though it should be in the first case. If you're not going to use it, you might as well get rid of it. Third, why create an empty list and pass it to the constructor? It's a constructor. Make it create its own list. 

This is a little harder to follow but it now makes it if . Another way to put this is that it is now in the opposite direction. 

Also, I find an unclear name, so I switched to which I find clearer. I switched from to as you are building a string. We could just as easily be working with the letters of the alphabet as with numeric digits. 

And you should be aware that when you specify , you are repeating the query once for each value. So this query would run six times. You may find it easier to run the six queries on the PHP side, as they'll be smaller. This can also help your programming logic. You might want to look up plans, as they should help hint at what your problems are. You might consider posting your SQL and explain plan to Stack Overflow (hint, just add before the and look at the results in an admin tool like phpMySQL). It's possible that the thing to do is to replace your column with a column and a column. Then your join would be on a fast integer join and you could do a straightforward date check. Rather than doing a , you might be better off with a regular inner join. Then look for missing times in PHP. Outer joins (left and right) are much slower than properly indexed inner joins. You may find it easier to look for the missing times in PHP than to have your database do it. I find it questionable to read all the data in and then use it. It's often better to read the data and then use it immediately. 

If I understand that correctly, the line is a comment. Then you have a loop from to where you assign all but the last entry of . After the loop finishes, you assign the last entry of output. The downside of this approach is that you have to sum up and divide the array for every entry. I think it would be better to do the end first and keep a running sum. I'm not sure of syntax, but I would expect that to look something like 

Note that I'm writing out rather than abbreviating it as . The fraction of the second that it saves when reading will outweigh the fraction of a second longer that it takes to type it. Not necessarily today, but six months from now, you'll need to spend a moment remembering what means. And of course anyone else who reads it has figure it out immediately. Useful code is read more than it is written, so it makes sense to optimize for the common case. StringBuilder 

This saves you an entire sort and a lot of swapping. Constant memory You can do it without the extra , but it requires more calculations to get the indexes right. 

Of course, if you do that, you need to mark as throwing an exception as well. I tried storing the dictionary in a trie, but it was slower and took more memory than your solution. 

Elsewhere you use snake_case names. If you did that here, you'd have . I'm assuming that you removed the read email address for privacy reasons. 

Note that the prior checks (as shown in Tim's answer) ensure that the list is at least of size 2 and that you aren't removing either the head or the tail. The start and end conditions ensure that you only remove things between the head and the tail. 

Now each is guaranteed to be set, so we only do this check once per category not once per product. Note that we may not need to do the check. if we know that is not set until we do this, we can just do the assignment. Currently we check that a given category exists before assigning. If this will always be true, then we can remove the check and just assign: 

This checks if the character at position in the string has a closing match (i.e. is a key in the array). If so, then you know that it is an opening brace and add it to the list of things that you need to match. If not, it checks if has an opening match (i.e. if it is a key in the array). If so, then it checks to see if it matches the most recent unmatched open brace. If not, then it returns to indicate that the string does not consist of matching braces. The final case is if the character has no closing match nor opening match defined in the arrays. In that case, it's not a brace. Since the string is supposed to consist entirely of braces, it throws the exception. We don't have to check anything in this case because we already did the checks earlier in the and clauses. If you are only adding one element to the end of an array, the operator is more efficient than an . I changed the order of the checks to avoid repeating them. The other way you did two or three checks on a valid case and two on an invalid case. This way, you do one or two on a valid case and two on an invalid case. Hopefully the valid cases are more common. Note that I haven't tried to run or test this code. 

There's a significant security issue in this code. Note that you are getting the player ID from user input. What if player 100 submits a bid for player 200? This might be safe ( is forced to be an int previously) but is definitely squirrelly: 

It's generally easier to follow if either both the and the clauses use or neither do. So change this to 

That way you don't have to generate all the tiles each time and ignore half of them (on average). Also, if is the empty space, this doesn't bother generating values of since all values of won't be checked. I changed to because I name scalar variables with singular names and collections with plural names. An is a scalar, so I wouldn't give it a plural name. 

I also changed it to only calculate the radian version of once rather than twice. I also created another version that loops in radians rather than degrees. 

You don't want to add the same head section to every file. You should have the ability to (for example) add more CSS or Javascript to a specific page. You also may want to add meta tags, etc. to your pages. At minimum, you probably want to add a title to your page, which should be different on each page. All that said, no, you are not creating your common code correctly. Your core.php file does two things. One, it creates output. Two, it defines things like classes. You should pick one task for it. Either create HTML output or define functions/classes for later use. As a general rule, the function and class definitions should occur before you produce any output. Output should be close to the last thing you do. This allows you to do things like redirect to a different page. Your code would complain that you already produced output if you did that. Your section is also missing code. Prior to creating your section, you should have a and an tag. Here's the code from this page: 

What's an odNumber? Unless odNumber means something, you might as well call it n. If odNumber does mean something, you should tell me so that I know it too. If odNumber isn't a standard name, then I'd much prefer it was written out. Why write out number which should be obvious from the type and leave od obscured? Similarly, do k, h, k_inv, h_inv, and f have meaning? I'd have trouble editing that code, as I have no idea what each of those means. I sort of think that k and k_inv have something to do with each other, but no idea what. Also, why are most of them arrays? This should be understandable from the code, and it isn't here. Your constants are named K0, H1, etc. Why not give these more meaningful names rather than just 0, 1, 2, 3? Of course, this could also argue in favor of moving these out of code entirely. If position is all that separates them, why give them names at all? You're repeating the exact same calibratedValues and overwriting previous values. 

My first comment is that is a weak name for a function. Almost all functions could be said to be processing their parameters. A more descriptive name would make it easier to see what the function is doing. 

What do you plan to do if a class doesn't grade like this? I've had classes where each assignment, test, and quiz had its own weight. Are you just going to make each its own category? Note that you'll have to calculate the percentages prior to entering the data here. Unfortunately, not every professor will return grades in the form of percentages. If I had this as a task, I think that I'd just use a spreadsheet for it. A spreadsheet already has the relevant computing capacity and is very flexible in the face of arbitrary rules. It also supports saving, which this program doesn't. You'll have to enter the categories and such every time you use the program. With a spreadsheet, you'd save and would just need to update as grades arrive. All that said, for learning purposes, I'm going to go over the code that you have. 

I'd write out and . Also, you don't need the . You immediately use string concatenation on it, which will throw it back into strings. So the only thing that the intval can do is hide bad input from you. 

You know that the user has a score, because you found it in the first query. Therefore, you don't need a . A regular is fine and will be considerably faster. 

The last two statements appear in all nine branches that do not , but we now we do them only once. If I counted properly, this replaces twenty-two statements with eight. 

I'd add a default case. This makes it easier A better solution might be to store both entries in a database table that maps between them. Then you can just add new rows in the database when you add a new language with highlighting. 

Separating statements into groups with whitespace can make it easier to see what goes with what. The first time that I read this, I didn't understand that the function relied on being set. Refactoring so that that is a static class function rather than an object function would allow for it to be externally called without an object. More importantly, we now call it which makes it obvious what it requires. I changed the name from to to indicate that it returns a boolean value. 

You can avoid unnecessary nesting by returning on an error rather than putting the whole function body inside an / block. Because of the , the rest of the function is implicitly an , but you don't have to write that out now.