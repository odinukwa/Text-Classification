...and a simple wrapper for calling it with string input instead of array input - note that this isn't unicode aware. 

The other answers hint around the performance, but I'll just come right out and say it. Your should really be named the . First, every single call that makes is late bound - even for Excel objects. It has to be, because like , it is forced to call on itself. This is always slower than an early bound call - period, end of discussion. 

That is just all kinds of wrong (and it would look even more wrong if you explicitly declared the return type as the that it is). First, your backing field type doesn't match the publicly declared type. Second, you're using a as if it was a . And third, there is no reason for the backing field to be a . The only place where it is used is in the property, so that means you're continually coercing it back and forth, but never use it as a . It also leads to code like this... 

The code above sidesteps the next huge performance hit in your loop, but you should be caching values for procedure calls that will always return the same result. In the quoted statement at the start of the answer, you call 3 times and 3 times. They'll always return the same thing, so put them in a local variable to avoid the repeated calls (note that in this case, Raystafarian's solution is doing the same thing, but on a much more "global" scale - it reduces all the calls to just one). 

And as promised, here is the link to the repository, which also contains formatted documentation on the respective github pages, and a full demo on Heroku. Please be responsible and only make HTTP requests to the Heroku link sparingly, as I have it hosted on a hobbyist plan, which only allows so many hours of uptime a month. I have plans to implement a service worker for it in the future to mitigate this issue. 

While this is a relatively simplistic and deceivingly elegant implementation, insertusernamehere's solution is admittedly an order of magnitude faster, when using an array as a perfect hash table for non-negative integers instead. 

If you are at all familiar with using promises, then you'll recognize this pattern. While it is typically considered an anti-pattern, this particular implementation is written properly, and is also necessary in this case to take advantage of a convenient implicit race-condition behavior of promises that I'll explain in a moment. 

Here, we are mimicking the signature of the native API, which has one required argument and one optional argument. We simply expect a property to optionally exist on within this wrapper function. 

Inside the callback, we're rejecting the constructed promise with a , but keep in mind, if the function has already invoked or in its , this call is essentially a noop because the constructed promise has already locked into its state and cannot be "settled" again. Because of this, it is unnecessary to assign a reference to the timeout and call if those occur first. Conclusion If you've read this far, you've probably realized by now that the suggested code is compact because it takes advantage of a thorough understanding of the promise specification, and is able to safely make assumptions that keeps the code DRY. 

OK, went through the code and gave this a bit of thought over the past couple of days. As far as the implementation goes, I don't see a whole lot that I would change (that you didn't identify in the answer above) other than a couple nit-picky things. First, is the use of the variable identifier. I couldn't find anything that justifies the naming and data structure other than imitating a .NET keyword. The keyword (as ridiculous as it sounds after writing C# for a while) is obvious to a VB6 programmer - is not. I would personally stick with individual member variables instead of the , but if using the I would name it something like . The fact that you were compelled to explain in the post what refers to in the class is a red flag because it isn't immediately obvious. The second nit-pick is also related to using .NET metaphors that do not directly map to a VB6 context, but this one comes from the opposite direction (and falls into the "errors being raised" category). A .NET programmer will expect assignments that are not type-safe to fail at compile time, not runtime. For example, this snippet in VB6 compiles and runs without complaint: 

The identifier is a bit confusing at first glance, as is . I realize that they're just loop counters\temp value holders, but the comments that explain that are a long trip with the mouse wheel up to the top of the procedure. If you want to use a short throw-away loop counter, I'd suggest using instead - it's pretty generally recognized as shorthand for "index". There's also nothing wrong with something explicit as to what it is like or . 

You can write concise code without using cryptic variable names. Change to something more meaningful like or even just . One way to resolve pyramid code is to look for places where your logic can be decoupled or flattened. While it's possible to continue to use the dependency in order to achieve this, it's probably much easier to just use since you're already using promises anyway. This will also give you an opportunity to get rid of your global variable : 

I'd appreciate any feedback on improving perceived responsiveness for the feature this UserScript adds to the webpage. I realize changing the URL after a slow image load within might make the URL change seem slow, but I also noticed that when calling or within a listener to or events, it appeared to cause the fusion image to load significantly slower. Though this UserScript still functioned properly either way, I'm curious if anyone can come up with an approach that improves responsiveness overall. 

One of the things in this rewrite to flatten your pyramid code, I changed the order in which is called, because the way your code accessed the property relied on the usage of a proxy get trap in order to work properly, which is both unnecessary and inefficient. Lastly, I cleaned up your generated text to break it up into a few lines, otherwise it's quite unreadable. You might consider storing that text to an external template file using a minimal template engine (possibly written yourself just for this specific case) in order to avoid hard-coding it in here. 

The purpose of this is to have the name of the function in the stack trace in case of an error. Otherwise, the function will be identified as anonymous. Here's another example. 

You could use sinon.js to have the power of spies, stubs and mocks. $URL$ That way you could create a stub of . Look for . Edit I added a code example. I did not fully tested the code, but it's how it would look like. 

When using callbacks, the first parameter is the error. So instead of throwing the error, you should pass it as the first argument. The signature of the callback should look like this . So instead of this 

The idea of a class in python is to keep track of a state. Your OnField class does nothing else than appending and removing players from (which is outside the class). Therefor, and could be defined outside the class. 

Here you know by its name. Therefor you don't need a comment block. This block code block doesn't respect the single responsibility principle but principles are meant to be broken. A 2 lines function doesn't need to be splitted. I would also allow some duplication in the signature. 

Then it should become pretty easy to test. As a bonus, you can have a look at $URL$ It's a good module for mocks, stubs and spies. Also, I realized that you are doing a synchronous for loop calling asynchronous functions. will never do what you are expected. does not return anything. You should expect it in a callback. If you want a tip to handle the flow properly, use $URL$ With this module, you will stay away of the mythical "callback-hell". Enjoy, node.js! 

Much better to just calculate the result, especially if this is being looped over in the calling code. You tend to see code like the sample you posted when people are afraid to work with dates. The calculation involved isn't that hard. You first figure out the payee's birthday for the given age and find the following [insert financial vehicle here] anniversary based on the effective date. This lets you calculate the number of months until the next anniversary. Taking the modulus of the number of months until the anniversary and the number of months between payments gives you the month that the next payment is due. The only reason to work with anything other than the month is to cover cases where the birthday falls on a modal cycle: 

- Repeated calls to are expensive, because Excel can't make the assumption that the lookup table will be the same between each call. What that means is that it can't cache anything easily. If (based on your comment) you aren't making changes to the worksheet that the lookups are being performed on or making changes that result in formulas recalculating on the lookup range, it is almost always faster to create your own lookup cache. In this case, after a cursory scan it looks like you're always using the same key column for the lookup. So... just create a set up lookup tables with objects with the set to the row number (note that this assumes you have unique keys): 

This first checks that is "truthy", and then checks that is a valid, non-zero number. If these are satisfied, then is assigned the value of the supplied property, otherwise it defaults to milliseconds, like in your example. 

This line invokes the native method with the wrapper's arguments and resolves the explicitly constructed promise with the fulfilled object, if, and only if, it is successful and it completes before the callback is invoked. The reason this occurs is because of the specification: a promise can only be fulfilled, rejected, or remain pending forever, and if it is fulfilled or rejected, it is "settled" and cannot be fulfilled or rejected again. If it is unsuccessful, and it fails before the timeout occurs, then it will invoke with an error. 

This part is pretty straightforward; we're creating a timeout given the amount of milliseconds supplied from or the default , and invoking the callback function in that amount of time. 

I would like a review of a library I've recently published. I realize this is a rather large request, but having looked on meta, it seems this is perfectly on-topic. I'll include a few choice samples from the library to demonstrate my approach, as well as a link to the full codebase for anyone interested in giving a full-breadth review. So to summarize, this library, called , is, as the title and tags suggest, an object-oriented approach at designing an educational tool for teaching sorting algorithms, which is why the sorting algorithms use generator functions to introduce interruptions in the control-flow in order to be visualized step-by-step. Here's a few of the classes needed to implement an iterative (bottom-up) merge sort algorithm: 

First thing first - if your else condition ends with a return, you don't need nest your if statements. Just reverse all of your test conditions and return if they are true. This also makes your code much more readable, because the condition you are returning is next to the test in your code, not the reciprocal of it's distance from the top of your nest: 

Don't discard return values that you need later. Consider this pattern that is repeated 3 times in the following: 

4 - I'd put your enumeration in its own module and make it public instead of private. That way if you have other procedures that use custom error numbers you both easily can reuse them and avoid the possibility of collisions in error numbers. 5 - Named parameters after line continuations should be indented consistently. This is incredibly difficult to read: 

Now that we have code to review - the first issue that I see is that you are not comparing identical source code, and that makes it impossible to get an accurate benchmark. The problem is likely this line in the VB source that isn't in the C# source: 

The version took 17 seconds over 10,000 calls. The version clocked in at 28 minutes. Moral of the story is that Excel allows you to open XML files merely as a convenience - it is not intended to be an efficient way of retrieving values from them. Always best to use the right tools for the job. 

You should only open one connection to mongodb. Otherwise if you have 10 users connected on your chat, you'll have 10 opened connections to mongodb. 

I would use async $URL$ change a few variable names and share the connection. Since node.js in single threaded you can open only one connection and share it to all your modules. 

You could create a function called . You also have a another callback inside this function to handle the callback. This is a smell. You could handle this case using promise or using the async module. I recommend the latest in your case in order to not change the paradigm. You also have a variable called . If you split your code in functions and later in different file, it won't be so obvious that this name refers to . Overall, make sure your code speak for itself. You should only have to use comments when the code needs to be unclear (algorithme optimization for instance). 

From there, I would split the code into small functions. One could be call and looks something like. 

I would avoid to print errors. You should raise errors. Ex: You are also using some 'magic values'. Ex: . I would suggest that you define a constant so that the if statement alone is verbose. The same apply to the player positions. This way you could re-use the constants and only maintain then in one place. 

So if the intention is to enforce type safety, the better meta solutions would be to not use Variant types if they can be avoided or to use an IDE plug-in to make sure your assignments are type safe. If the intention is to simply replicate the functionality of the .NET List object, this is an entirely different matter (and one that is both useful and well executed, BTW). Nit-picking aside, let's get down to the "better /more efficient" side of things. Given that the object in VB6 isn't much more than a glorified array (4 methods - seriously?), I would just skip it entirely and just wrap an array directly. The vast majority of the class just uses the for storage space, and the fact that the intention is to ensure strong typing makes the memory management a lot easier. Note that I am not recommending an array of Variants, and am at risk of getting into StackOverflow territory. VB6 is based on Window COM, and uses a SAFEARRAY structure to store all of its arrays internally. This (vastly simplified) defines the size of each array element, tracks the number of elements in each dimension, stores a couple COM flags, and holds a pointer to the array data. Since VB6 is COM based, it also has a couple of undocumented functions like for pointer resolution and manipulation and can directly access the Windows API. This gives you the ability to do inserts and deletes into the middle of arrays with memory copy operations instead of iterating over the array or the a . You can get the underlying data structure like this: