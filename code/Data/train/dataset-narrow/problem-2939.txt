To give or not to give, that is the question There are actually several possibilities that reflect how you want the provided solution to be used. For context, I am an instructor at Colorado State University and I am discussing assignments that students might encounter in the first two to three years (not CS1). Don't ever give the students solutions The motivation for this approach is that one can reuse the assignment in the future without worrying about a "new" student getting a solution from the past. Although this seems logical, a colleague of mine scours the web for postings of his assignments. He developed a nice automated tool to do this for him. He says that he finds a significant portion (~40%) have been posted, often to sites like $URL$ Thus, if an assignment has ever been posted on the web, it will be there forever. Even if it is not on the web, a solution from a "friend" (who did the same assignment previously) may be available. My take is that cheaters will cheat. I encourage students to look for help on the web. If they find help, I ask that they cite the link in their code. This way they can go back to what they found helpful without repeating the search that got them to this information. By citing a reference, you are declaring that your work is based on code you found elsewhere and are giving credit to the author. But, I also say that in using the code, you are taking responsibility for its correctness. You cannot say "It is not my fault the code I copied from the web doesn't work!". Supply a reference implementation to the student This can be done at different times, for different purposes. 

My personal opinion is that the more code students read, the more proficient they will become. Thus, I tend to provide (or at least discuss) my solution to assignments with the students. 

Something I have used is to present the students with a paper form (like an application form). Each of the fields is labeled sequentially with A, B, C, etc. Then I ask the students to fill out the form with information about themselves and tell them that getting all the answers correct will determine whether they pass the course or not. Of course, I immediately get questions about what goes in each filed? "Isn't it obvious?". After a little time I show a form that was filled out correctly. However, I use names in several fields that could easily be either a first name or family name (e.g. Paul, Kelly). In the short field between the two names, I put a "A". Most students assume it is a middle initial. Some of the fields contain numeric values values that could be almost anything. Finally, I reveal the actual "names" of the fields. The short values between the names is labeled "Grade I expect to get in this class". The point of the exercise is to reinforce that the names of variables should define the information they contain. Otherwise, reading the code and understanding what is does is difficult, even for the author after only a little time away from it. I follow up using short (often single line) helper methods in lieu of inline code. . For example, an if statement may have a complex set of conditions. I demonstrate how to pull this out into a single line function and, if the function is well named, how it makes code easier to read. For example I use something like comparing if (row == (numRows - 1)) vs if (atEnd(row)). I'm not sure my experiment has really taught he students to create better names, but when I review student code, I do make comments on naming. I suggest that students read other code for conventions and adopt a "style" that suits them. I also suggest that when the students work in existing code, they adopt the style of that code. I believe consistency is more important that the actual convention. 

Agile doesn't mean "don't plan", so there should be plenty to talk about. Have your students developed user stories? Can they talk about these? For example, let's take this example user story: 

It would seem obvious to explain that the code below that block runs when the sprite is clicked. Similarly, in Node.js, an event-driven programming language: 

Scratch even actively removes blocks to ensure that the number of blocks and categories doesn't get too large—if students can't find a block, it may as well not exist at all. This links well to the issue of colour: too many categories will mean that you begin to reach an unreasonable amount of colours. I suspect anything more than about 10 or 15 colours would be excessive (Scratch 2.0 has 10 categories). But, shape also has an important place: 

Image by Booyabazooka of Wikipedia (public domain) Whether this explanation is useful would depend on your students' proficiency with mathematics and set theory. For younger years, you could simply skip the subset discussion and show a Venn diagram to represent the idea that a float can be an integer, but an integer type can only represent an integer—not all floats are whole numbers, but all whole numbers can be floats. The issue of large integers not being represented by integers in some languages is more difficult to explain without stating the way that integers are stored. In many curricula, binary representation of integers is covered quite early, and if that's the case, explaining why types can't hold extremely long integers is straightforward. 

If you're able to discuss some relatively complex mathematics (compared to what you might generally teach at this level), artificial neural networks are fascinating to discuss and work with. Ever wanted to: 

Consider the benefits of a text-based language: once your students master it, they understand a general-purpose programming language used in industry. If you master Scratch, you still have to go through this step anyway to learn a text-based language. 

The colour of a block is a 'way in' for students, helping them to figure out what type of block they have. Ultimately, the important thing here is that there are logical categories of blocks—the colours just provide a way of visually showing what category a block is in, without an information overload of too much text. To Block or not to Block, That is the Question: Students’ Perceptions of Blocks-based Programming makes a great case for well thought-out categories: 

I don't think the concepts behind generators, sequences and iterators are too difficult to grasp if you're clear on what exactly they are. The 'old' function of Python 2 just produces a list of numbers: