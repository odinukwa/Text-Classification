This might give you a bit of performance where you don't need to bother going down into the and methods. Also, is there any way you can get rid of that cast? Probably not, but that would speed you up ever so slightly. 

I think the biggest thing here is that you need to create some functions and encapsulate stuff. Big Points 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

A good general set of rules to follow is GRASP. Another easy test is to look at what the class does and then check that the name matches that what it does. Your User apparently loads things from the database and checks passwords. Not exactly what I'd expect from a User. 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

Now we can simply call this method whenever we need to get numbers from the user. Much easier, and we've reduced the complexity of our code. Another thing that's redundant is your constant re-declaration of . You really only need to do this once. If it were me, I'd have it as a static field for the entire class, e.g., 

This will let us set the references for each missile type upon initialization. With these references, each missile will be able to calculate its values on its own. 

You actually have no need for this since Reflection gives you direct access to methods and method signatures, as you'll see in my modified version of your code below. 

That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?" 

I'm going to use this above method to point out a couple of things that occur throughout your code. The first is minor: according to Java convention, your access modifier should come before the keyword (e.g., ). Not a big deal, but something to be aware of. More significantly, your method violates the "do one thing and do it well" policy. The method is called and returns a . That means it should evaluate the two numbers and check to see if the number is correct -- and nothing else. Instead, you're using this method to also provide feedback to the user. If you published your API and I wanted to use it, this would in no way be intuitive. 

Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

This is a curious method. All method names should be verb phrases, firstly, and if this is taken as a verb phrase then it means you are executing the code to play again. But the really curious thing about it is this: you return if the user does not want to play again, and if they do want to play again. That's bizarre and completely counterintuitive. 

This entire block is very difficult to scan. What it does isn't readily apparent by the way you've named all your variables. For example sounds like the rightmost node in the tree, but in fact it's the left node of the right node in the tree. Then with all the subsequent processing, it's very confusing without stepping through line-by-line to get a better understanding. Consider renaming your variables to be more meaningful. In my opinion, the most beautiful and elegant code is self-documenting. Also, if you were looking for ways to further improve the code's functionality (besides adding recursion), you might look into generic types so that your nodes can hold any data, rather than just an . 

That gets us right back to the first question. If we assume User to be a class holding business logic, then technically, putting the db access into the User is a violation of SRP. However, when the impedance mismatch is small or doesn't exist, then using an ActiveRecord'ish pattern might be practical. So check how much impedance mismatch you have. When you notice your User to turn into a ORM, consider using an ORM instead. The other option would be that your User doesnt have any business logic and is really just a Gateway to the storage engine. Then it's okay to have db logic in it. It just shouldn't be called a User then though.