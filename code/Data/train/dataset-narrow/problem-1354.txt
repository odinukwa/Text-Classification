The separate variable h is needed for thread safety. Otherwise you could potentially have a second thread see a partially computed h (or as already mentioned have two threads calculating a hash at the same time and interfering). Both will break things badly (for example inserting a string into a HashMap with the hash wrongly calculated and you will never find that String again). Copying value to val[] looks like a now-obsolete micro optimization. Again the immediate check for the array being empty is a micro optimization to handle the empty string case without entering the loop. 

You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically. 

I'm working through some Project Euler problems using C++ and some of the numbers in question are starting to get quite large (21000 for Problem 16) and I need to add some of these large numbers together, so I quickly threw together a string represented (positive) integer adder: 

I'm writing a very simple engine which I hope to use to create a game at some point and felt that I needed buttons to allow the user to select options in a menu, so I wrote up a rudimentary button class. Think of this as similar to Windows forms if you like. Whilst what I've produced works and I can detect the button presses I feel like this is not the simplest way to do it (although note that I would like to do it myself as a learning exercise rather than using an existing library to produce the buttons). One of my biggest problems is that the buttons are done using rather than and so have a top left anchor and working based on window width and height in pixels rather than a center anchor ranging from -1 to 1, needless to say this makes rendering buttons a chore. Any advice on how to improve that alongside general scrutiny would be much obliged. display.h 

Is there anything that I can do to improve my function? I'm especially interested in the use of storage types other than and what the advantages of doing so would be. It should also be noted that I do have an intention of doing something like this in a however, as this was quickly thrown together for the solution that's parked for the time being. I'm less interested in my method of solving Problem 16, however any comments on that would also be appreciated. 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

In general for OO programming you separate out code into objects and each object focuses on doing one thing and doing it well. Each object should then generally have it's own source file in your code tree. 

Something to remember about the Java libraries (especially older ones) is that they were written when Java was a new language. Some of the techniques and patterns we use as standard now were not available and the compilers, optimizers etc were a lot less smart. A lot of things we can just ignore now and let hotspot handle had to be considered in the code, and since these are core libraries that must run well on every possible Java device they cannot assume anything about the environment they run in so have to do as many optimizations as possible by hand. Sun's code to compute hash of string: 

Recently I've been doing some experimenting with RPN and the shunting-yard algorithm, in order to test these systems more appropriately I planned on writing a tokenizer and then using these tokens to check validity and eventually get some output. I also think that I could use this to work with some primitive programming language, such as making a CHIP-8 assembler. Function The intention is for my tokenizer to separate the input string into a list of the following: 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

Something I'm less sure about as I haven't implemented a CHIP-8 emulator in some time is that it doesn't appear to be functioning 100% correctly, although some games are certainly playable. As far as it running is concerned, I picked of a few games to see how they ran, I had no problems with: 

Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

I don't think there are any possible edge cases here, at least some initial tests don't reveal any problem. I think it's short and readable, but readability is often hard to judge when you're the author. Any remarks? 

We have a table with calculated data that groups sales by product, year and month, to provide fast querying for statistics. My colleague argues that the year and month should be two separate fields, because a day is meaningless. I want it as a date field, because using two separate fields leads to awkward code like this 

I understand his argument, but the code is harder to read and there's a higher chance on bugs when doing date/time calculations without using date/time objects. I also can't cast it to a in the query because I'm using LINQ to Entities. Which method is the better one? 

The goal is to construct a with a connection that uses an access token. The access token is acquired with ADAL (Active Directory Authentication Library). The problem is that acquiring an access token is an async operation. Luckily, ADAL uses for its async calls, so it should be safe to do sync-over-async without risking deadlocks. Full code is provided below. The focus for this question is on the sync-over-async code and method of registering the , but remarks for the other code are welcome too. Container configuration 

One thing I'm not sure of: is the readonly property necessary for or can I write ? I'm not worried about the tiny chance of multiple calls to the same uncached object causing multiple and I'm also not worried about stale data. The main goal is to cache some informational data that is simply displayed on the screen, instead of retrieving it every request. I've tested this with an expiration of 1 minute and a class that gets on creation, and it worked fine, so I believe the code is bug-free. 

This is a very nice implementation, and in fact will be just as fast as the sun one since over an Array internally uses a style approach. The problem with it is that it is not compatible with earlier versions of Java since the loop is a recent addition to the language. Micro optimisations You will see this term a fair amount in this sort of discussion and in general it can be read to mean "something that makes such a small performance increase that it is not worth the increased code complexity". In the usual development scenario keeping code simple will reduce bugs and increase developer performance in terms of functionality provided for time spent far more than the micro optimisations can increase application performance. In fact in some cases micro optimisations actually degrade performance as they confuse the compiler which otherwise would make the same or better optimisations behind the scene. "Premature optimisation is the root of all evil" - Donald Knuth This is a well known quote in this field, although actually if you go hunt down the full quote there is far more to it than the catchy tagline. As a developer you should focus on writing clean and well structured code and on the big optimisations such as choosing the right algorithms, data structures, etc. Once that is done if you still need to increase performance then assuming you have the right algorithms and data structures (which will save far more than any amount of micro optimisation) that is when you look at progressively finer optimisations. But keeping the code clean and readable will gain you far more in the long run...quite apart from anything else it makes it easier to get the algorithm right! The core Java libraries are a special case as every single Java program is written on top of them, so slow performance there slows down everyone...and they have to run on every single JVM so they cannot rely on clever compilers or virtual machines. In many cases the core Java libraries are a bad source of coding examples. Partly for that reason and partly because they were written when Java was new and people were still learning the best ways to do things. In fact the book "Effective Java" by Joshua Bloch uses examples from the core Java libraries as things NOT to do. That's an excellent book by the way, you need some Java experience to appreciate it but I recommend it to all developers with a year or two of Java behind them.