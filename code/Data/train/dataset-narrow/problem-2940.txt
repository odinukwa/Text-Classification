One of my best CS students ever did her undergraduate work in Art. Another was, as a sideline and avocation, a ballet dancer. The best indicator is Desire. If a student wants something bad enough they will find a way to be a success at it unless circumstances make it impossible. Every student is different, so the question of mass production probably has a negative answer. At its best, teaching is a relationship between two people, a teacher and a learner. We make compromises for economic reasons, but there are negative consequences to all of the compromises. Socrates did it best. If you want to teach you have to work toward that ideal as much as can be managed. Even the massive classes (CS50) require a couple of hundred staff people, mostly tutors, to manage it. If you want to increase D in another you need to make things interesting and you have to give them a creative outlet as they define it themselves. Fear is a poor motivator, of course. Intelligence is overrated. An IQ of 150 and three dollars buys you a cup of java in most places. You/they/all can learn and can prosper if they see rewards that are worth spending the effort on and dedicating your Life to. A couple of other students who did some of the best work I saw that year struggled for every idea - over and over - until success. 

I've always used Hello name" as part of Hello World. It's easy enough for most students and makes the program more fun. After Hello World I use a conversion program. For example Fahrenheit to Celsius. That makes a lot of sense in the US but might not in other countries. But there are many conversions that make local sense in other parts of the world. Pounds Sterling to Euros perhaps. Students often like money problems. Conversion programs involve both input and output but add the introduction of assignment statements and calculations. More involved calculations allow for a review of the order of operations (one reason I use Fahrenheit to Celsius). Students get interesting results if they don't set up the formula correctly. Conversion programs also let one introduce testing early in the game. Sure the program compiled, ran, and gave you an answer but how to you know it is the right answer? 

Is this a bottom up (faculty driven) initiative or top down (administration wanting changes)? The latter is likely to be much less successful. Are the faculty already knowledgeable cross-discipline? It will be much less successful otherwise. How important is it to you to have pair-teaching (co-teaching, team-teaching) of several courses in your institution? Especially pair teaching with instructors of different core disciplines. Without that, I wouldn't expect a lot of benefit other than needing fewer "department chairpeople". 

then the compiler has little recourse than to give x the most specific possible type. It might, in fact be preferable to give x a more general type, such as an interface type used to create the Horse class. It is generally good programming practice to give variables interface (as opposed to class) types, though this requires other rules about how interfaces are used - a separate discussion. But, in some contexts 

One project I like is to have students draw a shape with a specified number of sides. They can enter the number of sides and have the turtle draw it. Middle school students might have to be taught to divide 360 by the number of sides to get the turn angle but after that they should be all set. It lets you introduce simple variables and how they can be used to control loops. If you add a small turn after the shape is drawn and put another loop around the first one you can get some interesting designs as well. And they learn nest loops is a way that makes sense to them. 

I introduce loops by showing them loops in the physical world. For example I have a student take 7 steps - counting loop. An other student walks to a specified point - while/until loop. We talk about how these loops work in our minds before we talk about how they work in code. Many daily activities can be discussed in terms of loops and we discuss several. Eating is a good "loop" with several possible indicators of when to stop. When you are full or when you are out of food or when you don't have more time to eat (end of lunch bell rang.) Steps can be counted or one can tell that they are at the top. Even better what happens if you "stop" early or late. Concepts first and syntax later. 

This doesn't answer your question, but might be a resource for your course. Back when (don't ask) Scot Drysdale (Dartmouth) and David Levine (Saint Bonaventure) had a great exercise for assembly language: Animal Write an assembly language program whose execution results in writing a true copy of itself elsewhere in memory and then executing the copy. A refinement is to erase (zero out) the original. It is recursion without a base case, of course, though you could trick it up. However you can also give it a payload, which could be nasty, so beware and discuss. It is also an example, in assembly, of a Quine Great fun too (sans payload). 

The grown-up answer: Because it's good for you. No, really. At this age the different things you study all give you different kinds of skills and different ways of thinking. Thinking is good and the more different ways you can do that the more likely it is that you will be able to solve the problems as they come along. The different subjects in the early years are put there because people (grown ups) think that they will be relevant in the future. Being able to think for yourself means you are more likely to be able to detect the lies that people will try to tell you to get you to do things that aren't really in your best interest, like buying something that has the main purpose of compromising your privacy. Math, History, Philosophy, CS, ... all teach you to think in different ways. And, in fact, programming is useful in many fields. Even philosophy if you want to examine a lot of texts written by old (dead) philosophers. Science can't do without it anymore. Nor can some aspects of literature. The less grown-up answer: Because it's fun. No, really. Well, if it isn't fun then maybe the teacher needs to rethink how the course is taught. Why isn't it fun? Is it the sorts of problems that the students are working on? Are they boring to the students? Is it the way they are supposed to behave? Too much frustration of working alone (or the opposite, I suppose)? Personally, I hate boredom. Or is it that they just don't have any bigger picture of what it is that they are learning, being always lost in the details? You can always ask the students what they "learned today". I used to ask that quite frequently, just to get them to focus on that before they left the classroom. Ok. That was a bit grown-up too, but devious. Devious can be good, if done right. 

I do tend to review some basic topics at the start of a semester to get a handle on what students have forgotten or never learned completely. After that I don't use class time as I expect students to make some efforts on their own. I teach high school so I may handhold a bit more than a university professor. In my case that means I schedule time for helping students during their free periods or before or after school. Additional resources, especially for review topics, are often helpful. I don't think that written resources work for everyone. I record a lot of the presentations I give for early topics and make them available for students. Lately I am trying to find videos by other people who, I hope, explain things differently than I do in hopes of reaching different students. An other option is to use peer tutors to help struggling students. Often peers who already understand a topic can make it understandable in ways that would not occur to me. 

An easy to use compiler builder suite is CoCo/R. You define a language as an Attribute Grammar (ATG) and the tool creates a scanner and parser from the ATG. You need to provide a semantic analyzer and code generator, but you can annotate the ATG to simplify this. The input language defined in the ATG needs to be (largely) LL(1), but a learning language should have that characteristic in any case. The tool will give you an analysis of your language as well. I've made extensive use of CoCo/R both in teaching and in building such "bridge" languages. And building your first compiler is a joy beyond joy. 

Any true paradigm shift requires literally re-wiring the brain. Thinking functionally is not the same as thinking procedurally (for example). The neural pathways of the brain need to be connected appropriately for the new paradigm to become natural. When you were a kid you were, if typical, used to walking and running. Then you probably got a bicycle (or a skateboard if you are young enough). You tried, you fell down, you tried again. Your brain got used to the subtle balancing required. Swimming - same deal. Differentiation - same deal. Haskell - same deal. As an instructor, the above implies that you should provide guided practice at the beginning - a skateboard park for the mind. If your students solve a lot of simple problems (not syntactical, but logical) they will skin their knees on these but if they are well chosen will get the skills. In scheme, reversing a list with only head and tail is simple enough. Doing it in linear time takes a bit more skill, but the technique is both cool and satisfying. Writing the code wires the brain. And, like riding a bicycle, it is hard to un-learn it once you get it, since the brain is now different. So, make it possible for the students to fall a lot, but to get up without getting discouraged. To add a bit of specificity to this. Assuming you know the paradigm well yourself, what are its 100 most important techniques? Can you come up with a 10-30 minute exercise for each of them? Try to have each exercise focus on just one thing (mostly anyway). These are your Etudes. Can you come up with 10 exercises for each of the 100 techniques, even if they vary only slightly? Acknowledgement: At SIGCSE 2004, Owen Astrachan (of Duke) convinced Microsoft Research, through Jane Prey, to give every attendee the book The Art of Changing the Brain by James E Zull.