So I'm looking at the "show perfmon" output from my ASA (5550, 9.0 software), and am confused by the "VALID CONNS RATE in TCP INTERCEPT" output: 

Original Answer As a rule of thumb, a "LAN" is a broadcast domain. (It may consist of more than one.) Then again, as a rule of thumb, a rule of thumb applies 3/8ths of the time, so this doesn't really give much to go on. This was understandably rather poorly received, so I've expanded below. Updated Answer I've never really liked the essentially recursive answer of "a LAN is a network of devices in the same area." Granted, it's a rather subjective term, so here are a few other options to illustrate what one may be. Note they may not apply in all situations, there may be exceptions... or they may ALL apply to your situation: Layer 2 Network If devices are in the same Layer 2 Network, they can be described as being on a LAN. Broadcast Domain Devices in a broadcast domain are in a LAN (or multiple LANs). This normally applies to VLANs (Virtual LANs), which can be used to segment a LAN... or can be used to link physically distant devices into essentially the same LAN. Yes, this stretches the definition of "local!" Non-Routable IP Address A set of devices on the same non-routable IP address subnet who can talk to each other (without NAT or other workarounds) are most likely on the same LAN as well. What are non-routable IP addresses? Wikipedia explains it well enough: $URL$ Essentially, these ranges are set aside for "local" use and are not to be forwarded out to the internet. Sidebar These non-routable ranges appear to have been rather arbitrarily chosen--eg, there's nothing special in electricity that makes 10.0.0.0/8 range not route, but someone realized some ranges should be set aside and made a judgement call about which ones. I could be wrong (which isn't rare by a long shot), but Jodies.de lets us see the binary of these ranges ( $URL$ ). I don't see anything terribly remarkable about the addresses. They just seem arbitrary. See for yourself: Address: 10.0.0.0 00001010 .00000000.00000000.00000000 Netmask: 255.0.0.0 = 8 11111111 .00000000.00000000.00000000 Address: 172.16.0.0 10101100.0001 0000.00000000.00000000 Netmask: 255.240.0.0 = 12 11111111.1111 0000.00000000.00000000 Address: 192.168.0.0 11000000.10101000 .00000000.00000000 Netmask: 255.255.0.0 = 16 11111111.11111111 .00000000.00000000 Enough digression! VPN Tunnels Additionally, a VPN tunnel (be it just from your PC to your company or a site-to-site/LAN-to-LAN tunnel) lets a remote machine behave as though it were on the LAN. If it walks like a duck, and it talks like a duck, and it tastes like a duck... Conclusion "LAN" and "WAN" are rather ambiguously defined. They are hardly the only delineations, either--I've been trained on a model that went from LAN to optional CAN (Campus Area Network) and/or to MAN (Metropolitan Area Network) to WAN. You may define your LAN as everything behind your home internet modem, but your ISP could consider every subscriber on your block to be in a LAN... and they could both be right simultaneously! The terms can subjective to a degree, but these guidelines (and all the others posted) should help you determine if something is a member of a LAN, a WAN, or both. 

UDP is obviously a send-and-forget protocol. For example, during an NMap UDP scan, the only way to definitively prove that a UDP port is open is if you receive a response from that port. Keep in mind that many services may not reply to arbitrary data and require protocol or application-specific requets in order to warrant a response. Certain ICMP codes can gurantee that the port is closed, however. RFC 792 and RFC 1122 give us some good information as to what to expect when a port is closed. For example, an ICMP type 3 code 3 "Destination Port Unreachable" is, for all intents and purposes, almost guaranteed to be a closed port. A full list of codes can be found here: $URL$ 

One reason--and I'm sure there are many, many more--is because you can have the same VCI on multiple different VPIs. The VPI is 8 (OK, 8-12) bits, while the VCI is 16 bits. VPI 0 has VCI 35... but VPI 1 also has VCI 35, as does VPI 2. Guess what? VPI 3 also has a VCI 35. These VCIs don't necessarily interact. This is probably more for the PVC (Permanent Virtual Circuit) implementation, common in ISP networks. It's a bit like asking why you have a third AND a fourth octet in an IP address, or why you need a street AND city name in a postal address. ;) 

In past experience, this is generally indicative of a loop of some sort. (Note: This is a school, and students have been known to intentionally plug in an Ethernet cord from one wall to another. We have plans to re-mediate this, believe me.) The setup is rather simplistic in that there are a total of 324 Cisco WAPs, each connected to one of the four switches in the Alcatel stack with a 1 Gbit uplink. Now, on the core, when I run: 

A coworker and I recently migrated a core from old Dell switches to two running Comware 7 and IRF. What we have noticed is that every 5 days, the user accounts no longer accept the passwords. Even if no unsuccessful attempts were made whatsoever, all of the accounts lock every 5 days. We only have HTTPS and SSH protocols enabled for remote access over the VTY lines. What we find is that, when we enter the wrong password, it asks us to re-enter the correct one. However, once we do, it simply terminates the connection. The only way that I have found to fix it is by getting physical, console access, deleting the accounts, and re-creating them. Is there a way to fix this? Unfortunately, this is a sensitive client, so I will not be able to post the entire configuration, but I can post certain parts upon request: VTY Line configuration: 

Hope this clarifies any confusion. You have your computer connected to internet through a Cisco router. 

( R ) prepares an Echo request. ( R ) checks its routing table and concludes that the packet needs to be sent out from interface ( 2 ). As the ( R ) has two interface it can choose to put either of their address as in the Source IP Address field, i.e 10.0.0.1 or 20.0.0.1. It chooses the exit interface IP address as the source by default. This is to simplify the routing process. Extended Ping command can be used to change this behaviour. So the IP packet will have the Source IP Address= 20.0.0.1 and Destination IP Address = 20.0.0.2. Interface ( 2 ) of ( R ) will prepare the packet based on the type of WAN link and send it forward to ( I ) (20.0.0.2) ( I ) receives the packet. ( I ) responds to the packet using a Echo Reply. This packet will have the Source IP Address= 20.0.0.2 and Destination IP Address= 20.0.0.1 Eventually ( R ) will receive the packet on its interface ( 2 ). 

Think of UDP as sending a letter regular postage, and TCP as sending it with tracking numbers and notifications on delivery. Keep in mind UDP and TCP are just delivery methods, they don't give a damn what's in the packet or what the application receiving it does with the packet. DNS is a stupid example to show someone the difference between TCP and UDP. SNMP (and traps in particular) is better. Let me try below. Note, examples are simplified slightly. When a router sends an SNMP trap (an alert such as "Hey, I've just rebooted, thought you should know") to the SNMP server via UDP it does just that: it sends the packet to the server and that's it. If the server is programmed to send something back, UDP doesn't care. UDP delivered its packet, now it's going to the pub for a pint. So what would happen with TCP? Well, the router world send the packet containing the trap message to the server. After a certain timeout period, it would then send the packet again... And again... And again... Until the server finally responds with an ACKNowledgement packet. And that's ALL TCP cares about. It doesn't care about the data packet that the server may (or may not) need to send back. TCP will deliver its packet and return with an ACKnowledgement, or die trying (more or less). You may want to review the OSI model, keeping in mind that each layer encapsulates the one above it. That is, each layer wraps the stuff it received from the layer above and carries it with professional disinterest as to the contents. 

I have a 4-switch stack of Alcatel Omniswitches connected to an HP 5412 core via 8 uplinks; these are ports D11-D18. Unfortunately, the client did not yet give me access to the Alcatels, but a request has been sent out. Meanwhile, I am seeing a high amount of TX/RX traffic on several ports in IMC regarding the core. An example: 

(for each port. I did it one by one instead of a range to specify). Each port from D11-D17 shows the MAC address of the Alcatel stack as well as the port to which it is connected in a fashing like: 

I'm having trouble wrapping my head around DSCP AF Classes and what--all else being equal--gets dropped first. I understand packets are given a Class, 1-4. The higher the Class number, the higher priority that packet gets. I must assume that higher priority means lower chance of being dropped. Is this assumption correct: Higher Class = Higher Priority = Lower chance of being dropped? I also understand that packets are given a drop precedence, 1-3... and in this case the lower the drop precedence, the lower the chance of being dropped. During congestion, does higher Class traffic have precedence over lower Class traffic, regardless of Drop Priority? If so, this leads to the absolutely counter-intuitive scenario where, while AF32 is less likely to be dropped than AF13 (32 > 13), AF32 is more likely to be dropped than AF31 (despite 32 > 31)... and that's really throwing me for a loop! 

On the router ( R ) there are two ports involved in forwarding the data to and from internet. Let's say we call the port connected to your LAN as Port1 and the port connected to internet is Port 2. 

( ï£¿ ) sends out an Echo request. The IP packet will have the Source IP Address= 10.0.0.10 and Destination IP Address = 20.0.0.2 Router ( R ) receives the packet on interface ( 1 ). ( R ) checks the routing table and based on that decides to forward the packet to interface 2. Interface ( 2 ) of ( R ) will prepare the packet based on the type of WAN link and send it forward to ( I ) (20.0.0.2) ( I ) receives the packet. ( I ) responds to the packet using a Echo Reply. This packet will have the Source IP Address= 20.0.0.2 and Destination IP Address= 10.0.0.10 Eventually ( R ) will receive the packet on its interface ( 2 ). ( R ) will check the route in its routing table and forward the packet to its interface ( 1 ). Interface ( 1 ) of ( R ) will prepare the packet based on the type of LAN link and send it forward to ( ï£¿ ) (10.0.0.10). ( ï£¿ ) receives the packet. 

I'm finding statements about SNMP holding-time like "traps whose holding time expires are deleted." While that COULD be written less usefully, it would take significant effort. I'm assuming that it doesn't work exactly as described, else setting any holding time would delete all traps the moment that time passes. I'm not seeing how this--as described--does anything but keep any and all traps from ever being sent. So what does holding time actually do, and how does it do it? 

You can use any channel you want, but as others have said channels 1, 6, and 11 are your best bet. The channels overlap each other such that 1, 6, and 11 are the only channels that don't overlap each other. A picture is worth a thousand words, this one is from the Android app Wifi Analyzer: