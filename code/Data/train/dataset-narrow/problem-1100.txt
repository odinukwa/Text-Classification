I don't like this. I think if you are going to down the route of using then use it for all references that won't change, that includes: 

This should reduce the amount of time the spends resizing itself. This reduces the runtime by about for - so has little effect. These sort of micro-optimisations should always be tested using benchmarks to see if the additional code complexity warrants their addition. A few comments on the code: Use of You use sometimes to delimit references that won't change: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

The has no idea that we've won - it carries on and still emits that we lost. is a busy wait, so causes one CPU to "spin" while it's checking the time leaving it unavailable for anything else. 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

Indentation Your main function needs to be indented one level inside your class. Functions Your code would benefit by moving some of the code in main() to functions. The main() function should generally be a place to process arguments, initialize the program and catch any exceptions. As it's currently implemented you need another variable to get a while loop to work. If the guessing part was in another function the while loop would be easier to implement. Multiple Loops You should have one loop for continuing the game, and another loop for the guessing part. 

hides the fact that cin, cout, vector and stack are coming from the namespace std where cin, cout, vector and stack are used in the code. This can cause confusion of where the code is actually coming from. As the software becomes more complex and uses more libraries this becomes a bigger problem. For a more detailed discussion of why it is a bad idea to use see this stackoverflow question and this stackoverflow question. The Use of new is Preferred Over malloc in C++ The code contains the line: 

To optimize the code create a copy of the array and use qsort() to sort the values in the copy. Find the dominator using the sorted array, then find the indexes using the dominator value. I don't know if this is a result of how you entered the code, but the following line of code should be 2 lines of code: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

Essentially we take each and we it that gives us a . I then you the method to append all present instances to a . If the `StringBuilder is empty simply append the current integer too. An alternative, not sure if it's better, is: 

But (and this is a big one for style) you should only use one type. You have got one type in some places and the other type in other places. Set a preferred style in your IDE and stick to it. Also, if using Egyptian brackets (the first style) please leave a space between the statement and the opening bracket. Comments Comments like this: 

What do you notice about the pairs 1. <-> 5. and 2. <-> 4.? There is a simpler solution to this problem than brute force... 

So whilst I have a lot of tweet data, I only need a list of integers. This is obviously much smaller. I want to be able to stream the data from the file and convert each line to its sentiment value in the most efficient way possible. Here's what I came up with: 

Use the Features of the Container Classes and the Standard Template Library You may find this website useful for learning all of the features a particular container class or the standard library. There are definitely some functions you could be using, such as , , std::count_if() and that could definitely shorten the code. It might be wise to investigate std::map as well for counting words. GOTO There are almost always ways to avoid using in C++. In rare cases may be appropriate for error handling, more so in than in because has try{}/catch{} and exceptions. In the following code there is really no reason to use a : 

The variable may not have enough space allocated to append the extention. This can cause the program to crash, especially when the code is optimized. Allocate a new string with enough space to accept the file name and the extension. 

Variable Names Generally the variable names are ok, some might improve with additional length such as changing to . One variable should probably be renamed from to `sequence_size since it is used in much of the program. Testing the Return of Allocation The code contains all the necessary testing to see if returns a value or not, but it would be better if each call to was immediately tested rather than what the following code does: 

While this C coding standard is for a specific class at a university it gives some good tips. The Use of typedef Might Help The typedef declaration provides a way to declare an identifier as a type alias, to be used to replace a possibly complex type name. By using typedef in the struct declarations the structs becomes types similar in some ways to , and . An Example Using typedef 

I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

I have some code that calculates the "sentiment" of a Tweet. The task starts with an AFINN file, that is a tab-separated list of around 2500 key-value pairs. I read this into a using the following function: 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input. 

which is causing the bug @TobySpeight mentioned. Functions in Header Files Obviously putting function bodies into header files works, however, it is more common to put function prototypes into headers and function bodies into cpp source files. The reason for this is that if the header file that includes function bodies is included by multiple files, the functions are now multiply defined and the user runs into multiple definition errors at link time. One way around this is to make the functions in the header file static, but it is much better to just have the prototypes in the header file and link multiple object files together. Reduce Complexity, Follow SRP The Single Responsibility Principle states that every module or class should have responsibility over a single part of the functionality provided by the software, and that responsibility should be entirely encapsulated by the class. All its services should be narrowly aligned with that responsibility. 

Since you are not doing anything special in either the constructor or distructor you can use the default constructor and distructor if you are using C++11 or C++14. This allows you to declare/define your constructors only in your header file, and let the C++ compiler generate the proper constructors and destructors. The less code you have to write, the less error prone it is. In C++11 or C++14 

This function should be called by the other functions that modify the children vector rather than repeating if (children.size() > 0). That way if you need to change the comparison you only need to change it in one place. 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

Using Caliper this method has a runtime of around for . I have done a few experiments with speeding up the code. For example, using the Prime number theorem we know that there are approximately prime numbers between and . Using this information we can create the used for storing the primes to almost the right size: 

And yet you continue with your program knowing that it cannot possibly work. Either throw an exception (which will be reported to the user, and be ugly) or simply to exit and terminate the program: 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number 

You don't use any of the properties of . You do not need to know that it is a . I would specify the argument as and leave the invoking class to decide on an implementation. Brackets There are two styles of using curly brackets in Java, and either are valid: 

First of all you've done a good job, the functions are atomic and perform only one action. The code is well indented and quite readable. The file names seem to be a good choice as well. So just a few suggestions: Follow a C Coding Standard When Programming in C The C programming language and the C++ programming language are distinct languages. Here on CodeReview C++ is defined as 

The previous declarations reserve memory for the globals in each object file, in essence this is creating a separate variable in each oject file. This should be: 

Welcome to code review, a nice first question. The code is well written and readable. Just a few observations that may help improve the code: As @TobySpeight mentioned, you should change the variables to so that the warning messages go away. Missing Header File The code is missing 

Welcome to code review. Nice first question! Global Variables xReprisal provides a good answer. The first 2 bullets are very good advice, I might have switched the order, You should avoid global variables as much as possible. In more formal programming languages such as C, C++, C# and Java they should be avoided completely. Global variables make a program very easy to break and very hard to debug. In very large programs it is possible that there can be global variables with the same name used for completely different purposes. Readability and Maintainability The code is already very readable and maintainable, but there are a few inconsistencies in the style. Maintain the same indentation for all code This code is indented differently than all of the other code: