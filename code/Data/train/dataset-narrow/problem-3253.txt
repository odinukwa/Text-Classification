Replace the IP with the address of your Raspberry Pi. Now you should be able to move your mouse between the two X sessions by moving your mouse off the screen to the right (east). 

This is how to resize a raw image file. I know it sounds stupidly simplistic, but it will work. Create a blank image, of the size you want to expand the original (in my example I use 5GB); 

I love my Pi, but it takes a considerable time to boot. If I want to use it as a Media Centre, it's quite important that it powers up quickly. Are there any steps I can take to improve boot performance? 

In fact, the latest and best tools do not need to be built by yourself. On the Raspberry Pi Tool GitHub Repository you will find the and toolchains for cross-compiling software. I recommend using the toolchain, as that will compile for Hard Floating Point, which will result in a much faster system. 

If you prefer the command line, then you can search for packages easily there. In Arch you can use pacman with the -Ss parameter: 

This file runs once every time starts and should solve the problem. I copy and pasted it from my own and can confirm that my screen does not blank. 

All you must then do is flash that image to the SD card and boot the Pi. If all is well, should be the location of the USB drive when the Pi boots, and thus it should attempt to use that location as root. The parameter is important as it will make the boot process hang until the USB drive is recognised. Without it the Pi may complain that the location doesn't exist. I suggest that you copy the root partition from an existing Raspberry Pi image to your USB drive and use that to boot from. Let me know if you need any further information. 

Do you have, by any chance, physical access to the computer? If that's the case, shut it down, put the sd card on a computer (I mean, like a laptop or a desktop or a server, you get the idea), mount the / partition of the sd card (/dev/mmcblk0p2, probably) and edit the profile file so that it doesn't work when you start the terminal (or add a & at the end so that it goes into the background). Another possibility: Did you happen to set up a different user on that board? If that's the case, try to log in with that other user, then sudo kill the process (hoping the user is a sudoer). 

Apparently time stuff (with ntp) can be set up to use gps devices $URL$ This one is for raspberry specifically: $URL$ 

You expect it to run on apache? Then you need to install apache2 with libapache2-mod-php7.0 and then you start it with apache2. If what you want to control is if php7.0 will be enabled on apache2 then I think what you need to use is a2enmod and a2dismod. 

I'm having fun with one side being an http server hith LAMP (or close) and then have a python script on the rp making requests against the server using python-requests. Simple enough. 

I'm doing basically the same thing on an application of mine. I would try setting up wvdial as a systemd service and set it so that it restarts time after time if it fails with Restart=always and RestartSec=60 or something like that. 

My first thought would be this is a firmware issue. Try updating the firmware using Hexxeh's tool, it appears to be the easiest way for Debian users to update (someone please correct me if I'm wrong). You can download the tool from his GitHub repository here. Arch Linux users should already have the latest firmware, as it is installed with a standard system update. 

It doesn't look as if alsa can find the device. Try manually inserting the module and running your script again. 

This is completely dependant on the Class of SD card you are using. A Class 4 card, which is the minimum recommended has an average read/write speed of 4 MB/sec. If you spend a little extra and buy a Class 10 card, you should find that the boot time is approximately 25% of the Class 4, as it should read at 10MB/sec. Using finnw's estimate that 24 seconds pass while using a Class 6 we can guess this could be reduced to 14.4 seconds with a Class 10 device. Classes 2-10 will give you boot times something like this: 

This bill of materials has not officially been released, so any real answer to this question would be speculation. You could derive an approximation of the cost by looking at each individual component, but you would also have to add manufacturing and labour, which is unknown. Also the economies of scale involved would be difficult to determine. It's worth noting that the design and initial prototype work was all donated, so that never added to the cost of the final product. Also, here is a quote from the foundation forum which claims that the manufacturing cost is definitely less than the sale price: 

I have a little experience with GPS dongles and so far I have been able to read from them by opening the device file as it it were just a normal plain file (with open) and then pulling with readline(). The only details I've had to change (say, set no echo or change speed) I just call stty with supprocess.popen and then I just go and open the file and read from it till I reach EOF (device was disconnected, for example). How long does it take for your application to fail? Because you can try with cat (on bash, say)... run cat on the device file and see if it will run longer than your application reading from the device. It should run forever, actually... if it goes fine, then I would expect open/readline() to work just as well on python reading from it. 

I would say as a general principle: if the set up is going to be that tricky with this system that is going to be remotely located, why make it more difficult with one additional variable (the presence/absence of a dhcp service somewhere). Just set up the rpi with a static address on a private network (say... inside segment 192.168.197.x/24) so that when you are in front of it you can set up your mac to have another address on the same segment and voila! You can both see each other. But, just in case, it would help up a lot if you told us how each of the network interfaces of the rpi will be used (wireless? wired? will you use a GSM device for it to connect to internet, perhaps? you will be working with it remotely, do you have a vpn setup so that you can see each other?). Networking is tricky stuff. 

It is a completely cli application and it accepts a wide range of arguments, which you can see by typing: 

I very much doubt it is irreparable, however this is a perfect example of why should not be on your root partition. Everytime your machine wants to log a message or start a process it makes small but significant writes To . Without these writes the system cannot function. I'll say it again for everyone: 

Update: With the release of new hard float distributions boot time has been significantly reduced. In addition, Arch Arm Linux is now using instead of which starts processes in parallel and is considered to be much faster. As a result my Class 10 SD card now boots Arch to a login prompt in about 6-7 seconds. 

There are several tools that will check integrity of a filesystem, and recurring errors will point to a SD card reaching the end of its lifetime. is a commonly used Linux application and you can use it to check a partition like this: 

Yes, there are logs for everything. If you connect a new device to the Pi then the module being loaded will show in . Eg; 

Type n to create a new partition. Type p to make a primary partition. Next press enter when prompted for a partition number to choose the next available. Press enter again to pick the next available sector to start the partition. Press enter again to use all of the remaining disk space. Type w to save the changes. Fdisk will now exit. You am need to reboot in order for the partition to be available. You can now make a file system for the new partition using the mkfs command.