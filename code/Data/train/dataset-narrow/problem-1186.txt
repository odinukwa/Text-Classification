I have an XML stream that looks like the following (attribute and node quantity , and node depth reduced for demonstration purposes.) 

That can be confusing to read, and difficult to debug. Consider using independent variables Magic error numbers You've done half the work of creating custom error numbers: 

And why not throw in a factory method too, although some might argue it's a return to the year 2000. In order to get the enumerable features of a Collection, I'll have to use a Collection behind the scenes, but I'll augment that with a Dictionary that keeps track of the keys used in the Collection. Then, when I want to test the method, I can check the Dictionary (and get all of it's hash-tabled goodness) instead of enumerating the Collection or suppressing a potential error by checking the index/key directly. I also want to make the Collection configurable so that it can be 0 or 1 based according to preference. I've made this setting private to the Collection, so it's up to the developer to adjust for the purpose at hand, but it could easily be exposed as property or set in a factory method. Pass the Widget First, we need a class for the objects that we'll put into our custom collection. A will do nicely. Nothing special here - just a class with a few encapsulated fields, and a bonus read-only property for returning an instance of itself. 

If you absolutely need to use your Find approach, or if you'd just like to see a centralized error handler, as per you question, then you can use a variable to store the custom error message, and then refer to that variable from the error handler: Also, in you On Error statement, you don't need the trailing ":" as that indicates that the line will have another statement following the ":" 

But I'm not sure that from the point of view of design it's a good solution, because it looks like a violation of LoD. There should be a better approach to solve it. 2) the calculation of should be moved into a separate method, which will allow to eliminate the last remaining in this part of code. 

And you need to invoke only for the case of , in order to check for method. is already available for all objects. Formatting: opening braces should be moved to the end of their preceeding lines. 

I don't know Akka-Http API well enough, but it looks like the condition is misplaced. I think that it can be substituted with a er under : 

Now we cannot reassign the field, but we can operate on its contents when necessary. method would look like this: 

If you want to avoid the creation of the on each call of method, one of solutions would be as follows. Change class to implement interface. This will allow to put its instances into a block. The created inside the original method will become constants in the changed class and they will be closed inside the method when the routine exits from the block (normally or with an exception): 

Another Approach I can suggest another approach that has more or less the same result of externalizing SQL queries, but can be achieved without the dedicated class, only by using the features of Spring. The fields representing SQL queries can be initialized from property file sources: 

The arg above allows us to reduce the number of references to pass from one object to another. Now we can introduce companion objects like following: 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

But the would ideally be defined as a constant instead of as a magic number in inline code. Check bounds before using 

I assume you're working with a 40MB file instead of a 40GB file. The performance will vary greatly depending upon: 

Be careful with properties matching built-in control names is the name of a built-in type, but you're using it to return a . That might be confusing for users of the property. Accessing the `Forms` object The Forms object extends the names of open forms at run-time. That means you're using late-bound code and you're not getting any Intellisense. Worse still, if the form isn't open, or it's in the wrong state, the call will fail. At the very least, you should have some error handling. Using the default instance of the form Access creates a default predeclared instance of a form (much like VBA creates a default predeclared instance of a UserForm), but Access only does this if the form is open. However, it is also possible to create instances of the Access form (and, I'd argue, is the preferable way to deal with Forms and UserForms). Your code is intimately tied to the default instance, and should perhaps be made capable of handling any instance of the form. See this example to see how a form with a default caption of "foo" is handled by VBA: 

If you mean that invokes , that is absolutely OK and should remain as a private function. Nesting within each other should not be overused. I would recommend it only when the nested function is 1) really short; 2) simplifies the readability of the parent one; 3) never needs to be invoked from other functions or itself; 4) does not call other functions of this entity. For most these conditions are not met. Mutability 

Loading the contents of an entire table using Set is very dangerous. First of all, if the table is rather huge (imagine just several dozens of thousands of rows), this object will squatter the memory and probably consume too much of it uselessly. It also duplicates the data supposed to be stored in the DB and produces too much overhead on each object creation by reading all the data. However, reading just the metadata of table columns and their types could have been useful for your problem. and objects are created, but never closed. Initializing them inside a try-with-resources block will solve the issue. , especially in a constructor, looks very ugly. Either replace it with a more concrete exception type or (even better) find a way to avoid the clause for the constructor. There are no validity checks for and arguments. What will happen, for example, if one of them or both are ? 

Indeed, I didn't cover it in the initial answer. is not necessary for field, it can and should be transformed to . The reference is never changed throughout the code, but only the contents of the array changes. And I also think that there is no need to expose the array with public access at all. The in also seems disturbing, because it recalculates the maze on each call and returns a new different instance of . Was it really the intention? It would be more logical to remove both and from and define an accessor for cell values at the trait level: 

Despite the documentation above, does actually seem to return when the ParamArray argument is missing, but it's still safer to check the array bounds. You obviously have a private helper function in , but it is not necessary - if the ParamArray variable is "missing", it will be an array, but its upperbound will be -1, and its lowerbound will be 0, so the statement is sufficient. 

Having said that, you're going through some variable gymnastics to pass a ParamArray argument to a private method. You can avoid that by declaring the helper function's parameter as , but then you do need to check that it is an array before enumerating it. 

IMO, you're better off with a function that either returns a boolean that confirms the sheet is present (before you try to do something with it), or returns a reference to the sheet or otherwise Nothing. That way you can keep you error handling concise, and avoid the need for labels. Here's an example of the reference approach: 

Also, you're using some nice concise bit-shifting, and you'll have noticed that VBA doesn't have any shifting operators, but you might consider using some bit-shifting functions to make the code slightly clearer (and you can re-use them everywhere else that you need to shift bits. And finally, unless you're certain that will always be a single celled reference, the color will default to if there are more than 2 cells in the range and they have different colors. 

Hijacking the predeclared instance's fields In the factory method , I temporarily set the state and X/Y fields of the default instance, and then in the event of the new instance, I read those fields though the default instance's getters. As such, I've relaxed the conditions around being able to access the default instance's getters, but this could easily be re-added. The default will always have X and Y's getters return 0, in much the same way that the default will always have default value 0. 

Case Classes Some of the occurrences of case classes are overused. I doubt that or could be useful in matchers, because they look like intermediate utility entities providing conversion to target and instances. This transformation can be done through a redefinition of function of companion objects. super-class also introduces a rigid structure and can be transformed into a : 

Here are some formal remarks that do not concern the design choices made in the code. Unnecessary Code All the repeated functions like 

Visibility and Encapsulation class contains too many public final s, which is quite suspicious. Number of them should be made private or protected and thus the visual pollution with will be reduced. 

branches are used to match Strings: this approach is too verbose and not very flexible. is instantiated in two different places, with same semantics. The thrown in block is immediately caught and thus is useless. The catch blocks hide exception details and trace, which is annoying for debugging. Returning is ugly. A better choice would be either to return an or throw the exception outside the method. 

Exceptions type is too general and is discouraged to be thrown from any method. Try to find semantically more appropriate existing types. For example, in function, if the stack is empty or contains more than two elements, it is in an invalid state. There exists for that and it might be used. I'd also suggest more informative messages in the exceptions and probably add more checks for the cases when numbers or operators appear in unexpected positions. 

Do not hesitate to extract the initialization of s, etc in dedicated methods, it will allow to instantiate the respective fields in one line without messy lines after. Group the instructions executed directly through the constructor into a dedicated function (that might also call other functions of grouped calls) and call this function once, as close as possible to the header of the class. 

Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: 

The strings redundantly repeat the literals. or will produce the same, so there is no need to add field. Now, after all the refactoring applied since the initial question, let's try to approach the design a bit differently, with the aim of simplifying the thing. In the reviewed solution there is an array to store symbols as strings () and enums per each chemical element (, ...), each wrapping data for nuclides. However, the core notion of this system is the chemical element, with a few constant values for different nuclides (symbol, atomic number) and with other fields varying. So why not creating a single that holds constant properties for each chemical element, used as prototype to initialize a for any of them? This could look like follows: 

If you are using Java 8, there is no need to create a dedicated class for this purpose. Lambdas are helpful: 

Bug In the constructor, must be initialized before calling , otherwise a is thrown if the folder contains subfolders. Design Constructor I agree with @holroy about the fact that there are too many things done in the constructor. Its job is too heavy, instead of just initialize some things. Moreover, it makes the instance unusable for other parameters, e.g. to search in another folder or with another regex, one will need to instantiate a new . 

For the rest, the code seems quite straightforward, rigid and repetitive, hence difficult to maintain. It contains many clauses that smell bad. Of course, the whole story may be refactored with patterns usage. But I don't think that the state pattern suits well here. It'd be better refactored with the command pattern. All the menu actions (create, remove, rename and their dependent ones) may be wrapped into separate objects, which associate the expected keys (1,2,3..), the text and other necessary stuff and sugar. For example, a (very short) version of class could be like this: