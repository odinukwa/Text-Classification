Now, you can reuse this code generator for other codes. The is an optional parameter. I don't know if you already know about this, but if not, here's the link : $URL$ 

What is printed? Is it ? Nope, because your instance constructor resets the field. The field shouldn't be static. Each should have its own number of stones. Maybe the number of stones could be customized with a parameter in the constructor? 

My Basket could become a black hole pretty quickly if I was to set a negative capacity. After all, what stops me? In your property, you could do : 

A magic string is a string that is hardcoded somewhere that means something important that isn't described in the code. I'll also apply this to other variable types eg. . What does 21 mean? (I know, but what if someone who reads your code doesn't) When I write a board/card game program, I'd like to think that someone who never played the game before could understand every rules by simply looking at my code. So I would introduce a variable that is properly named to represent the 21 value. Data structures 

Will it work? After all, the lambda isn't the same reference as before! Your dictionary might not find it. (Although I must say I'm not 100% sure) This is why, when you look at the pattern, returns , which is the object responsible to the , you should implement something similar in my opinion because you might not always have the opportunity to your callback when you want (example if you need to do it in a DLL that has no reference to your . Last thing, I don't think it should be a . I think your should be backed by an ( perhaps) so you can unit test your code more easily and create less dependance around your code. (If you need to understand why interfaces are nice, I'll post some articles in comment if you want) And you could use an IoC container to deal with the dependances. 

You're using for nothing, since is defined by the . The value will always either be a or . So just checking for would be good. These are all readability issues. I really think your code is more readable this way : 

Creating a syntax tree from the tokens The algorithm yields the following results in these test cases : 

I think it's a dangerous path to try and "thin" everything. At some point, some of your classes will hold more code than others. You want your controllers to be as thin as possible and that's good. That's why you have services, view models, etc. But building these things belong in the controller sometimes. 

The responsability of a controller is to create and return them. This usually imply some boilerplate code, creating new instances, setting parameters, etc.. Then, you need to return the good view, which also leads to some boilerplate code. Your controllers are thin. Very thin I'd say. I think you're searching too far to refactor perfectly fine code. I know, that's a boring answer, so I'll explain why I think it's the best I can do. What are our options? Extract a method to return the good kind of view ( or ) according to the type of the request? But this method would need 2, sometimes 4 parameters to work correctly. At least 2 parameters to define the view to return (The name of the view) and 2 other parameters to verify if the is null and what view to return in that case. That sucks, right? An "helper" method with 4 parameters where 2 are optionals? Nah, let's forget that. Extract the creation of the perhaps? Ok, so I need a , but what are the parameters? The , the , that other string beside the in your service call, sometimes you'd need to pass the parameters to create too, which is 3 more parameters. That leads to a that has 3 to 6 parameters, sometimes optionals, always looking alike. What's common between those refactoring experiments? No reusability, low cohesion, high coupling. So, it's bad. Plus, those two "helper" methods would serve what purpose? To create and to return the good view? If we re-read the first sentence of my answer, that's exactly what the controller is supposed to do! Why would you take their jobs (South Park pun intended)? So, all in all, that code is really good code. Keep it up. As a little side note that might decrease code's length, here's a tip: 

I can't help much about performance, but if I remember correctly the JSON.Net maker has a blog post where he explains how he improved the JSON.Net's performance. Otherwise, you can see how he's done with the source code! 

This way you reduce the nesting and you improve readability. Also, instead of throwing , consider throwing a custom exception. You always need the same format : 

Btw, think about using instead of . It's just weird! Last comment, to reduce nesting you might want to revert your condition : 

I believe it could be a one line, but I don't think you should. One liner's are kind of "cool" to write, but they are a pain to debug, and a pain to read. I think you should keep your variable, it is great for readability. What I would change though is the indentation of your . Bring those brackets to be on the same line as the . And, as @RubberDuck pointed, you should use the operator instead of . 

Notice that I inverted your condition to reduce nesting. So I just return if the value is a number, there's less nesting and well.. That's more readable! 

What I see here is a great scenario for composition! What you say is that you're annoyed because already has the shipment informations. Alright so, why doesn't contains instead of repeating all the information? 

It can be directional or not, implying that the between and can be traversed from if the is . The can be "weighted", meaning that there's an value linked to an edge, which will be used for some graph algorithms. 

Notice something? Well, that's the same code, with one different variable in . So let's take care of that by extracting another method : 

First of all, the variables aren't named properly. and aren't intuitive at all. Don't hesitate to write longer variable names, it will be very helpful if you ever want to understand your code easily in the future. Same goes for your method name, isn't clear enough. Your method removes all occurence of a in another . So you might want to consider or something like that as a method name. Next, as @200_success pointed out, your code has flaws. Whenever you see that you wrote 2 (or more in this case) loops with the almost same code, you should wonder if there's another way you could do it. I'm not sure my method is the most efficient, but I think it can lead you to a good path. 

First, it's confusing. Maybe you forgot to write a condition, maybe a for? I don't know, and it's confusing me. Remove those brackets. 

What is the expected output of this? You'd expect the count to be 8. But no, the output is now 2. Because your method changes the . Then again, your method just uses other LINQ extensions to replace . Because the LINQ's already has an overload that takes a . Overall, your methods add an overhead to simple operations that are already done using LINQ. If you want to rewrite LINQ, don't use LINQ. :) 

Delegates syntax are a little bit too much C#2.0. It's confusing for inexperienced developers and a little bit too ninja in my opinion. In C# 3 or 4 the and where introduced. This remains a matter of opinion but I believe you should use instead of your . Your method and are not very intuitive. What do I add a delegate to? When will it be executed? Why not name this and . I know, it looks silly, but look at what it looks like in code : 

I also think you should pull out the method of this class and put it in a class that is used only to start the application with the good parameters. Doing so, you could use your class to only find missing integer. This way, if you ever want to reuse it, you will be able to without bringing the method with it. Also, you could make your class respect the OOP more. You could input the in the constructor like so : 

When I finish writing code, I usually ask myself : "Okay, do I think I'd be able to understand my code in six months?" If the answer is no, it means I'm not done. My code needs to be clearer. I 100% think I wouldn't understand your code in six months as I don't get it now. Naming Crudely put, the variable names are terrible. What does mean? Why is 19, 11, 21, etc there? As I said above, I don't understand your code so I can't propose better names, but you should name your variables accordingly to what they do and use variables for all those "magic numbers". "Six months in the future" yourself might thank you if there's a bug in the code. I'd also rename the method to . 

With the idea of gathering the biggest hockey's individual stats dataset ever, I've started with the big league, the NHL. Using Selenium, I've been able to scrape this NHL's statistics page. To explain the workflow simply, I extract the data from the standing's table. It's basically a big string with a lots of to split the data. Then I "click" on the next button, redo, until the whole list is passed. Afterwards I change the NHL season with the URL and redo the steps above. Everything works fine, but I have some concerns about readability/maintainability. 

Dayum, there's some around here. Why not make it an instance class? What you have here is a workflow, where methods have a specific order. This is clearly seen in your method. The workflow usually have a state, and stuff is supposed to be stateless. So I really think an instance class would be good! Doing this would also mean you wouldn't need all those dirty parameters, nobody loves them anyway! You could keep these -> 

Note : The base class is used in the algorithms, but it is not used anywhere in this review. The is used in case of a non directional graph, it is used to see if two edges are from the same... association ( and ). 

In your prompted message, you always use and specify the line breaking character . Instead, you can use which sums up to : 

If you reach capacity, you should either expand your capacity, or throw an exception. Removing the first object is just a way to hide the problem. But if I use your class, I would never expect this situation if the queue was full. 

Might cause problems if there's a lot of . You iterate through the collection three times when one would be enough. From what I understand, you need to check all the collection is there are parsing errors, then you check it all for the other states. Why don't you build an algorithm for this that'd iterate once? (That algorithm would also deserve its own method I think) Something like this : 

This way, there's no loop and we join the strings only once. The problem with your code is that it's, as you said, not the most efficient way to do what you want. When you write code, always try to be conscious of the "cost" of the methods you use, and the amount of loops you use. Though I guess it comes with experience! Lastly, I don't think is a good method name, considering the method doesn't only join strings. It's kind of hard for me to come up with a better name considering I don't have the context of your application. But you should try to find something more representative! 

I don't know what 's type is. And it is used alot. Also, I don't know if that method is yours or an external DLL, but that doesn't respect the naming conventions. It should be, I believe : , or a property . Unless for sure, this method call codes something. But it doesn't look that way. This : 

I gotta start by saying it's weird to ask how much damage you want to take, my answer would always be zero, you know! Your variable names could be more descriptive. I understand that means damage, would be.. something health? Well I guess you see my point, if we don't know what the variable name means, it's harder to figure out what it does. Considering the PEP8 guidelines towards Python, your variable should never contain upper case. So I would change : 

Note also that the recommended use of is when you can figure out what is the type just by looking at the code, so : 

In , do you have multiple keys or a single one? Because this : is confusing! is an . According to the naming guideline, your enum should be pluralized if it's a enum. I don't know if that's your case, but if so the property name should be , otherwise the should be . And shouldn't you check for ? Mat, I remember writing this comment everytime I review your code. We should have a chat :p In , the cyclomatic complexity must be pretty high. Because there's the in there, I can't really propose a refactor. Plus, well maybe you won't be able to refactor since it seems there's a specific order in the execution of your code. But maybe there are methods you could extract! In , members should be on top, and I think members should be separated from the others, but I'm not sure. I know we should use brackets all the time : 

Excuse the method names, your comments aren't very self-explanatory so I did with what I had! Feel free to correct me. Then you can implement your class 

Before worrying about , there are some very basic notions we should review! :) Never, ever getting back together expose your fields. They should be . Use properties like you did in your class instead. This pattern is called encapsulation and is an important practice in the software development process. In general, an instance (like ) shouldn't deal with fields. Why is that? Imagine the following scenario where you have 2 quarries. 

The way you're doing it at the moment is fine, though it creates a bond between and . I'd consider your constructor more like an helper method than a necessity, considering all the properties are (which is very good in the case of a view). You just need to consider if could ever be built from information that wouldn't arrive from a . Now, I've typed this sentence and realized it makes no sense :p Your way is fine. Instead of you should use which has the same behavior but it's clearer! :) Also, in a case like this : Consider using instead of , it shortens the code and it is okay to use in such a case because you can see what is the type of just by looking at the code. 

If I understood properly, is used to verify that an answer is valid. So would be much more appropriate.