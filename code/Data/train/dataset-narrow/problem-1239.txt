The names and don't say anything about the variables' use. I had to read through most of your code to figure out what means. Always use descriptive names for your variables, at least for those whose value is supposed to persist for extended periods of time. I would be willing to accept the , as it is basically one-shot, but should be renamed at least to or or something more descriptive. Your looping and termination logic seems odd. You are using the correct construct , looping while there's valid input left. But then you have this block: 

You're overdoing it with comments. A lot. And trivial ones at that. Every programmer knows that creates a vector of pointers to , or that you have to use with pointers. Such comments are really just clutter and actually make the code harder to read. Save them for the non-obvious bits. It's unclear what protects. Does it protect ? Or ? Or both? This is one of the places where you should comment, but you didn't ( is absolutely pointless). If possible, rename the mutex to match its purpose. It would also be a good idea to wrap the mutex and the data it protects in a class, to ensure that unsafe access is impossible. requires the reader to parse it (and what's with the double parentheses?) The meaning of , on the other hand, is immediately obvious. And how does it create 4 threads? You could just as well rewrite the entire loop to make it more concise (and perhaps more efficient too): 

You don't need to convert an object pointer to , a is sufficient for that. Don't use stronger casts than necessary. You can simplify the assignment to and make it more obvious by assigning the result of the placement-new into it: 

This type of information must go into comments. The next maintainer (which can be you in 6 moths' time) will need knowledge like this to understand the code. You should add specifications to your functions. They affect efficiency of some operations (like storing in a ), and since this is a very generic class, you should not limit its use in any way. An example for the assignment operator would be: 

In that example, is 7, the duplicated number is 1, and the missing number is 6. So you get the formula . We can solve for by adding to both sides, leaving us with ! Let's do that. First, you can calculate the expected sum from that formula, . In your loop searching for the duplicate, you will need to keep a running total (and don't break early). After you find the sum of your list and identify the duplicate number, you can calculate the missing number using the formula we talked about in the above example, . Also, you don't need to record the frequency as an integer, you can just keep a list of booleans for numbers already seen. I've also taken the liberty of cleaning up the indentation issues and renaming some of the variables for the purpose of readability. Here is the solution: 

This is a good first attempt, but you have a couple things wrong with it. If you look at the for loops, you'll see it's adding each element to the nav in the same level (rather than nest them inside each other), but then proceeds to move it to the correct place with the inner for loop. That's the second problem. You rebuild the nested element structure each time you iterate over the array. You should eliminate all this unnecessary work, and you can do it in all plain JavaScript without using jQuery. Edit: changed function to accept any number of elements as arguments to nest (e.g., ). 

You initialize and , then you reinitialize in the outer for loop, then do nothing with in the inner one. You don't need to write an initialization step in the for loop if you don't want to. 

I think it would be helpful to redefine your function like so below. I would strongly suggest including the function in your "LinkedList.c" file as well. It is going to do the same thing no matter what is in your , so why leave this implementation up to the user? Just define for yourself as a helper function. 

Also note that I added a call to into the waiting loop. Your previous code was leaking the threads. You're writing C++. Don't use (type unsafe!) C I/O. Do this instead: 

The same holds for all other uses of C I/O (, ), of course. and would be better declared with type , as they represent the number of some objects. If you have access to C++11, all the above could be simplified even further using range-based loops, lambdas in standard algorithms, or at the very least iterator-based loops. I didn't bother with iterators here (even though they could be used), because their type has to be spelled out explicitly. In such case, it would also make more sense not to allocate the threads dynamically, but create them directly in the vector. No need for manual deallocation, no dynamic allocation overhead. 

The class is missing a copy constructor and a move constructor. These can never be created by instantiating a template. Right now, the compiler will generate a defaulted copy constructor for you (and no move constructor, because you have a user-defined destructor). Since you obviously don't want that, you have to define the copy (and probably move as well) constructor yourself. You're also missing a move assignment operator which you should probably add. Otherwise, your class wouldn't be fully usable with move-only types. Your code is missing comments (there aren't any). You even had to explain an invariant in the question: 

This will cause the loop to terminate when a 0 is entered in the input. This behaviour does no match the assignment, and hence it represents a bug. Based on the assignment, you should only terminate when input ends, which will be correctly caught by the loop. The line should therefore be removed. Related, your after-loop test for is incorrect. If the loop is (correctly) terminated by being unable to read more numbers because the file has ended, both and will be set on . The condition will therefore fail. You might want to augment the condition to check for EOF: 

These are already available in your scope, so you do not need to reassign them to a local variable with the same name. 

Here you throw a string. You can throw any value, but it's more helpful for debugging purposes if you throw an object. Just pass this string into the constructor to make your own error message. 

Your code grabs the from the then converts it to an , therefore treating a as an . The function you defined swaps the values in the s, effectively swapping the first bytes of your s (most likely the members). I'm not sure if this was intentional, but it certainly is pretty unintuitive and most likely unreliable. Instead, I would change your code to this, then redefine your function afterwards. 

There is a shortcut you can take to find the missing number after you've found the duplicated number. You may have come across this fact before, where the sum of the numbers 1 to is . We can leverage this along with the duplicated number to find the missing number. If you add up every number in your list and subtract that from what the expected sum would be from 1 to , most of the terms will cancel, leaving you with . You can visualize that with an example: 

You pass an immediately invoked function expression (IIFE) to the push method, but this is totally unnecessary. You can execute the code above the push method and make things considerably more readable. Also, you redeclare the variable inside this IIFE and use it for something else, which is pretty confusing. It'd be better to use a different variable name. Time Complexity Your current algorithm is O(n2) because of the nested for loops. A more efficient algorithm would be to step through both arrays at the same time, adding the next smallest element to the merged array. This approach would be O(n), so an improvement! Changes Altogether, this is how I would restructure your existing code: 

As far as performance is concerned, there are no problems in this code. It's using C++ streams in the idiomatic way, which is good. If you're experiencing performance issues, you could try detaching from C streams at the start of your program: 

Indentation in the post-loop conditional is inconsistent with the rest of the program, and should be fixed. The same holds for the block (unless that was just screw-up of the code formatter here on Stack Exchange). The return value of is interpreted by the operating system as the return code of the program. On all OSes I know, 0 indicates success, non-zero indicates failure. You should therefore return 0 on successful program termination. Or just omit the altogether, is implied in the function in C++. Or, if you want to be really beyond reproach, and comaptible even with OSes where 0 does not necessarily mean success, you can change it to ; this requires . Error output (such as your message) should be sent to (standard error stream, usually file descriptor 2), not to (standard output stream, usually file descriptor 1). A more helpful error message would be in order as well. Something like 

looks like a rather arbitrary number for the default template argument for (it's actually a magic number). There is even no guarantee that 16 is a valid alignment value. I would probably choose something less arbitrary such as . There is no reason to use for the type of . You don't actually care about alignment of at all (which is emphasised by you passing to its parameter). All you need is a buffer of suitable size, and for this (or a ) would work just as well. As a side note, be aware that was only introduced in C++14. Visual Studio 2013 supports some C++14 bits, but using it makes your code non-C++11-compliant. You might want to swap the order of the data members, it might prevent need for padding between an oddly-sized and aligned . You might consider overloading the pointer operators and for your class as syntactic sugar for , it simplifies usage. Other generic classes which store a single object sometimes do so as well; an example is . 

Maybe use some array methods like ? This will add up all the elements, starting with an initial sum of 0 (the second argument to ), then the sum is divided by the array's length to compute the mean. 

I've created a function that takes an integer greater than zero as an input and converts it into its corresponding Roman numeral. If you're not familiar with Roman numerals, you can read about it on Wikipedia. I've tested this code with some examples, so it should be working correctly. I'd be interested in hearing about any general improvements I could make on the code. Nitpicky details are fine as well; whatever you have to say I'm willing to hear, but I hope your answer is more substantial than that. I suppose my main concern is whether this is sufficiently efficient or if there is a way I could improve on that. Also, do you think I've used the correct data structure in this situation? I can't think of a better data structure for what I wanted to do, so that is why I chose arrays. 

You can use the comma operator, which takes the value of the last expression. It's not used very much, so may make the code less readable, but if you wanna make it one line, this is the way to do it in a single statement. You need parentheses because of operator presedence. If you omitted them, the comma would be interpreted as a separator between variable definitions. 

You've declared your function as , but what information does the returned convey? You're always returning , so no information is gleaned from the returned value. I'd suggest redeclaring your function to return and remove the statement. This goes for a few of your other functions that return . If you're always returning the same value of or , just remove the return statement and declare the function to return . Here's the list of such functions which I've changed below.