You don't just convert from OpenGL to OpenGL ES, as OpenGL takes shortcuts which are not implemented in ES. As Sam points out, glRasterPos* for instance has no equivalent, because it is not very useful. I doubt glRasterPos3f() is the only function missing to port you project from GL to ES, and you won't find function-to-function replacements for most of them. I'll advise you to learn what is OpenGL ES actually before starting anything. It is easily portable to OpenGL (the other way is NOT true), and will teach you some good habits (do not use glVertex*(), use object buffers, don't change states all the time, etc). But porting bare GL to ES ? Forget it. 

You could try something like the method described here . Basically, you generate random heat sources (random pixels in a texture for instance), then iterate over the whole texture and compute each pixel as a function taking the nearby ones as arguments. Let c0 be the color of the current pixel, c1 is at its left, c2 at is right, and c3 and c4 the two at its bottom; c0 color (value) is the result of (c1+c2+c3+c4)/4. Do this for every pixel at every frame, and voilà, you got a (somewhat basic) 2D fire. Feel free to distort the source image to add realism. Note that the very same technic is usable on 3D as well. 

Assuming start point is the green circle, and end point is the red arrow Compute the distance between the start point as DS and the black segment, and do the same for the end point (red arrow) as DE. If DS>DE, then the segment is pointing toward. if DE>DS, it is pointing away. If both are equal, the two are parallels. You can find how to compute the distance from a point to a segment here, and to a quadratic bezier curve here. However, depending of the shape of the bezier curve, it might return weird results (the curve can be crossing itself) 

I'd start with a perlin noise, filtered carefully. You'd end with something like in the picture attached to the question, with floating islands. Juste remove the floating islands afterwards using a counting algorithm like the ones discussed here 

In a more general point of view (ie. not talking about box2d), you could double the amount of objects present in the scene (if you want to display one enemy, you should actually have two of them instantiated). Once the first got out of the screen, enable the second one (which will then enter the screen), and recreate the first one (hidden, then) in the background. That way, although theoretically slower in average, permits to keep a constant framerate. 

You need to implement a "2.5D" system. Taking the picture as reference, the ground is drawn first, then all the sprites, using Y as the order. Start from the top (y=0), bush, bush, tree, plant, tree, character, tree, stick, and so on. Please note the character has been drawn before the tree near him, that's it. TL;DR: Draw sprites according to their Y offset. 

The whole point, and the best part, is this: you know that your solutions to the problem (H(a) and d(a)) obey the specifications (n(a)), so you get the same n(a), but you have freedom. You know exactly the freedom you have, and you can use it to customize the experience. You should always try to give yourself such freedom while satisfying your most important needs, whenever possible. Now that we've chosen the one-hit damage d(a), and since d(a) depends on the weapon damage w(a), we can use d(a) as our specification and try to find a w(a) that gives us this d(a). The principles are the same, the problem is different: we want the player to cause more damage as his level increases, even with the weapon remaining the same, and we also want the damage to increase when the weapon alone gets better and the level stays the same. But what importance should each factor have? Suppose we want level to be more important than weapons: a bigger part of the variations of d(a) = a² should be independent from w(a), for example with w(a) = 22.sqrt(a)    and, therefore,    d(a) = ( 22.sqrt(a) ) . ( 10/22.a.sqrt(a) ) = w(a).( 10/22.a.sqrt(a) ) We get the following graph for w(a)... 

The industry standard for first-person view simulation in most shooters is to have character models and animations distinct from those used for third-person view. There are several reasons for this: 

I can't say I've played all puzzle games in existence, let alone all games with puzzles in them. But I only remember one about whose puzzles one could say they were all always placed at the one and only appropriate point in the narrative and that they contributed immensely to it. What I mean is that when the designers of most games insert puzzles (or rather, "specific gameplay sequences") at certain points in their story, their goal is to challenge the player. And that's it. Maybe because the story requires it at that specific point in the game, maybe because it gives the gameplay rhythm. Take Half-Life 2, for example, and give me one example of a puzzle (you know, the physics ones) at some point in the game which couldn't have been replaced with another one, due to the story requiring that specific type of gameplay at that specific time. I know that in the latter half of the game, the puzzles require the Gravity Gun and can't be done without it, but the gameplay is pretty much the same: grab->put down, grab->throw. The same applies to almost all games, where the aim of a given bit of gameplay is always either to give the player a gameplay bonus or to allow them to move on in the story or more rarely, as in Deus Ex: HR or LA: Noire, to reveal more about the depths of ths story. On the other hand, in Braid, the gameplay and "story" are tightly interwoven. The first chapter is supposed to be "forgiving" and about innocence and so is the gameplay. The chapter with the ring is about finding comfort in the presence of someone dear, all the while knowing that their companionship is a burden (to someone as ambitious and driven as Tim), and the gameplay is a perfect translation of that. The same applies to the other levels and even to the epilogue. Jon Blow himself said about his game design experience with Braid that it was like sitting in a gold mine and scooping nuggets of gameplay, examining them from all angles (or something along those lines, was it in Indie Game: The Movie?). That's the phase you're currently going through, it looks like. So I what I would do if I were in your case, where you have a unique idea and you'd rather sit in the gold mine and scoop nuggets than write a story, is do precisely that, do this job of scooping as many gameplay nuggets as you can. Once you have something to say, a message to shout out, then you'll write a story with these two constraints: the message and the gameplay. They will be unrelated enough that the story can accommodate them both. Take, for example, this painting (the medium) that depicts an old Middle-Eastern king killing his servants, horses and dogs, bringing his world down with him as he is losing a battle and his palace is assaulted (the story). It's about grandiose decadence and egotism (the message). We could imagine lots of different works of art with the same message. For example, imagine a scene in a movie about a corporate CEO who in the end burns entire bags of bank notes in his condo as the tax administration/feds/IRS/what have you are after him. You can always write a story that adapts to your medium and message of choice. Edit to answer the asker's comments: So you have a gameplay you like as well as a story you like. You would like to develop both further, but doing so would mean having to make sacrifices on the gameplay end or on the story end when comes the time to merge it all into an actual game. One solution could be to work on the story first and use it as a constraint for the gameplay, which would only serve as the medium for it and, in your creative process, would always come second. Another solution, the converse of the first, is possible, where you find as many variations on your gameplay as you can and then see what can be done with it it terms of storytelling, hoping that you can build your original story around these gameplay elements. All this cranking of constraints into others looks painful. What I'm suggesting is that you take a good look at your story and try to pinpoint exactly what makes you like it in the first place. What, in its substance, makes you want to tell it. Extract that substance, forget about the details of the story like the setting, the names of the characters, their looks, the duration of the story, forget that it's about human beings (it could be about animals!), forget all of this and look at its substance, its deeper message, somewhat like I did (or tried doing) for the Death of Sardanapal painting linked to above. Then, I assure you that you will never have the slightest bit of worry regarding cranking the story and the gameplay together. You will find the story that makes use of the gameplay to convey the message. I personally believe that that is what matters the most. So scoop those gameplay nuggets. By the way, this is not how Jon Blow thinks we should make games, because this disconnects the message from the gameplay. If, like him, you can create an experience that is contained within the gameplay and have the player extract the message himself from that experience, that's also extremely cool. 

I'm trying to make a tactics game using python and the infamous pygame library. I use threading for networking and pathfinding. The game uses a p2p lockstep architecture, with one of the players acting as a host. The server starts 2 threads (send / receive) for every connected player. All the connected clients also start 4 threads during their lifetime, 2 for networking, one for the main game loop and a new temporary thread for each pathfinding request. My problem is that the program uses a lot of CPU and memory, even for very small maps, even when not blitting any sprites with transparency or running any pathfinding algorithms the program is slow and CPU intensive. The map in my game is built out of tiles, which are 96x96 pixel pygame surfaces, which map sprite images are blitted to 

I'm learning C++ and openGL and have this program as a result from tutorials and playing around. The problem is that the main loop is running at "full speed", making the program unnecessarily cpu intensive. I have managed to make it only perform rendering every 16.7 ms or so, but the outside loop that is waiting to render still is iterating as fast as my computer can handle. This is the full main.cpp: $URL$ This is the main loop at line 95: 

And so on, this seems really tedious and if possible I want to avoid loops and just define everything in the simplest, and shortest manner. I'm interested in how you would do this, or if you've already made a similar system, how you solved it in your own code. 

My game uses an entity manager and entities to represent everything including the player, enemes, items, ..everything in the game. In my engine it's the responsibility of every entity to update itself. Sometimes an entity finds out it has expired somehow, and thus needs to remove itself from the entity manager. My question is: Is it safe to have an object delete itself? I will illustrate what I mean. 

My plan has been to use RSA to exchange AES session-keys with a client, which is then used for all the usual in-game stuff. Clients never connect with each other, all communication is client to server only. The question is: Would I be wasting my time by encrypting the communication? How are big AAA multiplayer games doing it? If I do do encryption, is the basic scheme I mentioned a good start? 

The strength of this is that I can scroll the map by changing the map surface x and y. Also all the ingame coordinates are conveniently set in relation to the map rather than the screen. However I can no longer use pygame, and I'm trying to switch to pyglet instead. As far as I can tell pyglet doesn't have an equivalent class built in, and therefore I need to build my own, this is what I need help with. I've used pygame.Surface extensively without really understanding how it works (python programmers these days huh). So I'm hoping you can offer some insight on how to get started. I know it needs a width and height, as well as some kind of list of the sprites which have been 'blitted' to it, and that moving the surface itself moves all the contained sprites, so surfaces blitted to it are somehow anchored to the surface rather than the screen. How is this stuff done in pygame, and how do we create a pyglet friendly version? 

where R is the radius of the sphere and, for a certain positive even integer N, we have the constant θ = × π/N, k and n are integers with k varying from 0 to 2N-1 and n varying from -N/2 to +N/2. To make a half-sphere or an eigth of a sphere, you have to restrict the set of values taken by k and n. If k were real numbers and not just integer numbers, you'd get a whole sphere, not just the vertices on its surface. So what we've done here is rasterizing the surface equation of the primitive. The fearsome torus: it's easy after all we've seen! Again, more trigonometry, more vertices, more quads, more symmetries, more invariants... more geometry! Find out the equation for the surface of a torus, "rasterize it" properly, simplify the problem using the (obvious) symmetries of the torus and, finally, loop through the set of vertices you just defined and make the edges and faces as you go! See? Completely straightforward. 

First of all, in the case of axis-aligned rectangles, Kevin Reid's answer is the best and the algorithm is the fastest. Second, for simple shapes, use relative velocities (as seen below) and the separating axis theorem for collision detection. It will tell you whether a collision happens in the case of linear motion (no rotation). And if there's rotation, you need a small timestep for it to be precise. Now, to answer the question: 

Make two separate vertices. Make a circle around one of the vertices (the base vertex), that is within a plane perpendicular to the segment between the first two vertices. Hopefully you can make a circle using trigonometry, right? That's already all of the vertices of the cone. That's also one third of all the edges (there are n edges in the circle and 3n in total). Make n edges from the base vertex to the n vertices in the circle. You can make one half of the faces (that's n faces) as you do that. Make n edges from the tip vertex to the n vertices in the circle. You can make the other half of the faces (that's n faces) as you do that. 

Inertia is not a tuple (x,y,z), it is in fact a 3x3 matrix but in the case of a simple box, calculating said matrix within the set of coordinates naturally associated with the box yields a diagonal matrix (i.e. whose only non-zero entries are on the diagonal,so there are 3). The pdf you linked to gives Ix, Iy and Iz which are the three non-zero entries of the inertia matrix I (but I'm going to call it J because I is often used for the identity matrix). But if J had been calculated relative to a randomly chosen set of coordinates (if the axes in the pictures to the right of the table in the pdf hadn't been in these positions priviledging the geometry of the solid shapes in question) then the matrix J would have been much more complex and, in addition to Ix, Iy and Iz there would have been three other real numbers necessary to define inertia: Ixy = Iyx, Ixz = Izx and Iyz = Izy. Three additional numbers only and not six because J is symmetric. I don't know what was supposed to mean, but if inertia is going to be a vector, then you'd better make sure your solids always have nice symmetries and invariances with respect to the axes of your axis system. Classical mechanics tells us that J.(dω/dt) = T where T is the torque, ω is the angular velocity and dt is a small amount of time (your timestep). Both are vectors. To get only dω, i.e. the small amount of angular velocity that you will add to your current angular velocity, you need to multiply both sides of the equation by the inverse of J and then by dt: