Desura are fairly good for Indies - even free. They do have an approval process though, but it's more for the purpose of checking that you're uploading an actual game, and the one that you describe, and that it's not Copyright infringing, and that it works. I haven't put any on there myself yet, so I can't testify as to how easy or well it works. Source: $URL$ 

I'm attempting to program an offline puzzle game in C++. I'm trying to figure out the best way (particularly during the alpha) to report back to me 

But - as Byte56 said - there is no distinctly correct answer. The only asteroidy multiplayer 2d shooting game I can think of, if you want to see how another game approached it is the now free and open source "Allegiance". 

all this needs to be in your show method ( again for better readability if you want to respect Libgdx style ) then in your render method : 

I know it's the same but this is more readable, also you dont have to use stuff if your UI mainMenu is structured inside a like so : 

this code will look for body fixture which start being in contact with other objects in the word and I'm using to figure out which of my game characters is the listener and then if the game character is the Playron which will decrease the health of the player here is the 

Depending on what sort of game you are trying to make, you will need some place to put the actual game. A Facebook App points to external websites for the canvas part of the application. This is your own webserver/webhotel and what ever language your webserver uses ought to provide you with some database connectivity. So if you eg. use PHP on the server, MySQL might be the datasstorage. If you have a IIS/ASP/ASP.net server available, SQL-Express could be your answer. But with most server-side languages you can also remotely connect through IP to another database server somewhere else. You can also use API's to connect to webservices that allows you to put/get data from their storage. Some are SQL, some are Table and some are XML based, but if you have basic CRUDL functionality at them, you dont have to care about how they do it. Amazon AWS has something called SimpleDB which is a XML kinda storage. It has a great API too, but again, it all depends on your needs, economics and technical skills for implementing this. If you use Flash for a client, then you have the issue of how to communicate with a server to get the data in and out from the client. For this you also need the server-side "something" that can serve your data as needed and receive "POST" data from the Flash-client. So once you have a server, you know where you can put your data. To my knowledge, Facebook does currently NOT support native data-storage, but perhaps others can elaborate on this subject. 

It will limit the distance - which is OK, when not in combat with other ships at which stage it can be frustrating. Given that you already have the facility to zoom, what I would consider is the following: 

Understanding the separation between realistic physics and fun physics, I suspect real physics are still a really good stepping point as a starting point, and then hacking around the physics to make it fun. There is a fairly comprehensive guide to racing physics on $URL$ To be fair, I have only read small amounts of it and can not attest to its quality. I would then start working on special cases - so, for instance adjusting friction when braking to make it more playable, and 'nudging' the car towards driving straight in the correct direction after drifting. 

I think you should make the algoritm work differently. Place your "view" in an array (2D tilemap) and then look forward eg. 20 tiles. The "scroll" is the amount of pixels for 1 tile, so if your scroll becomes negative, just add the size of a tile, and increment offset for "view" with 1. Repeat until scroll pos is postive again. Then repeat this pattern each frame. Here is my suggested loop in pseudo programming language. 

The ScrollPos is the "fraction" of a tile. The viewOffset is the current screen/view position in the tilemap (left side of screen) Array/tilemap is needed pr. "row" of background. You could do this in multiple levels too, to produce a "parallax" depth - and with 3D this might look even more cool. 

you can simply use the box2d editor to match your sprite sheet with the body fixture there is a powerful application who do this for you : LINK you can : 

OK so I don't understand why you are extending but lemme provide an exemple of how to use the View port to fit your needs what ever the screen size: lets start with your show method you can get rid of keyword and remove and do something like so instead : create a public static attribut stage : 

it's quite easy to detect collusion in but you have to know that collusion depend on your Game object or characters which are created with box2d properties ( the BodyDef , FixtureDef..) so all your objects needs to be inside the then in your you just have to add if you are using eclipse the compiler will suggest you to override 4 methods theses two methods will detect all collusion happens in your physical world so if for exemple you try in the overridden method it will display the address of every object when starts to be in contact with another , and if you want to detect the collusion between a specific object and the world you do like so : 

Some people tells me I misunderstood the question, but others tell me that its a nice answer, so I will let it stay, eventhough its not providing an answer for an alternative Flash editor - sorry about that I'm currently moving FROM Flash and Actionscript 3.0 to Unity3D Framework. Its a GAME-ENGINE made for GAMES and there is a free "Indie" license where you get 95% of the engine features for free forever. You can later on, upgrade your license to PRO (1500$ or something) and then you will be able to use the latest game technologies for bloom-effects, realtime shadows etc. With Flash I had to develop everything from scratch and spend a lot of time preventing people from decompiling my sourcecode so they could cheat. Dont take me wrong, I like Flash, but it wasnt made for Game-development, eventhough its possible. Unity3D has never been made to make "banners" or "movies", but is a pure crossplatform real-time game engine. You can choose from webplayer (small plugin around 2 mb install) that works on both MacOSX and Windows. Or you can choose installer (real Windows EXE or similar MacOS bin) and if you buy the license, you can also transfer the games/applications to mobile devices, consoles like Xbox, Playstation and Wii. So, if you want to make sure that you develop on a gameplatform that also is "allowed" on Steve Jobbs iParanoid system, you should consider switching to Unity3D platform as I currently am. www.unity3D.com for more info. 

I'm writing a platform game which uses SDL for the main graphics code. There is a chance that I may be using OpenGL for the rendering at a later stage, so answers could relate to either. I'm needing a good method to include vector animations (such as a starting video) within the game. Being a platform game, I would prefer to limit the dependents and size of the data. This rules out using Theora as the resulting vector animations would be needlessly lossy and overly large compared to the rest of the content. Flash sounds like an OK option, however it is finicky to embed (or even use) on non-windows platforms, and requires significant amounts of dependencies. My idea is to use HTML5 animations, rendered by Gecko (the embeddable Firefox rendering engine) or WebKit (the Chrome rendering engine) in SDL, or rendered to an OpenGL surface in SDL. Quite simply - is this feasable? Are there any other examples as to how I should embed it? Is there a better (read: smaller and simpler) solution? 

One way to do this is create a kinematic body for each dynamic body as a 'shadow' body, with exactly the same fixtures. After very time step, set the position, angle, linear velocity and angular velocity of the kinematic body to match that of the dynamic body it is shadowing. The original dynamic fixture should be set to not collide with its own shadow fixture, and not to collide with the original fixtures for bodies that have a shadow body. When two sets of bodies like this collide, their shadow bodies will prevent the opposing dynamic body from pushing them, but they can still collide normally with other fixtures in the world. Keep in mind that Box2D tries really hard to replicate the physics we see in the real world, and what you are asking for here is not realistic at all. You will probably see some VERY weird behavior, especially if you try to pile these bodies up together, even though they follow your rules. However, for a top-down scenario where piling of bodies is not needed, it might be ok. 

You can tell Unity3D to use isometric rendering in the camera settings. Secondly, you dont use isometrical graphics on a plane, you just build the world in 2D/3D and let the camera make it isometric. I know this isnt a direct answer about rotation, but if you use my approach, your problem is solved. :-) I quickly did a Google search on the topic and found this tutorial on YouTube: $URL$ I also got some articles/tutorials on it, I think this one could be of usage for you too: $URL$ Remember, most of the time, someone else has had the exact same problem as you, so Google first. :-) 

PHP/Apache theoretically could do it. BUT - they are designed for making active webpages and will most probably not be the best tool for the job. You would be probably better off writing a server in the language of your choice - out of your familiarities, I would suggest Java or C++. Use the relevant sockets library, and code it directly. If it is a real time, though turn based game, I would use MySQL as a datastore, as it can interact with Java or C++ (or PHP if that is what you eventually decided to use). Make your server application Fork for each connection, read the current state of the game off MySQL and apply the rules (storing changes to the MySQL datastore, so any other players who connect will see the relevant data), provide accept the players input and output etc. This would also minimize the problems related to multithreading. However, using Forks as well as C++ (or, to a lesser extent, Java) will ensure scalability. I will warn you - I have limited experience in the area, so you can take my answer for what it is worth.