The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

Runtime improvement If you take a look at the last digit of the first few fibonacci numbers you will see that the digits are repeated after 60 numbers. As the digits in this range have a sum of you can calculate the sum for instead. Bug The task states that the given integer are non-negative, is a valid value. Currently you are returning i.e. for the range as is treated as , the initialization of sum has to be changed to: 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

The only thing I could think of that would make your program potentially faster is: Initialize the member variable using initialization list syntax 

Since you are dealing with only integral numbers as input from users, I would create a helper function to get input from users. 

After seeing your code the first time, something didn't feel right. I couldn't quite put my fingers on the problem. However, after going over the code a few times, I came up with a few things that can be changed to improve the code. Using the right nomenclature I think the nomenclature is wrong. Metre, kilometer, and mile are better thought of as units of distance instead of being distances. 12 metres is a distance but metre is not. Your use of distance and quantity is not quite right. Distance is a quantity + a length unit. When we say distance from point A to point B is 5 kilometres, 5 is the quantity and kilometre is the length unit. Design of the and various classes It occurred to me that your design violates The Open/Closed Principle. You have the following that's the lynchpin of your entire program. 

This implementation still feels like a literal translation of the for-loop approach. Streams offer options to improve readability, i.e. the inner loop can be flattened: 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

I am going to suggest couple of changes to your code. Providing a clean way to terminate the program Your code does not provide a clean way to terminate the program. Once started, you have to terminate the program by pressing the equivalent of Ctrl+C, killing the process form the Task Manager, or some such indirect mechanism. There are lots of ways to terminate a program cleanly. One of the easiest things to do is look for or as the first character of the input to exit the program. However, if you allow for such a method, you'll need to change how you receive user input and process them. Instead of 

Now, you can reverse regular s as well as temporary s, i.e. s, while paying the cost of making copies only for s. 

Parse an input string to construct a set of equations. Solve a set of equations to come up with a set of variables with the solved values. 

Minor changes As @coderodde already stated, there is not much to improve, nonetheless a few minor things: You can reduce the scope of the variables (which has always the same value as k prior entering the inner loop) and to the inner/outer loop. can be written as . Your inner loop starts at but only uses , you can start the loop at to avoid the subtraction. Depending on how s should be handled, you could use to throw a NPE if elements are present. If s are permitted, I would prefer that the string is added to the resulting array rather than a reference. You could start and at and use the (in theory) more efficient preincrement operator instead of the postincrement operator. Possible implementation (not using preincrement for and as I think it makes the code more difficult to read): 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

You get automatic memory cleanup. In your posted code, you don't have a user defined destructor. As a result, you have a memory leak. By using s, the default destructor provided by the compiler will take care of releasing memory used by the s. It is easier to iterate over the array. You can replace the following block: 

Does not use . Does not use dynamic memory allocation. Does not use virtual member functions. Uses class templates for and . Defines the units in an extensible manner. 

Since these functions are recursive, the check for whether the tree is empty should not be added here. Instead, they should be added in the functions of the same name. 

An Ace is to be put before a Two. Use the following order of Suites: Clubs, Diamonds, Hearts, Spades (the ordering used in the game Bridge). By that logic, Ace of Diamonds is greater than an Ace of Clubs. Using the ordering used in Bridge, Two of Diamonds is greater than Thee of Clubs. 

For O(1) performance you could precompute the factorials for values up to 12 (all factorials in int range). 

Besides that could (and should) be a local variable. The spacing between operators is inconsistent, you should add whitespace around the operators (except for unary operators) to improve readability. 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

Besides that I would rename the method as it prints the combinations, with the current name I would assume that the method returns the combinations. permutation This method is effectively a recursively written loop that returns the product of the range (=factorial, thus method should be renamed to factorial) and thus can be replaced with: 

Alternative implementation Your current implementation supports arrays with a maximum length of 30, you could provide a method to support arrays with up to 64 elements (or a larger datatype than to support way larger input arrays). 

I think or is a better function name than . When the function returns, the input indices are sorted/ordered. 

If you do that, the only member data needed in will be just the ID of the event. Suggested event handling code 

This will work only if you declare the function a friend of the class. Move parts of the class to the bottom The users of the class care only about the section of a class. Hence, it makes sense to put them first in the class. The section of a class are, to a large extent, implementation details. It is better to put them last in a class definition. 

I think is a misleading choice of name for a variable. I would expect to be the name of function. I would suggest using a different name, such as . It's used only in . If there is ever going to be one instance of in your appliction, which seems like it is, I would suggest putting as a variable in . It keeps the scope of the variable limited only to where it is needed. 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

Make functions still smaller You have functions that accept input, process the input, and display the result of processing the input. You can separate the first part the last part into separate functions. That will make your code easier to follow and maintain. For example, can be: 

Make a base class You can simplify the code in a few places by making a base class and creating two sub-classes: and . Refactored Program 

You are not making the links between the previous item of the list with the next item of the item being deleted. With your current code, the previous item's points to a deleted . You don't need a . A is sufficient. The code is more readable with the second definition. 

Now, you can use a class that captures results of an operation or a function call. It depends on and as its member variables. Of course, you can add as many convenience functions as you see fit to it. 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

If you cannot/do not want to change the interface, you can use an intermediate abstract class to have the forwarding method only once for all implementations 

Space efficiency: Currently you are storing 50% of all values, this can be reduced to 33% quite easily by not storing any multiples of . (Excluding additional values is possible but complicates the calculation between value and index, you might have to check until which point excluding values is advantaguous.) Sidenote: You reduced the space consumption by the factor 2*8=16, not 64, compared to an implementation that uses a (at least for the OracleJVM). Performance: You are iterating over each bit, I would use to process the bits in blocks of 32 bits. You might want to use multiple threads to sieve, a simple implementation could use multiple threads to strike of multiples of different starting values. (For comparison: my quite similar implementation that skips multiples of (and uses instead of ) is around 25% (singlethreaded)/60% (multithreaded) faster than your current implementation.) Implementation: You don't need the variable as it is equivalent to . Your current implementation may overflow for larger sieve sizes. I would iterate over the indices rather than over the values to avoid converting while striking values off. Possible implementation (the resulting array should be encapsulated in a class that provides methods to operate on the sieved values):