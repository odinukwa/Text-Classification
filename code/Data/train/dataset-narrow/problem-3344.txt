Older versions of the script would not have had step #1 because it was not required with older kernels. The i2c module would have been loaded by default, so "enabling" it was just a matter of making sure it wasn't previously blacklisted. Newer versions of the kernel require a line be added to ; you would have to reboot to make this effective. 

I think as per the other answers this is feasible in theory, but may not work out well in practice. I'm reproducing this graph from an article in our blog, Exploring the 3.3V Rail (thanks PM). Note that this graph shouldn't be considered definitive (keep reading): 

Those are the serial data bits, so again, there's a clock running at least 8 times as fast for timing, meaning all the receiver has to do is count. The furthest this count is going to be off is one tick, and that's not enough to misread an entire bit. For a mismatch in the clocks to problematize this, it would have to be whopping -- not like the equivalent of a second difference every few hours, but something closer to 10 seconds per minute. Unless they are damaged beyond any usability, as far as I'm aware crystal oscillator clocks used for hardware timing can't possibly go that far wrong. So, rule out the clock skew. 

The indicates there is currently no possible password which could be used for this account. The root user can change this, however, using the command to set a new password, which will replace the with the hash mentioned earlier (these always begin where is some random value that's used as the "salt" for the hash, but you don't need to understand that). Anyway, when I set up a card from a fresh image the first thing I do is go into and remove the so root's entry now starts: 

There's also a section there about how to find out what is supported by the display attached to the HDMI port: 

That's a pretty elaborate man page. Probably daunting at first but if you are doing things with 4 cameras, no doubt worth a read. From the looks of things the hue and saturation need serious adjustment. 

This is an anachronism that, again, will work for backward compatibility. However, if you are new to linux you should avoid it since the init system, , does not use SysV runlevels (so don't bother thinking in those terms). 

This may be because the card has just not been done right from the beginning, although if it ends up changed something is going on. Maybe. If, after you prep the card, insert it for the first time, and power on the pi, you see the green ACT light flickering intermittently, then it is booting and presumably ua-netinst is doing its thing. If instead you just see the green ACT light on solid or not at all, the card is not properly formatted and nothing is happening. 

1. Using an suffix is not really evidence that a file is executable either, although much like the permission bit in a *nix system, a DOS-esque OS may take it to mean that. You could copy that file to a windows box, rename it , and the system will probably believe you even if actually executing the file will do nothing. 

So if your clean-up is not too time consuming a SIGTERM handler should be fine. However, if this is a persistent service that runs from boot to shutdown, the best practice here would be to create an init service for it. I presume Arch on the pi uses systemd for this purpose. 

I wrote that these 3 things are important "before you go anywhere", because, with regard to learning, they will help you to understand what materials are relevant. For example, if you are using one of the normative linux distros (raspbian/debian, pidora, arch), these are the same as they are on an x86 based desktop. Pi users represent only a small fraction of linux PC users generally, so while I am a big supporter of this site, keep in mind there is a much larger GNU/Linux community out there (and an even bigger "unix-like" user community), and you would be wise to make use of it. The internet is of course (...naturally, even), a great resource for programming and technical material,2 and that coupled with hands on experimentation will almost certainly be the core of your learning experience. WRT to books, UNIX (or linux) system administration manuals are common (== easily found) and always worth looking at. If you are going to make use of the pi remotely and have a spare partition on another computer, I highly recommend you install a linux on that and work from there. Cygwin is something you should know about if you prefer to stick with Windows, especially if you want to do pi related programming. You can also run linux inside another OS via a virtual machine. Man pages are an indispensable reference. Like a lot of people I did not at all enjoy man pages at first, but the sooner you get to like them the better. They are the primary documentation (meaning, free from hearsay and misunderstanding, the "final authority") -- for basic commands and configuration files, and if you are squeamish about consulting them, you will end up wasting a lot of time. When you have questions about something, quoting something from a man page (e.g., something which has you puzzled or frustrated) is an excellent start. WRT Linux kernel features, the official source tree includes a directory with a lot of useful information in it -- probably most useful via a text file search tool such as (and see the switch in the man page). This directory is also available online. C/C++ Not everyone is a fan of lumping these languages together, but one is an evolutionary offshoot of the other, and it is worth noting that C was developed at least partially to revolutionize the portability of UNIX, and this unparalleled lineage of portability explains linux's adaptability as well. Many aspects of C's style have been a significant influence on most of the other widely used programming languages today. Linux (the kernel) is written primarily in C (with asm where required) as is pretty much all of the fundamental pieces of the GNU userland, which is why C is the "native" language of linux. While you don't need to learn C to learn C++, it certainly will broaden your understanding of it. Also, because C is so universal, higher level languages such as python, perl, and shell (which are in fact implemented in C) often "wrap" native library functions transparently, so understanding those native libraries will give you some insight there. The ISO compliant standard C library on linux (GNU glibc) is rounded out with extensions that come, for the most part, directly from the UNIX world. The GNU C Library Manual is a good introduction to these and system programming on linux generally. Man pages, which cover the entire standard library plus GNU extensions, are again the primary documentation. GNU C is also pretty much POSIX complaint, and the offical POSIX man pages are sometimes a better read than the GNU ones used on linux systems.