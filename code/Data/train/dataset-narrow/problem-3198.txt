Not all terminal devices support all capabilities. Once upon a very long time ago, "terminal device" referred to an actual piece of hardware; now it refers to an abstract device created by the OS or other software on top of actual hardware. Because of this, you can run into a few different "terminal devices" on the same hardware (and it is the same few on all common hardware). The first is a VT (virtual terminal, aka. a VC, virtual console), which is the basic "linux console" you get outside of a GUI context; this is based on emulating a VT100, which is a real (old) hardware terminal (I would guess the "VT" there stands for "video terminal", since it wasn't virtual). There aren't any alternatives to this AFAIK. The linux console does not support smcup/tmcup perhaps because the console is really a line interface, as opposed to a screen interface. However, there are screen interface libraries (such as ncurses) that operate within the terminal emulator (as opposed to something like X windows, which does not -- it supplants the VT); most complex console apps use something like that ( is more primitive). These are called terminal or console apps (as opposed to pure command-line apps) and includes editors like nano, vim, and emacs. You can tell smcup is not supported because, as documented in , 1 is returned to indicate this capability is not supported. 

If wiringPi doesn't set in this situation, then change this appropriately. Checks like this may seem like a waste of time when you are first developing something ("I'll go back and make all this properly robust later, right now I just want to see it work..."), but as this example demonstrates, it's usually more of a waste of time not to include error checking from when you first write the code. As in: if you are using a call you know can fail, wrap it in a check, now, not later! looks like a serial line to me, and I bet if you try you'll see: 

Change 2 (or whatever number is there) to 1, put the card back in the pi and boot. I doubt the result will be much more promising because I think the issue is with accessing the root filesystem (init can't find ). However, it might at least get you to a shell prompt, or provide you with some other clue. 

While there was no explicit setting, in , the is 600 and that's what the actual was (the pi is idle). Perhaps this has to do with being 600 and 900. 

I'm not sure that works (it really shouldn't...but that's tangential). You may need to instead to run . 

From the looks of this, you have to custom compile in order to change the hardcoded switches it supplies to in various circumstances. But that isn't going to make it anymore flexible if for some reason you change your mind because, e.g., this ends up having unintended consequences. Another choice would be to wrap so that it ends up called with the switch added. To do that first find out where the executable is with . It is most likely . Now check . is probably not the first thing in the list, which is checked in order. So if there's another dhclient in a one of the earlier directories, it will get used. This is going to be the wrapper: 

No. The only thing that's going to make a significant difference would be speed, and the hard deck there is determined by the pi itself, not the stick, presuming it legitimately meets USB 2.0 standards. Of course, I can't promise that some sticks aren't made better than others, but the fact that we don't see manufacturers trying to claim "Ours is the fastest!" is a big clue about reality here. 

Having a default policy and a catch-rule at the end of the chain seems pointless, but harmlessly so. This ends up as a practice because all chains have a policy, but only the built-in ones can be set; user defined ones are always RETURN, because user defined chains are only useful if at some point they can be traced back to a built-in; I believe those will default to DROP, but you can change them, and for other chains you can set a final catch all. So doing both for the same chain is sort of pointless but since there can be weird gotchas with iptables, not a bad idea. In that case, the policy should be REJECT or DROP, because it is going to apply to packets that have accidentally slipped through rules -- and since rules can be changed dynamically and nobody is perfect, being paranoid there is a good idea. But a default policy of ACCEPT is not exactly in keeping with this paranoia. The preferred treatment in a policy/catch-all should really be just plain REJECT, or better yet: 

Tshark requires special permission to use, or more specifically, to use it to monitor an actual interface. The instructions here are summarized from wireshark documentation and should be done as root (or via sudo). I have tested this on raspbian. First create a "wireshark" group: 

If you mean a network to which the pi is NOT connected, then you'll have to parse output from, e.g., . There's not much of a , look at . Referring to "looking for an ethernet network" to which the pi is not connected is not worth discussion so I leave it at at that. 

I've done pretty much exactly this using an 8400 maH power bank w/ a 2 A output. This will run the pi with camera and wifi for about 4 hours. Note I've never timed it precisely and I have not left it streaming over wifi the whole time, which would probably use more power. I have not noticed that the wifi range drops out toward the end of the battery life but I suspect it is possible. The battery is about the same size as a pi and the whole thing fits inside watertight tupperware. The battery produces heat, and the enclosure gets fairly warm, like 50-60 °C. If you do this you should watch the processor temp () and don't let it get over 80 °C. For the wifi, I have an extra router and plug it in as close to the pi as I can get. This is too far away from my ISP's router to connect it, so it's offline, but I can still connect to its WLAN with a laptop and thus into the pi. The limit on the range is the pi's adapter. If the router is outside or in a window so it is mostly just air in between, you might get that 15m. I haven't tried beyond 10m (with a nano size dongle). 

I am sure it will be fine. The newer zero obviously has the same footprint when viewed from above, judging by the placement of the screw holes in relation to the GPIO breakout. The camera connector is laid on its side. Although there's no picture besides a top shot on the Foundation blog post, in this Adafruit image: 

This presumes the SD card device appears as , which it most likely will if there's no other drives attached. I believe you'll have to reboot to make this work. 

Yes. The Pi requires a correctly formatted SD card in order to do anything. Otherwise, it is like removing the hard drive from your computer only worse, because the Pi has no BIOS/UEFI, and the CPU is bootstrapped by the GPU using firmware loaded from the SD card. 

maybe spurious here but doesn't hurt. See for what it does. If you want to get fancier, you can write a systemd service file for it -- you will find a lot of examples of such for online -- but if this works for you, then don't worry about it. 

And use that () in for brevity and to blackbox the current version string. To make it permanent, put that command in . Note that it applies only to the current shell session, so if you have added it in one GUI terminal it won't magically apply to a concurrent one. Also note that may not be run if you use a GUI login. To check just login again and . 

The first part is worth noting, because what defaults to on Raspbian is , not . You may want to look at to find out what the means. This may or may not matter to you and although you can change it to, e.g., (which is why I mention it), in this case you might as well leave it as is. When is run at boot, it is run by the init process, systemd. This means it is run with root privileges, so you do not need to use (and to prevent complication, should not). Although there probably is a valid set, to be paranoid you may also want to include absolute paths, meaning in this case . nohup The purpose of is to "run a command immune to hangups", meaning, ignore from the OS, which according to indicates "hangup detected on controlling terminal or death of controlling process". A process started via init does not have a controlling terminal, and its controlling process is init, which as per the wikipedia article will never die (or at least, if it does, it is replaced immediately and re-parents the children of the previous init process, meaning those children can never end up as orphans, and it is orphaned processes that end up getting a SIGHUP). So you do not need and should not use in either. If your process is mysteriously dying, that is not the problem and it will not fix anything. Backgrounding What will cause your process to die mysteriously is remaining in the foreground for more than a few seconds. Anything which is going to last longer than that should either fork itself and exit (leaving the fork running), which you can do in python if you want, or else it should be executed from a shell which does the same thing. This is a very common task for shells so the POSIX standard (which covers and ) includes the "control operator" to send a process to the background, which is accomplished by forking the shell itself, then executing the command from the fork. That allows the foreground shell to continue on, which with is important, because again, if it doesn't get to