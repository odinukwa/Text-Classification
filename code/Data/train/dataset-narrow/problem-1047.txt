If you do decide to make it a recursion, the overload of the method with the internal should be . does not actually get neighbours, it gets neighbours' values, and should be named . Don't iterate over values using - iterate over the values: 

First - be consistent - on one side check and on the other you check - choose! Using esoteric operators - the "spaceship" operator () is used when sorting arrays, and returns if is smaller than , if is larger than , and if they are equal. It is very rarely used, and your usage, while cute, might be very unclear for most (I know I had to double check what it returns). Is it really needed? Assumptions - you rely on the fact that is smaller than , which is smaller than , and you write your algorithm around that assumption. You are relying on an incidental fact, which might change when, say, you translate it to another language! Don't make incidental assumptions, use your code to define your rules. When there are too many exceptions to the rule - so you found a cool rule, which is good for [almost] all your cases. That is all but two, out of six... which is four... which is just about half the cases... Which you will need to explain to anybody who reads the code, since it is not apparent from how the code is written... Maybe it is not that good a rule? 

Since your list is not "all permutation", but is painstakingly built by hand, I would not suggest using array's API or something like that, but keep the curated mode you are using. I would suggest building it in a more readable way. In your way of it is very hard to follow which permutation exists, and which doesn't. The first list you show is more readable, and if you name your atoms correctly ( instead of ), it makes it trivial to understand what you are trying to do. I would suggest building your permutation table as a string like this: 

An empty interface is a code smell. In C# you can use attributes to mark a class instead of making it implement an empty interface. As I suggested in my comment, you can use reflection to build your instead of receiving it as input, and failing on discrepancy. With the power of attributes, you can add functionality by marking which properties you want to map, which to ignore, maybe add metadata (like the column index): 

and all the helper methods are no longer needed. Indentation and readability When parsing the time string you've got a piping block which looks like this: 

Before deciding to use more ternary operators in your code, let's understand what if/else is about: When the expression in the clause is resolved to , the block right after it is executed. If that expression is resolved to , and there is an block indicated, that block is executed. An clause is needed if when the first condition is there is still more than one execution option, based on a second(different) condition. In your code you keep checking one condition, and then the opposite one, although this is totally redundant. if is then is always , and vice versa. Asking the same question and then the opposite is not only redundant, but also a maintenance risk, since you need to change the condition, you need to remember also changing the opposite one. Also you should try to make all your conditions positive conditions - refrain from asking - it is far better to switch the and blocks and ask - the ! operator ("not") is easy to miss, and may cause confusion. Of course, if only one block is implemented - no block is better than no block - leave the condition as it is. To sum the above, a better code would look like this: 

As sorting by frequency works for every input type and not only strings, I would use a parameterized class instead of to support all types. Possible implementation: 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

MyWord Your / implementation is not conform with the specification of - equal objects can currently return different hash codes. The implementation of should return the hash code of instead of . The constructor performs no argument checks -> it is possible to create i.e. an instance with , which will lead to s thrown by the method. The method could return . Alternative implementation A priority queue is not a good data structure to determine the frequencies as you have to iterate the queue for each input element. You can use a to convert the input array to the frequencies with complexity (plus additional to sort the resulting frequencies, or to create a heap). Using the stream api this could be written as: 

Besides that could (and should) be a local variable. The spacing between operators is inconsistent, you should add whitespace around the operators (except for unary operators) to improve readability. 

Besides that I would rename the method as it prints the combinations, with the current name I would assume that the method returns the combinations. permutation This method is effectively a recursively written loop that returns the product of the range (=factorial, thus method should be renamed to factorial) and thus can be replaced with: 

In the array version you can use post/pre increment and pre decrement (most likely no difference in terms of performance but shorter and in my opinion better readable). 

The implementation 'does not count' as it overloads the method and does not override it. You can use generics to specify the expected parameter type. If you can change the interface: 

Currently each future processes elements (increasing the increases the total workload ()). Instead you want to divide the workload between each of the futures: 

Runtime improvement If you take a look at the last digit of the first few fibonacci numbers you will see that the digits are repeated after 60 numbers. As the digits in this range have a sum of you can calculate the sum for instead. Bug The task states that the given integer are non-negative, is a valid value. Currently you are returning i.e. for the range as is treated as , the initialization of sum has to be changed to: 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

The line in the first file means that ruby runs the second file before the first file, which is before the method is declared... Doing it the other way around will work, since only when is called is the module is required. dialect/dialect.rb: 

I believe the easiest way to avoid duplication each time you read from the database is to create a which receives a as a parameter, and does the heavy lifting: 

This will never be true - as is considered an indicator that it is invalid, and will then prompt the user for a new number... It is unfortunate that java does not have like in ... You can, however use boxing to indicate an invalid number as . This way - all valid numbers are fine, including . 

Naming - the method implies it will find the inside the , which, of course it doesn't - a better name might be or something like that. Also, your has and . In most implementations of a node tree, and implied the node's children. In your case, for clarity - I would have called those methods and . Algorithm I assume your node implements (because you are using descendingIterator()) it would be useful if you've added that code, so complexity will be more easily calculated - how does it know if it is lower than another node? Maybe I've missed the correct definition for 'lowest' from your description? The sample tree you've shown is not very clear... Complexity Your algorithm's complexity is \$O(n) * (O(i) + O(f))\$ where is the number of the nodes in your tree, is the complexity of inserting a single value to the (), and is the complexity of finding a single value to the (). Assuming the is of complexity \$O(1)\$, AFAIK complexity is \$O(log(n))\$. This means that your algorithm's complexity is at least \$O(n \cdot log(n))\$ To achieve complexity of \$O(n)\$, I would choose a (which has complexity \$O(1)\$ for inserting and finding elements) over . Then in the last part of the algorithm, instead of returning the first mutual ancestor, return the lowest mutual ancestor: 

If (even when the buffer size is more optimal at 1024) you still have memory issues, it might be because of ... you could use some other methods to make to conversion, as suggested here, for example: 

If this is what you actually wanted, you don't really need all the temporary artifacts in the middle - simply do it in one swoop: 

I don't see anything wrong with your implementation - if it works for you, and does not interfere with the system - go for it! I will even go further and claim that the guard conditions in your internal constructor are redundant because the constructor will only be used by the single public constructor, or by a test which: 

Regarding and , @BroiStatse suggested caching , and I'll say - you don't need to cache ! Once you have used it, you don't need it, so if you load the XML on initialization - you don't need to save at all: 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

Current approach You can determine the exact count of days in the mask beforehand -> you can use a better initial size than for the array list (or directly an array as the size is fixed). You don't have to sort the list (and thus don't need the comparator), rotating based on the is sufficient as the order of the days does not change. While this is very ugly: You could replace the with . Regarding your edit: This seems like a very bad idea if you ever want to make your app multithreaded. Alternative implementation You can avoid rotating the resulting list if you start interpreting the at the provided instead of . 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

Minor changes As @coderodde already stated, there is not much to improve, nonetheless a few minor things: You can reduce the scope of the variables (which has always the same value as k prior entering the inner loop) and to the inner/outer loop. can be written as . Your inner loop starts at but only uses , you can start the loop at to avoid the subtraction. Depending on how s should be handled, you could use to throw a NPE if elements are present. If s are permitted, I would prefer that the string is added to the resulting array rather than a reference. You could start and at and use the (in theory) more efficient preincrement operator instead of the postincrement operator. Possible implementation (not using preincrement for and as I think it makes the code more difficult to read):