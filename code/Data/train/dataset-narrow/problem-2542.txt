Three points, A, B and C define a plane. The lines AB and AC are both on the plane, so their normalised cross product, perpendicular to both lines, is the plane's normal n: n = normalise( (B - A) ⨯ (C - A) ) The equation for the plane is given by: n · x + d = 0, where -d is the displacement between the plane and the origin in the normal direction, i.e.: d = -n · A. An arbitrary point x can be described as the sum of two vectors, u pointing from plane to point in the normal direction, v being the other component: u = (x · n + d) n v = x - u The mirror image of x can then be calculated by flipping the u-component: x' = -u + v. Now that x' is known, capturing the calculation in a transformation matrix is trivial: solve T x = x' for T. 

You may want to cap the angular velocity to zero under a specified magnitude. The integration method is very crude and given enough time to settle, the timestep will eventually be too large and the rotation will overshoot its target. The resulting oscillation might even consistently increase in amplitude. An example: Imagine the rotation being very close to its target. As it comes closer, the angular velocity should gradually decrease until it eventually stops. However, the angular velocity isn't constantly updated; it is updated once every timestep. During these steps, the angular velocity should be decreasing, but instead, the rotations keeps changing at a constant rate. Below is what might happen. 

It's a little difficult to figure out what you're trying to do here, so let me start out by rephrasing the question as I interpreted it. An object has a known initial position and is initially facing a specified direction. It can only move in the direction it is currently facing, but this direction is variable; the object rotates. The rotation is described by an angular velocity which is a linear function of time. The magnitude of the velocity is also a linear function of time. You want to know where the object is after it has flown about for a set period, but you are unable to simulate its motion in timesteps small enough to simply keep track of where it is, how fast it is moving and in what direction at all times. Since both absolute as angular velocity are linear functions of time, the differential equations describing this motion can be solved analytically, but their solutions are ugly nonetheless, involving a bunch of Fresnel functions: 

Whether you let the in-game price converge to the real world prices by 2% per hour or some other system, the knowledge that they somehow will converge gives players a lot of certainty about the development of the stock market. If you want the recognition of rising prices to leave uncertainty about whether they will continue to climb, I would be very careful in offering tools to manipulate the market that have a predictable effect after they've been initiated. To maintain the uncertainty of the real stock market, you will have to avoid the in-game market lagging behind. As far as bandwagoning goes, it depends on what a player's objective is. If the goal is to make money, nothing will stop me from getting on board with the same shares the strongest player bought, knowing he will devote his resources to driving these prices up. If the goal is to outwit other players, there already is a lot of feedback discouraging this play, even with complete information. Buying shares from the same company reduces incentive for people to drive the price up, since that would be advantageous to their opponents, and increases incentive for competitors to bring the price down. The only non-speculative way to determine whether this feedback works, is through playtesting. 

If you didn't think these equations were getting out of hand already, you most likely will if you were to add more forces to the model. Unless you feel the need for the accuracy and speed these equations can provide, I recommend sticking with code that fellow mortals can read and maintain. 

This coordinate system allows us to describe a point in terms of the angle φ in arguably the simplest way possible, i.e.: x = cos(φ), y = sin(φ), while avoiding reflex angles. If you dislike negative angles, you could allow reflex angles, move the wrap-around point to the right and take the angular range from 0π to 2π instead. The point marked in the circle above would then be at φ = 240° rather than at φ = -120°, which is not the most convenient way to measure the red angle, though equally valid, e.g. should you need to find the x-coordinate of the marked point, both cos(-120°) and cos(240°) will yield the same, correct answer: -½. 

Stabilising the delta time is your only option. If we could change the time step of a numerical integration and were guaranteed to get the same results, we could exploit this to get really accurate calculations with barely any computational effort. Unfortunately, there are no free lunches today. If you change the accuracy of your simulation, the result could change. If you're okay with the results changing slightly, you could opt for a different integration method. Verlet integration performs a lot better than Euler in your example: the position after 40 ms will be estimated at 480 with Δt = 40 ms and at 480 with Δt = 20 ms, but they too will vary if you introduce a non-constant acceleration. I am not completely sure what the effect is that you want to pursue by changing the time step, but if you're looking to create a slow-motion effect that only affects playback, you need to decouple the simulation from the framerate. An example: your simulation normally works with a Δt of 10 ms. Every ten milliseconds, you advance the physics by one tick. The game runs at 25 fps; you redraw the screen every fourth tick. If you want to slow down to half the normal speed, you advance the physics by one tick every 20 milliseconds instead, but you keep Δt at 10 ms (because that's the time that has elapsed in-game). To keep a constant framerate, you now have to redraw the screen every two ticks. Regardless of playback rate, the results will be the same, but this method has other disadvantages. You can't draw a new frame until at least Δt has elapsed in-game and because that value is fixed, there is a limit to how slow you can go without the framerate dropping. You can push this lower limit by selecting a smaller value for Δt, but you'll be wasting resources for accuracy you don't need at normal speed. Eventually, your game might not be able to run at normal speed at all, if one tick is still being calculated when the next one is scheduled to begin. 

You wouldn't stretch the ground. As you gain altitude, you can see more of the terrain as the horizon expands, but it also appears smaller. The terrain covers less of your 2D projection in the air than on the ground. The difference is where previously unseen parts of your skybox will appear, and they have to show up as skies. If at any point the bottom face of the skybox is visible, which seems unlikely unless the box is centered above the camera or you're reaching absurd altitudes, then that side too should have a neat blue texture with clouds. 

Visualise a graph of rotation versus time that gradually drops to zero and notice there is an infinite number of ways of drawing such a graph. First, you'll have to specify how you want the angular velocity to decrease. Formulate a function ω(t) that equals the starting angular velocity (s) at t=0 and drops to zero eventually (t=T). Tune the variables to match the following criterium: ω(t) integrated over t from 0 to T equals the rotation yet to be covered. An example: I want my angular velocity to decrease in a linear fashion, i.e.: ω(t) = s + a t. To find T, we solve: s + a T = 0, ergo: T = -s/a. Integrating yields that the angle covered in this gradually decelerated rotation equals -½ s² / a. Solving for a gives us the desired angular velocity at every timestep, which we can numerically integrate as we go to find the current angle, or do this in advance to obtain a function angle of time which we can use directly. 

Extra Credits has devoted an episode to so-called 'core aesthetics', the main reasons a game appeals to us, and provides a non-exhaustive list as a more accurate basis for defining genres than what we normally base our distinctions on. Nearly all games I've played fall into a few of these categories: 

You don't need trigonometric functions for this. With fairly simple vector algebra, this can work for any viewing direction. Consider the normalised vector n (the yellow line) and a vector pointing to an object, x. The object is in the field of view if: n &centerdot; x > a |x|, where a is a number between -1 and 1 indicating the view angle (cos φ/2 = a). In components (2D), using n=(u,v) and x=(x,y): 

Normalised vectors have the same length by definition: one. If you want to scale them to an arbitrary length L instead, multiply them (or their components) by L. Note that the examples you have provided are not normalised vectors. To normalise, divide the vectors by their magnitude. For example (component-wise, as I do not know the extent of vector algebra support in your environment):