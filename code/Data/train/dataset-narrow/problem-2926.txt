HTML/markup languages can write things you put in. Python/programming languages can calculate the things to write. Ex (numbers 1-10): 

Introduce them to git/open source/collaboration by creating an "open source" project on github, involving whatever languages you're using. Open issues and have students assemble into teams and work together to solve problems. After some time doing #1, help them find their own open-source projects (see first timers only). Be there to assist, but let them give it a go. Help them explore prominent (most widely used in industry) languages even if they aren't in your curriculum - let them dabble in web design in a Java-focused class, for instance. Prepare throughout for a "final exam" - an "interview" and accompanying project with people from companies. Help them arrange internships for bonus points! Teach them about interviewing, resumes, professionality - none of it is gonna hurt. 

It's a balance, as with all things. Concepts are of course more important than vocabulary, but it's awfully hard to convey your questions and ideas without vocabulary. Just look at some old math papers (like, really old, before the invention of the plus sign old) to see what I mean. A couple of checks to make sure concepts are coming first: 

Don't go too far! Technology isn't the solution to your problems. I say this because I honestly have seen teachers who see technology as this magical god that will swoop in and save them from their troubles. A lecture that's pure powerpoint and talking and example can be great, and a lecture that's got every little tech widget and infographic and diagram can be a drag. The real solution is to think about what you want to say, and say it well. I had a math teacher. He had fifty minutes for class. Most of the time, he spent only fifteen to twenty minutes on the lesson, and then let kids get going on the homework, and spent that time bopping around helping those who needed it. Everyone loved that class, because he explained things succinctly and well. Note that that was an "advanced" class, but I really think that things are no different in normal classes. I'm not saying you should use only part of your class time - I'm saying you should be succinct. It's said that if you give a man a fish, you feed him for a day, and if you teach a man to fish, you feed him for a lifetime (excepting that one SMBC comic). I would adapt it to say that if you spoonfeed facts, you teach them for an A, if you let them discover facts, you teach them for life. So the more examples, interactive work, and intuitive explanation you've got the better. There was a day in geometry where we were talking about arcs. The teacher put the formula for arc length up on the board. I looked at it and started zoning out, like, where did that come from? And when I went home that day, I ended up looking up what the definition of a radian was, and I figured out how to derive it. I will never, ever forget the formula for arc length, or how to derive that $2\pi \text{ rad} = 360^\circ$. Ever. Practice your delivery, and nail your presentation. Like @BenI. says, don't give them a wall of text - give them animations and diagrams, that aren't gimmicky, but say what they need to say. Exercises, follow alongs, challenges, all good. Over reliance on tech to hold attention - bad. 

First, your classroom needs to be comfortable. No one's going to do well if they fear being called nerdy or some such nonsense. I myself have unfortunately been insulted along those lines, and though I ignored them (I figured, well, I've got better grades than them, so probably a good thing) it was hard to. Second, start small, work up. When I first started trying to teach myself things that I didn't just come across in pop-science books, it was hard. Really hard. But it's gotten easier as I've gone along, so I've started tackling more ambitious projects. No one's first program is a complete GUI in assembly with some animations to boot (exaggerating, but you see my point). If someone's been beating themselves up personally for a lifetime, it's gonna be hard to change. So start by giving them little things. "Go teach so-and-so about your method." "Try this problem, I know you can do it." Do it in private so any failures aren't public. Slowly build up their confidence. And one day they'll walk into class and rock that exam. And they'll feel on top of the world. Third, consider out-of-classroom problems. Unfortunately, it's a sad reality that not everyone's home life is good. Families are poor, broken, or otherwise messed up, and that can rub off on people. If someone's been insulted their entire life - well, that's hard to change. Connect such students with counselors, and build them up as much as you can. Fourth, show them your own failures. Others have already said this, but I'll say it again. I get annoyed when all this buzz is made about child geniuses and their magic talents. Yes, they're smart. But no story ever shows the hours of practice and work that went into it. No one ever walked up to a piano for the first time and aced a concerto. They started with Chopsticks, and 10,000+ hours later, they were playing their own composition at Carnegie Hall. No one ever walked up to a computer the first time (not Bill Gates, not Steve Wozniak, not Mark Zuckerberg, not anyone) and wrote an operating system or search engine. They started with Hello World. Show them how real people actually operate. We start somewhere. We work hard, we advance, we make mistakes along the way, and we advance some more. None of this magic wand stuff. Things that are worth doing are hard. They require work. Every time I've put effort into something, significant effort, I've been proud of the result. Finally - show them off. Show everyone the amazing work they've done. Brag on them. They're your students, they're surviving your class, they've come this far. They're worth it. 

The above, while a pretty useless function (I'm terrible at thinking up functions with no purpose =P), does a lot more things than a function in math does. It does some things on the side, returns some stuff, takes multiple inputs and outputs, and so on. It's a complicated beast. Heck, you can even write a function like 

Start by independently solving smaller problems. The Euler problems are great for this. Set specific goals for what the program must do. Then you know what needs to be done, exactly. Much like requirements in the "real world". Break the overall project into chunks, considering the requirements. I.e., if the project is a video game that requires a GUI, chunk one might be figuring out how the heck to create a GUI. Choose a project appropriate for your experience level, but also don't be afraid to plunge in. There's a balance here. Never, ever, ever feel like using Google/Stack Overflow is cheating. It isn't, or if it is, cheat away. Have a cheerleader! For me, I can sometimes talk about what I'm doing to my mom, and she'll be like, "Yeah, that sounds great!" And occasionally, this bonuses as "I'm working on this problem - see, ::explanation:: oh duh, that's what's wrong!" ::races back to computer:: That has happened to me quite a few times. Work at it consistently, but try not to get burned out. Staying up really late is a no. Working on it for several hours at a normal human time is a yes. Comment your gosh-darned code!!!! I learned this the really hard way, many times. Learn to use Github. Last one I can think of right now - set up your programming space in a comfortable way, then you'll actually enjoy working on it. Right now, I have a nice setup where I can plug a bigger keyboard and mouse into my chromebook, and we also had a monitor in the house that commandeered, and I set up the chromebook so it dual-boots Linux awhile ago. I installed all the various packages I use (numpy, scipy, etc) and programs (IDLE, git, etc). Basically, make it so when you start coding, you can actually just code. 

Before our teacher started talking, he'd tell us to turn to the front (for the people on the sides, see diagram below) or tell us to shut off our computers for the moment. Our classroom was set up similarly, and as our teacher was talking up front, he'd walk up and down the middle aisle a little bit, and if he saw someone not focused because of their computer, he'd go over, still talking, and use a quick keyboard shortcut to log them out. Of course, it wasn't a large class, so it wasn't as difficult to keep track of everyone. The classroom looked something like this ( is a computer, and are walls; the teacher's desk was at the back, while whiteboards/etc were up at the front): 

Tl;dr: use python. (Preferably python 3.) Well, I’m a teenager in your age group, so hopefully I’m some level of qualified to respond. I have to say as a bit of a disclaimer that python is my favorite language but it is in that position for a reason. Scratch is, for me, annoying to write because I can touch type so python is just faster. Further, I actually have always found scratch a bit non intuitive while on the other hand I have always found python incredibly intuitive but also very powerful - it grows in capability along with you. When I first started programming I used khan academy’s introduction to JavaScript, and then at some point I transitioned to python and have used it since. I have never felt either overwhelmed by or limited by python. My next thought would be that as 14/15 year olds, you’re going to have kids with a wider range of abilities and python can handle that better than scratch. There are as has been mentioned many resources for teaching python out there. I’d recommend codecademy for learning and repl.it for personal projects - they can then access their work when the camp is over and it provides autocomplete and other useful features. Another thought - since python has so many packages, maybe let them split up by what they are interested in? Python can do websites, games, scientific programming (math fans can work on the Euler problems), or mod Minecraft. (Scratch, I might point out, is limited to games.) Hope this helps, and I’d be glad to talk with you more about resources, etc. 

They're doing the same things; the for loop is just a condensed version. Tl;dr: a for loop looks for the boundary conditions, and then does what it needs to do, rechecking with a redefined variable accounting for the change that has been made. You input what change needs to be made to the variable to account for the action. 

When teaching an intermediate or advanced highschool programming class that also touches on general CS concepts (algorithms, etc), what are the benefits of explaining low-level computer architecture? How much added understanding of programming/computer science does a student get when learning about logic gates, for example? My question isn't a duplicate of Is it more effective to teach low level languages before high level ones or vice versa? as it's asking about logic gates, registers, instruction set architectures, etc, and the benefits of teaching those in a programming class, not about low level programming languages in particular. 

I'm reading quite a bit about quantum computing, especially optical quantum computing. Part of the problem is even the all-encompassing bible of quantum computing (Nielsen and Chuang, Quantum Computing and Quantum Computation) has only 10 pages on this particular physical realization. Other textbooks, by the time they're published, are already out of date. Hello, reading scientific papers! Of course, there's a problem associated with that - results are retracted, new ones encompass and expand upon old, and papers are rather notorious for being difficult to slog through. Having slogged through a few myself, I can tell you that notoriety is well-deserved. Worse (for the self-learner), most papers are focused on only a specific problem. All this isn't to say that papers are bad, just that sometimes other materials can be nice, and learning from just papers is difficult. How can one find materials other than papers to learn from in a developing field? 

It's got a nice setup for classes - each user has a profile with a public and a private gallery. You can add collaborators to projects, set up some form of "class" on the system, though I don't know quite what that entails, etc. Here's a screenshot of the coding environment with some code for a project I did in it: 

It's about setting boundary conditions first. Provide them with a more concrete example, like filling a glass of milk. You kind of need a glass or container (let me know the next time you pour milk right on the counter) and that glass is some amount full. We'll just treat it as empty. Then, you stop filling the glass when it's full (or half full or whatever), unless you want milk everywhere. Within those boundary conditions, you pour the milk jug. That is, mentally, you're thinking (in not so many terms): 

What will we see? Well, it is quite obvious that the first thing printed is "5"; I doubt there will be much confusion there. Now, the next line is squaring the previous , i.e., squaring 5 ($5^2$) and then setting that equal to , so now we basically have the line of code - which produces 25. All very well and good, now we do the same thing - so we basically have or 625. The difference between those two and what they mean is a very useful and important distinction, but to be honest I think it's not completely unintuitive. Once explained the former is a test and the latter a definition, I think students will catch on fairly quickly with a reminder here and there. Now we come to your last (well, first) type of equality. $x = x^2$ is a statement of definition, but it can also be manipulated. In python is a definition, and it accesses the previous definition of to "solve" it, like we did above. However, to solve $x = x^2$, we move terms around the equals sign - this is a quadratic, so we get $0 = x^2 - x$ and we can factor out the $x$ so $0 = x(x - 1)$ so using the zero product property one gets $x=0$ or $x=1$. We can solve equations like this in Python, but that's not automatically done when you define , instead it uses previous definitions. I hope that conveys what you are wanting, but I really don't think you need to bring up your first definition of equality - the rules of that have been drummed into them from math class, and the new rules of equality appear distinctly enough that I doubt they will be confused. Now, all of the above is with a nice, good language like Python. Some other languages have , , and . I'm not qualified to get into that, but this might not be valid for such craziness.