janos has given you some nice hints about your random, and array indexing. I believe you should take it further, though. Specifically, your system should be parameterized. I would expect there to be three parameters: 

Your code indicates that you have a serious problem with your object oriented design. Objects are supposed to be 'opaque', and you should not be able to see the structure of the data in your object. Instead, you have this code, which is somehow able to access: 

The idea was that if any one disk failed, I could replace things with minimal loss. The OS was supposed to be stuff that was easy to reinstall. The 'valuable' things are data that is irreplaceable (e-mail, photos, documents, etc.). The backup disk contains a copy of the valuable data. I also have learned (a long time ago) that keeping backups of your current data is not very useful if you corrupt (or delete) your current data, and then replace your backups with the corrupt version. As a result, I keep 'snapshots' of my valuable data at regular intervals, and I can go back to any snapshot to retrieve the data as it was at the time of the snapshot. If I delete a file now, I can go to a previous snapshot, and restore it. I started using a script written in bash to do this for me.... Mike's handy backup script! This worked for a while, but I discovered it had problems: 

Those loops will never happen..... what gives? Is the , , and array population completely unnecessary? 

There are two aspects to this, the general design, and the implementation. Implementation The entire things should be extracted as a function. The first line of code: 

General Your code style here is good, the variable names are nice and descriptive, and the algorithm you implement is easy to identify and follow. This is good-looking code. There are a few of nit-picks: 

There are some obvious items, and then some not-so-obvious ones, that should be addressed. The most obvious, is this line here: 

You do have a problem in your code that you have the 'magic-number' 7 embedded in your code. I have copied/pasted your code, and I have left the magic values in the method. Compare that with the other methods, and see how it can be done... I have also split your main method in to different methods, so the logic is more discrete. When you put it all together with a recursive method that 'handles' the out-of-bounds cases, it all looks pretty simple: 

Note that in a raw performance benchmark, I suspect your solution will be (slightly) faster, but I prefer readability over small incremental performance gains, unless performance is extremely critical. 

With the right stream, you can do anything you want, count, sum, etc. The Stream is self governing. Now, the problem is that it is not easy in Java8 to create a self-terminating open-ended stream. The solution to the problem is to create your own spliterator. Consider the following code which does create a valid LongStream using an OfLong Spliterator: 

That regex does not meet the requirements of your rules... so ... No, it is not OK. The missing aspect is that the regex requires at least two characters, but the rules say one char is OK. Also, I don't like that the last group has the on it. While it is accurate in the sense that the last characters can be alpha/digit, it implies that the rule is for more than just the last character. Another problem is that you allow logins of more than 20 characters. A more meaningful/accurate regex would be: 

At least this allows us to see what you are doing. Algorithm A nice algorithm will take data from the input string, and add it to the output if it should be added. A system where you do multiple conversions, add things, and remove things, is complicated, and hard to follow. Additionally, the null character is actually a valid character in Java, so you may have (an extremely rare) bug. I do not like that your code is removing all the duplicate values, it seems more practical to remove all but one of the duplicates, but you do not explain why it is supposed to be this way. More Information required The above, in itself, is a review, but, if you update your question with the requested details: 

The bottom line, is that, since your implements , the list it wraps should have a meaningful implementation of both and already, and, as a consequence, there should be no need to re-implement or override the method at all. If your method is not working using its base/underlying implementation, then you have a bug somewhere else. I would simply use and methods directly on the UnList interface using default methods that caller the inner version, like you have done with most other methods. 

The reason is not specifically for readability, but for maintainability. Consider the change you made in your answer, merging two loops. You converted the above if-statement to be: 

General This is a nice challenge. Your algorithm/approach to the solution is a good one in general (it can be tweaked a bit), but your implementation is a little ... spoiled... by using the static variable space for storing state. Your mixed-up use of naming conventions for variables does not help either. Some of the content belongs in the static space, like , , and , but the other static variables are not statics, or should not be. You should consider creating an instance of your class for the problem, and then using that instance to manage state, instead of keeping things static. For example, if your main method was: 

This strikes me as best being done by using a temp table, or clause. Also, the DISTINCT part worries me.... why is that needed? Are your joins not good? Still, I think you may have some more contentment with: 

It is guaranteed that there will be an instance created for you on the first call from a thread. Getting good seeding Your seeding system is both complicated, and wrong. If you are looking to have a special random generator that you feel out-performs the existing Java Random class, that's OK, but, it needs to be seeded right. There are a few problems in your seeding that I can see. First up: 

Update: additionally, your method should be so that no subclasses can change the behaviour of (same is true for ). If the method is not final, then a subclass could possibly override the method, and do it in a way which make the / mutable. Note, that the constructor for , in this instance, takes a value. This leads on to a suggestion that the immutable class should store a instead of a . The is immutable anyway, if final. 

I prefer a mixed approach for situations like this, and a second problem is your code duplication. Let me describe the mixed approach: You have a monolithic event handler, that handles the for all targets. Each of those events should be in a different function in your code. For example: 

and also in the calls in the checks. If you change your method signature to be a generic method like: 

It has already been pointed out to you that the remove process should use some form of locking... using a simple ArrayList will lead to corrupt lists as each of the 100 threads may try to modify the list at the same time. I suggest a different approach. I recommend creating a thread for each server you want to monitor. As the server comes available, it adds the server to the 'alive' list. As the server 'drops', it removes it from the alive list. The simple Socket connection to the server is all you need to worry about when it is alive. The monitor thread can sit there waiting for the socket to die. If it dies, it tries to reconnect. You can choose a different approach for monitoring the TCP state, but, the model of having a separate continuous thread for each monitored server, and the concept of having a maintained collection of 'alive' threads is the important part. Consider the following class, which has a convenient Main method: 

I think, when I run your program, that the combination of text-console and swing user input leads to a bad experience. Really, given that you have the GUI input boxes, why do I have to type the row/column that you want entered? Why not present me with a grid of buttons, and I have the number I can add to the grid, and I just click where the number should go? Doing such a grid would potentially even be easier than the text output you put on the console. Despite that, I do appreciate that the code is runnable, and works.... until I press the cancel button, at which point the code throws a . As for the code style, it seems awfully complicated, with a lot of code repetition and 'magic numbers'. Changing the size of the grid would be very frustrating.... it is all hard-coded in. So, you should set up a constant, say 'gridsize' and use that in many places: 

Your code does the task at hand, and that's a good thing. It's pretty quick too, an that's great. What your code lacks though, is a sense of readability, and maintainability. There are also a number of potential bugs, and some variable shadowing. Slices My initial beefs with the code are that it depends heavily on constants, and on fixed arrays, instead of slices. In general Go favors slices over arrays. Consider this method: 

This is a 'specialized' task, converting an input string to a double value. Whenever I have micro-tasks like this I try to refactor them in to a method which does things properly. As far as I am concerned, neither of the above two systems are valid. You should be validating the input value to make sure that, even if it is populated with a value, that the value is meaningful, and the parse succeeds. So, I would have a function: 

This SQL, for what it does, is neat, and concise. There is no obvious place where any optimizations can be made. With the data size as small as it is, there is no reason to recommend indexes, or other improvements. The only glaring issue has been pointed out already: There are tools other than SQL that are designed to do these types of heavy computation with performance that your database just won't beat. Apart from anything else, the log functions are notoriously hard to get right, and there are multiple 'standards' for implementation. Consider math libraries designed for data and computations such as this.