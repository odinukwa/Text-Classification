For years I have been running dedicated servers with more or less limited ressources, resulting in unsatisfying performance of the web application (Drupal). Tools like Matthew Montgomery's MySQL Performance Tuning Primer and Major Hayden's MySQLTuner always suggested parameters that required more RAM than those servers had. Almost every article about database performance repeated the same mantra: "rDBMS require as much memory as possible to work fast", "you can never have enough RAM". When I set up my latest dedicated database server a couple of months ago, I learned that this isn't the whole truth (most of you probably will know this already). The current database server (Intel Xeon E5-1620v2 @3.7/3.9 GHz, 4 cores/8 threads, 64 GB RAM) isn't even excessively well equipped, however I have been unable to make full use of it's available memory because MySQL 5.5.37-0+wheezy1 (Debian) won't become faster if the relevant tunable parameters get more ressources. In fact, above a certain "sweet spot", MySQL's performance becomes worse than it is with less RAM. This was an surprising finding I hadn't expected. In the past weeks I did some research and ran lots of tests; my results are consistent, and others experienced similar limitations of MySQL as well and documented it on the web. Some examples: query_cache_size - defaults on Debian to 16M; in my case, the "sweet spot" appears to be between 256M and 512M. With 1G or even 2G, performs significantly slower than with the default 16M (cf. stackoverflow.com/questions/2095614/mysql-query-caching-limited-to-a-maximum-cache-size-of-128-mb, blogs.oracle.com/dlutz/entry/mysql_query_cache_sizing). join_buffer_size - started tuning with "256" and increased in small steps to "15M"; with more memory, MySQL gets slower (cf. dba.stackexchange.com/questions/53201/mysql-creates-temporary-tables-on-disk-how-do-i-stop-it). tmp_table_size and max_heap_table_size - those default on Debian to "32M"; I increased those values in small steps to "12G" each; with more memory, MySQL becomes significantly slower and - even worse - the number of temporary tables created on disk does not decrease. It's always around 36%-38%, no matter if tmp_table_size and max_heap_table_size is "25G" each or "10G" each. Actually I'm currently working my way back down again to find the "sweet spot" (probably below "10G"; cf. dba.stackexchange.com/questions/53201/mysql-creates-temporary-tables-on-disk-how-do-i-stop-it). innodb_buffer_pool_size - I started with "1G" and increased to "24G". More memory does not result in better database performance (cf. www.mysqlperformanceblog.com/2007/11/03/choosing-innodb_buffer_pool_size/; dba.stackexchange.com/questions/19164/what-to-set-innodb-buffer-pool-and-why/19181; dba.stackexchange.com/questions/39467/mysql-performance-impact-of-increasing-innodb-buffer-pool-size; dev.mysql.com/doc/refman/5.0/en/innodb-parameters.html) Bottomline after three months of trial & error with the MySQL configuration: Even on heavy load, MySQL plus OS do not require significantly more than 25 GB of RAM. If I force significantly more RAM upon MySQL, the web application becomes slower than when running with an MySQL with Debian's very conservative default settings. The most plausible explanation for this behaviour I could find is, that MySQL's caching algorithms are buggy at some point and/or not fully optimized. Currently I'm in the bizarre situation to have 1/2 - 1/3 of the database server's memory vacant. For the time being I added some of it to a memcache cluster (currently using 26G of the server's memory accordung to 'top'). Still the server has ~20G RAM vacant. Questions: a) Is there a more beneficial way to make use of this memory with MySQL, and b) which tools are recommended to get hints when MySQL Performance Tuning Primer and MySQLTuner can not suggest anything useful anymore? Excerpt from my.cnf 

LATEST DETECTED DEADLOCK 2017-05-28 06:50:41 7f2f7ea56700 *** (1) TRANSACTION: TRANSACTION 50342747, ACTIVE 0 sec starting index read mysql tables in use 1, locked 1 LOCK WAIT 2 lock struct(s), heap size 360, 1 row lock(s) MySQL thread id 7149, OS thread handle 0x7f2f75052700, query id 79951872 139.219.195.240 root updating update device set alert_num=0, build_id=null, code=''AD-046'', create_date=''2017-05-20 09:35:07'', creator=null, type_id=70, device_version_id=null, enable=1, floor_id=null, last_activity_time=''2017-05-28 06:50:39'', last_red_alert_time=''1970-01-01 00:00:00'', last_yellow_alert_time=''2017-05-28 06:50:08'' where id=284 *** (1) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 183 page no 3 n bits 152 index of table . trx id 50342747 lock_mode X locks rec but not gap waiting Record lock, heap no 76 PHYSICAL RECORD: n_fields 30; compact format; info bits 0 0: len 4; hex 8000011c; asc ;; 1: len 6; hex 0000030026e6; asc & ;; 2: len 7; hex 04000017f708dd; asc ;; 3: len 6; hex 41442d303436; asc AD-046;; 4: len 17; hex 4162737472616374446576696365303436; asc AbstractDevice046;; 5: len 4; hex 80000046; asc F;; 6: len 5; hex 999ca898c7; asc ;; 7: SQL NULL; 8: SQL NULL; 9: SQL NULL; 10: len 4; hex 8000004a; asc J;; 11: len 4; hex 80000000; asc ;; 12: SQL NULL; 13: SQL NULL; 14: SQL NULL; 15: len 4; hex 800000d8; asc ;; 16: SQL NULL; 17: len 4; hex 00000000; asc ;; 18: len 4; hex 00000000; asc ;; 19: len 12; hex e7a681e6ada2e68ea8e98081; asc ;; 20: len 4; hex 8000001e; asc ;; 21: SQL NULL; 22: SQL NULL; 23: len 4; hex 00004042; asc @B;; 24: len 4; hex 80000001; asc ;; 25: len 4; hex 80000001; asc ;; 26: SQL NULL; 27: len 5; hex 999cb86ca6; asc l ;; 28: len 5; hex 999cb86c88; asc l ;; 29: len 5; hex 9902c20000; asc ;; *** (2) TRANSACTION: TRANSACTION 50342683, ACTIVE 0 sec starting index read mysql tables in use 1, locked 1 7 lock struct(s), heap size 1184, 3 row lock(s), undo log entries 1 MySQL thread id 7153, OS thread handle 0x7f2f7ea56700, query id 79951946 139.219.195.240 root updating update device set alert_num=0, build_id=null, code=''AD-046'', create_date=''2017-05-20 09:35:07'', creator=null, type_id=70, device_version_id=null, enable=1, floor_id=null, last_activity_time=''2017-05-28 06:50:38'', last_red_alert_time=''1970-01-01 00:00:00'', last_yellow_alert_time=''2017-05-28 06:50:38'' where id=284 *** (2) HOLDS THE LOCK(S): RECORD LOCKS space id 183 page no 3 n bits 152 index of table . trx id 50342683 lock mode S locks rec but not gap Record lock, heap no 76 PHYSICAL RECORD: n_fields 30; compact format; info bits 0 0: len 4; hex 8000011c; asc ;; 1: len 6; hex 0000030026e6; asc & ;; 2: len 7; hex 04000017f708dd; asc ;; 3: len 6; hex 41442d303436; asc AD-046;; 4: len 17; hex 4162737472616374446576696365303436; asc AbstractDevice046;; 5: len 4; hex 80000046; asc F;; 6: len 5; hex 999ca898c7; asc ;; 7: SQL NULL; 8: SQL NULL; 9: SQL NULL; 10: len 4; hex 8000004a; asc J;; 11: len 4; hex 80000000; asc ;; 12: SQL NULL; 13: SQL NULL; 14: SQL NULL; 15: len 4; hex 800000d8; asc ;; 16: SQL NULL; 17: len 4; hex 00000000; asc ;; 18: len 4; hex 00000000; asc ;; 19: len 12; hex e7a681e6ada2e68ea8e98081; asc ;; 20: len 4; hex 8000001e; asc ;; 21: SQL NULL; 22: SQL NULL; 23: len 4; hex 00004042; asc @B;; 24: len 4; hex 80000001; asc ;; 25: len 4; hex 80000001; asc ;; 26: SQL NULL; 27: len 5; hex 999cb86ca6; asc l ;; 28: len 5; hex 999cb86c88; asc l ;; 29: len 5; hex 9902c20000; asc ;; *** (2) WAITING FOR THIS LOCK TO BE GRANTED: RECORD LOCKS space id 183 page no 3 n bits 152 index of table . trx id 50342683 lock_mode X locks rec but not gap waiting Record lock, heap no 76 PHYSICAL RECORD: n_fields 30; compact format; info bits 0 0: len 4; hex 8000011c; asc ;; 1: len 6; hex 0000030026e6; asc & ;; 2: len 7; hex 04000017f708dd; asc ;; 3: len 6; hex 41442d303436; asc AD-046;; 4: len 17; hex 4162737472616374446576696365303436; asc AbstractDevice046;; 5: len 4; hex 80000046; asc F;; 6: len 5; hex 999ca898c7; asc ;; 7: SQL NULL; 8: SQL NULL; 9: SQL NULL; 10: len 4; hex 8000004a; asc J;; 11: len 4; hex 80000000; asc ;; 12: SQL NULL; 13: SQL NULL; 14: SQL NULL; 15: len 4; hex 800000d8; asc ;; 16: SQL NULL; 17: len 4; hex 00000000; asc ;; 18: len 4; hex 00000000; asc ;; 19: len 12; hex e7a681e6ada2e68ea8e98081; asc ;; 20: len 4; hex 8000001e; asc ;; 21: SQL NULL; 22: SQL NULL; 23: len 4; hex 00004042; asc @B;; 24: len 4; hex 80000001; asc ;; 25: len 4; hex 80000001; asc ;; 26: SQL NULL; 27: len 5; hex 999cb86ca6; asc l ;; 28: len 5; hex 999cb86c88; asc l ;; 29: len 5; hex 9902c20000; asc ;; *** WE ROLL BACK TRANSACTION (1) 

As already stated in the responses below your request it is most certainly due to the unbalanced nature of F and T causing SQL Server to prefer scan over seek. Though this is quite some simplification as you are querying a view containing quite a lot of tables and WHERE as well as JOIN conditions. In case you query "[...] and MOVIsResolved = 'F'" the SQL Optimizer most likely prefers a SCAN over a SEEK, as the given result is that large. with "[...] ='T'" it prefers a SEEK as the result set is small enough. And finally with "[...] <>'F'" the optimizer has no other choice but to SCAN and check each entry, whether the column contains not 'F'. In the end for you it is quite clear "<> F" equals "= T" as you know there can only be these 2. SQL Server does not know this. Therefore the resulting execution plans for "<> 'F'" and "= 'F'" are the same. As an alternative you might wanna look into OPTION( OPTIMIZE FOR UNKNOWN ), thought I do not know, whether this actually works with hard coded queries as yours. 

I also have stumbled about the article $URL$ and cannot find the correlation to the scripts above. Also I'm wondering, why there exists a differentiation for "@logicalCPUs >= 8 and @HTEnabled = 1 and @NoofNUMA = 1" and "@logicalCPUs >= 8 and @HTEnabled = 1 and @NoofNUMA > 1" as the result becomes the same. After all I ended up writing my own piece of code matching the article from above, though even there I would have loved a more precise definition and/or differentiation about "processors" "CPU" and "physical processors". Feel free to have your spin with it. 

I would have added LEFT and CROSS Joins as well, thought they are already part of your example. About the "experience in SQL Server normalization" - I'd say, besides looking in the code, there will not be much you can hold your self on. It is often just a "It depends!" 

Well, actually having a PK with 5+ columns is not necessarily bad in itself. It becomes bad once the PK is also the clustered index as that one would count as the row identifier and thus would be added to each row in a NC index. This would drastically increase the required space. It would also be bad once you actually use the PK by another FK, as you have to have the data of all 5+ columns in both the current table as well as the one referencing from. Once again it will increase the storage by a lot! Performance-wise it will be bad once the PK is been used as an index - let it be solely within the table or in conjunction with a FK - as a bigger PK-Key containing 5+ columns will take more space, thus less entries will fit within a page and henceforth more pages need to be read to analyze the index. That said - there might always be a good reason for actually doing so anyway, like e.g. a fact table. Therefore the best answer would actually be as in most cases: It depends! Regards Dennis