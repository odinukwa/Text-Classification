I have two optimization problems, both of whose inputs are from the set $I$ and whose solutions are from the set $S$, one a minimization with objective function $m_{\min}$ and one a maximization with objective function $m_{\max}$. I am studying what I would like to call the "join" or "direct sum" of these two problems, the problem of maximizing $m_{\max}(x, w) - m_{\min}(x, w)$, though I don't know the correct name for such a problem. In my particular case, each problem on its own has a trivial algorithm that produces optimal solutions, but together, the problem is intractable. Has the structural complexity or approximability of optimization problems of this form been studied in a general way? (The fact that one is a maximization problem and one is a minimization problem is not crucial here, they could both be the same type of optimization.) 

In the 2012 paper On the Concrete-Efficiency Threshold of Probabilistically-Checkable Proofs, the authors state the following (paraphrased from page 11). 

(The completeness probability can essentially be any fixed fraction; I chose $\frac{3}{4}$ so that it matches the probability given in your question.) One way of defining $\EBPP$ is as follows. A language $L$ is in $\EBPP$ if there is a polynomial time verifier $V$ such that 

I believe the Cartesian product for graphs satisfies the first and the third conditions, but the size of the product graph in this case is multiplicative (specifically $O(|G_1| \cdot |G_2|)$), not additive. I will be performing this operation a polynomial number of times, so a multiplicative increase in size is unacceptable. Edit: changed condition 3 to require a logarithmic space computation instead of a polynomial time computation. Edit: changed condition 1 to require the maximum minimum degree over all subgraphs should be preserved. 

That gives us an $\mathsf{USPACE}[O(\log|F|+\log n)]$ algorithm for reachability. Of course this is a pity bound, since by Savitch's theorem we have $\mathsf{NL} \subseteq \mathsf{L}^2 \subseteq \mathsf{UL}^2$. But what if we consider the reachability problem with a restriction that there are at most $f(n)$ paths from the source to any node in the graph? This defines the problem $\mathtt{Reach}[f(n)]$, and we have $\mathtt{Reach}[2^n]$ to be the normal reachability problem. By setting $f(n)$ a polynomial, applying the above lemma together with an $\mathsf{UL}$-algorithm for reachability in graphs with a minimum unique path (see the paper for more details), we can solve $\mathtt{Reach}[n^{O(1)}]$ in $\mathsf{UL}$. (The result occurs in this recent paper. In fact they use a stronger version of the lemma, which isolates every paths in the graph by a constructive way.) If a weaker isolation lemma is known to have less restrictions on either the size of $\mathcal{F}$, or the number of random bits being used, we can provide better bounds on the problem $\mathtt{Reach}[f(n)]$, with the help of some modifications to solve reachability in graphs with few minimum paths. Hopefully if the lemma is weak enough to set $f(n) = 2^n$, and we can obtain some better bounds about the important class $\mathsf{NL}$. Any comments on the proof techniques or obstacles will give insight to the question, and I would like to know that whether this idea has a tiny little chance of success, or it is just a completely impossible concept. 

I'm interested in but not familiar with this topic. Searching for "Average case complexity theory", I found a thesis written by Tomoyuki Yamakami: 

Theorem provers have been used to some extent for proving correctness of software, hardware and protocols. See, for example, here or here. The problem of data flowing in undesired ways through programs (an thus causing a potential leak) has been modelled theoretically using the notion of (non-)interference; get pointers here. 

Cranky Sunday morning idea that might or might not be correct: Wlog, let $P_1$ be the partition with more sets, $P_2$ the other. First, assign pairwise different names $n_1(S) \in \Sigma$ to your sets $P_1$. Then, find a best naming $n_2(S)$ for the sets $P_2$ by the following rules: 

Ad 4: You break your desired invariant for $R$ here since the last node in $x$ does not necessarily occur in $w$ at all. Example: $x = abc, y=adc, z=adce, w=ae$ I believe a worst-case instance might be the complete graph with $w(i,k) = 1$ for $i$ the starting node and all $k\neq i$, and $w(j, k) = 0$ for all $j,k \neq i$. Paths with more nodes will never remove those from earlier iterations so the tree is never shrunk at all, growing up to having $n!$ nodes. 

I think -- and hope -- that every computer science student is confronted with this problem which feels like a paradoxon. It is a very good example for the difference of computable in TCS sense and computable in a practical sense. My thoughts back then were: "Yea, if I knew the answer, it would obviously be computable. But how to find out?" The trick is to rid yourself from the illusion that you have to find out wether $\pi$ has this property or not. Because this, obviously (read: imho), cannot be done by a Turing machine (as long as we do not have more knowledge than we have about $\pi$). Consider your definition for computability: we say $f$ is (Turing-)computable if and only if $\exists M \in TM : f_M = f$. That is you only have to show existence of an appropriate Turing machine, not give one. What you -- we -- try to do there is to compute the Turing machine that computes the required function. This is a way harder problem! The basic idea of the proof is: I give you an infinite class of functions, all of them computable (to show; trivial here). I prove then that the function you are looking for is in that class (to show; case distinction here). q.e.d. 

Let $\mathsf{ZPL}$/$\mathsf{RL}$/$\mathsf{BPL}$ denote the classes of the languages which are accepted (with zero/one-side/two-side error) by a logspace Turing machine with one-way access to the random tape. Let $\mathsf{ZP^*L}$/$\mathsf{R^*L}$/$\mathsf{BP^*L}$ denote the corresponding classes by replacing one-way to two-way access. We have the normal inclusions $\mathsf{ZPL} \subseteq\mathsf{RL}\subseteq\mathsf{BPL}$ and $\mathsf{ZP^*L} \subseteq\mathsf{R^*L}\subseteq\mathsf{BP^*L}$. In the following paper, 

Let $G$ be an $n$-node graph that can be decomposed into two disjoint union of spanning trees. In particular, $G$ has $2n-2$ edges. It is not hard to show that the girth of $G$ is at most $O(\log n)$. However, I don't have an example with girth bigger than $4$. 

Hence we can assume the theorem holds on the larger n, apply the second observation, and concludes a contradiction by the first case, by setting n' satisfies $({n' \atop k})$ > K > $({n'-1 \atop k})$; such n' must exist by the fact that $({n \atop k})$ > K and K > $({k \atop k})$, n' must lie between n and k+1. 

(There may be a Karp reduction, but if we allow a Cook one, consider the following reduction: Replacing the given degree d node into a complete subgraph of size d with proper outgoing edges. Then for each edges in the complete graph we can query the oracle that solves Problem P. Note that a chordless even cycle passing through the given node corresponds to a chordless odd cycle of length greater than 3 passing through one of the edges in the complete graph.) Now for the main reduction. Given an instance of Problem P, first we detect if there are any triangles passing through $e$; if so, delete every node that forms a triangle with $e$. Note that deleting nodes that forms a triangle with $e$ will not removing any chordless odd cycles passing through $e$ (by the chordless property). Next, for each edge $f$ other than $e=(u,v)$ we add an auxiliary node $v_f$ and two edges $(v_f,u)$ and $(v_f,v)$. Observe that the new graph $G'$ has the following property: 

I'm looking for a binary graph operation $\oplus$ that has the following properties for all undirected graphs $G_1$ and $G_2$. 

This problem is hard, in various settings. As stated in the other answers to this question, the problem is NP-complete over the integers. In signal processing, the matrix and the vectors have rational entries, and this problem is sometimes called the sparse reconstruction problem. In this setting, the problem is NP-complete (see Theorem 1). In coding theory, the entries are from a finite field, and this problem is sometimes called the maximum-likelihood decoding problem. In this setting, the problem is NP-complete and not in subexponential time, assuming the exponential time hypothesis. Furthermore, according to a previous version of a paper on arXiv (see Lemma C.2 in version 1 of the paper), the problem is W[1]-complete. 

The title of this question does not match the content. As stated in the comments, there are some NP optimization problems for which any polynomial time approximation algorithm implies P = NP. Maybe you are looking for optimization problems that are not approximable within any polynomial factor, or that exhibit a threshold behavior? You may be looking for polyAPX-hard or polyAPX-complete problems. polyAPX is the class of NP optimization problems that have a polynomial time approximation algorithm such that the measure of the approximate solution is within a polynomial factor of the optimal measure. In Theorem 2 of this extended abstract, you can see that the Maximum Independent Set problem is complete for polyAPX under PTAS reductions. For more information on approximation-preserving reductions and approximability results, check out the compendium of NP optimization problems. 

is a syntactically correct Java program but will not compile because is not defined and does not have a fitting type. Secondly, you can parse languages that are not context-free (as obviously proven by the existence of compilers). It is only that CFGs can be parsed efficiently, while CSGs can not, in general. However, you can add certain non-context-free features while remaining efficient. Compilers often run in phases: first tokenization (regular), then context-free parsing, then name and type analysis (context-sensitive, sometimes even harder). You can observe that behaviour by the kind of error messages you get. 

By far the nicest procedure I have seen is the one mentioned by Sylvain. In particular, it seems to yield more concise expressions than others. I wrote this document explaining the method for students last summer. It directly relates to a specific lecture; the reference mentioned is typical definition of regular expressions. A proof of Arden's Lemma is contained; one for correctness of the method is missing. As I learned of it in lecture I don't have a reference, sadly. 

They are not and they can not, in general. We can only treat a countable number of inputs (and outputs and functions) with our models of computation. In particular, any input has to be finite but not all real numbers have finite representations. You could, I guess, assume some kind of oracle that yield the next digit of a certain real number upon request (sth like a stream). Otherwise you will have to live with (arbitrarily precise) approximations. 

It was the first to have impact and thus has been established, especially in complexity theory. This is a weak reason, but people work that way. We work on old open problems first instead of declaring new ones. 

Edit: consider the complexity measure to be one of the resource-bounded Kolmogorov complexity measures (for example, the length of the shortest program that outputs a given string, with an additive penalty of the logarithm of the running time of the program) to make the problem computable, as suggested in the comments. 

This is a partial answer; maybe it will inspire someone else to provide a better one. $\newcommand{\EBPP}{\mathsf{EBPP}}$ $\newcommand{\CP}{\mathsf{C}_=\mathsf{P}}$ Your class $\EBPP$ is a special case of $\CP$. I think one way of defining $\CP$ is as follows (see Section 2 of this paper). A language $L$ is in $\CP$ if there is a polynomial time verifier $V$ such that 

If $d_1$ is the largest number for which $G_1$ has a subgraph of minimum degree $d_1$, and $d_2$ the largest such number for $G_2$, then the largest such number for $G_1 \oplus G_2$ should be $d_1 + d_2$. In other words, $$\max_{H \subseteq G_1} \delta(H) + \max_{H \subseteq G_2} \delta(H) = \max_{H \subseteq G_1 \oplus G_2} \delta(H),$$ where $\delta(H)$ denotes the minimum degree of the subgraph $H$. $|G_1 \oplus G_2| \in O(|G_1| + |G_2|)$. $G_1 \oplus G_2$ is computable in logarithmic space. 

What do you call the problem of finding a largest possible subset of strings with smallest possible information content? I'm studying a particular instantiation of this problem in a different setting and would like to know about this more abstract problem. In terms of Kolmogorov complexity, this would be the following decision problem. 

What is the relationship between $\mathsf{PLS}$ and $\mathsf{APX}$? In other words, are problems that admit a polynomial time local search approximable? Do approximable optimization problems imply a local search algorithm in general? 

that $G$ contains a cycle of length at least $4 (\log_2 n - \log_2\log_2 n - 5)$. And a graph which meets the bound is provided in the result Über längste Kreise in regulären Graphen by Lang and Walther, so this is the best possible. For the reference, see Longest cycles in 3-connected cubic graphs by Bill Jackson. If the graph is 3-connected, then the bound can be improved to $\Omega(n^c)$ with $c\approx 0.69$, and there are efficient algorithm approximately finding a long cycle in $G$. 

This is known as the rectilinear crossing number $\overline{\mathsf{cr}}(G)$, which is the minimum number of crossings among all possible straight-line drawings of the graph $G$. Compare to the normal crossing number $\mathsf{cr}(G)$, one can see that $\overline{\mathsf{cr}}(G) \geq \mathsf{cr}(G)$. And your question is essentially as the same as asking whether $\overline{\mathsf{cr}}(G) = \mathsf{cr}(G)$ if $\mathsf{cr}(G) \leq k$ for some constant $k$. In the paper Bounds for rectilinear crossing numbers, Bienstock and Dean proved that 

Here's my two cents: The complexity class $\mathsf{RL}$, the randomized logspace, is defined as an analog of $\mathsf{RP}$, that is, the decision problems that can be solved by a non-deterministic logspace machine $M$, where 

See the paper for details. Some other papers by Mihai are relevant and nice, too. UPDATE: I found that his PhD thesis "Lower Bound Techniques for Data Structures" providing lower bounds for many central data-structure problems using the techniques he developed. It certainly worths a read. 

Distance preserver is also known as an emulator; many related work can be found on internet by searching the term spanner, which requires H to be a subgraph of G. But in my applications we can use other graphs as well, as long as H preserves the distances between T in G. 

String Matching, used all the time in application software and on database level. In the exact case, there are several quite involved algorithms (KMP, Boyer-Moore) with some that achieve sublinear expected runtime. They are also interesting to study from a CS point of view. Approximate string matching, that is alignments, is probably even more interesting. You know "autocorrecting" features? Also, searches in noisy string data (e.g. DNA) is done using alignments. 

The area you want to look at for answers to is machine learning. You have desribed a graphical model. I think in this case methods as easy as Belief Propagation should suffice. 

Let $H_i$ for $i \in \mathbb{N}^+$ i.i.d. random variables over $\mathbb{N}^+$ with $Pr[H_i = k] = 2^{-k-1}$ (height of tower $i$). Let $H = \max \{H_i \mid i=1,\dots,N\}$ with $N \in \mathbb{N}^+$. Then: $Pr[H \geq k \mid N] = 1 - \prod_{i=1}^{N} Pr[H_i < k] = 1 - (1 - 2^{-k})^n$. Now we can compute the likelihood of $H=k$ given $N$: $Pr[H = k \mid N] = Pr[H \geq k \mid N] - Pr[H \geq k + 1 \mid N] = (1-2^{-k-1})^n - (1-2^{-k})^n$. The zero of this expression's first partial derivative w.r.t. $N$ is found at $N^*_k = \frac{\ln\left( \frac{\ln(1 - 2^{-k})}{\ln(1 - 2^{-k - 1})}\right) }{ \ln(1 - 2^{-k-1}) - \ln(1 - 2^{-k})}$ (using Wolfram Alpha). Note that I was not able/eager enough to check wether or not that is really a maximum. If it is, $N^*_k$ is maximum likelihood estimator for skip list length $N$ given maximum tower height $k$. Some values, rounded to the nearest integer: