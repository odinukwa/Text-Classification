The specification says that a binary tree is "given". The code explicitly creates a separate implementation of a binary search tree without reference to the given. There is no method which takes a sorted list and returns a representation of the list. 

Instead of using the symbols ...it's not obvious what comes next without taking notes and working through the code and figuring out the implementation details... is more typical of Racket and other Lisps. The reason is that it aligns the level of abstraction in the program with the abstractions in the problem domain. When I see the parameter in the procedure my first thought is that it's type is a directory. The code base starting with low level string parsing probably sets me up. The extra characters of are worth the added clarity. 

In general, the code is, clear, easy to read, and well organized. All the decisions among alternatives are reasonable and straight forward. Doing the simplest thing that might work is a good approach because it avoids adding unneeded complexity to the necessary complexity. The use of template literals rather than strings might be unnecessary complexity because the templating features are not used. Support for template literals is not universal among browsers. The page may break for no reason for some people. To put it another way, using template literals rather than strings creates potential broken pages for no gain in browsers that support template literals. 

For efficiency, there's no reason to be redundant. One walk of the tree can compute both height and size. A class can be used to hold the results of the walk: 

A more direct implementation of the Scala code might use for both and . There's nothing wrong with using types to make writing correct clear performant code easier. Recommendations Think about how much effort Odersky invests in making his code understandable. There's thirty minutes of video. There's the hours of video that come before it in the course sequence. The coding session starts with diagrams explaining the problem. Those are habits that are worth emulating. Following what Clojurists on the internet espouse doesn't make one an expert [I am aware of the irony]. Clojure is the product of Hammock Driven Development. Extension I'm a big fan of Lamport's idea specification as the starting point. One of the issues with Odersky's generalized approach is that it doesn't quickly trim the search space. Consider the case with two glasses: 

Given the nature of floating point numbers and their arithmatic, it might be a good idea to have a method that compares to points and determines if they are close enough to be considered equal. The tolerance for "equality" could be passed as a parameter or hard coded depending on the application. Segments Geometrically, "start" and "end" are ambiguous: the line segment the same as . This suggests standardizing the order of points based on their geometric properties (and therefore a comparison method in the Point class). For example: 

Knuth has written a whole book on strategies for solving combinatorial problems. He didn't find a general solution. He doesn't believe that he ever will, and he encourages readers to contact him if they do. 

Make the code more modular by removing tests from the production logic. Delete dead code. Consider using version control to maintain historical investigations instead. Consider writing an overall description of the program, so that anyone reading it, including yourself a week from now, can more quickly understand what the code does and how it hangs together to do it. Consider better names. 

To avoid executing arbitrary code, reads values from files with . The input is not read lazily. The assumption being that sorting or an equivalent operation will be performed. The basis for this assumption is the proximate use case: reading data files for Discreet Optimization @ Coursera. The private function is called to match the argument at the call site in the private function . This reflects a personal preference for mathematical notation when invoking mathematical abstractions. 

Search This is basically the case where we have a value and want to know if is a member of . Since is a permutation, must be a tuple. The comparison can boils down to: 

[1] Clearly I have assumed that the author of the review code does not control the domain. My apologies if I am in error. The bases for this assumption were the standard parking content currently on the domain and the shape of the code relative to the shape of code expected when serving of area calculations from a website. 

The issue, if it is actually an issue, arises from inverting bits in the abstract rather than in a particular context. In a practical application, there is probably a specific type that we are concerned with, for example a 16-bit integer. Analysis of Issue As written the function throws away information by treating a leading bit value of 0 as equivalent to the absence of information. From an information theory standpoint, a zero leading bit is information. Sketch of information retaining function Using Common Lisp's parameters is a mechanism for passing the number of interesting bits through the recursive calls to . Using at the bottom of the function passes the bit-depth across the recursive calls. 

Hard coding a magic number for stack size has code smell. Stack semantics derive from automata theory. As an abstraction, stacks do not have a fixed size [of 16 or anything else] and cannot be filled only emptied. An object oriented implementation should perhaps reflect this at the top of the inheritance hierarchy to avoid conflating implementation details with stack semantics. When it is necessary to implement a stack of limited size, consider taking size as a parameter to the constructor not hard coded as a magic number. This will allow greater code reuse and more clearly separate implementation dependencies from the higher level of abstraction. Finally, why not implement stack as a list? Example code: 

Making these assumptions explicit allows those reading the code to reason about it more clearly. It makes it easier to extend the code to three or more dimensions [there's no reason a computer can't solve an maze] or to handle hexagonal grids in ways that make sense. 

Magic Numbers The immediate caller has to handle what is essentially an exception and to handle it in a form other than . It also precludes the caller from allowing the exception to bubble up to what may be a more appropriate higher level. All the worse because there's no way to distinguish a good zero from a bad zero. For example: given an array S = {-1 2 1 -3}, and target = 1: 

Each diagonal gets clipped at the board boundaries based on the distance of the bishop from the edges. The distance of the bishop from the edges is defined by it's coordinate value. 

are blocking and require further input from one of the players. Implementing The Specification This is a sketch of the game: 

Final thoughts The real scientific work is in simulating the behaviors of predators and prey. Getting the display code out of the way will allow you to focus on the core problem clearly. It will make the code more readable and prioritize bugs - it doesn't matter how right the visualization is if the underlying simulation is bad. 

Circling Back The original program could be refactored to incorporate several of the suggestions while maintaining the its original iterative approach. 

Naming The name suggests a natural number even though that is not case in the implementation which operates over integer values. More importantly, perhaps, it does not reflect the 'problem domain' or 'business logic' of the underlying mathematics in which exponents can be anything that counts as a number. Precision The use of floating point values limits the precision of the numeric results and does not take full advantage of Common Lisp's numeric system: e.g. arbitrarily large integers and exact ratios. Completeness The function does not handle non-integer values for the exponent, e.g. throws an error instead of returning the square root of 3. In fairness, Common Lisp includes a function that performs the operation. The implementation in SBCL is non-trivial at just under 200 lines of code (begins at line 158). Speed Optimization applied at the wrong time and/or in the wrong place has been known to occasionaly lead programmers astray. This seems to be a case where the hard problem is writing code that reflects the underlying mathematics has been foresaken for benchmarking implementations that don't. Recommendations The code might be improved by acknowledging the problem domain. For example rather than . It might be improved by testing for mathematically sound arguments that it does not handle for example: 

Better variable names. Write about rocks and paper and scissors: makes the code more readable. Readability particularly helps the person writing the code. Make the code more modular. Put all the initialization together. Put all the user interface someplace else. Separate out the string matching. Only put high level abstractions in the main loop. Consider specifying the problem before writing code for a solution. At the core Rock, Paper, Scissors does not deal with synonyms. Writing a specification makes it clear that synonyms are a feature and encourages keeping their logic outside the main loop. This makes the code more readable. 

There is a lot of sound advice in other answers, so I will only touch on aspects that I think are worth considering, but are not yet addressed (or that I misunderstood). Recursion I like recursion. But when I find myself trying to use it in Python I stop and reconsider. Using recursion in Python is possible, but doing so is usually an exercise in snake wrestling more than it is productive programming. 

The infinite capacity of the third jug allows it to represent a sink into which the contents of the other jugs may be emptied. The infinite contents allows the third jug to represent a faucet for filling other jugs. The problem Ordersky presents is none of these. It is a generalized case based on a Python example from Peter Norvig's Design of Computer Programs course at Udacity. The problem Odersky is solving has an arbitrary number of jugs with finite capacity plus one jug with infinite capacity and contents. I would like to dub this the "n+1 Jugs Problem" because captures the sink/faucet and hints at the notion of [at least in my little world]. Readability A joke: I married my wife despite her adamant unwillingness to change her name. What's the big deal about being called "Donna" to match my tattoo? Rich Hickey invented Clojure to help working programmers write good programs, not to give the world another excuse for tribal tattoos. I don't think or inside a function are big deals. They're very Pythonic and they couldn't make the code less readable for idiots like me. Chiapas I found the code opaque. "What is ?" I asked myself. I could look at the code for hours and never really figure it out. It took a half hour of concerted effort involving Google and watching a video of Martin Odersky...twice before I came up with a good answer: is a vector of integers. In Ordersky's code this is explicit at line 6: 

The Regex will validate some email addresses. Because the Domain Name System allows UniCode. the Regex does not match all valid characters in the Doman Name. Therefore it will not validate all valid email addresses. Alternatives: Validating over all allowable Unicode with Regex in a meaningful way is non-trivial. 

If the same values (1 and 5 in your example code) are being called repeatedly, they should be given meaningful names. For example: 

Because the program mixes the mathematical abstractions of "two integers K and L" with the business logic abstractions of "movies", "days", "watching", and "festivals". Remarks 

is always because something is either or . An can't be because is always an . More importantly, none of this makes it any easier to reason about how the code represents or solves mazes at the high level of abstraction or about how the code works at the level of and tuples of s at the lower level. Readability Structural decisions and the choice of abstractions make the code difficult to read. Writing zero comments should not be considered a feature. Modularity The absence of any modularity makes the code difficult to follow. Simply breaking out the tests would significantly improve readability. Scala has a common idiom for modularizing code: . There are practical alternatives available from other JVM language communities. Leaking Abstractions A maze declartion should be purely declarative. It should define the geometry of the maze in terms of walls, levels, chutes, ladders, dragons, etc. A maze object should have an API that answers two questions: 1. Where am I? 2. What do I see? It should initialize with a maze definition and a goal location. A maze solver should intialize with a start location and a maze object. It should reach a solution state based upon querying the API of the maze object. It should not have knowledge of the maze geometry, the goal location, or the solvability of the maze given the start location. It's supposed to figure all that out. This means a maze solver should build an internal representation of a maze based on what it finds. It has to do so anyway to maintain its search space, so even though it sounds like more work, it isn't. Decoupling the solver from the maze declaration and an instantiation via a maze object makes it more general - e.g. it could operate over the wire to a RESTful endpoint. Specification There needs to be a specification for maze declarations. The important issues are: 1. How many degrees of freedom exist for movement? A 2d rectangular grid might allow four or 8 depending on whether moving diagonally constitues one move or two. A 2d hexagonal grid would allow 6 directions of movement. 3d grids allow additional options. 2. What is the language used for maze declarations? Names Variables and constants should be named to reflect the business logic of mazes. The model should be tied to the language of mazes: 

Don't write Scala modelled on C or Java. Take advantage of Scala's high level features. Don't optimize what doesn't need to be optimized. Implement procedural code in languages where it is idiomatic. 

Analysis The current running time is 0(m+n) where and . Combining the loops reduces the running time to 0(n) where is the length of the longer list. Single Loop Example Procedure in psuedo code: 

Specification It is helpful to specify the solution before writing code. The mathematics of sorting three values means there are six permutations: 

Is "tree recursive" and therefore does a lot of extra work. Tree Recursion is described in The Structure and Interpretation of Computer Programs. Section 1.2.2 has a very helpful illustration that shows how tree recursive algorithms wind up performing substantially more work than is necessary. Remarks People often describe Structure and Interpretation of Computer Programs (often called "SICP") as a book about the language Scheme. It isn't. It is a book about computer programming and probably worth reading for many programmers. It just uses Scheme because Scheme is both powerful and easy to use. For example, SICP does not dive into Scheme's Macro system. It is also worth looking at section 1.2.1 on Linear Recursion and Iteration. SICP is a reasonable introduction to the way good recursive algorithms can be written. 

In my opinion, the biggest concern is that products are modelled with tax status as the most important property. This makes reusing the objects in different contexts, for example an inventory control system or an online storefront difficult. Furthermore, the tax status of a book is not a constant because in another jurisdiction, it may be taxable at the base rate and a book printed in Bolivia may be an imported book in Australia, but it is not in Bolivia. The code may meet the specification, but it is extremely brittle. It can not easily modified to address related circumstances or support making logically implied business decisions because it does not strive to fit into the bigger context of running a business. Code is a means to an end, not an end in itself. Modelling The key to designing a well-engineered solution is to have an appropriate model of the system. Sure there are times when quick and dirty is good enough, but a core business function such as sales transactions are usually not among them. Naive Model The naive model is specified in terms of computer input and output. We get an order and produce a receipt.