The large orange box on the right is a 12V power supply, which runs through a 7805SR-C Voltage Regulator(circled in red) to supply a 5V output to power the Pi. My problem right now is that when attempting to power up the unit it gets stuck booting. Basically it will start to boot, get to one point, and shut down and start booting again. I'm sure this is because it isn't getting enough power (positive in fact, I was having the little "Not enough power" lightning bolt showing on my monitor) which may be due to the voltage regulators only outputting at 500mA. As you can see, I have two voltage regulators set up. Currently I have nothing running from the 5V output of the second one. Would I be able to hook up the other 5V Pin to the other regulator without essentially blowing up the Pi? I'm not exactly electrical savvy, I was kind of just handed this and told, "make it work" :| I'm unsure if the extra voltage will be too much for the Pi or if it will be fine because of the low current from the regulators. Thanks for your time. 

So for the project I am working on I am attempting to power a Raspiberry Pi 3 through the 5V Pin along the header. This is the setup I have: 

As such I have been attempting to implement the ICS Kernel-mode SocketCAN module, as well as icsscand. My problem with that at the moment is with the kernel-mode SocketCAN module. 

It sounds like I am missing a dependency, but I am not sure where do download said dependency from. EDIT: Going off of the API page for Python-Can, under the NeoVi Interface section it mentions the following: 

Now am I correct in that the voltage output I will be reading from the ADC will be between 0 and VREF (1.05V in this case)? So If I want to read up to 2V I need to increase VREF to 2V correct? My other question is, what is the maximum voltage I can send through the input channels (CH0-7)? Is that based on my VREF as well? Or if I sent it 3V will it scale it to VREF and send that as output? Is VDD what my maximum voltage should be for those pins? I'm trying to be careful to not blow up my chip, while at the same time I think understanding this will make it easier to figure out problems with my programs. Thanks :) 

From the output, you see that the driver recognizes the WiFi dongle, but cannot load firmware for it, since the firmware file cannot be found. The Raspberry Pi forum has two threads about getting these WiFi devices to work under Raspbian. Normally USB devices can be seen in the output even if a suitable driver is not available. I believe the dongle did not show up, because it is disconnected when the firmware is not found, as the last two lines show. I found that the regular Debian package firmware-realtek contains the required file. This would be a clean and convenient way to get it, but on my Raspbian I don't have this file, even though the package is installed. 

It's possible and even encouraged. A nice command line player for the Pi is . It might be installed by default in Arch, otherwise it's available in the repositories. Omxplayer is written for the Pi, and uses the GPU for decoding video. It works extremely well and smoothly, provided that the video is in a supported format (h264 and mpeg4). Additionally, you can buy license keys for MPEG-2 and VC-1 in the raspberry store. Btw, the more graphical media player XBMC uses omxplayer as a backend on the Pi. 

The value of this capacitor should not be critical, it filters the supply voltage. In general, a larger capacitance is better. The voltage is not critical either, as long as it's rated above 5V (but some margin may be nice). A higher voltage rating should not hurt, but merely give you a larger and more expensive capacitor. Have a look at the schematic, your cap is connected between ground and the input voltage. The input voltage is directly wired to several places (test point 1, the GPIO pins, the other USB ports), so if your new cap doesn't fit where the old one was, maybe you can put it somewhere else. Then you don't have to hunt for a cap with the right footprint. 

I hope my title gives you basic gist of what my problem is. I have created a Python Tkinter app that I have set up to run on the boot of my Raspberry Pi. The GUI window is meant to be fullscreen, however I am having one small issue with it. While using the app if you press near the top of the screen, the Pi's menu bar will pop up on top of the app. This needs to be set up for that users can only access the program that starts on boot so this is a bit of an issue. Does anyone know a way to fix this or is this a problem because my app is getting loaded before the Pi's GUI loads the Menu Bar? 

hope you folks aren't sick of me yet :P (If you are I apologize) So I'm working with a Pi-3 and an MCP3008 ADC chip. After going through my work, I've decided to make sure I understand what to do with the chip. The current setup I have for the chip is: 

As you can see, instead of I have . I have no idea what this is, but it is obviously the interface name for my wired connection. The question is, why? 

So I am creating a device to measure voltage and current using the Pi with an MCP3008 ADC chip. I have two questions I need help finding answers to. 1) What is the correct math to calculate current? So with my setup, Pin 1 (CH0) of the MCP3008 is plugged into the device I am measuring the voltage usage of, with Pin 2 (CH1) being plugged into that device after it's gone through a 0.1 Ohm resistor (or shunt, or w/e it's called). Now initially my thought was to calculate the current, I need to first make sure I have the ADC in the proper differential setup, and then I just take the differential value, convert it to voltage, and divide by the resistance. Only thing is I noticed that on the API page for GPIOZero, it mentions that for the MCP3008 the can be negative in differential mode. So should I be using in my equations? Or am I fine? 2) Is there any way to have my program show more accurate readings? So I've been running the chip and using a volt meter so I have a way to see if my readings are correct or not. My problem is that for the device I'm working with, sometimes the voltage is so low (around 0.09V or lower) that it isn't even picked up by the ADC. However the high end of the voltage for the device has honestly blown out a chip or two already. So here's my conundrum. I need to figure out if there is a more accurate way to measure the voltage, while at the same time trying to figure out a way to stop my MCPs from dying. I only have a few left to work with before I have to order in more :| EDIT: For my setup, the voltage reference is 1.15V 

You can often find the configurations used to compile the currently running kernel in the special file . You could use this configuration as a starting point when compiling your own kernel. Get it from the Pi, gunzip it, and tell to load this configuration (can't remember exactly how). The configuration is actually stored within the kernel itself. This can be turned off when the kernel is compiled, but my current kernels for both Arch Linux and Raspbian have it. And indeed, the instructions include this step, a bit further down. 

OpenMAX is supported. It does not let you do arbitrary computations on the GPU, but it seems to contain compression and decompression of audio, video and images. This thread is about JPEG decompression with OpenMAX on the Pi. Here is a list of API:s supported by the VideoCore. 

Many mobile phone modems work directly in Linux. I suggest trying to get yours running directly instead of under an emulated Windows. Virtual Box cannot run x86-Windows on a Pi (since it does virtualization, not full emulation). Qemu should be able to emulate a PC with windows even on the Pi. Anyway, this is likely to be slow and troublesome. What is the make and model of your USB modem? Maybe it is supported under Linux, even if your provider does not explicitly say so. Otherwise, you could get a supported USB modem, and move your SIM card to it. I use my Pi as a WiFi-and-LAN to GSM router (details here), with a Huawei E173 modem. To connect to the internet with the GSM modem, I use the great Sakis3G script. The official website of Sakis seems gone, but there is a local copy of the script in the post. 

In addition to the good points in the other answers: get a WiFi device with good Linux support. You want one that works in access-point or managed mode. Many devices do not work in this mode in Linux, even if they work fine as a client. How well a device works depends on the state of the device driver. Before you buy anything, check the state of the various drivers at linuxwireless.org. Choose a driver with good support (at least the AP mode), then find a device containing that chip. I got a TL-WN722N USB device supported by the ath9k_htc driver. This works very well with hostapd and WPA2 encryption. I wrote a blog post on my wlan router setup here. Regarding the CPU demands mentioned in the comments of the question: I have not had problems with high CPU load. With , I measured 22 Mbit/s throughput over WLAN from a laptop to the Pi, when the connection speed was reported as 54 Mbit/s. I don't quite know how much one can expect, or where the bottleneck is in my setup. 

When I save with this text and reboot, if i put in the terminal, there is no eth0 interface. This is a screenshot of what I get when I run in the terminal: 

So I've had a bit of an issue with a Raspberry Pi after supplying power to it the GPIO Pins. My company has a device we've made that works with a Raspberry Pi as a kind of program hub. The device is suppose to supply power to the Pi from it's 5V GPIO Pin. When our electrician handed me the new model to test with the Pi, he had also included a connection for the 3V GPIO Pin. I told him we didn't need it, and needed to be disconnected, but he assured me he didn't know what he had to plug it into anyway, so it currently wasn't plugged into anything. So I plug the Pi in via a Ribbon cable, boot the device.... And then I notice that for some reason none of the attached peripherals are working. There's no blue smoke, no nasty popped hardware smell, but I power down the device anyway. I unhook the Pi from the device and just power it on with your usual MicroUSB Adapter. The Pi boots fine, the HDMI still works, so I can see the display on the monitor. However, as before the peripherals and Ehernet ports all seem to be dead. Upon further inspection, not only was the 3V Pin attached to something, but it have 4V-ish going through it. So essentially, I'm wondering if there is a way to salvage this at all or if I've permanently fried this Pi. I've included some pictures below of what the back of the Pi's board looks like right now. Picture 1 Picture 2 

I am not sure if I should just make the directory it is looking for, or if it not being there is a problem I shouldn't have in the first place. 

The one you found looks good. It requires >= 6V input, which your batteries will provide even close to the end of their life. For the Pi 2's current consumption, Adafruit estimates 650 mA (with a WiFi dongle and heavy computation). For the camera, the USB standard allows any device to draw at most 500 mA. The converter you found is specified for 3A, which is sufficient with a nice margin. One thing to consider though is how well the Pi handles powering devices through the USB ports. With the original Pi:s, it's often recommended to use a powered USB hub if the devices draw significant current. 

The Baking Pi course (about building an OS from scratch for the Raspberry Pi) has some material that could be interesting. It describes how to program the ARM CPU in assembly, and how to communicate with the GPU. Still this is not really programming the GPU, only communicating with it and the program it is already running. 

If you can choose the object yourself, it would be easy if you choose a sphere, since then the size in the image will not depend on the orientation (rotation) of the object. 

It does not even need to have X running. XBMC is of course an option, but installing it is quite involved unless you install one of the special distributions for it. For a media center, you probably want a full XBMC in the end, for the user interface. But for just trying things out omxplayer should be fine. In fact, omxplayer is the video player used in XBMC. 

I would try it on the pi itself, it seems simpler. The tutorial page you point at lists only gcc and mercurial as dependencies, these are simple and safe to install. Further, you can avoid mercurial if you just download the source as a tarball. On the raspberry forum there is a useful thread about installing go on the Pi. In particular: you have to set the environment variable GOARM=5 before compiling, to choose the correct ARM instruction set. I just tested building go on my 256 MB Pi with raspbian. 

I am attempting to create a program that can read DTC codes from CAN-Bus devices connected to a Raspberry Pi via a USB to Serial connection. I am testing with a NeoVi Fire that I have hooked up, and currently I am able to send and read serial signals to the device to control car seat heating and cooling units I have attached to it via said serial port. Now I need to expand what I have into requesting codes from the CAN unit so I am seeing if Python-CAN can do what I need it to (since the rest of my program is all written in Python). I also went and installed the PyNeoVi library since I am using the NeoVi unit, and I am running into a problem while attempting to use one of the test files with the PyNeoVi repository. This is the code for the test file: 

So my problem was the version upgrade I did. When I ran the Python code after opening up 3.6 it ran perfectly fine. Thanks to anyone who was offering help, it's appreciated. 

So today I recieved a Waveform High Precision AD/DA Expansion Board for me to use with my Pi3. Prior I was using an MCP3008 ADC chip to measure voltages, and I just wanted to see if I could get better readings off of this since the AD chip on the board is 24 bit as opposed to the MCP3008's 10 bit read value. However I did not realize how new the board is and because of that there is basically very little info online on how to go about setting some of this up properly. I know it just plugs into the Pi, but specifically I am curious about how i'd go about wiring it in a way similar to what I was doing with the MCP3008 chip. If anyone has any experience using the board I'd appreciate some help :)