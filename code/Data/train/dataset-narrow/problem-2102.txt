The Acer Aspire-One D255E model has some hardware difficulty in getting SPD data and therefore likely can't intelligently configure RAM. At least the CPUinfo shows SPD field as blanks. According to this blog, the D255E works only with 1333MHz memory, and fails with slower SODIMMS. I am typing this on the D255E model, and I did upgrade the original 1GB memory to a 2GB SODIMM. I can't remember which one I did use, need to open the netbook up. I can tell that graphics performance has doubled from "experience index "1" to index "2.4" under Win7, which is quite more enjoyable. EDIT: I just checked my successful memory upgrade. The blog info appears to be not true: my memory is Hynix 2GB 1Rx8 PC3-10600S-9-10-B1, and it works just fine. 

This gives a clear answer to the concern. The iPad is connected to this SPECIAL "camera adapter". The adapter ADAPTS power feed (through the female lightening port) to BOTH iPad, and to the downstream USB port. The adapter makes the iPad to be USB HOST, but forces the iPad to reverse the direction of VBUS, so it becomes a power consumer. This functionality resembles the so-called "accessory charger" concept from the USB Battery Charging specifications. In conclusion, the lightening cable (connected to "camera adpater") will provide power to BOTH devices, iPad (as USB host), and a downstream (RIAA, camera, whatever) USB device, at the same time. 

First to note, it would be more correct to say, "USB 3.0 to SATA adapter", kind of paying respect to who is the boss (USB host), and not the opposite way. Obviously the adapter is not symmetrical, and a SATA drive can't host USB devices. Now, some older HDD SATA enclosures did use dual-fork USB cables. This was done when only 2.5" mechanical drives were available for portable storage. The mechanical drives have a bad habit (feature) to consume a lot of current during spin-up, so the single-port voltage can drop below the level of control electronics likes, and initialization of a HDD will frequently fail, and the enclosure would fall into infinite cycle mode, start-fail-start-fail etc. To provide more peak current, manufacturers offered a hack in the form of Y-fork cables, to take power from two USB ports. With advent and proliferation of SSD there is no problem with spinning up, and SSDs consume less power in general. Therefore a single USB 3.0 cable with the standard port power capability of 900 mA appears to be good enough in most SSD-enclosure cases. To the question "will this work", why don't you try it, and run some taxing benchmarks on the storage? If it fails, then post another question, and we might help to understand what went wrong. 

You are not supposed to ever use the "male-to-male" dongles or "male-to-male" cables. They are outside USB specifications, specifically for the very reason - so a user cannot connect a PC host port to another host port, either another PC or downstream ports of a hub. For the very same reason the upstream port in hubs has either a Type-B connector (or non-detachable A-plug). When you plug the male-male cable between PC and downstream port, you are setting an electrical conflict, host against host. That's why nothing works when you try this. It is strongly advisable to get some USB basics before wasting too much time experimenting on wrong assumptions. Unfortunately, there are no non-technical interpretation of USB, the best I know of is this one. 

In USB 2.0 framework USB1 devices didn't slow down anything. The problem with single TT (Transaction Translator, to translate HS traffic into FS/LS packets locally, in each hub) was that a single TT would slow down USB1 devices on the same hub, not the overall HS hub performance. In USB 3.x specifications, electrically the USB 2.0 interface is completely independent from SuperSpeed path, it runs in parallel, on dedicated old-style D+/D- wires. Unlike USB 2.0, USB 3.x doesn't introduce "TT" (Transaction Translator), the USB 3.x super-speed transactions cannot be "translated" into HS USB 2.0 transactions. However, internal pipes of the controller and system interfaces (internal fabric) have limited bandwidth, so the system must manage it. The xHCI specifications define the concept of "BI", "bus instance". BIs can be of SS type, or HS type, or LS/FS type. System can assign several BIs to a port, and allocate certain bandwidth for each port, so it is possible that too many USB2 devices may encroach into SS bandwidth. This will depend on xHCI implementation and on software driver stack. It is unclear to what extent modern USB stack is intelligent to manage all this flexibility. This write-up is an example of general confusion in the area of USB bandwidth allocation. 

Totally reset BIOS to factory default. Sometimes a simple jumper-based reset does not fully work, and you need to remove CMOS battery, and short the CMOS rails for a second. Try first a pair of KINFGSTON DIMMs, to see if the BIOS can accommodate one load of this memory; Use fail-safe defaults in the BIOS, and definitely disable any "overclocking" option. ASUS has a lot of crazy tune-ups to appeal to gamer's community. Try to start the system several times, with full power off (including disconneting it from AC. The BIOS might have an iterative fail-safe algorithm, which "remembers" previous state of failures, and iteratively scales the memory setting back. Be patient, BIOS can use some test runs to check memory stability, and big memories takes this longer. Use the latest BIOS, always. 

Let me try. Literally the message says that Linux USB stack has issued "USB_RESET" to your particular device (devices #19 and #20, whatever they are). The error seems to occur once per 10-30 seconds. After reset, the log should have fresh enumeration messages, since USB reset will force the connected device into "default state". Looks like verbosity of your log is very reduced. Resetting a USB device in the middle of operation is a pretty drastic situation. The controller resorts to this "port" reset if it encounters "transaction error". Transaction error occurs when the link does not complete all required phases of USB transaction, or has a CRC error. In normal USB the EHCI controller will automatically re-try the failing transaction (typical maximum 3 times), and then will set an XACT_ERROR interrupt. Statistically, by error theory, if a link does not respond properly to three attempts in a row, there is something wrong with the particular USB segment, mostly electrically. So the transaction error is considered as fatal, and software tries to recover the link. If tree-four attempts to recover the link fail, the host considers this port as dead, and quits. In Linux however, someone has decided that 3 theoretical attempts is not enough, and Linux software performs additional 32 (thirty-two) attempts, making it 96 (!!!) total. If the hardware link happens to be electrically marginal, the 96 attempts might succeed in 99.99% of the time. Linux software gurus claim that this helps to improve operability of questionable devices/cables. In essence, this technique hides a serious problem with this particular USB connection, which does not help users in long run. The problem could be in marginal voltage (VBUS) supply to the drives, or VBUS glitches, or signal degradation on signal wires. I would try extremely short high-quality certified cables first, and check if the statistics of error changes.