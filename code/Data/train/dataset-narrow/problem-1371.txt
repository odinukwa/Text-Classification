There are already great answers that focus on code style and trip-ups, so I'd like to approach from another angle: as a potential user/debugger of your code. Add/Subtract are not inverse operations While clamping the values is attractive for the security it seems to give us, it also endangers the Principle of Least Surprise. If I have 500p and I add 800p, I end up with 999p (and 99g99s99c). If I then subtract 800p again, I do not have my original 500p; rather, I'd have less than 200p left. If you're concerned about how to display large amounts of money in a limited space, the component in question can figure it out. Perhaps it could progressively leave out copper / silver / gold coins if it needs more space. If I have that much money, I wouldn't be worried about how many copper coins I have. ;) No feedback on failure (I am not a C# programmer so I may have this wrong.) It appears that I can subtract 50 coins from 20 coins and end up with 0 coins. This surprises me. If a function cannot do what it claims to do (or seems to claim to do—tricky), it should signal the fault in some way, like by throwing an exception. HasXYZ vs GetXYZ In the case where you have 200cp or 2sp, which is the same here, HasCopper() will return because it also checks HasSilver(), but Copper() will return 0. It feels to me that HasCopper() should imply Copper() > 0, so either HasCopper() should return or Copper() should give the total worth in copper coins (200). Simplify or Go Big My base advice would be to either: 

Going through 10 million randomly generated activities took about 4779ms versus the initial 71183ms, sorting included. You can shave off some more time by giving the roster an initial capacity (like the 40000 you mentioned). With many activities and many time slots, we may need to set up a balanced interval tree. I'm not sure if this is within the scope of your course. 

TreatmentAspirin "If the treatments include aspirin and paracetol, then insuline was injected, because they are dead." I feel like I'm missing something crucial to understand this. 

Entity manager factories are usually pretty expensive to create, since they must parse their configuration and mapping files, and possibly set up a connection pool to your data source. Factories are thread-safe, so it's safe to have only one per persistence unit in your application. Recreate the factory only when it fails to create an entity manager (and log when you had to do so, because it may be indicative of problems). Close the manager when your application shuts down, to give it the chance to shut down and cleanly disconnect any database connection pools. That said, my experience is that this manual managing leads to bloat and maintenance overhead. If adding a library or container to help you is out of scope for your application, consider creating a template class so you can focus on the what instead of the how-with-resources. 

You can go another step and make the comparer use only one value to track the relative value during the comparison. This is limited to 31 comparisons for a 32-bit integer. 

You could probably reduce the number of branches in that code and get additional performance using SIMD, like SSE or AVX. All of the variables in would fit in a few registers. It is likely for the compiler to be using a lot of branches in that code. I can't tell from here but I would guess you have a lot of unpredictable branches. Unpredictable branches kill performance, because the processor is wasting its time trying to speculatively execute the wrong instructions 50% of the time, then flushing the pipeline and restarting. You can immediately eliminate some ifs, by multiplying by 1 when you don't need to multiply by -1. A ternary is likely to be a conditional move, if the instruction set has it. To eliminate branches, you can use vector comparison intrinsics. They do not work like typical comparisons, instead, they generate a result with all binary 1's for true, and all binary 0's for false. This way, you can write the code to compute both sides of the , then bitwise-and () the true path against the comparison, bitwise-and the else path against the ones-complement of the comparison (), then bitwise-or () together the two execution paths. This will leave you with the correct execution path's result in the result. The reason: it is often far faster to compute both paths and select the results at instruction retirement than it is to constantly speculate through branches in the wrong direction and flush the pipeline and start over at the correct target. Modern CPUs aggressively compute far ahead of where the program is really executing, and mispredictions throw that work away. 

You can replace that with a helper that uses branchless code to carry forward the true or false with bit logic. Branchless code 

Note that I forced in fake data because I cannot do the real ajax request on jsfiddle. I had to rip out that foundation thing to make it runnable too. You should have no trouble modifying that second part to actually use the post. EDIT: If you wanted to have a more complex template, say, a span with text and icon then you could do something a bit like this: 

Ideally, look into replacing the forever-loop by requiring your client to either write an array or list, or by prepending the message with the number of expected commands. Other Remarks 

(1) If you're confident about your data being densely distributed and bounded, you can replace this with an array for quicker access—approaching O(1) i.o. O(log N)—but it's going to make your code messier dealing with edge cases. 

The short answer is, yes, a getter will do fine. The longer answer, much hated answer to most any question, is: It depends! (dun dun dun). Providing a getter solves the problems that would come with adding methods to the interface. But—and there is always a but—you risk running foul of the Principle of Least Knowledge, also known as the Law of Demeter. An example will make this clearer: 

No, the algorithmic time complexity is probably as low as can be. Overall impression: This is pretty good code. There are ways to make the code more performant in terms of instructions executed: 

For range queries to work, however, you will need to change the way you store the IP addresses so that they can be quickly compared. You could either make them string-comparable through making each segment always 3 chars long, or you could parse the address as a number and use that: 

The name of is misleading; while it does construct URLs, among other things, it also loads network resources. Consider splitting the responsibilities: 

Now that the logic is more separated out, maybe it would be a better idea to move the parsing itself to PatientType. It's independent from Quarantine: 

Note that we check if the stopwatch is currently running when asking for elapsed time: otherwise, we're going to get a very strange reading. Now we can 'clean up' a little bit to follow conventions: 

The code looks decent enough. I'd like to point out three issues, though, all related to timing/multi-threading. GUI → EDT All GUI operations should happen on the Event Dispatch Thread. Java boots into the Main thread, which is different from the EDT. Your should be called on the EDT: 

On the whole, yeah, looks good. I recommend you use braces for one-liner blocks as well. In this instance, I'm not batting an eye at it—it's fine—but it's a good habit to learn.