To my knowledge, there's no way in which you can put a sleep mode in your fstab entry. If it's not possible to leave the RPi on all the time, I would mount the drive using the root user's crontab and the @reboot flag. The key part you'll need is bash's sleep command. Steps: 

This project is going to require additional hardware. Windows 10 IOT is not a real time operating system; that makes millisecond precision rather tenuous at best. Your best bet will probably be to use something like an Arduino, and have it communicate with the RPi as necessary. 

Unfortunately, you're not going to be able to get the time information from the DVB-C. The company that builds the tuner you listed doesn't provide an interface to interact with its hardware. It's theoretically possible to reverse engineer the software provided, but it'd be a ton of work, and I can't guarantee that the hardware even has the ability to provide the current time. Just because the signal provides it doesn't mean the hardware shares it. It would be much simpler, and far more reliable to install an RTC like Steve suggested. 

Sure, there's no reason that you couldn't connect one RPi to another via the GPIO pins. You'll have to work out some kind of protocol to pass messages, but that shouldn't be too difficult. I would be careful about powering multiple RPi's through a daisy chained GPIO setup. If you have three RPis hooked up in a line, the first RPi has to deal with 3x the current it needs so that 1x the current reaches the final RPi. If you're not careful, you could wind up with a string of dead RPis. 

mariadb by defaults uses UNIX_SOCKET plugin to authenticate user root. $URL$ It works by retrieving uid of the process that has connected to the socket and allowing to connect to the MariaDB account with the corresponding user name. In another word, if you are running your RPi as user, when you run 

Data communication are often serialised and transmit in instead of string. Bytes in python are indicated by the prefix in front of the data as you shown but you are trying to treat it as a as your if statement is trying to compare, you can confirm that the return data are indeed in bytes by by running: 

The default password for is blank. By the way, once you log in, you can verify that root indeed uses unix_socket by running this mysql command: 

This happened quite often lately with Raspbian Stretch, somehow running screw up the gateway setting. This can be observed by run the following command: 

1) First since the release of Jessie, many tutorials or past posts of changing the became obsoleted. It was common in previous OS release to make changes directly to the for network configuration. When using Jessie, it will be necessary to make changes through . 2) As mentioned by @Millways, your configuration doesn't make sense. If your netmask is , then both of your routers are actually on the same network instead of what you said on two different networks. Therefore you should check both of your router configurations and provide more information so that others can help you. 3) Since we don't have sufficient information on how your two networks are configured. But in general, if you have two sub networks (e.g. and with an assumption of netmask of ), in order for each network to be able to communicate with the other, you need to setup a static route at router A with settings like (as per your example), and another static route at router B as . These can be done at routers. On the raspberry pi, you will need to setup your wlan0 ssid credentials to connect to router B. Hope this give you a general direction to work it out. 

Steve is correct. A response code of 500 means that there's something wrong with the store's web-server. Usually, this means that they have a fatal bug, or some internal system is down. There's nothing you can do about it. 

The multihub solution should work. You will need to pay attention to the Hub's max power out. Each RPi will need a bare minimum which will increase as their workload increases. I'm sure you can find an appropriate hub, but it probably won't be one of the bargain bin models. According to the Raspberry Pi Foundation FAQ, the power requirements for each RPi are: 

What you're looking for is either or (I prefer the latter). These create a detachable console that you can then leave and then reattach to later. 

AutoHotKey is a windows scripting language. You cannot run it natively on a Linux operating system. It is technically possible to run it through WINE, but that hardly seems worth the effort, in my opinion. The official scripting language of the Raspberry Pi is python, but numerous other options like ruby, perl, or php would work just as well. Your best bet at this point is to look into learning one of those. 

It's an apples to oranges kind of thing. Arduinos are comparatively much simpler than the RPi. Arduinos, as a platform, are all microcontrollers. They have much less computational power, but are very good at managing things that are time sensitive or require low amounts of power. The Raspberry Pi on the other hand is much closer to a traditional desktop/laptop setup. It will pull a hell of a lot more power, but it has a full desktop/server OS. That gives you a lot of flexibility, but introduces other tradeoffs. 

You didn't mentioned what OS distro you are using. But if you are using Raspbian Stretch, RPi.GPIO is included in default installation of Python 2.7, but it does not seems to be included in Python 3.5 by default, you will probably have to install it either running: 

One of the problem about those online tutorials is that they are obsoleted and never bother to update it, and many tutorials were prior nodejs has the official binary package for ARM CPU which Raspberry Pi used. Please take a look at this link for the correct installation. Please noted that the link does not refer to the latest available binary, please visit the official download page of nodejs, and right click on ARMv7 for Raspberry Pi 2 and 3 (or ARMv6 for older Raspberry Pi) to copy the link and replace it with the commands that refer to the early version of nodejs. 

As per @Ghanima's suggestion, repost my updated as a separate answer. I've solved the problem by myself by changing the settings from 

As per @joan's comment, I also decided to solder the DS12B18 and the pull up resistor direct to the back of Raspberry Pi header connector to make sure verify that the problem is not due to pure join to connectivity (see the picture), but I get the same result. 

You should create a user for your current user, and grant all the privileges to the user, this will allows you to access the database server without sudo. Remember to restart the service at shell: 

...This displays the time from the RTC. It may well generate an error because your clock is not initialized properly yet. In any case, we will now set it. (1) make sure the system clock is set using . If you are on a network, it should be set already; if not, get out your phone, or your pocket timepiece, and try something like 

when you have the system time set properly -- being careful to get it right for the time zone -- you can do 

In the 'B' those two USB connectors are wired to the ports on that hub, and the 'inboard' side of the hub is wired to the single USB port on the Broadcom SOC. In the 'A' R-Pi, this chip is absent, and the single USB connector is wired directly to the Broadcom chip. So, to upgrade to two USBs, you need to: - remove USB connector and replace with double connector - obtain and install the USB hub/ethernet combo chip - remove the jumpers connecting the port directly to the Broadcom chip Sorry to be short on details - more info can be found on the R-Pi schematic - but the bottom line is it's probably not worth the hassle (and is definitely more than just adding a double connector). 

Supplementary Answer - Troubleshooting with I2C tools While trying to make it work I found it helpful to use i2c-tools to look at the RTC, and you will find many references to this in other discussions. I had added some information to the question on what I found with it; I've moved it to this answer in case it is useful. You will need I2C enabled (raspi-config) and the i2c-dev module loaded - you can force this with a . is not needed to make the RTC work, but it is needed to use i2c-tools. You can install i2c-tools using , if 'i2cdetect' is not present. If you have a Rev. 1 PCB: Change to , and change all the to in the commands. You can do 

The Relay module in your picture is what so called Relay shield specific designed for directly interfacing with micro controller such as Raspberry Pi or Arduino, the board already consists of the protection diode and switching transistor and active/disabled LED indicator. You can connect 5v, GND, and GPIO directly to VCC, GND, and IN at the shield. To test it out before you applying high voltage source to the Relay, connect an AAA battery (Positive) to the anode of LED, and the cathode of the LED to the NO of the Relay. The COM of the relay connect to the negative of the AAA battery. When you activate the GPIO through program, the COM and NO should formed a closed circuit between the LED and the AAA battery. The green LED on the Relay Shield should also turned on indicating that the GPIO pin is pulled to low. 

First, WEP key (i.e. password) only allowed hexadecimal digits (i.e. 0 - 9, A - F) as password, therefore 'hello' is not a valid password, and maximum length for the password is 26 hexadecimal digits (or 104 bits). This is the reason that WEP is not very secure and seldom be used nowadays. If you still want to use WEP, here is what you need to do. Run your editor (example using nano) to modify the configuration of file: 

I'm not sure this will work but I would try to add in the configuration on Pi zero which basically telling the Pi to add interfaces that you want brought up at boot time. If this is not working, maybe sharing your and on P3 would help to diagnostic.