Next, don't try to return every type of Object from the one Switch statement, it will always be ugly. In order to work out the next step maybe you could elaborate on what is happening outside the blackbox, e.g. if the calling code wants a Double you could add that into your enum: 

In general try to limit how much you are working with the type and reduce as far as possible your use of reflection. 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

(Note that you don't actually need here, but I prefer to use it as a good practice for the case that I'm writing code where I don't deal with random access iterators.) This is the best solution I could come up with. If you have any improvements, be free to beat me to it. 

I tried to follow most hints and suggestions I received for my previous question about bubble sort. I am aware of the fact that the algorithm can also be implemented in a way that only requires forward iterators, but I decided to require bidirectional iterators here for ease of implementation. Again, I also provide you a file for simple compilation and testing purposes: 

By using an enum you clearly enumerate all the supported cases and encapsulate your data without resorting to data structures that do not fit your purpose. If your data is not clearly defined, or is dynamic or extensible in anyway then the enum approach will not work. At this point I would need to understand the relationship between the key and value in your map. If the key describes the parameter and the two values encapsulate the behavior then the key should be a part of the object (if this is the case you are using as a tuple). In this case you should begin by modifying to include a parameterName member variable and then override and so that you can use in a set. How you chose to override the methods will depend on whether you can have multiple instances of a parameter with different values or whether each parameter name should be unique. If your data is hardcoded today, but might not be tomorrow, don't worry about it. If your data is hardcoded today and won't be tomorrow you could define an interface, say . This interface can expose whatever maethods might be useful to you - size, iterator, next... Create a single implementation for today say or - whatever accurately describes the data you will be feeding back. This means that in the future you could add a or or whatever. Now, inside your you could create an enum as described above. If you need to iterate over the values to convert them into another structure you can use the method: 

This helps eliminate redundant layers of indentation and makes the code more readable. Since you don't write anything to the argument string, you should use to iterate it (in addition to making the parameter , see point 1). Please, don't use . It's horrible. Why? Because it does not do what its name advises and is pretty much redundant. does write an end-of-line character, but it also flushes the underlying buffer, which is seldom what you want (and if you really need that functionality, you should use ). 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

Code Style and General Issues I will get straight to the main point of this answer: What you wrote is basically C. You use basically nothing of the things C++ offers you. While that is generally a valid thing to do, you posted your question with regards to C++ coding improvements, so a big part of my answer will focus on making your code more C++-like. In addition, there are some other issues which have nothing to do with whether you are working in C or C++ that should be addressed as well. Let's get started! 

Are you changing the fields that you expose from your objects depending on certain conditions? On the whole it would be best to use reflection only as a last gasp. Gson works fine with collections in general see the documentation over at Google. If you want to exclude some fields from serialization then you can use the annotation, as documented here. This requires you to annotate all fields that you want to serialize with the annotation, and to use a builder to instantiate your Gson Object like so: 

should be the first modifier in most cases. Things like are bad because most people are used to thinking of it as an which is also , in contrast to a which is also (i.e. the first level of categorization is usually , then ). Leave a space between and the corresponding angle brackets/quotation marks. The fact that has a "meanings" comment hints you at the fact that you should probably choose better names for your variables. Usually, typing a few more characters is not going to hurt your coding performance very much (especially not in times of auto completion!) and will make you code much more readable. As a reviewer, I do not want to switch back to to look up the meaning of a variable every time I encounter one. should probably take its parameter by reference, because you are not actually doing any modifications to the object. You should rethink your approach on ownership. Currently, does not own its children, which means that they have to be owned by something else. That means that your whole design structure is not self-sufficient; you always need some kind of class that maintains a vector of all current , to which each of your s only holds a reference. You also need to make sure that none of the objects expire before your , or else you will run into undefined behavior. Also, if any of your are moved, you will need to update their reference accordingly in their , which is cumbersome at best and invokes undefined behavior at worst if you make a mistake. Thus, I suggest you to change the relationship into an owning one, and possible give out references or pointers to other users (also, you still need to face the issue of relocation and thus invalidation, which is why you will probably need another layer of indirection (i.e. a vector of )) If you want to begin your class definitions with the public members, I would recommend you to use instead, since all members of are implicitly public unless marked otherwise (still, this is very much a question of personal style) Use the correct integer types. For example, it appears that can never be lower than 0, so it should at the very least be . However, for variables denoting a length, is generally more appropriate (especially since you assign it the length of a string, which is also of type ). 

Then onwards. Arguably this is borderline procedural but with these few steps I think that is acceptable. Edit: Less readable, more old school 

The main difference here is that you have deferred the creation of the random value to the callers end. The calling code will also be required to either use generics too: 

If you cannot rely on a selector (like I used above) to find the elements that you are interested in, or if you cannot add classes to the elements when the page is assembled then you could add the class in code: 

They are inherently unsafe. You have no guarantee that the pointer you receive is a pointer to a valid, zero-terminated string and not to anything else, like an array of binary data, or nowhere at all. C-Strings are dumb. They don't contain length data, nor anything else besides the address of their contents. Usually, you are wasting performance here by having to call on a string whose length is theoretically known at compile time. 

There are a few things here that could improve your code (whether the code becomes more succinct or not is a matter of debate, but it will definitely become more readable):