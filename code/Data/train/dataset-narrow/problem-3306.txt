You can add additional storage only though USB or Ethernet, as these are the only external high speed interfaces available. If you are looking for something small, consider USB flash drives. You can get them up to 128GB, for a total of 512GB on a Pi. Note, though, that its possible that you won't be able to use as many as 4 USB flash drives in the Pi if they draw too much power, but you're probably okay. Another option for something small is a USB Wifi adapter - it is small, and allows you to remotely have access to storage on other machines on the network. In that case, your storage is effectively unlimited. 

Its reasonably likely that you blew the fuse. The Raspberry Pi has a polyfuse, which will "blow" if you draw too much power from the Pi. A quirk of polyfuses is that they can take a long time to reset. Set your Pi aside, and try using it again in a few hours, or tomorrow even. Google "Raspberry Pi polyfuse" for more info. 

Total speculation: it's reasonably likely that the Raspberry Pi wires the 5V HDMI directly to the Pi's 5V input. If so, the VGA converter will have power equal to 1A minus whatever the Pi uses. 

Another datapoint, if its useful. I regularly shutdown via ssh, but I run ssh from the command line (not via Putty). The following shuts down my Pi and powers off (HDMI out becomes disabled, but always on Power LED stays on). Note: this is on Raspbian, and I ran uname to show you my version. The commands below were run remotely from my Macbook. 

If you are looking for something extremely simple, consider using netcat (this is similar to the ssh approach, but likely a little faster). netcat is including in Raspbian by default. On the "server" RasPi (the one that will be setting a GPIO, assuming GPIO4): 

TL;DR - That cable is probably NOT HDMI compliant, but likely still works. As you said, you do need an active converter to convert from HDMI to Analog (VGA). Analog signals are not provided by HDMI. However, some cables (like the one you linked) do not have an external power source. If that's the case, then they are powering from the HDMI cable themselves. The HDMI spec says that you can draw at most 55mA, which I believe is far too little for a VGA converter. I suspect that cables like the one you linked are not HDMI-compliant, but still may work. Note: here's what the HDMI association has to say on it: 

Here is an example of a valid but not-ideal answer. It is kind of hacky (several wires, plus extraneous microusb port?, etc), but the use of a good Adafruit design is definitely a plus. However, if you look at the page detailing how to use this, it's got quite some quirks and relies on some GPIO behavior that is not guaranteed depending on whether a Bluetooth-having Pi is used or not. Here is another product, but this does not meet the requirements by virtue of not supporting any charging capability. So it's just going to drain the battery and then we're done and have to swap the battery. I want a little bit more convenience than that. A Zero Lipo with charging would be nearly perfect. Even if it has just a few more components!' OK. I found the UPS PIco. This has the features I want, although it is a bit bulky. I think I am just asking for something that does not exist just yet. Hopefully soon! 

I'd like to drive a high powered WiFi adapter, and I'd like to maintain the voltage safety mechanism and continue to power it all from the micro-USB so that I don't have to make unsightly modifications to the USB headers or my adapters. I can splice the USB connection to pump 5V into the Wifi adapter only, while leaving the Pi running comfortably with the F3 polyfuse in place. That's the alternative. Furthermore the external power supply may be fused. This is entirely serviceable, however I would really like to maintain the modularity of the system. So to entertain the possibility of keeping things clean and boosting the power that can be accepted by the Pi, safely, I am reading up about the power circuit of the Pi... The schematic shows rather nicely how D17 upon overvoltage will short across F3. Since I expect to surpass 700mA through F3, F3 has to go. But then nothing protects me from catastrophic short circuit under an overvoltage situation. The answer must be to solder a slightly higher amperage polyfuse (or any other kind of fuse) on top of F3! Has anyone done this? After looking at the schematic I'm pretty confident that this is a safe mod, but it sure will be a pain getting it soldered on properly (I may end up jumpering it). 

Given your issue seems to be with the messiness of restarting fbi, which is intended to be interactive program, here's a (perhaps) better approach (but still simple): Get imagemagick: 

The bigger issues are going to be how useful the data received is for analysis. Things like clock jitter, bits of resolution, and probably most importantly the analog front end will strongly effect what you can do with the data. For example, if you have a specific signal you are searching for, then the details of your implementation will very well matter. But, if you just want to use it to get a rough assessment of the signal, the above will work fine. 

As you've created a tkinter program, I'm assuming you're running it in X windows. So the question is more 2 questions: 

An approach that potentially requires less wiring is a keypad matrix. It essentially looks like this: $URL$ You then would "scan" the rows by only enabling one row at a time, and reading the column to see which keys in that row are pressed. You'll only need enough GPIOs to make ROWS * COLS > 84. In this case, 9 and 10 would work, which means 19 GPIOs (the Pi has 26 available on the header). 

If you are using matplotlib, then you are using Python, correct? If so, then for FFTs, you'll likely want to look at scipy or numpy. For generating WAV files, Python includes a library called wave that can generate wave files from raw samples. 

The Pi doesn't have external access to high speed interfaces that would normally be used for something like this. However, for a relatively low speed like 1MHz, you may be able to get away with using the SPI bus: 

Use it to convert images as needed directly to the framebuffer. Depends on your framebuffer (which you can details on in /sys/class/graphics). Lets say the framebuffer was 640x480, and color depth 8:8:8. Then you could use a single command line something like (untested): 

I have ordered one of these products. Looks solid. Not Lipo, sadly. So it is bulky. And this product is definitely the ticket. It does not appear to be available for purchase anywhere, yet, however. 

I just want to add UPS functionality to some of my flock of raspberry pis, and with an emphasis on portability. One of the ways to get this is with certain USB battery banks. I have one here that is capable of continuing to provide output even while you plug the pack itself in to charge. This works, but is quite cumbersome and bulky. What I'd like is a portable circuit that has a battery JST plug or just solder pads, so I can choose what size lipo to use, and most importantly is designed around having reliable power delivery to the pi. An elegant way is to allow for this battery board to charge the lipo whenever the pi is powered via microUSB, and to serve power to the pi as a UPS whenever it becomes unplugged. Preferably, the entire contraption can mount cleanly on the underside of the Pi to enable transparent full use of GPIO pins, and be a reasonable form factor for both full size Pi and Pi Zero. This way, I can use a very small lipo with it and it will still serve a useful purpose, because even with only one hour of reserve power available, which would only require a tiny battery, it does provide the ability for me to hot-disconnect from power without shutting it off! Having a JST plug would be excellent as well as it would mean that the battery can also be hot-replaced as long as the pi is plugged into USB power. Furthermore, the functionality should be seamless so no configuration or limits on which Pi models (in particular the Bluetooth-having versions behave differently in many cases) are used. It really really preferably is a transparent hardware only modification. 

I have an init script that and adds a SSH key to inside. The problem is, when doing this it needs to be done as root and then once the system is initialized, the user cannot save anything new into due to being owned by . When I am on the linux environment that has the OS image mounted (where I make the call) I am unable to run because is not a valid user on this system. Is there any way to do this? Must I create a user on this system? 

To start X windows, you can enable "boot to desktop" from raspi-config. To start an app automatically when X windows starts, add a line to /etc/xdg/lxsession/LXDE-pi/autostart. It should look something like: 

Generally, most likely causes for not booting are issue with SD card or issue with power supply. If you have an extra SD card, try imaging it with Raspbian. If it boots, you'll know the issue is with you current SD card. 

Generally, yes. In Android, the question about whether or not an LCD will work, and what you'll have to do to set it up, is really a Linux question. Do you have drivers for the LCD? If you have drivers, and can build them into your kernel, and configure them correctly, they will in general expose an interface to /dev/fb. Android will automatically find that interface and use it as your display. 

There may be some trickiness if your fb is 5:6:5 format, as I believe imagemagick does not support that. Note that because imagemagick's convert utility understands practically every image format, you can replace my_image.png with most any image. (Imagemagick has lots of other nifty features, too, for example if you wanted to add text or other overlays). 

In general, no - GPIOs don't have a variable voltage output. If they did, we'd call them a DAC. As suggested by xPino, you might be able to use a PWM pin - but I suspect that the backlight pin on the LCD is going to have higher current requirements than can be provided by a GPIO (or PWM) pin on the Broadcom. You'll have to look at the LCD datasheet to find out. 

Yes, just as a point of reference, I have a SIIG serial adapter (based on FTDI's FT232BM chip) that works fine. Check out: 

As concern over long-term SD card reliability is frequently mentioned (and is a valid concern, especially for low-quality SD cards), there is another approach: initramfs (or initrd). This requires a little more dirty work, but essentially you need to rebuild a kernel with your own initramfs (or separately build an initrd). The initramfs would include everything you need to run your application. As the Raspberry Pi 2 has 1GB RAM, there is ample space for most applications that do some "basic automation and statistical generation". Of course, if you need some larger application, like X or Mathematica, all bets are off (but 1GB can still handle a lot of stuff). Of course, the SD card is still used - but it would only be used at boot time. In fact, Linux would never need to use it at all, only the bootloader. If you want to keep the initramfs very small, a common approach is to use a GNU replacement, like busybox. There is lots of info on both initramfs/busybox out there, and it is not Raspberry Pi specific.