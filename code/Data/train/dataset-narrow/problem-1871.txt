only generates a single invocation with all matching files given as an argument list (in practice it behaves like ). executes the command once for each matching file (the needs to be escaped in the shell; hence the preceding ). Note that some versions of lack the option, but the GNU version is most likely installed on anything non-embedded Linux. 

An interesting but somewhat hidden feature in Chrome is that it actually siphons visited search engines continuously and provides easy access to their search URLs via the browser preferences. As an example, right now I went to Google Scholar and did a dummy search ("test"), and directly afterwards I can go to "Settings" → "Manage search engines…", and now "scholar.google.com" is in the "Other search engines" list with the correct search URL already filled in. The second column represents the keyword, so just click it and enter "gs" or whatever you feel comfortable with, click "Done" and it is indeed done. It's not difficult to manually add engines for that matter, but this is a nice but not really advertised feature. I follow the "unstable" branch of Google Chrome, but this is not a new function, so it might very well already be in the stable branch. 

Primarily make very sure that your port forwarding is active and that it is working correctly. Problems with this are so common it is ridiculous — the router, Windows firewall, perhaps an extra local firewall must all play ball. Sometimes restarts are needed at the router, etc. My tip is to absolutely positively check that the port forwarding rules work before looking at other parts. 

No, you do not have a 6.3GHz CPU. It would perhaps be something that someone without technical knowledge in a marketing department that tries to sell you new hardware would say, but it is false. 

Issue in a terminal without arguments and press Ctrl+←. Paste the entire keycode that occurs ( in my case but most probably something else for you since it doesn't work by default) into the irssi bind command: 

if you want to pipe it like that (but always try to use the file name version directly if it's available). 

A lot of content is not searchable for the simple reason that it is created dynamically when requested, or is behind limited access in multitude of ways (pay walls, etc.). This is the original meaning of the phrasing "Deep web". By its very definition, the "deep web" is not searchable. It is a term to describe the collection of material that is explicitly not searchable. It is not, as some entities like to use the term, some "cool" part of the internet where "regular people" aren't allowed. I admit that "deep web" sounds cool in the same way as "black hole" does, but in practice that does not make any difference. E.g. I run a personal web server. Some parts of it are restricted to real life acquaintances in different ways. Would it make sense for you to access it? Hint: No. The statements you cite, e.g. 

If you have shell access and your shell user owns the file (or your user can change to the file's owner (su/sudo/…)), then just it back by hand. Otherwise, if you can edit the PHP script (and the PHP runs as the file's owner), just edit it to the file to the desired permissions. 

C-x means Control+x, so C-a is Control+a. M-x means Meta+x, but there probably is no Meta key on your keyboard. So instead, you can use ESC x (i.e. Escape then x). Terminal has an setting to automatically send ESC before keys pressed with Option held down. Using this feature disables the extended character handling that Mac OS X usually provides when using the Option modifier. So, if you use few extended characters and want to have Option+x send ESC x, then you can enable this Terminal option. There are lots of ways of moving to “Hello” in your example: 

Any configuration file that lives in a directory can be placed in a template to serve as the initial copy for that file in new repositories initialized from the template. I suppose you could even provide initial objects and refs. Once you have a template directory made up with your customizations you must tell and where to find it. This can be done explicitly with the option (Git 0.99.4 or later), or implicitly with the environment variable (Git 1.5.0 or later), or implicitly by setting the configuration variable in the “global” (per-user) or “system” Git configuration files (i.e. or (varies by installation); Git 1.7.1 or later). 

You can see how this burns a lot of time (the diagrams even skip over the character-by-character backtracking which actually occurs; only the “high points” are shown above). The problem comes from having an earlier bit of the regex greedily match something that the later part of the regex will eventually have to match to get the proper number of repetitions of the group. In my expression, each repetition () never matches anything that the following element () would match, so the backtracking is purely linear. Once backtracking starts for each “shrinkable” match, it will (in linear time) find that there are no earlier places where the following expression can match; this forces backtracking to continue with the previous “shrinkable” match until nothing matches and the whole line is decided to be non-matching. Instead of “zero or more non-pipe, then pipe” (), it is also possible to use with an explicitly non-greedy repetition ( in Vim, but it varies; other regex languages use ). 

So, means "print everything that consists of one or more word characters followed by ()". This will still match e.g. the part of . One could argue that the parentheses actually end the word, which makes "a word that ends in ()". I assume that this is not an issue in your actual use case anyway. 

in the script instead of to kill the parent shell (tip: try just echoing the pid first and check which process it corresponds to so you don't kill your WM or something). If doesn't do it for you, you can also try sending the pid as a parameter to the script, but it depends on how and where it's called. 

When run, you can enter a command, press Enter, and it will be launched in the background. If you want the shell to automatically think "ah, this is a graphical program that he wants to run in the background" and only then add a , then you'd need to keep some sort of list on all these binary names, and it would most likely be a great annoyance to other operations. If your question is "How do I catch Ctrl+Shift+- in xterm and act on it?", then I don't know. All in all: I strongly recommend to just use a stand-alone application launcher, and get used to the shortcut for that. 

I propose that step 2 should not be needed with the switch to , but if you do some experimenting, you will probably see how it works in practice. Note that the forum post lists the packages and as prerequisites for Retrospect (this is where multiarch might be needed, but the person in the forum post seems to have managed without). 

It is straight forward, but quirky, to add logic to get the same fancy output as has. could be used to filter and reverse lines in a single command instead of and , but it would be a bit more convoluted. EDIT: Added to better handle spaces. And on that note, a pure version with the same output as the above script in its current form: 

Run as the first time to be able to visually inspect the renames without doing any changes. Check . The rename expression works by first padding all numbers with n-1 zeros, then removing as many zeroes as is needed to have n digits left in all numbers. It will not truncate information, which is nice. Float numbers are not handled above (e.g. ), but can be easily done with 

The benefits of tree-orientation, chiefly the ability to view commits as a unit of interdependent changes made to various parts of the whole tree, general greatly outweigh the extra typing (which can be alleviated with aliases, scripts, et cetera) and CPU time spent digging through past commits. Storage Efficiency When a new object (e.g. a file with previously unseen contents) enters the system, it is stored with plain (zlib) compression as a “loose object”. When enough loose objects accumulate (based on the configuration option; or when the user runs git gc or one of the lower-level packing commands), Git will collect many loose objects into a single “pack file”. Objects in a pack file can be stored either as plain compressed data (same as a loose object, just bundled up with others objects), or as compressed deltas against some other object. Deltas can be chained together to configurable depths () and are can be made against any suitable object ( controls how widely Git searches for the best delta base; a version of an historically unrelated file can be used as a base if doing so would yield a good delta compression). The latitude that the depth and window size configurations give the delta compression engine often result in a better delta compression than the CVS-style simple one-version-against-the-next/previous-version “diff” compression. It is this aggressive delta compression (combined with normal zlib compression) that can often let a Git repository (with full history and an uncompressed working tree) take less space than a single SVN checkout (with uncompressed working tree and pristine copy). See the How Git Stores Objects and The Packfile sections of The Git Community Book. Also the git pack-objects manpage. * You can tell Git throw away commits by “rewriting history” and with commands like git reset, but even in these cases Git “hangs onto” the newly discarded commits for a while, just in case you decide that you need them. See git reflog and git prune. 

I do not have bsdtar on my machine (it is tar in FreeBSD, as well as tar in Mac OS X 10.6 (older releases use GNU tar); it is available as bsdtar on some Linux distributions: Debian GNU/Linux, Ubuntu, and some RPM-based distributions), but looking at the code, I am sure that invocation will just cause an “Option --strip-components is not permitted in mode -c” error. If you want this, you will probably have to roll your own program (or get someone to do it for you). Fortunately, this may not be as hard as it sounds. bsdtar is based on the very nice libarchive library. It looks like it would be fairly straightforward to make a program that does what you want. Since bsdtar already has most of the code you would need to copy one archive to another (through its handling), you could probably even do it by adding some functionality to bsdtar. An simple “damn the architecture, just get it done” approach might be to enable for mode and add a call to inside . The problem with this approach is that all the transformations would be applied to both entries from s and the pathnames of actual files specified through other means (command line args, pathname lists, etc.). This behavior may or may not in the best interest of official bsdtar (there is probably some reason is not already enabled for mode). 

First: EDIT: original post edited to clarify, just a typo Second: is recommended before (read ) (if is available on your system, of course, maybe it isn't (though I don't know a mainstream Linux where this isn't the case)). Third: does not take the cleartext password! Read . If you look in , you'll see the password you entered with in clear text, but when you try to log in it will be assumed that the password entry is encrypted. 

(line breaks added for clarity). This moves finished downloads to a path that is set as the downloads are started (ignore - used for a different purpose, but I keep it as an example). As you can see, external scripts are executed and their return values are caught by rtorrent. By having external scripts that keep track of what you have downloaded (e.g. writing hash or file name to a log file/database for finished downloads) and check new downloads against this list ( or DB utility) and act on this, you can achieve what you want. A complete run-down of rtorrent's scripting abilities is far too comprehensive - see the manual and online resources. I'm not saying it is self-evident or easy - certainly not - but it is possible :-) . 

Even if you use a browser that is light-weight on CPU and RAM on the server, in this case the limiting factor will undeniably [1] be the network. What you want to avoid is mostly unnecessary screen rendering. 

In very loose terms, to emphasize where the complication lies: The bits on the drive are interpreted as binary, "1" and "0" if you like, but in reality it is a continuous variable that is measured. One could figuratively say that every bit really can take any value between 0 and 1, and the drive interprets all values >0.7 as 1, and all values <0.3 as 0. Let's say a bit is at charge 0.9. You then overwrite it with a 0, which effectively lowers the charge. The final charge will be maybe 0.25, but if the bit originally had been a zero at charge 0.2, maybe it would end up as 0.15. Thus, by using equipment possible to read the charges at high precision, in theory one could recreate data that has been overwritten by all zeroes by using a normalization where charge<0.2 is a zero and charge>0.2 is a one. If one instead overwrites the data with random numbers, it is instantly much harder for this recreation. That's why it is preferred for very sensitive data. In reality algorithms are much more clever, depending on how good the resolution of the equipment used to analyze the magnetization of the disk is. There is a reason why the data recovery companies charge silly money :-) 

This abuses the “repeat” binding functionality by using it to stay in “prefix mode” while basically ignoring the first byte of the UTF-8 encoding of ù (hex C3 B9, octal 303 271). The first byte of ù (octal 303) is bound to a dummy command, and the second byte (octal 271) is bound to the target command. This requires that you must not have set the tmux option to zero (to disable repeating), and has a side effect of leaving tmux in its repeat mode for milliseconds (defaults to 500ms) after you have typed Prefixù (this side effect will usually only be noticeable if you immediately type an arrow key (with or without Control or Meta) after Prefixù—those keys are the only default bindings that are “repeatable”). The above example uses the shell command to generate the required bytes, but this will not work in your . If you were running tmux 1.7, you could write it like this (in your ): 

But since these are the default, you will need to track down where they are being changed/removed before you will know where to put the above commands to make them effective (they will need to come after whatever else is modifying the bindings). Are you sure your option is set to ? It does default to , but tmux will set it to (along with ) if you have the VISUAL environment variable set and its value has in it†, or if you do not have VISUAL set but do have EDITOR set and its value has in it. You can check your global value with . You may also have a per-window value (omit the to check its value; you may use to target another window if you can not run the command in the window itself). If you want to override the “auto-detection” and always use the binding tables, then you can put these lines in your : 

In my version of Vim, after using that sequence, the last visual area is slightly wonky (re-selecting it with selects an area that is not quite right). To move around in the current visual area a user can use (and maybe if using a block area) interactively, but these are not deterministic if you want to use them in a map. So, I wrote the function below to make a deterministic version of (defined as and below). The example command uses them to do a similar ‘wrapping’ as the above , but also fakes keeping the visual area selected by re-selecting an area () after doing the wrapping: