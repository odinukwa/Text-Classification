The TMP36, in my experience, will not work with Raspberry Pi this way. I do understand that there are online sources where people say it works, but that's not been my experience. I have made it work using an op-amp as a voltage follower. I got on the right track using the instructions on this thread: $URL$ The relevant part: 

The need for this is somewhat mitigated by the fact that you typically don't need a password to run on the Pi, but it's good security practice on most systems. Related discussion here: $URL$ 

I was expecting the question to be if this could be harmful to you! The answer to that is potentially yes. This current flowing is a sign of a problem in your wiring, which should be fixed or replaced. The Pi, as a secondary consideration, could also be damaged for the same reason. Whatever is causing this stray current may be unstable and cause a surge. Your Pi also cannot handle high voltage, so its circuits are exposed to anything near 120 V or 240 V (depending on your location), it will be fried. 

This is not possible, at least not as you've stated the problem. There's no magic way that all of the computers on your network are going to know where you put the DNS that does the resolution. Many (but not all) home routers now do this automatically for you, but that's a feature of the router that yours may or may not have. If your router does not have it and you want your own DNS, you will need to configure that on the router. An alternative to a proper DNS that does this would be to modify the "hosts" file on each machine on your network. If you have a small network, this can be a good option, but it can spiral into a maintenance problem if you have a lot of machines or your network changes frequently. 

This is ultimately a question about Java that has nothing really to do with Raspberry Pi or pi4j. You need to provide the path to external libraries / sources when you compile and when you run. How you provide the path in Java depends on what type of resource you want to access. I don't know pi4j, but I'd guess that you need BOTH the and the to include appropriate values. The to point to the native libraries that I assume underlie the implementation and the to point to the file with the Java classes. The is typically set at the operating system level (or the shell level if you're in a linux-type system). The can be set as an environment variable or passed as an option on the command line to the various Java commands (e.g. and ). You'll need to read the documentation to get a full handled on this. See, for example, the PATH and CLASSPATH tutorial for Oracle. 

The SD disk and the USB do have limited writes, but, in many cases, I think that this limitation is oversold. Depending on how long you're going to run this, it might make sense to just write on the SD card and back it up periodically. (Note that reads don't create the same wear - It's the writes that are limited.) If you want to avoid the SD, your question includes a pretty extensive list of options. Two additional options: 

Put everything that you need to communicate on the cellular network. (In the comments you implied that's the one that you need to work on the Pi.) Create a VPN to tie together the subnets through the public internet. 

To do this you need the IP address of your Pi on your local network. You can get that with on the command line. Let's say, for example, that it was 192.168.1.42. Then you want to forward port 22 from your router to your Pi. (Port 22 is the standard port for .) In the input form that you have, it looks like that will require a row that looks like this: 

I like the Redis solution by @tobyd for some situations. The other option, which is not specific in anyway to Python, would be to structure your script (Python in your case - could be bash, Perl, Ruby) so that it communicates with PHP via STDIN and STDOUT. You can call your script from PHP using and store the results in a PHP variable: 

I think you're confusing two things. One is the circuit on the breadboard and the other is the way that board is connected to your Pi. The other answers so far (and I agree with them) suggest soldering the custom circuit components somehow - either on a custom printed board or on a strip board. I would think in your case a strip or perf board of some sort would be fine. When you do that, you can solder pins onto your custom board just like there are pins on your Pi, and then you can connect the two of them with jumper cables. That should be pretty stable. Alternatively you can put female headers on your board and plug it directly into your Pi as a "hat". I personally would not solder anything to the Pi itself. 

You can get a continuous listing of a file with . I'm not familiar with your specific service, but according what I see online, it keeps two logs at and . You would then get the non-error log with this complete command: 

Now you'll check the current time at the end of each loop, and if you're at the top of the hour, you break the loop. Since you broke the loop, the script will continue - in this case to the end of the program. You need to implement the function to meet your needs. You can use the functions in to do it. For example, if the minute value is between 0 and 1, maybe return true. See also $URL$ 

I don't support Python, so I cannot tell you if there's a more efficient function to call. I can say that you will probably do better if you run the data acquisition and plotting in separate threads or processes rather than inside the same loop. This will prevent your plotting routine from blocking you data acquisition while it works. You could do this by starting two Python processes performing the two tasks, possibly controlled by a batch script or other program to start them and end them together. If you use a different language, then you'd have better tools for multithreading and only need one process. 

If you configure an op-amp at unity gain, it will provide a high-impedance source when the measurement is taken. 

Both options are good, but they are applicable to different circumstances. They can also be used together - For example write quickly to the RAM disk for speed and have a background process copy some of the images out to a permanent storage device in the background. References: 

Anyone else can also to your Pi using your public IP address. You'll need to take care with security. You will be scanned by bots that try to log into port 22 using common passwords and other exploits. Right now your router's firewall is blocking that out for you. If someone penetrates your home network because you enabled port forwarding and made a security mistake, they will likely be able to take control of other computers and devices on your home network. 

In the example and are variables in PHP that you want to go into your Python, and stores what you get back. The return will be a string, so you may or may not need to do some processing on it to convert type on the PHP side. The Python, in this case, has to be set-up to take command line arguments via STDIN and to write the result that you want back to its STDOUT. 

Summarizing the key point about the error logging, the error usually appears under on the Pi. (You'll see other potential locations listed for other hardware and software options at the stack overflow questions since they are more general.) To address the underlying permissions error, if that's what it ultimately is, you may have a couple of options. You might be able to grant the appropriate permissions to the php user, or your might run it with from your php script. That, in turn, may require you to add the php use to the list of sudoers. Be careful with either option - especially if there's public access - because you'll be allowing external control of the pins on your Pi! Having mentioned how to do this, I think it's worth noting that this probably indicative of a bad design anyway. Based on what you said, it seems like php is the wrong tool for this job. If you must allow changes in state to your Pi via web, you're probably better using cgi-bin programs instead. Usually php is for serving dynamic content in the webpage, not for changing the state of the server. (In this case, the Pi is the server.) That's a whole different set of questions and issues though. 

The Pi isn't going to give you more than 5 V natively. To go beyond that, you either need to use an external power supply, which you can switch on and off with a transistor, or you need something like a "boost converter" to up the voltage on one of the GPIO pins. If you do the latter, you need to take care to ensure that you don't accidentally pull more current than the Pi can safely provide. Emphasizing in light of the comments: The first of the two options is potentially risky to your Pi if you cannot properly compute, measure, and control the current pulled. For that reason, it's not ideal for most beginners. If you want the simplest answer, try the first option with external power supply. It adds the complication of a transistor, but you should be able to find a lot of information about how to create a simple circuit of this type. Your GPIO pin will connect to the gate on the transistor (through a resistor) and the other pins will go in series with the buzzer and external power supply. 

This seems to behave properly. I think your expectation of what happens on the click is probably wrong. What seems to happen (correctly) is that you click the button, and the browser attempts to load . That file attempts to execute your Python and print the text it gives on standard output. Your Python script writes nothing to standard output, so that part is blank. Then it echoes the text "Hello", which you can see does appear in your browser. If you want the main page to reload, then at some point in your flow, you're going to have to tell it that you want that to happen. Exactly how to implement that is a design decision. Clues for moving forward: I don't think PHP is the best tool for this. Usually PHP is for making the webpage content dynamic, not for executing code on the server. Probably better would be javascript and / or a server-side cgi-script. Of those, I'm more familiar with cgi. You'd have to configure the server for that (a whole different set of questions) and then have the cgi script (which could call your Python) write out the HTML for your "main" page to standard out when it's done. 

The short answer is that this depends on your home router. Most home routers now provide a domain name service in addition to the standard routing. They can vary in how they implement this and how configurable they are in providing the service. The router that I currently have at home does not append anything to the device name. In contrast, I've worked with routers at friend's houses that do not provide domain name service at all, and then you always have to use IP address to access machines on the LAN. In terms of what IP address you have, that is almost surely assigned by your router. That will differ than the public IP address for your house as viewed to the outside world. That's the basics of what it means to have a home network. If you're not clear on that, I suggest doing some more reading or asking a new question. (Maybe superuser would be more appropriate than this site in that case.) 

The main drawback to doing this on RPi 1 and RPi 2 was that you bypass the polyfuse, which made it more likely that you'd accidentally burnout your device. The Zero does not have a polyfuse anyway, so you you're not necessarily taking any "extra" risk by doing this and, as I understand the device, it should work. $URL$ 

Using the (notional) IP addresses in the text above. You need to modify that to your actual public IP address. Before doing this, however, note the following: 

You have two bottlenecks here that are going to slow you down. First, there's the SPI, which was mentioned in a comment. That takes a few clock cycles in each direction and will limit you some. The second is writing to the SD card. I expect that the second is more important for your speed. Disk writes are generally much slower than computations, and the SD card is even slower than disk. If you just want to use the whole number of CPU cycles, try taking those out and see what happens. Of course that means you won't be accomplishing your task, so then you'll need to put them back in some other way. A possible option would be to buffer your write-to-disk operations and have them trickle out in their own thread while the rest of the code runs. This may or may not work - For example, you might over-run the buffer and crash. You'll have to do some design and experimentation. 

It's not running in any terminal, so there's nothing to see. Terminal is an interactive program that can use to start jobs and receive output. Programs can run other ways - For example launched from graphical desktop or via script as you have done.