The files in packages are for compiling userspace applications; they're e.g., part of the syscall interface. To compile a kernel module you need to compile it against a kernel source, and you will find all those files in . You can get the source for the Pi kernel from the top level of that github repo. You must make sure you use the exact same version as the kernel you are using; check , and the source version is at the top of the top level Makefile (e.g., the one linked above is 4.14.39). Or.. Normally on linux distros the kernel source is available in a package; on Debian this is called . I do not have a Raspbian system running, so I cannot check this, but have a look at the output of: 

Actually, that's for a; I don't have a NumLock on this keyboard. Every time you press a key you will get a "KeyPress event" and a "KeyRelease event". Note before this there's probably a "KeyRelease" for the Return at the end of the command. Don't move the mouse or you may loose the functionality. For both events, the third line with "(keysym ____, ____)" should mention . Notice right before that it says, most likely, "keycode 77". ("a" above is 38). The number may be different; this is the information you want. You can stop by closing the little white window with the mouse. Now: 

You should get some output from the last one, probably regarding . If not, the phone is not configured to share a connection. If so: 

Notice the three bands on the 3.5mm jack, one more than a standard stereo plug (these are actually separators as I believe in both cases there is an additional pole for ground, which is the sheath on the RCA end). These are commonly available at electronic stores or online (search for a "3.5mm to RCA video cable"). Beware as mentioned here (thanks Milliways) some of these cables are intended for camcorders and have one of the rings on the 3.5mm jack swapped; those will not work. So don't get a cable that is intended for use with camcorders! 

It's not an image which you can run directly, but an installer, but it does have an ssh server running by default: $URL$ It is quite minimal though (no X etc), so you'll have to install all the packages you want yourself. 

In scenario 2 everything may look fine right now, but there's a reasonable chance that things go wrong when you plug in extra devices, like a wifi adapter or 'more dangerous' an external drive which takes the power from the USB bus. There is a variation to scenario 2 and that's when you use (or for the Pi 1) as kernel and have DeviceTree enabled. See $URL$ and (upstream report) $URL$ In that case there may be nothing wrong but the red power led is still not on. This applies to the Pi 1B+ and Pi 2B, but not the Pi 1B. 

There is now also an X-less image by the foundation named : $URL$ And if you want an installer which installs only a minimal system, there's also the Raspbian UnAttended Netinstaller 

Have you tried the Raspbian UnAttended NetInstaller? Without any customization it would install a very bare-bones system, but you can customize it in a number of ways, see $URL$ for details about that. The most interesting part for your use case seems to be to script your customizations in . While it has a extension, it is sourced from the main installation script and thus executed as script and you're free to (ab)use that fact. And this is not some dirty hack. 

And now you're ready to compile a kernel module. Step 4: Compiling the kernel module You're lucky as someone has posted the source file and a Makefile to compile the module. To compile it, go back to your home directory, clone the git repository and make/install the driver: 

Important: Follow these instructions meticulously Note: The OP is using Wheezy and the latest kernel version from then is , while on jessie that version is and that's a critical difference! If you're going to apply these steps to your own situation, adjust the values accordingly. Step 1: Get the git_hash from the firmware Get the firmware-commit-id: which returns or for short. On $URL$ you look for that firmware-commit-id ( on 23 Sep 2015 (the date is only as extra helper, the only relevant thing is the firmware-commit-id)) and click on Browse the repository at this point in the history and switch to the directory. When you're there, download and save it in your home directory (for the Pi 1, you'd download ). In the directory you'll also find a file which you should open and write down the id () you see there. This is the kernel-commit-id. Step 2: Prepare the kernel for module compilation Get the kernel sources and put them into the folder: 

There is a tarball: $URL$ Since it looks to be written in PHP, it doesn't need to be built and you don't need a special ARM version for that Pi. I'm guessing it plays nicest with apache. In any case, Nextcloud has documentation for the server. Raspbian is a form of GNU/Linux, so you will want things that apply to "linux" (since it apparently won't work on Windows, the docs are probably very linux oriented). If there are further distinctions made, you want the instructions for Debian (preferrably) or Ubuntu. If you run into a snag there and need to ask for clarification, they also have a forum. You might also try our larger sibling site Unix & Linux. Since the userbase here is smaller, and not necessarily all nextcloud users, avoid asking detailed questions about Nextcloud here unless you believe they are specific to the Pi or Raspbian. 

Which doesn't mean it is going anywhere, but you might as well use , which will also show everything. If it still doesn't show up, it's probably because of this -- note no available linux driver. That's unusual, but to spare yourself grief you should check around before buying. My recommendation about wifi drivers is to get them from a brick and mortar place close by that will take a return or exchange no questions asked within a short period of time. However, grepping through the kernel source, I found the ID registered and "Linksys WUSB6100M" in corresponding comments. Unfortunately, it is for the driver which 

You may not need/want the last line if you've set up a DHCP service (just assigning the CIDR will work without DHCP if the connected devices set their own static IP and default route). I'm presuming based on your question that refers to the subnet you are creating and not the WLAN the Pi is on. 

There will be at least one package, but most of them are probably from Debian, not Raspbian, and are of no use on the pi. Look again at the output from . If there is a version number that matches, try installing that. Then go to the directory that exactly matches, e.g., if gives you , you want to look in . Then try and look in the directory there. If it is not actually a directory, but a dangling symlink, you will have to install the source from github as already mentioned above. If it is a directory with lots of stuff in it, you are in luck 

For the Pi 1 you should replace with . Now copy the file you downloaded earlier into the kernel tree and rename it to : (for the Pi 1, just copy the into the kernel tree). Step 3: Set up your system for kernel module compilation When you're compiling a kernel module, the build system looks in the directory for the kernel headers/sources. So make the link from that directory to our current directory: When you now do you should get the following: 

This will download more then 1GB of data and then process it, which will take a while. To prepare the sources for kernel module compilation there are some other steps to do. First you need to checkout the kernel code at the exact kernel-commit-id you found earlier. I always do my 'work' in a separate branch instead of in 'master' as that makes it easier to start over in case things go wrong and it is considered best practice. Then you clean everything up (), load the default configuration for the Pi 2 () and prepare the sources for module compilation (): 

If an adapter doesn't show up in that usually means that it needs firmware file(s) and your dmesg output proves that: 

If you want to know what's responsible for boot time with systemd, run or and then decide whether there are things you can live without and/or research the items which you think may be sped up. 

For some reason disabling power management at compile time and at runtime, through still does not result in the same behavior. In you can find the following code block: 

Add and to the respective stanzas. tells the system to react when a specific event occurs, like plugging in your adapter. tells the system to automatically bring up the interface on boot. Hence you need the part added to your 

And then to load it, do . As the USB ID is part of the driver code, when you plug the device in it should detect it automatically and load the driver. 

The last command may not exist and you will first have to . You probably won't see much or any output at this point. It is being written to those (small) files. You can look at them afterward with or or whatever you like but you don't have to at this point. Now stick in the adapter. On older models (A/B), this may cause the pi to reboot -- wifi adapters are often things that must be plugged in first and cannot be reattached once removed. This is due to a design flaw. In any case, now do the same thing with slightly different filenames. 

I guess that depends in what sense you mean "related". Related to your use of it, perhaps. More directly, it is from the linux kernel; the "Attempted to kill init!" error message can be found in the source tree (see ), as can the forward trace (i.e., from a subsequent call) "not syncing" (). Unravelling that would require further poking around. I think a common cause of this in a normal context is a problem with the root filesystem. I can say that I do not think "the problem" is simply that it cannot be found or read, unless perhaps you are using an initramfs (which n.b., is probably pointless on a platform specific kernel; this is why they are not normally used on the pi at all). These are crude guesses though. You are probably going to have to do some tedious debugging, more specifically, tracing the execution of the kernel to find out where it goes wrong. Hopefully you have two pis because being able to do this in contrast to your uClibc version might be helpful. 

I'm sure the CPU can keep up if there is no transcoding going on; in fact it will probably be mostly idle. I've benchmarked the output via USB to an HDD at ~30 MB/s -- that's MB/s, not Mbits/s -- out and slightly less (27 MB/s) in (but not simultaneously). This means the pi about fulfills the USB 2.0 maximum of 280 Mbits/s. Note that the SD card interface on the pi is ~35% slower than this. Online HD streaming rates are no where near that, and according to this (the older) HDV 1080i is 25 Mbits/s, while "other HD formats record at 50-100 Mbit/s or higher"; DVB-C appears to have a maximum of 64 Mbits/s and may be much less. So you should have no problems. If this is a straight copy, all the processor has to do is read this into memory and then write it out again. If you want to process the data somehow, then that's another story. 

This will send stderr (fd 2) to stdout (fd 1) and therefor ends up in your custom log file. Note that is cleared on reboot and you'd thus lose any files stored there, but in this case that may not be an issue. The last suggestion I have is to use FULL paths in your commands. While developing I'd add so that your is send to stdout and that makes it easy to spot errors or wrong assumptions in your code. , and are in and that was not in the of the 'cron'-user. Adding a at the beginning of the script fixed that. But I actually prefer to just use the full paths in my code and would thus have used , and . 

Your staging driver does not support MAC80211 and that's what wpa_supplicant defaults to. It probably works if you start wpasupplicant like this: 

There are a couple of things I'd do differently and it's a combination of a fuller version of Octopus' comment, a modified version of the answer by rob and my own thing. By default, CRON's output is send to the Mail Transport Agent or MTA and on Debian the default is and you can read the mail messages with for example. And with your entry it would send both stdout (your statements) and stderr (errors) to it. If you don't have and/or don't want an MTA, rob's variant works good too, but you'll miss any errors that would occur (see my next point for that). You can have both stdout and stderr if you change it to this: 

Optionally without the part. If it does you should find out how to make that permanent. The Arch wiki may be of help: $URL$ 

According to WikiDevi you need the rtl8192cu driver, which is now part of the mainline kernel. So just updating your system should fix it. If not the output of after you plug in your device will help solve the issue. Also provide the info of in that case.