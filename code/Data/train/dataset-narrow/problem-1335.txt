Notice how much cleaner this is than having the constant pairs of and ? It's because any processing which is repeated over and over can usually be encapsulated in its own method. This makes your code more readable and reusable. Let's skip down to the method to see what that means. 

Below is another version which is a bit more advanced because it uses an enum, Reflection, and Generics. I like this because it makes getting a valid car size from the user and retrieving a from it much cleaner and ties all the data together nicely. It also prevents me from having to make , , ... etc., etc. It may be a bit over-engineered for this particular example, but it was fun to make. Figuring it all out is left as an exercise to the reader. :) 

This loop is a bit hard to scan because it's all pressed together. Consider spacing it out: The rest of your code in the block is adequately addressed by the other answer. 

Stop declaring your variables and then setting their values. You can just set the values in the same line that you declare them. Always use the appropriate type parameter for generics (i.e., , not just or . Don't create variables where you don't need to (i.e., , , ). Wherever possible, separate out different functions into different methods. For example, in your refactored code below, I split the anagram generation into a separate method from the actual file IO. This not only improves code readability but also prevents your program from holding a lock on the file for the duration of the run. (Think about it; there's no need for the file to be locked up while we're actually checking the list for the anagrams.) People generally use the interface rather than the underlying object whenever possible. ( vs. ) Not really sure why, to be honest, but this is the accepted convention. The function probably doesn't even need to exist, but if you're going to leave it, it can be a one-liner. Use variable and method names that are actually meaningful. Don't convolute code where it's not necessary. For example, see the refactored method below. 

Now it is possible that I'm asserting incorrectly, but that is what the tests do. They show us what you expect to happen given certain circumstances. Hope this helps some. 

Next I am going to point out 2 things here. One is that even though you are in school, and you are somewhat new to programming I am a firm believer in using tests (and not user input) to test your program. I don't want to start a debate about how to write tests and when. That isn't the point. The point is that writing automated tests have many benefits. Granted at first it is a little harder and slower to write a program. But once you get the hang of it it is amazing. Some of the benefits are that your code can test itself, and it can test itself very fast. For this game I would imagine that it could be written using about 20 tests total. Those 20 tests would (and should) complete in less than a second. (probably in the 100ms range) You may be fast, but not that fast. What's also nice is that it gives you confidence to change your code willy nilly to try new things and know that you didn't break your code. So I am going to take 2 of your methods. Pull them out, and make them testable. (FYI, I had started a book about how I got from A to B with your code. But instead I decided to just show you what a few of my tests look like, and what your getInt method turned into)... First the tests 

This entire block is very difficult to scan. What it does isn't readily apparent by the way you've named all your variables. For example sounds like the rightmost node in the tree, but in fact it's the left node of the right node in the tree. Then with all the subsequent processing, it's very confusing without stepping through line-by-line to get a better understanding. Consider renaming your variables to be more meaningful. In my opinion, the most beautiful and elegant code is self-documenting. Also, if you were looking for ways to further improve the code's functionality (besides adding recursion), you might look into generic types so that your nodes can hold any data, rather than just an . 

This is of course pretty subjective, but this variable name is really, really verbose, even by Java standards. would be sufficient, or even just for these purposes. Just an opinion. 

What that means is that this is a prime candidate for encapsulation into its own method. Something like this: 

This works thanks to autoboxing, and it's a handy trick to remember as you move forward with Java. Even though this bit of code now works, it's still really bad practice since it's a completely unchecked (and therefore unsafe) downcast. In other words, you're just assuming that will return something that can be cast to an . We'll return to this later to add some sanity checking and error handling. 

The last thing I want to mention is that if you pull this out into a unit test (which is very difficult, but I got it working) you'll be able to time it. I loaded up mushroom.txt to what I assume you have, but the output is a bit..well confusing (here are the first 6 lines of data that I got back of the 8124) so the question is.. how does one determine if this is right? 

Now imagine that something is wrong with your fighting logic. Where do you start looking? Well obviously the method which narrows down where the problem is by a lot of lines of code. Things to keep in mind 

I'm going to assume that this isn't used in anyplace other than your unit tests. Part of the reason you wrote it is because your class isn't testable. I would rather see maybe another class created that represents a point on your graph that would contain its point in space and its color. Than you'd return the two points and test that the colors are the same. Some pseudo code. 

I'm reviewing some source code for a buddy of mine and came across this function. I am very new to Python so it is more of a learning experience for me. I see that he put in a comment about is there a better way to do this. I started thinking about it, and I know how I would do it in C#, but since python is so much more laxed it does seem like this function could be improved. 

I'm being forced to use the common anti-pattern of a which many classes in this project implement. Long story short, I need to have a constant which is pre-populated with values. Normally I would do this like so: 

One last note: I could have just had them all be statements as well, since each only returns and removes the method call from the stack anyway, but I find that it makes the code more readable to have s, since it means the conditionals are logically joined to the reader. EDIT: I actually had to expand the initial checks slightly. Technically speaking, given your rules, if the is passed in as , it should return , not the empty string. 

In general, you should try to have more descriptive method names. Following Java naming conventions, they should always be verbs or verb phrases. It just makes your code more readable and easier to follow. For example, this could be called or something. 

(Note that in your code, it's actually impossible for a draw to occur, since you check both of the winning conditions with and , meaning that the condition will be caught in one of those. This may be a bug in your program. :) ) I might even make a function to avoid some copy-and-pasting: 

This was just an experiment to see if I could replicate something like C++ function pointers in Java. Basically, the idea was to have an object which represented a method call, and when you call on that object, the method would run. It feels a little sloppy to me, and I feel like there may be some tricks of Reflection and Generics that would make the code more elegant/usable which I haven't thought of or am not aware of. Any tips or tricks? 

Normally I would also mention testing, and one place in particular that I would like to get under some sort of test framework is Baller because there is some logic in there that needs to get tested. specically there is a bug (as far as I can tell) that if my paddle is at a steep angle the collision detection is wrong. I'm not sure specifically where it is wrong, but the ball fell right through my paddle but did move slighly (almost like there was a hole in my paddle that the ball fell into). That is all I have for now. 

Assert This is the important part of it all. This is where you check that your code did what you are hoping. In this case I want to assert/show that those arguments were not valid. 

You get back a list of strings after loading some xml into memory and picking out values that you want. Well Lets pull out this very small bit of code into a class called since should not care how it gets its titles. So after a few tweaks the new class could look like this. 

so now my tests pass again. Oh but I have duplication again, but no longer in the start position, now it is in the end position. Since I know it is there I can remove the check in my while loop and make a slight adjustment in my duplicate change in index. My final outcome is something like this. 

I'll leave an in-depth analysis to the true Python experts, but here are just some quick notes: Variable and function names: As far as I'm aware, variable and function names should have words/elements separated by underscores (e.g., , ) main() function: Instead of having your functionality on the first/default level of indentation, it's good form to wrap it in a and call it via: 

You can shorten this long block of variable declarations as the following. Makes the code look a bit cleaner. 

Follow Java naming conventions. Class names should have , and variable and method names should be . Also, class names should be nouns, and method names should be verbs. For collections, the overarching interface is usually used. (i.e., ) Not really that important in my view, but it adds some style points according to some authorities. Most of the literals should be true constants. So for example, you would have at the top of your class, and then call . It doesn't matter for this small application, but for large-scale projects this will allow you to change the setting globally just by modifying this one value. Otherwise, you'll be doing a lot of digging through your code, and you're guaranteed to forget to change that one spot it mattered most. Every. Single. Time. Why are you bothering to convert the into a before returning it? You may as well just change the return type of the method to . In general, it's best to avoid primitive arrays and use these data structures. And they can also be used in the enhanced loop in your method. You should hardly ever swallow s and do nothing about them. Again, it's pretty trivial in this case and doesn't really matter, but if you're looking to develop good programming habits, start logging and doing safety checking and all that now. It'll make your life a lot easier down the road. 

it would be debatable in my opinion to make the concrete builders return the answer in English or to just return the numbers and let others format it. The way I see it it would be trivial to switch back and forth because on I would think you'd save the number internally on that class then in the you would either return the number or the formatted string. Other concerns 

Since you mentioned a programming class, I find that most students would greatly benefit from learning about Unit Tests. It isn't often taught, but I believe it should be. One main reason is that it forces you to be make code that is able to have automated tests. Automated tests are awesome because they are fast, and give you feedback if you made a mistake or not. There are a few prominent approaches to writing tests and the purpose is to not make you use a specific one. I can say that I prefer to write my tests first then write my production code. I do it this way because, for myself, I name methods a bit more with english in mind than programming. This takes a small amount of brain strain out of programming. (FYI the paradigm I mention about writing tests first is TDD, but like I said there are a few other ways of doing it they all have their advantages and disadvantages). So although it may seem trivial to write a test for a calculator one thing that it could possibly do is make choosing where you show your output even more trivial. (I've read in a few of the answers people mentioning where they would put the output.) You mentioned how you want your code to flow so I will focus writing a test that matches what you wanted. (Note the final code is almost complete, just need to finish implementing the operators.) IntegerCalculatorNGTest.java 

It performs your check to see if the selected value from the first combo box is greater than the current count. If so, it adjusts the second combo box's selected item, incorporating your error handling (checking if the new value is less than 0) using the ternary operator. Then we set the count to the second combo box's value, since we do so in all cases. (That was where you were copying and pasting that big block of code around.) 

You actually have no need for this since Reflection gives you direct access to methods and method signatures, as you'll see in my modified version of your code below. 

You should try to use consistent style throughout your code. Above, you switch between having spaces between your assignment operator () and not having spaces. What I tell my coders is that it doesn't really matter which one you use, as long as you're consistent. The vast majority of work that will be done on the code you write will be done by people who have never looked at it before in their lives trying to do maintenance, so consistency really helps. 

You should try to use consistent style in your code. If you're going to put these checks and return statements at the beginning, either put them on the same line as the statement or don't. It doesn't matter which you do, as long as you do the same thing throughout. Makes your code much more readable and easier to maintain. 

Many of the unit test frameworks work on the same premise that you are trying to achieve where you check if a certain condition exists, but they offer a little better form of "Assertions" that give you some more information except and . I also want to point out that you shouldn't write a method in your class that tests its state only unless it makes sense. 9 times out of 10 though it does not. So for instance this method 

So I suppose the answer to your question can go in a few different routes. Best practices would suggest that you write tests, encapsulate and use some different design patterns. However my thoughts when looking at your code is that this might be a little frustrating to you. But your question also points to something that I think a few people will miss. Making 10 small classes to solve the same problem (in terms of lines of code) will be the same as 1 large class. I'll offer this suggestion as a rebuttal and an answer. Learn how to encapsulate in clear logical manners. You'll end up with 10 (just a random number) small classes. The point being that the smaller the class the easier it is to understand what it does. To answer your question as a superficial answer would be to make methods to remove the duplicate code. Your method has TONS of duplicate code and would be greatly simplified like so