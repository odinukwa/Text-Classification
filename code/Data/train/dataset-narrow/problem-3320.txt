There are a few options. For simplicity, check into car rear-view monitors - they come as small as 3.5". Take a look at: $URL$ for wiring/ideas for putting it together. Also check out a 3.2" touch screen here: $URL$ 

I don't think you'll be able to do it to be honest. There is a solution using the composite port (see $URL$ for an example but that requires soldering as well. You might be better off looking at $URL$ - price is just above what you want but it's going to be a good screen. It's not available yet but will be within the next few weeks. 

Each Pi will require 1A (1000mA) of power to run. They will run at slightly less than 1A power, but you risk brown-outs (loss of power leading to a reboot). So, you need a hub that will deliver 1A for each USB port. Which means that you will need a power supply for the hub that will provide at least 7A (7000mA) to the hub. It's not clear from that product page how many amps the power supply provided will generate so I used this calculator ($URL$ to work it out. It says that each port will be provided with 2.8A, which sounds okay. I recommend asking the manufacturer of the hub how many amps each port will get before buying it. Anything 1A and above per port and yes, that hub would do. 

To read this sensor on the Pi, you can use one of two methods. First of all, you could have Arduino read the sensor and send the readings back to the Raspberry Pi, over a connection, either I2C, Serial or USB. For an example of the USB method, check out Simon Monk's blog at: $URL$ Be aware that if you use a pin-to-pin connection, you might need a level converter in there somewhere to make sure that the Arduino's 5V is not transmitted to the Pi's 3v3 pin logic. Alternatively, you could connect up an analog to digital converter and communicate with the chip over SPI. There are a number of blog posts out there, but the first one to look at is over at Raspberry Pi Spy - $URL$ This will give you a clear example of how to wire up the chip. If you don't want to wire up the chip yourself, I recommend the RasPiO Analog Zero board which has just gone on pre-order (and will be available very soon otherwise I wouldn't have mentioned it!) at $URL$ You might need a voltage divider to take the 5V output of the gas sensor down to 3V3. However, in my experience of using multiple gas sensors with the same analog-to-digital chip, you can just put the 5V of the gas sensor into the MCP3008 and the Pi will be fine. If you are going to use an analog-to-digital converter, take a look at Alex Eames' blog post here: $URL$ He takes you through using the GPIO Zero library ($URL$ to read an analog sensor through an MCP3008. 

Not really a specific question, more a call for help. But anyway, because it's fun to think how to do things... If you don't want to use GPS, then yes an accelerometer would be best. This would give you readings as to what type of movement A has done. You would then replicate the movements with B. The trouble with the accelerometer is that it has no idea of where A physically 'is' - just that it has moved in X direction for an amount of time. You could look at something simple like the XLoBorg from PiBorg ($URL$ if you didn't want to mess around too much - it's a GPIO plugin board that monitors motion and direction. You will potentially need accelerometer boards on both Pis so that B knows what ground it has covered (you could of course just take it's word for it). You would then need a way of A communicating with B. Either do this over wifi or you can probably use something like $URL$ to communicate wirelessly over serial. Either way you'll need to write the software to both send and receive. There is complexity here that I don't think you can get away from and possibly some tricky maths if you're not careful. The only other option is to get A to tell B what it has just done. So if A moves forward 5, turns left 90 degrees and moves forward 5 again, it could just tell B that information and B could replicate it. This would give a master-slave configuration which could be just the ticket if you needed simplicity. 

From the Raspberry Pi wiki: Back-Powering; (powering the Raspberry Pi from a USB hub through the uplink/data port, single cable) Back powering is possible on the Raspberry Pi. Revision 1.0 boards have to be modified to back power, this is due to the 140ma "polyfuses" that are installed in the USB port circuit. Revision 1.1 boards do not need modifications to back-power, they have replaced the polyfuses with 0ohm resistors in their place. Revision 2.0 boards do not need modification, they have neither resistors nor polyfuses. It is advised that short (12" (.3 meter) or less) USB cables be used for back-powering a Raspberry Pi. Cable resistance plus connector resistance can quickly reduce operating voltages below the proper range(5.25V to 4.75V). 

There is no simulator for emulating the GPIO pins of the Raspberry Pi. Perhaps you could describe what you wanted to do in another question and we could tell you if it's likely to work. 

You want to use a step-down power regulator that will take your 7.4V LIPO battery and take it down to 5V. You could, for example, get one of these: $URL$ which takes in the + and - from the battery, steps it down and then gives you USB ports to connect your Pi to. Be aware that the regulator may get a bit hot due to the dissipated energy and also be careful not to over-use your LIPO. 

The HAT plugs directly into the Pi via the GPIO pins. The motors then plug into the HAT's 'motor' pins (shown on the right above). You will need to solder the wires onto the motors. The HAT has two H-Bridge motor drivers which provide 200mA at 5V per channel, allowing you to control two of these motors. They won't be the fastest or most torque-y motors you'll ever find, but if you want basic movement without a separate power supply, this will do nicely. 

I think you need to provide a full path to python. Type the following to find out where Python is located: 

The most capable motor controller board that gets closest to what you require is called the 4tronix Picon Zero. 

Raspberry Pi has never maintained that the Pi is open source. There are many parts of it, especially the software, which are open source, but not everything is. There has been criticism of the Pi for having parts which are closed source, however given that the aim of the Pi is education of children, open sourcing everything is not seen as a priority. 

Probbably your best option is to get the Explorer HAT Pro from Pimoroni ($URL$ or The Pi Hut ($URL$ and some micro metal gear motors ($URL$ 

Take a look at the Raspberry Pi thin client project: $URL$ This might provide you with what you want. 

Try raspi.tv e.g $URL$ Alex has written software to utilize the Gertboard and is likely to be able to answer your questions. 

You could take a look at this cable from Adafruit: $URL$ It is a USB to TTL serial cable which allows you to connect serial communication to the Pi's GPIO pins. You would then need to find a way of communicating via serial from your C++ program . This is similar to the way in which an Arduino communicates to a laptop or PC so you may find some help from the Arduino community's methods. 

You should have a cable that plugs into the type B port. Plug it in and then connect the other end (the flat USB end) into your Pi. This ensures that whatever else you plug into the hub sends it's data to the Pi. Now, you should be left with 4 normal USB ports. Turn the Hub over. One of the USB ports has the Raspberry Pi logo next to it. Connect a cable from that port to the power socket of your Pi - so that's a USB type A plug on the hub to the micro USB power port for your Pi. That's got everything you need connected up. You're then left with three other type A USB ports to plug in peripherals, like keyboard, mouse etc. 

That's the main problem with the Enviro pHAT, and the SenseHAT for that matter - proximity to the Pi affecting results. You're better off getting a Dallas 1-wire temperature sensor, preferably one with a long cable (such as, and this is just an example, the one contained in CamJam EduKit 2), or extend one without a lead by using jumper cables. This will let you get the sensor away from the Pi. You can then use the 1-wire protocol to read the temperature. Instructions for how to do that can be found in this worksheet. 

If you 'just' want to run x86 apps on the Pi, try ExaGear Desktop. It's not perfect, but it might give you what you want. 

There are 26 usable GPIO (general purpose input-output) pins on a Raspberry Pi (2,3,A+,B+,Zero). They are usable as either inputs or outputs, depending on how you configure them. I believe the MQ series sensors work by air naturally moving into the sensor, being heated and then getting analysed by the sensor inside the casing. So, a very limited area in answer to your second question. They're normally good for what you want though. You will require an analog-to-digital converter to read the values from the MQ series of sensors as they are analog sensors. I recommend the MCP3008 as it gives you 8 analog inputs. You can use a simple Python programming library called GPIO Zero to read the values ($URL$ or do it the old fashioned way with RPi.GPIO and another library. It's shown in the pic below how to wire it all up. You don't need to use the prototyping board, you can use a breadboard if you like. It's just what came to mind first. The ProHAT, if you do want one to play with, is available here. 

I'm afraid it's one of those 'It all depends' answers. There are some battery packs that can do this... many of them can't. Alex Eames over at RasPi.tv has found one that does work even though it's not necessarily recommended: $URL$ There is a project coming out that gives your Pi UPS via a LiPo battery mounted onboard a board which itself is mounted on top of your Pi's GPIO pins. I can't find the link right now but I'm down as a beta tester. 

Hope that answers most of it! Any lingering problems, feel free to contact me on here or via my blog ($URL$ 

Have a look at RealVNC's VNC Connect. It's a cloud-based "remote desktop" solution that doesn't require port-forwarding. Raspberry Pi recently announced it was available on their blog 

In my experience, Yes, if the green LED flashes just once then stops, this indicates that the SD card is corrupt. Sometimes it doesn't even flash once, though. 

In terms of doing new things with it, obviously you've got more GPIO pins, so if you want more inputs or outputs then the B+ is for you. Plus it's much easier to plug USB things in to (less need for a powered hub). If you're doing robotics with a portable power supply, the B+ will last longer on it thanks to the lower power consumption. 

You can do this with the PWM pin on the Pi. Here's a link to a blog post dealing with this that uses the C WiringPi library to do it: $URL$ I would paste the code in here but the editor isn't co-operating. 

The Pi should not be powered from it's own USB ports. It's not a safe way of supplying power. The correct way is to use either the micro USB port or the correct GPIO pins. The hub you have is at fault here - it shouldn't be supplying power upstream along the data feed cable. You may have to take it apart and cut a wire. Powering the Pi from two places is not recommended. 

You should use 'exfat' instead of 'exfat-fuse' in the fstab entry. This should make it work with exfat-fuse. The assumption is that you've already installed exfat-fuse. 

You have, unfortunately, hit the nail on the head. The Raspberry Pi does not have analog pins, therefore it is unwise to expect it to be able to read analog values. You would need an analog-to-digital converter (for example the MCP3008) and then you would need to change the cylonjs source to read values from a different bus (SPI or I2C - there are a2d chips for both). Alternatively, take a look at using Python and the GPIO Zero library instead. 

You could run a script, perhaps in Python or C that checks the status of a GPIO pin and then connect up a push button to that GPIO pin. Then when the button is pressed, the script could trigger the shutdown. 

Providing you can get all the parts necessary and then hook them up to GPIO pins, I don't see any reason why not. Pinball targets are pretty much all digital so there should be no problem there. Spinners might be analog, but you can add an analog-to-digital converter for that. Look up a few things to do with building arcade machines using the Pi for buttons and other controls. Where you would get the parts to refurb a pinball machine however, I have no idea! 

This will run your Python programme 'headless'. i.e. it will run it as a process that you can't 're-attach' to. Once you've rebooted, open up a Terminal and type the following: 

The MMA7361 (assuming you've got the bare module) produces 3 analog outputs. Unfortunately, the Raspberry Pi has no analog inputs. However, you could use an analog-to-digital converter chip (e.g. the MCP3008) to read those analog outputs. See here for a tutorial on using the MCP3008 with the GPIO Zero Python library: $URL$ The alternative is to use an Arduino (see this tutorial: $URL$ and transmit to the Pi over serial. 

You probably want a seventh, central Pi controlling 6 other Pis, all connected to the same network. The master Pi will send a command to the 6 other Pis to take the photograph. The 6 other 'slave' Pis will each have a camera module. Remember you can't have more than one camera module per Pi. Take a look at this - might give you some ideas $URL$ 

The digital output you will get will either be 0 or 1 depending on the level you set with the trimming potentiometer (the blue and white thing). It can be used to detect, based on the trim pot, the difference between a value of 'hot' and a value of 'cold'. Above the level you set, I believe you'll get a 1. Below, you will get a 0. You will be unable to tell what the actual temperature is at any time except when the value turns from 0 to 1. If you want to read the actual temperature, you will need an Analog-to-Digital converter chip such as the MCP3008. You will then need to perform calculations based on the range the sensor can read according to the value you read. The easiest way IMHO to get an MCP3008 (or other A2D chip) working is to use GPIO Zero ($URL$ A good tutorial on reading temperature (though it's a different sensor) is over at RasPi.TV ($URL$ 

You need to be running version 2 of Sonic Pi for these new functions to work. Version 2 is available from: $URL$ Full instructions are on that page. I won't duplicate them here because the new version is still being developed and the release candidate number for the download is being updated regularly. 

One easy solution is to use a clothes' peg or bulldog clip. I have seen the use of a piece of old credit card to put a fix in place - you could see if that would be appropriate. $URL$ Or you could try replacing the entire slot: $URL$ and $URL$ I've not cut-and-pasted the solutions wholesale as that would make for an enormous post, most of which might not be an appropriate solution.