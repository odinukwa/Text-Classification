I assume you are aware of Chrome Canary, which I gather is able to use binary deltas? I don't think it's pure Chromium though. Your code is pretty clean. You could be using argparse for parsing the command line, currently you are ignoring flags that don't match. You could wrap the exit call around main, like this: , and use / statements instead. You could replace with , or pick up some defaults from the registry, but that's not necessary unless you plan for a larger audience. You could also reduce the window Chromium is unavailable by unzipping somewhere else, then moving the directories, then clearing the previous one (but I don't think you can make it atomic without something like symlinks or hardlinks). 

Make yourself a "template" that you immediately convert into html (using innerHtml or whatever your framework has handy), then use the dom to fix up the few variable bits. You may use ids to locate the tags that need substitution, if you can guarantee they are unique. Otherwise use XPath. 

1, 2 and 4 depend how well you've secured your system (no privilege elevation or random suid files lying around). 4 also depends on the security of flask and the rest of your python stack. Five can be broken, depending on how your firewall is configured (someone could use connection tracking to get your socket forwarded, even though it is bound to localhost). You'd be better off using unix domain sockets. The second is broken, because you chmod the file only after you've written to it. That gives a window for the attacker to open the file. In fact the attacker could even write to the file and execute arbitrary commands, which is why you should never use os.system, and you should use urlparse to build the url. The third is broken in two ways: 

General SQL-related advice: I would factor most of these queries into a single view; you can then add WHERE parameters when selecting from the view. You can also remove the few instances of variable expansion inside the queries, and replace them with named parameters throughout (you have already). For example: 

listen in on someone else's sockets. read another user's files otherwise learn the secret execute random python code in your server And the inability for a remote attacker to connect to your socket. 

I'll criticise the general design of the function. can't accept general input, because that would produce invalid xml. It special-cases empty contents, which prevents it from being generally useful; there is no way to use it to get an empty tag (breaking a weak requirement of good APIs: making simple things possible). It only makes sense as a private part of a slightly larger program that produces valid xml, which you did not include. 

Simple and pure Regarding the comments the following is an example of a simple JS solution to the problem. Turns out that it is also a pure function. 

But this is a bit obscure and not very intuitive. We still want to to use named function calls to get a corner, "topleft..." rather than a non descriptive array to define a corner. (see below) Variable repetition If we look further there is still repetition of the arguments passed to . We can define , , and in the function and pass it the argument and array of offsets. Looking at the functions named , ... etc, each contains which is a good clue in what to remove and create once. A good rule of thumb. If adding the same name to a bunch of variables, that similarity should be an object, eg becomes (the get is redundant in lieu of more info about Path's functionality) Though Javascript class syntax is not conducive to complicated Objects (*), so it is best to redefine the whole object as a factory function (see rewrite) So we can create something like 

It was not until I read it that I realized most of it is completely unneeded. With identical functionality is the following 

Some extra points. I was a little slow and Sam beat me to the answer, and he has covered many of the points I had. However I can not agree with , it is much better to use to convert a if you know it is already an int. Your naming is very bad. Prime example is much better as The whole thing encapsulated would improve portability, see rewrite. Use object literal declarations to define objects. You had something like... 

Performance review These code challenges have tight constraints (a very good thing in my view) so you you must be aware of the actual load on the CPU for every line you write. Also these code challenges run on V8, and sometimes that version is not up to date. It helps to have some knowledge of some of V8's oddities, past and present. Looking at your code. The first problem is the parsing of the input. Using is convenient but slow. Rather than parse the input before you process it, combine the processing with the parsing. This will save a significant amount of time. Don't slice arrays if you don't need to, there are better ways to access data in arrays if speed is important. Same with , there is no need for it in this example. Use to convert to number rather than as it is quicker. There really is only one use for and that is to convert numbers from bases other than 10. The commands (first value per line after first line) are not used as numbers, you don't need to convert them. are very quick compared to loops, iterators, and many of the array functions. Its well worth learning to get the most out of your code. You can use a RegExp to split the input. will split on each non digit and a zillion times faster than using and Function calls add overhead that is not related to the algorithm. Avoid needless function calls if you can. That does not mean flatten out your code that means dont create indirect function calls if there is no need. 

There are already and friends for . Avoid inconsistent state Instead of keeping track if your rng is , seed it in the constructor. Follow standard naming conventions I find some of your names to be too verbose and far away from common naming schemes (stl, boost). Especially . For instance . I would think is just fine. Avoid indirection if you don't need to Why do you manage the by inside ? This has negative performance impact. Use such an indirection only if you need to move the objects around often but cannot cheaply do so. The same argument applies to , but it requires more careful reasoning because the object is more complex. Is it required to often move around es in operations? (I don't think so) Is it expensive to move a object? (Depends on ValueType.) 

While your code doesn't leak right now, it will leak as soon as you replace as a value type with a more complex or generic object type. Then for example in lines like this: 

tim's answer covers the most important issues, but I would like to put a bit more emphasis. First of all you mastered the first step towards secure code. You obviously know that you need to sanitize user input, that is already very good. Input sanitation However, while your code may not have sanitation issues right now, it probably will not be once you extend/modify it. Arbitrarily throwing sanitation methods at input is not the solution. The solution is to use clean abstraction interfaces for output (e.g. template system) and database (e.g. prepared statements) and sanitize at the input to the abstraction. This way it is more feasible to actually get it right for non-trivial sites. Randomness / hash is not suitable for security-related randomness. This, and suggested alternatives, are also documented. Note: It seems the alternatives suggested by the php manual are not easily available... [insert php rant here]. The arbitrary restriction to ~30 bits (1,000,000,000) is certainly not helpful. There is also no reason to hash this value here, and most certainly not by chaining two weak hash functions. Remember that hash functions map arbitrary size data to fixed size. They do not generate entropy. You can use a hash function if you have non-alphanumeric random data. So lets say you generate a random token of sufficient entropy (30 bites are NOT!) and send that token to the user. Then you can store the hash of the token in the database. This way, when an attacker obtains a database dump somehow, he cannot reset passwords. This works the same way as with passwords, although its more important to apply it to passwords. You can use . Protect against phishing Emails with links are in general problematic, as both links (what is shown to the user vs. where the link goes to) and emails (sender address) can be easily manipulated. If you send an email to the user, especially when it contains a link to click on, it is customary to personally address him by name. This is at least some assurance, that it is not a phishing mail. It is of course not perfect as the name can often be devised from the email address. An alternative to sending a link, is to send only the token (in your case hash) by mail and redirect the user to a form where he can enter the token directly after he requests the email. Code structure As Tim mentioned, your code structure should be improved for clarity. This also has security impact. SQL efficiency If you do not intend to use the result of an SQL row, don't it, but instead. Use example.com The domain is reserved for this very use. Use it instead of a domain that is actually owned and used (domain.com). 

Object assign via operator There is a sorter way to do the property order if you use the spread operator to assign properties. 

That with the other check ensures you don't step on toes, and your code is safe as well. Though what to do if that function is already taken is an issue that is best solved by not adding to the prototype and just creating a function 

Some issues that would black list your module in some organisations. Untrusted state The whole thing is unsafe due to exposed properties. Exposed properties should be protected from improper use via code that either 

Underscores are used in languages like C/C++ to ensure that variables and functions in libraries did not clash, however it is only a convention not part of the language. Most commonly it would be double underscore This has also been used in other languages for the same reason, more commonly just as a single underscore. In Javascript it has been adopted as a sign that a variable is private, and is particularly common in code that uses the token which does not allow for private properties. It is bad because the language does not enforce the rule. is by trust not enforced in the language. You can use it if you like but you must still treat it as a public property if you wish to trust your object's state. And if you go through the effort of ensuring the safety of the property then why bother with the underscore in the first place. 

I was going to check if there was an item, but it seams pointless. Works the same as your function shifts the first entry, returning it, or undefined if not found. I would make a slight change to your version 

Update In lieu of the above answer and comment you made the following might suit your needs a little better. Rather than pass a callback to the series function, that function returns a promise which will resolve when all tasked have completed successfully, if there is a problem along the way the function will terminate returning the error. Also the results stack is passed to each task. Rather than the last results the entire results stack is passed. It is up to the task which results it needs to use. Also added are some options. Stop on error if true will stop on the first error, and timeout is greater then 0 will have a timeout error on tasks. 

You don't use it consistently. Sometimes you use instead Don't use an array there. Seriously. Why would you introduce so many ways to shoot yourself in the foot without need. 

exceptions can occur and you will leak memory. This is subtle and difficult to get right. Therefore always* use smart pointers to express ownership, in this case . *: unless absolutely necessary and you know what you are doing. Otherwise follow the advise of Edward which is much more immediate. 

Vertex "type" What actually represents a vertex in your graph? Do you really want to have separate ids for vertices? Or is a vertex uniquely identified by it's value? In any case you should use a to identify your vertices in method paramters, similar to how is used. Return by value or reference instead of by input reference For instance your always requires an unnecessary and potentially expensive copy operation (from the internal to the outside variable provided by the caller through the reference). Consider implementing and instead of and . This is also more consistent with common interfaces. For example in your current - what happens if there are already elements in the provided vector? It complicates things and is more difficult to use. It requires to user to define a variable first and then passing it into your methods rather than defining it directly from a return value. If you have multiple return values use a or . Take s by value instead of If you pass small types that are cheap to copy, it is preferred to take them by value. Note: if you do not know the type in generic code, a is just fine. Allow for in-place construction Currently a user has to first create a vertex and then assign it a value in a second method call. This is complicated and error prone. Instead allow for in-place construction (emplace) or at least copy construction of new vertices. 

First: you leak memory. Terribly. Never use unless you know what you are doing. Use smart pointers, or in this case just objects on the stack. The visitor pattern is meant for separating algorithms from an object structure. There is no object structure / composition / hierarchy in your code, so there is no use for the visitor pattern. Following your example, there should be a class with an method, that iteratively calls accept for all elements in the cart. Also the visitor pattern is supposed to prepare for unknown algorithms operating on data structures that should not know about the algorithms. So it does not make sense to use a return value here. If you want to accumulate a prize here, you would have to do it in the state of the visitor. Also: Use consistent spacing between etc. Use consistent capitalization of methods (). Avoid redundant newlines.