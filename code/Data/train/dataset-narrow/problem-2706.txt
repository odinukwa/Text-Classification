In addition, as another answers mention, using SendMessage doesn't remove the coupling. Instead it makes it not error out at compile time. Very bad - as you scale up your project it can become a nightmare to maintain. If you are further looking to decouple your code without using interface in the editor, you can use a strongly typed event-based system (or even a loosely-typed one actually, but again, harder to maintain). I have based mine on this post, which is super convenient as a starting point. Be mindful of creating a bunch of events as it could trigger the GC. I worked around the problem with an object pool instead, but that's mostly because I work with mobile. 

Have a look at IUnified ($URL$ which lets you expose interfaces in the editor, just like you mention. There is a little bit more wiring up to do compared to normal variable declaration, that's all. 

However, I still find it difficult to get a clear picture of what is going on from the stats. So what are the best practices for determining where I am losing players? 

Rotating a bitmap will always result in a blurred image - there is no way around that. (Except for rotations of 90/270/360 degrees.) Even high-end programs like photoshop cannot work around the issue - but they mitigate it. First, a bitmap stores its information pixel per pixel. So you have a large grid of pixels that composes the image. To see it in action, open you favorite bitmap painting tool and zoom in to the max. At that point, you can see the individual pixel that composes an image. Those pixels are always arranged in a grid of horizontal rows and vertical columns. Always vertical and horizontal. This is where the rotation problem arise... The image above shows what is going on. In the top left you have an example bitmap. Notice that its rows and column are horizontal and vertical. In the bottom right, you first have the same bitmap, with a slight rotation. But as I explained earlier, you cannot leave rows non-horizontal, so you have to transcribe the rotated image to an horizontal/vertical grid (shown in red in the image). By the way, each square represents a pixel. As you can see the pixels of the red grid do not align cleanly with the bitmap behind. (In fact the bitmap is now a little bit larger than it used to be - another effect of the rotation.) To figure how each of the grid pixel should be colored, you take an average of the pixels in the bitmap overlapping the pixel you want to draw. Which, of course, results is colors that are slightly different and therefore a blurred image. The technique you use to average the color are varied and some result it much much better images, but they also take longer to evaluate. I suspect that the Android .createBitmap image does do a good job at it. You have a few solutions: 

I assume you are using the physics engine to do the 'deviation' automatically based on shape/mass when things collide together? if that is the case, then change the mass of your zombies to a very minimal value and they won't affect the car. 

So that means you get one call to your touch handler per pointer action (down/move/up). So two fingers moving = 2 calls. A nasty side effect of your code is that it applies the action of one event to all the pointers... So, instead of looping over the traces, simply get the pid/x/y/action for the current event only (for simultaneous movement, you will get another call to your handler a tiny bit later, like I said) Here is my code to handle events: 

require a pointer id, not , because there's no garantee they'll be in the same order. In addition, there is another subtle but important problem. Notice how the getAction() family of function do not take a parameter. That's kind of weird, right? Getting X/Y requires the pointer id, but not the action performed? That is hinting at a couple of important things: 

So that's a brief overview but should give a good idea of what was going, you can see more for yourself in the code (tarball) but be advise there is a whole lot more concept going on in there (object containers, etc). 

It saves a draw call (compared to particles) and gives you total control on the spread of the effect, if you want to do it smooth or staggered. 

I'm an indie game mobile game developer and there is not a week that goes by without me trying to find a better toolset. You can have a look at: 

All of them use points, which I think is probably the right metric: anything a player does in pinball grant points, with the most difficult objectives worth more points. Points also take into account all of the rare combination of objectives (like score multiplier + multiball) that would be hard to track manually. However, I am not sure which approach to use and I bet other games have implemented similar skill-measuring system that I can use as a guide, so I'd appreciate any and all help on this. 

A lot of good answers about getting a mathematically correct answer, but I'll try a different angle: if your code allows for it, you could simulate a very large number of games and then check if there is a strategy (or strategies) that win too often. You might be familiar with Monte-Carlo simulations or genetic algorithms. The idea here related. You need an AI to play the game and some key measurement. You let the AI go at each other in a large tournament, often enough, with different starting variables and you measure the results. I've always wanted to try an approach like that to balances classes/weapons, it would be a ton of fun. 

Sometimes, in game development, you need to take shortcuts. The shortcut here is called an Impulse, which, physically speaking is a very large force applied in a very short time. Instead of integrating it over time, you just apply it to the parameter as a direct change: set velocity to 0. The question is: do you want to use the shortcut or not? 

This is with AdWords enabled for when there are no graphical ads to show. You'll also notice that there is quite a seasonal effect. eCPM varies quite a bit, so take the 32c as a baseline to figure out your $300/day. It would take ~1M impressions a day. Also note that it depends on the frequency and placement of your ads. Too many of them will annoy the user, etc. 

I am designing a level-based game where the user completes the level 1, then 2, 3 and so on. There are 200 levels and each is rather short: 60-ish seconds. I am tracking 

About your problem, if the STATE is only used in Animations, then you don't even need to expose that to other Components. If it has more than one use, then you need to expose it. The system of Components/Subsystem that you describe feels more hierarchy-based than component-based. After all, what you describe as components are in fact data structures. It doesn't mean it is a bad system, just that I don't think it fits the component-based approach too well. As you noted, dependencies are a big problem in component-based systems. There are different ways to deal with that. Some require each component to declare their dependencies and do a strict check. Others query for components implementing a specific interface. Still others pass reference to the dependant components when they instantiate each of them. Independently of the method you use, you will need a GameObject of some sort to act as collection of Components. What that GameObject provides can vary a lot and you can simplify your inter-component dependencies by pushing some often-used data to the GameObject level. Unity does that with the transform for example, force all game object to have one. Concerning the problem you ask of different states/animation for different game objects, here's what I would do. First, I wouldn't get too fancy at this stage of the implementation: only implement what you need now to get it working, then add bells and whistles as you need them. So, I'd start with a 'State' component: PlayerStateComponent, Enemy1State, Enemy2State. The state component would take care of changing the state at the appropriate time. State is something pretty much all your objects will have, so it can reside in the GameObject. Then, there would be an AnimationCompoment. This would have a dictionary of animations keyed to the state. In update(), change the animation if the state changes. There's a great article about building framework that I can't find. It said that when you don't have experience in the domain, you should pick one problem and do the simplest implementation that solves the current problem. Then you add another problem/use-case and expand on the framework as you go along, so it grows organically. I really like that approach, particularly when working with new concept as you are doing. The implementation I proposed is quite naive, but here are some possible improvements as you add more use-case: