The rate is in Kbps. If you want to be more proactive, you can consider configuring SNMP traps for spanning-tree and storm control events. Your switches can then send trap messages to a central SNMP trap server when a loop occurs.This SNMP trap server can then send you an alert (via mail, SMS, IRC, or whatever you have in place). On Cisco you can configure SNMP traps like this: 

TCP port 7 ('echo') and ICMP echo request messages are two very different things. Ping uses ICMP echo messages, which (since it's ICMP) do not use TCP. So this has nothing to do with TCP ports being open or closed, you can't "ping" TCP ports using the ping utility. My guess would be that nmap scans 1000 ports by default because those are most of the well known ports, and to reduce runtime. You can always specify all ports using . 

As Ron said, anyone can write a proposal. I have a hard time taking proposals seriously from someone who suggests interconnecting satellites with optical fiber, though. Also, I can't imagine this actual proposal gaining any momentum, especially due to this note: 

Link local addresses are used in one single network segment, they can't be routed. Unique local addresses can be routed, but only within one routing domain. So an ISP can choose to use ULA for services which can't be publicly accessible. 

Both are used very often: private interconnects are often used between a BGP transit customer and its upstream networks as well as between networks which need to exchange a lot of traffic, to offload this traffic from IXP links. BGP sessions via IXPs are often used to connect with a lot of networks without having to set up private interconnects with each network. 

is for when you don't know exactly how things are organized on your target system. Meaning, you know that system has the table, but you don't know exactly what the first entry is. 's job is to literally find, the next entry to whatever OID you point it at. I know for a fact that does not exist on my target system, lets verify that with an : 

In terms of subscriber management, I understand there are two major approaches - DHCP and PPPoE. I know I'm being very general, so give me some rope. If using DHCP, RADIUS/AAA will authenticate the user, and then allow DHCP to happen, assign the address, etc. If I'm using PPPoE, the PPPoE session establishes, and the address is assigned via IPCP. My question is, if I'm using PPPoE, can we use DHCP to assign the address? And if so, how is that address conveyed to the client? Will DHCP choose the address and be sent to the client via IPCP? 

Simply allows you to ensure that one is added statically (as you already know). Statically defined MACs are also preserved in the configuration, so after a reboot they would not need to be relearned. From Configuring Port Security 

So, basically, you're not defining the filter as "inet" in your dynamic-profile. OR It could be your filter itself that you're not defining as "inet". 

Source: TCP/IP Guide What layers encapsulate the data depends on what generates the data. In general, de-encapsulation will only happen for what is relevant to the data's current place in the network (on a router, on a host, etc.) By this I mean, if I'm a router, I don't care that there is an HTTP request buried in this packet if all I'm trying to do is route traffic via Layer 3 - I will only strip off enough headers to get what I need, do my job, and move on to the next packet. We all use the internet everyday in some way, so here's what a typical HTTP request will look like, taking the OSI model into account. For simplicity's sake, we can assume the network is available and there aren't any problems. 

It looks like you're mixing up console access and telnet access. The statement you're showing only works for telnet access. If you want to set a password for console access, you need to configure it like this: 

Some VPNs push the default gateway (a /0 netmask) as two /1 networks: 0/1 and 128/1. Since a more specific route always wins, this forces traffic to be routed via the VPN instead of over the default gateway. 

Make sure the switchports of the DHCP server and the clients are in the same VLAN, or use a DHCP helper. The DHCP protocol by default relies on the server and clients being in the same broadcast domain. If they're not, DHCP requests won't reach the server unless you define a DHCP helper address. 

For Juniper devices you can use the command, it shows an overview of all interface counters which is automatically updated: 

The SSG-20 only runs ScreenOS, not JunOS. Juniper switches run JunOS, so this won't help you test your scripts and test configs. Personally, I'd look for a cheap 2nd hand low end model Juniper, but it all depends a bit on your budget. 

Unless you're talking about the AS-numbers defined in RFC6696 meant for private use (64512 - 65534), all AS-numbers are assigned by RIRs to their LIRs. 

If you're planning to do a lot with BGP communities which are used for signalling between your own ASN and your upstream or downstream peers, a 32-bit ASN might be less useful since the second 16 bits for the 32-bit ASN are used for communities in 16-bit ASNs. There's an IETF draft which will provide these communities for 32-bit ASNs. If you're not planning on doing anything with communities outside your own ASN, there's no real drawback in using a 32-bit ASN. Any router nowadays supports it, and if it doesn't, it at least supports the AS23456 transition mechanism. 

Setting idle-timeout for root directly from the CLI is not possible, unfortunately. I wrote an event script that does what you need. Basically, every 5 minutes it checks: 

First, ALGs are technically independent entities. If we are looking at JUST the ALG, it cares only about the SIP signaling packets, not which ports are used. You define the ports by application and bind the ALG to that application. Below is an example: 

You're correct about switches learning device location (port) via the source MAC address. That alone means they're necessary everywhere. In your example with two computers/servers connected they're still required because those computers/servers could have multiple interfaces. MAC addresses are per interface, each interface would have to be able to discern what traffic is destined for it. The network stack of your OS doesn't care what it's connected to, it's going to interoperate the same with anything. 

Once your file(s) are copied, you must enable them. This prevents anyone who can copy files to the device from executing potentially destructive scripts. 

You'd have to verify with WHOIS, some of the networks other than 192.168.0.0/16 within the 192.0.0.0/8 range are also private. You could check anything you like in the future from just about an Linux distribution command line via the WHOIS tool: 

0x8100 This TPID is used in 802.1Q - its your average, everyday VLAN tagging. A common use for VLANs is for enterprises to organize their network into functional groups (like research, finance, or management). 0x88a8 This TPID is used in 802.11ad - its used for provider bridging (also known as QinQ, stacked VLANs, or double tagging). QinQ is used when a customer has to transport VLAN tagged traffic across a service provider network. The service provider will have its own set of VLAN tags, perhaps a tag per customer. So we have customer VLAN tags, and service provider VLAN tags, appropriately called C-TAGs and S-TAGs. S-TAGs are correlated with the 0x88a8 TPID to signify the existence of the inner C-TAG which uses TPID 0x8100 (S-TAGs are inserted before C-TAGs). 

There's a fair chance this answer won't be applicable in your situation, but I feel I have to say it anyway: You can implement IPv6 and obtain more than enough addresses so every service can run on its own address on the ports you want them to run on. Of course, this requires every visitor to have a working IPv6 connection so it will probably not be a real option at this point in time, but it certainly is one of the best ways to solve NAT problem. 

This are just spanning tree packets from your switch. Disable spanning tree on your switch on the interface towards your server if you don't need it and don't want to see these packets. 

NAT and DHCP are two totally different things. DHCP assigns IP addresses, DNS servers and gateways, NAT translates adresses between two networks, typically between a private network using RFC1918 (local) addresses and a public network, so multiple local devices can share one public IP address. To answer your second question: there can be many reasons why those two computers have different IPs, they all depend on your network. One very obvious reason would be that there's no NAT involved and those two computers use different routable IP's, another explanation could be the use of a proxy farm which uses different IP's for its outbound connections. Without any more details on the local IPs, the IPs shown in these tests and the actual network configuration it's mostly guessing though. 

R1-R4 are MX480's and CORE-R1-R4 are MX960's. Below are graphs comparing RSVP subscription and utilization of the LSP. Red is subscription, green is utilization. You can see that the utilization follows the reservation almost exactly throughout the day. We should see subscriptions be very close to each other between the LSPs toward the same destination. 

If the BDR field in the Hello packet header is set to 0.0.0.0, it means you do not have a BDR elected. In your case this is because you have your other router set to a priority of 0, this makes the router ineligible to become a BDR (this is why you see "DROther" and not "BDR"). You just need to set the priority on your other router to something that isn't 0. Here is the other piece from the RFC for some more context. 

You're correct, not the person you were speaking to. TCP establishes a connection between a "client" and "server", anything in between is just the the paths. It doesn't care how the traffic gets there, just that it does get there (using the built in sequence numbers, acknowledgments, and congestion avoidance capabilities). In your diamond example, you load share over both of the middle routers, you could just have one primary and one backup path, etc. It doesn't matter, as long as IP reachability is present, TCP can handle the loss. 

As you can see, I retrieved all entries in that table of OIDs. will also recurse through a table A, if table A contains tables B, C, and D. Such as the entire in your example, it will recurse those as well. 

Your reasoning is the wrong way. TCP/IP handles the layers top down, not bottom up. PC A will first do a lookup in the routing table and decide that the only way to reach PC B is via the router specified in that routing table. If the MAC address of the router is unknown it will send an ARP request to figure out which MAC address corresponds to the gateway IP. Then the frame (containing the IP packet) will be sent to the MAC address of the router which will do a lookup in its routing table to see on which interface PC B is connected or via which next hop it should be routed. Assuming PC B is connected to another interface of the router the router will do a lookup (and if needed an ARP request) to figure out the MAC address of PC B and then forward the frame. 

As Ron Maupin already mentioned, anything in those three ranges defined in RFC1918 will be fine, those are assigned for local networks. Personally, I wouldn't pick one of the more obvious ranges like or if you ever plan to offer services like VPN for remote workers. Most of the home routers use those by default for their local networks, so it can be wise to stay clear of ranges to prevent an overlap. I'd pick a range from the network (which seems to be less used in home routers), and not the first , so for example . 

Since you remove the ability to load-balance (for RSVP), the PFE will reprogram to only a single path until an auto-bandwidth adjust occurs automatically, or you can force an adjustment: 

As you can see, you don't have to specify or . But looking at that configuration you wouldn't be able to tell whether it was EBGP or iBGP, without looking at neighbor information or already having knowledge of the network. For a more practical reason to set a at the group level, would be enforcement of that type of peering in that group. If you have a group built for peers in an IX exchange, those peers probably inherit the same policies and other attributes. If someone comes along and puts an iBGP peer in that group without having the type set, that peer might come up. There are a ton of reasons that this could be bad, but would vary per deployment, setting the type at the group level helps mitigate any of the potential issues. It's a lot cleaner to do something like this: 

[Layer 1] Now your gateway router receives the 1's and 0's. The NIC (interface) on the router gets that data and basically says "I have no idea how to read this!" and brings it up to layer 2 so it can read the data. [Layer 2] The gateway router now inspects the L2 frame, it says "okay cool you came from this MAC, neat. I see your destination MAC was set to my MAC address, so I am allowed to keep doing the work. It will de-encapsulate the L2 header so it can get a look at the IP header (layer 3). [Layer 3] Your gateway router is going to look at the source and destination IP address now. It says "Okay, you came from this source, cool. Your destination is this IP address. Hmm I don't own this IP address, but I know who does." It will lookup a route for the destination IP address (google.com) in its routing table and use that entry. After all of this, the same general process repeats. It will check what interface it needs to send the packet, use that interfaces MAC address, turn it to bits and send it. The next router will do the same thing, and so on. In general these packets will only be stripped back down to the layer 7 when it reach its final destination. As I mentioned before, the routers only care about getting the packets to their destination, so it is only going to care about Layer 3, so it won't have a reason to look at anything else besides what it needs to in order to get to that information. So it will see L1/L2/L3 information, but nothing else. Eventually the data will hopefully get to the destination web-server and at that point the data will have its outer layers stripped all the way down to the HTTP header for the web server to read, and do whatever is necessary to process that request. 

General rule of thumb: never use documentational space. It has a very specific purpose, don't ever use it for anything else or you'll regret it at a later time. If these two servers only need to talk to eachother and don't require any other connectivity for the given IPv6 addresses I'd use ULA space: pick a somewhat random /64 from within and use that between the servers. 

Assuming the firewall is a Layer 3 firewall (and not in layer 2 mode like some firewalls are) this won't generate a loop. If it will work, that's a totally different question, that depends on your actual configuration. 

As I said, there's no such thing. You can get an ASN and IPv6 space, but a large part of the internet still only has IPv4 connectivity, so having your services only available on IPv6 will probably not work as well as you'd like it to. You could possibly consider to have a service like CloudFlare or Akamai (or another CDN) to do the IPv4 hosting and connect to your services via IPv6, but I'm not aware if they do support this, and this probably only works for HTTP(S) services. 

There's no guarantee that packets are received in order when using UDP, so yes, you can receive them out of order. Retransmission isn't available in UDP unlike you mentioned, this could be done on application level though. Also, it may very well be possible that routers on the path between two endpoints loadbalance packets over various links, so you can't assume that they use the same path. If you really care about packet ordering, UDP isn't the appropriate protocol.