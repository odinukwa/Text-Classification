You don't need the second in your select or grouping. Other than that, the query itself looks fine. I'm a bit more worried about how your table is built, though. 

You can shorten / simplify your StudentStatus implementations. Both and have a fixed return value for . You can leave out the field and add the value directly in the method. copies what the constructor already copied. You can simply return . Domestic students have no documents, so can return the empty list. 

The trick is to give special treatment to your first or your last item. If you know that you have at least one element, you can unroll it and then loop over the rest; the examples below make that clearer: 

Here there be nitpicking! Your error handling is very coarse: does away with stack traces and exception types, both very useful for debugging. Either bubble up the exception, or log the full stack. and have a similar purpose but a different method signature. can leave the balance negative. Consider expanding your query to: 

Unsupported operations should throw . Catch rather than . Implementations can throw exceptions for reasons that may be out of your hands (like concurrent modification). Idempotent operations may not throw. Implementations may choose not to throw UnsupportedOperationException if they can determine that the invocation is a no-op, such as with , or on an empty list. 

...you have no guarantee that those two variables were drawn from the same set of mappings. Another thread may have switched mappings in between. What you do to fix this, is fetch and store the array locally for as long as you can both: (1) not tolerate interference, and (2) can tolerate stale data. 

You have 'too much' data to keep in resident memory. There are a number of things you can do to smoothe this out, but they will take a bit more effort than rearranging code. Read input line per line Right now, the algorithm looks a little like this: For each record in the database, search the input file for a match and write that match to output. Since the database is the indexed one, and the input file (probably) isn't, we'll save time going at it the other way: For each line in the input file, find the matching record(s) and write them to output. This will let us read the input file line per line, just once, using java.io.BufferedReader, which will save you from having to slice your files into bits. We will have to hit the database (or a in-memory version that you keep) more often, but they're built for this, and may cache some things: 

Looks completely acceptable to me. If there is no reason to hold on to the lambdas in some other way, e.g. to flush or remove them, and they're not too big or complicated to distract from the current context, then I see this as much the preferred way to do it. Short answer but, yeah, good question. 

(pass!) There can be many readers. (pass!) There can only be just one writer. (simultaneously, I assume) (fail!) Fairness among writers. In other words, writers should be served in FIFO manner. 

It takes the lazy-loading out of the lazy-loader, but then you could ask yourself what the remaining uses of the class are. 

Use lists (expandable) instead of arrays (fixed-length). A number of arrays have sizes that appear arbitrary, such as (later redefined to length 100). Unless these lengths represent agreed-upon limits, in which case it would be best to name them through constants (e.g. MAX_CLAUSES), consider using an ArrayList instead. ArrayList has comparable performance to arrays, will grow as needed, and will relieve you of having to store or guess the number of elements. Add documentation or help code self-document. There are useful comments in the code, but not enough to get a view on what happens where, when, and why. They probably would be enough if the functions and variables could be renamed to signal use or purpose ( ? ? ). Reduce the number of static, reachable, mutable references. The abundance of statics greatly widens the conceptual scope of named references, making it harder for human beings to read and reason about the code. Reduce this scope by making them instance references—this will also reduce the number of arrays you need—and by restricting access through where possible. This will be tedious, make no mistake. It will require you to rethink and remodel some parts. But it will greatly improve the ability for people (including yourself!) to reason about the impact of a change to the code. Consider a instead of and . Maps tend to be very fast in lookups, so it will save you processing time. It will also free you from keeping the two lists in sync. Add to specific classes where needed. All calls to appear to follow the pattern of . Consider adding an instance method to class Symbole, so that you can change into . Aim for 1 statement per line, and prefer using braces for code blocks. This is not an unbreakable rule: there are cases where 'packing' statements or blocks is defensible for visual or conceptual reasons. But I'd err on the side of caution. Prefer generics over raw collections. Generics help keep your collections type-safe (reducing bugs) and reduce the number of casts you need. Prefer logging over System.out.print. Java comes with a logging utility (java.util.logging); you can also use one like log4j or slf4j-logback. If this feels like overkill, consider moving to methods like to reduce clutter. Consider instead of chains comparing to constants. is an example where would probably both be faster and clearer. Scrutinize . You'll probably need only two or three of its methods, so you might get away with adding the methods explicitly, and then delegating to a private field. If these classes do need to be list-like, consider adding the interface instead, and then delegate, or add a method that provides a view of what you need. 

... however, if it is incorrect, you will only find out when you try to use the value later and (hopefully) encounter a NullPointerException. Let the exception bubble up. Try separating the constructor into a method that parses a string and returns a map, and the constructor that creates the object: 

Ask your platform for an index. For WindowBuilder, this is Eclipse, which has information on loaded and available classes. For stand-alone Java applications like GUIs, this will involve scanning your class path. Also available for your needs is . If you or your users can be bothered to make an index file in provided JARs, ServiceLoader will do some lifting for you. Ask your user for a JAR and scan it. Open it up, check each class whether it extends , and add/flag it if it does. This covers archives that aren't on the class path. Ask your user for a class name and let the ClassLoader fetch it. This covers classes that are not in a JAR or on the class path. 

As a bonus, this would mean you can use your program as a 'text utility' reading from standard input and writing to standard output, where compression could make you save drastically save on disk churning: 

And a nitpick from an 'elegance' point of view: consider adding a method to MyWord that creates a new, incremented instance. Right now, outside code is accessing the fields and creating new instances with it. This is something MyWord can handle internally. 

This isn't my preferred approach, because all this does is evade the radar, basically. If you're in a pinch, though, this will do the trick. Mind: is not a type of . (On another note: you probably need to mark as volatile!) 2. Move the loading to an initialization method: 

... at which point your original functions can be hollowed out and the algorithm kept mostly in the same form elsewhere: 

Alternatively, if the is a bit of an eye-sore, you could hoist the check into the for-header, but I'm not 100% it's an improvement: 

The harm lies in that you have no way of enforcing that these subclass instances are themselves immutable. Depending on what properties of immutability you rely on, this can throw off otherwise working code.