Adding a node is a common task with its own specific method of doing this. Use this common method to do the actual work of adding a node. This prevents duplicating of code and makes sure that adding a node is consistently done (Note your current is not very efficient but I will address that separately. 

The trouble is that at the end of scope. Both objects get destroyed. 'y' will get destroyed first calling its destructor and calling delete on the node. Then 'x' will be destroyed and it will also call delete on its one node (but this node has already been deleted so this is illegal). Now the compiler generated methods are usually exactly what you want. But when your class contains an "owned" pointer then you need to do some extra work as the default implementation simply does a shallow copy. Rule of 5 (Optional) In C++11 they introduced move semantics to the language. So it has become pretty standard to implement move semantics for container class (as it makes a lot of things very effecient). Use Initializer List 

Don't worry. With RVO/NRVO and move semantics. This will become just as efficient as the original. But now is much more readable. Which is nice as we can now spot mistakes easier. Seems like we are special casing in two sub expressions but not the third. Which is odd looking. Why not modify the meaning of p (it always point to the start of the next section (or end). 

What I think about your code: This is sloppy coding. You should not use it. It is best to fully qualify stuff from the std namespace. Its not that hard or long. 

I would use here. So that it is easy to spot and you intuitively know that this is a dangerous operation. 

I can see that there is no else. You are just asking for trouble when the code goes out of sync with the comments. Comments are for describing why you are doing something. There is no point in describing the code with comments the code should be readable by-itself the code describes what it is doing. You go to all the effort of making the counter inside counter_base atomic. But this is a complete false sense of security as the variable inside is not atomic or protected in any way. Also there is no checking of the counter when accessing the element so you can just as easily hand off an invalid pointer. 

Does not seem to validate the arguments. Also it prints out help. I would have two different functions for this. Especially since you may want to print out the help under other situations. Looks like the first arguments to this function is not modified. So why is it passed by reference. Best to pass parameters by const reference to avoid the copy and prevent accidental modification. Prefer not to use out parameters return the result. 

Notice that if m_bRunning is false at start-up then you may not unlock . Also the second time around the loop you are call un-lock without calling lock. This case can be fixed by moving the first lock inside the first while loop. In general though this is a good case for the usage of RAII where things need to be done symmetrically even when exceptions are in play (In parallel to the advice about the constructor, it may be worth wrapping the pthread_X objects in some C++ classes). Though I comment you for commenting. I prefer comments at a minimum and try not to write comments that tell you what the code is doing. We should be able to see that from reading the code. Comments should be there to explain the overall technique of what we are doing (ie what not how). 

Your lock is not exception safe: Use RAII to guarantee that locks are correctly locked/unlocked in the presence of exceptions: 

Now that I can see the code. I see a lot of common elements (and I am not sure I believe it is correct). Looks like the tmp element is being set as the second last element in the list and rear points to this element. 

There are several problems with this one small bit of code. There are no ownership semantics defined for . You pass as a pointer to so I am not 100% convinced that you need to delete them (I will now need to check how that method works to make sure you are doing it correctly). But assuming you are this means internally you are making a copy of so why do you need to create them dynamically like this and delete them if you are going to make a copy. Those three lines just make my ears bleed. I would have done. 

There is no need for a virtual destructor. That is already taken care of in the base class . Since you are not doing memory management (your example shows string literals) these methods are empty anyway. So you can remove this: 

Experimenting with vera++ to validate some C++ source files. $URL$ vera++ is expandable by providing your own rules in tcl. To interface with the vera++ parser the following interface is provided: $URL$ Using the above I have written a rule to look for "using namespace XXX;" in source files. This is to compliment Rule T018 which bans "using namespace XXX;" in header files. 

You do have to worry about recursion limits in template functions. Different compilers provide different limits. The minimum they must support is 6 (the last time I looked). But your compiler can blow up. You way want to pre-compute the value and save it to a file that you read in. 

While we are talking about iterators and generalizing the code.The wrapper can be generalized to any container type (because nothing in the function is dependent on it being a ) by simply adding a template. 

No need for the type T here. In fact putting it here is probably a bad idea. As it allows you to search a vector of double with an integer. Now there is not much you can do with compiler standard conversions but at least you can make sure that the value passed to the function has already been converted to the correct type for comparison. 

As explained above yes. To stop allocating space for the object and the counter in two different allocations the standard came up with a function called This basically creates the counter and object in the same space (one allocation rather than two). So if you want some practice try doing that. Move Semantics Move semantics. C++11 (and C++14) have move semantics. You should definitely start practicing using them. Comments not covered by @glampert I think your comparison operators are questionable. 

You allocate the buffer and force every member to default initialized. Then you turn around and immediately copy over those default initialized values. What you should be doing is constructing and using the members of the list to construct in place once. Same problem here. 

Memory Management Normally there are two ways to do memory management. Smart pointers and containers. These are complimentary methods and you don't usually mix them together. So I would expect a vector to do its own memory management and not delegate this work to a smart pointer (though you can). 

Dry up your code Don't repeat yourself (DRY) Some of the code is overly verbose. I think you can tighten some of this down. 

There are lots of other advantages that happen when you start dynamically sizing your strings which happens in any reasonable code base. When you use C you have the start the whole processes of memory management and making sure the string does not leak memory. In C++ this is all handled for you inside the std::string class. Serialization Vs Binary protocol Binary protocols (such as you use) are by nature very brittle. You should consider this. Serialization is definitely more expensive and can take more code but it is more flexible and thus robust and is thus usually preferred over a binary format. Additionally your binary format is fine for very simple objects. But once your object starts to use any members that use resources outside the object this will start to break down. You make several assumptions here without even realizing it. 

This can only lead to disaster. It is unlikely it is more efficient than std::string and is much more likely to lead to memory leaks. Use std::string it will work is correct and has been optimized very heavily you can not beat it using your own hand written one. This is a premature optimization. Same Again: 

Doing rand that way is bad. The exact value of RAND_MAX can very but is usually 32767 (or multiples thereof). This means gives you: 

Create a count of the number of each letter from both strings. To be anagrams these counts must be the same. So look across the counts and sum the differences. 

OK. Looking at this as a code maintainer and not understanding what the underlying logic of the chip does (which is what will happen in real life). The function names look a bit generic. You may want to prefix them with the name of the chip (C unlink C++ does not provide function overloading). So that you can provide similar functions to a set of chips. From reading the docs this looks good (though I must admit I am not 100% sure). But a general maintainer is going to look and wonder why half the code paths do nothing. 

I personally would not expect sort to return a value. Next Step: Try again splitting into the two separate classes. A lot of the other problems I see will just go away. Post your code again for another review.