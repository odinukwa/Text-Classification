Before I answer this question here's a quick idea of how I would go about implementing an infinite or endless runner. I have worked on a couple of endless runners and they have both worked in the same way. This isn't necessarily the only way to do it but it is a way that has been proven to work. You can create generic sections of a level that contain geometry (such as the ground, maybe some buildings and so on). These sections will also contain a spline (path) fragment. In Unity these would probably be saved out as prefabs and placed in Asset Bundles or under the Resources directory. At runtime you would then create a number of these sections and stitch them together. (Some pieces might not fit with each other so you will need some way of recording which pieces can fit with whichother pieces - this would be some sort of offline process in the editor). Once your character has cleared a section that section will be destroyed and a new one will be created at the end of the currently loaded sections. Now to answer your question about colliding objects: 

It doesn't HAVE to be this way, but I've seen the pattern in many games from console RPGs to PC strategy games, and even handheld tower defense games. In a game like Oblivion, the difficulty is that the player has to make choices in the strategy building in the early- and mid-game by choosing how to level up that can have drastic consequences late-game because there's no option to change that strategy later. It's how you've built your character. The same is true in Diablo 2, and many other games that allow you to select skills for your character without the ability to change them later on. A skill-based character advancement thus takes a bit more fore-thought into how individual skills can be used to build a cohesive strategy. In Diablo 2 you can see how the developers struggled with it by looking at how often they tweaked the skills over the lifetime of the game. It's easy for an inexperienced player to reach a point where their permanent strategy choices are no longer effective against the opponents they're facing. That doesn't necessarily make the game unbalanced - it simply turns the skill progression choices into part of the player's strategy, and may require several playthroughs to develop an optimal strategy. 

As Jinbom said the main difference here is speed. However it is important to note that this is only the case for the transform property of GameObject. Other properties such as camera and rigidbody are just convenience properties and call GetComponent<> under the hood so the performance is identical. It is for this reason that Unity has deprected these 'helper' properties in Unity as it is not immediately obvious that Unity is going to search for the component rather than returning a cached version. With the exception of the transform property mentioned in the question, all other components should be cached at the first available opportunity using GetComponent<> and that cached value should be used thereafter. 

To implement your own custom inspector make sure you override OnInspectorGUI() and place the relevant code there. As you ahve said you will need to follow this approach for each component that already has a default Custom Inspector set up. 

A formula like this is good if you want a very simple method of estimating damage, or a quick jumping off point for modifying damage based on other factors like skills and elemental weaknesses. To show how broad this kind of formula can truly go, consider the damage formula for Inflation RPG, an Android and IOS game (See $URL$ The formula is heavily both stat and equipment dependent. Each piece of equipment has two stats - a bonus to the ATK stat, and a multiplier value. Some pieces of equipment have low multipliers, but high bonuses, others have low bonuses but high multipliers. For a character with only 10 ATK, the Battle Axe with it's 5000 ATK Bonus but low 145% multiplier is a great choice. The total damage is , but the Estoc, with 0 bonus and a multiplier of 300% is a poor choice - the damage is . Later in the game, a character with 5000 attack would prefer switching weapons. Stat- and Level-Based: A good example of this is Final Fantasy V, VI, and Final Fantasy XII (See $URL$ for example). The formula for swords in FFXII is: 

It would be perfectly feasible to do this yes, provided the number of objects is not stupidly high. If you have followed the previous setup then objects the player can interact with can be placed randomly in each of the sections that gets generated on the fly. Usually these sections would have some predefined areas marked up for where to spawn these objects so they do not get spawned in silly places. As there are only going to be a few sections loaded at any one time and only I would imagine 10s of object at the most in each section this should perform just fine and in fact this approach has been used on a couple of games I have worked on for mobile devices. 

You certainly could do this. You could store a data structure containing a position and a radius for the circle/sphere collision or some other appropriate data if you wanted to use another kind of collider. My guess though would be that its not really going to perform any quicker than the Unity collision system. So long as you don't have a silly number of objects and you know that it's not causing you any bottlenecks I'd stick with that. 

One thing you might think about here is looking at more strategy-oriented games like Civ, Starcraft and roguelikes such as Nethack and Crawl. In these games, game difficulty and player progression are not simple single-variable functions. The gameplay evolves over the course of the game. In the early-game the goal of the player is to simply survive, progress, increase in level, get the next equipment with a +1 bonus, etc. Generally everything the player finds is better than what they currently have - whether that's a new fishing spot in Civ, or a new sword in Nethack. The mid-game often features the player exploring the environment for gameplay options. Now, maybe they're setting up strategic forts, or collecting equipment with special effects that have situational uses, but still simply trying to survive to accumulate more stuff. The late-game forces the player into a showdown, usually with the toughest opponents, but also with the most options at their disposal. More experienced at playing the game, now not only must the player survive, but also exploit the effective weaknesses of their opponents with the tools they've discovered and refined from mid-game forward. You can see the same progression in Final Fantasy games - in the early game, most enemies can be killed with a simple attack, and maybe a couple healing spells as needed. Mid-game enemies begin to appear that are more difficult, but with obvious elemental or status weaknesses to exploit. Late in the game, the enemies might be practically unbeatable except for clear well-thought-out strategies based on less obvious weaknesses or AI script. 

Using the CustomEditor attribute should certainly work for the Transform component. I have my own custom editor for transforms to make resetting them a bit easier. By creating the following CustomEditor you will notice that the localRotation changes from displaying three values that represent the Euler angles (x, y, z) of the rotation quaternion to the 4 values (x, y, z, w) of the underlying rotation quaternion. This is because Unity is now using the CustomEditor which is empty and just shows the raw transform data structures. 

Well this number is going to change wildly depending on which platform you are talking about and how much other stuff you have going on in your game. In an empty scene on a low end device you could probably chuck in a few hundred colliders and keep a nice framerate. On iOS iPhone4 is the lowest device most developers target these days and that device is pretty poor. At the studio I work we haven't targeted the iPhone 3GS at all in any project over the last 2 years or so so I cna't comment on that particular device but needless to say its capabilities will be less than the iPhone4. I would suggest that your bigger problem would be rendering the geometry for all of these items the player can interact with. But under a 'normal' level I guess you could probably have a good 30 odd colliders. This is a bit of a guesstimate based on working with the platforms before so don't read too much into these numbers. It will depend very much on how much stuff your game is rendering to screen and how complex your game logic is. On Android you're going to have to deal with devices that perform even worse than that though and Windows Phone also has some really low end devices so its hard to give an exact number with so many unknown variables.