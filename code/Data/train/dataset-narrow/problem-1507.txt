Python provides extensive operator overloading capabilities. Use them. For example, could be called , which allows you to then check a condition like . You can then drop the line of the docstring about what the return value is - it is implied by using that operator. Even if you decide to leave it as a normal method, isn't the best name - it sounds like it should return some kind of index, rather than True or False. The reason for the argument to is that a Trie behaves like a Python dict - the strings that you store efficiently are keys, and each one has an associated value. So, you could call instead , and you can do things like . If that is useful to you, you should also implement appropriately. If it isn't, drop that argument. is also a strange name. It sounds like it should return some kind of metadata, but instead it prints some stuff to STDOUT. Printing from support classes like this is usually worth avoiding anyway - build the full string and return it instead, and rename it to , and then to print it you just have to . The docstring for it seems to be lying when it says "equivalent representations are randomly chosen from" - you have no randomness here, the closest thing is that you use dicts (whose order is arbitrary but consistent, not random); it says it isn't testable, but you do test it in your doctests for another method. 

I am following good programming practice (I'm not new at Java but its been a while and I usually code in python so I am likely to miss idiomatic ways of doing things) My class design/structure is appropriate and (more importantly) easily extensible if I want to add more features somewhere down the line I'm handling the actual logic (tokenizing, parsing, building syntax trees, etc.) the correct way. My interpreter works right now for what it is supposed to do, but I want to make sure I am doing things the right way so that in the future it is easy for me to expand it. 

I have the following python code which implements a simple neural network (two inputs, one hidden layer with 2 neurons, and one output) with a sigmoid activation function to learn a XOR gate. The code runs fine (ie no syntax errors or runtime errors or anything) and I have it plotting error over time to visualize its progress. I have tested it piece by piece; I know the feedforward works correctly as I tried hardcoding in weights and feeding it through and it gave the expected results, and while I didn't have the patience to backpropagate errors for the entire network by hand, I worked out the errors on the output and one of the hidden layer nodes and got similar numbers to the code. However, when I try to train it on the 4 test cases I have cyclically, the network consistently converges to . I've tried changing various parameters (, , , etc.) but to no avail. I even tried replacing the function with for the activation but that didn't change the results either. I've used in some places to make the matrix/vector math cleaner. I would greatly appreciate any suggestions on how I can improve my code, as well as what could be causing my problem. 

And then adjust your conditional to either have a (and a short comment pointing to the assertion) in that branch, or omit that branch entirely. This makes it abundantly explicit to anyone reading your code that that is an 'impossible' situation, and means the invariants of this class have been broken (and that it isn't that client code has passed in bad data - for that, use a normal exception rather than an assertion). A more minor quibble is that you don't need to pass into the helper function as an arguments. You can use closures: 

Starting with the low-hanging fruit: A variable called 'temp' is a big sign that you can do better. If you were to set up your code so that it returned a new list rather than modifying it in place, you could do this: 

Note that I have modified your conditions a little, since yours seemed slightly off. The branch of your condition effectively says "if the zeroth column is "name" or the first column isn't a match, it must be a header" - I've changed it so that instead, an appropriate value in the zeroth column is a header, and a non-matching first column on is ignored. I've maintained a temporary 'headers' list, because your code is currently robust against those appearing anywhere in the file. A better way to maintain that robustness would be if you know - or, preferably, can parse from your file before now - how many variables you have data for. Then you could do away with that list and do this: 

shouldn't work because - well, imagine this: runs and now temp is set to the last node. Then, the check is ran . Because the last node is not null, it will run , and because you're already on the last node this means that temp becomes null. The check then runs again, and as temp is null it moves out of the loop and attempts , which doesn't work (and probably triggers an error) as temp is null. You're gonna want it to check the next node before it sets temp to that value, as it does currently. As for code review, the logic seems sound, and presentation is up to you, however if this were my code there would be a few things I'd do personally, however I'll put an example instead of points: 

I'm learning Java too! Looking at this the only thing I might suggest is that you only do the calculations that you need to. You could then remove all answer variables and print the result of the calculations directly, saving time and memory, albeit not much. In terms of presentation, I personally would use lowerCamelCase for variable naming, e.g. firstNum, and I would also indent all of the cases as they are within the switch block. Finally, for I'd make sure there was no space there. Despite what I say for the presentation, that part of it is totally up to you, so do what you prefer, as long as it looks clear! 

Note that the first condition changed from testing a length to testing a position, and that the helper function works completely in-place. This makes one copy, in the outer function. You can also change it back to an in-place sort like your original code by deleting two lines, and it will make zero copies. This is probably the best a recursive insertion sort can be. 

Going down, is a .. very strange name for a list. It seems to contain solutions, although you put two numbers in it each success, which seems odd; but I'll assume that that makes sense, and say call it . You don't need the number at all - the way you use it, it will always just be . The two statements could be combined, as in: 

Second, you could inherit from the stdlib one and add the missing functionality. If you want to add directly to timedelta this way as well, you would also have to override and to turn any object they are about to return into your extended . I was going to suggest monkey patching as another option (this being one limited context where it does seem worth it), but it turns out you can't ( and use ). I only recommend adding the strict compatibility things this way. The idea is to set it up so that if you stop supporting 2.6 down the track, you can delete this code without having to adjust anything else, except maybe some imports. in particular ought to stay separate, especially because it fairly specifically enforces/assumes your local policy ("serialised dates will be in one of these two formats"). 

: Represents an expression that evaluates to a single value. This is an abstract class, and is subclassed by and which differ only in the operators implemented in the overridden method. 

The codebase itself consists of 22 classes which is a ridiculous number to copy/paste into here, so I figured I'd just share the relevant/important ones and then provide a quick description of the others. If code from the other classes is relevant, I can edit this to include them. Without further ado, here is the tokenizer class (): 

Then instead of at each iteration, just add to that set; this ensures that it is unique. Or if you want to print it right away, do something like this instead of the 

I am working on a project that involves me writing an interpreter for a small toy language in Java, and while I intend to build it into a fully featured programming language at some point, it is currently in its very early stages (I have only implemented parsing complex mathematical expressions and boolean expressions involving , , , and , as well as a very rudimentary way of storing values in variables). My code seems to be increasing in complexity very rapidly, and before I continue on to implementing statements, loops, and functions, I want to make sure that 

This will end up falling off the end of the function, and so returning . The rest of your script will continue, but eventually fail horribly. This probably isn't what you want. 

You have a variable to capture the links on each iteration of the loop, and to accumulate them across all the pages you parse (which is only one at the moment anyway, but I'm assuming that could change later). Those names are quite confusing; it would be good to differentiate better - call them for the one that gathers all the links, and for the one that gets the links for just this page. Your function parses what I would call your 'main' data structure. Since that is a lot more than just email-related information, isn't the best name for it. The data structure that creates seems awkward for your data. If you think of people as 'records', and the information you capture about them to be 'fields', then it would make more sense to have it as a list of namedtuples, or or even a pandas dataframe if you're working with a lot of data. That way, your code to parse it is a little bit simpler: 

The Sieve of Eratosthenes works by going through and marking all numbers that can be divided into, essentially. Take your input "n", for which you want to find all the prime numbers up to it. The sieve starts at 2, and multiplies 2 by increasing amounts until the multiplication is about to exceed the value "n" - in your program, this is accomplished through the integer division and then iteration up to the calculated result. So, as it multiplies the values together, it marks the result as non-prime. Meaning that 2, 4, 6, 8, 10... etc are all set in the bitarray as 0 (meaning non-prime in this context). It moves on to the next value, so it starts at 3. The process repeats as it marks all multiples as non-prime. Time to move on to the next number - 4. As 4 has been marked as non-prime, it skips over 4 and moves on to 5. This continues until it finally reaches the number which is the value of its square root, so when you are using the sieve to get primes below 100, that means the algorithm checks the multiples of values from 2 to sqrt(100), so 2 to 10. It doesn't need to go past this value as all prime values above that share multiples which values that have already been checked. So, for example, if we moved past 10 to check multiples of 11, we'll get 22 (which is divisible by 2, so has already been marked non-prime) and 33 (divisible by 3). The values which remain with a value of 1 are prime. tl;dr The algorithm goes through all prime values below or equal to sqrt(n) and marks their multiples up to n as non-prime. The remaining numbers must be prime. EDIT: The code above adds 1 to the div operation, which I didn't mention in my explanation. EDIT 2: This specific modification of the sieve is essentially the same as the original sieve, however rather than removing square values during the normal removal process it removes them separately at the end. 

subclasses and implements the specific syntax of [math_expr] GT|LT|EQ [math_expr] which is not covered by : 

UPDATE: I took the time and backpropagated the errors by hand for a couple of random initial configurations, and my results matched what the network calculates. Also, I ran it once on each test case and saw that the error for that test case improved marginally after the update, so I know my backprop and weight update steps are correct. Unfortunately, it still converges on bad values. Any ideas? 

is a tiny class I wrote to "box" variable types so that I don't have to know what kind of an it is, just that it has to be evaluated. I'm not sure that this is the best way to do it, but I couldn't think of anything else that maintains that level of abstraction. I'm also slightly uncomfortable with how complicated the class got, but it doesn't really fit into the because that deals with operators whose arguments are also s, whereas takes arguments. Finally, the method in my class currently just tries to evaluate a boolean expression and if it doesn't work it tries to get a math expression; the boolean expression class tries to parse a single boolean and if it doesn't work, it tries to find a comparison. I don't like this "guess and check" approach but I don't know how else to do it, because I can't just look ahead in the token stream as I wouldn't know how many tokens to look ahead. Any and all advice you can give me would be greatly appreciated.