Using to access rows (and concatenating the index) is unnecessary - you can use and just provide your index directly: 

6 - Consider using a regular expression to remove duplicate line feeds in . This can also avoid the possible bug if the data contains a . Since you immediately split the result, I'd use a function like this... 

If that's your , change it. and are both VBA keywords. If it isn't your , fully qualify the members both to make it easier for the reader to see what you mean and to avoid any potential that they would inadvertently conflict with the keywords: 

Much better to just calculate the result, especially if this is being looped over in the calling code. You tend to see code like the sample you posted when people are afraid to work with dates. The calculation involved isn't that hard. You first figure out the payee's birthday for the given age and find the following [insert financial vehicle here] anniversary based on the effective date. This lets you calculate the number of months until the next anniversary. Taking the modulus of the number of months until the anniversary and the number of months between payments gives you the month that the next payment is due. The only reason to work with anything other than the month is to cover cases where the birthday falls on a modal cycle: 

Wouldn't it be much simpler to simply have the base URL as a value in a .config file? Especially considering what's happening in . 

and contains four lines which are almost identical, except for the message. Instead of copy-pasting you should have moved them to a method: 

and aren't good names, not in the least because they contain the word "String". Wouldn't and be better? 

I note that you keep the Excel file open and then parse one or more text files. Have you tried closing and opening the Excel file for each text file you parse? Also, have you considered other ways to open and edit Excel files besides Microsoft.Office.Interop, like OpenXml? 

And why are all the properties in your classes suffixed with ? This adds so much noise to your code -- e.g. -- whereas is perfectly understandable. 

I don't think is a good class name, for one it is a plural. It can also be simplified by using Auto-Implemented Properties, e.g. 

At least this time you're logging the exception (unlike above), but again you're returning an empty list. So unless someone checks the error log, no one is any the wiser that an exception has occurred. 

Is this really actual, working code? Also, you're not showing us ; I wouldn't be surprised if it doesn't need to be an "overloaded function with 6 type overloads". I also would expect a method called "Create" to return something, but that's open for debate. You could look into System.Convert and use that to convert the object to a value, but again: this depends on . I'd advise you to submit a new question and include those methods, and provide us with more background. 

The code above sidesteps the next huge performance hit in your loop, but you should be caching values for procedure calls that will always return the same result. In the quoted statement at the start of the answer, you call 3 times and 3 times. They'll always return the same thing, so put them in a local variable to avoid the repeated calls (note that in this case, Raystafarian's solution is doing the same thing, but on a much more "global" scale - it reduces all the calls to just one). 

That is just all kinds of wrong (and it would look even more wrong if you explicitly declared the return type as the that it is). First, your backing field type doesn't match the publicly declared type. Second, you're using a as if it was a . And third, there is no reason for the backing field to be a . The only place where it is used is in the property, so that means you're continually coercing it back and forth, but never use it as a . It also leads to code like this... 

Conclusion - Burn it. Burn it with fire. The premise behind the code is that there is a common set of operations that you can do to "speed up" code. In fact, this is never true. In reality, you are turning off Excel functionality that can slow down code. There's a big difference. If you approach performance issues by looking outside of code that you've written, you're starting out looking in the wrong direction. A catch-all "solution" for performance simply doesn't exist, so I wouldn't pretend to be be providing it. The best way to look at it is to imagine that any code under performance review to be copied and pasted in place of this... 

In one and the same LINQ method you first convert SharePoint s to an anonymous type, and then convert those to s. This is something that really should be happening in a separate class. Moreover, it should not be a two-step operation: convert those s to s directly. 

I just noticed your edit, and I'm wondering whether the NULL checks are even necessary, since I don't see any NULLs in your sample output. I also agree with the comments that this code indicates issues elsewhere, and that simply focusing on this method is not enough. 

Why do you have a namespace that is called "database", and even worse, why does it contain controllers? You need to separate your Data Access Layer, your Business Logic Layer and your UI Layer. If this is a WPF project, implement MVVM. 

What are these, fields of properties? If they're fields they should be private; if they're properties they should have a getter/setter. 

There's always going to be a switch, but this way at least you're not repeating too much logic. You might even want to put those four parameters in a class and pass that class instead. 

But the above are merely minor flaws. That they're omni-present is however a warning sign (as well as the obviously copy-pasted parts), and I'm afraid that I don't see any value in this code. I fear you're relying on very outdated documentation; instead look into ORMs like Entity Framework and how those are used. 

The second thing that I'd mention is a usability issue (and a pet-peeve of a lot of validations I run across). If there is more than 1 thing that is being validated, and the user has to pass all of the checks, let them know everything that was wrong the first time. It's possible to have no capital, no number, and be too short -- don't make the user attempt a password 3 times to figure that out (and don't assume they'll read the instructions first). 

Now that we have code to review - the first issue that I see is that you are not comparing identical source code, and that makes it impossible to get an accurate benchmark. The problem is likely this line in the VB source that isn't in the C# source: 

While you probably could come up with an algorithm in VBA that does this fairly efficiently, I would doubt you'll match a relational database engine in performance on this. The take-away here is that if you're looking for the best way to skin a cat, make sure the cat needs to be skinned first. 

- Repeated calls to are expensive, because Excel can't make the assumption that the lookup table will be the same between each call. What that means is that it can't cache anything easily. If (based on your comment) you aren't making changes to the worksheet that the lookups are being performed on or making changes that result in formulas recalculating on the lookup range, it is almost always faster to create your own lookup cache. In this case, after a cursory scan it looks like you're always using the same key column for the lookup. So... just create a set up lookup tables with objects with the set to the row number (note that this assumes you have unique keys): 

What if the order changes? Also, this makes it hard to figure out which parameter is connected to which field. 

I also feel is too generic a name, since it is only used here: . Why not call it ? I don't think should be part of your clause, IMHO this is input validation that should happen before you compile the clause. 

I realize naming is often hard, but please avoid the temptation to name things "temp", e.g. . Also, why is the method named when I assume it only downloads a single video? And why would return a tuple? Is this the same tuple it receives as a parameter? (Note that I did not look at your full code at the link you provided.) 

I'm only thirty lines into your code, and already this review is starting to get long. Next I see another badly named variable (), and another one (). I notice strings like which are repeatedly used, so they should be . There's a block of code that starts with , yet at the top you've already made sure that can only be "1". I see the same similar lines repeated over and over again, which suggests they should be written as a single method with a couple of appropriate parameters: 

So if the intention is to enforce type safety, the better meta solutions would be to not use Variant types if they can be avoided or to use an IDE plug-in to make sure your assignments are type safe. If the intention is to simply replicate the functionality of the .NET List object, this is an entirely different matter (and one that is both useful and well executed, BTW). Nit-picking aside, let's get down to the "better /more efficient" side of things. Given that the object in VB6 isn't much more than a glorified array (4 methods - seriously?), I would just skip it entirely and just wrap an array directly. The vast majority of the class just uses the for storage space, and the fact that the intention is to ensure strong typing makes the memory management a lot easier. Note that I am not recommending an array of Variants, and am at risk of getting into StackOverflow territory. VB6 is based on Window COM, and uses a SAFEARRAY structure to store all of its arrays internally. This (vastly simplified) defines the size of each array element, tracks the number of elements in each dimension, stores a couple COM flags, and holds a pointer to the array data. Since VB6 is COM based, it also has a couple of undocumented functions like for pointer resolution and manipulation and can directly access the Windows API. This gives you the ability to do inserts and deletes into the middle of arrays with memory copy operations instead of iterating over the array or the a . You can get the underlying data structure like this: 

Why are you getting the stored password from the user name and then comparing that to the password the user entered in code that is in your UI? This kind of check should be happening in a back-end and return a boolean. Moreover, this kind of check is just mindbogglingly bad: you're storing an unencrypted password, one that is an int? That's wrong on so many levels... 

I do have to say I'm not 100% sure about how you create because I lack some knowledge about the data you're processing, so please don't just use my code blindly but compare it to your results. 

My main issue is that this code follow the "arrow anti-pattern", which makes it hard to read. Once you start nesting s, your code quickly becomes hard to follow, especially when there are blocks involved. I know how to solve this in C#; however I'm no Java expert so I can't advice you on how to solve this. In C# I'd possibly convert this method into a class and each would perhaps become a method, but I don't know if that's the right way in Java. 

Move code to methods. By the time you hit you're nearly ten levels deep. Not only are you losing valuable screen estate, it also doesn't help the clarity of your code. You could also use to reduce indentation: