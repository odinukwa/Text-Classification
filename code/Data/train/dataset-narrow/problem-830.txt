In your second loop, you use four lines to swap two list elements. This can be more idiomatically done in one line using tuple assignment: 

Sqlite objects can be access by column name - rename your variable to , and you can do, eg, `repost['permalink'], instead of having to create variables to keep track of what each one is. A more Pythonic way to manage your counter down the bottom is like this: 

These things together will make your code easier to follow, more maintainable, and often both faster and shorter. So, start by looking at your core data structure: 

Consider moving this function up to module level and passing the colours into it (or, if you really feel like it, use a class for the squares and make this a method on it; but that probably isn't overly worthwhile). 

avoid bare , it can mask bugs, and even cause some - eg, you might catch and ignore . instead. Consider adding a docstring to explicitly say that it tries two formats, as well as that it gives you a timezone-aware datetime. 

Then you can move your inside the loop, in place of the . At that point, continuing the search to find all pairs is trivial: change the to a , and your function will become a generator that will keep yielding every pair that works until it has exhausted the search space. This outer loop: 

will give you the same answer as your loop. You can almost read it as a sentence: "to get count, add up which numbers in have this interesting property". 

Starting with the low-hanging fruit: A variable called 'temp' is a big sign that you can do better. If you were to set up your code so that it returned a new list rather than modifying it in place, you could do this: 

The first thing that pops in my mind is the naming you used. For example, from a method called I'd expect to receive a and not a string. The same from . In the method the variable should be renamed IMO as the name is not so meaningful. The same regarding . Also, commented code is only confusing. I'd remove it. In addition: 

method In the current case, for s I mean, the method seems good. In case you consider changing it for the general case, I'd suggest the following logic: 

As @Heslacher mentioned in his answer, naming should be changed into something better. I'd suggest to change: 

We get the sets of 2 non-contiguous substrings. For each set of 2 strings do the following: 2.1. Get the last string. 2.2. Repeat operation in point 1. 2.3. Add the other strings in the original set to the calculated sets in 2.2. Repeat point 2 for the sets of 3 strings ( in general) until no more strings remain. 

In addition to what's been already written, I'd say that it shouldn't be necessary to implement the method. That is a test method and it should be in a test module. Regarding the implementation, I'd make the following operations: 

Let's take an example. If we have that and we'd need the numbers from to . We just parse to , multiply it by 10 for 3 times (length of is 2 and is 5) and return the numbers from 15000 to 15999 ( is set to 16000 which is the first value that is not allowed). In addition, if you just need an the previous method would be something like the following: 

I'd go with the built-in control. Here you can find the documentation and some examples. Also, I'd suggest to use the and for the other operations. Usually, if you have to manually insert some HTML code in the page some bug is pretty sure to show up. 

Generally, when you have a lot of duplicated code you should try to take out the parts that are different and put them in an array, then loop the values and perform the operation based on the values. Here's a quick re-factor I threw together of your code with that in mind. It could probably be improved upon using JS6 stuff like instead of the closure but at least this should illustrate the point. 

Your current code gives you a bunch of booleans, duplicates a lot of code and does unnecessary computations.. You should aim to get the time of day itself rather than a bunch of booleans. 

You don't need a loop, you can use the string's method, but in order to get only the matched group you have to use a lookbehind, which javascript's implementation of regex doesn't support, but, it does support a lookahead, so basically, you could reverse it, reverse all the matches and filter out empty strings to get the reservation codes. Since you only have a single match for the names you don't need a loop for that either, assuming there will always be a match, so you can just use exec and pop the result off the end.. 

TL,DR The biggest problem I see with your question is your use of the word "better," as if that's an objective term that means the same thing in every context. Faster !== better. Assuming you're the one maintaining the code, the best one is always whichever one works and whichever one you like the most. Synopsis First, let me mention jsperf - a site that was built for javascript performance testing. If you insist on testing server-side code on the client side, you should really use this instead of building your own, for many reasons, the main one being: because it's easier. But to get the most accurate results, you really should test in the environment it will be run in (on the server side). It is good to know how to write your own benchmarks, but if you do, you should make sure your benchmark code has the smallest footprint possible so as not to affect the results. Among other things, every time you concat a string with the computer has to load the entire string into memory. It is better to put your string parts in an array and then join the array at the end. As Blindman67 noted in the comments, benchmarking Javascript is tricky and generally unreliable. There are simply too many variables (different JS engines, other things running on the computer, etc). 

For what I see, it should suffice - in order to increase time performance of the cycle - to transform the , , and into dictionaries with the respective as keys. In this way the following lines: 

Get the type of info the input string represents. Already taken care of. Keep track of the different punctuation characters in the different input types. For example: and for dates, for acronyms, and so on. Write a method that splits and merges again a string on a certain . Something on the lines of . Once you split the original string by the splitting char you just trim its components (remove the starting and ending spaces). Call the method in the various cases. In the acronym's case (picked this one because it has only one splitting character) the call will be something like the following: . In the case of dates you have to call it twice, once per punctuation character. In the case of phrases you have to call it more times (you have multiple splitting punctuation characters: , , , , and so on). Final step. Remove possible double spaces (just replace with and you should be good to go). 

The end result - after applying the changes in the first solution and the changes for these 3 points - should be something like the following: 

There's one thing that is particularly disturbing me: the last block. That's an example of Busy waiting and that's something that should be avoided IMO. A possible solution to this problem could be to store the objects to a and once you have created all the threads you run a for each thread on such list. That being said, I'd suggest to take a look at PLINQ and TPL. One last thing: I'd remove the in the block also. I'd say that the instruction should be used only in a method. See here and here for ways to handle exception when working in an async way. 

This is a really cool snippet! I like that you were able to avoid using . After a quick glance I only have a few minor suggestions. Separate the logic from the interface. You separated them to some degree in that you have the event handlers attached manually after constructing the calculator (even though the event handler is defined in the calculator constructor). I would instead make 2 constructors, a constructor that can take an expression and evaluate it, and a constructor that sets up the interface and the event handlers. That way you will be able to use that sweet calculator code in other projects, or extend it for use with a more advanced calculator. Clear the results of the previous equation before moving the current one to the top row. I believe that is fixed by fixing the typo in your function where you do instead of is not necessary. You're using variable instead of just using in several places. In fact I don't see any places where is needed at all, just stick with and leave alone. Consider taking advantage of . Using to assign methods makes us feel like we're writing classes so it feels natural, but JS doesn't have classes*, so embrace the prototype. *ES6 actually does have classes. 

Validate your fields individually so you can provide the client side with better error messages (assuming this is an AJAX script)... 

The paramter is supposed to be the plaintext version of the regular body, yours has html in it. You need to do wrap it in striptags and nl2br like so... Avoid returning plain text from an AJAX script too. Set your properties in an array and return it in JSON so Javascript can read it easier. for example: 

For the testing part (for which I'd appreciate some feedback also) I used the following: LogicOperationTests.cs 

This approach calculates each result in \$O(n)\$ time and has a space complexity of \$O(1)\$ and, IMO, is the way to go if the function is calculated not so often. Cached-result processing In case the function is calculated often I'd suggest another approach. If you use an appropriate data structure (an arraylist should be ideal) you can implement the function in the following way: 

Another thing from the design point of view: The class doesn't seem to need instance methods. You don't actually need to create or objects (at least, so it seems). In that case the class should be declared static and the constructor goes away and the actual instance methods and properties have to be transformed to ones (the current methods just create a object that calls the instance methods anyway). Regarding the object, what's it doing there? Is it actually needed for the algorithm? If it's there for debugging purposes use it in directives. The same for the bit. Performance Regarding the performance bottleneck on and I'd suggest two changes (besides changing the name into something more meaningful): 

and then proceed as you are already doing (randomize the list and write it in a file, or whatever the case may be). Let me know if something is unclear. 

is repeated code (the two cycles are almost the same) and could be transformed in a method. Other things seem ok. 

We have a prefix indicated by a string (that has a numeric format alright, but it is a string) We have a max length, let's call it , of the numbers you can consider. The allowed length of the prefix, let's call it , should be We need all the numbers that start with the given prefix and have the given 

Caveats is somewhat picky about syntax. If your markup is not valid this will not work well as is. This means your example code will not work unless you correct the syntax first. While it would be trivial to write a function to make the required corrections in your example code, that is beyond the scope of the question. 

You, my friend, are an architecture astronaut. Holy moley, dude, 110 lines of code on top of 4 libraries to do something that would take a couple dozen lines of code to do in "vanilla" JS sounds to me like you're abstracting way too much. I have the exact same problem and it's led to hundreds of hours of wasted coding so I know it's hard to hear, but my honest opinion is that you should come back down to Earth, take a vacation for a few days and look at this again and ask yourself, do you really need all this? Your buttons only respond to the event listener once, it's not immediately apparent whether that was by design or if it's a bug. Does the component make sense? Not immediately, not to me, though I've only worked with mustache a few times. Is it easy to follow? No, sorry. You required a 4200 character explanation without even mentioning core observable library (which is what you should really be asking for a review on) - that's a pretty good indicator of how easy it is to follow. Can you foresee any shortcomings or disadvantages with the design approach dictated by the framework? No, just a little over-engineered IMO. 

I don't think so. This would only serve to make the computer iterate over each value twice. I don't see how that would make it simpler.