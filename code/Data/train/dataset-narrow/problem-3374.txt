Create the bridge device. Assign an IP address to the bridge device. Configure to listen on the bridge interface IP address. 

As others have mentioned, df -h will give you overview. Also useful: (show total disk space used in current tree) (show total space used in specified tree) (show space used in subdirectories) You can also install the package which will give you a more granular breakdown of disk usage. 

I use both old Android phones and Raspberry Pis. Each has strengths that the other cannot easily reproduce. An Android phone is fine if you're comfortable with developing Android apps and being limited to the features you have access to. On a rooted phone, you should have access to most features. The phones have an impressive array of sensors (light, compass, GPS, more), a built-in battery/UPS, outstanding cameras and wifi. If you want these features in a handy, self-contained package, a smartphone is hard to beat. I can buy a Droid Bionic for roughly $65 used, and use them as remote network cameras, polled by my Linux server running motion. The RPi lets me run mainstream Linux programs such as Node and Flask for server development. They provide a cheap platform that I can use for open source development using a bewildering array of languages and pre-built, free libraries at no cost. Programs written for the RPi can typically be run on a full desktop and vice-versa (within the limitations of hardware). I can also use the array of powerful open source software tools that previously required me to haul around a couple of laptops in a convenient form factor. I have used the camera module, but it pales compared to the smartphones for quality (though it's certainly useful for other purposes). It has no battery, but I can plug it into a 10,000 mAh battery for hours of use when needed. I don't do hardware development, but even without the GPIO capabilities, the RPi is irreplaceable for me. The RPi can be plugged into a wired network, or configured as an access point or wireless monitor. I can plug the RPi into a monitor and use a USB keyboard and mouse for comfort. I can plug 8 USB-serial adapters into a hub and use it as a serial terminal for configuring network equipment. I use RPis for network testing. My typical RPi costs about $85 (RPi, case, power adapter, 2 USB wifi adapters). So while you could, conceivably, make one to much of what the other does, there's no real reason to do so. They won't do it as well, and you'll have to make compromises. They are different beasts. They compliment each other in many ways (phone makes good user interface to wifi-connected RPi). It's not a zero-sum game. You can use both. 

As you dive in, come back and as more detailed RPi-specific questions and you should get some more helpful answers. If you just want to kick around ideas, someplace like the raspberry_pi subreddit might be more appropriate. 

Unfortunately, there have been a lot of significant changes to recent raspbian distributions. You have just encountered the new "predictable interface naming" scheme that comes along with raspbian stretch. If you are using guides based on older versions (jessie, wheezy), you may encounter this problem. Fortunately, you can revert to the old naming scheme by adding to . Network configuration is no longer done in as in previous releases. Be aware that there are other significant changes, including to the init script process. Where possible, validate the OS version a howto is based on, or at least the date to give yourself an idea of what to expect. 

Once you have configured, it will hand out dhcp leases to devices connected to either interface in the bridge pair. dhcp requests received on either eth0 or eth1 will be assigned addresses by . Be sure this is what you want! If you want to limit to only eth1, you'll need to do some additional work, and bridging may not be the best answer. For devices not using dhcp, simply point them to your RPi's IP address (192.168.0.2 in this example) for their DNS server. The Debian wiki has an excellent summary on bridging. As Joan notes, the file has a wealth of documentation on configuring it for dns and dhcp options. EDIT: In hindsight, the question appears to be simply about configuring on an internal network, and not about routing or bridging. I'll leave this response here in case somebody really is after a bridged solution. 

A disk imager should be able to make a full image of your card, even if the underlying OS can't read the partitions on that card. Win32DiskImager is popular on Windows. The image will be the size of the full card, whether or not you actually use all of the space, so a 32 GB card will yield a 32 GB image file. You do have to ensure that the target disk is larger than the source image. 

I'm understanding that you have a wifi adapter that isn't supported, and you're trying to add the drivers. Easiest will be to boot the same card on a RPi that does have Internet connectivity. Otherwise, you're going to have to figure out how to download the drivers and copy them onto the card for installation. In any case, you're going to require a working network connection. You could just use a supported wifi adapter on your RPi Zero 1.3 (e.g. Edimax, TP-Link and other low-cost solutions) to do all of this, then swap adapters once you have the necessary drivers working. I did this early on when the TP-Link adapters weren't well supported. I'd boot with a supported Edimax adapter, load and configure everything, then swap the Edimax for the TP-Link. 

If you are planning on running a light source, just plugging the RPi power adapter into that is probably going to be your easiest solution. 

The bonus to this method is that you can call the job as required at other intervals besides just boot time, and you don't have to edit init scripts. 

Rather than configuring every device on my network with avahi or other solutions, I resolved this issue by setting up an internal dns/dhcp server using dnsmasq (in raspbian repositories). I have a Raspberry Pi B (old model) taking over all dns and dhcp duties from my Internet router. Every new RPi that gets an address via dhcp can be pinged by hostname (e.g. raspi01, raspi02, etc.) without touching the new RPi configuration. I can also easily set up aliases for machines (e.g. the RPi running dnsmasq, "raspi05", is also "netservices"). It also runs netatalk and samba for Apple and Windows filesharing, as well as CUPS to service a USB-connected printer. 

I think you're looking for in /boot/config.txt. There's a discussion on setting this on the RPi forums that covers power supply considerations. 

In short: If you are assigning the RPi a permanent IP address, can put that address in place of 127.0.1.1. This is a debian thing, not a RPi thing. [Edit] Regarding the discrepancy in names between and , it doesn't seem to originate with . The relevant lines that it uses to update the hostname are: 

I did have a very similar problem on an older Model B with the same adapter, but recent updates seem to have cleared up the problem. I had previously tried adding to as discussed in this thread but encountered error messages, so abandoned that approach. Is your RPi firmware up to date? () Also -- Just to be certain -- Is there any chance the RPi is connecting to another AP/router when your primary drops off? Can you get onto it to check ? 

If you mean replace with another solution, yes. You could use a USB-Wired Ethernet adapter. I'm using TP-Link adapters and they work quite well. If you mean physically repaired, while it's not impossible, the effort will likely cost more than the price of a new RPi 2B or require specialized skills. The RPi additionally needs integrated magnetics, so it's not just a simple RJ-45 jack replacement. See this article for a description. 

You need to clarify exactly what you mean by "it fails". Can you not locate the IP address or your server, or is it failing to pull up the appropriate web pages? Based on your comment that "www.my_website.com" works, but "my_website.com", it sounds like you have configured the apache virtual host incorrectly. Apache (and other web servers) allow you to host multiple virtual hosts on a single IP, differentiating between them based on the URL by which they are called. In your case, it sounds like you have "www.my_website.com" configured, but not "my_website.com". There are options for defaults that you might want to look into as well. It's worth noting that this is a Apache issue, and not a Raspberry Pi issue. 

This will only work if you know the hostname is still "raspberrypi". Otherwise, you can try to locate it with a portscan for port 22, although this may be a bad idea on a corporate network. There are other possibilities, but any of these will require obtaining some sort of connection, either a cable of some sort, or a wifi configuration: 

replace with the desired existing user account. I have tested this on raspbian jessie and stretch. Alternately, set your script to run as a daemon using . 

One of the advantages provides is more granular control over when in the boot process things are executed. Provided you don't have any network or other dependencies, you can kick off video playback early in the process. I've used the following service file definition to kick off a slide show display early in the boot process with debian stretch: 

You are using the same 192.168.0.0/24 subnet for both and . From your description, it sounds like you want to route between all 3 interfaces, which means that and need to be separate subnets with corresponding rules for each. If you truly want and to share the same subnet, you need to bridge and , which can work but is not generally recommended. You'd then use the bridge interface (e.g. ) in your rules. For all of that, the RPi is a pretty dicey router. Performance issues aside, just having those easily dislodged USB power and network adapters laying about is asking for headaches. Wifi performance is "not great". 

As Joan notes, is the key. The Debian wiki has good information on how the motd file is generated at boot and how to modify it. Check out the How to keep your /etc/motd from being overwritten section to make permanent motd changes. If you just want to disable it for your user, create a file in your home directory: 

There are many ways to do this, of course, but don't forget using . If you put a line in your crontab, that command will be executed on every restart. To test, I just added the following line to my user crontab with : 

In my experience, the CUPS web interface always required the root user password. You probably need to actually set the root password to be able to use it ( to become root user, then to set the root user password). 

Assuming a new name of username: To create a new user account: Follow the prompts, being sure to set a good password when prompted. You also want to add the new user to the same groups that the pi user belongs to. You can view the groups the pi users belongs to with . 

To address only having a single SD card slot on your computer, the easy answer for burning multiple images efficiently is a powered USB hub and a number of inexpensive microSD-USB adapters. I've tested using a 13 port USB-3 hub and cheap (< $1) microSD-USB adapters. So far as burning a lot of base images simultaneously, check out dcfldd. It is available in the raspbian jessie repositories. It's an enhanced version of GNU dd, with the ability to simultaneously write to multiple images. I did some casual testing, and was able to copy a microSD card image on a RPi 3B to a mix of 7 cards plugged into 3 types adapters on a USB hub. Prior tests to a 3 port USB 2.0 hub on an A+ also worked. It's pretty much fire-and-forget once you get the parameters set correctly. I was limited to 7 adapters, but there's no reason to think it wouldn't work with a larger number of cards, albeit speeds will be limited to that of the slowest destination card. If you need to keep a large number of RPis up-to-date with configuration changes once they're running and on your network, I'd look into using ansible or fabric to allow updates over ssh and avoid needing to re-burn the cards to keep them current. Finally, you could modify your master to change the hostname on each RPi using a unique identifier (e.g. based on network MAC address) to allow easy location via without having to modify every RPi to avoid conflicts after it boots to avoid conflicts. 

The key point is that your hostnames are resolved by whatever is doing DNS resolution on your network. That DNS server must either create the appropriate entries separate from your RPi, or you use some other method you can control from the RPi (e.g. MDNS). 

What I think you want is layer 2. A window manager but nothing else so you can launch a GUI program. There are some very lightweight window managers available. I chose OpenBox for the project in the video. Of course, you could forego a GUI entirely and build it using a text interface, but if you want to take advantage of web technologies, or use GUI toolkits, you'll likely want a minimal GUI. Wikipedia has a nice summary if you want more info. 

Your RPi can only have ONE default gateway. You are specifying one in (192.168.0.2) that might be over-writing the default router assigned by DHCP. Try removing that line. 

On a fresh raspbian jessie install, is configured the same way. Here's what mine looks like on my RPi named "desktop". I manually edited it to replace "raspberrypi" with "desktop": 

If by "take the power from it" you mean simply disconnecting power without shutting down, you do run the risk of corrupting the SD card. Ideally, you should do an orderly shutdown before removing power. This will require something more than a simple on/off switch with the light. 

is a text editor. It is an optional program that can be loaded - typically with the Gnome Desktop - but may not be loaded with every install. It is not a built-in command in the shell, but is called and executed when you invoke it. Of course, it has to be installed first, and according to your error message, it doesn't appear to be. What you need to do is determine what text editor is loaded on your system and substitute that for in the command. For example, I use the editor, so my line would be: . It would be most helpful if you'd let us know what you've installed on your system (e.g. Raspbian with the Pi desktop, Lubuntu or something else.) 

wicd will let you select options to force use of the wired ethernet if present, otherwise try to connect with wireless. It introduces a bit more complexity in the form of a daemon, but gives a lot of flexibility with wireless configuration. You can configure it from the command prompt with wicd-curses. Your /etc/network/interfaces looks OK to me. Are you having problems with interfaces connecting, or just trying to prefer the wired connection? 

Your problem is that all of the edits you've done are for name resolution on the RPi itself. Other computers need to be able to find your RPi using DNS. Specifically, the DNS server they are using for name resolution. The solution is going to depend on what you're currently using for name resolution. If your router/current dns server supports it, you can simply create a static dns mapping or alias there. That way, the other computers will obtain a response when looking for the RPi's name. If you want a more scalable and easier to manage solution, can strongly recommend as a very flexible dhcp and dns server for exactly your situation. You configure it as your dhcp server, and configure the dhcp leases so your other computers point to the server running as their dns server. By default, will create dynamic dns entries for any machine it assigns a dhcp lease to. For example, all of my machines are assigned dhcp leases by , and point to the server for DNS. When I boot a newly-burned raspbian image, the RPi gets the same settings via dhcp, and creates a dynamic dns entry for the RPi. By default, I can locate new raspbian machines with , as well as every other machine that is configured to use dhcp. I can also create static dns entries in for machines that do not use dhcp. I found setup and usage to be far simpler than using ISC DHCP and BIND. Be aware that anytime you make changes to your dns setup, computers will cache dns entries, so it may take some time for changes to be recognized on all of your other computers.