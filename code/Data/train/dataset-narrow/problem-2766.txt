My concern with either of the approaches currently offered is that they'll both lead to 'variable-speed' blinking, which could not only be distracting for the players but also make it hard to gauge exactly how long an object has left before it vanishes. Instead, somewhere in your parameters (whether they be global for the renderer or on a per-object basis) I would have four constants: , , and . When rendering, if your object's remaining life is less than , then blink it at ; otherwise if it's less than , then blink it at . If you wanted to go a step further then you could have an array of distinct s and s and check them one by one, but in practice that's likely to be overkill and just having 'warning' and 'critical' states should be enough. The code would look something like this: 

It's definitely possible, though it doesn't have a clean explicit formula. The projection of a sphere is an ellipse, and given the projection matrix you should be able to find an explicit formula for the ellipse, something of the form ax^2+bxy+cy^2+dx+ey+f=0 (the canonical formula for a conic section); from this you can find a rational parametrization of the ellipse (of the form x=f(t), y=g(t) with f and g rational functions). The problem then comes down to minimizing (f(t)-x_0)^2+(g(t)-y_0)^2 as a function of t, and it turns out that rootfinding methods work pretty well for this - there are exact solutions but they require solving a degree-4 equation, which can involve hairy complex arithmetic and tends to be less numerically stable (and thus less accurate) than the approximate methods anyway. 

If you want your shield percentage (for instance) to actually be an integer from zero to one hundred, then there's little you can do; as you note, you'll be prone to error on things like recharge simply because your 'resolution' isn't fine-grained enough for what you need. But I think you're confusing an integer value with an integer view - simply because you present shields to the player as a whole number between 0 and 100 doesn't mean that you need to represent it that way! Indeed, reasons like your recharge example are exactly why even values that look like integers to the player are often represented as floats (or, at least, 'higher-resolution' fixed point numbers - for instance, imagine that shields scale from 0 to 1,000,000) and rounded (or truncated) for purposes of showing to the player. You say you 'would like to stay away from float damage values for memory reasons' - how many enemies are you expecting to keep track of? Unless you're processing far more enemies than most games can dream of (literally tens of thousands at once if not more), then it's hard to believe that using four bytes instead of one for a handful of values will have any substantial impact at all on your memory footprint. This is really a drop in the bucket, and I can almost guarantee that you'll have far more important things to worry about memory-wise. 

Assuming that you want an actually smooth terrain, I'd suggest stepping back from the noise-based answers and understanding where they come from. A 'noise' signal is essentially a sum of infinitely many sinusoids of random amplitudes, with the 'average' amplitude at a given frequency given by a function of the frequency f. You can get most of the common 'noise' definitions this way. For instance, Brownian motion has a 1/f^2 frequency response (that is, the average amplitude at a given frequency is inversely proportional to the square of the frequency): this means that nearby points have a fair bit of correlation with each other, since the high-frequency components of the signal are heavily damped. By contrast, the classic fractal noise (midpoint displacement, Perlin noise, etc.) has a 1/f frequency response; there's more variance between nearby points, but still quite a bit of correlation. Going a step further, white noise has a constant frequency response - there's no correlation at all between any points. What good does this do you? Well, you can get a smooth signal that still has a bit of a noisy look to it by just summing a handful of sinusoids but making sure that they have an appropriate amplitude at any given frequencies. You want the frequencies to be 'random' so that no two of them will have a common multiple (otherwise you'll get a periodic component to the overall shape of your hills), so I'd suggest something like the following procedure (complete with working example): 

First of all, you probably don't want to get your coordinates by 'converting' a tetrahedron; instead, just start with icosahedron coordinates. Fortunately, coordinates for the vertices of an icosahedron are actually pretty straightforward; they're just the corners of three 'golden rectangles' interlocked with each other: (±1, ±φ, 0), (0, ±1, ±φ), and (±φ, 0, ±1), where φ is the golden ratio (sqrt(5)+1)/2. Finding the 20 triangles that use those vertices is actually probably best done 'by hand' - put together three rectangles like that and look at how they connect and you'll get the idea pretty quickly. On a side note, I would recommend using vertex buffers - rather than having explicit vertices for every point of every triangle, instead have just a list of the 12 vertices and then index into the buffer for your triangles. In your tetrahedron example, this would be more like: 

Using a cellular automata for simulation of a relaxion-diffusion equation might be right up your lines - the equations aren't really all that complex and the results are pretty striking. Have a look at $URL$ for some of the first papers on applying the results to computer graphics; $URL$ has some other fine examples, including for instance: 

—but the problem is that there's no number n that has 16*n=1000! Essentially, while you may be clamping yourself to 60Hz elsewhere, here in these game loops you're actually running one frame (one call to update()) per 16ms—and those aren't the same thing. That disconnect (which would also occur with UPDATE_SKIP = 1000/30, since that also isn't an even division) is probably the source of your issue, but without the rest of your code it's hard to say precisely what the correct fix would be - hopefully this will give you more to look at, though... 

Then on every update, we first find the vector from the first body to the second — of course, the vector from the second body to the first is just the negative of this. While we're at it, we pre-scale it by the gravitational constant and the inverse squared distance between the two vectors; these values will be the same for both accelleration computations, so now's a good time to get them out of the way. Note that since we'll normalize vDeltaPos by dividing it by its length, and then we divide it again by its squared length, we could actually just divide by the length cubed - but vector normalization routines often have special code for numerical stability, so it's generally best to do this 'the hard way'. 

To supplement the excellent answers this question has already gotten, I thought it would be helpful to offer one of the most straightforward ways of comparing hands once the basic classification technique in place. First of all, you'll want to tag hands with their class, as numerous answers have suggested - most of your comparisons of 'is hand X better than hand Y?' can then be done just by comparing the two hands' classes and seeing which class is better. For the rest, you'll actually need to compare on a card-by-card basis, and it turns out that a little bit more work in classification will make this easier. As the baseline case, consider the situation where both hands are 'high card' hands; in this case, you'd compare the two highest cards first, then (if they matched) the next two cards, etc. If you assume that each input hand is sorted from highest to lowest card, this approach leads to code that looks like this: 

Now, with all this, there are some big caveats to be aware of. For one, you'll notice that this math is mostly floating-point, and in fact it almost has to be; trying to use this method to update in a loop and rounding back to integer values at every step can do everything from making your circle not close (either spiralling inward or outward every time you go around the loop) to not getting it started in the first place! (If your d is too small, then you might discover that the rounded versions of aX/aY or bX/bY are exactly where your start position oX/oY was.) For another, this is very expensive, especially for what it's trying to do; in general, if you know your character is going to be moving in a circular arc, you should plan out the whole arc in advance and not tick it from frame to frame like this, since many of the most expensive calculations here can be front-loaded to cut down on costs. Another good way to trim back the costs, if you really want to update incrementally like this, is to not use trig in the first place; if d is small and you don't need it to be exact but just very close, then you can do a 'trick' by adding a vector of length d to oX/oY, orthogonal to the vector towards your center (note that a vector orthogonal to (dX, dY) is given by (-dY, dX) ), and then shrink it down to the right length. I won't explain this code quite so step-by-step, but hopefully it'll make sense given what you've seen so far. Note that we 'shrink down' the new delta vector implicitly in the last step, where we add it to our center to get the updated point: 

This breaks into two distinct pieces: testing collisions against the endcaps, and testing collisions against the body of the cylinder. The simplest way to handle both is to first transform your way into object space — the ideal 'object space' for a cylinder is with the origin at the center of one endcap and one axis (for concreteness' sake, we'll say the Z axis) running along the 'body' of the cylinder, orthogonal to the endcap planes. In this space, your cylinder is then a pair of discs of radius R in the xy plane, capping a cylinder that runs from z=0 to z=L. To intersect the ray with one endcap, then, you need to find the point on your ray where it intersects the xy plane: assuming that your ray's equation is r(t)=r0+d*t (I'm using boldface here for vector quantities), then by solving rz(t)=0 for t, you find t=-(r0z/dz) (note that this breaks down if dz=0; in other words, if your ray is parallel to the xy-plane. In that case, you can skip the endcap test and just test against the cylinder, along with a check to make sure that r0z is between 0 and L). (Similarly, if you were trying to intersect with the z=L endcap, you'd find t=(L-r0z)/dz ). Plugging this value of t into your ray equation then gives you a point p where the ray intersects the plane of the endcap; now you just need to test whether this point is within your disc or not - in other words, whether px2+py2 ≤ R2. Testing against the body of the cylinder works similarly, but is a bit more complicated: in this case, you'll project your ray down to the 2d plane (since we're working in object coordinates, this is as simple as dropping the z component of your ray equation — you can see why these coordinates are so useful!) and then doing a 2d line-circle intersection: essentially you want to find the points where |rxy(t)|2=R2 (here rxy(t) is the ray equation 'projected' down to the xy plane by dropping the z component); this equation is just a quadratic in t, and you can solve it for the two possible values of t. One big caveat, though: once you find the two values of t that solve the equation (and note that there may be none, which means that your ray doesn't intersect the cylinder at all), you'll have to plug them back into your original equation to make sure the corresponding z values fall in the 0..L range. Finally, you'll have (up to) four distinct t values: the two possible intersections with the endcaps, and the two possible intersections with the sides of the cylinder. (Of course, in practice there can only be two, but that's a separate matter). Just choose the smallest of these that's greater than zero, and that's your intersection point.