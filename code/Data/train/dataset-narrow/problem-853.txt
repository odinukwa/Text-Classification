This comment is redundant, the append method on a list appends an element to that list, you don't also need to say that it adds to the list. Here is an example of a comment that's useful 

This way you don't need to worry about either, not that that would really be a problem here anyway. This while loop could be a lot simpler. Try breaking it down into multiple well named boolean values instead. 

Thanks for sharing your code, Instead of dealing with nodes directly, I think it would be easier, and make a lot more sense to have code that looked like this. 

We've cut on verbosity, but it's debatable to me whether it improves readability. It's harder to achieve the same thing for , although you could pull it through if you added a helper extension: 

doesn't make sense to me. When your code is conditional, DRY (Don't Repeat Yourself) and try to extract whatever is common for all execution paths. Eg. 

Shouldn't this be a , or ? And why is it defined in ? It feels wrong if a parent class knows about its child class. 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

So no the class is your "Runner" and is used in your main method, it contains an instance of a and a . Hopefully you found this review helpful, keep up the good work! 

and let the garbage collector worry about the rest. You would of course still need to check that all of these values are okay to use like this before hand. LinkedLists are supposed to be good at adding and deleting elements from the start. And if it's a doubly linked list, also the end. As side note, I would prefer to see your Node class as a private class inside your linked list class. As this Node class probably shouldn't be used anywhere else. Your public interface is a bit unusual, for a list, I would expect to have public methods like , etc. is an implementation detail, this should be a private method that's called when the list is empty. if I wanted to insert an element at the head of the list, I would prefer Another thing that stands out is your deleteNode method. This is definitely an implementation detail leaking out. A user of the list shouldn't know at all about Nodes. The method doesn't even take a node, it takes an int, I would prefer . Also, your list won't properly support duplicate values, if I have 3 nodes with the value if 5, and I try to delete 5, it will delete the first node with a value of 5 it finds. As another side, you should make as many variables private as possible. 

So how on earth is it able to correctly detect whether is present in the collection? Standardization Custom collections should support standard .NET interfaces such as IList. Otherwise other code can't really use it (other than as an ) unless specifically refactored to do so. Besides, your implementation doesn't allow inserting an element in between pre-existing elements, which pretty much defeats any major benefits of implementing a collection as a linked list. Generics As @MatsMug remarked already, it's supposed to be generic, yet - same as your previous implementation - it doesn't support , only its non-generic, legacy version. Documentation It's good that you now use documentation comments (at least for a class that's supposed to be of general use). But this "this is" (as in "this is a singly linked list data structure" or "this is the Node class") is unnecessary. It's just fluff. We understand that it's a class, and that the comment must refer to this class, not some other class elsewhere. Typos don't make great impression either ("Implementatoin"). If your class is opinionated about nullability (which is an improvement over your previous submission), this should be described in documentation comments. As of now, your comments are stating the obvious, for example: 

Now, in order to be a , we just need to implement an method. So instead of maintaining booleans which describe the concrete class, we can make many smaller implementations instead. Let's have a look at a potential implementation. 

This Sorter interface at the moment has just one implementation, but if you decided to work on other sorting algorithms, you could make a MergeSorter, QuickSorter, TimSorter etc. I've changed from a static method to an object that you instantiate. Insertion Sorter Class 

If someone passes in that list, they can add/remove stuff from it and it will effect the list in your playlist object! Try this instead 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

I would advise against renaming an import like this just to be able to write c instead of Counter. The code becomes far more readable if I'm looking at 

thanks for sharing your code! There are a few pretty big issues with your current code. Variable Names Your current variable names tell us absolutely nothing about what the variable is, or what it's doing. and tell us nothing. If someone needs to read through your code following a poorly named variable just to find out it's purpose, that's not a good thing! Remember, other people reading your code didn't write it, they won't know what each variable is unless it has a clear, meaningful name. Let's just look at this short snippet 

The last trick I can think of would be to convert these conditionals into instances, and pass them to the LINQ chain. I haven't got a C# IDE on this computer, so this code could be syntactically incorrect, but you get the idea: 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

thanks for sharing your code! I want to start by saying that I think this looks pretty good for someone only having been coding for around a month, but I think you're getting some concepts mixed up or not quite sure how/where/why to use them. The other comments and answers have already pointed out flaws with the class, so I won't repeat those 

Consider using named constants, instead of magic numbers. A magic number is a number that has no clear meaning on its own. 

this is a violation of the Tell don't ask principle. Here, you are asking the object to tell you what its health points are, so that you can perform some calculation with that result. Instead, you should tell the object what you want to know. For example 

And again this is subjective, but I see these as a (common) anti-pattern. It's code, not a painting or a poem ;) We've got version control systems for that. 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

It's not bad already (save for the weird formatting of parameters, what's with commas at the beginning of the line? : ) But that's a matter of taste, and beyond the point). You could return to the trick you used in your previous implementation to avoid breaking the chain and get rid of value reassignments by pushing into the predicate, like so: