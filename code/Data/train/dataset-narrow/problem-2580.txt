I've heard it's around 30%, but like all sites of this type, the actual pricing structures are under an NDA. 

I'd consider doing it as two flat lines, set at ninety degree angles, such that the cross-section of the wire was literally a cross. If you wanted to be a little cleverer, you'd do the billboard thing, such that you had one flat line always directly facing the player. Meshes and shaders seem overkill. (Well, okay, the billboard thing might use a vertex shader. But seriously, just do two flat lines unless that's actually causing problems.) 

If you're doing it this way, finding the shortest direct path isn't difficult - travel the maximum NW/SE distance that you can without overshooting your target along a cardinal axis, then travel directly along that axis to the target. But of course that will happily run you straight through mountains or other impassable terrain. To answer a question you haven't yet asked: The A* Search Algorithm is a common and reasonably good approach to pathfinding. It will handle not only weird non-grid layouts, but will happily deal with obstacles and even obstructed/slow ground. 

The traditional solution to this is a finite state machine, which is being suggested in several comments. I hate finite state machines. Sure, they're simple, they're supported in every language, but they're such an amazing pain to work with. Every manipulation takes a ton of bugprone copy-and-paste code, and tweaking the effect in small ways can be a huge change to code. If you can use a language that supports them, I recommend coroutines. They let you write code that looks like: 

you've got two questions you need to answer. First, do you intend for players to be able to see the lobby while they're playing a game? If so, you'll obviously need to incrementally update. Second, do you expect incremental lobby update bandwidth will be excessive? If so, then you'll obviously want to wait to update. Personally, I think this question just isn't an important one. The bandwidth is likely irrelevant. The answer really comes down to "do what is easiest to code", IMHO. But in general, you'll have to weigh server load vs. player experience. If you've got any further questions, toss me a comment and I'll make things clearer as needed. 

The first one massively emphasizes the grid edges. Some of the gems are nearly invisible. The second emphasizes those still (and more than I personally would), but it also emphasizes the border of the puzzle very strongly, and the gem is significantly more (though still not perfectly) visible. This method isn't a panacea by any means, but it can help you track down things that should be fixed. Just keep in mind that human vision is based around edges and contrast, and design your UI to be readable by humans. 

Store the last time you rendered a frame, and if it hasn't been enough time, Sleep(). Note that Sleep() can sometimes result in your program not waking up when it should, giving you a framerate stutter - test it pretty carefully. In my experience most modern OSes will timeslice frequently enough that this won't be an issue except in fast-paced first-person-shooters. 

The simplest texture manager has one function: GetTexture. GetTexture checks its cache for a texture. If the texture isn't cached, it loads the texture. Then it returns the texture. Kapow! Done! That is sufficient for most small-scale indie games I've seen. You just don't have enough content for this to ever be a problem. One downside is that this can result in loading hiccups during gameplay. Quick fix: just call GetTexture with all the textures you expect to use during a "loading" section. Another possible fix: when you "load" a texture, hand a functional blank texture handle back, then start loading in the data asynchronously in the background (in another thread or with asynchronous file loading calls) and fill it in once it's done. This way you avoid the load hitches, but things can look a bit weird until textures are filled in. If you want to implement this, I'd recommend a GetTextureAsync function to call when asynchronous loading is acceptable (which in my experience will be only a few places, but those places may account for the majority of the textures in your game.) Another downside is that you will, eventually, keep all the textures in your game in memory at once. This can also be easy to fix - if your game is divided into levels, just clear the entire cache between levels and reload everything. A somewhat more complex solution is to throw away textures after they've been unused for some number of seconds. This works great for large streaming worlds with unknown resources needed at each point (like MMOs - you never know what armor you're going to see next) but it does mean there's some lag between when a texture is unneeded and when the memory is actually freed. If you want a more complex texture manager, you can start having formal concepts of blocks of textures that need to be preloaded. Each level can have a texture corpus, and when you change levels, you explicitly throw away the old corpus and load in the new one. Couple this with on-demand loading for unexpected textures, and a delay for deallocating those, and you're pretty much set for quiet some time. As an example of this, in a game in a large contiguous world you might break the world into areas, then come up with a corpus for each area. Load textures for all adjacent areas to the player while throwing away textures from further away. (With refcounting, of course - if every area uses "grass", then there's no reason to store multiple copies of "grass".) But meanwhile, back in reality, you'll probably be just fine with GetTexture. :) 

I suspect this is one of those things that isn't elegant, just involves a lot of code. You can try to come up with reasonable building blocks to create attacks. You can try to generalize things massively. But you may spend more time trying to invent generalization than you would just coding it a dubious way, and there's no way you're accomplishing this without a significant chunk of code. I'd just start coding new visual effects, either via a branch in your animation method, or via inheritance. Generalize where it makes sense (i.e. it's silly to write "animate fireball hitting enemy" and "animate energy bolt hitting enemy" classes, just write "animate image hitting enemy" and specify the image based on the spell.) As you write more visual effects, look for ways to combine them sensibly into a larger structure. Maybe one will become apparently. Maybe it won't! Maybe it's just annoyingly complex code. 

Speaking as someone who's done this: it's not worth the hassle. Unless your game design absolutely needs it, and it almost certainly doesn't, you'll spend far more effort getting sweeping working than you really expect. And it will be slower than you wanted it to be. 

64-bit architectures are great if you have a game that can take advantage of 64-bit architectures. If your budget doesn't have at least eight figures you probably don't have that game. Target the system that makes the most sense for your game. That's probably a 32-bit build, and if it isn't, you likely already know it isn't. 

I think part of it may just be that Blizzard has an amazing number of texture artists. But let's rephrase the question a bit: 

Pathfinding is fast, and on something the size of a normal tower defense game, you'll have no trouble running a full A* or Dijkstra pass whenever something changes. We're talking well under a millisecond for a full refresh. Any kind of adaptive pathfinding ends up horrifyingly complicated. Just do it the simple way, unless you're making the world's largest tower defense grid. 

After you've rendered the world, reset the camera position to something more useful for UIs. Then render the UI. Next frame, put it back to the world position before rendering the world. And so forth. By "camera position" I really mean "transformation matrix". Nobody says all rendering has to go through the world transformation. 

This isn't a perfect match, but Dominions 3 is the first thing I thought of. It's got the simultaneous movement and heavy use of diplomacy in order to win games. There's no official way to "support" units, besides having them form larger armies, and there's no way two players can assist each other in combat. But from what little I played of Diplomacy, Dominions 3 has the same basic feel, only with, you know, hordes of monsters and worldshattering spells added. In a more general sense you might want to look into the Play-By-Mail genre, now frequently referred to as Play-By-Email or PBEM. There are many, many examples of this genre, but besides Dominions 3 it may also be worth looking at the venerable VGA Planets and Stars! games. 

Besides the "make sure the keystrokes are replayable" solution, which can be surprisingly difficult, you could just record the entire game state on every frame. With a little clever compression you can squeeze it down significantly. This is how Braid handles its time-rewinding code and it works pretty well. Since you'll need checkpointing anyway for rewinding, you might want to just try implementing it the simple way before complicating things. 

And as a side note, I just implemented this algorithm (fixed width 512 pixels) for quite literally the exact same application that you're doing (no ftgles, but opengl-rendered freetype glyphs.) Here's the result. It looks blurry because mine is using Valve's distance-field based text rendering algorithm, which also accounts for the extra space between glyphs. Obviously, there's not a lot of empty space left over, and it does a good job of cramming things into open spots. All the code for this is BSD-licensed and available at github. 

Three answers: First, figure out where your bottleneck is. You've described a very long process there. Where's the slowdown? If the slowdown is glReadPixels itself, then you've got a problem (see second answer). If the slowdown is everything between glReadPixels and AVAssetWriter, maybe you just need a more efficient way of passing it into AVAssetWriter. If the slowdown is AVAssetWriter itself, then maybe you just need a more efficient way of dumping the video to disk. Second, if the slowdown is glReadPixels . . . well, if a much faster approach existed, don't you think glReadPixels would likely use it? It might just be slow. You might just be out of luck. Third, I know I've seen videos of iPhone games. Contact an indie developer with an iPhone video. Ask them how they did it. Then post the answer here. 

If you're talking about from the very beginning, and note that very few major game engines are coded from scratch anymore, and note that this is an example and not necessarily how it always works . . . Rendering: Start by rendering a flat-shaded cube. Add basic lighting effects to it. Add a way to move the camera around. Now you can fly around a boring cube, suspended in an infinite black void. Yay. Next, you probably want to import a model. At the very least, your artist can whip up a demo model (a teapot is surprisingly traditional), but they may have an actual game model they can hand you. Again, we're sticking with flat shading for now, so it'll show up looking like it's made out of . . . well, no realistic substance, but sort of a cross between matte plastic and porcelain. This, but without good lighting. And we're still at the point where it's completely unmoving. The next three major steps can be done in any order. 

I'm a big fan of many things moving simultaneously at slightly different rates. Take a look at (shameless plug) KØЯ., a vertical shooter I wrote a bit back. I'm quite proud of the explosions. They're a bunch of simple arcs (literally, I drew a circle in Gimp, then deleted an offset circle out of it, then saved it as a .png) rotating about all three axes at a random speed, expanding at various speeds, slowing down at different speeds, and fading out at different speeds. All of that is random. I just tweaked the randomness a bit until it looked good and went from there. One thing I've started to realize is that subtle intentional breaking of the laws of physics looks awesome. I imagine we've all seen anime with people leaping off walls or falling ten stories and landing in an instant. We know that stuff isn't possible, so our brains interpret it as "omg this person is so awesome they can defy physics." The explosion effects are the same way. You can't have an expanding sphere of explosion with some parts accelerating and some parts decelerating. That's crazy talk! That can't happen! And yet, that's exactly what I do, so, bam! It looks awesome. You can also - as you can see in KØЯ. - get a lot of mileage out of "stylistic design" (read as "the programmer sucks at art so he makes monsters that consist of a bunch of colored boxes") and fancy linework and bloom, as long as it's all consistent and looks like the designer was clever instead of just incompetent. Fundamentally, though, look at other games or movies and see what they did. Go play Gratuitous Space Battles for a few hours. Or look at GSB's source material - space combat movies, Star Trek and Star Wars, and go from there. Play games with awesome effects, watch movies with awesome effects, watch anime with awesome effects. Analyze it from there and figure out how to fake the behavior you want. 

Most likely not - I doubt Torque would want their engine to be open-sourced. For a real answer, read the license you signed when you bought the engine. For an even better answer, read the license, then hire a lawyer to read the license. What you may be able to do is distribute the Torque modifications as a patch. Anyone who has the engine source will be able to apply the patch and release a build. But, again, consult a lawyer before doing this. 

First, I am not a lawyer, this is not legal advice, if you follow my advice and get sued then it's your fault not mine. That said, you've talked about "copyright issues". I'm going to break this down into two questions: 1) If I get sued for copyright infringement, will I win? Probably! Game mechanics can't be copyrighted, so you're safe there. If "potion" isn't officially in the public domain then it's only one court case away from being so. "Ember" should be reasonably easy to defend - I know that ability name is used elsewhere. The "ball" is probably the sketchiest thing you've got, and if you just change the ball you're probably gold. 2) Will I get sued? Maybe. Unless you have a nice big legal war chest to rely on, getting sued is almost as bad as losing. You can't hope to match Nintendo's legal funds. It will not happen. You'll go to court, and you'll probably blow thousands of dollars just on prep work. And then even, if you win, there's no way you're getting that money back without a second court case - more money, and you're not even guaranteed to win that one. So, as I see it, you have two realistic approaches ahead of you. First, you can change things up enough so it's not as sketchy. Give your game a feeling of its own, not one copied from Pokemon. Don't use "gym trainer" and "tall grass", invent stuff. Instead of four abilities, use six. Give your PC a seven-monster party, and do something new with the monsters. Throw out two thirds of the Pokemon elements and make your own. (You're probably safe with "fire", but if you have "psychic", "bug", "rock", and "ghost", people will look at you a bit odd.) "Inspired by Pokemon" is safe. "Exact copy of Pokemon" isn't safe. Alternatively: get legal counsel, get legal insurance, and form an official company to get at least a slight hint of the corporate veil going on. It'll cost you money, but it'll be a lot cheaper than being sued into oblivion by Nintendo, who will probably cheerfully drop the suit the instant you sign over all your intellectual property to them, and not a moment before. Again, not a lawyer, not legal advice, get a lawyer.