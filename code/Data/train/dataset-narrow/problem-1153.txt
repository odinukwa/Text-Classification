By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

Much simpler. Premature Optimizations If you ever have enough members in a room for the optimization to gain you anything, you'll probably be exceeding the length of the Mongodb query. This needlessly complicates your code. Ironically, any gains are lost when you forgot to use rather than , which needs to iterate through the lists you just made to avoid iterating through the lists. It looks like the accessors for the attributes already return values, so this can be much more readably rendered like this: 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1 

Then you can have your validation method return a state, and you can do your checking block after, like this: 

The only other comment I have is that the and methods are , so you should be calling them as and rather than which is for instance methods. 

What I have so far seems to work fine, apart from the aforementioned issue, though the amount of code for what sounds like such a simple function is far above what I'd hoped, so I'd really appreciate any ideas on how to reduce it. 

The first thing that jumps out is all the Strings you have which are reused throughout, those need to be removed and ideally put into constants so you only have to change them in one place if you ever need to rename them: 

So it sounds like they want it so you can add a mouse to the choir and it will only squeak, and a cat will only meow. Instead you have a single choir which randomly picks a sound to make and no distinct objects for the animals. I suspect they were wanting an Animal to make a single noise which is specified upfront in a more object-orientated way. Something like this at a minimum: 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

Additionally, I'd suggest reading up on your SQL for a start, this whole thing screams out clause. In every case, your database will be more efficient at sorting the results than whatever programming language you're using them in (and certainly PHP). Such as: 

I have a array and a of a custom object and I'm needing to loop around and perform an operation on both but only as long as one of both is available, the original method is as follows: 

There's a few changes I'd suggest to insert, firstly as the second parameter has to be an array, you can use type hinting to indicate this: 

I would also avoid using regexes or any kind of manual string parsing, you can do it all with and , thusly: 

The ideal package structure is one which indicates usage. Classes such as these which exclusively contain static methods are definitely utility classes, which I usually put in a subpackage of your main application. From what it sounds like, you don't have a main package at the moment which ideally would be your website (in reverse domain order), e.g. so that the more specific elements are later, then on top of that you'd have the name of your application which may make it something like . This would be the core of your program, and from here you could then add on your extras. The package in particular doesn't sound helpful: your entire program seems to relate to Twitter so it doesn't really convey what that part of the program does. Frankly, I'd just put all those classes under and add in more sub-packages if you add more classes. And generally speaking, in Java packages should be exclusively lowercase. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

There's really not much we can help you, given the low level of detail in the question. There are somethings you have in this code snippet that are generally considered a Very Bad Idea, so I'll give what help I can in that regard. Null Checks There are a bunch of these types of checks in the posted code: 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

With this, you can remove the first if/else and foreach loop entirely, by removing the ternary and using , like so: 

You also haven't got any access modifiers on your methods. As directly prints out a segment of HTML which wouldn't be valid on its own, I'm guessing that it's probably only used once somewhere in your View and as such should be or to prevent misuse. As for the actual code, aside from collapsing some statements there's not much to change. These lines in don't appear to be doing anything though: 

I put as a method as it isn't clear whether you're using this design pattern elsewhere, but I assume so as you're connecting to something and there's usually other exceptions that can happen later. If you aren't, you can just stick it back into the catch block of . Additionally, if it isn't clear, the ternary is so you don't have to manually type in the message to attach a cause to an unknown exception being wrapped. And I took the liberty of replacing the generic message "connection" with the stack trace of the exception that caused it being passed to your logger, as this more detailed information will be useful should you wish to debug the cause of it. 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree. 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

Though even this is pretty sloppy, depending on the amount of time you have I'd probably go deeper and write out the standard s and es they're looking for with these tests: , (for all the validation methods), , , etc. 

If number of lines is your primary concern, then really all we can do with this is merge your array creation lines, and use to create temporary arrays which you can loop around, like so: 

However, when you increase the number of possibilities to 10, and reduce the guesses to 5, you can no longer do this, and the chances of never guessing a correct number increase dramatically, e.g.: 

You do a lot of mapping from parameters to arrays and vice versa, which you could simplify by storing an array of the parameter names and whether or not you want them trimmed, for example: 

It's secure, but it's really chunky and tedious to write. I'd do this by overriding the magic method to trick GSON into thinking the methods exist, like so: 

And you can delete the rest of your class. Edit: Using the new method would then allow you to add pieces of text at the specified points in your message, so your validation method that returns a State would use it as follows: 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier.