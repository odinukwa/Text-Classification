Depends on the context, or how the rest of the method looks like. With the exception, it's clear, what the method does - but Exception messages shouldn't describe what the intention of the code is, right? If you had something like 

Well, when I read it first, it made sense. But when I take a closer look, man there's some fancy stuff going on there! 

We have an app with few entities, which are passed through a workflow. The entities have different workflow states. The main issue is, that the change from one state to another often leads to other executions, such as updating other records or sending emails. The actual code is a bit of a mess right now, very long methods with lots of if elses. I'm trying to implement some sort of an entity state machine with the main goal, to reduce the code mess. The code does not respect assertions, such as null checks, exceptions, etc. I'd like some advice, if I'm heading in the right direction, if there's some simpler methods, if I will have some sort of problems with this solution - or any advice in general. Well, if you see something that annoys you, I'd like to hear that, too =) I like the most about this code, that we can isolate necessary code for switching from a specific state to another specific state, as in . But I'm still not really convinced. The 'assignment' of the posted code would be "If I finish a Task, the task is persisted and a mail has been sent to the user". 

I recommend to use brackets. I've never seen code guide lines where no-bracket-one-liner-thingies (What's it called?) are allowed. 

I really think the 'only select data you need' paradigma is quite out dated. The management of the 'choose what columns' thingy, the 'be careful because its not null in the backend but someone might not have loaded that column' and the inconvenient increase of execution plans on your backend - which has to be managed, too - is in my opinion much more expensive compared to just select all (= upgrade the switch or add another cpu to the backend server) 

That's it, isn't it? That's three things, you have to verify for this class. All the other dependencies, well, their implementations, have to be unit tested in separate test cases anyway. Potential improvement would be the , I think this can be decoupled to a separate service. Instead of creating a worklogServiceContext using the worker key, and then call it with the inputParameters, you could wrap and in one method ("Tell, don't ask", $URL$ With that said: You might want to let us review your test code. Hope this helps, slowy 

... I think a view with a dao responsible for that case is the way to go ;-) To be honest, in ormappers, I do not like the represent the complete erd in java objects approach. Maybe I just didn't get it, but sometimes it gets quite horrible. I mean, you have a Customer, the Customer has a List of Addresses, a List of Orders, a List of PhoneNumbers, a List of Items in the Shopping Card, a List of open bills and and and. And everything is present in the type of hell. And it gets worse, because all those dependencies have other dependencies, too. I found, that an app, at least above a certain size and complexity, is much more maintainable, if "those" problems are taken care of with a certain degree of isolation, even though that means, there is some redundancy, maybe a ClientAddress type and a ClientOrders type, instead of a "one size fits all" approach. Hope that helps,... 

Yeah, just a check, but jumping out of the method. progress() Progessing what? What's val? What does it return? Uses CTRL+F THE VELOCITY? WHAT? step() 

(You won't believe how long I was clicking around the app you linked, that thing is somewhat satisfying... ) This is very interesting! If you got a github repo, I'd be happy to play around with it. If not, I'd be happy if you would make a github repo =) Performance in general Well, to improve performance for future requirements, which are not specified, can often results in a step backwards: Requirements can change or are not required anymore. Then, you're sitting on code wich is implemented for requirements, which are, well, not required. "By definition", more code makes your app slower. That's why I argue, that measuring is the most important thing to do, when it comes improving performance, because sometimes you get the opposite. And: The more flexibility you have, the less I'd invest time for potential performance problems. Less flexible would be stuff like, geographical aspects (e.g. where is the data center located) or scalability aspects (the software must perform the same for customers who want to analyze gigabytes of data as it would for customers who want to analayze peta bytes of data, just by adding more servers) or any given restrictions, like bandwidth. FPS One thing I want to mention: Since you visually display your data, you should have a component which renders the particles. So all your calculations must be finished within 1/'Amount of FPS you want to render' seconds. If you haven't finished the calculations, just skip a frame. And: At least decouple rendering from calculation, if you haven't done that yet, it shouldn't be too hard to achieve and it should improve performance (which should be verified/measured). multi threading That's usually a thing I try to avoid. Because,... well, let me phrase it like that: If you want to solve a problem using multi threading, you might solve the problem, but you will get at least one other problem :P Most of the particles move themselves. When I'm thinking about two particles with gravitational force, they both influence each other's direction and speed. Now, you could either calculate the new position of one particle, set the position, and calculate the new position of the other particle, using the newly set positions of the first particle, or you could calculate the positions, and set them at the end. I think this way you could at least multithread the calculations of the next position. And the outcome of the new positions should be always the same. Other interactions, like spawning or destroying particles, I'm not really sure. If I'm looking at the app you linked: If a ice particle touches a water particle, and a 'bomb' particle touches a ice particle: Which should go first? Because: The bomb particle could destroy the ice particle, and at the same time, a ice particle could turn a water particle into ice, even though it got destroyed at the same time. If you analyze it, or if you define a rule set yourself, you might find particle types which can be calculated parallel. Hope this helps, slowy 

Ordering The ordering is a bit mixed. Try to an ordering such as: variables, constructor, public methods, private methods. There's no real convention for that, but try to tell the reader the story about your class. As for instance the member vars are the protagonists, the Constructor is the entry of a book, and the methods are the chapters. Probable bugs 

My two cents: Swing Swing's dead, just wanted to mention that. I still use it too sometimes, to test stuff out. GUI The main issue I have with your code: I don't see a GUI pattern involved. You might want to check Martin Fowler's website, he has quite the list of Presentation Patterns with good examples. I mention that, beside the Single Responsibility Principle problem, because of the following reasons: 

Naming things The naming of the classes and variables can be improved. Naming things is essential. It may sound stupid, but it's not uncommon that at least two people discuss the name of the class. And then, if you got the name, you ask another one: "If you read the class name WhateverThingerClass, what do you think it does"? The background is: You spend an awful lot of time reading and analyzing code. It can happen, that you need 4 days of reading code, and then a single day to implement the feature. And if the code is not self explanatory, you need more time to understand what's going on. It's not only about maintainability, it's also very important from an economic perspective. 

It's much easier to use and understand. toString() For instance in the type, you append to the return value. Is there any reason for that? @Override You're overwriting the toString method. Always use the @Override annotation for overwritten methods. It helps the reader to see, that it actually is overwritten, and, the compiler actually checks, if the method is actually from a super class (if you mess things up) Liskov / inheritance Now, I'm pretty sure, this isn't within the scope of your assignment either. In your main method, you got an array of Vehicles, at the end you iterate over it. Now if you were to know, how many passenger seats there are, you will be only able to do that, if do something like ). If you add another interface, for instance and want to get information out of that, you add another if clause. That's a violation of the Liskov Substitution Principle, or, in other words: bad inheritance. (You should look that up, it's a object oriented core principle). Now, I really dislike inheritance, in general, it's often a pain in the long run. I would have hidden the sub classes behind a static factory or something and provide an API like 

My understanding from a builder is a bit different. In my opinition, the User should not have a dependency to the Builder (you have a bidirectional dependency which is usually bad anyway). With that said, use the User as member variable within your builder: 

I'd provided additional methods like in the base class. But since it's a home work assignment doesn't target real world problems, but wants to teach you something, I won't go into more detail. Hope this helps, slowy 

In general, it's easier to learn something if you start easy. It's better to learn driving a car in a small car than in a 1000PS Koenigsegg. If you're not in that learning phase, it depends, if it's a 'throw-away' app or a productive app. To your code, I just reworked a small part of it, to give you an idea 

Now, that's some dubious stuff, isn't it? Why can I call the method on 'MOBILE' and pass 'EMAIL'? This made me literally laugh xD. And what displayed message? Displayed where? Where do I get this display message? What does it do with it? 'getTranslationForEnum' or something would make much more sense. 

Reverse the condition and remove the continue. And I don't know,... I usually cringe when I see . Reminds me of my assembler lessons somehow. Don't know why, I try to forget about it. 

As RobAu said, there's a lot going on. A priori, I am developing enterprise applications, so there's usually a lot of stupid logic involved, way too much data and thousands of concurrent acccesses to databases - and maybe I sound like a bit like I'm ranting and nitpicking and maybe some suggestions are a bit overkill. But since we're here... Transactions / unit of works You are working with transactions within the method. But this method is called in which actually does whipe the table. Just keep in mind, that if you have a unit of work, where you do more than an insert, you can get inconsistent data in a concurrent environment (not only concurrent within your app, but others accessing and manipulating the database). The transaction management is usually decoupled from the database access object, since, like in your example, the method does not know about what is happening around it. I highly recommend to read about those topics (transaction management, unit of work, isolation levels). Speaking from experience: It's surprisingly easy to mess everything up, if you do not know exactly what you are doing. So easy ... delete and insert all Usually, deleting and inserting is way more expensive than to update existing, insert new ones, and deleting non existing ones. If you delete everything, and insert everything, you mess up indexes and statistics. column index access During reading, you read the values using the column indexes. It's almost always better to use the column names. If you declare the columns' order within select statement (which I do not recommend), you always have to change both, the statement and the retrieving of the column values. If you and the columns get reordered, your application will break. JSON / Model You actually provide an , but you pass json to , which then is de-jsonified to the an , which then will be passed to , within that, you get the and create the insert statement. The json has no business in the data layer, the mapping from json to the actual type to write should be performed in its separate type. I recommend to write a type which holds the data it needs and pass this one, instead of JSON, a map of channelNumbers and a map of channelImages. tidy up Your methods are way too long. For instance, the , consider the following points: Declare the insert statement as constant in the class and move the binding of the values to a separate static helper method. That should look much better. SQLite I never worked with SQLite, to be honest. But: Keep in mind, you cannot exchange your database without a huge amount of work - at least that's how it looks. I would have implemented it using standard jdbc, assuming sqllite provides a jdbc driver. other