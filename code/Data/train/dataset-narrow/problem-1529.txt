If I had more time (going holiday shopping with the GF soon) I would describe how we could eliminate mutating it, but I think this lesson stood to prove it's point: we can almost entirely avoid mutable state in F#, and we also learned a few cool tricks on the way. 

Based on the research I could suss-out in a short bit, this looks like it's appropriate for EF-Core, whereas the accepted answer looks more like EF on standard. I can't test it, so I leave it to you, but I would go more towards this route than a shared lock. Of course, it's up to you, but I wouldn't even try to re-save the on a duplicate key violation, because we know it's going to be right now, so why do the extra work? I'd just and swallow in this case, with a clear comment as to why: 

For a functional program, it's not too bad. I don't like how many times you use (I always prefer ), but when dealing with boolean types it does quite fine. 

Yes, the idea of the is to mark a shared resource as "in-use" so that threads know to wait on each other before they can proceed. You could, however, replace it with a instead of an for smaller overhead. You could have performance implications by the , but that's the downside of multithreading: somewhere you will have a bottleneck from context-switching, et al. That is beyond the scope of Code Review. 

That is entirely acceptable, and prevents us from accidentally setting the list in a non-constructor. (The constructor can still set directly, but no other code can.) 

Next you can pull a lot of that work outside the block, and throw a better error. I would, at the very least, change it so that the error message reads "Could not migrate Student ID" et. al. Then, at the end of that block (after ), if you really want, you could add another , or just since they're the same type and such. After we adjust this section, we should extract a method for it. 

Next, we'll talk about your conditions. You use an statement for all your operations, but that's unnecessary and creates extra processing in the case that the operation is the last condition. (Each previous is evaluated before it continues to the next.) Instead, we'll go to a statement: 

When using braces, try to include a space between the identifier before the brace and the brace itself. This should also be applied to parenthesis on , , , etc. Basically, parenthesis that are not for a method call: 

Optionally with your / pattern. This way, if you create more stored procedures it's less work to make them operate. 

Bugs So, some interesting bugs. If I specify two cultures that have the same invariant, but are different versions it creates really unpleasant circumstances. (Infinite loops, anyone?) 

So that's easy, now we can specify a specific day to check. All we have to do in the code is use that variable. 

Although this feels very "examplish", here are my thoughts: Personally, I would rethink how you handle paths currently. As it stands, the directory structure must be very specific: you are provided with some "root" folder, and in that folder you have subfolders, each named after the of the library within it, then a folder, then a folder, so an example would be: 

Generally speaking, in C# we try to use (first letter of each word is uppercase) for public and protected members (properties, fields (never have public fields except when absolutely necessary), events, methods, classes, interfaces) and (first letter of each word is uppercase, excepting the first word) for private members, and locals (variables that are only contained within a method/property). We don't use or anymore, though I won't lie, I still use for constants. If you want to help keep members a little more distinguished, we also commonly use the underscore () as a prefix to members. I do this almost always, as it helps me distinguish between them a bit better from method parameters and such (which do not get the prefix). This also means we can avoid using the naming convention which was popular at one point. 

But we're still not done, let's say we want to write our such that it doesn't create the entire result array, we want to stream it, sort of like an in C#. In F# this isn't nearly as hard as it seems, all we have to do here is rewrite our as a sequence generator, which turns it into: 

First thing's first: Don't use public fields. (What is a field? It's a member of a class/struct that looks like a regular variable.) 

In an effort to answer my own question (and help remove a potential zombie) I did some self-improvement: Obviously functional languages prefer matching to conditionals, so I rewrote as follows: 

throws a gray-flag for me. Perhaps you should consider injecting the into the ? It seems to have an awful dependence on certain specifics, that can be abstracted away. Another suggestion, would be to consider generics for it, considering you also depend on as well. The ideal solution would be an interface that you depend on, regardless of the implementation. You could provide a default implementation, or allow the additional assemblies to provide their own. Likewise, the use of tends to lend way to some particular properties, for example, the behavior between assemblies can be different. This is particularly foul. You should consider either marking the methods , or marking them . Depending on what you have access to, you should consider interfaces/generics again to allow for the to vary a little between assemblies. By restricting the implementation to , you also restrict it to only those DB types that supports. (If it only supports MSSQL, then you'll need an MSSQL server for each-and-every other project you use this in.) 

Never omit braces from statements, and never one-line them. Adding braces won't prevent bugs, but it will help prevent bugs. 

Regarding the , I would consider moving a lot of that method to inside , as a method. Or at least this bit: 

Pretty simple, and definitely keeps things more functional. In the same respect, I did all the other boolean statements the same way. The only weird one was the one in : 

We also used as may not guarantee what we want. Now, I can see why you wrote it the way you did, but we'll fix that. You can modify and to work relative to the end of the stack. 

Lastly, different users' may have their week start on a different day. We want to accommodate for that, so we'll create a new default parameter for that. 

This method runs in \$O(\log n)\$ time, which is entirely necessary as I need to be able to call it frequently, and have many concurrent sessions running. I used for the index tracking because I absolutely need to be able to use this with astronomically huge values. This, again, threw a monkey-wrench into my original design, but the new one seems to perform well for large arrays, quite likely because of the \$O(\log n)\$ nature. (Do note that the \$n\$ in all cases is the total element count.) I have a few test cases written into a console application, I added a to the actual method to prove to myself it was \$O(\log n)\$ which have all succeeded, so the following code works as a decent test: 

If you're not an Excel whiz, here's what's happening: The function in a formula will do a lookup on the first value in a column that matches a specific location. So, will return the value in . Simple enough. Next, is a function that will find the first value in a column that is less than, equal to or greater than the provided value. So will find the index of the cell that is the last cell found which is less than (the final parameter) our current cell. So from our column, for it finds , etc. It then returns the row that cell is on, which can be piped to to find the actual value in that cell (or a different column). So when we put it together, assuming is 100000, we're replacing our formula with: 

As far as security goes - maybe. I'm not a security expert, but I would be wary of having no input validation here. At the very least, do not allow input with a semicolon (), as that can totally mess with your connection string. 

One note I think you should have: I'm not sure if you realize or not, but doesn't stop the underlying value of the field from changing. It stops assignments from affecting it. What I mean is, the following is perfectly valid: 

So now we should see that the majority of your code can be rewritten as a tail-call recursive function. We see the relationship between state and tail-call recursion, it's easy enough to write for such. I've blogged about this topic before, so I'm not going to go into too much detail, but the idea is to identify the following: 

First: that should be a , it doesn't need to be a ( members cannot be ) but it should be a . Right now anyone can reassign it. It should also be a member since it's not used outside your class. As far as naming, usually C# avoids but personally I use that casing type so that when I am looking at a name I know immediately that it's a constant. Generally members follow the same naming convention as normal: and are and is . We have three casts here (yes, I did say three). The first two are obvious, casting to . The third is an implicit cast from to in the condition . Yes, that is a cast. What can we do to fix this? First, since has to fit within the range of an index of an array (which is always an ), then we can just either change the type of to , or create a local variable which is an version of it. Next, We want to eliminate that cast we do twice, but how? There are two methods: create a new local variable that is a and manage it in the loop, or create a cast of one time in the loop. 

I didn't implement all the overloads of the method (yet) or the variants of them. This can literally be used in the exact same manner as the .NET , or you can use or instead of , and you can implicitly convert it to a . 

So that's more than one, but that's fine, we need to finish our analysis to make appropriate decisions on what to do next. Let's look at : 

Essentially, the collection can still be modified after instantiation, it just cannot be set directly. Instead of exposing as a , expose it as an . This prevents any accidental or method calls. You can still directly assign a to an , so no other code has to change. (Isn't .NET magical?) 

As best I can tell (with the limited info available on the language), it looks like you're violating just a couple language concerns. First: all example SNOBOL4 code I've seen has the lines without labels indented past the horizontal extent of the longest label by at least 2 spaces. That is: 

Of course, we can take one more step to cleaning this up by using a : Take our method (second one) from above and rewrite it as follows: 

The rest of it looks great. I won't comment on the algorithm, because I'm not an algorithms person, and it looks like it does what it wants. What I'm even more interested in is the fact that you wrote this algorithm so clearly that it's easy to follow and read. Personally, I think more people should take that page out of this playbook and write code for clarity first, then deal with whatever issues may arise. 

So we're immediately casting to to allow the type-system to make it's next move. Since doesn't implement we can't enumerate each item as an : we have to enumerate as an . Then we on the type: says "Is a type?" If it's a yes, then we return which is the node casted as , if not we return a . Of course this means on the client-side we would have to test for or , which we don't want to do. So we'll also build a which will cast to and remove the entires. A naive implementation could look as follows: 

That will print , not only proving that this method works, but also proving, I think, your original design was flawed. How do you create an empty object if the only constructor for it requires a Byte-Array? 

Let's talk about two major things in this: building a modular API, and Unit Testing. This can be easily unit tested, you should have 7 tests, one for a date in each day of the week. Let's pick a Week (past, present or future, doesn't matter), for this I'm going to pick an easy week. Since is the first day of your week, we'll pick the first week of a month that starts on a Monday. Scrolling backwards in my calendar I found August, 2016. August 1st, 2016 is a Monday, so we'll test that week. The problem right now with your code is that it cannot be tested. You have to reset the system clock to test it. This is not a hard problem to fix. We'll redefine the API a little bit (add a default parameter, basically): 

In that case you should not be using the local constants, they only create overhead on the stack, they're not used more than once, and they're not cached, so in reality they provide no additional value. 

Advantages? Your code doesn't need modified, at all, to add support for a new type. Simply add the type, define , and if necessary. Downsides? Calling it frequently can become expensive, it would not be difficult to build a cache to hold all the queries and select the relevant one from, so that if you call it would return the result from the cache. Now the point we're at is great if you only need select queries, if you need more than that we hit a slight issue in that we have a lot of code to reproduce to build a new query. Now there is a fix for that. 

I gave and a only to prove a point, because my serialization mock is pretty lame and I didn't want to build actual serialization as it doesn't matter: 

You're using the stack backwards. Not only that, but it's not a true stack. (Which is fine, we'll talk about that now.) A true stack cannot have elements directly modified. In a stack there's no sense of an "index", elements go in the top and come out the top. With that said, the easiest way to fix that is to rename this from to . (Now the name is more meaningful - first-in-last-out list.) It's far more performant to insert items at the end and then remove them from the end. 

This should help maintainability in the future. Yes, things are much more verbosely named, but variable/parameter/method name lengths only affect compilation performance, not run-time. Qualifying Names I would also consider fully-qualifying the names of the member variables of the class. I.e. instead of . Yes, it makes it much more verbose again, but it's also clearly expressing exactly where things are coming from. The idea is to be able to skim the code and know it immediately. (Not that you can't do that with the original, but it does remove ambiguities.) If we make that last change as well, we end up with: 

The only suggestion I would make is to extract each culture's tests to it's own unit tests. Each unit test should be testing one aspect of your code, whereas yours are each testing at least two. Point 1: the only two overloads you need are and . Everything else is just noise. Point 2: you should not be adding composites like that, at all. It's just noise. If you really need that info to be passable to the call, then you should consider a third and fourth overload: , and . Point 3: I don't know enough about C# to be able to answer that exactly, but I would assume you should be using the literal space everywhere, or the everywhere. Pick one or the other, but don't mix-and-match. Your unit tests have good content, but they need better names: