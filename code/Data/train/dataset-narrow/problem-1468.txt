Load the value - all the threads will see the same value, e.g. 3 Do the math = decrement - all the threads will calculate 2 Store the value back - 2, but the result should be 0 if three threads were removing their callbacks! 

First of all, you should use instead of and please don't use for template parameters ( is mostly for preprocessor, sometimes used for constants and/or static variables), rather use , e.g. . Your implementation looks good to me otherwise, but you know it can only be used with containers with member . If you want to create it from , then it would be something different (e.g. ). You may find some inspiration in . 

I don't know the book but have personally written few parsers, compilers and virtual machines, so, I will answer from this perspective. AST v.s. eval() I do not fully understand why you have selected mathematical representation of numbers which can be found in set-theory. There is one element to be known - zero (or empty set) and a construct to create another - succ(zero) (e.g. set containing one element - the previous set). In classical numerical evaluation, you would have some type containing the numeric value. and would then access the value and add/substract one (increase or decrease). With your cunnert design, , but does not know , it only knows or . This way you either have to make somehow public (e.g. by public getter) or have to use the friending as you did. C++ features used It is safe to use but it would be better to have some constants and actually share them! The examle would be - looks like good attempt to share, but you'll need to make it working (trully sharing one instance, not creating new ones). But you will also need static versions and probably hide the constructor (to ensure, there is only one and only one , not multiple). The can be replaced by 

Are there any other reasons for using the -syntax without filtering, selecting or ordering that I might have missed? Which syntax is better and why? 

In response to your latest edits: I think that your method is quite short, concise and easy to read. Maybe the length of the if-conditions make you think it is ugly, but there is not much you can do about it. One important remark: in the variable should never be null, or you'll get a later on, somewhere else. I therefore strongly recommend that you throw a in the switch case and remove the from the line . Two reasons: if you ever add a new enum member to and you forget to add the appropriate to the switch, you'll get an exception right there in your switch instead of in some other method (e.g. ). If you then do add the case but forget to set the variable to something valid, you'll get a compiler error stating that might be used while it has not been assigned a value. This way you ensure that is never null and that your switch covers all cases. Further, on more personal preferences: I'd rename to something like . The fact that it is conditional is an implementation detail: you might later on change how the formatting is done and this should not require you to change the name of the method. And it formats only one row, so use singular instead of . You could also rename to just as that's what it does. Lastly, your method does not care about or , yet is asks for them. Your method cares about so that's what I would put in the parameters. This also makes your testing easier, as you can just put a single value in the method and see how it works. The conversion from and to an enumeration member may then be done somewhere else, and tested separately. 

The original code needed more than 8.8s on my old PC, but the current version needs only 0.11s. Full code: 

Not much left to review Your and looks like helpers that should in my opinion be , have a bit different names (already pointed out in other review) and there could possibly be non-static members taking no parametr for this. A bit about the design, you have mentioned: 

Interface Enhancement The is not enough for algorithmization. A way to call some (templated/universal) function (functor) is needed. For now, this was added: 

You should pass to your and terminate it, once you reach zero oxigen. Big map with low can cause TLE. You don't need the , you can reuse the array and just mark visited spots (e.g. with '*'). This would be wave algorithm (handle all nodes in the queue at the start of the step, reduce counter and proceed to next step, unless or zero reached). This is simplification of Dijkstra algorithm for graph with all weights=1. Your code is hard to read. You are on Code Review! You are using C++ but program like in old C. Use instead of when possible, avoid super-shortcuts like and , please. 

Concentrating on the method, I see three times so that is something I would move to a common place. In fact, only its last argument -- lets call it -- changes. The initial value for is actually the default for when the two -statements don't fire. So I would put that initial value as an to that -statement. Last but not least: accounts for most of the clutter. By specifying an alias ( at the top) it conveys more meaning and makes it all more readable. The end result would be like this: 

In regards to the switch-statement: essentially there are four ways to accomplish what you want to do: as a switch-statement, as multiple if-statements, using inheritance, or as an index into a delegate array of functions. Multiple if-statements are probably uglier in this case than a switch-statement, and inheritance would require a complete rewrite of the Urgency enum to a class hierarchy. The index into a delegate array of functions would look like this: 

After some tests (adding more time-points), we can find that the double for-loop used to find all abundant numbers is the slowest. Now we can think about speeding it up, by shortening the inner loop. We start with and try every number we find can divide upto . We immediatelly know that the product will of course divide the number as well, but need to take special care for numbers of the form . 

Normal Class (not static) Read-only (getters and reaonly collections) Tiny objects if you really need to change the index - create helper class that can access the collections and return the indexed value. 

Your code will work, but you are using events in a way they should not be used. Once they are public, they are for signing and unsigning as per user of the class (those that start the operation), not to be unsigned by the class (controller). If you still for whatever reason need to preserve the class (and its state) and call the action once, it should be a parameter of the start method: 

However, I would not recommend it. It is very likely that it severly reduces performance. There is just not much you can do about the switch statement and I would not mind seeing it there where it is now. But an alternative might be to move the switch statement altogether into another method, with the added benefit that it is possible to early out of the switch. 

He said that while is an field, this is the way it is supposed to be written in Linq, and everyone does it this way. It also allows one to add -clauses later on easily. On the other hand, Reflector shows that a new delegate is created that is passed to the function on the observable, but that function always returns just , so it seems to me it also has a slight overhead. So I don't agree with him and would have written it as follows: 

That looks like you plan to derive from while providing and in the constructor and overriding which should therefore be . Did I get it right? Await Response Unfortunatelly, I am forced to use .NET 3.5 and therefore don't understand / that much (use threads and events instead). I hope that some override in your or casting the result to appropriate type (as the original returns , not or ) will solve the problem with type and later usage: . What I don't like is the active waiting (or it at least seems to be active waiting): 

Hacky ways vs. BOARD_SIZE It appears that you have board of size 3x3 and never tested with bigger board, because this won't work for bigger board: 

First to note, your code seems to work and the code-style is OK. There is not much to review :) ...but still: Using the not to write reallocation (growing) yourself is fine, but the is unnecessary, as all the time, it is redundant. will throw IndexOutOfRangeException if the queue is empty. It would be better to check and throw InvalidOperationException instead.