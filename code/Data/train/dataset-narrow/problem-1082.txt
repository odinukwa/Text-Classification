Now you can safely put in your query. Suppose an attacker sent in a dangerous parameter as the such as The code below would transform these ids from the dangerous: 

In my own work, I put such functions in the class which can in turn call with the right parameters. It still meets your requirement that only the class interacts directly with the DB engine. The class has no information about other objects. It just executes queries and returns results. The core of my class is similar to: 

You are executing DB queries in a loop: . This means that for 4,000 urls, you will query the DB 4,000 times (assuming no unrecoverable error). This is expensive and will slow your script down considerably and lead to a lot of overhead. You're better off building and storing all the commands you will want to execute in an array. Once you've finished your cURL operations, the array into one big operations (look up how to insert multiple records with one query). The docs for mysql_query show that the default behavior is to store results in memory. I suspect that because you make so many queries without closing the connection, your memory is filling up (I'm unsure though since almost all your queries are rather than ). I suggest you change that behavior by passing a as the 3rd argument. This means that after you've processed the result with your script you must execute before making the next query. This has less to do with performance and more with maintainability and scalability; consider breaking out the functionality into several single purpose functions: could return your array, could make the cURL requests and add to the , and arrays (notice I passed them by reference). You would iterate over that function, re-inserting the again urls at the back of the line until you have processed all urls into just and array. Next, would implode all results into one big operation and a single request to the DB 

You probably shouldn't be doing the work in this script. I'd have a or class that does nothing except receive the request, figure out what it's about and forward it to the appropriate service. I'd have one service for each task: add to conversation, send survey, unsubscribe... Because email addresses are case insensitive, I would make sure that all checks are case insensitive. 

It's great that you use prepared statements to prevent SQL Injection, but this code is evidence that you're storing the passwords in clear text, without hashing. This means that if your database gets stolen, the thief will know your users' credentials, and can use them to impersonate the users on other services. It also means that anyone with access to the database can do the same thing. Instead, when a user registers, hash the password before saving it. 

From what you posted, I cannot tell whether you're sanitizing the data before saving it to the database. Hopefully you're not just inserting strings you received from the client into your DB queries (this would expose you to SQL Injection attacks), but are instead using parameterized queries. How do you handle a query not returning any result? For instance when I look at , you call on your results without checking whether there is such a result. I'm not familiar with Laravel so maybe it handles this for you? Be sure to test how your script handles getting a non-existent resource. In your class, you create a new instance of every time a method is called. This is a waste because you will have a lot of parallel connections to your database that you never close and all those objects must be kept in memory. A better approach would be to instantiate a in the constructor of , assign it to a class variable, and use it for all DB queries. Then in the function of , disconnect from the DB. 

You should rewrite your code to access the DB as few times as possible. Reading from the DB is an expensive operation, because it requires PHP to connect to DB, send execution instructions, wait for results, parse results and make them available to your script. Notice for instance that in , your prepared and are identical. You're forcing your DB server to do the exact same work multiple times ( is executed in a loop). Why not call once and just bind different parameters to it before executing? Better yet, can you compile all the s you need and make the query once? Start to think in this manner to reduce DB queries. When you access the DB on every iteration of a loop, you're really paying a heavy price. For instance in , you execute a query to retrieve all the data for a particular , then for each result you execute another query to count the rows in table that belong to this follower. Look around resources/forums to figure out how to do this in one query that will return . Trust me, it can be done (hint: look into SQL operations). Only select the data you need. For instance, instead of in , if all you care about is the so you can match it against the same ID in table, then use . The bigger your result set, the more memory your script will use. NEVER sort if you don't need to. Sorting is really expensive. If you only care about the number of results (in ), why are you sorting the results with ? Imagine if your boss asked you to sort all the words in this post alphabetically and report how many words there are. I bet you won't bother to sort the words; you'll just count them and report the total. Sorting is hard work. 

Have only one class directly interact with your database. It doesn't make sense for your class and it definitely doesn't make sense for your to be executing methods. Think of what a nightmare it would be if you decided to change database drivers to or the next greatest thing? You would have to go into all your classes and even your regular scripts to make adjustments! A much better approach is to interact with the DB only from your class. Put the generic there. As much as you can, avoid writing queries in your general scripts (such as ). Instead, craft them within methods that live in the class you want info from; methods such as and would make sense. The reasoning is the same as for my last advice; if in the future you decide to change your DB table structure, or use a different storage mechanism altogether (not MySQL), it would really suck to have to go into all your scripts to change your queries. It would be much easier if your queries are concentrated in a few methods I don't understand why you didn't combined the two lines below... 

This should give you an array of rows, each row would have holding the number of days between today and last seen day, and holding the number of records that were grouped into that row. The result set is also ordered with the fewest inactive days first. Your PHP script could then use that result as needed. If you fetch the array and call it , you could do 

Hint: If you find yourself doing something over and over and over, you probably need a loop. Since this is a login form and that you expect just 1 variable besides the password, don't have so many vars in your script: , , , , , , ... just use . If you really need to cycle through all possibilities build an array and loop until you find the one the user submitted: 

There is a logic error here. Remember that the is evaluated at the end of the loop. So on first pass which means and are undefined. Change to This may not matter to your requirements since you use only with flattened arrays above, but it will return a false negative if you use it with arrays that contain non immutable members. Eg: 

Notice that this is a singleton . There can never be more than one object in memory. This is to ensure that all your scripts are storing and retrieving data to and from the same cache. You would use the static method to grab a reference to the cache. Since the method is static, you call it on the class itself (). Once you have this in place, when you need a value that may be cached, you check for it in the cache first. For instance, suppose you previously saved the sport type data under cache key "sportsType_123". In your controller's function, change your code from: 

By the way, this logic should be moved to a function that returns TRUE if the user is logged in, false otherwise. You can extend it with further checks. For instance you could record the IP address to which the session was granted, and if it doesn't match the IP of the request, deny access (to protect against an attacker stealing the session and CSRF token and trying to re-use it from another location). In login.php you have: 

This will turn into . Unlike the other answer, this function supports spaces in attribute value and I have casted the value into a numeric type when it's really a number rather than a string 

Since this is the backend to a login request, I assume that you expect just 2 inputs, the password and one of the others. So why not use the following: 

At the start of each function, I set to null. If there is an error, I fill with the details. So the consuming code can check this variable after executing a query to check for errors: 

In general my approach to finding the culprit would be to then comment out individual steps of the operation and run the script, watching the memory usage. Eventually you'll pinpoint the memory hog. 

Then when a user logs in, you verify the submitted password against the hashed password. Do something like: 

I didn't give feedback on the logic because the other answers covered it well. The things that struck me the most were: 

You take the existence of a cookie as proof that the user is logged in. Nooooo! Anyone can send any cookie named anything to any site. There are a few good alternatives, but at a minimum your solution must ensure whatever you get from the user (eg: cookie, token) is vetted before you do anything else. You insert what the user provided directly in your MySQL queries. This is death if anybody wants to hurt you. Never trust content supplied by the browser as safe even if you wrote the website/client application. Look up and use parameterized queries. You use really weak hashing of your passwords. This is too easy to break. Use PHP's built in functions and You were smart enough to get started and build a working program, and insightful enough to hash your passwords and to realize that you probably missed some things. You'll be alright :-) 

Because browsers send cookies automatically with every request, the user's cookie will be sent to when the browser tries to load the image, and your script will treat the request as legitimate, therefore it will act on . To fix, set a token in your response headers when the user logs in, and expect the same token back from the request headers from legitimate requests. The two points above lead to a modification of . When the user logs in, you now do something like: 

Will cause the new lines and blank spaces between PHP blocks to be echoed to the browser. Since this is not your intent, it can result in unintended and difficult to fix problems. Change to: 

Unless I'm missing something, your and can be used for other operations as well, because you don't actually check that the queries are or respectively. In fact you call when the consuming code calls or so why have all these functions? In and , you accept an argument () that you don't use. Why? 

I recommend a separate class that handles storing and retrieving from the cache. The argument for a separate class is simple: you want each class to have a narrow purpose. If you choose a particular cache driver/server today, but change your mind in a year, you should be able to change just one class -- the one that interacts with the driver -- to update your code. Start with this basic framework for a class: 

Then you can attempt to create the token with those credentials. Beware I've never used Laravel, but I wrote my answer after going over this helpful page on how to access requests. Quick sidenote: I notice that you have a check that can be true only if email has length < 6, and another that can be true only if email has length > 6. What if email has length===6 ? 

Be sure to test! I may have a bug in my code, but you get the gist. If you find a bug, leave a comment asking me to fix it. Don't do anything you don't understand. Take the time to learn what each line of code does, so you can get better, catch errors and even improve upon it. If the order of the results doesn't matter to your logic, don't use the clause; sorting is computationally expensive and should only be used when needed 

You're right, you should avoid querying in a loop as much as you can. If were 30, I would run a query like: 

It assumes that the existence of in the session is proof of authenticity. If your user doesn't log out, anyone who uses his browser much later to come to your site will be admitted; likewise anyone who logs HTTP requests and later looks at the log will find the session cookie and can impersonate the user. To fix, store a date in the session when the user logs in. Then when you check for credentials, you only admit the user if the login validity has not expired. Your site is vulnerable to Cross-Site Request Forgery (CSRF). Suppose your logged-in user visits my website where I have something like: 

Your intuition that your script is inefficient is right, so you have good instincts. Don't worry: once you're done optimizing you'll be amazed at the difference. 

You're still vulnerable to SQL Injection. Take another look at . This function receives the parameter, sends its contents to the server which in turn puts it straight into an SQL query as the cat IDs: 

For the same reason, do not close the PHP tag at the end of the file unless you're trying to send more content to the browser. In for example, it makes sense to have the closing tag because you need to send the HTML template below it to the browser. But the end of and should not have since you're not trying to send more blank space to the browser. 

Remember that server code should never trust incoming data as safe, even if you wrote the front end (website) code. If I wanted to inject SQL into your queries, I would go on your website and watch what legitimate HTTP requests look like. Once I know the URL and parameters sent by your AJAX call, I would craft my custom request but replace the valid cat IDs with SQL. I don't even need to use your website to make these requests to your server so good website code does not protect you. Addendum One simple fix: in ; if your DB field holds integers, use: