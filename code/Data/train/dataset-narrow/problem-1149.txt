Code Style Whitespace Put spaces around your assignments and comparisons: is harder to read than . Also, be consistent. Sometimes you do this already, but most of the time you do not. Braces You have nested loops, but only the inner loop has braces. Both loops should have braces surrounding the body for consistency. Precondition Checking Although it is good that you leave comments indicating the data types you expect from and , it is better to verify this in code. Adding assertions about these conditions makes it easier to debug if a wrong parameter is passed: 

Algorithm Now that your function has been simplified a bit, it is easier to see that you have written a naive pattern match, which has complexity \$\mathcal{O}(mn)\$, where m is your pattern length, and n is the string length. You can improve upon this by implementing one of the well-known pattern-matching algorithms, like Boyer-Moore or Knuth-Morris-Pratt. I leave this as an exercise to you, both because it would make this answer too long, and it would be a good candidate for another question on Code Review. 

Before critiquing your code, I'd like to compliment you. In general I found your code readable and appreciated that you've broken things into short functions, and your variables were well-named. Do you really need ? Unless you have a compelling reason to use , you should probably stick to . will be better for data locality, and offers random-access iterators. That means that your can be made to erase items without needing to traverse any of the data structure. I would expect switching away from to improve performance. Don't use In a few places you use dynamic allocation with and return a pointer to an object. This creates a burden on the programmer to make sure is called appropriately, and is not exception safe. Prefer instead to return by value. The object copies can be elided by the compiler. Don't use arrays C-style arrays generally aren't the best data structure for, well, anything. They don't know their own size, and decay to pointers when used as function arguments. At the very least, use instead. correctness Declare variables wherever you can. This lets the compiler guarantee that variables that aren't supposed to change, can't change. Less moving parts makes your code easier to reason about. Too much This may be open to some debate, but I think you use too much. Sometimes you initialize a container like this: 

Algorithm You enumerate within a loop also enumerating . This means your algorithm is quadratic in the length of each sentence, which is bad. I think you can improve your algorithm to make only a single pass over by creating a which stores unique words as keys, and lists of word indices as the values. Then you can lookup the appropriate indices of the items in your wordlists and perform the distance calculation. Since lookups are a constant-time operation, this reduces the complexity to linear in the length of each sentence. Do note that the algorithm is still quadratic in the length of your word lists, so there may be some improvement to be had if your word lists are long. Correctness and Edge Cases It's hard to tell exactly what this code is supposed to do, so I will be making a few assumptions. The handling of edge cases will vary depending on the requirements. You likely have at least one bug in your code, which is reflected in your example output: you check , which will evaluate for the string in the word . If this is not the desired behavior, you may want a stricter check like checking equality , or something based on Levenshtein distance for a less strict evaluation. Another possible bug is that you never include the first word of a sentence in your results. Your check will be for every word whose index is . Code Style Holy indentation, Batman! Deeply nested code is hard to read and understand, and usually indicates you can organize your code better. Usually the inner loops can be brought into their own function. You can sometimes reduce nesting by consolidating conditional statements. For example, an statement immediately followed by another with no can be brought onto one line: 

Output arguments You currently use a pointer for your output argument. While this is a matter of preference, I found it confusing considering the other pointer argument indicates an array. I would use a reference for instead of a pointer. -correctness and immutability In a pointer-math-heavy function like this, it is especially important to document which values can and cannot be changed within the function body. Use to specify that a value is not mutable. This allows the compiler to do more error-checking, and makes the code easier to reason about. Most of your function parameters aren't modified inside the function, so they can be marked . Note especially , which has two modifiers, indicating its value cannot be changed, nor can the data it points to. Also, is only mutated when it is clamped to zero. You can rewrite this using (from the header) to put the initialization on one line, and then make it as well. Note that using requires be a signed type, otherwise there will be overflow errors. An improved beginning of your function would look like this: 

Use when you can Both and do not change during the function evaluation. They can be declared as to allow the compiler to perform checks that they are never accidentally modified. Additionally, you can reduce the scope of by declaring it inside each of the loops. Then it too can be made : 

This consumes more memory than a hand-rolled loop because needs to be filled with values. If memory is constrained, the calls to and can be replaced with a hand-written loop. 

Magic numbers I don't know what is supposed to represent, and neither will anyone else who doesn't intimately understand the algorithm. It would be better to assign it to a named constant. Something like 

I have written an adapter class that allows iteration over the rows of a object from OpenCV. For those interested, here is the Mat documentation, but the salient points are as follows: 

Naming uses Hungarian notation. Please don't do this. Instead, try to come up with a more descriptive name, or just leave off the prefix. 

Coding Style Limit variable scope It is best to limit the scope of your variables to the smallest scope possible. You aren't writing C89, so you don't need to declare variables at the top of the function. Naming Be sure to give descriptive names to variables and function parameters. is not descriptive. Also, it's good to denote separation between words in names. is hard to read. You should pick either or for variable names and be consistent. Use where you can If a variable is not supposed to be modified, it should be marked . The compiler can then verify that the variable is never changed. Both and should be marked . Algorithm Inspired by Schism's linear-time solution, there are several opportunities to replace hand-written loops with standard algorithms. These make the code easier to read and reason about. My implementation follows: 

Reduce Variable Scope and are both declared outside their respective statement, but are not referenced outside of it. Declaring them inside the statement limits their scope to within the loop, reducing opportunities for them to be misused. You can also use for type deduction, saving you the necessity of typing long iterator type names. Reduce Nesting Your code contains many nested and statements. This can make the code hard to read. If you have an statement wrapping the entire loop body, you can reduce the level of nesting by inverting the condition and breaking early: