Another thing you'll probably want to do is make the player accelerate much more quickly toward zero than he accelerates beyond zero, otherwise your character will feel unresponsive. If you use something like this for forward/backward, and another variable for left/right, you'll have to limit the combined speed (bust out your geometry), otherwise your character will move diagonally-forward faster than he moves only-forward. 

I have a turn-based car simulation. My vehicles have a maximum speed they can travel in a round, as well as a maximum amount they can change their heading over the course of a round. Say, 20 meters and 45 degrees. Knowing the starting position of a car (x,y coordinates), and its starting heading (orientation), I want to find the end-of-round coordinates for the car turning its maximum amount and moving its maximum speed. (And values in-between, as well!) There has to be some simple math formula for this, but I haven't found it yet. I also happen to be working in Unity. 

This code (which needs optimizing) will give you the maximum height you can go according to the x and z coordinates of the camera. 

Perhaps you can have a class which contains read-only properties for each thing you want to perk. Then pass all the perks to your various classes in a whenever you need to. Inside the different classes of your game, you change each property that's relevant. 

Biggest mistake new independent developers make is aiming too high. Start making a really simple game engine, with extendability in mind, and slowly add things to it. Never go too long with an engine that doesn't run, and MAKE LOTS OF REGULAR BACKUPS. 

When the system enters your code again, your is reset, so any system time spent while your app was paused is automatically accounted for. 

Now the snake will only suicide if it runs into its tail and turns in the same direction the tail is "moving" (causing the snake to spiral until it runs out of space). This however will never happen if the snake makes sure to turn toward the direction it originally needed to, to get the current piece of food. Why? Because of where the previous piece of food was - the snake will only run into its tail if it has to double-back along the X or the Y to get the piece, so you can usually be assured the snake was previously moving in the opposite X or Y to get to the piece you just picked up. I believe this will break down if the snake has to double back for multiple pieces in a row, and the distance between all the multiple pieces happens to be shorter than the total length of the snake. But hey, you said "simple" and "relatively" well. 

With the sale question aside, yes. Using a tool you are familiar with is always a good choice. You should make a list of all the items that you are unsure whether RPG Maker can do. Post on their forum and ask if they are possible, you will then have a list of critical issues and what their resolution is. If one of these critical issues is a deal-breaker, re-think that portion of the project. It's better to know up-front than hit a critical issue in the middle of production. I encourage you to start and finish your project. At the end you will know better than anyone what the strong/weak points of RPG Maker are and whether or not you need a better tool and/or a programmer for the next project. Also you might have an easier time attracting a programmer if you point to a finished project for them to see you are serious. Considering selling on Steam. First you need to research RPG Maker and possibly contact them to see what their distribution license is - this will guide how you use their provided assets i.e. this faq. IMO, the payoff for the first project might simply be to finish it and attract more like-minded hobbyists (just from personal xp). 

In 3ds max, when you use the material on your model and change the the material doesn't actually have a texture, and so it doesn't use one even if you give it one later. Basically, here are the steps to make it work (sorry if you don't need such a specific list, but I'll make it usable by anyone): 

The model file contains data about materials, in this case it looks like the diffuse color or texture. When you create a new object it doesn't contain the right colors and such, so you get white. See here: $URL$ $URL$ If you want to use the same texture, you can do this (I haven't tested though): 

There's something weird about your concept of the issue since you say, "could potentially be moving at double speed in the reverse." This should not be the case with an acceleration-based solution. You will have a value in your Player class. To keep it simple for now, imagine just forward/backward velocity. Every frame, you add your acceleration value () to the player's velocity until it reaches a maximum - the speed at which you generally want the player to run (). This should only take a handful of frames unless you want the controls to feel very "floaty". (You don't for a modern FPS.) If the player reverses direction, you add negative acceleration. If they are moving forward at full speed and reverse direction, it will take them twice as long to get to "full speed reverse" than it does from standing still. If the player releases all buttons, you add acceleration towards zero. He will slow down until he stops. An implementation: 

I'd say you're on the right track, you might want to look at this article: $URL$ It explains some basic collision avoidance and path-finding using the A* algorithm. Edit: If you really only need what the best way of propelling your objects in the right direction is, then you should use a force (say, MovementForce or something) pointing in the direction of the best path you found using the path-finding algorithm of your choice 

Using this code, I get an exception because all of my s dispose for some reason. Is there a way to change the MultiSampling in the middle of the method? 

When you use in the class it only dispatches the mouse clicks that fall on the actual visual data inside that . If you use you can use the whole stage. 

for example. Then maybe later you can implement some kind of fake slowdown later if you get that far. 

Drawing bitmaps with the object is arguably much simpler than implementing OpenGL. However for anything intensive, you may find later the class won't cut it. Basically if you don't need to do any of the above, you should be able to get away with just using . 

You should make as many other elements rely on the deltaTime value as possible. This means, however, you can no longer assume frames of your game as a "fixed" time. Your enemies and bullets should have like a "speedPerSecond" value and each frame they move deltaTime's percentage of that distance. 

According to the book Real-Time Cinematography for Games, the fastest but least accurate way to do this is by calculating the projection of an object's bounding sphere onto the viewplane of the camera. r = f*r_w / (v . (p_w - q)) Where: f = focal length r_w = bounding sphere radius of the object v = normalized camera direction p_w = bounding center of object q = camera location . = dot product Finally, the area of the object on the screen space is: a = PI*r^2 Similarly you can project the 8 corners of the bounding box onto the screen plane and calculate the bounding box area. 

New piece of food shows up. Snake figures if it needs to go + or - X, and the same for Y. On the first turn snake starts heading to the food's X (by moving along the Y axis). If the snake encounters itself while moving Y, it makes a turn in the correct X direction (it remembered whether it needs to go +X or -X), and heads straight until it reaches a square and doesn't detect its tail to the side anymore. If it detects more body ahead, it turns to the free direction, continuing until it detects an opening to the side and can return back to its course. (It "wall hugs" its tail until the tail runs out and it can get back on course.) Once the snake reaches the correct X coordinate, it begins moving along the X to get to the correct Y coordinate. If the snake encounters itself while moving X, it makes a turn toward the Y direction it first remembered for this piece, and checks for open space similarly to the Y movement. 

Obviously this code can be optimized a lot as it becomes redundant after the first call. EDIT: Just to explain why the properties seem the same, once your code runs once the effects become the same, so if you're seeing anything but the first call the properties will be the same. 

As you said, billboarding a plasma sprite and using a bloom shader Creating a particle system and using a bloom shader (will look better than above, but takes more power) Both, which by looking at the picture, I'm inclined to believe is the method used in that game. It uses a main explosion sprite and then some particles with an additive bloom shader for sparks.