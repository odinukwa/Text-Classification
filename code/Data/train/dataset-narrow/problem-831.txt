Return a String instead of printing Instead of your method being make it return a and remove all the from it. Then from where you call instead do . This limits the side-effects of the method. For tiny programs this is not a big deal but in larger projects knowing exactly what a method will do is very handy -- especially if the method is what is known as a "pure function" which means it literally has no side effects and its output is directly dependent on its output. Consistent formatting In some places you have spaces before braces () and in others you don't (). It's less important whether or not you use them than how important it is to be consistent. Personally I put spaces before them. 

Note: I don't have much experience with the operator, if or something similar is valid I would prefer that instead of making the variable. DRY is still relevant though! While writing tests like this takes up more space I think it's more important that the test be clear. All that said I don't think DRY is completely useless in unit tests. Suppose you were doing more checks on , like making sure it's not , contains a specified number of elements, etc. I would put all those assertions in a separate method. Basically the assertions that are tangential to what you are testing. For example, you're not specifically testing the list has one element above, the assertion you care most about is that the only element is . You can't really do something like that so you have to assert that the first element is . Anyways, I tend to put these tangential assertions in methods like this: 

Specifics The below code is a little odd to me, it's saying in the th word in the th character, find each in the th character that is any of the vowels. 

If you throw a checked exception every single call of this method will need to be wrapped with . Checked exceptions are a pain to deal. If you throw an unchecked exception then you have the same problem of , maybe people don't realize it could happen. So they don't wrap it in a try-block. 

I don't like the use of here. If is null then it's fine (but I still don't like it). It seems better to throw a . In addition, if it actually was null it would throw a "real" at the first if statement. 

I am only going to talk about the sports method, from there you should be able to get the info you need for the others as they are all basically the same. DRY isn't a big priority As I said in my earlier comment, DRY (don't repeat yourself) principle applies to production code more than unit test code. I think even in general it's easy to take this too far, readability is important, but that's off-topic. Your code however is tough to grasp. To me, something like the below is more clear. I like to specify "given/when/then" in comments (although usually I do nothing more than , etc.) but it's not necessary. 

Just moving the constants out of the loop should gives you orders of magnitude speedup. If your is 1-dimension (i.e. just a number), then the last optimization I could find is to group the variables in long summations by 4's. For example, (a+b+c+d)+(e+f+g+h)+... instead of a+b+c+d+e+f+g+h+... The reason is due to a compiler inefficiency. Putting these parenthesis around can increase the speed of the code by a few times. A bit more fine-tuned of an optimization is to now reduce the temporaries. Anytime you have a vectorized operation like it stores the result in a temporary variable. So in the case where and all of the 's are vectors, there are a lot of temporaries that are allocated each step. First you can get rid of some by making an in-place function which takes in a and doesn't return the value, but instead writes it into . In the spot of the du you will put the k's. Once that's in-place, then you will want to de-vectorize all of the large summations. I created a Gist where I tested which is the fastest way to do this. The winner is to do the long-single loop with parenthesis grouping the terms by 4. You'd want to do that to every line of a's in the k = f lines, and you'd want to do that in the solution update part. You can re-use the same in every line because it's only used for one part, and thus you only need a few cache variables around for the whole approximation. The result of that optimization is an utter mess. Refer to the DifferentialEquations.jl source code again. However timings show that even for small vectors you can get about 1/3 faster. Then you can change those cache arrays to StaticArrays to probably get major speed gains (but require v0.5). So the resulting code is no simpler, but it's much faster! Note that DifferentialEquations.jl has these hand-unrolled devecotorized implementations of also the order 12 and 14 methods if you'd like to take a look. It gets quite tedious to do, but sometimes you have to do it if you want the most optimal code. 

I have optimized Feagin solvers in DifferentialEquations.jl. You can find the codes starting here. I know your question was about simplifying the code, but after really optimizing them, I believe that is the wrong direction (except for teaching purposes. For teaching, just put A in a sparse matrix, b,c as vectors, and go with it). The code needs to be almost fully unrolled for a few reasons. First of all, if you test static arrays/matrices for the coefficients of this size (via StaticArrays.jl, they are not good at staying stack allocated. The reason is because they are more larger than what you want to always keep on the stack. This is exacerbated by the fact that A is sparse (even in the lower triangular part that), and so using a full matrix would have large amounts of memory overhead. So you want to keep at least a as stand-alone variables. b and c are easily put into a StaticArray. That simplifies things a little bit. (I tested and it's the same as stand-alone variables. I haven't done this yet on master because it's only v0.5 and I want to keep v0.4 compatibility right now). But now towards optimization. As @MattB noted, the first thing is to deal with the constants. They should be moved outside of this inner function. Also you should take some pre-caution to make sure that all of the types match (to make the code more general. Maybe you will want to use ArbFloats for better performance?). To add this robustness, you just generate all of the constants inside another function, and you can parse them to a given type (inside that function, so that way in your main function they are always type to avoid type instabilities) with 

Method signature This may be an unpopular opinion, but I like not using in method signatures and instead using explicit types. It makes IDE suggestions and readability a lot better. 

I actually just looked this up writing the answer. You can use a method called on arrays in place of a closure. Documentation 

It's unlike Java where single quotes are for characters. One exception to this is when using the in Strings, you have to use double quotes for this. 

This is worse. This is like saying . If you're set on leaving some comments it'd be more beneficial to leave some in the other methods with more logic involved like the method. 

Everyone has commented about how to better replace the spaces, I will answer how to better test. I suggest making a proper unit test with Junit. This way you do not need to manually look at your output, you can simply run the test and it will tell you if it failed or passed. Unit testing is extremely crucial in a professional environment and is a very important skill to pick up early. (The below assumes your class is named .) 

The only reason I even include the manual throwing of is because I assume you do more stuff in the part, if you don't, remove it because it will do that on its own without you writing it in. 

Scope and `translated are only ever used in your for loop. It's important to limit the scope of variables as much as possible. So it's probably better to declare them in the loop like so 

My reasoning against returning is this: It is never 100% clear if a method will return or not in Java and maybe someone will think this won't so they won't guard against the null condition with . If you return an , it's an extremely clear signal that the content of the result may or may not be present. They still may handle it wrong but at least you can be more certain they know what's going on. My reasoning against throwing some exception when the book is not present is this: 

The commented out line is basically the same as the but it throws which to me is just more informative in this case than , but it's up to you which you prefer. 

I recommend this, but it's ugly. I'd like it better if the throwing was at the top, but it's a trivial change you can figure on your own (It makes sense for all preconditions to be at the top). 

A short suggestion because no one has suggested it yet. Instead of returning or throwing an exception when the book you are searching for isn't found, you should use . 

I know this is a small script but I am new-ish to writing Bash scripts and want to learn. The lines seem a little ugly, though they do work. Also I can't pass multiple commands in with a like because the ends the statement in the line, so I am wondering if there's a better way to write that line (or pass them in). 

This now has the magical special form of recursion that can be turned into a . Let's do so! See if you can spot where each piece of code from the above ends up in the below. 

The test for this one is a bit complicated; since the old implementation is partial, we have to restrict ourselves to those inputs that work. 

Actually, using and is also a code smell, for the same reason as the rest of the changes so far: is partial. Instead of protecting ourselves from calling on inputs it can't handle, we should write our code in a way that avoids partial functions. Here's how: 

Okay, let's check our work. We already know that the final thing works differently for negative numbers, so let's only check non-negative ones. 

As with waaaay back at the beginning, I find the choice of base case a bit odd. Let's try the trick from before of letting the "loop" run one more iteration (and this time hopefully the refactoring isn't wrong!). 

Now, as we all know, building up a linked list by repeatedly appending to the end is a bit inefficient. Probably for such small lists as you'll be using in test cases here it won't matter, but it's a good idea to get in the habit of paying attention to some of the easiest stuff, so let's try to improve this a bit. We have a choice here: either we can keep the interface of this function as-is, that is, always output a list in the right order, or we can choose to change the interface, and change all the call-sites of this function. I think for this case we can keep the interface. The idea we'll take is to build up the list backwards, then reverse it at the very end. The name is traditional for local workers. 

Whoa, whoops! Can you figure out which refactoring above was the culprit? =) Now we have to decide whether we like the old behavior better or the new one. I think in this particular case we should like the old behavior better, since the goal is to show a number, and we'd like to show up as rather than as . It's a bit ugly, but we can special-case it. Since we like our future selves, we'll leave ourselves a note about this, too. 

(I've added a little creative whitespace to show parallels between the branches.) The only thing I'd change now is to pick a better name. For example, might be an okay name for this. I'll mention one more thing, which is that this can also be implemented quite beautifully as a list comprehension: 

which we can use to index into our lookup table with the digits of our integer. So let's try to write this directly! Taking a cue from the final implementation of above, we can write 

It's common in cases like this where the trailing arguments to the function you're defining are also trailing arguments to a function in the definition to omit the arguments entirely. The technical term for this is , I think. Whether you choose to do this yourself is primarily a stylistic choice.