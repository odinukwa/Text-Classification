Regarding rule one, a mathematical relation by definition has unique tuples but when adapted for use in data management Codd added a key to serve as a unique identifier for each row as in the real world entity types are identified by one or more of their characteristics (attributes). Note there can by more than one candidate key so I just use the word key here. Regarding rule four, Codd initially intended that no column could contain a relational valued domain (RVD). It was later shown that RVDs do not violate the relational model and instead any domain of any complexity, including another relational variable, could be contained in the column of an R-Table so long as that column contained only one value. The table you have shown in the question and labeled as UNF format is not in 1NF as it violates a portion of the first rule - distinct rows - if I interpret the diagram correctly that Customer Number is the key based on the single underline under its name. There are three rows with customer number C002. Of the two tables shown which you believe to be in 1NF, the first is still not in 1NF as it still contains three rows with the same customer number C002. The second table is in 1NF as it has unique rows as defined by the key of customer number and item reference. Note that the original table does not require splitting to achieve normalization. Instead, the original table could be changed to have as its key customer number plus item reference and it would be in 1NF. 

For your first database class and first attempt at an ER Diagram (ERD) I think you have done a great job! I'd like to give you some feedback in the context of the process I use to break down a set of requirements like you were given and create a draft diagram. Hopefully by taking this approach I'll help you in your development of the skill of ER modeling and database design and not just give you an answer to a homework assignment. Find the Entities and Relationships The idea behind an ERD is to identify the entities - things of fundamental significance to the business - and how they are related. Thus the name Entity-Relationship Diagram. The goal at this point is not to design or implement a database but instead to develop a more structured understanding of the domain of interest on which a database will ultimately be based. A good way to get a start on finding the entities is to look for the nouns in the requirements and then pick out those which are persons, places, things, concepts, or events. Then, you can find most of the relationships by looking for the verbs that connect those nouns. Here is my first pass at finding entities and relationships in the requirements provided: 

shows Jones to be a designer on the Nile project but we know that is not the case. Let us assume instead the business model did say there were MVDs of and . In this case, what those MVDs mean is that if an employee plays a role, and if that role is on a project, by definition that employee plays that role on that project. In this example, that same EmpRoleProj table is now not in 5NF and now does suffer from redundancy. Now, the facts that Smith is a designer and there is a need for a designer on the Amazon project are stored redundantly as those facts could be inferred from joining Table 1 and Table 2! Likewise, taking the join of Table 1 and Table 2 now does not result in a spurious tuple as the inference that Jones is a designer on the Nile project is a fact now based upon the business rules defined by the MVDs. This is why you cannot assess the normal form of any R-table without knowing the dependencies and the defined key. Making any assumption, even one that seems to you to make sense, can be dangerous. If you are ever asked what normal form an R-Table is in, you must ask for the dependencies to assess. In addition to Fabian's series of papers, Chris Date's works provide the best information available on normalization theory. 

The term "relational" comes from mathematics and has nothing to do with relationships between entities. I'm not a mathematician (whereas Codd had a PhD in Mathematics) and so won't elaborate, but will point you to this wikipedia article on binary relations. The wikipedia entry on relation (databases) gives additional detail on how Codd adapted the mathematical concepts to apply to data management. As to why this mathematical structure is called a relation, I think it has to do with the idea that there is a "relationship" between the domains that make up the relation. The best source I know of to better understand Codd's original thinking is Fabian Pascal's Practical Database Foundations and Understanding the Real RDM series of papers. Chris Date has also written extensively on the RDM and his Third Manifesto site has a section listing papers and books. His book Relational Theory for Computing Professionals is a good introduction. I hope this helps. 

The simple approach to normalization is to create a table for each person, place, thing, concept, or event. By doing this, you have each characteristic of each person, place, thing, concept, or event of interest to you in one and only one place in the database. The benefit of data integrity is achieved for when you insert and update data. Because you have normalized you don't have redundant copies of the same characteristic in many places across the database, each with a different value, that you have to remember to update and keep in sync. Second, you have only one place in the database to program checks when inserting or updating data to make sure the data is valid. Since your data is coming in from many excel spreadsheets, normalizing your data gives you the opportunity to implement data integrity checks on the load to make sure you analysis is based on accurate data. The benefit of query flexibility is achieved for when you want to read and analyze the data. Because you have normalized the data you can connect up the tables in a flexible way based upon the question about the data you want answered, including only what you need to answer the specific question. Second, this enables the database to return the answers to your questions much faster than if it had to scan through all the data, including the data not relevant to your question, in your un-normalized tables . Access is a simplified DBMS and does include a basic SQL processor that allows you to write queries and thus take advantage of the benefits of normalized data. If you are eventually going to move to SQL Server, which is a full featured DBMS, then normalizing your data now will ease the transition and let you take advantage of the full capabilities of SQL Server and its very rich implementation of SQL. As I mentioned in the beginning, to achieve these benefits you must be willing to do the up front programming to translate the data coming in from your various excel dumps and map the rows and columns in those spreadsheets to your normalized tables. This is not a trivial exercise but doable using Access programming. One approach would be to create tables that replicate the data as in the source and load the data into them. These are known as stage tables. Once you have the un-normalized data in Access tables you can then more easily write access code using SQL to extract the data from those stage tables, normalize it, identify data quality issues (say the same characteristic in two different excel dumps that should have the same value but do not), and load it into your normalized tables. This is the common method for normalizing data coming from an un-normalized source very common in subject area based data warehouses. You will find this additional level of effort to be well worth it though once you have high quality, normalized data in your access database. You report consumers will see that you are a real data professional when you show them examples where data quality was poor and you discovered that fact so it can be corrected in the sources. Likewise, when they ask for a new report that analyzes the data in a very different way, you can rapidly create the new report using SQL to combine the data in the normalized tables in this very different way that wasn't originally anticipated. They will be very impressed that you are able to do this quickly and easily! I hope this helps explain why normalization would be of benefit to you.