Playing video with LibGDX has been defined as out of scope for the project. So no, you cannot play videos using LibGDX. This does not preclude the possibility of writing code specific to Android to play videos though. It just means your application won't maintain the portability of LibGDX. 

Where , , and define the corners, use them clockwise or counter-clockwise depending on the winding order of your graphics library. The right can be derived from the cross product or the look and the up vectors. 

Likely starting at a known connected point (like the bottom of your world) then doing a breadth first traversal of connected voxels would work pretty well. Make sure you're flagging voxels as connected while you go. You can do this per-chunk. Additionally, there are less expensive ways to minimize, but not completely remove the floating terrain. 

I still have a genuine interest in being able to teleport myself around. But I have my expectations based in reality. I think genuine interest is not what you should be gauging, but rather the expectations of the individuals. Weed out classes are a must for any engineering degree. Make it clear that it's not a bachelor of arts, but one of science. Calculus, linear algebra, physics, discrete mathematics and algorithms should all be early in the program. Additionally, implementing an exit survey should help you gather good information about why people are leaving and allow you to further refine your "marketing" of the course to future students. 

On the collision, simply reference the relative positions of the two objects. If the ball is above the block, it struck the top. You really only have to check the y coordinate if you're sure a collision is happening. Something like the following: 

Looks like you're wanting to draw an arc. An arc that's thick. I found this article for doing just that in AS3. Check out the demo at the bottom. 

This makes it so an animation speed of makes the animation behave just as before, where an animation speed of will cut the time per frame in half, therefore doubling the speed of the animation. 

If cube below has less water, flow down If adjacent cube on same level has less water, flow laterally. If cube above has less water AND source cube is higher than the cube above, flow up. 

These meshes will conform to the walkable areas in your game. You can make the nodes as small as you like. In this way, you can have far fewer nodes for your A* algorithm to work on. You can still have smaller nodes if you like for fine detail pathing, or you can use something like steering to get between nodes. If you'd still like to do your idea of a larger grid and a smaller grid, that's fine too. The larger nodes would just be made up of multiple smaller walkable nodes. There's no reason to make the larger nodes include non-walkable areas. I think what you'd eventually end up with is something like the navigation mesh above. 

Most any top down perspective will work. 2D games have done this in the past with games like PacMan: 

Depends on the game and the people making it. There are common sources for nearly any product being created, games aren't that different, but the below are tailored slightly more towards games: 

As for the X and Y, you'll need to maintain two values if you want them to always correspond to the top left. Something like . 

I imagine that since the only thing you're changing is then you're likely not instantiating your variable. I imagine your error is something to do with a null value? 

You'll find some optimizations for other collision detection strategies work here too. For example, first finding your min/max values and creating a proper bounding box. Then you can just check if the two bounding boxes overlap before doing anything. 

Create a circle of vertices around the unit, with the unit at the center. The radius of the circle is the maximum movement distance. The density of the vertices can change depending how detailed you want the final result to be. For each vertex position, simulate the movement of the unit steering towards that position. This is done in a tight loop without rendering. When the maximum distance is reached in the steering simulation, move the vertex to the point of the simulated unit. This point is the closest the unit could get to that vertex before the current turn was over. This has the effect of shrinking the circle to the size of actual movement. Use those vertices, along with a vertex centered on the unit to create a rendered circle to draw the possible movement distances. 

The best results I've seen for this when a mesh is decimated. Decimating the mesh attempts to reduce the polygon count with minimal shape changes. The decimated meshes retain their shapes fairly well and this would be ideal for non-organic structures like buildings. Though it even works on organic structures as you can see here: 

For my system I use an class. This takes care of common entity tasks, like tracking available entity IDs, reusing removed entities to save allocations, creating/deleting entities, adding/removing entity attributes and so on. However, there are more specialized classes for different tasks. There's a manager that has functionality like finding entities within an AABB, within a range of a specific point and other functionality having to do with location. Then there's a manager that knows the relationships between entity types. It can be queried for the threats between two entities. There are also functions that utilize the manager to find all entities that are a threat to an entity. Basically what I'm saying is, it's up to you. Split out the functionality into basic/simple logical classes. Then combine the simple functionality into more complex functions. Where to place the more complex functionality depends on what's going to use it and how it's going to be used. This could be as simple as a large class that contains and combines all the functions you want for your entities. You can create a filter system for these functions. Where each simple function has a filter that describes the required components for an entity to be queried. For the more complex functions, these filters are combined to filter all the entities that don't have each of the required components to be passed into the functions. This would likely be something like a , with a bit for each required component. 

You are incrementing , and you want to go from frame 5 to frame 9 right? That's how you do it. I should also note that you should really try to avoid the use of constants like that in your code. For starters you should pull them out and put them at the top of your code with nice names. 

Additionally, you should probably be checking bounds when moving. So check that your character's position + movement amount is withing world bounds, before moving. 

You make the model however it needs to be made to appear correctly and/or animate correctly. The collision shape does not need to be the same as the model and the collision shape can be a combination of multiple different shapes. If the inside of the cube is to be collided with, you can create collision shapes that just occupy the solid parts of the model, in this case, you would create rectangles that represent each of the walls. 

Yes, you should try implementing it the way you suggest. Another way would be to create the animated ray in an art program. Export it to a sprite sheet and just use a textured quad to display the animation where you need it. That would be very efficient. 

Compare the object's heading with the normal of the collision edge. If they are perpendicular, proceed with normal collision response. If the angle between the normal of the collision edge and heading are off perpendicular by some amount (20 degrees? It'll take some testing), allow the object to pass through the collision edge. These special edges would be at the left side of the loop and the bottom. 

Box2D is very popular and well documented with lots of examples. Of course it's a full on physics library so it'll give you a good amount of flexibility for expanding later if you want. But you don't need to use those features if you don't want them. For learning more about the algorithms and how to implement them yourself you can check this out. Additionally this is a nice resource for showing how to detect intersections between various shapes. Which plays an important role in collision detection. 

Using this method there are some situations you'll have to make special cases for, like three planes vertically aligned: 

Essentially your main problem is that you're not rotating correctly. Which is leading to other issues. When rotating I find it's easier to use the version of that takes an axis to rotate around, and the number of degrees to rotate. So: 

Notice the type of collision is the correct way to implement this method, in addition to the capital at the beginning. I started a new scene. Added two 2D sprites. I added colliders to both. I then added a rigid body to one and attached a new script to the other. The script contained your code above for . When I moved the rigidbody object over the other object, the debug text was printed. You either need to start over because you've done something wrong or you need to reexamine your assumptions. 

Is it only with the tap response that the force is not applied? If you were to just apply a force in the update loop, without conditions, would it be applied? I'm guessing not. Which could be a number of things. Ensure the player body has been added to the physics engine, and make sure the body is set to respond to forces (i.e. with some physics engines, you set the mass to 0 if you want it to be static). 

How about making any "stick" surface a character touches apply a force along the inverse normal of the surface? The force remains as long as they're in contact with the surface and overrides gravity as long as it's active. So jumping off the ceiling will have the expected effect of dropping down to the floor. You would probably want to implement some other features to make this work smoothly and be easier to implement. For example, instead of just what the character touches use a circle around the character and sum up the inverted normals. As this crappy paint image shows: