Feedback #1: Angular can actually build the select for you without the repeat via the ng-options attribute directive: 

Feedback #6: You have no error handling around your request, but on an app this simplistic that may be by design. 

I have one entity that depends on another however in my API service class I would like to just deal with the dependent entity. Am I doing this correctly and is there a better way to go about this? Post Entity 

The stored procedure requires you to pass it the log table, the source table and the primary key that ties the two tables together (usually the source PK). And is a temp table created before this is executed in the stored procedure that simply stores column names that match between the source table and the log table (not all fields from the source are being logged). Now this code behaves as intended, the problem is the query takes about 10-20min to complete (just this part of the stored procedure). The heaviest query this is used on is looking at 48 fields in a table that only stores 300K records. There has got to be a way I can make this query faster. 

I am writing an application that either mirrors a file/directory into another location or creates a zip file "snap shot" of a file or directory and stores it in another location. The user is able to create "rules" where they define the source file/directory, the destination file/directory and if they are archiving how many archives to keep. The user is also able to exclude files/directories if they so choose. Now this service class is a lot of code and I am wondering if there is a better way to do this. Of course all of the methods that can be called by the interface are called with a BackgroundWorker.RunAsync() method. Any feed back on how to make this more efficient would be super appreciated. 

Where everything inside the quotes is what to print, % means the next piece is a variable, %d means an int, %s means a string There are some other things you can do, like if you never want to change the number of spaces, you can hardcode it like: printf("%3d ", count); Here is a reference for it 

Now getting the median of this is a piece of cake, it will be in the middle slot of the middle row! Since N * M is odd, both N and M must be odd. Therefore the median is at matrix[N // 2][M // 2]. 

There is a bug here, if you reach the end of the array, and the longest sequence is at the end, what happens? I'll leave it to you to figure out the fix. A hint towards what I would do is try to add an extra check at the end 

What happens if on player1's go, they win? The game should be over, but player2 still gets to try and make a futile move. 

Continuing from my previous point (and ignoring that if it is a lowe case alphabetic character this doesn't returning anything) this could be a function for just one player. Another small piece of note is that even if the character is not an acceptable character choice, it is still assigned to the player. That seems like an unintentional feature/bug. My suggestion for a first iteration of refactoring is as a constructor for the Player class 

I only have a few quick points, Names and consistency: In general, keep variable and function names to starting with lowercase. When I see an uppercase word, I think it will be a class. A second point here is if you are getting input, make sure the function name states that. There is no reason NameAndEmail couldn't be getNameAndEmail, and I know what the latter function does immediately. NameAndEmail looks like a class. 

190 MB/s is ridiculously low for an hard disk, unless is a 5-8 years old cheap model; right now even an SD card can be faster than that, sometime. From a decent SSD I'd expect at least twice that speed, and today even SSD in the range of 100$ can easily saturate the SATA interface. That is, you want to read big chunks of data every time; no matter what, don't read a line at time. There is no magic number, but unless the computer has serious memory issues 100 megabyte each time should be more than good. Now, problem is, while waiting for data the CPU is sitting idle doing nothing. Then, while the CPU is crunching your data, the disk is sitting idle waiting for something to do: needless to say this is time for some free multithreading. Deciding what to implement is a bit complicate without knowing the exact details and limits of the project, because you can simply have a number of threads equal to the number of cores, each one working onto an equal part of the file (easily doable in an hour total), or going to write a central dispatcher that read chunks of the file, create threads up to a certain limit (maybe doing some throttling), and collecting the results (and this can take up to a day of work). It all depends on money and time you have available to do this but, yeah, go for it. 

It's just 6 milliseconds for each barcode, including save to disk: it's not that slow at the end of day, and you have a custom library doing most of the job, so that means that you really have to squeeze every single possible fraction of millisecond. In every loop you already know the size of the final string (just add the length of each single part of if), so when instancing the StringBuilder use that number to set the initial capacity. Or, just in case, set it to the maximum possible string length and see what's faster. Use a parallel for. If this thing is running on an average working PC, let's say an 8 cores, going from 6ms to 1ms could be a plausible scenario. Even taking into account that you need to instance a new encoder for each barcode, I'd say that it's realistic to at least expect the final time to go down to an half, even a third. Give proper names to loop variables. 

There is a decent chunk of text here, so TL;DR is rename variables so that they are more descriptive, don't treat players any different from one another and make functions that represent that ideal, and finally removing duplicated code often gives leeway to notice patterns and simplify code even more. I hope you take on some of the points and post a follow up, I'm very interested in seeing more from you. Good work! 

This is the perfect time for if/else statements. One good piece of logic here is if they aren't equal, and a isn't bigger than b, we know the answer to a < b without needing to check. There are more things to mention, like moving the check if two numbers are equal to a method, and making use of the library of methods available, but get it working first, then post a follow up. Best of luck 

The globals here are unnecessary, and a bad idea. What happens if someone forgets to call this function? Or worse, it causes an error? The rest of the code would either have to explicitly check for it, or pray that it will always work. An alternative is to just pass the two values back, and have nice local variables to work with, kinda like toys that you know someone else won't swoop in and break on you. 

Algorithm What can we say about a knights move? It moves the piece 2 squares in a line, and then 1 square perpendicular. You have listed all the possible moves, but we can just check if one of the absolute differences is 2, and the other is 1. 

The only place y is used is as an index. To quote Raymond Hettinger "There must be a better way". We can use enumerate to keep y, but make the iteration look a bit nicer The conditions can be shortened a little too, though not everyone would say it is an improvement.