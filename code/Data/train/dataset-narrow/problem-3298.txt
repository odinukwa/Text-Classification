When you open a GUI terminal, it starts a new (interactive, non-login) shell, which explains the behaviour you are experiencing. It is sometimes suggested to instead use (or , or something in ), since this is the shell configuration for an interactive login shell (a login shell is the shell first opened after you complete a text console based login). However, this is not a great idea since if you are using a GUI, there is never a login shell (although some desktop environments will run to make up for this. It is probably a bad place to start anything GUI oriented since it applies to remote text logins (e.g., ) as well (although you could probe the context conditionally to deal with this). With regard to running something just once at the start of a GUI login session, this is specific to the DE ("desktop environment") you are using. The current default on Raspbian is PIXEL, a spin-off of LXDE. 

Where "1" is the number of your current VT ("virtual terminal", aka. VC, "virtual console"; these are accessed via ). You do not have to be logged in on the VT where the image will be displayed, so you can log in remotely and use this to put images on a display attached to the pi (presuming the correct VT is on screen). is not in the man page, but it is listed with . Note you cannot use this to view the image on a remote terminal; those aren't associated with the framebuffer. A couple of other useful options are , which will zoom the images to fit on the screen if they are too large, and , which allows you to rotate images (I believe they are then saved with that rotation, you may want to check that if it presents an issue). 

Where is the appropriate IP address (if avahi is working, you may be able to use ). You will then be prompted for the user password. After that you should see the command prompt from the Pi. 

If it turns out there's a rich history of oom killing going on in the logs, yes. You'd want to find out why. When the system gets to that point, it is usually not very responsive or functional for a period of time. If there isn't, this is not necessarily a big deal. 

If Chromium is the only thing running in the X session, then there is not much s/he'll be able to do, as a bare X session gets you a mouse pointer -- no menus, no hotkeys, no taskbars, no nothing. I have some more stuff about this here: 

If you get a "command not found", you have to install the package. If you get "iptables: No chain/target/match by that name", then the module is not available to your kernel (but is by default on raspbian, so this should not be a problem). If you had previous firewall (iptables) rules set up, you obviously want to integrate this into it. The configuration above does not really provide an effective firewall (it just forwards the port from the default used for HTTP, 80), but if you didn't have any rules before, then this won't be any different. If you are also running a web server on the pi, then this will cut it off -- the traffic will be redirected to mopidy instead. However, you cannot have your cake and eat it too in that case, unless you set up the webserver to redirect certain requests to mopidy. 

Maybe. Also maybe you will fry the GPIO, since that buzzer looks a lot like this one, which "[carries] a maximum 45mA". The GPIOs (excluding power pins, which are not actually GPIOs) are rated at 15 mA. Although a lot of people will report doing okay at 20-25 mA, 45 is very likely too much. You probably need a resistor to limit the current, at least initially -- the buzzer itself will have resistance as well. Realistically it looks a bit beefy to be controlled this way. You would be better off feeding it 5V toggled with a transistor. 

I don't have experience with this, but if you look around online ("raspberry pi universal remote") you'll find a lot of people that do. There's even an entire site about it (or at least, a domain name with blog links). The software side on the pi is LIRC. You also need to connect an infrared led transmitter (IR LED), which are less than a $1 US. I don't know what the range will be, but as lenik points out, the pi is not a mobile device and will have to sit in more or less one spot anyway. As per that "Open Source Universal Remote" site linked above, presuming you have a wifi LAN, the best idea is probably to have the pi run a web interface that you can then access on, e.g., an android phone. 

Not in particular, since glibc is the basis of Raspbian and all of the other normative Pi oriented distros (as far as I aware). Prior to jessie, Debian/Raspbian actually used a slight variant, eglibc, but since that was merged back into glibc several years ago and is no longer developed, Debian 8 (jessie) marks a return to glibc proper. 

Beware to use and as indicated, not . The path for the command can be anything you want but it should be an absolute path regardless. Then in : 

1. Bounce occurs when the button goes down and goes up, and alternate states evenly. This means even if you are just interested in the "pushed down" edge (in this case, positive/high), you still need to watch both edges so you can apply a bounce time at the end as well. Then when the button goes up, the first event will be the for opposite edge, and any subsequent bounce down again will be properly discarded. 

That's a whole other issue, then. If you want more specific help, you'll have to post another question explaining what you've tried and where it failed. It won't happen automatically. 

It appears that the data links are just going through one of the pi's existing USB ports via an adapter. The GPIOs passed through are presumably not used for anything (trying to use them to implement > USB 2.0 speeds would I think be futile anyway). This means you are still limited the same way. You could now attach a SATA drive, but it won't be working at SATA speeds. 

It's very hard to give a comprehensive list including all the applications that might require device tree overlays. However, one thing you could do is check your current for entries that are not commented out. If there are you will probably know why, since by default there aren't any. Further, things that are actually problematized this way by an update would be exceptions and not the rule. I don't know where you are getting the version numbers from; I'm guessing a distro package (I use the git repo). If so, then this should include an appropriate addition to to match any new kernel. If not, then you need to make sure that is done. Fortunately, the Pi kernel will boot without it, but functionality will be affected. If doesn't have any output, you are missing the correct modules directory. 

That's all you need to know to write a script to resize a filesystem. IMO very few people really need to do that, and the ones that do should have the ability to read and make use of this information. If it seems beyond your current skills, you probably do not need to be doing this in the first place. Note that new versions of Raspbian look to have a new GUI tool for expanding the root fs, but of course you are not using Raspbian. 

In order to write to a file, you need write permission on it, but you also need at least read+execute permission on all the directories leading to it. So for example, if is set (everyone can read and write to it) but the directory it is in, , is set 744 (owner rwx, everyone else just read) and you are not the owner, you will not be able to access that directory. This is a little confusing since you don't need execute permission to read a normal file, but you do need it to read/enter a directory. By the way, you don't need execute permission to write to a file. So, presuming is owned root, the minimal permissions you would need would be 755 (owner rwx, everyone else rx) on and 666 (everyone rw) on . That presumes that pre-exists, since without write permission on the directory, transmission won't be able to create the file (but if it is already there and writable, it could write to it, because it can read the directory, and write to a file which is writable for it, but it cannot create a new file there). So the best bet for the directory is actually 777. 

Personally I think the second option is better, because you can then use inputs with internal pull-downs, I think pull downs make more sense in general, and it makes things more flexible in that you could leave controls attached and not use them for a particular game. Also if you make the opening bell signal a second click on one input you give mean spirited players the opportunity to cut someone slower out ;P 

Yes, and in fact if you need more room there for this kind of thing you can make the boot partition any size you like (of course, with an existing card this would mean moving the second partition first). 

-> the three things I see from your post. Prepending to is most useful if there are system wide version of something you want to override, since paths are checked left to right (for example, if the system has a version of ruby installed as a prereq for something, you can leave that ruby there and prepend the path to your own version). If this isn't the case, appending seems tidier to keep bash from searching ruby/bin first for everything -- however, that's not a hugely significant issue, and prepending may be more foolproof. You can add those functions and such to . For more information about what bash does when initialized, see INVOCATION near the beginning of . 

First a warning about the fact that stated output voltage (in this case 5V) and current (for the 3 with nothing attached, at least 1A) of a "battery pack" aren't the whole picture here. I have a 21200 mAh 5V, 2A power bank (the kind sold for recharging) with a set of these inside. It will run a Pi 3, but the undervoltage warning (little rainbow square on display, red PWR led goes out) flashes intermittently when the CPU is working. It's been fine to the extent that I've used it that way, which is not much. Other people have reported the same issue here using large, decent quality USB power banks. To be fair, power banks aren't sold for this purpose. The data sheet linked above for the actual batteries shows they don't output 5V and don't really output a very consistent voltage at all, which is how batteries usually are -- go check a 1.5V battery that's been in use for a while with a multimeter. Even though it probably works in context, it isn't outputting 1.5V anymore. It works because battery based devices either don't really depend on a consistent voltage (e.g., flashlights, which just get dimmer) or they have some kind of onboard power regulation to compensate. The Raspberry Pi is not a battery based device and will not help you with this issue. To make a total guess as a electronics neophyte, I'd say likely the four batteries in that pack are all in parallel and the voltage is stepped up (making the claim that it is a 21200 mAh battery pack subject to the caveat that it won't, at 5V, put out 1A for 21.2 hours). I believe a problem with stepping voltage up is it costs you current. Current output from batteries isn't regulated at all, meaning you can actually draw a lot (very quickly draining the battery), so that is not such a big deal, but to protect attached USB devices, a USB power pack also has to regulate current. Combine this with the fact that it is stepping up the battery voltage and you have something that, unless intended to do so, may not deal well with things that have sudden spikes in current draw. Things that are being recharged (i.e., other batteries) won't do that, but things that are being powered directly (the Pi's CPU) will. The long and the short of this is, USB power banks aren't geared to this kind of use and will tend to disappoint. I believe the best solution is to create a supply yourself1 from actual lithium-ion batteries (lots of options there, but most commonly <5V) and a DC boost converter -- something which is intended to provide a consistent voltage for the purpose of powering devices, not just recharging them. Be careful with that though, because a simple DC boost converter may not compensate for the dropping input voltage from a battery. They're intended to boost one consistent voltage to another. However, there are ones around that are intended to compensate for exactly that; this is an example end user device based on this boost converter -- so if you can find anything with a TPS61090 inside, it should be worth a try. Note that device also allows you to recharge the batteries while it is in use.