At this scale (fewer than 5 students) lectures are a poor choice of educational methodology in any case. Lectures were created as a way to scale up education for the masses. They are driven by economic considerations, not educational ones. What you have here is precisely the scale of an Oxford University Tutorial in which a few students meet a few times a week with an expert who guides them. Students prepare work in advance. The tutor comments and guides them. He/she can suggest readings, possibly different for each student, and sets new tasks or re-work on existing tasks. You can also investigate Inquiry Based Learning (Thanks to User skull for proposing that idea in the classroom). This is essentially the same concept as the tutorial, and emphasizes Active Learning. Thirdly, you also have precisely the scale for a small Agile Software Development team that could be set to a building task using one week iterations that also required that they learn about the language, process, and OO principles as they go. You become both the product customer and the learning Coach. When their code could be improved, show them how in your meetings and have them update it in the next "iteration". With this idea, perhaps combined with the tutorial idea, you can encourage them to teach one another so that not everything they learn comes from you. This can also take Active Learning to the "next level." As an undergraduate in Maths (shortly after Plato's death), I had at least one course with such a small number of students. One of our tasks was to periodically prepare a topic for presentation to the rest of the class. This might also be possible. Their "lecture" might only require a few minutes and be accompanied by a Q/A session. You can do a wrap-up yourself. This technique can also, over time, helps students overcome their natural reluctance to perform publicly. Many of them will eventually go in to careers in which such performance can be a valuable skill, so you can advance their skill/knowledge on many fronts simultaneously. For some of the students you might need to review their mini-lecture prior to their presentation, both for content and for reassurance. The real issue is that different people have different ways of learning. You already recognize that and have made adjustments for it, but you may be able to go farther. I'm not sure that this scales to as many as ten students, however. But some of it might for relatively advanced (i.e. experienced) students. 

In industry, the DEV environment is where developers are free to play and break anything (provided they fix it for those who follow). A typical enterprise shop will have a DEV, TEST/QA, and PROD environments, with developer access to DEV being nearly unlimited, but PROD being limited to end user support without significant from 5 layers of management and a pope. DEV will typically mirror prod closely enough for practical purposes, but be underpowered to reflect its lesser usage. 

My answer is "play it by ear", and don't expect to make any progress. Example 1: myself I was one of those LR students decades ago. Grades and peer approval had no meaning to me. There were no levers for a teacher to pull to get me involved. I pulled in C grades, yet scored 100% on the standardized provincial physics exam in 12th grade. I recently found out that I am (by this year's standards) autistic, in addition to being ahead of the curve by a significant amount. I either ended up doing all of the work for "team" projects, or got shuffled to the side because I had no interest in the drama that went with dealing with people. No amount of teacher intervention or classroom technique changed that. Example 2: My daughter My daughter was part of a group assignment in her media class. When one of her team mates started texting her inappropriately, she and her team mate were informed that she was doing her assignment solo. The teacher was puzzled by the sudden unilateral change, but he wisely chose to trust that this was necessary. Edit: I missed the point Based on comments (thanks @Buffy) I realized I totally failed to make my point. The two real-life scenarios I describe are personal experience, and are not extreme. My own autism has not stopped me from having successful careers, and would have remained undiagnosed until my passing had I not had other health issues in which it was found. Without the background information I provided here that was not available 4 decades ago, my high school teachers saw me as having "advanced academics" and "poor social skills" etc, and "would do the task over night to bring it back to the first group meeting, completed". At that time, autism wasn't even on the books as a legal diagnosis. It was years before it was recognized as being biological in origin. Today, I understand that the point of the tasks was the group experience rather than the task itself. But without that explicit explanation, I was physiologically not capable of realizing the task was not the important part of the assignment. Furthermore, had I been told that the "group" was the important part, I would have simply shut off rather than participate. While not all kids with poor social skills are autistic, when I see the combination of poor social skills and advanced academics, I raise the question because of my own experience. Likewise, without the background information, my daughter's teacher's perception would have been that an advanced student suddenly went rogue without explanation. The texts were mistake of the young man's that both found terribly embarrassing, and neither were prepared to talk about with a teacher. He (the teacher) may still be under the impression that she got tired of being slowed down by a novice. As a teacher you don't have all of the information, and all you can do is the best with what you have. Edit 2: What can you do?? As suggested by @beni , I have some suggestions that might help. I find it almost as ironic that I am making recommendations centered on "soft" skills as I do that in my volunteer time I manage a team of (mostly) adolescents in the high pressure and close quarters of live webcasting. 

While I truly love Java, it may not be the best choice here. Something with a lighter footprint in which small(ish) problems can be quickly solved. Python moves in that direction. Even AppleScript or an equivalent. People in the life sciences have computational needs, but the small problems probably outweigh the big ones. A while ago, a course in Unix Shell programming (pipes and filters) would be the way to go. But fundamentally, the course should be about problem solving. How do you conceptualize your problem, how do you decompose it into chewy bits? If you can get there, you can get someone with deeper tech skills to help you program it as needed. Dare I suggest spreadsheet programming? It is pretty powerful actually, and solves many needs and also has some of the abstraction facilities we promote and some of the debugging requirements that we teach. Recursion is possible if you want to go wild. 

The kinds of things that people with technical training can do have societal impacts, both for good and evil. Programmers are building the future. One future nightmare is Skynet. Many problems in the world have been caused by scientific hubris as well as the Fallacy of the Last Move, a concept from Game Theory as it applies to Arms Control and other strategic thinking. Unbound technologists, especially if amoral, can be very dangerous to the earth and its inhabitants. So, it seems that future Software Developers need some training in ethical concerns. What, to you are the most important issues and where in the curriculum should they be taught? Note that ethical issues can be simple or complex. Even something as simple a accepting buggy software can have ethical implications and such lessons can be taught in early courses. At the other end of the scale is the question of how much a person owes to their employer vs to humanity as a whole. 

I would challenge not teaching the correct use of "goto" as being a failure in the curriculum. I learned programming in BASIC, and learned (eventually) to write clean structured code even though the only way to define flow was through "goto" and the nearly equally evil "gosub". COBOL is still the most widely used language in industry. For those who think it's dead or dying, read this link: $URL$ With 5 billion lines of code being added each year, it is still one of the most important programming languages in the industry ecosystem (as much as I hate to admit it). Due to the aging workforce, a COBOL programmer fresh out of college can jump into a $75K per year entry level position. The primary flow control feature of COBOL is the "perform" statement. Since COBOL has no concept of scope or stack, everything is global to the program. A java programmer would be tempted to read 

As many of them will go on to become computer engineers as programmers. Computer engineering is all about logic circuits. You teach them at this level for the same reason you teach them programming. Besides, some problems are not solvable in real time by software alone. For a fun reason they might appreciate more directly, Redstone circuits in Minecraft are integrated circuit problems time scaled to the minecraft heartbeat. You could have them make the circuits in Minecraft. Have them build boobytraps for the last person through the door, or other problems that require complex logic. 

In writing software we name things. In Java we name classes, interfaces, methods, variables, etc. How can we teach both the importance and the skill of choosing good names? What teaching practices will lead students naturally to good practice in naming their programming constructs? How important is naming in the creation of quality software? In particular, how important is it to teach good naming and insist on it in student programs? Moreover, what practices impede the student from learning and practicing this skill? Good naming is important for both the creation and maintenance of programs. Good naming also makes the evaluation of the student programs easier when the student uses, for example, intention revealing names consistently. . Note that much of this applies to other languages, but Java is a popular teaching language. Java is mandated in the Advanced Placement courses commonly taught in the United States. It is also a common language in first courses taught to undergraduates. 

Finally, I note that languages with static typing (Java) have tools that can, in principle, provide better guidance than those with dynamic typing (Python, Ruby). Of course, Java has a lot of opportunities for syntax errors, too. 

This started as a comment, but got too long, and I realized I was moving well into answer land. Understand I'm not a teacher with a class full of kids, so this may be too esoteric of a way to look at the question. However I have worked with students at different times from different types of backgrounds. Those who were in classes where OO programming is taught first took longer to produce their first working application, but when there was a working application it was far in advance of what their peers in a functional programming first class are doing. I admit I learned functional programming first, then progressed to OO programming later, but that was because in 1975 there were not many OO languages available to a high school student using the school's teletype. Xerox had decided that Smalltalk was cute but had no commercial value, so the paradigm appeared dead. Start with the understanding that Object Oriented Programming is a way of analyzing and structuring problems, and is not tied to any language. You don't need an OO language to write OO programs. I have seen OO programs written in COBOL (not OO COBOL, which is neither OO nor COBOL). I built OO frameworks in K&R C, back when C++ was mostly an academic novelty. I have seen and built OO programs in BASIC (as in "10 let x=1", not the modern Visual BASIC which is a blending of BASIC and PASCAL). Teach the concepts of dealing with an entity. There is the entity, its attributes, and methods for it to interact with the outside world. In COBOL, you might embed the entity and attributes in a copybook, then the methods in nested programs (the lack of scope in COBOL sucks). In C, it might be a struct in a .h file and a function library. In OO languages, use the languages natural paradigm. Personify your objects. Use pronouns like "he" and "she". Teach to build the logic in the entity's method, and keep the methods very simple. Show that a complex method means that the solution is either housed at the wrong level or not clearly borken out. If they are taught this from the beginning, a lot of issues that require retraining can be avoided. 

I would say yes, definitely. It is a great bunch of well informed and friendly people. The conferences are very valuable, including the panel discussions, demos, and tutorials. The SIGCSE conference is also a place at which some of your students might publish and, if they are interested in teaching as a career, meet people who can help them. The people who go to the conference have broad interest in CS as a whole, not just teaching. Some of the questions that you ask here would find ready answers in the SIGCSE community. Many things done and discussed in the community would enhance your own teaching. SIGCSE also has an international conference (ITICSE) at which people from lots of places, but mostly Europe, come together annually. If you don't care to get conference proceedings, etc, on paper, an electronic only option is available and very inexpensive. I'm a long time member, never an officer, frequent reviewer. I've maintained membership even after retirement, though I've withdrawn from other, more technical, SIGS. Worth it, always. 

After some reflection on user Kevin's post here, I thought it might be useful to capture some of the comment discussion permanently and also provide to users who don't use C very much (I don't myself lately), a deeper explanation of what is going on. I agree with Kevin (hereafter the OP = original poster) that this sort of coding isn't what you teach novices first, and is limited, perhaps, to C-like (even assembly-like) languages. Below, I've modified his example just a bit by trying to explicate the various shells that I discussed in a comment. In particular, the only change has been to add a block structure to the code using braces (which can be opened anywhere and create a new lexical level, though I don't need to use if for renaming variables here). It is just to make the structure (I hope) clearer to the reader and the code archaeologist. I've also given "names" to the blocks/levels/shells, though just as comments.