is fine. The resulting string in is misleading. The is the amount of cans the vending machine currently holds and the is the number of coins that have been inserted. You should also directly return the string instead of creating an empty variable 

Update Following your comment, this is how I would implement the file creation based only on a date + a counter (if needed) 

contains only notion of blocking until the value is not computed. How the value is computed is totally abstracted here. 

Going even further As I said in the first chapter, the method has actually 2 responsibilities. I would split those in something like that: 

My code appears to work (although I am curious to know if it has any correctness issue). But I feel like the memoization I am doing is a bit inelegant. Can we do without dictionaries/maps, perhaps a dynamic programming based approach using 2d arrays? Or is that even worse in terms of time and space complexity? Also is my code to update the memoized_sol good in terms of coding technique? 

Below is my code which is accepted. But I feel my algorithm is not efficient. Can you please provide recommendation on how to improve both the algorithm and the coding style? 

For one thing, the domain being global is not very good: what if two users have email addresses on different domains? Are you going to set it to different values in between user creation? Just let the user have its own email address. Globals in general are frowned upon for many reasons, so when you catch yourself thinking "yes, I'll make this a global", please count to ten and then don't do it. To answer your question in the comments, where you assume you have an internal mail server only: a good rule of thumb is to keep outside of your program everything that can conveniently kept out. In this case, the domain is configuration, and as such it should be kept in a configuration file. Your program does not and should not know what the specific domain is. It just needs to know how to read it from an external configuration file/database/what-have-you. Modifying software is not a lot of fun, so if you can make a program whose behavior you can modify without even touching the source, it's way better. What if your domain changes? As it stands, you have to change your program, and possibly even test it again. What if the domain sits in a config file? You change it in there and you're golden. If you think hard enough, you will find that a lot of configuration can be kept outside of the program, even down to the choice of different algorithms to accomplish the same task. Personally, I try to make everything I make as configurable as possible, because recompiling and testing and deploying is boring. Finally, globals are bad because they're hard to keep track of, and it's difficult to know what parts of the code read from and write to them, which makes the whole thing horribly coupled. Do try to avoid them as much as possible. 

The algorithm as you have intended looks ok to me. However I have a few comments about the algorithm's efficiency. With the current approach you will regenerate the same permutation many times if there are repeated integers. Is that what you'd want? I don't think so but if you do discard the rest of this review. For repeated numbers, to avoid repeated entries in the permutation result set, one approach would be use a dictionary and check if the solution was already added to it. But this gets very inefficient when you have many repeated integers. Think about a list with 10000 instance of the same integer. Like [42, 42, 42,...., 42]. The number of unique permutations possible is exactly 1, yet your algorithm (even with dictionary) will loop many many times just to produce that one result. To address this, what is typically done is, a dictionary is created that stores the frequency of each integer that is available at a given point. We can do a DFS starting with all available integers and their original count. At each level, when we use up an integer we decrement its frequency by 1 before going further down. And we only can use an integer if the available count is greater than zero. This will generate each unique combination exactly once, so the case mentioned above with 1000 42's would finish quite fast. 

Code like this is bound to be a bit hairy. However You aren't using parameters This is a big security vulnerability. What's that method doing? Is it doing everything by the book? Does it handle every possible obscure corner case? Let ADO the MySQL connector manipulate your query, especially if there's a chance you're handling values supplied by the user. MySQL can perform the so-called MERGE (also called UPSERT) You can do it via INSERT ... ON DUPLICATE KEY UPDATE statement. In case you are not aware what that is, it's basically a way to either insert or update in case the fails because of a duplicate key error. It's for sure faster than making a separate query to retrieve the records that are currently present. By the way, code like this leaves your code open to race conditions in case another user inserts a record exactly between when you read the current records and the moment you execute your . This is bad, and you're not currently guarding against it. MySQL can do it for you, take advantage of it. EDIT Also 

TaxiMeterApp This class also doesn't need to depend on , the only useful information is the amount of the base charge. One now takes as a parameter since the distance is obviously not known when starting the taxi meter (the base charge is, however). I also removed the App from the class name because I think it has no value and only bring visual noise. 

Meter I think this class totally useless since you only wrap an (for nothing ?) Don't you think it's a bit redundant to write instead of ? I would remove it. CarType As Tunaki said, I won't couple the distance into the , this has nothing to do with a . Don't you have the feeling when you compare , and that there's a lot of redundancy ? From my point of view, it's screaming for an enum since the only difference between all of that is the value of . I would refactor all of that into the following: 

This is a leetcode problem ($URL$ Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that: Only one letter can be changed at a time Each transformed word must exist in the word list. Note that beginWord is not a transformed word. For example, Given: 

To better understand the code, the intuition is, for any given subtree rooted at node n, I calculate the maximum path that includes n as one endpoint and ends within that subtree. I also calculate the maximum path that is between any two node in that subtree (to do that I take the max of few things). The global solution is then computed at the root of the whole tree. 

are you sure this is correct? Concatenating a column name to the other like that? Are you assuming the column name will be passed in followed by a comma? And anyway, isn't it going to blow up with a syntax error when you do the `UPDATE`? Or will the column name get passed as an empty string? Might be a good idea to check what garbage you are receiving through your parameters, assuming said checks aren't already in place at an upper layer. How can you be sure all callers will remember to pass your arguments exactly the way you expect them? Plus, just my two cents, but if my assumptions are correct, this is not a very fun API to work with. 

As you can see I have used a magic number in place of -inf. This is not only inelegant, it will actually produce wrong answer if the input node has values in that range. I can think of a few ways to solve it, but I am open to suggestions about how you would do it. I can perhaps use special value like None but that introduces extra if logic that's not that beautiful. Are there better ideas? Do you have suggestions for better names for variables and methods? Please ignore the name of class (and the fact that it does use class) since this is due to how Leetcode's wants it to be written.