I have two kinds: USER and MESSAGES. A user can send/receive many messages to/from another user. Thinking in a relational way the relationship would suggest a user can have many messages, and a message can only be created by one user. So if user A sends a message to User B, both user A should be able to see the message they sent, and user B should be able to see the message they received. I was thinking first of storing all sent/received messages inside of each user object, but since there is a 1mb limit for entities this is not an option as some users can retrieve many more messages than this. Second I was thinking of creating two kinds, USER and MESSAGES.The messages kind would have a to and from property both which would be indexed so that I can get all the messages a user has sent and received. As a result each message would be its own entity and this is where it is problematic. Lets say a User is deleted, I know have to delete all the message sent and received by this user. If a user has sent though sands of messages, the cost of removing each message will be very expensive. I was wondering what would be an efficient way to model this. I am be to Google Datatore and would be open to any ideas as I have nothing implemented yet. 

Click Options >>. Go to the Additional Connection Parameters tab. Enter the additional parameter as ApplicationIntent=ReadOnly; (Note: Users must not click the Options << button after entering the Additional Connection Parameters or the parameters will be lost.) Click Connect. Always launch query windows by right-clicking on the desired database in the Object Explorer view and choosing New Query to avoid running into the #3 caveat below. 

SQL Management Studio (versions prior to 2016) Unfortunately, there are some caveats that make using Application Intent in SQL Management Studio somewhat painful: To connect manually with ReadOnly intent, after bringing up the Connect to Server dialog from the Object Explorer, users must remember to: 

Unfortunately, you cannot install SQL Express without Administrator rights on the machine and it's not something you can set in the config file or on the command line. If being able to install without Administrator rights is a requirement, you may want to investigate using SQL Server Compact Edition. See the following MSDN topics for more information: 

We believe this will work for, but we currently have an active community of users and have estimated when we roll out the feature it will be heavily used. Thus we would also like to plan for the future to be able to scale (premature now, but we think this is a very simple feature and are hoping to design it well now to save us time in the future). If in the future we need to scale horizontally we do not think our design will scale very well. We don't believe an auto-incremented message_id pk will work in a multi node environment. We looked into setting a UUID for this column ($URL$ but have read that this can really hurt performance since the indexes will be large. Reading this article we see paging can be an issue too. $URL$ In our current design we don't really see a great shard key which can be used for all our queries. We would like our queries to reach one shared server if possible. So my question is what would be a an efficient way to implement this basic messaging feature so that in the future it scales well with the queries we need. I have only ever worked with a single instance of MySQL so I am not an expert on scale out design with MySQL by any means and am open to ANY ideas (complete redesign too)! We believe sharding will be inevitable since our instance types are not very large. PS: We know some may say NoSQL is a great option for this scenario, but we looked into NoSQL options for this feature (Cassandra,DynmoDB,Google Datastore, Azure DocumentDB, FileSystem like AWS S3 or Azure storage) for a few months but due to costs for performance (indexes are very expensive in managed NoSQL environments), lack of ACID compliance (we have other ideas which will need true transactions), and more we decided on MySQL. 

Third-Party Products LinqPad stores the whole connection string including Application Intent and the database when you save a connection and therefore might be a viable option for performing Read Only queries against Always On databases. 

The Object Explorer view will not enumerate any of the tables or other objects in the AlwaysOn databases. Attempting to expand them results in an access denied message. You cannot have a Read Only and a non-Read Only connection to the same listener open at the same time. Intellisense for object names in the database does not work. (Oddly enough, Objects get enumerated just fine in the Query Designer that you can launch using Design Query in Editor... from the right-click menu.) Caveat 3 from the prior versions' caveats still applies. 

The SQL Server is running normally and the SQL Browser service is started. Querying the SQL Browser service with another tool on the same server yields the expected results. I can run regular SQL queries with SQLCMD and get the expected results. I was able to verify that the output above is the same on a workstation where I caused SQLCMD -L to receive no responses at all by enabling the firewall; however, the firewall is not an issue on this server. I've checked the settings and, as stated previously, my other tool gets SQL Browser Service responses to a broadcast just fine. Also, running WHERE reports that the path to SQLCMD is , which is correct per File Locations for Default and Named Instances of SQL Server. Does anyone have any idea why SQLCMD is doing this and how to fix it? 

I am looking to expand my single MySQL database into multiple instances to provide High Availability. As well, I am looking to be able to have read replicas and to shard in the future. I have looked for options andnoticed two external tools called MaxScale and Fabric. I was wondering what the difference is between them? 

1) User would login using their username and password 2) User could get friends by getting their USER entity based on their username 3) User could add/remove friends by getting the entity of user1 and user2 and either adding or removing friend via transaction to make sure they are consistent. 4) User could get all the message they have sent by using indexing the the 'from' attribute (limit of 10 message per request). The same could be done to view all the messages they have received by using the 'to' attribute. When the message has been seen for the first time I would go to the message (1 get) and update the entity (1 write + (4 writes x 3) = 13 writes to update the entity). My major concern - If a user gets 10 messages, this will require 10 get requests plus if all 10 messages are new I will need to update each entity and if all of them are new that is (10 x 14) 140 writes. Then if I get another 10 message for this user the same process and this could all add up very quickly. I then thought of creating an entity to store all the sent/received messages in a string for a user inside of a single entity: 

Although you can get SQL Management Studio to connect with Read Only Intent, it does not store the Additional Connection Parameters when a connection is added to Registered Servers. Behavior when hand editing the locally registered servers in the RegSrvr.xml file to add the Application Intent is extremely inconsistent and will be overwritten any time a change is made through the GUI making this workaround unreliable. The Always On database must be selected before the query window is opened; otherwise, the connection gets routed to the primary server. If you attempt to select the database using the query window's drop down after the query window has already been opened to a non-Always On database, you will get an error dialog. If you try to change the database to an Always On database with a USE statement after the query window has already been opened to a non-Always On database, the results look like this when you attempt to execute the SQL query: 

The function is documented here: $URL$ ATTENTION Be aware that those two queries can give different results for periods that are exactly . The following returns : 

Anyone can help me to figure it out? Many thanks to all Pietro UPDATE I forgot to logout and then login after editing the bash profile. The suggestion made by Daniel Vérité was right. I just edited the env variable in in order to make it visible at a global level and not only from the interactive shell. I added the following line to : 

where and are 50% and 75% of total RAM size respectively. should lay between and for your use case.Test it and give us a feedback. There are also two other moves you should make: 

You can play with to obtain the merging concept you have in mind. Here's a link to the official documentation (PostgreSQL 9.4): UNION clause. I think that you would like to remove duplicates (if there are duplicate entries in both tables), so probably the is right for you. 

If the SQL Browser Service is active, you can query the service for SQL Instances with the PowerShell code below. It implements the following commandlets to perform the queries: 

I have a server with three installed SQL Server 2014 instances with Service Pack 1 (build number is 12.0.4213.0) installed. When I run SQLCMD -L on the server I am getting the bizarre response below. 

As long as they are not nested, you should be fine. @@FETCH_STATUS is set at the time the FETCH NEXT is performed. @@FETCH_STATUS is global to the session, not the entire server. There is no equivalent to SCOPE_IDENTITY() for @@FETCH_STATUS. If you need to nest looped FETCH NEXT operations, make sure that your outer FETCH NEXT is performed after the inner loop completes. If you need to stack FETCH NEXT operations or perform a FETCH NEXT before an inner loop containing a FETCH NEXT, you can DECLARE a temporary variable of type outside the loop, SET the temporary variable equal to @@FETCH_STATUS immediately after your FETCH NEXT statement, and then use the temporary variable as your loop control instead of @@FETCH_STATUS. 

I will be using Amazon Web Services RDS service to host a MySQL 5.7 server (Currently AWS do not support 5.7, but they have announced they are working on implementing this version and it will be out soon). I will only have one table, but I expect it to have MANY rows. It is a messaging table which will contain messages from users to other users. A Message can only be sent by one user to one other user. This message when read for the first time will need to be updated stating it has been read so it will require one update in it's life if it has been read. A User must be able to view all thier sent messages ordered by newest and all the messages they received ordered by newest. My initial design looks like this: Messages Table: