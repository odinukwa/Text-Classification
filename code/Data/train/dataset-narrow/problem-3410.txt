From Raspberry Pi Documentation: "The flow of boot begins with reading the OTP to decide on the valid boot modes enabled. By default, this is SD card boot followed by USB device boot. Subsequently, the boot ROM checks to see if the GPIO boot mode OTP bits have been programmed — one to enable GPIO boot mode and one to select the bank of GPIOs it uses to disable boot modes (low = GPIOs 22-26, high = GPIOs 39-43). This makes it possible to use a hardware switch to choose between different boot modes if there is more than one available." As per above, it doesn't seem that you need to program the OTP (One Time Programmable) bits to boot from USB. 

By looking at your question, it seems that you are trying to gather light data from multiple Arduino boards and using Raspberry Pi as collection (and may be reporting) point. SPI specification has no set length limitations but when run a few meters apart, it is susceptible to EMI/RFI, cross-talk, slew rate issues. Assuming your Arduino boards are far apart, you need a differential pair bus like RS485, RS422, etc. To answer your question in simple words yes, you can use SPI to communicate between 3 or more Ardunino boards contingent to proximity between your nodes. Master with three independent slaves: Simple in operation but limited to the GPIO pins required for each SS. Each additional slave will require one additional Slave Select pin. 

AFAIK only one audio output can be selected. You can, however, select one of them manually using amixer command: 

Normally, GPIO pin is not connected to anything so it's value is not possible to reliable detect it's state. It is said, that this state is floating as in this state, value of GPIO pin can change depending on some unpredictable external events. Now, you can connect switch (or bush button) with one side to GPIO pin and one to the ground (GND). This way, if you push the button, GND will be connected to GPIO and it's state will be low. If you release the button, GPIO wont be connected to anything again (so it will have floating state). So you need to somehow make your GPIO be connected to high voltage when your push button is released. This is called pull-up as when you do this, this will pull your voltage up. But how to do this? You have to connect your GPIO to 3.3V. This way, when if your button is released, GPIO will have state high (3.3V). If you push your button, it will be connected to both 3.3V and GND. Current will flow from 3.3V to GND leaving GPIO at 0V (state low). There is one problem, however. You have almost no resistance in your circuit so the current that will flow will be very thing (so called short circuit). That's bad. And this is why you need resistor, a pull-up resistor. It will limit current flowing from 3.3V to GND or GPIO pin. How big resistor should be? Big enough to limit current to the value that won't damage GPIO pin, won't blow your input fusses on RPi or make input voltage drop to the value that will make your RPi reboot. In case your RPi would be powered from batteries, you would also like not to take too much current so the battery will last longer. It can't be to high, however, since RPi may have problems with detecting high voltage in the input. So to be on safe side, let's say that its resistance should be measured in kilo ohms :) Now you should imagine what is internal pull-up resistor. It's a small resistor inside of a chip that connects GPIO pin to high voltage that you can use instead of connecting external one. 

This is an excellent question as a lot of people want to drive loads using their Raspberry Pi. I'm not sure why you received a -1 your question may have need rephrasing. Yes, You can drive a load using a Bipolar transistor or a MOSFET. A MOSFET will be more efficient. 

Master with daisy chained slaves: More scalable (adding slaves will not use additional pins) but will get more complex in operations. 

Your application doesn't need denouncing as there are no mechanical contacts involved. The pulse adapter board has no mechanical contacts, relays, etc. Debouncing is only needed if you connect mechanical contacts to digital inputs. From Whatis.com - "Bouncing is the tendency of any two metal contacts in an electronic device to generate multiple signals as the contacts close or open; debouncing is any kind of hardware device or software that ensures that only a single signal will be acted upon for a single opening or closing of a contact." Here is a excellent guide on debouncing. On the other hand, your application may need signal conditioning. The pulses from the adapter bard may be of different amplitude that the PI can handle. Or the pulses may need filtering, etc. You can read more about signal conditioning here. 

Is, it recommended to use SPI to communicate over a long distance, No! My recommendation will be to use ESP8266 modules with Arduino boards and transmit the data over WiFi and collect using Raspberry Pi Ethernet (or WiFi interface) 

Try building and booting kernel without file. Try adding ready content to your kernel. Change this content to suit your needs. 

Also note that you can change some of the frequency configuration (at least for ARM) dynamically using . Just take a look at: 

application does not use ALSA or any other sound drivers at all. It uses so called , which support events. There are couple of such drivers in Linux kernel for different beepers, like PC-Speaker or speaker build into Intel HDA card (or some more). As far as I know, there is no driver that implements events on top on any ALSA driver and since there is no other type of sound device in RapsberryPi, you just can't beep by default. 

Note, that in normal case, you need root permissions to do this. Since all this is just a file operations, it can be easily done in C program with // functions. Be careful when using // functions since they use buffered I/O. Directly using registers This one, I believe, is being used by wiringPi itself. It uses device to access physical RaspberryPi memory and to operate on BCM2835 memory mapped registers directly. In order to use it, you would have to read BCM2835 datasheet ( section). It is not that trivial however. Note, that you need root permissions to do this. There's also one more C library that uses this way, you can find it here. It does much more than only manipulating GPIO but since it's quite simple, it should be easy to extract only the GPIO code and understand how it's working. 

The Raspberry Pi board operates at 3.3V internally. Although you power up the board using 5V but the GPIO voltage is 3.3V. Even if you replace the 5V relay module to 3.3V relay module, the GPIO can't provide enough current to energize the relay coil. You need an opto-isolated relay board that will take 3.3v trigger input (most opto-isolated setups do). Referring to below schematic, you would connect DGnd to Raspberry Pi Ground, IN1 to Raspberry Pi GPIO, Supply Relay voltage (12V in this case) at J9 and connect your load (bulb) at J5 (in series with your load supply voltage, same as your current module). 

For a new system you would have to create a wpa_supplicant.conf file in /boot to configure your wifi. Follow this post for a new setup. 

You need to put your script in /etc/rc.local. This script runs once when the OS starts. It runs irrespective of id any user logs into the system or not. Raspberry pi manual describes it in detail here. The .bashrc file is used to setup your bash shell environment when you login into bash shell. .bashrc does not execute if you don't login into bash shell. 

Yes, you can use command line tools to play internet radio streams. I have used omxplayer to play internet radio streams with no NDMI/video head. I created certain shell scripts for station choices like Jazz, pop, etc. I would ssh into the "headless" box and start/stop playing. You can improve by invoking shell scripts via GPIO buttons. 

There is a lot of sensors you could use. The only restriction is that they can not be analog devices since RaspberryPi does not have analog to digital converters (unless you use some external A/D chip, which isn't that hard). You should search for something like . Just ensure it is 3.3V compatible. Here's an example from Adafruit. They even have a thread on their forum about using it with RaspberryPi. 

which should spin your drive after 10 seconds of inactivity (you can change to other values (1-240 can be used to specify multiples of 5 seconds, 0 turns spin down time off, 241-255 can be used to specify longer periods). Another option you could try is to use: 

where each of corresponds to physical pin number XX. So if you want to turn and on and , , , , and off, you would write value of (in binary) which is 0x11 in hexadecimal to the register. I²C Addressing Each of your , and pins should either be connected to ground or to , depending on the address you want to get. You should never left it without any connection since this will make it . This means for the chip it may have different state each time it is read. So if you want to have address , you should connect all of them to ground. If you want to have , you should connect all of them to . Final notes Please note that this is simplified explanation of how this chip works. It has different mode of operations and some more features that can be configured using chip's registers. You can read about such details in the datasheet. 

Raspberry Pi does not have an orientation sensor built in. You can simply use of of the GPIOs along with a tilt sensor to detect the flip / Orientation. Here is are example of tilt switches. 

From your diagram, it doesn't seem that you have connected the LED to a GPIO! Here is a map of the GPIO connector: 

Connect your RxD GPIO Pin (GPIO15) to TxD pin of your USB to serial adapter. Connect TxD GPIO Pin (GPIO14) to RxD pin of your USB to serial adapter. Connect your USB to serial adapter ground to Raspberry Pi Ground (Pin 6 of GPIO connecter) Use appropriate serial terminal program (depends on your OS and choice) 

My recommendation would be to add another layer of opto-isolation when driving the above relay. Here is how opto-isolators work. If possible, double the capacity of the relay (90A) to add scalability and over-current scenarios. There a lots of advantages of using SSR over mechanical relays. Here is an application note from IXYS that delineates the advantages of SSR over mechanical relays. I would not recommend you do it yourself unless you are licensed. Better get a licensed contractor as the voltages are lethal and one mistake would cause electrocution! 

Download and image latest raspbian on SD card - Guide Mount the SD card in Linux (assuming your laptop has Linux or a VM with Linux) and edit the /etc/network/interfaces file assuming 192.168.10.110 is the IP you want to assign and 192.168.10.1 is your gateway. 

protocol is very simple. It does not really define data structures that are sent over the wire. The frame consist of a slave address (with direction bit indicating if master wants to read or write) and (in case of writing) some bytes of data. Since it doesn't make sense to initiate write with 0 bytes of data, first byte is mandatory. This first byte is often used as a slave register address or command number but it doesn't have to. There may or may not be additional bytes after the first one. The higher level protocol defining what each byte means is device specific. This may explain why there are two separate arguments - first one () is mandatory and second one () is optional. While your example is in language, the API used here is actualy very close mapping of original API where you can't easly create optional arguments. 

Most such cases (where script works in shell but not in cron) are because of environment variables that are different in script. In many case the problems is variable. You could use full paths to all executables you are running in script or modify in first line of your script. To trace such issues, you could start from dumping environment variables aviable to your script by using command, like this: /usr/bin/env >/tmp/env.txt 

Direct answer You can't do this reliably since there is no framebuffer arbiter or anything like that. This means you can't stop X server from writing to framebuffer after you displayed your pattern. If nobody moves cursor/windows and no program is currently drawing some animation, it shouldn't happen. You can also rewrite the screen couple times a second to prevent your content to be overwritten by X (unless you have some animation happening in which case X server will be doing the same. You can read the framebuffer content at the beginning of your program and write it back when you finishes, restoring the screen but this may not be up to date. You can also force X server to refresh the screen ( command from does this) but I'm not sure how it's done. You have to check the sources. It probably uses some or function for this. Other aproach While I found this problem to be interesting, I'm still actually not sure why can't you just write X application that will open on full screen instead of manually writing to framebuffer. If you care about being able to run also without X, you should investigate library. It should be very easy to write such application for example using and (but you can of course use any other language with support).