for what i can tell by now it's something similar to FreeGLUT to me, but looks much more portable and standardized. 

I find difficult to study the performance of a shader or a series of statement probably because the OpenGL is a state machine and also the execution is in parallel and not serialized like a standard X86 CPU I/O. There is something that i can use for this? The BigO notation is based on the concept of growth, but with a state machine there is nothing growing, how i can approach the study of this kind of code/algorithm? 

I noticed that this series of free books from Nvidia is really popular and well know in the devs world, the problem is that is simply old; you would recommend to read those 3 books to a developer that wants to improve his skills with a programmable pipeline and is starting to do so in the 2012 ? 

This is called split screen. It's a relatively big topic to handle in a small reply but is strictly related to how you are managing your viewport, you can find more online in the wiki. 

Now, this looks really trivial and simple, but my problem is with the mod function. This function is taking 2 vec2 as inputs but is supposed to take just 2 atomic arguments according to the official documentation, also this function makes an implicit use of the floor function that only accepts, again, 1 atomic argument. Can someone explain this to me step by step and point out what I'm not getting here? It's some kind of OpenGL trick? OpenGL Math trick? in the GLSL docs i always find and explicit reference to the type accepted by the function and vec2 it's not there. 

In theory with HTML5 you get what you need to code what you want to do, but you can't create an app with just a pure HTML5 codebase, you need to interface your code with native code in a way or another. The real solution that can fit your case is using an HTML5 framework like phonegap. It's the easiest and shortest way in your case. 

To debug an XBOX 360 game you need a devkit and here is how you can buy one. You can run the game on your standard XBOX 360 if you have payed a subscription for your developer account. 

After i have been played for some days with various vertex and fragments shaders seems clear to me that this programs are called by the GPU at every and each rendering cycle, the problem is that I can't really quantify this frequency and I can't tell if is based on some default values or not because I don't have a big collection of hardware right now to do extensive tests. For what i know the answer could be really trivial like "it's the same of the refresh rate of your monitor", but i would like some good answers on that to be clear on this. For instance looks really odd to me that all the techniques used to control the amount of FPS that i have seen until now uses a call for the OpenGL function to retrieve a value in ms about when the rendering started but I have to relies on the CPU to do the math. Why I can't set an FPS value in OpenGL if OpenGL clearly has a counter and a timer/clock? PS I'm referring to OpenGL 3.0+ 

If you ask me the language for you is the C++ because learning C# or C++ is the same thing for a newbie, it's always a new language, but what the C++ can offer the C# can only dream about it; you also will develop a real know-how that you can spent on as many platform as you want and on all levels, from small games to serious development. The last part about what framework you are supposed to learn, again, i will go for the most business friendly and the best choice as an investment these days is OpenGL with a programmable pipeline approach and this means OpenGL 3.0 and above. I should also remark the fact that OpenGL is a rendering technology when DirectX is a complete framework oriented to all the main aspect about multimedia, but the thing is that today there are frameworks available for every purpose that you have in mind, most of them are free and really well tested, with an history of several years of testing and they are really reliable, they are also cross-platform and with a really good license most of times if not in every case. As soon as the OEMs will stop installing Windows on their machines, and most of them already do that in practice, just see the market share percentage of Windows Phone, the entire Microsoft ecosystem will collapse and just looking at what is now, it's not that good anymore. Look at the marketplace, Microsoft has a marketplace by years until now and there is absolutely nothing, it's empty compared to what you can find on the marketplaces of the competitors. Look at the technologies, C# lives thanks to the web development, if it was for Windows Phone 8 development it were dead by years; Silverlight is a big flop, find 1 technology that Microsoft has introduced recently and see how good is performing on the market, even Internet Explorer have lost its throne. I know that most of the people that will read this, especially advanced and senior developers, will get this as a ranting against Microsoft, but when even the founder doesn't believe in its own Corporation that is performing so badly before an important launch, that is losing important assets and presence on the market on every field, i think that you just have to consider the facts. recap: go for C++ and OpenGL 3.0+ and you can code anywhere. 

Just learn XNA with the C#, the XBOX 360 is really only a particular profile from a programmer viewpoint. there are a lot of tutorial on the internet but this is an official resource. 

There is no standard about this for a good reason: there are infinite variations on the topic, infinite combinations of inches and pixels for every device out there. Usually a smartphone or a generic mobile device has a dpi value much higher than a normal PC monitor, so if you think in terms of pixels you are supposed to produce an image that will appear much larger on your monitor than what actually does on a mobile device. You can solve this keeping in mind 3 things: 

If you want a completely free solution, where you can also feel free to publish your work without warring about royalties and fees, you can use the Blender game engine and you can create your own game right inside blender and export it as a standard application. Blender is a completely free open source 3D modeler with advanced capabilities and it's written in C++ for the biggest and offers internal API for Python. 

I suppose that XNA vs the world ( aka OpenGL and DirectX as real alternatives ) can easily look like a religious question especially when targeting a new developer, but i find that the right adjective for XNA is simplified and not powerful. XNA is a subset, someone can argue that, but in the end is just a subset of DirectX, this framework is well suited for small project and not for serious gaming. You have also to consider one aspect both C# and XNA ( or DirectX ) are technologies that are available only on Microsoft platform, this is important to stress, my point is that today Microsoft is not a big player in the industry, if you consider on how many platform you can make games, including desktop and mobile, you will easily realize that Microsoft is simply struggling in the market and more and more Microsoft will see its own market share resizing to a smaller size. I personally believe that C# and DirectX/XNA will have a really hard future, i think that during the lifetime cycle of Windows 8 many many people will realize how bad their choice was about the language to adopt as main language, C++ is much more suitable for the performance, for the business and for cross-platform compatibility. I do not want to influence anyone, just propose my idea, my points are: 

in this online book there is an example about how to draw the first and classic hello world for OpenGL about making a triangle. The vertex structure for the triangle is declared as stated in the code above. The book, as all the other sources about this, stress the point that the Clip Space is a 4D structure that is used to basically decide what will be rasterized and rendered to the screen. Here I have my questions: 

I need to code OpenGL ES 2.0 bits and i would like to do this and run the programs on my desktop for practical reasons. Now, i already have tried the official GLES SDK from ATI for my videocard but it not even runs the examples that comes with the SDK itself, i'm not looking for performance here, even a software based rendering pipeline could be enough, i just need full support for GLES 2.0 and GLSL to code and run GL stuff. There is a reliable solution for this under Ubuntu Linux ? 

Xcode comes with a built-in fully featured emulator for both iphone and ipad, so you just need Xcode at minimum, you can code for iOS without having a real device. If you care about optimization the only solution is always buying a real device. Also depending on what sensors and controllers you want to use, you can just consider to buy an iPod touch if you are not interested in the differences between an iPod and an iPhone. I also should add the fact that the GPU is basically the same for the latest 3rd and 4th gen of Ipod touch, iPhone 3GS and iPhone 4, the only new GPU is in the iPhone 4s and is not so revolutionary, so i think that you can go for an ipod Touch if you want a real device for just testing your app. 

I need a way to capture what is rendered on screen, i have read about glReadPixels but it looks really slow. Can you suggest a more efficient or just an alternative way for just copying what is rendered by OpenGL 3.0+ to the local RAM and in general to output this in a image or in a data stream? How i can achieve the same goal with OpenGL ES 2.0 ? EDIT: i just forgot: with this OpenGL functions how i can be sure that 

I don't know this device but Eclipse doesn't care about this, your bridge between your Android phone and your PC is , a tool distributed with the Android SDK, and you should be able to develop and test an application with every Android device out there. The only real problem are the drivers; the suggested platform for Android development is a Gnu/Linux distribution but many people still use Windows or Mac, with Windows you must have the right drivers for your device because otherwise you can't use it and you can't connect it to your PC. On a GNU/linux distribution you don't have this problems and the setup is much more easier. 

for extruding and right after press to scale and move the cursor to the center of the star. Now you get how to extrude the shape to the center, to give a vertical extrusion just press and right after to grab and then the axis where you want to move the selection like . To create the final point for closing the center of the star just press again with the final edge loop selected and press to collapse the selection to the center of the shape. With this you can achieve what you want to do. 

I would like to export a 3D model with each part having a name or a label if you will. For example i would like to export a model of an human body and name each part in specifics vertex groups like: left hand, right hand, right foot, head, ears, ... and you got the idea; so i can have a single 3D model that i can explode in various parts if needed. If there is a better technique about how to mark vertex groups in a 3D file please share your solution. As 3D editor i use Blender.