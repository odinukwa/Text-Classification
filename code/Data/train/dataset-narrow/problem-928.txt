(I don't actually know what the three decimal values represent when you're setting the console color. If they're not RGB, you can rename them accordingly. But you get the idea.) Finally, it's standard to encapsulate your functionality into a and call it like so: 

Use reusable functions, especially when you find yourself copy-and-pasting code. Don't hardcode anything; use constants rather than "magic numbers". Don't use global variables. Wrap it in a . 

Certainly, that seems adequate. You may want to make the field , though. Otherwise having a getter is pretty irrelevant. Also, I would make the field so that the associated color can never be modified. Were you told to code your own class? There's already one provided for you in . 

I wrote this script a few days ago to find all files which were taking up over a certain threshold of memory on the hard drive. A hard drive on one of my computers had just 6 GB left, so I needed to clean some space up. I used this to identify bulky folders to find out where the problem was. Is there anything I could have done better? I'm particularly displeased with the exception handling in the function, since I ended up handling the same exception twice, just at different levels. Couldn't think of a way around it off hand, though. Also, efficiency was an issue with this script. I know I could've invented some framework to keep track of all the folders previously scanned, but that seemed like a bit too monumental of an effort to make for such a trivial script. The recursion was much easier to implement. Any and all suggestions are welcome! 

I rewrote your entire method as follows just by following some decent object-oriented design practices. 

I only see one really questionable thing in your code. Why do you call in your constructor? Your parameter-less constructor does absolutely nothing, so this line is irrelevant. If anything, I would actually even remove that constructor entirely so that your API can only be used with your meaningful and useful one. Also, as a side note, the following line opens you up to a since you never check to see if is or if it has any elements. 

Casting is actually a kind of "all else failed" tactic in Java programming. Ideally, you should never have to explicitly cast anything. I think you're referring to the concept of polymorphism rather than just casting. A good way to learn about polymorphism is with some game or project involving different kinds of animals. You would have an abstract class or interface named , and below this you might have mammals and birds and all sorts of things. Turns out the world of biology is naturally suited towards hierarchy. Exceptions you learn naturally when you start actually trying to deal with errors rather than allowing your application to crash when it doesn't go down the "happy path". I think most beginners first experience this when they're trying to get a user to input integers and they have to deal with a user maliciously typing in . As you try to make your applications more robust, Exception-handling skills will develop. 

I'm sure you're fine with this, but just be careful with unsafe casting! :) I like to check whether the cast is valid with either or, preferably, . 

Here's my five minute rendition of it. Actually, my version uses inline statements because I find that it makes the code more concise and readable, but I laid it out a bit more to make it more intuitive for you. 

Overall, your code looks pretty good! I'd say if you want a more thorough code review of your abilities, you should write up some code that doesn't simply call these external methods. It's hard to get a good feel of whether you know good programming/Java habits when all of your methods only call other methods that have been written for you. With that said, my primary qualm is with your method names. In general, you should always design your methods with the idea that someone else will be using them in the future. That means they should be as self-explanatory and intuitive as possible. For example: 

Notice that I also didn't break the line into multiple. This is based on your subsequent lines, which show that you're willing to have content out past its character limit. No need to perform unnecessary line breaks. It just makes the code muddier. I also reworded it, since "resolution failed to resolve" is a bit redundant. Also, if you're checking against multiple files, I would use a of them. This will make it easier for you to tack on functionality later, if you need to. e.g., 

Your getters and setters would be for fields of the class, not passed in. I'll use your two simplest ones as examples for you to work from. 

In general, method names should be actions and verb phrases. The name is a noun phrase. Perhaps this is simply a typo, where was supposed to be , though. More importantly: why are you passing in an object instead of the primitive type as your first parameter? Usually you should only do this if there is a very good reason to do so. As it stands, your method is vulnerable to a if it is called incorrectly. If you simply use an , you remove this danger without sacrificing any functionality. If you really want to keep the object wrapper, at least do some sanity checking (either at the beginning of your method or when you use it). You can check for and throw an or simply default to , depending on how you want to design it. 

Why would you ever combine all this functionality into one method? Each case does completely different things. The "name" that the method retrieves from the ID has completely different content based on what it's looking for. Having three methods with the following signatures makes much, much more sense to me: 

Note: setting the combo boxes into the this way will cause issues if you intend to use the class with concurrency, but the solution for that is left as an exercise for the reader. :) 

When dealing with s, you should almost always have the functionality defined in some class that rather than extending itself. So you can have an anonymous class or an explicit one. The standard way to do it in-line like you tried to is like this: 

I'm not going to go through all of this code since it's like 800 lines and would take me all day, but I can give you some good general tips just by glancing at it. 

I was skeptical of this method immediately because it's very, very rare to have to pass around GUI elements like this when using Swing. Ideally the combo boxes should all be declared as global fields in the class (i.e., ) so that all of your code can reference them as necessary. Also, this really breaks Java naming conventions. In general, a method name should be some kind of verb, never a noun like this. If I was skimming code and I saw something called , I would assume it was an object, like of the class. Anything that's a noun in your code should be an actual object of some kind. 

This makes your code a bit less complex and a bit more readable. I completely avoid your block by simply returning the boolean directly from the recursive method call (EDITED: As David Harkness says in the comments below, this actually changes how the method functions, so I've removed that bit.). Also note that it my loops I compare and to and , respectively. This isn't a huge deal if you always know you're going to be handling boards which are 9x9, however when you're designing code you should always try to make your code as flexible as possible. The more flexible it is and the more scenarios it can handle, the more powerful it is. 

Your code is actually pretty good overall. I have one very big question, though: why do you want all these to be inner classes? Normally, we use inner classes only for a very specific reason and only if the class in question is a critical component of the outer class and somehow inseparable. Usually, this is done with enums, for example: 

For your next iteration... I challenge you to do some file handling! Download this file to your workspace and figure out how to read the words into your program and have it "think up" a random word from it. :) 

... Or you could write the conditional as , but I honestly really hate the flipped comparison rather than explicitly checking for . I suppose it's a matter of taste, though. Anyway, bottom line: no, there's no use for it, and there's evidence that the original programmer didn't entirely know what he was doing, anyway. 

... Then, all you have to do is change these variables if you want to modify the game in the future: 

This controls the flow of the program based on normal execution. It should be pretty easy to see why this isn't ideal, simply for code readability, not considering aspects like performance, style, and best practices. What you have in the above code is fine. Throwing Exceptions for errors is what they're for. If you're throwing Exception simply to break out of loops or functions or are using them during the "intended" execution of your code, that's when you're going down the wrong path. 

Since you can only use this one class, the key to having better, more beautiful code is to encapsulate logic in reusable and well-named methods. Below is a modified version of the code which follows some basic design principles, which I will explain piece by piece. Also, you have a lot of variables that you declare and never use, but I left them there under the assumption that they were going to be used in a future release. 

This / construction allows us to do some basic exception handling. Basically what's happening here is that will try to force the into an , which will then get autoboxed into our variable. If can't be parsed as an (i.e., if it's not a valid integer), then the call will throw a . This will be immediately caught in our block, at which point we simply print the error message to the user and continue execution as normal. Because we are still within our loop, we will keep doing this until the user enters a valid integer. 

Out of curiosity, is there a reason you make this two-dimensional array ? It doesn't affect the values stored in the arrays, and the doesn't affect the reference when it's returned from the method, so there doesn't seem to be much value in having it here (unlike its use in your class, which makes perfect sense). 

You're doing like four things here. You're comparing to produce a , extracting an element of a list, performing a slice operation, and printing a value. Again, it seems obscure because it is obscure. I can't even begin to trace out what you're trying to do in your first line of code, unfortunately, or I would. I have a story which demonstrates the point. On one of my more recent projects at work, a contractor had produced some code with several nested ternary conditions. It looked something like this, in one line of JavaScript: 

It all works fine, but it feels a little too verbose at times for what I'm trying to accomplish, like I've tacked on a bit too many nuts and bolts. Like I've gone deer hunting with a .50 cal or something. Any suggestions to improve this? The same messages are used redundantly in several places, so I am seeing some value out of it, but I'm not sure if there's a good way to make this still more clean or otherwise accomplish what I'm trying to do in a more succinct way. If it's relevant, I'm using . 

Without an advanced math degree, I think this is a perfectly reasonable solution. Here's a sample implementation. It's not that complicated. Basically, for every that exists (each of which is a set of coordinates on the board), we check that sequence and see if the s are all the same. If so, that player has won. I don't think that's a step in the wrong direction. It's perfectly logical and functional. Now if it was a more vast game like Connect Four... looping through each variation might be a better option that explicitly listing each win condition, obviously. But since Tic-Tac-Toe has such a small set, this is fine and makes the code pretty readable. 

Here you can actually just use if you feel that would make your code less wordy. As you can see in the documentation, you don't actually have to pass in an array of the appropriate size to the method; it only uses your array for infer the type to return to you. So by just initializing an empty, zero-length array like this, you may be able to improve code readability a bit (and performance by just a small amount, by saving on memory allocation). There's no consensus or standard on this. Just personal preference. 

So this method is a little more complicated because I've added input validation to it. We want to make sure the user actually inputs an integer, otherwise our program will crash, right? This method may be a little more advanced than where you're at, so you can just skip over all of this if you want to ignore it. But it's a good reference point for when you start to learn it later. Step-by-step through this method... 

I changed your to a in order to avoid your having to handle s in its initialization (or ignore them by having that ugly clause on your method, haha). This is just an easier API to use at this level. I've also moved it to be a field for the entire class. This will allow it to be referenced from all of the methods we create from here on out. 

It took me awhile to figure out exactly what he was trying to accomplish. When I asked him about it later, he said he thought he was being very clever and doing something good for the code by being "short and succinct". But it's not clever, and it's far from helpful. It's just frustrating for the people who have to maintain your code later. 

Small final note: I think you have a bug. The line where you display the results always says "sum", even when you're doing division, multiplication, or subtraction. :) 

Here, your method assumes that every image is a rectangle of some kind. If you had an image that was, say, a triangle, your code would fail with either a or an at some point (depending on which end of the triangle you started at).