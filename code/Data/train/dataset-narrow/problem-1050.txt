AS pointed out by Joseph answer is a perfect, but his answer was a little bloated and can be simplified The is no need for the as it can be coerced with an empty string 

Not bad but needs improvement. First I will say 9 out of 10 for style. Not that I am a particulate fan of this style but you have the number one rule of coding under your belt. Consistent style, it is the most important skill any programmer MUST master or you will forever be in the hell of a thousand typo bugs. I am a fan of the singleton style of design. This encapsulates the toDoList within a single scope. Your code is very similar as you use the event to start the process and have everything inside that function. To make it a little more portable create it as a separate object that can be added to a page as needed and not rely on the event. 

Rewrite moves function out of also include the string function, the first is as you would write it if you included it in the API the second is how it can be written outside the API and thus trust the caller 

What could be improved in this implementation? I think I could eliminate one of this methods: getLastNonWhitePosition, getFirstNonWhitePosition using Java 8 and functional programming, but I cannot do that. 

I made this password generator I'll use in a simple Android App. I want that it generates a password using a truly random number source, but I don't have idea how to do it by now, so a let a seed parameter to generator class that will be created by that numbers source. I used the decorator pattern to compose the source from which the chars will be picked up. So if I want a password in which the chars will be picked up from a source of numbers and lower case letters I will decorate it with NumericDomainRange and LowercaseDomainRange, but there is no warranty that the password generated will be composed of number and letters. It must calculates the password entropy based on some algorithms, I have not implemented anything yet. Please, review its overall design. root package: 

This avoids creating endless copies of the of the links array, via the filter and map methods. It also solves the problem of paths that fail. Now to fix the cyclic reference problem To do this you need to track the traveled path to each destination. I have created a stack that tracks the current path links "traveled". When end points are found the current links are popped of the traveled stack so that the links are free to be use for another path to the destination. The code is in the example below. Well I think it works, it stops the crash, whether it finds all solutions may need some very in depth research which is beyond the scope of this answer. UPDATED code snippet I wanted to be sure that the function worked so did some more testing, and while I was doing it I realized that a further improvement could be made. The problem is that each step requires the entire array of links to be iterated, checking if each link has the correct origin. That can be offloaded to the creation of the array. Using a indexed by allows the main loop to only loop over the links with the correct origin ( returns a pre-existing array of with origin ). This is a significant performance increase. 

It's a implementation of Transformation from Picasso library looks for the first different pixel color in both sides, in the vertical and horizontal, and crops the bitmap from there. Here is the Bitmap class doc from Android library. 

I made an re-implementation of your elevator simulator. I change the methods elevatorUp and elevatorDown to one unique method, to avoid code repetition and to put off some ifs. 

Please, review my code about any aspects you think is relevant. One question about performance: these object creation whenever user change a property is a risk to performance? I like this way of doing things (creating objects) I think in java this is not so problematic anymore. In Android maybe. thanks in advance 

So it will run both the programs asking by 3 numbers, that will be: 50.000.000, 60.000.000, 70.000.000. I put a time counter in your fillPrimes method to compare it with the time taken by the entire execution of Solution program. If you run this version of DivisorPrint you will get something like: 

Well!! First off I will say that is an impressive amount of work for a sort, lots of research and references. BUT!!! I am not going to sugar coat the rest. The implementation is overly complex and very inefficient, the testing touched none of the edge cases or expected failure states, and the overall design and layout of the code is chaotic and difficult to follow. Your concerns 

Review This is a code review so I will point out some style problems first Function expressions V statements There are several ways to ways you can declare a named function. 

Summing up. I was going to review more but that is enough from me. I will just say that over all you have done a good job. A few style issue, need to improve object encapsulation, missing some ES6 features, and 

Strings Strings are quicker than arrays. A common pattern is to use arrays when a string result requires a separator. 

...as it is much clearer what the intent is. Use quotes not apostrophes To avoid confusion with template string declarations delimited by Back Quote try to avoid using Apostrophes (AKA single quite) Don't duplicate variables The object creates the object and assign the property the value of the argument . This is just a duplication as the only place you use is in the function it is available as the argument Design You are on the correct path to using JavaScript to create private (protected) and public states. Though there is no need to create the objects as you can use the function scope to hold the private state, including functions Simple example of a object with both public and private states, using getters and setters to protect type ( as a ), and access to private state from private and public scopes (eg function 'show') 

I did a little modification in the class DivisorPrint and in the class Solution if you run both again you will understand why the first is slower. I change the scanner instantiation to do the process automatically without the need to enter the numbers manually. 

So... the Solution.java algorithm solve the problem in about 2 milliseconds. Your optimized method alone took 12 seconds in the first iteration. Even if in the subsequent iterations it taken about 0 millisecons if the subsequent inputs are all covered by the numbers in map, it would only tie the game after about 6K iterations! The problem is what this type of optimization don't work very well in this context: in the Solution.java code the programmer has used only primitive types and keep the calculation very simple. That map and lists you've used and the related operations, all the autoboxing and unboxing needed, are to much expensive compared to the use of the purest java. 

Name conventions: you have to pay attention of Java widely used name conventions: Java code conventions