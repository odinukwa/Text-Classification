It is good practice to design away unnecessary else conditions like you have here. There is no reason whatsoever for your else condition here. You already do a good job of bailing out of execution when you have the insert conflict. This could just be: 

When inserting votes, why make a call (and 2nd query against the DB) to ? You could just set value to 1 on insert and/or have default value for that DB field be 1. 

But, I find it best practice to keep animations related to a certain set of functionality within their own queues so as to minimize potential conflicts with effects you might add in the future. Like say you added some functionality in the future to change some of other property/class on , if the effects were in their own queue, they could be applied to the element simultaneously with the icon loading effect without causing undesirable interactions (obviously other than if they impact the same CSS properties in the class). 

I think @holroy gave a good answer, regarding the function itself. I wanted to add some thoughts around your unit tests. With , you are supposed to put the expected value as the first argument, not the second. 

Why do you only have two suits of cards? Why numbered 2-14? As opposed to common J,Q,K,Ace nomenclatures? This looks to me like someone who does not have forethought to move between numerical values, that may be needed for calculation/comparison to values that are meaningful to the user. 

In your one public method, you do nothing to validate that the parameters passed are reasonable for use with this function. You should validate and fail out (ideally with some sort of exception) if proper dependencies are not provided. You should definitely not be setting up dependencies in your private methods as you are often doing (reading user input, instantiating related objects, etc.) Your public methods are your contract with the caller. Your caller needs to give you all the dependencies you need. You need to validate those dependencies within the public methods such that the private methods that might be called from there know with 100% certainty that their dependencies are set up exactly the way they need to be. Otherwise, you get into having to have validation code sprinkled all across your class methods. 

What value do you get from having this in a function? Right now the only thinkg your function adds is try-catch handling (something that can easily be done outside the context of of a function) and actually stops code execution if there is a failure (something you really should leave up to the caller to decide how to handle). If you truly insist on having a function ere, at least name if something meaningful like , that clearly indicate what the function does. 

I admit I don't understand the need to stand up the dump and compare it with the production database, especially if you are not going to retain the dumped database as a hot standby or similar. The tools give you significant flexibility in how you can log/handle errors that may come up during the dump process, as well as various performance, consistency, and table selection options. What value are you REALLY gaining from just matching a list of tables? For a large database you could be consuming a lot of resources and time to go through this step. If that is your case, maybe you perform this test at some sampling interval as a sanity check. If you find that your daily backup is THAT critical to your system recovery plans, then I would suggest your overall architecture might need revisiting. Why not have a read replica of master you could dump every X minutes/hours (depending on dump time) without impacting performance on production (and also giving you point-in-time recovery capabilities). Or, better yet, why not begin thinking of cloud-based solutions like Amazon RDS that can basically abstract away all of this logic and effort from you, allowing you to use single command to take database snapshot, restore from snapshot, etc. The technology in this space has evolved pretty far past daily database dumps for use cases where you need high availability and/or more robust recovery capabilities. That being said, I think you have put together a very well thought-out script. It is simple, well-documented, and clear in presentation. I think this could be useful for you for basic dump operation. I would just encourage to think about whether some of commentary above is more applicable to your use case. Some more specific thoughts: 

It seems clear that you two are not working using a common coding standard or styleguide. If you are going to collaborate, you should agree on this so that you don't end up with poorly written code that varies from script to script and class to class. I would recommend looking at the PSR standards, particularly PSR-1 and PSR-2 as a starting point. $URL$ You should enforce whatever style you decide upon using a style checker before committing code to your repository. I would also suggest that you both familiarize yourself with $URL$ as a reference you can use to help guide your development. 

Then we want to define a "class" in javascript for this selection tree. Here we assume this class can use jQuery as a dependency and that we will focus on caching the jQuery collections on the concrete object produced from the class prototype. This class could (and probably should) live in its own file that could be included on pages that need this functionality. To continue to to think about re-use as we design this class, we also give some configuration options (along with defaults) that let user specify different id's and class names that the class can use to set itself up. 

You are duplicating work in your function and in making your database inserts. Consider a method like . To both validate the images and read them into an array that can be used directly in code shown above (i.e. removing need to recalculate file location on server), or provide result on validation error. So perhaps a usage pattern like this: 

I honestly don't see what value this brings as opposed to just letting classes work directly with instances (or a common instance). Below, I walk through the code and give more specific thoughts. My comments are within multi-line comments. One common comment I would make is that your code has no comments in it at all. Comments are just as important as the code when it comes to maintaining a code base. You should have comments in cases where there may be question as to what the intent of a certain section of code is. One can easily over-comment their code, but I would rather someone who is starting out do that than have no comments at all. You will eventually learn through practice when comments are most appropriate. users.php 

Don't hard code database credentials into your classes as is suggested in your comment. This should be derived from configuration, not in your code. Ideally, these shouldn't be a part of your code base at all, but rather derived from environmental configuration. 

This eliminates all those nested ifs. Your code is also extremely densely packed making it hard to read. You should really try to keep your lines under 80 characters, breaking longer lines across lines. And while I am normally a big proponent of meaningful variable and function names, you seem to almost take it to the extreme, using overly verbose variables when sometimes it does not seem necessary. Take for example how in your for loop you store the array length into when something short and simple like would be just fine since it is clear what is happening here. 

I would consider using SPL's RecursiveDirectoryIterator and RecursiveIteratorIterator for this. This would eliminate the need for the function itself to be called recursively (which is generally a good thing since PHP does not perform tail call recursion optimization). 

You are not doing anything on your public class methods or functions to validate data passed to it. For example here: 

Where are you just ing objects in you ajax responses? Should you be wrapping in HTML (since you are directly ing into DOM, or use are something similar to give you an actual formatted response? 

This guarantees that these objects are passed a valid dependency upon instantiation. If you try to pass anything else to the constructor, an exception will be thrown and the object will not be created. It fails loudly. This is desired behavior, as the calling code can then do whatever it needs to do to handle the failure condition, which would obviously include not trying to conduct any further operations against that object as would happen now with your current code. Your setters probably also need validation. For example, perhaps you need to fail loudly if a non-integer (or integer value in string) is set for ID value. Perhaps you need to fail if an invalid vote type is attempted to be set. 

In class A, why store both an instance of the class and an instance of PDO? If you really wanted to stick with singleton I would simplify this down to something like: 

You are not really implementing in plain JavaScript in that you are using jQuery inside the function. This seems to be an odd choice. Are you using jQuery or not? You should make a decision. If you are using jQuery, then I don’t know why this function would exist at all. The function name itself is meaningless and does not at all convey what the function does. You are not url encoding your query string. You are not handling case where your asynchronous fails to return 200 response. You are using loop counters where you don’t really need to. It makes no sense how you build a query string then split it apart and then reassemble it. Code style is problematic: