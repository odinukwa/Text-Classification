I'm looking for some way (tutorial, library or build in option) to draw texture on JMonkey in real time. So I have 2 images one a normal texture that is fairly big(4000x4000) and another much smaller texture (100x100) the second texture is white(or we can set alpha high) with something drawn on it (say a tree) now I would like said drawing (tree) to be drawn on the bigger texture in such a way that it does not massively slow down the system and that it easily ignores the unused pixels. I already know I can use a for loop to change each value of a texture but that is a CPU computation I would much rather, if possible, offload this to the GPU. 

One interesting solution might be to first draw a line which you want the player to follow then draw obstacles between random point in space above and bellow the line. You can then tweak difficulty by how many obstacles are spawned the with of this line and how complex the curvature of the line is. Easiest to get this line right is to first generate a set of target points. You then write a simple ai that tries to go up if it's bellow the point and go down if it's above the next point. You then record the height for each position per unit of width of the map. Congrats you know have a useable line which the player could follow, increase the number of points for a more difficult map. Now you have this line you generate sets of random point with a height between the height of your screen and you line (add a value to the line to make sure the player fits). And draw an obstacle between the 2 points. Repeat as for bellow the line and for the number of obstacles you want to place (remember more is more difficult). Another thing to note is that you can add a constraint such as "within a certain radius" or " not crossing another obstacle" by simple testing if the constraint holds true and if it doesn't recreate both point. And you are of course free to place single point obstacles as well. Of course an alternative is to just place obstacles between sets of random point and let the player deal with it. 

I'm working on a unity game where I want to change the color of a material from within a script. The material applies to a line renderer. I currently have the following script: 

I have a number of objects (mostly prefabs) that have their transform origin in inconvienient places such as about 1 unit to the left of the actual geometry or somewhere inside an object where it's hard to see. Is there any way to move these transforms without actually moving the object itself? This is in 3D. 

What you will need to do is replay the entire game on your sever. If you use randomness in your game then store for each player the random seed you send them on your server and then have the server play the game to validate that their moves do indeed lead to a victory. This has the advantage that other types of cheating won't work either. If it's multi-player you can also ask the loser to send a message as well and then make a sanity check to see if the same player keeps losing against the same opponent. Now let's for example look at a game of chess: As you might know it's easy to represent chess games as strings. If you receive such a string it's fairly trivial to detect any illegal moves and games that didn't end in a win. So you can at least check for a valid game now. If you play against an AI you can also look at what seed the AI used while playing (send this to him from the server and store it or else a player can keep playing against the same AI by messing with the seed->keep sending the same message without actually playing). You can now check if the moves the AI made check against the behaviour you would expect it to have given it's current state. If you are smart you even can even tinker with the random generator to be based entirely on the original seed and the moves made so far as this means that you will not have to validate every AI move but can just sample a few of them (and if a player repeatedly sends bad AI moves you can simply ban him). If you play against another player you can also let him validate the game and check to see if a given player/IP-adress is losing far more then they should. 

It depends, if you want to build a city you can either do so procedurally (which also allows endless regeneration) or you can do so manually. But even if you do so manually you will likely want to duplicate a lot of things, for example you probably don't want to model each lamppost individually but instead keep one model for all of them. You can do the same for entire building especially when you copy over a building and then make some small changes (change the number position of tables in the houses ext). But no matter how you do this you will have to model every object. A good system if you want to do this procedurally is by first generating a region map (this part is rich this part is poor industry goes here and shops there). Then one you know what region you are in creating a road map. You can then divide the free regions in areas where buildings go and then look into a folder with different buildings you have created, each building in this folder should contain regions and parameters for where various objects inside the building can go (and maybe even make the buildings slightly dependent on the space they occupy so that a 2 by 3 version of the building is slightly different but still generated from the same basis as the 3 by 3 building). You then add is details to the streets and maybe some people and you are done. Be warned that if not carefully managed a procedural city can end up feeling very bland. To prevent this apply the following techniques: 1 many different types of regions, to somewhat offset the cost of this remember that you reuse some of your old buildings. 2 a great deal of variation between regions (and maybe between streets). This can be the simple things like changing street lights or by making different cars stand in different regions (what is a Ferrari doing in the poor part of town?) 3 some uniqueness to regions, allow buildings/objects that normally shouldn't be that this can create a feel that something is going on here, maybe that is and old factory standing near the rich part of town, maybe that Ferrari standing in the poor part of town really does belong there (just a lot fewer then in the rich part). Manually you will likely want to follow the space steps but instead of having a computer do it you do it. 

They are historical figures, basically anyone who has been dead for a long time (80 years+)). You can basically do with these people as you please Anyone who serves an important public function, games are a form of media and are therefor allowed to report and display people with public functions (politicians and related). Note that this is more limited as this has to remain fact based. Parody is protected speech: you are allowed to make a parody of any person who you can reasonably make a parody of, this is however usually limited to somewhat famous people as otherwise it's very difficult to get a parody (this is always very difficult to get right). Anyone who has given you permission (obvious) anyone who (and whose family) is unable to sue you for whatever reason (for example if they would get arrested if they got into your country or you know they won't be able to sue for any other reason). Note that that technically doesn't make it legal but you can't be punished for it. In these cases make your own ethical decision. 

You need to find players somehow, the first obvious step is to tell your friends, if they like it enough to also tell their friends this can be a good start. A second point is to post about it on some forums, not on the general spammy "play my game now" way but more of a hello I'm and have made a new game and am looking for some advice ext. this can help you gain even more players. Once you have this going you can send it to some youtube game reviewers/let's players who will then hopefully play you game and get you enough media attention to get you to the top of the play list. The basic system is that each download you get increases your chance of getting in the initial top so you need to use methods outside of the store to get a number of downloads required to do well in the store, use a combination of online and offline methods to increase your chance. 

You might be interested in a so called quad tree. A quad tree is basically a structure where you divide the area in boxes and put all objects in lists on these boxes. You can then check for collisions only in the boxes that are actually in range of the object. The advantage of quad trees over say 2d arrays is that you they scale very well, if you have a large area with nothing in it and a small area with a lot in it then most other solutions will not work as well. This is how to maintain a simplified quad tree: 1 If a box loses an object check if it's now to small, if it is merge it with another square 2 if a box gains an object see if it's now to large if it is split, if you split an object always do so by spiting it over the largest side (a 10-20 should be split along side the 20 axis) and at such a position that both boxes now contain an equal number of objects. 3 Every box stores in it all of it's neighboring boxes and each object stores in which square it currently is. Now if you want to check if an object is in range start by checking if it's box is in range if it is check for each of the objects in the box if they are in range and then check repeat this check for all neighboring boxes (recursive). This does however carry a bit of overhead so if your range is likely to be larger then say 25% of the map it usually slows things down. I think that what a game as Gratuitous Space Battles (at least for ai) does it first check if a ship is in range (any part of a ship is in range use a square for this) and then check each individual part. What most real games do is use a combination where large scale AI calculations are ran on the second system and the first is used for collision detection (and short ranged stuff). 

And what's also unclear to me is how I can later chance the Beta value used in the shader? Any ideas? 

This is a quite complex problem, are you sure you need to optimize this (how big are the areas?), One options is to generate a 2d array for each power (note different orientations = different powers)and use it to store how many chars you can hit if you target that position. You can calculate this by picking each character and then increasing each position that could hit that character by one. You then keep track of the best square and target that when you have checked each position. So 

I have put the animation type in legacy and the generation as store in root (Depricated) as suggested elsewhere, this did not work. The animation works in the import/annimations view. The origenal comes from blender. And all f this is in unity 5.