There is nothing magical about OSMC; it just prepackages all the executables you need to run a media center, and gives you a nice interface. IIRC, it is based on Debian, so you have two options: 

In this case, the power the speaker draws is limited by the GPIO pin's ability to source current, which, if memory serves, is of the order of 10mA. You won't be getting much use out of that speaker; it will look like a short-to-ground to the pin. 

You obviously do not need internet access to do this -- why would you? If you want to work with ad hoc mode, just configure the wireless interface for ad hoc mode (read the man pages for and ), use an RFC1918 subnet that you are not otherwise using (e.g., 192.168.100.0/24), and set up to give an address to your android device (or configure your android device with a static IP address). Or you can use hostapd and set up the pi as an access point; you'll still need to decide on what address space to use, and you'll still need to set up dhcpd. Of course, none of this is Pi-specific. 

and wait for a while; sdcards are not very fast. Usually the number of sectors will be a multiple of some power of 2, and you can increase the copying speed a little bit by increasing the block size and decreasing the count, keeping the product constant. To feel a bit more comfortable with how partitions are laid out, use the non-graphical version, , and specify units as B (bytes). /ji 

Try the standard output, see if you like it. If you don't, get something more expensive. Beyond that, any reply you'll get will be purely subjective; the objective measurements (SNR, frequency range, etc.) are all available at the respective spec sheets. 

Use to enable the camera. If it still doesn't work, you either have a faulty cable or a faulty module (I've had both). 

The first article you are referencing is full of errors. I just corrected some of them. Set up your Ethernet static IP address in , but do not give it a default route. Let's assume that your home network is , that your router is , and you want for your Ethernet interface and you want a DHCP-assigned address for the Wireless interface. Now, for the complication: if you have both interfaces on the same network, by default they could both be used to connect to local machines. This is not what you want, though. You want local traffic to go over Ethernet, and traffic to the rest of the Internet to go over WiFi. In your , configure to have a local static address, but note how you are not giving it a default gateway. 

I don't know why you are using protobuf 2.5.0, but I suspect it's because hadoop requires that version and won't work with 3.0.0. I'd suggest just getting stuff from github, like this. In general, piping the output of curl to a shell is a bad habit to have (from a security point of view). It's OK in this particular case, of course, but I took this opportunity to point out a bad habit that may bite you in the future. 

Let me answer a somewhat more general question. If what you are stacking are real hats (they have an ID EEPROM), yes. If both hats are using the same bus, say, I2C or SPI, a good designer would either have provided little short/break pads to change the I2C address, or alternate CS pins. in your case, one of the components is a simple breakout, not a hat, so it's up to you to decide how to connect it. Here are some bits of advice: 

If the SoC could support more, the designers would probably have included more memory, as others pointed out. There is a much more important reason, though: cost control. The price difference, for that kind of part, between 512M and 1G is under USD 1; both are around USD 5. Even an 8G IC in that category is around USD 14, so you might think, big deal, up the price a bit. It's not that simple. The 3 retails for USD40; its BOM is probably under $15, so even an extra dollar would significantly impact the retail price, percentage-wise. And although some people might buy a more expensive pi for more money, merely making two versions available increases costs (design, testing, distributing, stocking, etc.), and your $40 1G model might have to sell for $45 instead. You and I might not care, but that does make a big difference to the educational market, at which the Pi is primarily aimed. Also, when you work with a constrained budget, you have to make decisions over what to include. I, for one, am a lot happier about having wifi and bt on the 3 than I would be with extra memory. Your experience my vary, but so far I've never needed more memory, but everything I've used the pi for needs WiFi, so saving me $5 on a wifi dongle was a choice I like. If you absolutely need more memory than that, there are other (more expensive) options around! 

Check with that your device is indeed being scanned. Also, the original Pis had the i2c bus as bus 0, not bus 1; maybe that's your problem? Also, the proper way to do an infinite loop in Python is 

closing your terminal window obviously did not kill your program. However, because the terminal from which your program was getting its standard input stopped existing (technically: the pty side was closed when the terminal emulator window closed), every read() system call of your program returned an end-of-file condition, which your program interpreted incorrectly, thought it read something, and acted accordingly. None of this is pi-specific, of course. 

I've built a little circuit using an INA219 with an ESP8266 that continuously measures current and voltage, and outputs it in a variety of ways (LCD, serial, raw tcp stream, etc). It's a work-in-progress, but if you are curious, here it is: $URL$ 

Not impossible, but here are the obstacles to overcome: First, the SD card knows nothing about FAT, ext4fs, or any other file system. What it does is accept commands from the host interface and either store the data given to it, or retrieve data and send them back to the host. The filesystem interface is implemented at a higher layer. Whatever you create will not (should not, cannot) know anything about filesystems. You need to create something that serves blocks. Second, there are two modes to communicate with the SD card: SPI mode and SDIO mode (there is actually a somewhat-newer physical interface involving an additional row of pins, but I think this extends the SDIO mode, it does not involve a third mode. I could be wrong. SDIO mode is a lot more complex to implement; if you look at the Arduino (and other such systems) libraries for how they access SD cards, they use the simpler, but a lot slower, SPI mode. Your question now can be rephrased as: "Is it possible to implement either the SDIO or the SPI sdcard interface on the Pi?". If this is true, you can then have a chunk of storage (on a USB-connected drive, or even on the on the on-board sdcard) that you are exporting over the sdcard interface as if it were the flash chip that sdcards use. (In fact, sd cards have their own tiny embedded OS that does exactly that -- Bunnie Huang from MIT has written about it, and how to hack it). What you put on that chunk is up to you; you can rely on the other side to store/retrieve data, or you can put a filesystem on it, mount it, store stuff from the Pi side, unmount it, and then let the other side play with it. Obviously, you should have the chunk mounted as a filesystem both from the Pi and the outside at the same time (OK, obvious to me; the reason is that some metadata is not written synchronously, and what's on the chunk of storage that you are exporting may not be a consistent filesystem). Already it's a tremendous amount of work to implement this; you'd have to implement the SD card specification (start at www.sdcard.org; they have the simplified specs available, but you need to be a member to get the full spec). Add to all this the complication that, while sd cards have to support the SPI interface, the host controller may not be implementing it, so you could end up implementing all this complexity to export an SPI-interface-only card, which cannot then be read from the particular machine you may have. There aren't too many sdcard controller chips out there, and you may be able to figure this out by reading the corresponding linux device drivers. You are still not done. Even assuming the simplest (but still not simple) case, where you will be implementing the SPI interface, you are stuck with the fact that the Pi does not support SPI slave mode. So you'd be back to having to bit-bang the SPI (or, worse, the SDIO) protocol on the GPIO pins, which would have to be done inside the kernel with interrupts disabled so as not to mess with the timing. Even if you are implementing a very slow sd card (which you could tell the host when it asks what kind of card you are), that would be about a megabyte per second, or eight megabits, and when you are running at 800MHz, you'll have about 100 clock cycles for each bit in which to read the status of signalling pins, decide what to send out, and send it. Not impossible, esp. if you can take an interrupt at the rising edge of the clock pin and can have some stuff precomputed, but that's a rather tight timing budget, and you'd have to do a fair amount of assembly coding. You are still reading?! :) Now for the good news: you may still fail, but you'll have learned more than most people about sd cards, spi/sdio, file systems, interrupt/real-time programming, and kernel device drivers :)