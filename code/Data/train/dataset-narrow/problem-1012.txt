The class you could add constants in stead of repeating your chars. Then also, you have repeating stuff what you can put together. The naming , are for me to broad. Example of how I should make the class : 

I find this a nice piece of code. Still I found 1 minor and 1 bigger issue. Bigger issue : You say in the javadoc that if more then 1 bassin is found the biggest must be returned. You implement nice testing but this I don't find back in the testings. All your testings have 1 lowest bassin. I should add this to the test : 

Fifth : Your has only all static methods and variable. So no instanciation has to be made. Why not make the class static and maybe even final when you want to be sure nobody may extend that class. 

As long that entity isn't saved (have an Id), I don't show the tab. In mine application I work MVVM so it's a little easier there to notify the GUI when an object is changed. Note: For the 2 solutions : the tab is always rendered in the dom 

Duplicated code You have indeed some duplicated code, sometimes just a little off. You can make abstract class for and and move the duplicated code to there. I should move to an private method of the abstract class. 

When I looked first I was thinking you don't need it cause has operations. But when I read your full I see that you create a map where the key is the same as your value. Next thinking of me : Isn't that a little overkill? Why don't you just put a in your ? The isn't so then you shall need the again. Then you could refactor to this : 

This is a nice example of magic number. It's better that you create at least a for it, but even better could be the possibility to change that value by a property file, with a default of 1000 if the property isn't there. Like this you could give the users easily control that value, because in mine opinion there could be people who want it slower or faster. To the infinitive 

I saw your comment about the question wasn't relevant anymore, but still wanted to answer this one. I have a deep love for Java enums and this I couldn't resist to answer. Your trying to create a factory pattern inside an enum. I do think this isn't the way to go, but I want to point out some issues so leaving this construction working as it is. You work with the static variable to return them in the implemented method . You could refactor it to : 

This is just one bad piece. You catch an exception, doesn't do a thing with it and creates a new exception to be trown. First of all, try to catch the detailed exception if possible. Secondly, If you need to throw the exception back you could use : 

Implement more methods to reduce method complexity Like I already showed you with the switch case, make methods what do less things. This reduce the complexity of your method. Readability of the code comes higher and troubleshooting goes easier. 

So with a small refactoring you create a class what could be good for multiple users application. Other advantage is you can call the method multiple times, where in your setup this was impossible and even dangereous. Naming your class : A class is just so poor chosen. If you see a class name like that, what do you expect what's in it? It could be Utils for Strings like StringUtils or more like MathUtils? As you see at this name, you already know what to expect from it. A better name could be Constants : In android there is a class who have a lot of constants. In stead of doing this : 

In the javaDoc you tell exactly that the key for is and so on. This is then clear for every programmer that will use that method. You see that I cut the sorting to from that method. I prefer a new method for sorting the 2 arrays : 

Known memory leak Your code has a memory leak, not by you but by Apache. There is a tracker for it but it isn't resolved because Apache would not see it as a leak. I came upon this because I'm the OP and the server died after approximate 250 pdf's done. I rewrote the replace function to a simpler search, this means no looking in header and footer, and just returns the first Node what match the text to search : 

Same as h.j.k that you don't have to store the booleans for an if. Return directly in stead of saving into message. Result is like this : 

And change the building from hostNames to a set. You have the advantage with set that no duplicated entry's can be set. The other 3 additional methods can be refactored as well with the use of a set. Problem again : Now that (not so) great idea I can put away. The set itself is NOT and so there are questions about being thread safe. So to the creator of the class, great idea to take the in stead of a . So I'm starting all over. Solution : The is in mine opinion not necessary. However, your setting and remove a entry of the is NOT thread safe. I should use the witch is an atomic operation. The is a operation so I suggest you refactor the also to that method. 

As I'm a more java programmer than C# but I try to answer you as good as I can. The decorater pattern should be able to decorate multiple times. Example : I must be able to decorate with cream and cherry and cream again. In your implementation you can only decorate once. Your decoration class have to implement the interface to so that your test should be : 

The same for your basic classes. I see and always popup(except for ) and and have even more in common. Try abstracting this to an abstract class. Dangerous situation Now I guess you have overlooked it but you have a potential bug in your code. In the class you have the and calculates the distance in async task. You don't provide a setter cause that will break your distance. The fault is that you have this getter. 

It's cleaner code who saves a little amount of memory because you don't need to recreate the every time you call the method. 

You do this check 3 times, I have no problem with that. But what if your maxUsageCount is 0 ? I think this is an unwanted situation so better to do : 

Also with this method you could move the method to the factory. Footnote : I did check your github and was happy to see the refactored enum. It's more logic in that way with separating the concerns. 

Legacy code You know how it's going. You write and erease code constantly. I see in your code an block with nothing in it. Remove the else block cause it's not used anymore, so you get lesser and cleaner code. Method's complexity - Separation of concerns Most of your methods are a little long(we have seen a lot more worse then yours) and can be refactorred to smaller methods with a small specific problem. can be lot smaller and make 4-5 methods for it. Example : The code of your actionlistener. 

Reviewing the code. At first sight it look all nice and clean. Nice formatting of the code. Java standarts are a little differtent then you use, but you are consistent and that is good. The deviation is where you set your . This is normally done at the same line and not a new line. Still some improvement can be done to make your code easier to maintain. Magic numbers Yeah, for some people they are the hell. I'm not saying to convert all your "magic numbers" to but some you have to do. 

This is not how you should use it. I come with a , or even a to the shelter, not a . The usage should be : 

Logging multiple languages While you do make usage of logging, you write them in sometimes in Dutch and sometimes in English. Please try to hold to 1 language, preferable English for the logging. Static or not? 

Time to review, while I think your second line just have a typ fault I will not consider that. Implement abstract method with use of generics. All your Service extends . I see the method for AService. I see the method for BService. I see the method for CService.(I asume typo?) You can put this abstract method to the BaseService if you use generics. So it could look like this for BaseService : 

Opening and closing resources As last in this class is for me the absence of closing your resources. This is just a nice example to create memoryleaks. Summary You see you have good experience in programming, it's a nice and readable code with really tiny things I could point out. I hope this review could help you in one or more points. 

A good usage of the final word and array but you create this array for each instantiation of the class. Better could make that field also so you have instantiated this variable once for all the different instantiations of . Final keyword in other situations 

This could be better set as java doc in stead of normal comments. Like this if you generate the javadoc, people who read that will also see your comment. same or not the same 

Its a strange set up and you can make a mistake when you call this method, by not setting the length of the array big enough. At least this you should be doing : 

This can be done easily by creating the Node in method. With me I added the creation even in the Queue class, so I could return the exact from the Also, throw an error if some people come with because you do not shelter this type of creature. Also with returning this is mine code : 

This is much easier to refactor. Just change your constant, compile and your off without having errors that could be raised if you forget to change your for loop. Now why do you count 65 plus? What is the meaning of 65? You use multiple time 65. When you need to change one, do they have to change all? If the answer is yes => certainly make a constant, otherwise I suggest to refactor to a constant but this is not so important. Scoping of variables The default scope is package-private. All classes in the same package can access the method/field/class. Package-private is stricter than protected and public scopes, but more permissive than private scope. Are you sure you want that scope for all your global variables? 

Your list will be empty and your will have incorrect value according this new list. Program defensive and return an unmodifiable list back so no one can change it with the getter. 

The code is actually a TemplateBuilder. We have 2 different templates, French and Dutch. We need to change the template and then convert it to PDF so it can be stored in the DB later. The main method is . What am I looking for? 

Third, in this case the whole try catch you can remove cause you trows through the method the exception to higher place. Use braces for if 

Let's talk about improvement of your code. You know even numbers are never primes. So a first step is to raise the for loop to Second, This is correct but make 1 if before you do this : The if should check if the square root of trial is lower then the prime number. If that is the case, you can abort your for loop cause no more matching results will be found. 

Same for this but I should make an abstract method and make the implementation later cause it's for the 2 classes a little different : 

With this implementation you could ask an id for each class. This is because the is also thread safe for some methods. Important note : Your generator will reset himself after server restart so usage for generating an id for storing in database is a bad idea. You could also just return the . It doesn't matter if you are using a lot of threads and every thread knows that instance of the . The will stay threadsafe. Footnote : Wrote in java 6, with higher java you could refactor the instantiation of the . 

First of all you make 1 big fault by saying that your classes inside are private. They aren't, they are , more info on site of oracle. Then, let's start with the enum. Your is also package private. => change them to private. Your getter for the code is also a little off the normalisation, let's try to call it . Final result could be : 

As you can see this is already a lit clearder of what it does. You put yourself a white space just before the for loop. You seperate 2 different actions there so refactor this method further so it will look somthing like this in the end : 

After seen this question, I had the feeling it could be better with more OO programming. So I started to create mine own way, with more OO, less code and easier to read. I was happy with mine result until I did benchmark it with your code. Result of 1000000 iterations : 

Execution is almost the same. But now we are sure when is changed magically the next step it will correct itself. Further, this could be refactorred a ternary operator :