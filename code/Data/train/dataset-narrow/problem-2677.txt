If I have to guess I think you are calling initialize function every time you try resuming the game. You just have to avoid calling it when the game is resumed. Remember there is a diffrence between launching game and resuming it, and initilize is only used for launching game. 

where is acceleration and is object's previous velocity. Also to handle collisions I've used a method which is somehow different from those I've seen so far. I'm detecting all the collision in the given time frame, stepping the world forward to the nearest collision, resolving it and again check for possible collisions. As I said the world consist of very simple objects, so I'm not loosing any performance due to multiple collision checking. First I'm checking if the ball collides with any walls around it (which is working perfectly) and then I'm checking if it collides with the edges of the walls (yellow points in the picture). the algorithm seems to work without any problem except some rare cases, in which the collision with points are ignored. I've tested everything and all the variables seem to be what they should but after leaving the system work for a minute or two the system the ball passes through one of those points. Here is collision portion of my code, hopefully one of you guys can give me a hint where to look for a potential bug! 

There are three common approches I saw in game engines, I'm not sure about XNA supporting all three but here they are : 

with the information you provided I think you can use A* with just a little modification. in a normal A* algorithm, you mark every node as you pass over them to make sure you won't ever pass it again. That is the exact part that makes problem with the Items. The key change is to remember what was your items when you previously passed from a node. here is a sudo code explaining what I mean: 

first of all you don't need the character to be a tile, your character is basically some ccNode Object (it can be a sprite, a tile, an animated image or whatever) and every ccNode instance has a boundingBox (I'm not sure property or function) you can easily check if two bounding boxes collide or not. depending on your layer type you can use either one of these two sudo codes: 

You should retain each animation created in the last line of . something like . And later when this class is getting destroyed (in or whenever you don't need animations any more) you should release all those classes you retained the animations to mark they are not needed any more. Note that you should not delete anything, if those animations where needed in some other class, deleting them will result in that other class malfunctioning. And if it's not needed anywhere else, releasing an instance of (grand parent of all cocos2dx objects) will automatically delete that instance which means that object will be deleted twice that will result in access violation. 

I'm not familiar with either obj-c nor opengl (I'm using cocos2d-x in c++ and occasionally needed to add some basic opengl function), but from what I know the code above should work. 

I guess you can use 3dmax/maya or other modeling tools and just render you objects there. you can render your object with very high quality and with complex rendering tools like raycasting. if you want you can also create orthographic camera in modeling tools to create a real 2d image for you. 

There is a limit in box2D configuration file, but the main problem is with how you implemented bubble. The rope length should always be a less than a value, meaning it shouldn't become longer to give that big reaction in the first place. 

start from from one of the empty cells. using BFS algorithm, mark all the cells in that area. add all the nodes visited in previous step to start list of new BFS algorithm, and using it explore through the walls until you find some other empty area not already visited clear the path your second BFS took to reach the new area. repeat process from step 2, until all the cells are visited. 

I know it's probably not the best way to do job but I'm sure it'll work. and if you are targeting anything other than windows you just have to find equivalents for HWND value and createwindow function. they sure are somewhere in codes since almost all window systems either windows or non-windows share same logic. 

Also we don't want this to happen only once, or else we could simply run a action. So we wrap the whole sequence inside a Action, which means this should be run more than once (in this code 5 times). 

I'm using cocos2d-x for a while, it's a game engine based on c++. (it actually a c++ port of cocos2d-iphone). using this engine you can easily run and test your codes on windows and then compile the same code for iphone/android export. 

All that being said, people will cheat, whether you like it or not. But using these methods you can only reduce the number of times they cheat and that's the best you can hope for. 

again note that length is always some positive value but it can be equal to zero (where all elements in your vector are exactly zero). you have to check if a vector's length is zero you can't compute a normalized vector! 

You can simply remove object i from the vector using and then to process everything for the new bullet in i'th position. But this way vector will move all the object after the that specific bullet, meaning this kind of removal is O(bulletArray.size()). But usually order of the bullets is not important, so you can simply put the last bullet in the i'th cell, and only remove it's spot. This way it's much more faster since these operations are O(1). And it's implemented as again you need to decrement i by one to check this new object in this i'th position in the next loop. 

People reading about a game in the net is a problem for all games, not just level-based puzzle ones. For instance a simple search can give you detailed walkthrough/cheatsheet/solutions/guides to any game you can think of. Even games like Fifa or LoL that obviously has no definite solution in the first place. But that being said you can more or less control people checking for online material. Here are the few tricks I've seen being used: 

It's not a bad design by nature, but it can easily get out of control. In fact you are using that design in your everyday codes. For example vector knows it's first iterator and iterators have pointer to their container. Now in your case, it's much more better to have two separate classes for GameEnigne and GameState. Since basically those two are doing different things, and later you might define lots of classes which inherit GameState (like a GameState for each scene in your game). And no one can deny their need to have access to each other. Basically GameEngine is running gamestates, so it should have a pointer to them. And GameState are using resources defined in GameEngine (like rendered, physics manager, etc.). You can't and shouldn't combine those two classes into each other either since they are doing different things by nature and combining will result in a very big class which no one likes. So far we know that we need circular dependency in out design. There are multiple ways to create that safely: 

I guess that's some issue in box2d, there is such a bug to increase performance. since more accuracy needs much more computational power. to fix that issue I guess you only need reduce box physical sizes (for example you can create a 84px*84px rectangle for a 86px*86px image). you can also fade the pixels in the edges to get better results. 

upgrading usualy doesn't consume space but building some new guns need more space so if I were to balance them i would put higher price for upgrades, and besides i think it's logical that upgrades take less time than new building, but that's for you to decide, so i think for an upgrade that duplicate a tower's power i would set 1.2 of the tower original price and 0.9 of it's building time. the same senario goes for rts games, except map size limit and it's usualy population limit that prevents you from building lots of things. 

Another possible optimization would be to not use priority_queue... Using priority queue won't let you update each node distance individually (which is needed for A*). Using a custom implementation of min-heap, you can fix that issue. This way pushing, and popping nodes into the heap would be of O(logn), and so will updating be. But size of your heap will always be equal to the number of your open nodes. 

you can implement your object control in map calss, but that would create some god object and it'll be too difficult to debug or add features your program in future. there are two approches for this problem : 1- one is to handle all the inputs in the player class, and then ask map to move your player as player calculated, this can also be applied for any other dynamic or static objects in your scene. note that in this apprich map class only check for collision or other similar things , and doesn't care how or why is the object moving. 2- you can also share all map data with other dynamic classes (using physics engine and creating an object for every child of map is a way of doing this) and check all the thing you have to consider while moving objects inside their own class. the first approch is much more simpler and take less time to implement, because you consider all your object the same and move them in a same manner, but in the second aproch you have much more flexibility with your obejects moving (for example you can make some object to ignore collsion)