If you do want to bias the first midpoint selection, the easiest way to do that is to cheat — just start with a three-point list, and reduce the iteration count by one: 

For example, let's say you have n clients involved in a game. When then first n−1 of them send in their moves, you just check that the move looks valid and send back a message saying that the move has been received but you're still waiting for other players to move. After all n players have moved, you process all the moves you've saved up and send the results to all the players. You can also refine this scheme to include timeouts — most I/O libraries should have some mechanism for waiting until new data arrives or a given amount of time has elapsed. Of course, you could also implement something like this with individual threads for each connection, by having those threads pass on any requests they can't handle directly to a central thread (either one per game or one per server) that runs a loop like shown above, except that it talks with the connection handler threads rather than directly with the clients. Whether you find this simpler or more complicated than the single-thread approach is really up to you. 

Depending on your jurisdiction, simply using your title (and perhaps marking it with a ™ symbol) may qualify it for protection as an unregistered trade mark. The Wikipedia article is pretty short, so let me quote it in its entirety: 

There's certainly more than one way to do it, but personally, I'd skip the separate threads entirely, and just use an event loop. The way you do this will depend somewhat on the I/O library you're using, but basically, your main server loop will look like this: 

Alternatively, if you don't like spherical coordinates, you could use a simple cartesian (x, y, z) coordinate system. Just put the origin at the galactic center, have the z-axis point out of the galactic plane, and arbitrarily choose a direction in the galactic plane as the x-axis (with the y-axis also in the galactic plane, 90° away from the x-axis). An advantage of this system is that you can calculate distances simply using the Pythagorean formula dist(a, b) = sqrt( (xa − xb)2 + (ya − yb)2 + (za − zb)2 ). The main disadvantage, compared to the angular coordinate system suggested by Marqin, is that you'll need to use this formula even for distance from the galactic center, instead of just getting it directly from the first coordinate. Of course, if precise distance from the galactic center doesn't matter much in your game, this might not really be a disadvantage anyway. (Other possibilities could include a hybrid "cylindrical" (r, θ, z) coordinate system, where position within the galactic plane is given by distance r from the center and an angle θ, but distance from the galactic plane is simply given as in the cartesian system. Given that the galaxy is mostly a flat disc, this might make some sense.) 

I'm not familiar with AndEngine, but the obvious general approach is to turn off collisions between the character and platforms whenever the character's vertical velocity is positive (i.e. the character is moving upwards). If your platforms (or character) have a non-negligible thickness, you may need to deal with the situation where the character partially overlaps a platform at the top of their jump. There are (at least) two ways to handle that situation: either ignore collisions with platforms which the character already overlaps (which causes them to just fall back down if they didn't jump high enough to fully clear the platform) or detect such overlaps and move the character up until they're standing on the platform, perhaps accompanied by a special grabbing and climbing animation. Note that, if your platforms are not always perfectly horizontal, you'll need to take some extra care. First, when the character is running uphill along a platform, you obviously don't want them to sink into it; this may require separate treatment of running/standing characters as opposed to jumping ones. Also, simply checking the vertical component of the character's velocity is not always correct for highly tilted platforms; what you really need to test is the vector dot product between the character's velocity and the platform's (upward-pointing) surface normal. You may also want to set a slope cutoff above which platforms are simply treated as walls, and cannot be jumped through. (As an alternative to a simple cutoff, you could do something like taking the platform's upward-pointing surface normal, rotating it around the vertical axis to face the character, and then taking the dot product of the character's velocity with the rotated normal. If I didn't mess up the math, that should restrict the range of directions from which the character can pass through the platform as it gets more and more vertical, like this:               Here, the thick black freehand line is the platform, and the cones show the directions from which the character can pass through three different points on the platform.) 

Don't do drawing on the server. Just have the server tell the client what it needs to draw and let the client handle the actual drawing. Have the client keep track of the information it's previously received, so that the server only needs to send it a list of changes rather than sending everything again. Have the client predict (as far as possible) what will change based on the player's actions, so that the server only needs to send it any changes the client doesn't already know about (such as those caused by actions of other players). 

The time needed to solve a 15 puzzle depends a lot on how the player approaches the problem. Those using a systematic solving method will solve any solvable puzzle in about a minute or two, depending on how much practice they've had. On the other hand, a systematic solution will generally take about the same time regardless of how well scrambled the puzzle is. Meanwhile, people who don't use any kind of systematic approach, but just slide the blocks around randomly and hope that they'll fall into place, will probably not manage to solve any but the most trivial of puzzles in any reasonable time, if ever. If they haven't solved it in 10 moves, they probably won't manage to solve it at all. (Solving a 15 puzzle systematically is easy enough that even new players may figure it out on their own. Just the two rules — 1) solve the puzzle in numerical order, and 2) don't disturb completed rows unless you absolutely have to — will essentially do it, even if you may need to experiment a bit to figure out details like how to get the last block in a row in place.) Anyway, the point of all this is that the "difficulty of the puzzle" is not well defined — it depends entirely on the solver. Sure, you could use Markus von Broady's suggestion to guarantee that there exists a solution with at most n moves, but unless n is really small, most people will either fail to spot the solution or will not even try, preferring their own solution method instead. 

Instead of recording all object positions at every frame, just record the information you need to recalculate them. Generally, this consists of three things: 

I think you're overcomplicating things. The usual way to implement realistic jumping goes something like this: 

You just need a small, constant array of block objects. Your block IDs will then be indices into this array. Alternatively, you could use something like a HashMap to map IDs to blocks. This is generally slower and consumes more memory than a simple array, but it does have the advantage of not requiring your IDs to be contiguous, which might be useful in some situations. 

There are only 24 possible orientations achievable by 90° rotations around coordinate axis, which form the rotation group of a cube, also known as the chiral octahedral symmetry group. Since there are only 24 elements, you could easily build a multiplication table for them. (In fact, you only need a 24 × 6 table, since only 6 of the elements are 90° rotations.) The elements of the rotation group can also be naturally represented by 3×3 transformation matrices — in particular, those 3×3 matrices which: 

Once you have a list of all (possibly overlapping) T-shapes occurring in your grid, what you're left with is a maximum set packing problem. In general, this is an NP-complete problem. However, your grid is small enough (and typically breaks up into even smaller independent subproblems) that it may well be feasible to obtain exact solutions. 

Of course, the words "vertical" and "horizontal" can be exchanged in the definition above. The point is that we need to pick some way of breaking the symmetry so that only one of the possible paths for traversing an open rectangular region is considered. Harabor and Grastien do that by preferring "diagonal-first" paths, but since we can't do that, we have to make do by preferring vertical-first (or horizontal-first) paths instead. It might also be possible to develop alternative pruning rules that produce more "natural-looking" paths, such as preferring the current heading over turning, or perhaps even preferring constantly turning staircase paths. The rule I gave above is simply the most straightforward translation of the Harabor & Grastien rule to an orthogonal grid I could think of. 

Honestly, the first thing you should do is switch to a better algorithm. Parallelizing your simulation can, even in the best possible case, speed it up only by a factor equal to the number of CPUs × cores per CPU × threads per core available on your system — i.e. somewhere between 4 to 16 for a modern PC. (Moving your code to the GPU can yield much more impressive parallelization factors, at the cost of extra development complexity and a lower per-thread baseline computation speed.) With an O(n²) algorithm, like your example code, this would let you use from 2 to 4 times as many particles as you currently have. Conversely, switching to a more efficient algorithm could easily speed up your simulation by, say, a factor of 100 to 10000 (numbers purely guesstimated). The time complexity of good n-body simulation algorithms using spatial subdivision scales roughly as O(n log n), which is "almost linear", so that you could expect almost the same factor of increase in the number of particles you can handle. Also, that would still be using only one thread, so there would still be room for parallelization on top of that. Anyway, as the other answers have noted, the general trick to efficiently simulating large numbers of interacting particles is to organize them in a quadtree (in 2D) or an octree (in 3D). In particular, for simulating gravity, the basic algorithm you want to use is the Barnes–Hut simulation algorithm, in which you store the total mass (and the center of mass) of all the particles contained in each cell of your quad/octree and use that to approximate the average gravitational effect of the particles in that cell on other, distant particles. You can find plenty of descriptions and tutorials on the Barnes–Hut algorithm by Googling for it, but here's a nice and simple one to get you started, while here's a description of an advanced implementation used for GPU simulation of galaxy collisions. 

The option above will resize all the sprites to 32 × 32 pixels (adding transparent space around smaller images and scaling down any that are too large) and tile them with 0 pixel gaps between them. (The double quotes are there to keep the shell from interpreting the as an output redirection command.) By default, montage will try to create a "squarish" sheet with roughly as many rows as columns. If you'd prefer, say, a single-column strip, add the option after the . If you want the sheet to have a solid color background, change the to a color specifier (e.g. or for white). 

As I said, the rule is kind of weird, and I have no obvious geometric interpretation to offer for it. It does, however, satisfy the expected properties that: