You don't strictly need to read a psychology book for that, actually, but The Art of Game Design has what you need. With examples by real developers. 

You could, of course, hardcode all of this in the actual game logic, but that would be awful and would get really messy. Also, you've built yourself a nice event system that you could use for many other situations too! 

I'm pretty sure you're wrong here. You'll be able to get a job in a few years actually. Few meaning 2 by my country's laws, I think. But not a full-time job. There are still options to work when the school is out, and if you're good, and you probably are, then there sure will be a dev company that would want to hire you. A gamedev company? Probably not. But there's no reason you'd actually want to work in one as a starter, AFAIK you could get paid better in a regular company, and work on a game in your free time. Besides, just look at your name, it's almost as if you've already familiarized yourself with the joy of C++ programming! 

I am going to do a language and platform independent approach here. All images should be represented as rectangles. Rectangles are usually just 4 elements long arrays that look like this: . and represent the position of the image. If you want the image to have a falling effect, ie to move downwards, they you will want to increase the coordinate gradually (the axis increases "downwards" in computer graphics, remember that). The and , obviously, represent the dimensions of the image. A click can be represented by two numbers, just the and , as it is actually just a point in space, it doesn't have any dimensions. Now, your problem is essentially checking whether the click happened inside the image. How do you do that? Well, like this: 

I am in the process of writing a 2D game engine, and a dilemma emerged. Let me explain the situation... I have a Scene class, to which various objects can be added (Drawable, ParticleEmitter, Light2D, etc), and as this is a 2D scene, things will obviously be drawn over each other. My first thought was that I could have basic add and remove methods, but I soon realized that then there would be no way for the programmer to control the order in which things were drawn. So I can up with two options, each with its pros and cons. A) Would be to split the scene in layers. By that I mean instead of having the scene be a container of objects, have it be a container of layers, which are in turn the containers of objects. B) Would require to have some kind of z-coordinate, and then have the scene sorted so objects with lower z get drawn first. Option A is pretty solid, but the problem is with the lights. In what layer do I add it? Does it work cross-layer? On all bottom layers? And I still need the Z coordinate to calculate the shadow! Option B would require me to change all my code from having Vector2D positions, to some kind of class that inherits from Vector2D and adds a z coordinate to it (I don't want it to be a Vector3D because I still need all the same methods the 2D kind has, just with .z clamped on). Am I missing something? Is there an alternative to these methods? I'm working in Javascript, if that makes a difference. Edit: it was hard to decide with which option should I go, but I chose option B, adding the z coordinate. Some other design choices that might help others reading this question: 

Edit: We have two objects, and here... The scene is the actual game, while the menu is, well, your start GUI. denotes how translucent (transparent is the wrong word for this) a picture will render. If it was 0, you wouldn't see the picture (it would be transparent). If it was 1, the picture would be opaque, which means that you can't see whats behind the picture. is simply a flag that tells your game whether to render the menu (eg "start" and "highscore" buttons) or not. What we do here is increase the alpha of the game, and decrease the alpha of the menu, making it slowly fade away. If you set to , the transition would last 10 seconds. It is also important to understand that this isn't Java, but pseudocode. You probably have different names for these things in your code. I hope I cleared things up. 

I'm making a game that consists of many onscreen objects, one of which is the player. I need to know which objects are colliding every iteration. I made something like this: 

I have decided to make a simple engine for a new game I'm working on, and now, I'm wondering: what are the essential features of a 2D game engine? Or, a game engine in general? 

I'm making a game which will be completely centered around PVP battlegrounds and arenas. Think something like WoW, but with the RPG part removed. There will just be a lobby, where you can join a battleground and fight. I plan to use WebGL with the Three.js abstraction. So, making a game where people can just hit each other isn't my problem - I'd like to have physics play a big role. I simply don't understand how is that possible with open source clients (open source, because it's a website)! Also, by physics I mean things like burning logs rolling over from a hill, spells that send everything flying around, possibility of dying when hit by a high-velocity object, and so on. I seem to have only two options: A, do the calculations on the server B, do the calculations on the client side With A, the problem is that I plan to use some plugins for collision detection, and I need to have all the meshes and bounding boxes to test, which I only have access to on the client side! Also, physics might be just a bit too much for my servers to handle. The obvious problem with B is that you can never trust the client. If I depend on the client telling me that the player got hit really hard and that he did, in fact, throw the player somewhere, that's an obvious security hole. The user can make a simple script that blocks any messages with a "he got hit" header or something, and become invincible. But, while I was writing this, I came up with a third option, which is to let the client care about others, not just about itself. This falls under the reality checking category, I believe, because if the majority says that someone got hit, and he says he didn't, I'd trust the majority... This option's flaw is that it might be a really big strain on the clients, because this will be a browser game, and my resources are limited. 

I'm not sure this kind of functionality is engine-specific. If you have a way of setting a global alpha, then you could do it just fine. Interpolate the scene alpha and the menu alpha through time, for example, for one second... 

I'm finishing another HTML5 game, and this time I'd like to do some spying business on the players... Mostly just basic stuff: when they are playing, for how long, what upgrades they are buying the most and so on. Now, my first idea was just to collect this information during the gameplay, and then have a Javascript function fire when they close the tab/browser, and said function would send it to my server via Socket.io. This, of course, wouldn't work, because anyone who takes a look at the code would realize it and could start sending a tonne of false info which would mess up my statistics. Questions: 

I call this logic function ~30 times per second, so it's responsive enough. As for the netcode, it's best to record input and only send that to the server. The server only sends back the difference in the game state since the last message (see: Backbone.js diff). 

I'm planning to make a simple, HTML5 game, that would use some elements of the Half Life universe. Basically, it would be a 2D Portal clone, but it would have it's own story, and portals would be different, along with the mechanics of making and using them. Also, how far can I go with this? If possible, I'd like to have Gman, a character from Half Life, walk by a few times, and maybe even use some of the sounds from Half Life or Portal. It's also important to note that I wouldn't be making any kind of profit. 

I think there is something wrong in how you handle systems and entity fetching. Your / shouldn't have a dictionary of all entity GUIDS, but rather, an dictionary-of-arrays that looks something like this: 

You shouldn't do scrolling like that, it is very counter intuitive. Just create a object, that has a position, and then render everything according to the camera's position. Move the camera around, don't change the entity positions, as that can alter your logic and mess everything up. 

This is all if you actually want to create your start menu using a canvas. You might not want to do that, because it would be easier with just HTML. This has several advantages though, like animation and so forth... Also, there is a way to find out the text size. The height of the text is simply the font size, but to get the width of the text to be drawn use this: 

Not all your clients are going to have the same time. One could easily change the date values being sent to your server. 

This has O(n^2), which I'm told is bad. How do I do this more efficiently, is it even possible? I'm doing this in Javascript, and n will usually be lower than 30, will it be a problem if this stays the same? 

Try Facebook. You have to host your game and everything, they just provide the actual playerbase and the social aspect, which are quite valuable. I believe that you still have to code up the leaderboards and all that, and I suggest Node.js + SQLite, it's a nice and robust solution for a simple project. As for the achievement system, I'm not sure. I am not aware of any currently available HTML5 game engine that can handle these, as they (the achievements) can get quite game specific. But, thankfully, they're not hard to implement, let me explain how I would do it... A game can be considered a stream of events. Events, as in "player killed x", and "player gained new level", or "x killed y", you get the point. What you will need to do, to effectively implement achievements, is make an event system for your game. To realize why, I must first explain what these are, although you probably already know all this because you're using HTML. Others might not, so I'll do it anyway. An event system is consisted of events and listeners. You can implement listeners as functions that subscribe to certain events: each time an event fires, that function is executed, passing the objects and some other data to it as an argument. I suggest that you have an EventManager that gets called on each game loop iteration (or less frequently), and holds all the listeners and other information. If you want to listen to a certain event, you simply do this: . This is, for example, how you would implement an achievement that requires the player to kill 100 enemies (it's a pretty bad achievement in terms of game design, but it's simple to implement).