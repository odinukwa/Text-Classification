Exceptions Regarding : Catching all exceptions is usually regarded as a bad idea. I'm not saying this is the case, but consider catching the specific exceptions you expect to happen, e.g. , , etc. Why does the method return a if the string is always empty? Why not just ? Similarly, your checks if the string is null: , this seems redundant. Also, returning a empty/non-empty string to signal that something went wrong does not seem right. Surely, if the API call fails, that would be an exceptional scenario, would it not? Consider letting the exception bubble up to the controller, where the error can be handled. Then, change the return type from to simply . This is how I'd report errors: Web Api: 

What you want is to have multiple producers - and a single consumer. You can use TPL Dataflow's for this. Here, acts as a single-threaded thread-safe consumer. 

I was wondering if there's a simpler way of implementing . I had a look around to see if there was anything I could use, but no such luck. Being a Haskell novice doesn't help either, I'm only familiar with a very small part of the core libraries. Other improvements (naming, conventions, greater generalization) are also welcome. 

As bonus I also introduced you to standard SQL datetime-literal syntax. Let's create some data to play with: 

Use analytic function (you might also consider using or functions instead) to assign an unique number in ordered sequence to each row. This is the standard way to implement top-N, bottom-N and inner-N queries in Oracle. Note that this example doesn't resolve ties. 

The is just for demonstration and is to guarantee the correct ordering of the tables. The is not needed if you have other rules ensuring the id is found only from one table. If the id can be found from different tables just add a wrapper -query (the details left for exercise) to pick the first one only. Now just wrap that inside your PL/SQL as you see appropriate. When some information is not available in all tables it's up to you what is the value indicating missing value. It can be e.g. or or depending on the context. However I'd recommend unless there is other factors that rule that out. Hope this helps ! 

The same goes for properties - so should be named Coding Style You could mark your private field . People often also explicitly mark them as though it's not entirely needed. The type doesn't really represent a role, does it? The name seems misleading. I think would be a better fit. Why does have a parameterless constructor? Using that constructor would result in s being thrown, since would be unassigned. This cast is unnecessary: 

Now, imagine table C depends on table B, i.e., table B cannot be dropped while table C exists. The function will be able to drop tables A and C, but not B, and so it will return . So, I wanted to write a function that takes a list of tables, and calls . If any of the operations fail, it calls again but this time only with the tables that could not be dropped in the first iteration. And so on, until either all tables have been dropped, or progression halts (i.e. all operations in a given iteration fail, due to e.g. a connection being closed) This was my first stab at it: 

This is very much the same idea I'm using to encapsulate "business logic" queries for re-use in PL/SQL code. So if you're looking for a validation of a concept you'll pass my review :) In a comment to the other answer you said this is just a snippet from a package code - that's good you're using packages. For PL/SQL apps in practice all code should be located in a package - a standalone subprograms a rare. The notes: 

is always guaranteed to return a single number so the exception handler for is a dead code and should be removed. If you're just checking for existence there's no point to count beyond 1, thus enter . This also guarantees the returns either or . This might or might not help your query performance (check explain plan). It's a bit questionable if such an utility subprogram should record the exception or not but more information about your error handling implementation would be required to comment further. I usually don't but I'll let the exception propagate to the caller context and then record the full stack trace there. The good thing is that you (I just assume that from the name of ). 

Your implementation is technically correct, but... There is no benefit in using in an web application. All you're doing is deferring work from one thread to another. So, in fact, not only is there no benefit, you're actually adding overhead. I'll quote Stephen Cleary, because I could nevet put it better: 

I could have easily defined these as extensions on or , but I wanted to try and define them for the most abstract type possible, . For this, a is needed (I think). Code: 

Context I'm trying to write a function that drops a list of tables from a database (e.g., tables A, B and C). This function has the following type, it returns a list of booleans indicating whether each table was successfully dropped: 

I then tried to generalize the core algorithm, and remove all references to tables and database connections: 

So, unless you're doing true async I/O, do it synchronously. Alternatively, if you want to expose an async interface, where the implementation may or may not perform asynchronous I/O, synchronous implementation should use instead of . Example: 

I'd solve the problem by providing a PL/SQL procedure that knows the "split"-logic. In the example below I assume that non-splitted rows are not inserted into the table at all but all inserts should be done with the procedure. This is a rather common pattern when there's data manipulations but it is not clear from your problem statement if this is an acceptable solution in your case. I used regular expressions as it's a very handy tool for pattern matching with superior expressiveness and clarity compared to spaghetti. I didn't used triggers as it's not possible to modify the table trigger is attached to. The solution can be easily applied even if you need to read the input data (i.e. non-splitted) from the same table. Example 

I'm afraid you current solution is a prime example of inappropriate use of PL/SQL when plain SQL provides much more elegant solution: 

Your core problem is how to find out top-1 and bottom-1 in a single query. This is essentially a SQL problem and has not much to do with PL/SQL. First I present you the SQL solution and then simply wrap that into PL/SQL. You didn't provided table definitions. I was lazy and didn't tried to reverse engineer your schema but instead created very simple table that illustrates the solution that you can apply to your real problem. Other notes that might or might not be relevant to your case: