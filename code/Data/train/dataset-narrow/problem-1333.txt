You could also benefit (depends on your actual usage) from not using for the compared values - by using a generic the compiler will complain if the types of the two are not compatible (for example, you are comparing to ): 

You can simplify the code greatly without loosing any performance, more likely gaining instead. There is no need to use - you can write directly to the - it will be faster since there will be no need of copy the whole data twice. Next, there is no need to use - you are using it to buffer data before writing it to the disk. The same can be achieved by specifying the buffer size when creating . You should play around with the buffer size to see what is fastest on your environment - usually 4KB is used, in the sample below it is 1MB, but you have to try it on your hardware. You should also play around with the options how to open . You should try what impact and has on your solution. Of course, as the other answer proposed, separating reading from database and writing to the file in two threads might work as well. Try and measure three separate scenarios - just reading from the database (measure separately the query ( and first and then reading the other rows - because it might be that most of the time is spending to initially execute the query, not to iterate through the data), just writing to the file (dummy data) and then combined. This way you will see if there is actual reason to put the two operations in parallel. 

You have to decide if the caller of your method needs to know if the parent was not found or if there is no difference when the parent was not found or when the parent element is simply empty. If the second holds true, then the other answer already describes the correct approach - return an empty list. However, if the caller needs to be informed that the parent element () does not exist: 

I would change your method to use generics (so that the return value is meaningful) and not call internally. This will enable you to use it in more scenarios. 

I personally prefer something like a generic class that allows me the re-usability of a single data structure for handling responses that might fail. The class would look something similar like: 

Preferably though, the method shouldn't return anything that can be modified. I wish I could create it as an instead, however, that would not work with your method. As I do not know how you intend to filter, I chose to keep the . The filter also doesn't seem to filter, but rather seems to remove items from that list, so without knowing how you are using it, I chose to stick with . 

According to your specification, a keyword is defined by a name + a number. It can ofcourse be that eg: would be followed by a number, if that would be the case, I think you could add a comment to the array why these appear to be different as specified. Variable naming I think, in general your code is quite confusing to read. You seem to be using rather unusual names for your variables, some examples: 

This only gives you an idea from how you could reformat your code using this pattern. The last piece of code can then also be rewritten like: 

Ofcourse, as Vogel612 metnioned in the comments, this is not the most optimized way. I just presented it as a way that it contains less code, and that it is separated in single utility functions. The code from coderodde is ofcourse lots better. Instead of deleting my answer, I will simply add 1 more version how you could do it by using ES6 and classes 

From the demo page, I have to say, it looks very nice. I am very curious why you do not use the constructor to call that seems a bit verbose for any user, neither does it look very good to use as it is not a constructor in the strict sense, you don't even need it. For a detailed description, please find it on MDN, where this explanation is of importance to you. If you return anything else but undefined, you will not receive a new Slider object, but just the returned object. 

SharedPreferences - Best method Java provides many ways of storing application data. One of those ways leads us to the SharedPreferences object which is used to store private primitive data in key-value pairs. All logic are based only on three simple classes: 

SharedPreferences SharedPreferences is main of them. It's responsible for getting (parsing) stored data, provides interface for getting Editor object and interfaces for adding and removing OnSharedPreferenceChangeListener 

Visual C++ excludes rarely used stuff from the platform specific. can fail if the file system contains links to the same file that the compiler cannot follow. For example, NTFS5 (Windows) supports hard links, but you can't detect that files are linked if you access the file system across an (SMB) network. What about to use a standard include guard? It works just fine. The one caveat is that GCC didn't support it before version 3.4. 

If the function is a class/struct method, the array can be defined as a static (class) property outside the function, just to avoid instantiating it for each function call. Note that this solution generates a runtime exception if the num value is not in the [0, 2] range. I suggest you to apply the method by using the statement. 

Actually, I think you want to use rather than but this is besides the point. To write to multiple clients you want to make sure that you don't use blocking writes. You might get away with not detecting whether a particular can digest more data and thus you might not need to use (or ) when writing. However, if you want to be prepared for clients consuming data with different speed you might want to receive notifications when a client can digest more data. Other than that, or can notify on both data available in the read buffer or space available in the write buffer. The use is pretty much the same except that you need to set a different flag. Your code is well-made, but there is something you could do to make it more readable and more efficient. Coding-Style 

A memory leak in Java is a situation where some objects are not used by application any more, but GC fails to recognize them as unused. As a result, these objects remain in memory indefinitely reducing the amount of memory available to the application. 

Here you really have to be consistent with your choice. There is no reason why a statement brings benefit to your code, as you are iterating arrays and not an object. It makes the code less readable if such unexpected twists are added. Subtopic variable scoping The use of the keyword in JavaScript and it's scope has been confusing since the dawn of JavaScript. It is important to know that in JavaScript, defined variables are not block scoped, but they are function scoped variables, as this small snippet demonstrates 

True, the code is longer, however, it's commented, there is a clear definition of what the function will do, and what the user of the function can expect. Splitting up single parts of your code into there own functions is a good way of structuring your code, and promote re-usability. Now, another instant observation I might have is your interesting mix of different for statements. Especially seen that they are so close together, I really wonder if there was a reason for you to mix it up, or again, you felt like experimenting different forms of iterating an array 

I hope it still brings you something (yes, I know, I posted 1 year after the original question or something), however, I felt it was a good practice for me as well 

more about plugin creation for jQuery can be learned here Currently, I believe your method takes a bit to much control, and as a user of the slider function, I cannot really do a lot. I can only start the slider, I do not have any actions available to me where I could stop the slider (eg: ) or decide how fast it should slide, and though you offer the it is completely unused at the moment. There is also no way to interact with the slider from a different place in your code, to for example show a specific slide on the click of a button. So I think your plugin is to much in control. 

You also define some variables only inside the for loops and although in most languages that would be fine, in JavaScript 5 they don't belong inside the for loops. ES6 really made huge improvements by adding the block scoped keywords and , so if you would have the chance to use them now, I would really suggest you do so. So as a rule of thumb, keep all definitions on the top of your function, or where you define the first variable. Extract similar code to functions Code duplication is one of the most annoying things in a code base that you could have. Even if you know your code perfectly, still changes to certain parts of your algorithm could be forgotten if you copied the code to other parts. One piece of code that could definitely be extracted into a function, would be this beautiful block of duplication 

Editor SharedPreferences.Editor is an Interface used for modifying values in a SharedPreferences object. All changes you make in an editor are batched, and not copied back to the original SharedPreferences until you call commit() or apply() 

Exception Handling In the case of creating a Robot, if you get an AWTException as you have, remember that this means no Robot was created so you can't rely on it later. Remember also to show the exception description. Typing "error" or "unknown error" isn't so fair for me, you can easily get the description of the exception. 

A static function is almost like a global function: it doesn't need a class instance to be called on. So you only need to get the pointer to the function to be able to call it. Take a look to (or or if your compiler doesn't provide it yet), it's useful in your case as it allow you to use anything that is callable (providing () syntax or operator ) as callback, including callable objects and member functions (see or for this case). Functions aren't comparable, but pointers are. The reason functions aren't comparable is that there is no way to determine if functions are equal (not just in C++, in computer science). I.e., there is no way to determine if functions have the same value. However, by using pointers, we can at least see if they occupy the same space in memory. . Take care when using this, and you may have to perform your own checks when a callback is registered or before you call bind, to make sure that you don't have two duplicate binds of the same function but that occupy different places in memory. To use a callback to customize a class instead of subclassing, with your alternative you can: 

case is handled by the default case, using the fallthrough keyword. Now you are able to apply this method to your code. Following the example, an alternative way to achieving the same, taking into account that the possible values are consecutive and starting from 0, is using an array: 

However, the function objects can not access protected members of "their" object, which may require that you break encapsulation on the host class so that the function objects can do what they need to do. All in all, this seems like a good way to associate an object with external behavior that should be initiated by that object (e.g., a button click handler), but using it to extend the inherent behavior of a class seems like it creates more problems that it solves. The most common example of a good use of this paradigm is for callback functions or event handlers, because the class is concerned with the mechanics of drawing the button and handling mouse events (for a button class), or with managing the network protocol (for a network socket class). In these cases, making the event handler virtual and implementing it in a subclass isn't good object-oriented design because the subclasses aren't conceptually new "types" of their parent classes, just like you shouldn't have to subclass a button to change its height and width. 

for both if blocks. But that should not be the end, you might as well extract the code that checks if the keyword exists in the array, and the extraction of the keyword. In the end, the statement that you wrote can be reduced to this (now I think I understood your code while refactoring it) 

This would now be an abstract class (ie: a class that cannot be instantiated), from which the method has to be implemented still. Also note, that this change means that all methods now changed from modifier to the modifier In the implementing classes you can then implement something like: 

It returns it's own promise, and uses the . In case the result is returned (or another error is thrown), the is called and the promise gets handled by either resolve or reject. In case the interval occurs, the promise gets rejected, and the is also called. Note that if you run the test (at least the es6 one), you can see the time it took before the timeout occured, and it will not run longer. Neither does the then method of the fetch still execute. It is true however that your httprequest will still be open, but I don't think that should be such a huge problem, as it will not interact with your own code anymore. It is still important though to handle the catch of the fetch and pipe it through, so that the interval gets cleared, but that you also get notified of the other errors that might have occured during the request. 

I guess if you just want to validate, you could write something like the following, though i'm not sure if that really answers your question. 

This you could extract to an own function if you like (I don't think I would need it when I check if I know understood your code correctly at the end of the response) 

I think one of the most common errors in today times, is for example handling potential errors, as you try to do here: 

Suggested rewrite ES6 If your code base is not to large, or if you are willing to put the time in for refactoring, I would suggest you wrap fetch with your own function, like in the following code sample. You know that will return a , so create your own version of , which you could then export if necessary, and redirect your files that point to the functionality to your own implementation.