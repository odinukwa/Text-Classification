It does not follow PEP8 and should be You have the same hardcoded string in multiple places : you are pretty much asking to be biten at some point if you want to change this. What about . You are calling for no good reason You do not define if the condition in the is evaluated to false. Maybe you meant : TXT_EXTENSION = '.txt' filename = file_title.get() if TXT_EXTENSION not in filename: filename = filename + TXT_EXTENSION You are changing "toto.tutu" to "toto.tutu.txt" but "toto.txt.tutu" does not change. If what you are interested in is extension, you should probably be using . 

Code organisation It can easily be seen than nothing will happen for a given if it is already in . We might as well extract the corresponding logic in a single place : 

Finally, because of the way this is going to be used, you do not even need to actually build the list : you could just use generator expression : 

you are comparing to and if they are equal you compare to . As far as I can understand, the second check is not useful at all. 

Now all I need do is create functions which can add to, prune or walk the tree. These will do so recursively, using pattern matching to do the appropriate thing depending on the type of the node. There is more than one way to do this, but first let me say a few things about the example code above: 

Point 2 is actually the more important one. To choose an apt analogy, you know the story of the peasant who asked the emperor to place one grain of rice on the first square of a chessboard, two on the next, four on the next and so on through powers of two? And the whole empire is bankrupt before square 64? That's what you're doing. You are forcing Haskell to consider every possible variation, which would be costly even in an imperative language but is more so here. In an imperative language, you would use lots of tricks to detect when you can abandon one branch of the permutations and track back. The advantage of lazy Haskell is that you can greatly simplify such code by "creating" large or even infinite structures, but only every evaluating small sections of them. The trick is to only ask for what you need. Here's part of a much more idiomatic and also much more performant n-queens solution: 

Please note that if you were to define a function/macro, it could be useful inside the loop too as it would become : . 

You don't need a class I highly recommend the Stop Writing Classes presentation. The typical situation it describes : a class with two methods, an init and a run is exactly what you've done. Changing this already makes your code much simpler. 

Now, even though it doesn't really matter here, it can be a good idea to iterate over your containers by using (const) references to avoid copies. Also, I am not quite convinced by the variable name. I'd find better than , better than and better than . 

A different algorithm could be written using a different data structure like a dictionnary or a counter. 

Algorithm optimisation There are major changes possible to the algorithm. Before considering smart optimisations, you should make sure you use proper benchmark tests with big inputs. Optimisations could include things like: 

I think in your case, it would be more explicit to define a dictionnary mapping field names to function being called to set these fielde. It would make the code easier to search in. My first idea going too quickly over your code was "these functions are called nowhere", I was obviously wrong but you can see why I thought so. This could be done via the not-so-beautiful: 

EmptyBST.min Since can only return type , has to throw an exception. There is no logical alternative. You could consider also implementing , which gives the caller more flexibility. Then would return . Tail recursion None of your methods are tail recursive - not even the simple ones and . You can test this by placing before any of them. The compiler will give an error. min and search These cannot be tail recursive, even though the calls to or / seem to be in tail positions. Class methods (as opposed to object methods - functions, in other words) have to be final or private and have to call themselves, not - as you are doing - a superclass method. For these two methods, this can be solved simply. One way is to use a loop and a to descend the branch (this is how many methods in the collections library do it). Another is to use an internal helper function like this (for ): 

If the map contains a key which is equal to the sum of the stream, the value associated with that key will be a list of all equilibrium indices, sorted in reverse order. If there is no such key, there were no equilibrium indices. 

I was about to say that I had found a bug with the following test cases while trying to understand how your logic works : 

Also, the loop accepts an optional block after it which is called when the loop exited with no (just because the thing we are iterating over has been fully consumed). This can be useful to rewrite : 

Regarding You don't need to use a new variable. You could use directly. You may use the fact that non-0 integers are considered as True in a boolean context and 0 is considered as False to write . Anytime you use and on the same values, you could use . Here you could write: 

More optimisations You could compute the limits outside the nested loop. Your loops are actually loop in disguise and you could make things more efficient by using or you could use the argument of range to use the values you'll actually need : (in both cases, there might be an off-by-one issue but I'll let you check and fix). Final (untested) version of the code 

At the beginning, you iterate resolved to True if is True, False otherwise. I think this does the same as : 

Step 2 is very simple and easy to write. So if you can create a function (or piece of code) which delivers the two largest numbers, it will be easy to do the second part. If we call the function largest2 and assume it returns a list of two numbers, then the second part could like this: 

(for simplicity, assume we have created 3 functions which implement your 3 transformations) then will still be untransformed in reality, waiting to apply all 3 transformations to any item you ask for. So if you then do 

And then iterate through the list, calling each function in turn. If you are not familiar with functional programming (in Python or any other language), take a look at this short tutorial 

then it will start by applying all 3 transformations to the first line. If that line is "3/0", the program will halt without touching the rest, saving a lot of time. 

In Java, the way to represent things which are essentially the same, only with different details, is though classes. Imagind a class which contains a field (a String) and a field (a object - an instance of the class). Imagine a class, which contains a field (a collection of strings),a way of printing the description (calling on each collection element in turn) and a collection of . The has a method which 

Close your file You a file but never close it. You should but it's quite normal to forget it. A nice solution not to forget it is to use the statement. 

As you have updated your examples, you can write some code to ensure the code we are about to write works properly : 

Now, if I was to write the same function, because it is so easy to iterate on strings in Python, I'd probably avoid the recursion and so something like : 

Another issue found What if we look for "c" ? At the moment, we'll do with an empty list of candidates : this will crash. This should be handled much the same way we do for longer strings : check if we do have a match. Also, this removes some unrequired logic : 

An example of dynamic programming approach (but I do think it will be better for you if you try to rewrite your solution with tests first, at least you'll be able to compare results and performance): asuming you have a string s "dddddD1D2" (a string composed of any digits then digit D1 then digit D2) and you know the number of combinations for all strings "" (empty string), "d", "dd", "ddd", ..., "ddddddD1", how to you know the number of combinations for string s ? You have two different options : 

returns an iterator. Why not stick with it. , and work the same with with iterators as with views. So if your three functions take and return , it just works. The bonus that 1) the whole file isn't even read until you ask for it all to be processed and 2) the original, pre-processed lines are definitely thrown away and garbage collected. The danger is that you have to be very careful to only traverse each intermediate iterator once. So don't keep any references around. 

then you should have two different classes to represent them. The first type should not have a car field at all. The second should not be creatable without being passed a non-null car object. Depending on the rest of your code, the second class could be a subclass of the first (with the addition of a car field amongst other things) or share an interface with the first (preferred option of those two) or the request could be an entirely separate class, replaced with a car-containing rectification by a factory. Either way, only need specify the second type as input. And immediately a whole category of errors is eliminated. There is no need to check for the existence of a car when it is guaranteed to be present. If you do it this way, you never have to check for the presence of a real car. Any method that depends on the existence of a car simply has to specify the car-owning type. I would not be surprised if other stages in the lifecycle of rectifications can be treated this way. If you create a common rectification interface but 

The trick is that because we only consider "ordered" permutations, we don't have that many cases to handle : we consider 19437 permutations (instead of 9999999 integers) leading to 8500 distinct integers. Then for each integer, we consider if it is a valid number by checking that its corresponding decomposition is in the associated list. The point of using a dict instead of checking each number as we go is just to make debugging easier for me but also to try to limit the number of time we perform the same operations by grouping them : is not called as often as it would otherwise. However, I have done any profiling as it was fast enough for me. 

Code organisation You've separated the input/output from the actual algorithm and that's a very nice thing that is not done as often as it should be in questions tagged with . The only thing I'd change about the way you've done this is that the function does not need to be provided the value as it should correspond to the length of the argument. Loop like a native I highly recommand Ned Batchelder's excellent talk called "Loop Like A Native". Among other things, it tells you that in general, you should not use a combination of (or ) and to iterate over something. At this stage, the code looks like: 

Like many algebraic data types, a binary tree is a recursive type. A node is a tree (one which can hold other trees). Nil/Empty is a tree. Instead of working with that, you have an inflexible wrapper class Tree and a set of case classes which implements nodes. That incurs many penalties. For a start, you have no representation in your type system of the empty tree. Secondly, you lose the ability to create simple, elegantly recursive methods for your case classes. Look how much simpler your code can be if you work with that, rather than fight it: 

The option to tolerate whitespace in your input Powerful pattern matching Easier error reporting val fractionLine = """(\d+)/(\d+)""".r 

splitParameters Same as the other two, but multiple recursive applications of is even more expensive. This can be rewritten safely as 

There are only 999 6-digit palindromic numbers It is trivial to generate a sequence of them in descending order Testing a decreasing sequence of potential divisors, starting at 999, can be abandoned as soon as palindrome / divisor > 999 The search can stop as soon as palindrome % divisor == 0