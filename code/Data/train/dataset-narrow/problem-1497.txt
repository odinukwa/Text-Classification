The general idea is to use library code, particularly to eliminate explicit recursion, and inline things used only once. abstracts computations that can fail and abort at some point, and allows you to bind into pattern matches that fail the computation if they don't match. abstracts retrying them until they work, using s instance. abstracts computations that carry around a piece of state to read and write to. defeats the need for to manually loop. Contrary to that comment, abstraction is kinda Haskell's thing. 

Your strings are no longer than 80 characters. Do you mean your lines of code? You don't need , you can pass the do block directly to . The conceptual no-op should be replaced with , but in this case captures it more precisely. The next-player arithmetic is wrong - if a player is removed, you skip over the original p+1 which is now p to the new p+1 which was originally p+2. Make sure to set echoing to False, so people can't see what the others put in. Since is only used in one place, I'd inline it. 

is just . Aeson provides ways to derive , not sure whether they're applicable. If you're desperate, you can throw TemplateHaskell at the rest and generate the code yourself. 

Combining with is a fool's errand. (I don't know where you get and , so I'll assume they start at 0.) 

There doesn't seem to be a reason to filter out the s. List comprehensions neatly let us skip the empty tail, and get rid of . 

One property that comes to mind is that applying any permutation before does not change the result. But what is a permutation? I'd say it's a function that doesn't exploit properties of the element type, has a left inverse and preserves the length. (The first ensures that only input elements are used. The second ensures that no elements can be dropped. The third ensures that there is no space for duplicated elements.) 

Another thing that comes to mind is that k*k might be faster than k^2 for obvious reasons. looks it up Oh hey maybe you want to look at $URL$ 

And just for fun, this should only traverse the counts result once. (Requires that indices is sorted, though.) 

This piece of code is, incidentally, the epitome of order confusion and what wouldn't happen if there was a way to bundle API updates with automatic patchers to old code. 

(I don't understand the part of your post that talks about an .) is superfluous, right? No sentence contains anything that has children, right? It appears that to me that 

is from Control.Monad.Random. Stuff that you only ever plan to use once and in one place should usually be inlined. allows us to abstract away the passing around of the blacklist. replaces this recursion. Your into an if is subject to Boolean Blindness and should instead be done via a uniformMay combinator. It's a shame it doesn't exist. Let's make a pull request to MonadRandom and pretend it does. reduces naming further. 

<- You want . implements some of your stuff already. I wouldn't introduce the types and in the first place. They just introduce wrapping without extra type-level structural info. 

I would separate the looping queue logic from the rest. A general implementation of necessitates a state monad here. 

Calling a monadic action a given number of times doesn't need manual recursion, and thus also doesn't need to give the repeated action a name: 

If you used , would be Using , is , except that the list is the right way round. Replacing with allows you to remove the last line, and thus the recursion, in loop's definition. Prepending to allows you to remove the . skips getting system time. 's allows you to require ability to generate random numbers in exactly the upwards call hierarchy of if you use mtl-style type signatures. You won't even need to specify that it is actually provided by (except in ), giving type level gurantees that you aren't using IO except for random numbers. Then you can wholly reduce to . 

provides a matching instance for , but we want to modify the number of s to one, so we'll need an . Let's submit that. Usually could have done our job, but we don't want to target the arguments of the and constructors. 

Please, resist the temptation to write your own ECS system, I've been in you and it is a no-go. But if you have to do so, do it right! 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

This allows you to implement entities in C++ directly (prefer always this, even though direct memory addressing of C++ allows you to do dirty things) 

suggests me that you already spent a good amount of time digging into the topic. While your first point indicates you are on the right way, your second point gives me the impression that you have been hijacked by articles written by people that do not really use the ECS pattern or do not understand the pattern at all (Unity, Unreal and Lumberyard are NOT Using the ECS pattern, neither in its old conception). To directly address your question, I think the best suggestion comes from @Laurent La RIZZA's answer: 

You have to write a complete parser (a simple one, but too complex for becoming a single answer) to avoid these issues. You can know if you have done everything correctly luckily: 

Let's me make a premise, I'm actually a consultant, helping a small indie team of quitting dependency hell, I'm basically re-writing a small game (30k lines of code). Turning it into a full-fledged ECS game. And I'm using an already existing ECS framework, not a mine framework. Explaining it is the most difficult part. I'm actually learning new things with every-day problems I face, so I'm not speaking to you as "expert", but as person that is learning. Sometimes I ask questions to the author of the framework I use and he is very willingly to help me and find better solutions to certain problems. Believe me, I come from a C++ programming background, so I always struggled to make my custom engine, dealing with allocation etc. I even started a 3D engine once, I would never do that again. What you are trying to achieve already however: 

but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic). 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

The ECS paradigm emerges as a tool as long as you think your logic in a modular and decoupled way. I think you should seriously take a tour into Svelto.ECS (beware, its author renamed "Systems" into "Engines", I believe to avoid confusion with c#'s namespace "System" from .NET), written in C#. To do that you have to drive away from most of ECS articles you find on the web, I'm sad to say that, because I tried to use ECS "the old way" and it simply didn't worked well, it forced use of anti-patterns and made me wasting time. Most ECS frameworks, don't scale. You start easy and when the project becomes big you enter dependency hell, but you don't realize that because the dependency is hidden by components. With Svelto you just need to start, it seems hard (well it is a change of paradigm afterall), but after you get the first 10 engines done you realize how easy and flexible it is. 

When you need to reverse afterwards, that's a hint you should have folded the other way. But this can even be written in terms of : 

In general, I'd go for the second sort of approach. It scales better. I'd eliminate four names and the hack like so, at the cost of and : 

To bring 's last lines closer in method with the rest of your code, you could do and put another to the right of . (Or , because the repeats everything anyway, but that's kinda incidental.) When you implement a transformation of a simple partial algorithm into a safe one, chances are 's already got something, here . in its prefix form allows me to not close each option with a multi-line closing bracket, and shuddup indentation blocks split code into units just as well as names do, and then you don't need to choose names for everything. Each option even already lists a description of what it does! 

Have some rewrite rules applied, combinators used and helpers inlined while I think about your algorithmic question. And make a . 

Here's a version of your list of lists version using list comprehension and no !! and no explicit recursion: 

Your example would then look like . By the way, whereever you're using the Eq instance of Tank, consider pattern matching instead. 

is . points out some redundant brackets and suggests using in . , and are superfluous once-used one-liners. All the passing can be abstracted with the monad. For example, becomes (I assume reversing the order of adding does no harm) and can be inlined. And s are , so no need for . And becomes and can be inlined. (I note these because it might otherwise look like I'm rewriting the code from scratch as opposed to reviewing.) 

The explicit recursion in can be averted by using library functions that specialize in particular recursive patterns: 

Try to put configuration-like parameters to the left and data-like parameters to the right, it composes better. condenses much conversion. lets me improvise a query language so I don't need to unpack the tuple everywhere. You already wrote and then you didn't use it. 

I don't see the definition for , and your first code paragraph doesn't look like Haskell to me. You have one more place where you could use your . Both uses are for , so you could instead wrap in your name for it which returns a . Assuming a lens into the content field of : (note that ) The source of $URL$ seems to want to give you the attributes in s too. Maybe they have reason for this - should you also retrieve that in ? If so: 

Ignoring what kind of error messages you get, you don't need to handle error cases yourself: (!!) already does that. 

Successive elements of the list returned by genPositions and xs are zipped together; captures this pattern. i is now not needed in its non-rooted form and I recommend changing the interface to take N as an argument instead. Non-square arguments can currently crash !! anyway. genPositions is only used once, therefore I inline it. 

can be assembled from library functions. To reduce code duplication, turn the parts that differ into the parameters of a function you implement once. The things you happen to be doing here can be written in terms of a few modules. Try to inline everything that's used only once. 

The "intermediate array" takes no extra space due to lazy evaluation. is . Yes, swapping the parameters makes sense. Inline and once more. I wouldn't worry so much about constant factors - have you compiled it with -O2 and tested (eg with criterion)? import Data.List (minimumOn) 

Changing the where to a let allows you to skip passing the secret. Passing guesses in and messages out purifies the control flow part of the program. zip [1..] makes clear: The number of tries during each step does not depend on the control flow. interact, lines and foldr replace the recursion. (Recursion is too powerful for brains to handle in general, so we should avoid it when we have a simpler tool.) Your mileage may vary on any of these suggestions. 

Here's how to use to brighten the day a little. You may have hoped for a way to do only once after combining the s with ... but I also don't know how to do that. If went to arbitrary MonadError instances, could have been more concise.