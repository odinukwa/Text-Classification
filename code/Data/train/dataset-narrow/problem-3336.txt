The remote machine now knows there is no point in retrying this port. That includes scanners. If you did not read the footnote yet, read it now to understand why. This port is blocked by a firewall. Period. Before I get into your example here's something you want as rules for INPUT and OUTPUT, preferably at the top of the list: 

Comes on solid and stays on. The SD card is not being read; if you try taking the card out and plugging it in, it will do exactly the same thing (check to confirm; the Pi 2 may instead have the LED off). You can try creating the card again, or if you are sick of that, try a different SD card. If it still does not work and you have followed the instructions to the letter, the Pi may be defective and you should find out about returning it to the distributor. Flashes in a regular rhythm. This will be about a 1 or 2 Hz pattern, then a slightly longer pause, and repeat. The number of flashes in the pattern indicates the specific problem, but the underlying issue is most likely that the card was corrupted at some point. You should try to recreate as per number one above. Flashes rapidly and intermittently for about 30 seconds, then goes off. This may be a bit shorter or longer, but if it is between 10 seconds and two minutes very likely the boot has succeeded. In this case you are probably going to need a screen, keyboard, and mouse to sort out your problems. However: 

That Kali appears to be compressed, something which isn't mentioned in their install instructions for the pi, and is sort of deceptive if true because of the suffix. Perhaps this is your first test ;) 

This actually replaces the newline () with a space. If you just want to remove the newline, use instead. See for details. 

Two-way network connections are done with IP sockets, which come in two predominant flavours,2 TCP and UDP. TCP are the most common and arguably the most functional, that's probably what you should use (the WWW is TCP/IP based). The GNU C Library Reference Manual has a nice introduction to socket programming in C. Remember: you must use IP sockets to communicate on a real network, meaning the relevant bits are about "internet namespace" and not "local namespace", and you probably want TCP sockets, which are the style. And again: the C Library counts on the system to provide an up and running network that can be used to make connections. By analogy, your web browser does not set up your internet (eth or wifi) connection for you -- that's a system administration task. If there's a network available, the web browser is able to use it; if not, the user is informed and can do whatever is necessary. 1 If you are aware of the OSI model, ethernet vs. wifi is part of layers 1 and 2 ("physical" and "data link"). Two-way socket communication is an aspect of level 3 and above, but the kernel takes care of implementing layers 3 and 4. 5 and 6 are sort of irrelevant in this context -- what you are doing manually in C is implementing layer 7 ("application"). 2 There's a 3rd kind, "raw", but you don't want to use that. 

Note that I've changed this slightly by uncommenting two lines; that's what you want to do. If for some reason you can't find this section in , just cut n' paste those lines in. You'll then need to reboot. 

That won't stop it right now, but it should prevent it from starting next boot. You will still be able to start it manually via (and stop it with ). If you want to re-enable it at boot, use . 

Leave that running in the foreground; it should be clear it has contacted the WLAN, which might take 5-10 seconds. Now from another shell: 

You should be able to, although as per my comments it probably is not necessary; all you need is a commonplace OTG adapter. Based on the wikipedia description, however, you could make one yourself using one end of a normal microUSB cable and a female USB jack from somewhere (here's someone who has), since that is the context: You need to insert the male end of whatever you are connecting to. There are five lines in a micro-B plug, but only four of them connect to the female jack. The extra one on the male end is simply pulled low by attaching it together with the ground. 

I think you are best off with a quad core model (i.e., the Pi 2 or 3, aka. "2 B" and "3 B" but there are no other 2/3 versions so the "B" is superfluous). Other basic accessories useful in setting up and working with the pi are a USB keyboard, mouse, and HDMI cable for attachment to a monitor or TV. With regard to the camera, you can use commonplace USB webcams but these can also be a gamble with regard to driver support; the official pi cameras (5 or 8 MP; beware there is a "no-ir" version which you do not want) are the best bet. The down side to these are 1) They require a special cable; generally they are sold with one 6-8" long but they are available in lengths up to 24", and 2) They are very small, delicate, and like the pi do not include an enclosure. There are cases available for them and they also have (very small) mounting holes. It is not particularly difficult to attach the camera inside a tupperware container with room for the pi itself, although you will want to drill a small (~1/4") hole for the lens. I've done the above and covered the hole with a very thin layer of clear plastic (e.g, from some kind of packaging) epoxied onto the outside of the tupperware; this is fine since the camera does not autofocus, and if you compartmentalize the container with some bits of cardboard, styrofoam, etc., and use decent quality locking style tupperware, you can squeeze a pi with camera and powerbank into a fairly weatherproof, 10" x 6" x 2" box. If you are using this outside in the heat be sure to monitor the CPU temperature (there is a built-in sensor) via wifi; it is unlikely to be a problem, but the power banks generate additional heat and combining that with direct summer sun and no ventilation may not be a good idea. Something else to consider... 

Has anyone else noticed this? Does anyone have any idea about why it would happen? A recent firmware update? [As it turns out, I hadn't been updating the firmware -- see my answer]. 

The problem with this is it doesn't involve any kind of standard or protocol. That doesn't mean it isn't possible in general, it just means there probably isn't be a pre-existing solution in a specific case. If you understand the nature of http exchanges and basic html, you could reverse engineer the login and automate it with, e.g., or or some simple client in python, perl, etc. You need to fetch the login page and then send an approporiate response, probably data but there could be other mechanisms. Watching an exchange with should enable you to see the details of what is going on. Cookies probably are not involved since you are authorizing yourself for low level internet access. If you don't think you have the prerequisite knowledge for this, it is going to be too difficult to be worth bothering with. 

1. The reason I've used 10 Ah as an example here is in general, if you want to do things this way and are shopping for a new battery, I do not think it is worthwhile buying anything smaller although in theory such a battery could last 20-40 hours (see discussion in comments below). I have not done a lot of research and experimentation this way, but I suspect a problem with many/most power banks is that as they run out of power, their voltage starts to fluctuate; this is fine if they are used for what they are mostly advertised for use as -- charging. However, with a pi, if the voltage dips below a certain point, it will stop working, and this may happen long before the battery is actually dry. Put another way: "Your mileage may vary". 

There's a bit of idealization in the last point -- a pi left doing nothing will probably last longer than one constantly maxed out -- but the general principal holds. 

Without knowing the context of that statement it is hard to say whether you were accidentally misled, but either you or the person who told you this is confused. There is always the chance that it might work out that way, but there is no particular reason to believe that it "will flawlessly". 

All apologies for my (deleted) answer about USB using 5V logic. I had assumed this was the case, but when I went to check that I found this, which says high is <=3.6V and low is >=0.3V. I think this should be okay. However, it also reads: 

That is probably defective, since almost anything plugged into a USB port is going to be expecting 5V. Considering they are often used to recharge batteries which can explode, it is a potentially dangerous defect, so you might want to give some thought to where they came from. 

Unfortunately you will not be able to tell which one this is by looking at the box or an online ad. You have to stick it in a machine and get the USB ID (in this case, either 0b05:17ba or 0b05:17d3). My advice WRT wifi adapters is to buy them from a store and not online if possible. The reason for this is they are pretty cheap to begin with and do not vary greatly in capabilities by size, so there is no advantage to spending hours browsing around for one with has better specs for fewer bucks, etc. Presuming you don't spill coffee on it, a brick and mortar store will usually do a refund or exchange, no questions asked, within 7 days (at least most of them will in N.A., be sure to check). So if it turns out not to work properly, you can just bring it back and get another one. Also, stores tend to have much less selection than online retail, and that selection will be the most popular and commonplace items (which are more likely to have well tested linux drivers). 

This depends a bit on where you are getting the new OS from, but most likely, neither. Those are partitions on device , and that's where you want to put the new OS image. Raspberry Pi operating system images are, as a rule, device images which contain (at least) two partitions, and such an image must be copied to the SD card device, not one of the partitions on it, e.g.: 

I don't know if there's a proper source package distributed through Raspbian -- but even if there were, 3.10 is way out of date now, so almost certainly you are out of luck that way. Presuming you are using that kernel because it was from an image distributed to support some special piece of hardware (e.g., various touchscreen manufacturers do this), you likely cannot get their source from anywhere, but the upstream version (i.e., the official one) may be close enough to work. I believe you will have to compile the kernel before you can compile the module against it. Have a look in to see if there's a file there; if not, try . If that works, check again. Copy that out, unzip it, rename the file , copy that into the top level of the tree, and you can run a make. This will take quite a while on any model of pi. You can also cross compile it on a bigger system; there are explanations of how to do that around online, just beware you want to do the ARMv6 version, which means stock ARM cross compilers will not work (they are generally ARMv7+); there are some pre-built tool chains here in the directory. If your kernel is from a special source, likely the .config won't work as is, but either that will show up right away, or the build system can adjust it automatically. If it doesn't work, or there isn't one to start with, use: