It is worth noting that the promise of unique colorability seems to involve more structural consequences than the uniqueness of the maximum clique. 

for any vertex $x\in A$ at least half of the neighbors of $x$ are also in $A$, and the size of $A$ is minimum. 

3SUM: given $n$ input numbers, find 3 among them that sum to 0. As far as I know, the fastest known algorithm runs in $O(n^{2-o(1)})$ time, and this order is conjectured optimal. On the other hand, the verification of a solution is much faster, since all we need to do is just to check that the 3 found numbers indeed sum to 0. All-Pairs Shortest Paths: given a graph with edge weights, compute its shortest path distance matrix. Once such a matrix is given, can it be checked faster that it is indeed the correct distance matrix, than re-computing it? My guess is that the answer is perhaps yes, but it is certainly less obvious than for 3SUM. Linear Programming. If a claimed optimal solution is given, checking it is easier than re-computing it, when auxiliary information is also given (an optimal dual solution). On the other hand, if only the primal solution is available, it is not clear if one can check it faster, than actually solving the LP. 

There are some results/concepts in TCS which are used in areas other than the "home area" where they emerged. For example, NP-completeness has complexity theory as its home area, but it is also used in many papers that are not about complexity theory. This is an indication of the general usefulness and importance of the concept. Similarly, network flow algorithms, shortest path algorithms etc., have combinatorial optimization as their home area, but are also used in many papers that are not specifically about combinatorial optimization. Graphs have graph theory as their home area, but are used in many other fields, as well. Question: What are some other, not so obvious or not so well known examples of methods/concepts that also proved useful outside of their home areas? 

Let $L$ be an NP-complete language. Let $W(x)$ denote the set of (polynomially length bounded) witnesses that certify $x\in L$. That is, $x\in L$ if and only if there exists a $w$, such that $w\in W(x)$. For example, if $x$ encodes a SAT instance, then $W(x)$ contains all satisfying truth assignments of the formula $x$. Let us assume that every witness has even length, and define the following new language: $$L'=\{x\#u\:|\: \exists v \; \mbox{such that}\; |u|=|v|\; \mbox{and}\; uv\in W(x)\}$$ where $\#$ is a symbol that is only used for separation, it does not occur in $x$ and $u$. The meaning of this construction is that with every input $x$, the new language $L'$ reveals the first half of a witness. In this sense, $L'$ is "easier" than $L$, because we only need to find the second half of the witness, its first half is already given. On the other hand, finding the second half still appears hard. For example, if for a SAT instance half of a satisfying truth assignment is given, it is still hard to find the other half, since after substituting the given truth values, in general we are still left with a polynomial sized formula to satisfy. 

For (search versions) of NP-complete problems, verifying a solution is clearly easier than finding it, since the verification can be done in polynomial time, while finding a witness takes (probably) exponential time. In P, however, the solution can also be found in polynomial time, so it does not seem obvious when is the verification faster than finding the solution. In fact, different problems seem to behave differently from this point of view. Some examples: 

A graph property is called hereditary if it closed with respect to deleting vertices (i.e., all induced subgraphs inherit the property). A graph property is called additive if it is closed with respect to taking disjoint unions. It is not hard to find properties that are hereditary, but not additive. Two simple examples: $\;\;\;$ (1) The graph is complete. $\;\;\;$ (2) The graph does not contain two vertex-disjoint cycles. In these cases it is obvious that the property is inherited by induced subgraphs, but taking two disjoint graphs that have the property, their union may not preserve it. Both of the above examples are polytime decidable properties (although for (2) it is somewhat less trivial). If we want harder properties, they could still be created by following the pattern of (2), but replacing the cycles with more complicated graph types. Then, however, we can easily run into the situation where the problem does not even remain in $NP$, under standard complexity assumptions, such as $NP\neq coNP$. It appears less trivial to find an example which stays within $NP$, but it is still hard. 

All these reductions are not just computable in polynomial time, but the inverse of each function, which exists after making the function injective, is also computable in polynomial time. It is known that if two languages are both reducible to each other by reductions that are polytime computable, polytime invertible and length-increasing, then they are polytime isomorphic (see Theorem 7.4 in the book "Theory of Computational Complexity" by Ding-Zhu Du and Ker-I Ko). This would mean that all $NP$ complete languages are $p$-isomorphic, that is, the Isomorphism Conjecture holds, which is known to imply $P\neq NP$. There is at least one among these functions, for which the inverse is not computable in polynomial time. This function would provide an example of a worst-case one-way function. It is known, however, that the existence of worst-case one-way functions also implies $P\neq NP$. (See Theorem 2.5 in the book "The Complexity Theory Companion" by Hemaspaandra and Ogihara.) 

Here is an example, where one can produce a solution in polynomial time, but evaluating a given solution is NP-hard. Input: Positive integers $n,k$ (in unary encoding), with $k\leq n$. Task: Maximize the number of edges in an $n$-vertex graph under the constraint that its maximum clique size is at most $k$. Solution: It is known from extremal graph theory that the optimal graph will be the Turan graph $T(n,k)$ (see here), which can be easily constructed in polynomial time. On the other hand, checking the quality of a given candidate solution (a given graph) involves checking that its maximum clique size is at most $k$, which is NP-hard. Note: If we only want to check whether the solution is optimal, then it is easy, because the Turan graph is known to be the unique optimum, so it is enough to compare the candidate graph with the Turan graph, which has a simple structure. On the other hand, if we want to evaluate the quality of a candidate solution, as requested in the question, that is, whether it is feasible and how far it is from the optimum, then we have to check whether it satisfies the maximum clique constraint.