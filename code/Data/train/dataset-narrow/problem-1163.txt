There's a precept in Python, EAFP, which stands for "Easier to Ask Forgiveness than Permission". What it means is that Python programmers tend not to check things with conditionals, like doing . The style in Python is more to assume everything is good, and let the program throw an exception if it's not good. In this case, if there's no such file, you throw and complain. Sometimes you do want to ask permission, but I think this is a case where it's easier to ask forgiveness. This is something I also see elsewhere in your code. It's good to be safe, but in Python, people tend to really lean more heavily on exceptions than on explicit conditional checks in most cases. The case where you do use a conditional is when there are multiple possibilities, all of which are valid, and you need to figure out which case you're in. But if something is wrong or invalid or unexpected, like the passed file name not being a real file, I recommend exceptions. (By the way, you don't need in your clause. What does is skip over any code that comes after it to go on to the next iteration of the loop. In this case, there is no code after , so it would always go to the next iteration anyway.) In both and , you have some code like 

I translated the given C# code to Java, and timed it on my machine using the Unix command. It ran in 0.161 seconds. Your original code ran in 1.023 seconds. Here's the Java translation of the C# code: 

I wrote an implementation of the Karp-Rabin string matching algorithm in Java 7, based on the discussion in Section 32.2 of Introduction to Algorithms (CLRS). Clearly, I need more experience with numeric programming, because I spent two days wrestling with overflow issues and floating point error, but I believe it works now. Of course, anything goes, but I'm especially looking for feedback on the following points: 

Your original code contains an apparently correct implementation of Euclid's Algorithm, as do some of the other answers, but it seems you weren't sure if the algorithm was correct, so I'll spend some time to explain it a little. (aush gives a very terse C# implementation of the algorithm in his answer as the private method , which is great for writing the program, but not so good for understanding the algorithm.) I don't know C#, but I took number theory at university, the first half of which was more like "Applied Euclid's Algorithm", so I'll summarize the idea behind it a little. The idea is that, when you reduce a fraction into lowest terms, you're dividing out the greatest common divisor of the numerator and denominator. In your example, \$ \frac{3}{4} \times \frac{8}{15} = \frac{24}{60} = \frac{2\times12}{5\times12}\$. Euclid's Algorithm can find the GCD of the numerator and denominator. Think of writing out the numerator and denominator as prime factorizations: \$\frac{24}{60} = \frac{2\times2\times2\times3}{2\times2\times3\times5}\$. Euclid's Algorithm finds the number whose prime factorization contains all the prime factors shared between the numerator and denominator, in this case \$12 = 2\times2\times3\$. When you divide out the GCD, you're dividing out all the shared prime factors: $$\frac{\frac{24}{12}}{\frac{60}{12}} = \frac{\frac{2\times2\times2\times3}{2\times2\times3}}{\frac{2\times2\times3\times5}{2\times2\times3}} = \frac{2}{5}$$. There are no more shared prime factors, so the fraction can't be reduced any more. In this case, the numerator and denominator are both prime and are unequal, so it's obvious there are no more shared factors. Other times, you might have two composite numbers that share no prime factors, e.g. \$\frac{8}{15} = \frac{2\times2\times2}{3\times5}\$. The idea behind Euclid's algorithm is this: if we have some numbers \$a\$ and \$b\$, both integers, and \$a > b\$, we can divide \$a\$ by \$b\$ and get two numbers, a quotient \$q\$ and a remainder \$r\$ (remember back in grade school when \$23 / 11\$ was something like \$2 \ \mathrm{remainder} \ 1\$?). In other words, \$a = bq + r\$. There's a theorem that if some number \$d\$ is the greatest common divisor of \$a\$ and \$b\$, then \$d\$ is also the greatest common divisor of \$b\$ and \$r\$. So we calculate \$r\$, and then we feed it back into the algorithm as the new \$b\$, with the old \$b\$ as the new \$a\$. Eventually, we'll get a remainder of \$0\$. The value of \$a\$ on this final iteration is the GCD of the original \$a\$ and \$b\$ that we started with. (All of this can be proven, but I won't do that here. Here's a page that both describes the algorithm in more detail and gives a proof for it.) I hope this answer and the pages I linked can help you understand that the GCD method does work, and why. Here's a link to another page that also explains it in terms of code. The code is in C, but shouldn't be too hard to understand if you know C#. If you're interested, you can also use Euclid's algorithm to compute the least common multiple of two numbers, which could be useful in the addition and subtraction methods. From Wikipedia: $$\mathrm{lcm}(a, b) = \frac{\vert ab \vert}{\gcd(ab)}$$ So you could also write your addition method something like this (this is the first C# I've ever written, so there might be some errors): 

You could also use to be explicit. Similarly, when you do , you require that is a RandomAccessIterator. Replacing it with still requires that is a BidirectionalIterator. Unless you think that is a reasonable requirement (for some versions of bubblesort, it would allow it to be more efficient), don't do this. Rewrite the for loop as so (or any variant where you keep track of the two): 

Also, it's strange to close already, since we are going to be using it later. Also, this constructor can be implemented in terms of the other: 

prevents using this function for types such as simple C arrays, or even vectors if the vector uses a pointer as its iterator. Prefer . I find that that's a mouthful, so I tend to use : 

If I was doing this, I'd actually make this a CRTP class so that it becomes very easy to create smart_singletons: 

You copy the matrix to a temporary matrix and back every time. This is very inefficient. Although we tend to like immutability, I would avoid it in this case. There are two things bad here: 

You don't need to pad the strings; if we could just iterate from the right side of the strings, it would work. You don't need to compute sums for each digit before constructing the entire string; we can compute and construct as we go. 

It's fine for it to not be thread-safe, but in that case, it is very important for the documentation to make it clear. If you are going that route, however, it might be worth separating the from creation like so: 

I have no idea what this is by the name. What's the for anyway? What is this the period of? Or is this referring to the punctuation mark? 

It is considered bad to extend . For most purposes, you don't even have to extend Swing components. The only time you'd need to is if you want a custom paint method, so just stay away from it. Favor composition over extending. 

This means that (almost) everywhere you had to have a special case for an empty sequence, you now don't. For example, you can completely remove this: 

You want to remove the function chaining and temporary variables by replacing it with other functions. I strongly recommend against this. Breaking this into small methods, as you suggest, isn't good. Functional programming is designed to be highly readable as is like this. Hiding the details behind functions makes it hard to understand: 

The keys are the first two elements of each list, still in a The values are the 3rd element of each list. 

Your code looks amazing. That said, I recommend avoiding the use of raw s. It's better to make use of thread pools. Seeing as merge-sort is a naturally recursive algorithm, the use of a fork/join seems fitting. Basically, by using raw , you might get a slight performance gain, but it's too easy for your code to bloat. You have two rather large files in order to perform your sort, but by using the thread pool, I was able to implement it in one notably smaller file like so: 

This comment shows that you should split your function in to a couple functions. The "reporting to file" should be another function. 

If you run that code, it will print "File opening failed". Of course, that's not really what happened; what happened is that exceeded the maximum recursion limit and the code threw a . But the clause is misleading us. Now imagine that this code is much, much larger, and also you didn't write it. It could take days or weeks (depending on complicated the code is) to figure out that the code is lying to you. 

This is a really cool project, and I don't think the non-functional aspects are as problematic as they might seem. One of the things that makes Clojure so flexible is that it lets you be imperative, or even object-oriented, when it makes sense. I think most of the messiness in this code comes from insufficient generalization, rather than being imperative. If you do want to make it more purely functional, James Hague has written some really interesting essays about game programming in functional languages (he uses Erlang, which is even more purely functional than Clojure); the most famous is Purely Functional Retrogames, where he takes apart the process of implementing Pac-Man in Erlang in a purely functional manner, without passing around a "game state" variable. He also argues in Functional Programming Doesn't Work (and what to do about it) that even in a purely functional language, there are certain situations where an imperative "pressure relief valve" is extremely useful and that we shouldn't contort ourselves trying to avoid those. We Clojure users have it good here, because Clojure has high-quality imperative pressure relief valves like the reference types. I've never written a game in Clojure, but I'll try to offer some suggestions based on general principles and my understanding of Hague's advice, starting at a low level and moving up. In general, I think you could clean up your code quite a bit if you had more small helper functions. For example, I would put the calculation of in into another function: 

It's a bit shorter than . (I like Java well enough, but it sure can get long.) Here's the entire code sample with my suggested changes, including the one that eradicates and boosts performance that Chris Hayes suggested: 

I would prefer not to catch the here. Letting an exception go uncaught will just stop the whole program, which seems to be what you wanted. Some other languages force you to catch or declare every exception, but Python will just bring down the whole program around you. That's not what you want for production code, but that is absolutely what you want for development: anything anomalous will make the program crash and die right away, with a reference to the line number where the crashing and dying occurred. As a bonus, it's quicker and easier to write the code that way, because you don't have to add blocks around everything. If you can do something about the invalid input, then definitely catch the exception and do something. But if all you can do is say "You screwed up, fix it", then why not just let the exception be thrown? This piece of code from could be a lot shorter and cleaner: 

Or, if you're uncomfortable with the shortcut syntax for anonymous functions (it can get pretty hairy), like this: 

I feel there are other places this code could be tightened up, but without knowing what it's supposed to do, I don't want to suggest anything that misses the point. 

And, here's an even faster version that just attempts to calculate the desired pixel spacing and starts with that. This is 14x faster than your original. I don't think the last two loops are probably needed at all. 

I've discovered that node.js v10 supports for promises (or you could employ a polyfill) so it could be slightly improved by moving the logic into a handler. 

Item 1: I'd suggest getting rid of all global variables except . They don't look like they are needed and just open you up for a potential conflict with other global variables. Item 2: This line of code: 

Here's the original answer before the actual HTML and actual rendering intent was disclosed It would be useful to both see the HTML and understand what you're really trying to do here. It may be much easier to add some appropriate classes and do things a simpler way, but we can't really tell without seeing the whole problem including the HTML and a description of what you're really trying to accomplish. From purely studying your code, it can be deduced to a pattern and that pattern can be generated with javascript rather than repeatedly typed out. Here's my first analysis of deducing the pattern to a couple loops of code. There's one loop to create each event handler and another loop inside each event handler to loop through each item and apply the desired change to each one: 

One potential problem I see is that you initialize the variable once at time and then you use that value in several event handlers. But the window width is a dynamic value that can be changed over time so your event handlers can be using a stale value for . You should probably be fetching anytime you need it so it is always correct. 

Note: this doesn't populate variables , , etc... Instead, it puts the players into an array where they are likely easier to deal with later. 

This creates the same underlying methods as your original code, but is obviously a bit cleaner syntax. Usage of the constructor and methods is identical. 

You should avoid assigning to named argument variables like you are doing in because this prevents some JS optimizations. 

What you have looks like it would work just fine. Declaring the structure does not execute the functions you've assigned as properties. It just defines the functions and assigns them as properties (waiting to be called later). You could save a little execution overhead by moving the static definition outside the function so it just gets defined once (I'm assuming this is private module scope so moving the symbol outside the function is fine) and change it to . You can also remove the and since neither add anything here. You're just returning a promise anyway so you can just return the promise directly without and . I also added more explicit error checking for the category name. 

There is no native way to do this so your general logic seems sound. Here's some improvements, you might consider: 

You are correct that it would be much faster to parse all the parameters once into an object and then just access them from there rather than refind every single parameter from scratch each time: