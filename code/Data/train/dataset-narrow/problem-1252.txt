But looking at this code... it seems you will either return or . Never any other number. So I think you've got broken code... 

Because then it's already clear. It does make things more messy, but we're gonna clean that up too, promise. 

already checks that internally, so basically, if the first condition is true, the second part will also always be true. I'd replace it with because that's what you're going for. 

Indent your code, then post a follow up question. Right now, I have trouble understanding the structure of your code, which makes reviewing the code on a higher level hard. Aside from indentation (see @EngieOP's answer for that), you should give semantic value to blank lines. 

But, like this, we have another case of thread unsafe code: If thread 1 and thread 2 resume application via at the same time, they will both reach ! So let's fix that. It's pretty easy to fix - just add . What does is say "only 1 thread can be in any method that is per instance at the same time". For now, this is good enough, but later you may want to use locking objects to prevent other possible coding errors. 

Bad rolfl. This is the kind of comment that is written once and then dies a slow death. If you must leave such comments, name it somewhere. Even if it slips through the cracks of your issue management system, you'll still be able to search for TODO and find the remaining tasks. ... and if a TODO stays there for a very long time, maybe the cheat way isn't so bad. 

This would be one of your consumers. They're doing... mostly the right stuff, but on too low an abstraction level. I think they're on the wrong side of the counter! All this stretching, adding ingredients, and baking is part of the PizzaBuilder's job! The PizzaLover, instead, as the client, defines the recipe. 

Dead data CTRL + F "name" ... 8 usages... class member variable, comment, comment, constructor argument, setting variable, passed in argument... comment, setting variable... No reads! It's nice that you gave your LinkedList a name, but if nobody is going to call it by its name AND it doesn't get to tell its name to anybody, it's still gonna feel lonely. Treat it like the inanimate object that it's supposed to be and strip it of its name. (Sorry if that sounds harsh.) DeleteNode Who manages the nodes? or ? Pick one and make that one responsible. Heck. Copy the method, paste it in LinkedList, make it private and make it take a argument. LinkedList now controls the Nodes like it should (don't ever expose the nodes to the client, they don't want the nodes). Stack and Queue You might be better off implementing a generic (yes, generics) type that you use to initialize your LinkedList. Doing so means you don't have to cast anymore, and that you support more than just . Comments I dunno if your course teaches this, but when you make generic (not generics, just generic) classes like this, you'll want to add javadoc explaining what each method does and what it's side effects may be (such as throwing an exception if the list is empty when removing something). 

So lets alter this so it makes sense again. Right now, you've simulated what a human does. Look at the board, get the position of the object, look at in what way it's going... Then pick it up, hit each tile it passes, and place it on the last tile it needs to be. Welcome to the magical world of programming, where board pieces can move on their own. should contain a function. I'm not sure how the game works, since there's no instructions anywhere, but I assume it's a game where you give a series of Actions that would do stuff (like moving a unit some place). in the original source code reveals this to me. So a tractor would only move forward. I suggest a radically different design from what you've suggested. Assign responsibilities to each class. Land manages the Locations. Location is a value class, it contains x, y. These can't be altered. Unit has a Location and Orientation. With this new design, if you want to move, you ask the Unit and give it the Land to do so. Unit then queries the Land in regards to obstacles and such. Then it moves by requesting a new Location FROM Land. So why is this important? Because right now, you've defined Move to be a pretty rigid Action. There's only one way to move. And that way ignores all obstacles (I have the feeling it even ignores the Land's size!). If you were to add obstacles later this code would come crashing down as you have to ask the Land for ALL it's units, iterate over their locations (and possibly orientations, if they're moving at the same time), and somehow calculate if it's possible, and then do the move. And you have to do this for each move, because you can't store state in between. 

By using a specialized style for constants, it's easier to see that it's a constant, and not some local variable. 

This section of code, you check if the is not null. If so, set it to null. The only value which is going to equal to null is null, so skip the check and just set it to null. 

You might want to use more descriptive variables in your code, because I have the hardest time trying to understand what is. The and variables aren't helping either: are you traversing two collections? In what way? Your class names are weird, what does mean? More descriptive variables and classnames will help you when you view your code at a later point in time. If you don't feel like explaining the algorithm in code, at least put the name of the algorithm together with a link as a comment in the code. 

Another idea I just thought of - if you're not gonna filter in place, STOP filtering after the first number multiplied by itself is bigger than 2 million. That way you stop before a 10000 iterations - this should vastly increase performance. 

Lastly, keep in mind if you were to feed your code an impossible situation ("stuff 5 people into 1 house where each house can only contain 3 people at most"), you will get an infinite loop. It's up to you to decide how to handle this. 

Polymorphism failure. Determine who is responsible for deciding what the output is supposed to look like and go from there. If the feedback is responsible, just implement and overload . If the printer is responsible, find a way to get most of the detailed information into the interface. 

So for and and we enter the if statement, for and we perform the check for setting , and... the last statement is for when both are not null. So, basically, rephrased: 

Just like you define , you should try to define in your header. Additionally, it would be better to check with , because if something happens and default is lowered to 100, then you get 100, 200, 400, 800, 1600, 3200, 6400, 12800, 25600... and then 51200, which is over the limit of 32000, but because you're using , it doesn't get detected. With , it would be. 

Lastly, I think you would be better off by renaming the variable to because that's what it really is. seems to point to the idea that somewhere, you have a list of circles, and right now, you're working on 1 specific circle. But that's not true, because you HAVE no list of circles and all that really matters is how many you've displayed so far. 

This one is weird. usually returns a boolean, not int. Either explain in a comment or change the type? It's good that you documented the return type, or I'd have thought it was boolean. ... still, what does a result of mean? Is that good? Bad? Is the domain name valid if I get back? 

Take a look at . It allows you to specify the upper bound of the result. Like this, you can get a chance for this; will give you a value between and . You can use this to assign understandable probabilities to your distribution of sharks/fish/empty tiles. 

This section of code is duplicated. I think you could extract it into a separate function, as well as merging the two conditions: 

Just because you removed the last pair does not mean you're done. Take, for instance, this line of code: 

I think you should add some blank lines to improve the readability of your code. Take these two methods: 

Because you check ALL , it is not needed to check for in the inner for loop. In fact, checking this is a waste of time, as you'll eventually get to it anyway. I don't like the way you handle checking regions, lines and columns, given that you go through 3x9x(8+7+6+5+4+3+2+1) iterations for validating a completed board. That's a total of 972 checks. Consider using a to keep track of visited numbers - if the adding fails, you'll know that you have found a duplicate. Like that, you check the entire row with 9 iterations. This makes the algorithm 9x3 - 9 iterations to check a group, and three sets of groups of 9 elements each: the rows, the columns and the regions. This would make 9x9x3, 243 iterations.