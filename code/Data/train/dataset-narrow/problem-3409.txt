Looking at the header it appears isnt actually implemented which would explain why your code changes didnt make a difference 

According to your code the value of is just initialized once. since you need a different file to be selected every time motion is detected a you need to pick a new file from within the function like so 

[disclaimer] i havent really tried this but i believe it should work if the drivers are correctly setup 

And found a few more like those. Since you have mentioned the device used to work prior to updating, I m inclined to think update might have broken compatiblity with the firmware package (firmware-ralink) installed which is showing up with different error messages. If you can check the version of the firmware installed by running and share the details, it might help identifying/narrow down the problem. You could also try updating the firmware package like so and checking it it makes a difference. 

Approach 1: identify and possibly fix the issue Clarifying some of the below questions could help narrow down the issue: 

Cursory look over your code makes me think there might be a performance problem with the way you have interspersed your file writing logic with your acquisition loop. I am referring the statement in the acquisiton loop. My hunch is OS provided file buffers are getting filled due to the repeated fprintf and at some point blocks until the buffers are flushed and all writes are done. The write ares subject to the limits of the port speeds and the drive's write speed. this could explain the gaps in your acqusition. For a quick fix, I'd recommend using a binary write rather than a printf so that less cpu and memory will be used. if required you can write a binary to text converter that works offline From a larger design perspective I'd recommend trying the following changes create a struct like so to represent a sample 

The module can be setup as a wireless->serial bridge and further communication will be as simple as reading / writing to the serial port. 

According to this and this GPU acceleration is not available on Windows 10 IoT for RPi :( Might want to consider using raspbian if possible. If you find the playback is still choppy on Raspbian for FullHD, You could try increasing the amount of memory allocated to the GPU using and checking if that improves the performance. the following commands should tell you how much is currently allocated 

that either windows or one of the net work adapters on it (probably the wireless one) is using its own mac address in your dhcp packets, or your dhcp server is not using mac addresses but some characteristic of the wireless link as unique identifiers, and since you are using the same link ... 

Cron may not support backtick command expansion. put your commands in a script and run that from cron instead. much easier to debug. 

Not all VNC servers support file transfer, specifically the original realVNC server used on debian and the raspberrypi does not. The tightVNC file transfer extension is not well supported on anything but windows. 

The longer the wire and the smaller the wire the more voltage you loose. That is a plain and simple fact. There are basically three ways to compensate for this: 

I seriously doubt that you will be able to reverse the hdmi port and use it for input, but It would require at a minimum a different kernel, disabling the X server and the frame buffer and writing a custom driver, if it is possible. You may have some luck with the camera port, but I know very little about it. Vga would require high speed a/d circuitry. It would be a fun project but nothing quick. 

MIDI (Musical Instrument Digital Interface) is a simplex serial protocol (that is only sends data one way. If my memory serves it uses a standard uart. My first thought would be fire up minicom open up the usb midi adaptor tty device and set it to n81 31250 baud, then just do an ascii transfer. the two issues Are that that is a nonstandard baud rate, and something in my mind wants to say even parity which would mean 7 data bit. Give her a try, It can't hurt. 

Not all modems can be used for dial in. Almost all landline modems will work fine for dial in, but with GSM modems you need to verify that it will work. The fast easy way to check is to verify that it will sind RING messages and supports the ATA. If the modem meets those requirements it will work (with suitable adaptors). Install mgetty and read its documentation for software details. If the modem does not support those features there is still a slim chance it will work, but it will be much harder to setup. The modem bobstro linked to may work, but it is designed for other use cases (it is designed for continuous internet connection) and probably will not work with mgetty. Unfortunately you will probably need to talk to a salesman to find the right modem for your use case. If this is noncommercial you may also want to look at HAM based radio modems. P.S. use ppp not slip. slip is better than nothing, but ppp is much easier to use. 

One of my friends had the very same error which he resolved by following the steps on this page. Apparently there is a/are defect(s) which prevent xrdp working with the vncserver. However it works with tightvncserver Also the order of installation of tightvncserver and xrdp seems to be important. In summary 

Probably not the solution you are looking for, but I noticed you have not launched the jar file as a background process as it should be done when editing the file. The system will not finish booting until the exits. See the documentation on this Try adding a at the end like so 

My guess as to why ssh (from laptop to PI) works but not pings from Pi to laptop is likely because the laptop OS is configured to block ICMP requests. I have seen that happen on some networked computers in my office. 

Looks like there is thread here that discusses a very similar/same problem you describe. Extract from that link 

I have a feeling the card has not been written correctly to be bootable. Please share the steps you took to create a bootable disk. The green flashing usually indicates the disk is detected/recognized but it turning orange or red might indicate it was unable to boot properly. However i have never encountered this before and I could be wrong. Common mistakes and problems include (I am not saying you did) 

Try checking/printing the return value of your call to verify it is indeed so. (I wasnt able to find the headers for the exact kernel version you have mentioned). Update on how I traced The linux kernel source code cross reference is available here. The Raspbian version here should be mostly the same. I searched for gpio_set_debounce on the linux cross reference site and traced the following sequence conditionally includes or but also provides a default implementation (returning -ENOSYS) as fallback in case there is no specialization for the particular chip/device. 

Usually posting the details of (kernel version) and (os version) helps in narrowing down problems. I suspect the i2c has been blacklisted (disabled) in the kernel. here are the instructions to enable it. briefly using you should be able to enable like so 

this should allow you to simply (double) click and execute from a GUI based file explorer. An alternative is to use a tool such as to create a binary out from your script With regards to the icon, AFAIK really depends on the desktop environment you are using 

There are some USB hubs with active power management that when they are plugged into a computer try to negotiate power consumption with every device, so they cut out the power to every device to start plugin events. These hubs (which are otherwise very nice hubs and work fine for every other use) will not work to power the RPI and act as a hub for it at the same time. the two workarounds are to add a really big capacitor (or battery) to the RPI so that it will function through this power interruption, or to steel power from the hub's power supply instead of the hub. It would probably be easier to just use a cheaper hub. 

As rasbian and umbutu are both debian based, they have a lot in common, including typical apache configurations, so there are probably no problems following for one on another, other than the wisdom or lack thereof of the author. 

increase the source voltage: if you lose .4v over the wire increase your source voltage to 5.4 volts so that you get 5v at the point of use. You must measure your exact voltage loss. increase conductor diameter. decrease cable length. This is easy enough, if you use an ac extension power cord you can place the power supply close to the rpi. 

Most display managers can be configured to have multiple X servers and on boxes with one or no monitors using Xvnc works well. The setup that I use has the advantage of using the main X configuration with out using xdmcp. I use xdm because it is the most configurable. here is my /etc/X11/xdm/Xservers file 

Use of a password with sudo. This is hard to do, prone to mistakes and seldom provides any benefit. Allowing full permission to the web server. The www-data user only needs to run one script for this to work. It does not need full root access. This can be done easily with sudo. 

the web server. wrapper.cgi: this program is called as www-data by the web server it calls sudo or super. sudo or super with a configuration file that only allows www-data to call real.cgi real.cgi: This program writes to gpio after preforming final checks. Be very careful when writing this. 

I'd guess its damn near impossible ... There are some options to try to secure your IP though. All options below definitely can be circumvented, these measures at least a inconvenience, nuisance and at best a deterrent for those who are easily intimidated or put off) 

It is a powerful wifi solution that costs ~5$ on amazon and much cheaper on aliexpress for bulk purchases. There are many boards based off the ESP8266 chip that provide expose more complex or simple interfaces. The ESP01 board one of the cheaper and simplest boards that can be easily interfaced with a arduino via USART. With a raspberry pi 3 (with built in wifi) on the other end the possiblities are many. Here is my poor attempt at ascii art for your viewing pleasure 

Shell Scripting Assuming your objective is simply to play a single file once there are much simpler ways than writing a python script My personal favorite for playing mp3 files is which I install using 

and you can either wait or poll for the process to exit. The indirect approach is generally useful if you don't need total control over the playback but just a simple interface. Sometimes I use it to play a song for a certain duration and stop by having a timer callback terminate the process 

I tried the steps and was able to get the build going. BTW this question (and answer) has very little to do with raspberry pi hardware or Pi specific software and should probably be migrated to the right site ... and btw Welcome :) 

Up and down speeds depend on the network and are typically asymmetrical (meaning download speeds are higher than upload speeds) This mode of usage is pretty much opposite to what you are looking for. Typically there are number of considerations that would go into configuring a system that is going to be exposed to public such as security, load balancing etc. Assuming your use case doesn't require such rigorous effort or considerations but just a simple system that allows you to remotely access some information on your Pi from another system, you will need to deal with at least the following 

Have a look at this and this for a short intro what a NoIR camera is. NoIR stands for No Infra Red filter meaning the sensor will pickup IR waves in addition to visible light which will affect the final image.