Avoid repeating string literals like '\0', 'X', etc. all the time. Use string constants: const char EMPTY_SQUARE = '\0'; Don't duplicate your code. Try to identify repeating patterns and extract them either in small functions, or code more cleverly. 

Being able to check equality of statuses is desired. With these in mind, I coded a class which implements : 

A GameStatus can be compared to the , , immutables, or with other statuses. Overriding the , and the operators assures that every comparison should be correct. 

I think, your Presenter is doing too much. The logic about who wins, the next move, etc. should go to the model. The logic about highlighting, colors, X and O's constants, message strings etc. belong to the View. You are appending an empty string to a char for the side-effect of converting to a string: b.Text = model.GetPiece(row, col) + ""; 

Each of the two functions really does one thing. :) The first function is standard for all classes other than the type in the cast. Notice that we know this cast is safe, because we checked the type shortly before. 

What is the unit of measurement in and in and respectively? It is a readability plus to put it either directly in the variable name, e.g. , or in a comment. 

For the line and the line are connected. will throw an exception if it is not guarded by . This is a simple example. In more complex cases the maintainer of your code might move some pieces around accidentally breaking the code. If we apply that to splitting the documents into the two datastructures it would look like this: 

The type is now modelled as a tuple. I would recommend a case class for it. That allows you have the code in search be more readable. 

In a sense it's strange that a contains a document title. If you look at the method you see it's actually used in a (somewhat) arbitrary way. From the outside it's unclear which document title is returned. Another indication is that the document title seems not to be used in the indexer, it uses the given document title. You might want to consider some members to be lazy. You are now doing work on construction while it might be much later that a value is actually used. Note that this depends on the usecase. 

I would also change to a normal class without title and a lazy field. About the and the , they seem to be the very related. It seems you can construct an instance from an , this would make the an ideal candidate for the factory of . Such a factory is commonly at the companion object. Note that I would personally introduce a case class for document. 

Regarding the whole organization, it might be better organized as a small command interpreter with specific commands for hint, level etc 

Does position have a constructor? If not, it would be nice to create one for it. If yes, it would be better to use it. 

Here are some suggestions. Get rid of data types that do not carry their weight. For example, Shape should really be one of the constructors. plane.hs 

Note that positionx and positiony may best be stored together in some datastructure - perhaps a tuple Something like this 

One improvement is to not use the reverse end as the stack of current tag, but just use the current free cell from the beginning itself. It has the advantage of avoiding copying when the tag is switched. 

Avoid extra indent when one of the cases is simpler and can be dealt with easily. Also, about your ranges. They should really be named constants. 

Using auxiliary definitions can make your code read much better. Prefer sequence to do notation when values are not used in intermediate computations. Try to move out of the imperative mindset when using do notation. (the do notation makes it easy to write 'c' in haskell :) ), using auxiliary functions can help you there. (I used case instead of if/then because that is what I prefer, there is no particular reason for that except that it makes it easy to use destructuring easier if I need to.) 

It's clear that you took some time to polish your code, good job on that. I like how used method names like , the allow for very readable code. My suggestions (note that none of the code was tested or compiled): It's 'weird' to combine a class and a . A case class gives you a few things for free: 

Note that for the implementation of the implementation of (without title) makes things a bit tricky. For that reason I would add a relation in the document space, either with a or a pair. This would result in to be a map . As a result it would remove the call in which could then be renamed to allowing you to remove the comment. The two most common errors by Scala developers are the usage of on options and on futures. The only place these methods are allowed to be used is in test code. If have (to date) not found a valid usecase for either one in production code. There is a small problem in your method: is an integer and thus could result in . In the (and to some extend in the ) you have mixed statements in your code. As a separation of concerns those should be moved out of the code performing the operations. The functional programming paradigm is really strict in this sense and some of their patterns can help you to do that. The book Functional programming in Scala contains a section about this exact problem. Note that I would personally keep the statements in the app constructor and only remove the ones from the document loader (which I would place in a different class). As with all things, always search for a balance between effort and 'ideal world perfection'. 

stopWords is clearly a constant. So take its construction out. Also see that a set is used. It makes the member operation cheaper. 

by keeping a list of values equal to pivot, you can ensure that your sort works even if there are non unique values. 

We can depend upon tar to not create empty archives. So if the filelist is empty no tar files are created. 

The same program with a few changes. first, try to refactor your functions so that they are small, second, Often, using a case statement is more clearer to using cascading ifs. third, 'using namespace std' is a bad habit. It is probably ok to use in a small one off program like this, but avoid polluting your global namespace in larger projects. And avoid magic numbers when possible 

A small observation about your code is that it prints the error to the error stream in the case of errors. This is not always the best solution. A better idea is to indicate the error with a return error code and let the caller decide what to do about the error. (This is not implemented in below code.) 

It is nicer to separate out self contained functions even if they are of type IO a (You already have some, but take out as much as you can.) 

The method has a comment, requiring the user to do something before it can be used. Most programmers will not read a lot of documentation (apart from Ikea manuals) before using a library. In this case it might be best to help users of the method with an explicit type. 

I recommend the same structure for classes: public (and most important) members at the top. Then (in usage order) the other members. This is ofcourse personal preference. In some cases it's not needed to specify a type. For public facing members it's good practice to write down the full type. For private (and function local) members it's not needed and might actually introduce noise that harms readability. I noticed you are using and a lot. I try to not use them as they require the reader to backtrack to find the type of the tuple that contains them. There are a few techniques you can use to avoid their usage. 

With a case class you say: this class is defined by it's values. With a Traversable you say: this class is defined by it's contents. To me that is a bit confusing, is it about the parameters passed in, or about the contents? 

The class contains quite a lot of public members that are not really suited for public use. It's a good practice to mark methods as private that are only for internal use. This has (at least) two upsides: 

I added the unit test import here, and the set. It is rather adviced in haskell to look out for opportunities to take out general definitions when possible from a more complicated expression. The idea is to build the language to describe your problem and then use it to solve the problem by describing it. So lots of tiny general purpose functions are very good. 

Should you check this here? It is more of an assert than a problem with user input, and the user input is validated elsewhere. 

Any particular reason you handled the first one using exception and the second one using an if condition? Also consider returning an error code, If program can be used in non-interactive way, printing any errors to stderr also helps. I would also modify it as 

Your code is fine as it is, and there isn't much I can recommend. However, I believe that this may profit from being made into a class. 

consider for checking for uninitialized variables. The general convention is to use small letters for variables you don't export 

In the interests of people who have to use 80 char width terminals, I advice an 80 cols limit (or near abouts) for lines :) . I would also advice on verbose and dryrun flags to tell the user what is going to happen, and what is happening. The stdlib example is to just call .parse! directly and I think that that style is more rubyish than creating a new variable optparse. 

A few general notes I recommend you to reverse the general order of your code. Most important (or less detailed stuff) at the top. It's easier for readers to zoom in and see the important (public facing) bits. So if you have a program in a single file, put the App on top. Within the app, put the stuff that actually does something at the top of the file. I now have to scroll down and skip a lot of noise before I get to the actual stuff that is being done. 

It seems there is a clear relation between a and a , it seems reasonable to expect a factory method. 

You don't bother users of your class (yourself) with the internal details It allows you to easily identify which members can be safely refactored 

To me it's unclear why the method contains the code it does. It seems the code could also be in the class. Or, the other way around, the code for analysis could be in the factory (or another class). I would not use mutable structures to split the document space and documents containing a word, this is more sensitive to programming mistakes. On top of that it disconnects two pieces of code that are connected, forcing our brains to do more work. A simplified example using option: 

This particular method feels rather odd. All you need is a map that checks if img_src matches http:// and if not, returns an updated version. Here you are mutating a data structure within a foreach loop (it works I agree) while you have no reason to do that. 

I myself prefer the first form because it avoids the need to declare an extra variable, and in my (highly subjective) opinion, extra variables tend to clutter up program, and inhibits comprehension. In your updated example, I will jump in your boat if you change the for statement to while and remove found :). 

The given problem can be attempted in a slightly different manner. You can see that the pairing corresponds to binary digits with { standing for 1s and } standing for 0s. For e.g the pairing with the maximum value for say 4 {}'s is 11110000. So all we have to do is to generate every number from 1 to 11110000 and strike out all numbers that do not conform to our requirement - that is, at no point while counting the digits from left in a number, can the number of 1s be lesser than the number of 0s, and also that the total count of 1s and 0s must be equal. A few optimizations can be done, For e.g, all odd numbers can be eliminated. And the total number of digits have to be even, etc. If the number of braces are , then the algorithm is of complexity. So it is not an efficient algorithm. I wonder what the complexity of your algorithm is, and how you can show that your algorithm is indeed correct. For additional ideas ref: catalan numbers.