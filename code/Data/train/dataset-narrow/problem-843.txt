Let me make it clear for myself. You have an array of images, which sometimes can be empty. You start off by checking the first image, if it's valid for your needs you take it, and if not you keep on checking the next one, and the next one, and so on until you find the one which is valid. Is that right? If so, here are my few thoughts. Firstly, I must say that Glenn has made good points, namely: 1) factor the common code in all cases out to a separate function, and 2) if you have nested conditionals, most times it's better and more readable to replace it with Guard Clauses. However, personally I would prefer the following solution: 

I would also suggest that you look into some popular MVC frameworks (Zend Framework 2, Symfony 2) to get comfortable and confident with the concepts. 

This way you control the state of your object and have no need in the and methods anymore. Moreover, internally I would store the field names and values in one data structure, rather than in two separate arrays. The single structure could be a or a , the latter one is preferable if you have a class. This brings us to the class. I think, it would be more practical to encapsulate the field names and values within the class, which will yield a better OOP-style design. Also, this change will allow you to transform the class from an inner class to a static nested class, because you don't need the reference to the outer class anymore. After you encapsulate the field name and its value in the class, the field would naturally belong to the class. And because the class name is , the field could further be renamed to . One other opinion on the constants would be that you don't actually need them because you don't use them anywhere else besides the methods. So, you could just use the string literals instead: 

Let's me make a premise, I'm actually a consultant, helping a small indie team of quitting dependency hell, I'm basically re-writing a small game (30k lines of code). Turning it into a full-fledged ECS game. And I'm using an already existing ECS framework, not a mine framework. Explaining it is the most difficult part. I'm actually learning new things with every-day problems I face, so I'm not speaking to you as "expert", but as person that is learning. Sometimes I ask questions to the author of the framework I use and he is very willingly to help me and find better solutions to certain problems. Believe me, I come from a C++ programming background, so I always struggled to make my custom engine, dealing with allocation etc. I even started a 3D engine once, I would never do that again. What you are trying to achieve already however: 

suggests me that you already spent a good amount of time digging into the topic. While your first point indicates you are on the right way, your second point gives me the impression that you have been hijacked by articles written by people that do not really use the ECS pattern or do not understand the pattern at all (Unity, Unreal and Lumberyard are NOT Using the ECS pattern, neither in its old conception). To directly address your question, I think the best suggestion comes from @Laurent La RIZZA's answer: 

Update 1 Please look at the code below which should be almost a complete example. The method is the one which does the work using the database open. Notice that and may need to be provided from the outside of the function. 

One thing you may want to consider is remove the hard coding for and instructions. Instead, you can pick up current orientation's proper new orientation by the letter itself. 

, , and similar names are meaningless/hard to decipher. TypeScript just like JavaScript follows naming convention. Stick to it. I.e. should be , -- , and so on... 

P.S. As a minor side note, I want to mention that some devs like to explicitly mention the //... interfaces in the class' clause. I am not sure whether it's very helpful or a big deal, but at least the compiler will complain if the is missing while class declares that is implemented. 

Little note. I think, that from the "big O" point of view we haven't improve the algorithm. Since is \$O(n)\$, the performance of the entire solution is limited by the (which is probably \$O(n * {\log n})\$). The way we're potentially improving solution is by making sure that the constants in our "big O" cost are as small as we can achieve. Nevertheless, if we'd put the performance as top criteria of the solution, I'd learn as much as I can about the real data being processed; as well as conducted a thorough performance test. In real life scenario, however, I personally never put performance above readability, because I believe that lack of readability is eventually the same thing as lack of correctness ...and correctness is almost always more important than performance (few exceptions are known though). 

This gives an overview simplified of the design process. You continuosly refine things, because you can't predict everything. I Assumed objects have a position ok, but then after I defined the first piece of logic It was obvious that the bush was missing the radius for collision avoidance. It was not so hard to add it later. This kind of continuos changes are a real pain without an ECS system. And I added a Radius, without warrying if that could interefer with other engines, just because the engines are selected by the entity view, so there is not risk that adding the Radius to bushes automatically makes the bush processed by Radius-realted systems. Bushes are only processed by Systems interested in their EntityViews. If later I want bushes to be only slowing down player, I could altogheter remove the EntityView from the descriptor, and automatically I change bushes behaviour, without having to change engines, or without having to change the Bush. Honestly I think the final syntax in C++ will be quite different from C#, but I believe it is actually possible implement the same of Svelto in C++. 

I like the idea of this utility class, but there are a few points I would like to mention. Let's start with naming. I would rename the class, probably, to one of the following , , or . The rule of thumb is to put the / nouns in the end of the class name. Personally, I like the first two. Then come the constant fields which could be shorter. For instance, they could be named as instead of and instead of . That is, the 'BETWEEN' part is redundant because it's already obvious that a separator separates the one from the other. Two other fields would be better named as and , which is more intuitive. Another thing is that you have two separate methods for adding the field names and values and then you check that there is a corresponding value for each field name in the method. You also check for indexes and arrays' length in the method. All these checks are error-prone, but they could be eliminated by enforcing the one-to-one correspondence rule of the field names and values in a single method for adding those fields and their values: 

Functional vs imperative â€” hopefully not off topic Disclaimer I don't think that Codereview.StackExchange is the right place to ask questions of that sort. The answers may get extremely subjective (and result in a "holy war"). The issue is that there's no universally objective criteria which could be used to justify that functional code is by definition better than imperative ...or vice versa. I prefer functional... Still, I chose the functional code snippet you provided and improved it, rather than the imperative. Here's the reason why, but please take it as an opinion. In my experience, functional code is less buggy, so to speak. Now, I do not have any data to back this statement, and my guess is that the scientific studies on that subject are contradictory. Nevertheless, this is what I feel about it. Reasoning behind "functional is better" Here are a very few functional programming aspects and their possible effects: 

Returning is okay-ish for as long as the consuming will not need to store as a valid value. IMO, there are two better ways. Which one to choose is up to you. I am personally a big fan of defensive programming and fail fast approach. Thus, I'd prefer to so that the consuming code breaks instead of hiding a bug. I say "bug", because when a queue is empty, nobody should not even try to from it. If you disagree, you can at least make your class consistent with JavaScript. Return the same thing as the one returned by an empty array when is called (which is ): 

I think it's a matter of taste and preference. In either case, you would have to duplicate something. But, there's something that drew my attention. I don't claim it to be correct or be a solution to your problem. Hard to say without knowing the context and data structures that you use. Anyways, here we go... I noticed that in both cases, whether or not, you pass the same arguments, though to different methods. I suspect that this checking might occur in many other places as well. So, what if we create a method (e.g. ) and move this condition statement to that method. And the method would internally decide whether to add a new or modify the existing one. Somewhat similar behavior may be observed in the method, where the method checks if the element has already been added to the and then returns without adding it twice... Then, we end up with something like this in the client code: 

Once you have pieces of logic, working on Components, then you finally just need one further step to link that logic togheter, and what you need is actually a ECS framework. 

This allows you to implement entities in C++ directly (prefer always this, even though direct memory addressing of C++ allows you to do dirty things) 

This is deeply different. Basically you can select which engines process which entities without having to resort to specialized components or without resorting to usage of Tags or groups. Basically when you spawn an entity, you have to select in advance which engines will see that entity. You can change that at any time by updating EntityViews in its descriptor, if there are missing components a nice error message will tell you that (I think you can implement that at compile time with C++, I done something similiar in past). Basically you may have X entities in your game that have a Position component, but you don't want to process your position the same, so in example static objects should not even have Systems updating them, so they could just have a method that returns the position without allowing to change it (that method does not implement any logic it just returns data). 

This is a really good question -- starred it! I am not very experienced with RxJs, but I believe your code around and is as concise as possible. itself is "subscribable" (just like an ) but it's a really bad practice to expose it directly to the consumer, i.e. your separation of and is a right thing to do. Exposing is okay because it's designed to be read-only. is inevitable in your code, unless you decide to keep the usersSource state as a local field, but IMO it does not do any good in this scenario. Having state to be stored as a part of the is handy. 

Here's my take on it. The following code uses the same idea about the string representation of date that is directly comparable for sorting. It is not possible to tell in advance how performant will this solution be compared to one you presented above. It all depends a lot on how many dates are being sorted. If you deal with tons of dates, there will be many more invocations to the arrow function we're passing to . Therefore, it's not good to keep translating the date via every time our arrow function is being used. Instead, I recommend three steps: 

but let me explain why his suggestions arepure gold. ECS pattern is about decoupling all the game logic (yet seems most articles put focus on components, the point is deocupling the logic). 

Simply use EntityViews like in Svelto. This concept was introduced with that framework. And I really love it. Most ECS frameworks have this dull concept that Components are coupled with engines and every engine should loop all components of a certain type. They should not! Both for flexibility and performance issues! (there are even technical articles from AAA industries that use tricks like skipping updating Systems every X frames because they were basically looping too much). Everything in Svelto is decoupled. Most ECS frameworks have this concept: 

the ObstacleAvoidanceView could be something similiar to (assuming the avoidance is done using a circle or a sphere): 

When you instantiate a bush you also specify which entity views it will implement, so basically this allows it to be processed by right engines. In example if you want bushes to be avoidable by avoidance algorithm 

but what if the read asked for a block of characters instead of a single character, and then iterated through the characters one-by-one? Usually, it is way more efficient. However, the documentation says that the data is being read from the buffer, so there may not be any performance improvement at all. I'd still give it a try for the sake of curiosity. Another thing which might be slow is . Again, I'm not sure whether it's really expensive in node.js but it might be, since it deals with I/O. Try benchmarking your program without any console output invocation. If it works faster, you may collect all the messages in memory while doing the job, and dump them all at once when the program is done (since your input is really small -- 360 words). Minor performance improvement There's no need in three s, and es in . Assuming that all node objects in the provided array are in a good shape, you can sort using a fat arrow function that relies on simple subtraction operation. This approach is very commonly used for comparison.