Why are you first removing the quotes and then putting them back? And why are you removing the brackets and them putting them back? This does the same thing, except change ' to ". It also doesn't handle commas in names, so if you have that it won't work. In that case I'd probably use a regexp. 

Update: sucks, and that means your format is inconsistent and not parseable without horrid hacks. In that case your code seems OK, although I'd probably do it differently. I would most likely use a regexp to find all cases of commas that are NOT preceded by > and followed by a space to something else, say chr(128) or something like that. I'd then parse the code with my code above, extract the email from withing the brackets, strip all quotes and brackets from the remander, and replace back chr(128) with commas. And the lastly write that to the outfile. The difference there is that I don't try to handle a horrid format, I first try to fix the problems. It makes for cleaner code, IMO. Update 2: I instead replaced the commas that should be split on, making it simpler, like so: 

This is neat and simple, but the result is a lot of HTML inline. One of the templates is 219 lines long... :-) The other technique I use is to include the template as if it is a script in the HTML: 

Try to put configuration-like parameters to the left and data-like parameters to the right, it composes better. condenses much conversion. lets me improvise a query language so I don't need to unpack the tuple everywhere. You already wrote and then you didn't use it. 

can be assembled from library functions. To reduce code duplication, turn the parts that differ into the parameters of a function you implement once. The things you happen to be doing here can be written in terms of a few modules. Try to inline everything that's used only once. 

Here's how to use to brighten the day a little. You may have hoped for a way to do only once after combining the s with ... but I also don't know how to do that. If went to arbitrary MonadError instances, could have been more concise. 

You can make nonpartial by using . Then it turns out that already implements that and calls it . Using it, you can eliminate another case from pull. 

provides a matching instance for , but we want to modify the number of s to one, so we'll need an . Let's submit that. Usually could have done our job, but we don't want to target the arguments of the and constructors. 

With cred to @Vedran≈†ego for kicking me in the right direction, my current solution is simply to split the two regex-parts into separate parsings, the first one a split (instead of a match) and the second one a findall on the floats (because doing a split is near impossible, as - both should and should not be a separator, depending on context).: 

It's more than okay, it is nicely readable, has no problems and involves no abuse whatsoever. I sometimes do the same. 

I'm doing my first major jQuery development. It's a Widget for recurring events, and is as such a fairly complex beast. The full code is available at $URL$ for those who want to check it out. I appreciate any kind of feedback about any part of the code, so anyone who wants to take a look at it, that would be awesome. I have a couple of specific questions, and it seems best to put them as separate posts, so here is the first one: Does my directory layout fit with what a jQuery developer would expect? Is it "best practice"? The directory structure is this (somewhat simplified): 

I'm doing my first major jQuery development. It's a Widget for recurring events, and is as such a fairly complex beast. The full code is available at $URL$ for those who want to check it out. I appreciate any kind of feedback about any part of the code, so anyone who wants to take a look at it, that would be awesome. I have a couple of specific questions, and it seems best to put them as separate posts, and here is the second one: I have several big snippets of HTML and I'm using jQuery templating for this. My question is on the best way to include these templates. Currently I'm using two different ways, and none of them are obviously better than any other. In one case I use a string literal: 

I don't see the definition for , and your first code paragraph doesn't look like Haskell to me. You have one more place where you could use your . Both uses are for , so you could instead wrap in your name for it which returns a . Assuming a lens into the content field of : (note that ) The source of $URL$ seems to want to give you the attributes in s too. Maybe they have reason for this - should you also retrieve that in ? If so: 

In general, I'd go for the second sort of approach. It scales better. I'd eliminate four names and the hack like so, at the cost of and : 

Successive elements of the list returned by genPositions and xs are zipped together; captures this pattern. i is now not needed in its non-rooted form and I recommend changing the interface to take N as an argument instead. Non-square arguments can currently crash !! anyway. genPositions is only used once, therefore I inline it. 

Library functions, particularly Maybe's Applicative/Alternative instances, can make your code more consise: 

<- You want . implements some of your stuff already. I wouldn't introduce the types and in the first place. They just introduce wrapping without extra type-level structural info. 

As you can see, the reason you can't use rndStr directly is that rndStr uses IO. So it cannot be directly used as a function. You can think of it this way. rndStr returns some thing that is wrapped in a box. You need special constructs to unbox it, and the special construct is either <- . You might also notice that main has the same kind of signature. That isn't a really good analogy, and I am not the best teacher :). So if you really want to understand what happens, it might be better to read any simple monad tutorial. 

Your code is fine as it is, and there isn't much I can recommend. However, I believe that this may profit from being made into a class. 

Avoid excessively long variable names. I know that various books advocate longer variable names, but often they take away from your screen real-estate, Also, try to restrict the width of your statements to about 100 characters. It is a little more easier on the eye of the reader. 

Why not use a hashmap as the main DS? That way, you optimize for when name and event are defined, and suffer only a constant penalty and degrades to linear for other cases. (In your solution the cost is always linear). (As below) 

I would separate the looping queue logic from the rest. A general implementation of necessitates a state monad here. 

Edit: Second: Shuffle arguments around so eta reduction is feasible. Also inline most stuff that's only used once. 

fires when returns an empty list; we'd expect to be able to ask that question only once. and do not deserve names - if you want the reader to be able to tell what the value means, comments are more appropriate. Most of the rest of is about descending into a nested data structure and changing a small part, which specializes in: descends into the board, then each of its elements, then each of their cells. gives you, roughly speaking, the positions of the targets in the original board - it separates the board into a and a for each target. lets you forget there was an . 

The explicit recursion in can be averted by using library functions that specialize in particular recursive patterns: 

is . points out some redundant brackets and suggests using in . , and are superfluous once-used one-liners. All the passing can be abstracted with the monad. For example, becomes (I assume reversing the order of adding does no harm) and can be inlined. And s are , so no need for . And becomes and can be inlined. (I note these because it might otherwise look like I'm rewriting the code from scratch as opposed to reviewing.) 

Well, it is subjective. :) so this is my understanding of the situation. Use the particular operator depending on what you want the user to understand immediately, that is try to be as specific as possible. In this case, what you want a reader to notice is that the value of is updated only if the previous attempt failed to return a value. So I would go for which is explicit about the value on the left. The operators and have a different purpose. They are used if the normal execution always goes through however, for some reason (which is checked by a boolean expression ) you make an exception to this current flow and do not execute . I do not think that your above workflow is suited for this from this point of view. 

Any particular reason you handled the first one using exception and the second one using an if condition? Also consider returning an error code, If program can be used in non-interactive way, printing any errors to stderr also helps. I would also modify it as 

Also remove all the magic numbers like 600. They should be named with some meaningful names, and those variables/constants should be used instead. You can reduce some thing such as this 

To bring 's last lines closer in method with the rest of your code, you could do and put another to the right of . (Or , because the repeats everything anyway, but that's kinda incidental.) When you implement a transformation of a simple partial algorithm into a safe one, chances are 's already got something, here . in its prefix form allows me to not close each option with a multi-line closing bracket, and shuddup indentation blocks split code into units just as well as names do, and then you don't need to choose names for everything. Each option even already lists a description of what it does! 

Another thing that comes to mind is that k*k might be faster than k^2 for obvious reasons. looks it up Oh hey maybe you want to look at $URL$ 

Your example would then look like . By the way, whereever you're using the Eq instance of Tank, consider pattern matching instead. 

When you need to reverse afterwards, that's a hint you should have folded the other way. But this can even be written in terms of : 

And just for fun, this should only traverse the counts result once. (Requires that indices is sorted, though.) 

As you suggested, there is a difference, however, it seems that the difference is actually in favour of case statement rather than if. I am not sure what to make of it, especially since you seem to have a different result. However, the time difference does remain if I increase the number of loops. 

I suspect a simpler approach would be to just join the tokens together to form a sentence as string, and then use list of regular expression patterns to substitute each case. This will reduce the complexity, and will be much more readable than your example. (I will flush it out later.) pseudocode: 

Do you really want to go recursive on this? Binary trees in the worst case may be a linear list. A better idea is to do some thing like this: 

Should you check this here? It is more of an assert than a problem with user input, and the user input is validated elsewhere. 

Note the use of , I feel that it is better to do this than to distribute the cleanup code every where else in the function. Now, observe the functions below. Another way to do them is populate them into a table rather than defining function wrappers as below. An advantage of that approach is that, you could avoid defining too many helper_x functions. 

Here's a version of your list of lists version using list comprehension and no !! and no explicit recursion: 

I would inline, eta-reduce and use more library functions to make the code short enough that adding another command is trivial. Perhaps give the fields names so adding another can't mess up numbering, and you need less comments because the code describes itself. Edit: I'll use non, making the map not add a value for new users until they want to change it. This way we don't need to initialize with on logging in, and we can get rid of the Just returned by the "get" action without needing to promise we already initialized. (Which we don't necessarily have, as the initial ""!) 

Have some rewrite rules applied, combinators used and helpers inlined while I think about your algorithmic question. And make a . 

One property that comes to mind is that applying any permutation before does not change the result. But what is a permutation? I'd say it's a function that doesn't exploit properties of the element type, has a left inverse and preserves the length. (The first ensures that only input elements are used. The second ensures that no elements can be dropped. The third ensures that there is no space for duplicated elements.) 

Declare the variables at the place you want to use them. Here, firstNumber, secondNumber etc are to be moved to makeSum method. 

Notice the underscores in member names, these are converted to their lense equivalents by makeLenses 

The options are globals. So perhaps it is better to specify that explicitly. This will help in modularization later. 

I think this is better than repeating the state@ again and again. I think the below might also be nice since it is avoiding the repetition of foldexpression 

Consider making an error function err() { xecho $@ >&2 } errexit() { local exitval=shift; err "$2" >&2 exit $exitval } I feel cat is cleaner than multiple echoes, but it is just a preference. Also consider making verbose a function 

Your fetch implementation feels like it is partly done. I would prefer fetch to either read the image or move the opening of uri completely to save. Right now, the resource (an open connection) is acquired in one method, and used in another, while you could have done both in one go, and avoided that. (I suppose there is nothing wrong in that, but it just feels wrong.) 

Another advice is to avoid magic numbers in your code. If there are any, they should be declared in a highly visible area along with their purpose rather than buried deep in the code.