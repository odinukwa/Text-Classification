Do not do this. Think in real-life terms to keep things straight. A is a ? That does not make sense. A has to display stuff on the screen so it is (inherits from) a Window - whatever the appropriate class is in Java. 

You are beginning to mix up the business logic with the user interface. You should (be able to) design a "game driver" class without regard to user interface. You want to keep your GUI code separate from your game logic code. And another OO paradigm is to create new objects separately and pass them into where they are used. I see a class ( "Dealer" might be a better name) that handles the cards, deals them to players, etc. Then your class wires-up it's buttons to the methods. For example a "Deal" button's click event handler might be . pseudo code for the idea: 

Refactor DB calls out of classes i.e. Separation of concerns; Single Responsibility Principle; Maximize cohesion and minimize coupling. To facilitate this, you may want to design "data transfer objects (DTO)" classes (collections) to pass to your new database code layer. The idea is an object of data w/o little or no behavior; simply for the purpose of cleanly and conveniently passing data. And certainly your classes can integrate these easily. You may want to think about making these DTOs inner classes so or , as appropriate, has total control over them. 

As per the previous point - a model class cannot be named "Model". Controller By defining a class called Controller - CakePHP's base controller class cannot be used. 

There would be little point using the code as presented if it didn't make life easy, and not escaping any of the properties would make it cumbersome and error-prone to use. E.g. you've got this in the Testing section 

Be aware of the difference between isset and empty This will return true if the userid in the session is e.g. "" 

No I'm not sure why this question is tagged CakePHP but since it is: This is not CakePHP code =). Some specific points to elaborate: session_start, $_SESSION This should not be in any CakePHP application code - The session is started on demand whenever it is first accessed via the Session component, session helper or the CakeSession class. include_once Files shouldn't need to be included explicitly at all in CakePHP, there's a standard way to load everything. For classes that is using App::uses, for template files it's Controller::render and View::element. Model By defining a class called Model, even if it were loaded correctly - CakePHP's base model class cannot be used. new Model This is not the right way to construct a model in CakePHP - the normal way is: 

Sure, the above is putting off actually doing anything, but we're going fractal here. will internally pair players... 

Why do you have HEAD and TAIL NodeTypes? Doesn't their position on the branch tell you that? I'm concerned that you have structure traversal code infused into class. Classically the structure - tree, queue, List, etc. - is independent of the objects it holds. I would think greatly upon using something like , , etc. Use that structure's inherent reference/traversal features in the context of . - wrapping (inheriting?) that structure along with your concept of into a class that is essentially a class. I wonder, is what you are really building? In any case I suspect the separation of concerns will make the idea standout better conceptually and architecturally. How many palaces do you have defined I wonder. Why is enum defined inside ? That's unusual. You want it hidden from client code? I don't think so since you have method parameters of . 

Now What? Where/what do you want this to evolve to? Not much else to say w/out that vision. Nonetheless here's my "first thoughts": Hit vs Sunk The should end with the ship sunk. This is a good place to start evolving the code because it addresses the core state management of the game. Getting core fundamentals right profoundly effects the entire app code and structure. And "hit vs sunk" necessarily motivates structural changes of the game's objects. My immediate thought is the ship itself. Firing Encapsulate the random number generation into a method that exposes the idea of firing the gun. I think there is no point of a particular ship firing. That may be obvious from actually playing "battleship" but these sorts of things must be explicit. Ship Class Will have to know how many hits it can take and how many it has taken. The fact that a ship has 1 or 20 "hit points" should not be exposed in the loop or anywhere else. The ship may know where it is in the ocean (every ship has a navigator doesn't it?) - so it can tell if it got hit. 

Yet the code in the question isn't simple. It's 180 lines of code that mostly duplicates built-in php functions. To wrap the functionality in a class, simple would be (example and almost pseudo-code): 

When the time comes to write unit tests, the code shouldn't need to be modified. Changes to make code testable are usually trivial - and just mean planning ahead and having appropriate methods to set and get data. Be secure As indicated by other answers an unsalted sha1 password is weak. Passwords should be stored such that even if someone gets access to the database, they can't determine the original password. It's not hard to store passwords securely, here's some pseudo code: 

I use gearman as an example - but you can implement it any way you wish. Just ensure your solution account for jobs that fail intermittently (job fails once, reschedule for later) and for jobs that fail consistently (something wrong, job fails 3 times - flag for action). 

In this way the embedded logic in the build method is separated and more obvious - and the repetative logic is avoided. It also becomes possible to run the function whenever the data changes rather than each time a call is made to return output. Concusion Some of the other answers have focussed on the use of public properties, on that: what does it matter. There are more fundamental concerns to address with the code presented in the question. Whenever writing code, try to apply the DRY principle not only to the code you write but also to the code as executed. In this way you get code that's easier and faster to read and run. The way the class works is only 'easy' to use if you want an absolute url. The build method should be refactored to permit only real possibilities. If you're already using the class with more permutations than just absolute and relative urls - you'll need to decide whether to change the calls or the code so that it still works. Assuming your code already works you're in a perfect position to write a few unit tests for your class (if you don't already have some) - and then start tweaking it. Writing unit tests will give you the confidence to rip the guts out of any code and know that if/when the tests pass - you've safe to commit your changes and benefit from your shiny(er) code and/or new-found knowledge. 

I think what Disco Beat is getting at (and very rightfully so) was that from a object oriented mindset you are approaching this problem incorrectly. I would recommend looking up and researching the difference between mutable and immutable objects if you are unsure of what they are. That said the point I want to get in (which was already slightly covered) is to the idea of hiding the details of a class and offering solutions to manipulate data. I often think of the car illustration: How do you calculate fuel level? Do you first put on a new gas tank, then set the number of (gallons/litres) then do the math? Or do you look at your fuel gauge? Many examples on the internet would have you do the first. Instead you should just offer a means to know how much fuel remains. The code difference would be (bad) 

out of curiosity I double checked the work and you missed two scenarios. A win in column 2 and a draw. My solution looks like this 

Notice that it introduces some duplication with assigning index. Since you have passing tests that means we can refactor a little bit. Now I know you are probably thinking that the reason you put the assignment in the while loop was to remove duplication. Before we address that though lets attack some of your naming. Index. Normally this is a good choice of words to use, but index usually refers to a location in an array. Although a string is an array of characters in this context it is not the exact definition of an index. So I believe a more appropriate name would be , , or even this would allow us to make a sentence out of our while and if statments by giving a name such as or since it is a constant . 

Changing the answer would completely destroy the illustration for the future reader. Updating the original question in response to answers is discouraged on StackExchange. Distinct from error corrections, it can cause answers and comments to become wrong, non-sequitur, and confusing overall. I would say however that additions, distinct from changes, can be OK sometimes; particularly for clarifications requested in comments which are common immediately after postings. But even then, conventional wisdom says to fence an addition with (bolded) "Edit .. endEdit", and a brief "why" is helpful. 

The terms similar and separate are confusing when considering class design. So allow me to think this through... 

This answer is post preferred pick This pattern is fine if exiting on the first invalid condition is what you fundamentally want. OF COURSE what if scenarios bring other considerations into the validation code design. As the code evolves refactor the validation structure as needed. I agree with @slugster - change the name to (or , whatever) because ... "IsValid" vice "IsValidForDB" method name is a paradigm shift A valid business object is one thing. Putting the data into a database is another, separate, thing. Do not put database features/limitations in your object's business rules. The generic means we are validating the object for problem domain business rules. Valid or not the database puts demands on us that are not problem domain validation issues per se. For example how do we store ? As , the blank character, or some other arbitrary character(s)? So changing the method name acknowledges these separate concepts and therefore we codify these separate concepts literally. Code that must transliterate values to/from the database should be in some data layer of code independent of your business object. 

I'm not particularly fond of the style of coding, not everything needs to be a class. But there is only one point that I feel warrants significant attention: Huge Point: Not escaping means not useful 

By using crypt and blowfish (the string '$2a$' indicates to use blowfish encryption) passwords are stored securely such that password leaks such as the recent linkedin incident become a none issue. Be configurable In the above code example, blowfish and a cost parameter of 10 is used. Instead it would be better to make the hash algorighm used configurable: 

Especially where it appears inline somewhere - use whitespace for readability. Sprintf If you find that your code gets to be like this: 

It becomes difficult to automatically serve optimal packets. If each individual request results in 1 js file that is sub optimal, as the user receives one file per page, but the same content multiple times as they browser around the site. As such it's likely better to define all js packets in a config file and only refer to the packet names rather than permit dynamic usage. Appropriate Headers Whether you heed or ignore the above, this point is the biggest failing with the code as presented. There are 2 ways to handle headers for asset files (css, js images), the serverver and/or the php script needs to implement correct headers for optimal performance. Validation requests A short expiry is sent in the headers, the user sends a request and a successful response is either a 200 or a 304 - make sure to be sending 304s where appropriate. This means a user downloads the file once on the first request, and on each subsequent request for the same asset they receive an empty 304 not modified response. Not sending the user back the same file saves bandwidth and increases speed. Long expiry If the url changes when an asset changes - there's no need for validation requests and you can send in the headers that the response is valid for - e.g. a year. This means a user downloads the file on the first request - and never requests it again. Validation requests are a great improvement over no/incorrect cache headers. Long expiry is another significant improvement. Finally: Look for existing solutions You may find repos like this one useful, either the code, the docs, the api or all of the above. Try to avoid the mistakes that many have already made before you :). 

in actual code above I said the assertFalse method expects that you give it a Boolean value (true or false) and the value should equal false. If it is true than the test will fail saying words along the lines of and give you a line of code where it said that. Hope this clears up this subject a little for you. Make the test pass Now I wrote that test first before I wrote anything in CommandLineParser. So it looks like this right now. 

That will at show that helps some too, and you don't have to add a string always. And the last option (the one I prefer) is to use FluentAssertions. It's a personal preference, but what i like is that sometimes the TestFrame work of choice doesn't work and you end up having to switch. Using FluentAssertions you would only have to change the attributes for your test methods and test classes. Plus I like the way it reads: 

I'll edit this answer again later when I have more time. I have a lot to say. Since I've only had a chance to play with SceneView.java that is what I'm going to mention. the update method is too large. It needs to get broken up into smaller pieces. Typically I personally like to grab everything inside a loop (be it a while loop, or a for loop) and put it into a new method. With your update method I made 2 more methods: and . I notice too that you switch back and forth with how you iterate through things. Be consistent. Here is a small look at my solution. Note that there is a small bug introduced with this method because your current mode of drawing relies on each matrix being drawn at a specific order. 

Mixing and usage is a little strange, as they are functions which overlap in functionality. file_put_contents in fact is just a wrapper to call , and - expanding that call to it's component parts would therefore make what the code is doing more obviously repetitive. So, the first goal I would suggest is to avoid repeatedly opening the file to append text to it; the goal of the function is simply to append bytes to a file - so make the function do that, in one write call. An example of what I mean is: 

since it tries to talk to the database, which isn't connected. You can use set_exception_handler so that you don't need to scatter try catch blocks around your code where the intended result is to do nothing except logging and show the user (or developer) a 500 error message. With that said, some more detail in the order points are encountered reading the code: Don't mix presentation logic into classes Unless the class is dedicated to presentation logic - don't put presentation logic in it. This simply means don't return or assume html, instead just return appropriate data (booleans, arrays - as appropriate). The function is an example whereby it would be better to just return the array stack and let something else loop over it and dump to html,json, the log etc. Don't create needless classes The error class doesn't seem to offer any benefits. I.e. this: