I think when it comes down to it, short of writing your own codec or something, if a user wants to view the videos, they'll do it. For the most part though, I don't think "regular" players will be mucking about in the game's install directory. If this is a single player game and they player chooses to ruin it for themselves by watching the video early, then so be it. It's their game, they paid for it. If it's multiplayer, then maybe they'll be able to see something before they get there, but then, they could just ask a player who's already been there. This actually goes for single player too. So, I'd say don't worry about it. Just make a great game that they'll want to keep playing to see the new videos. 

Your player is moving towards an obstacle. Player's next move intersects obstacle. () You move player in the opposite direction. () Player is holding down button and velocity gets set again since the player is not against the obstacle. GOTO 1 

Is it possible that when it recalculates the next best position, it thinks going "forth" is a good idea so it goes that way. Then, when it checks a half second later, it thinks "back" is a good idea and goes back that way since you're erasing the old path? As John McDonald described in the comments, to fix this you could weight the points already on the path so that it's more likely to follow the previous path but isn't necessarily stuck to it. 

You can probably get away with not resetting the scissor rectangle for this basic situation, but you need to reset it if you want to draw other things (like those backgrounds). This example also assumed a lot of variables which you can infer (I hope :-) ) from their names. A few other notes on the variables: 

The fact that you have so many more pixels than if you were rendering to, say, 640x480, means that if your textures are low resolution, you'll be able to tell, or more importantly, your players will be able to tell. As for models, if your models are square and blocky, then yes, this will be noticeable and you'll also want to make new versions that look round and smooth in higher resolutions. Perhaps this can be solved with textures, but that's for you to decide when you're designing it. 

The way I handled this in my simple textbox UI element was to use a scissor rectangle (as Nicolas Bolas said while I was writing this :P). Here's the basic idea: 

I think that's something you'll have to figure out once you run it in an HD resolution. The better the quality of the textures, the better things will look in game (theoretically). But they also take up more memory and may take longer to load. Maybe you'd want to prioritize what textures have the best resolution (i.e. the main character that the player is going to see ALL the time) vs ones that may not necessarily be important (i.e. the top of a mountain). 

1) Consistent Framerate - At least on console, since you know the hardware limitations. It's difficult to ensure the framerate won't fluctuate on PC since you can't control the player's hardware. 

It seems to me like people missed the XNA tag on the question, so here's an XNA-specific answer. First of all, you need to add two variables to your class (if you don't have a class, add them to the class where your method is located): 

Attach your "object" bodies to their respective holders using s. This locks your objects to the holders but allows them to rotate freely. 

If you're just trying to calculate the experience at (10), and you want it so that each level requires (28) more experience than the last, you can just use this formula (without the loop): 

You could do what Gustavo - Gtoknu said and pass the content manager variable into your ResourceManager class OR you could create a new content manager. You'd have to have a reference to your main class, but this is the idea: 

The " value" part of step 4 is referencing step 3. So, in step 4 it's saying "sort the points array based on the values in the array you made in step 3 (using something like quick sort)." Now, if sorting that array of values will get you the clockwise order of points, then sorting it in reverse order will give you the points in a counter-/anti-clockwise direction. Hopefully that clears it up a bit for you. 

Now, there's a few things to note: Regarding Point 4: I actually have two custom shaders, one to draw the lights to the lighting render target (step 4) and another to draw the tile render target to the screen using the lighting render target (step 5). The shader used at point 4 allows me to add (what I call) a "luminosity" value. This value is a that gets multiplied against each pixel in the texture before it's added to the render target so that I can essentially make lights brighter or darker. At this point, I also take into account the light's "scale" value which means that I can have large or small lights using only one texture. Regarding Point 5: Think of the lighting render target as essentially having a value for each pixel from 0 (black) to 1 (white). The shader essentially multiplies that value against the RGB values for a pixel in the tile render target to make the final drawn image. I also have some more code here where I pass in (to the shader) a value to be used as the day/night overlay colour. This is also multiplied into the RGB values and included in the lighting render target calculations. 

Based on your code example, it looks like you use the alpha channel in your bitmask to determine whether or not to draw a pixel. It also looks like you treat an alpha of as "draw the pixel" and anything to "not draw the pixel." I'm also going to assume that in your bitmask, you can make anti-aliased edges in the alpha channel where the alpha value is between and (exclusive). If any of these assumptions are incorrect let me know. Now, assuming the above is true, you should be able to do this simply by using this code: 

Saying your game supports (or is) HD, basically means that it can be output (/displayed/rendered) in an HD resolution (for television screens). For a 1080p TV the display resolution is typically 1920x1080 pixels and for 720p it's 1280x720 pixels, assuming a widescreen aspect ratio of 16:9. Most modern computer monitors are able to display these resolutions and others crisply without a problem. However, older TV input standards (i.e. "standard-defition") required that the display resolution was much smaller and so older video game systems such as the N64 and PS1 would effectively be outputting to resolutions of 640Ã—480 (NTSC, 480i). There's also the issue of 1080i vs 1080p but that's outside of the scope of this question. If a game says it's HD, it means it supports, and was designed for, a high definition resolution. So when you run the game at 1080p, the graphics will be crisp and clear, and the framerate will be consistent1. 

The code you have gets the position of the camera but doesn't set the direction it's pointing. You didn't create the view or projection matrices yet (at least, not in your example code). Perhaps this is the problem. See the next steps in the MSDN article. Here's the code (from the next two steps) that creates the view and projection matrices: 

I think one of the most important things you can do is choose a game that you enjoy playing. This will help keep you interested in it and will make you more familiar with how the code itself translates into the players perspective. Once you've picked that game, regardless of how big it is, you don't have to try to figure out how every line of code works. Pick a piece of it and look at that. For example, try to figure out how player data is stored or how a menu item is drawn, etc. The next thing you can do, which goes along with my previous bit, is try to change something. Not something huge (at first), just something simple and noticeable in game. Even something as simple as the text on a button on a menu or adding a menu item or changing damage calculations. Maybe you think they should have done something differently, try to change it yourself. When I first got interested in developing games, I was really into 2D online RPGs. So I found the source for one online and I started building onto it. Adding my own features and tweaking things, fixing bugs, etc. That was in VB6 a few years ago and now I'm using C# and XNA and writing my own game from scratch. Because I enjoyed the games, it motivated me to want to work on it, to make it better. Coincidentally, this is also how I learned a lot of the programming, debugging and problem-solving techniques I use today in my non-gamedev related day job. It's also very helpful if the game has a community of modders that you can ask questions and get help and examples from. But then again, even if that doesn't exist, you're already here and we're ready to help. 

Make your real objects rotations match each other by attaching an angle joint. Note: you don't have to attach an angle joint to each and every pair of objects. Just add an angle joint to the main body and the other body and the rotations will translate across all objects. 

What you could do is have certain quests that involve many people or require a certain number of people to complete it in order for something to happen. You could also have a counter-quest/decision that prevents it from happening (or causes something different). Then, once the requirement has been met, you can change the world based on that for everyone. Then, you can just keep going with that storyline and add new quests based on it and make it part of the history of your world. I know that some games do things like this but have "ages" or "epochs" whereby after say, one year, they reset the server and everything goes back to level one and the "world decisions" that were made are undone. Thus allowing people to make new decisions and see how they affect the world. You could even make the trigger for the reset a huge end-game quest that involves all the players on the server. So that, unlike many MMOs, you can actually beat the game! Edit To address Lohoris's concerns (see comments), you could set up a system where the story for one "age" ends but a new story begins based on the world at that point. So if a city has been burned down because of a collection of player decisions, that city stays burned down, but maybe some pirates and bandits have moved into the ruins. Perhaps two ages later the players have the chance to rebuild the city. There's a lot you can do here. Doing it this way, you give players the ability to control how the world and the game itself evolves. Which would increase the immersion factor immensely in my opinion. 

Note: I've spanned some lines in order to explain what's going on, you obviously don't need to do this. 2. With Bodies You should also be able to weld two bodies together like this: 

What you want to do is have an boolean property on your objects that determines whether or not they get drawn/can be affected. You then create a pool of the objects (i.e. define and initialize an array of inactive () objects as large as the most objects you'll have active at one time). Then, when you want to spawn a new object, find an object in the array and set it's properties and then set it to . When you want to get rid of objects, loop the array to see what objects have an value less than 90 (or whatever) and set their . This means you won't have any garbage to collect and should help your game run faster. Edit Actually, if you used a stack (here's an implementation for actionscript) for the inactive objects and an arraylist for the active objects, then you wouldn't have to loop anything to figure out if you have available inactive objects. When you want a new object, you just pop it off of the inactive stack, set its properties and add it to the active list. Then, the game only draws items from the active list. When you want to remove something, remove it from the active list and push it onto the inactive stack.