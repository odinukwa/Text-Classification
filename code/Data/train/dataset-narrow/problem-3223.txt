According to me you do not want any additional circuitry for your ping ultrasonic sensor except a voltage divider. The physical pin 2 and 4 of Raspberry Pi zero give you 5V power and you can expect pull about 1.5A from these pins. But you only want 30mA to 35mA for the working of this sensor according to datasheet. So we can assume that there is no problem with connecting physical pin 2 or 4 of your Pi to Vdd of ping ultrasonic sensor directly. You can connect Pi's physical pin 6 (ground) also directly to ground of ping sensor. Then the problem begins. Now you want to make signal(SIG) pin as input. From datasheet it is clear that signal pin output can have up to 5V. But the 5V as an input to GPIO pin can harm your Raspberry Pi. Since it GPIO pins are 3.3V(CMOS logic) tolerant. So you want to make a voltage divider between GND and SIG pin using two resistors R1 and R2. If the resistances of R1 and R2 is same then the voltage splits in half(2.5V) since the maximum possible SIG is 5V. If the R2 is the twice the value of R1 then we get 3.33V approximately which is fine. So ideally we want R2 to be between R1 and R1 x 2. In this circuit we are using 330 Ω and 470 Ω resisistors. Alternatively you can use 270 Ω resistor and 330 Ω resistor or 1KΩ resistor and 1.5KΩ resistor. Then you can connect the SIG input to RasPi GPIO pin from junction of R1 and R2. I am very new in Raspberry Pi. So you should critically think about this answer. I believes Raspberry Pi Stack Exchange community will help you to think critically about this answer. 

You can request that motion take a snapshot at any time via its web interface. From a command line on the Raspberry Pi running motion, use 

This will silently request that motion take a snapshot and discard the response. A symbolic link, lastsnap.jpg, in the motion file directory, will point to the snapshot itself. See $URL$ details on using http commands to control motion. 

You should not need to reboot a Linux system, except to install OS updates. Your slowdown over time is probably the result of a program leaking memory and eventually causing page faults, which would be very slow from a SD card filesystem. Try , which will show all of the processes on the system, sorted with highest memory use first, just after a reboot, and then after 7 and 14 days to see if you can identify the culprit. Memory use is shown two different ways, in the SZ and RSS columns. Restart the offending program, and your system will run fine. Most Linux distributions will automatically rotate logs on a regular basis, compressing the older ones, and deleting them after a period of time, so your system should reach some level of logs and then level off. You can tune this by editing /etc/logrotate.conf A Raspberry Pi on clean power should last several years; my oldest one is just over a year of continuous running (in a weatherproof box outside with ambient temperatures from -10 to +90F). 

This will open the SimpleCV console. This is a Python console, with extra features for SimpleCV. However installation of simpleCV already asked on Stack Exchange. This may also helpful for you. If you are installed OpenCV before that may be a reason for failure of simpleCV installation. Alternate method for installing simpleCV is discussed on this article. But I didn't used this method yet. Since first method was worked for me. 

Once installation is complete, you can check that everything worked by running this command(You can also check is simpleCV installed on your Pi before using this command): 

I am using Raspberry pi in college lab. There is lot of wall sockets which are connected serially. If I turns on or off other devices on the lab suddenly my Raspberry Pi display become blank for few seconds. After few seconds this comes back. But my data is not loosing these times. Sometimes I also noticed that there is some rainbow coloured boxes on the display while this thing is happening. What is the reason behind this? Is there is any chances for turning on and off other devices harm our Pi? 

There are several ESP8266 based relay power modules. The ESP8266 is a WiFi and CPU chip and is widely used in Home projects for the purpose you are asking about. I prefer to program them with Arduino IDE and uses MQTT as control protocol, and as a hub I uses Raspberry Pi with Mosquitto and Node Red to create the logic that control the different devices/modules. I get my inspiration from: $URL$ Andreas Spiess channel $URL$ 

On a unmodified Raspbian installation you can reach your Raspberry Pi machine with url $URL$ if you install a web serve or for a terminal session. 

See ref. below. 2. Network interface names. Quote: Predictable Network Interface Names As if Stretch, the old network names like eth0, eth1 have gone away as the device name can change. The new names are similar to these: enp6s0, enp8s0, enp0s31f6, enp5s0. Ref.: $URL$ 

Not all USB Bluetooth adapters compatible with Raspberry Pi. Make sure your USB adapter is compatible. I believes this article may help you to find out a compatible Bluetooth adapter. To install the software needed to support Bluetooth, enter the following commands: 

These commands should work for all Bluetooth adapters supported by the Raspberry Pi. Now you want to plug your Bluetooth adapter. You can check the Bluetooth adapter is connected or not using this command after hot plugging the Bluetooth adapter: 

If not found don't bother about it. Just reboot your Pi. You will now find a new entry on the Raspbian Start menu under the Preferences section called Bluetooth Manager. Open this utility and click Search to look for nearby Bluetooth devices. Make sure that there are some Bluetooth devices set to be discoverable. It is my first answer. I don't know is Stack exchange expecting these kind of answers... 

The internal design of the Kill-A-Watt does not physically isolate the low voltage circuitry from the mains power. A direct connection from the Kill-A-Watt to the Pi would allow for the possibility of destroying the Pi or a lethal injury if there was a malfunction. No responsible tutorial publisher would want the liability associated with such a design. 

You can execute shell commands remotely using ssh. has more info than you'll ever want -- here's the essential info: Let's call the host on which you want the commands to run the target, and the host requesting it the client. 

On a linux client, this command will login to the pi, launch raspistill, and pipe the camera output (the .jpg) back to you. Using a certificate avoids scripting a password (see SSH login without password for an example of how to set up the cert). Syntax will vary, but the same thing can be done with windows ssh clients. I prefer this method for simple tasks, because it avoids the overhead of running a web server on the pi. 

PWM and solenoids, hmm doesn't sound like a good idea. The solenoids you refers to are either on or off, why do you want a half locked/open lock? I would propose 16 relays with driver circuits since the Raspberry Pi can only drive 16mA per GPIO and and not exceeding a total for all GPIO of 50mA. 

GPIO.cleanup() is cleaning up all the ports you’ve used. It resets the ports you have used in your program back to input mode. 

The HATs is a bit flawed. I cant see that the GPIO's that control the HAT can be changed and this mean that "HAT 1" and "HAT 2" is using the same GPIO. And a reflection, a Raspberry Pi is a bit overkill, a Arduino could do the jobb. 

The error is often mentioned when a corrupt image have been transferred to a SD card or when a SD card is faulty or kernel bugs. I have replaced a corrupt SD card due to this cause and that solved my challenge. 

Assuming your pi is directly connected to the internet (no intervening router -- verify this by checking that "sudo ifconfig eth0" shows your 103.37.x.x address), you will need iptables rules to accept incoming connections on port 80. I don't have a config were I can test this specific scenario, but you will want something like this: 

where user is the username to use on the target (can be omitted if same user as the client) target is the name or ip address of the target command is the command to execute An example with a user account jim on target host utilipi might be 

Generate a key using ssh-keygen on the client, using the account that will be making the requests. Accept the default value for any prompts. Copy the public key (default file name is ~/.ssh/id_rsa.pub) to the target machine, and append to the file ~/.ssh/authorized_keys for the user that will run the commands. You can do this via From the client, you should be able to run commands on the target with a command like ssh -luser target command 

The voltage divider isn't causing a current of any significant, the input resistance (impedance) is 45-65 k ohm. The total current is approx 0.77 mA and a 1/10 will be passing through the internal resistance (77 uA). So taking in the internal resistance in the calculation the divider will be 1.7v vs 3.3v and that's within the Raspberry Pi's tolerance 

The main constrain is if you write to the same location of the SD card. And as I understand you question, you arn't writing to the same file and changing the content of the file, but creating many files++++ then it wouldn't be a problem. 

The other way is to change the metric for the 0.0.0.0 route so that the route via LAN has a higher metric than the one for the WiFi. To make the router taböle permanent check out How to make a change to the routing table persist? 

This will bypass the handoff of those requests to the NAT logic on the FORWARD chain. (If you have existing rules on the INPUT chain, you may want -I to insert these new rules at the beginning rather than -A to append them at the end). Before you do this you should be sure you have physical access to the pi in case you lock out remote access. Don't save the iptables config until you're sure it works the way you want it to. You should also be aware that allowing direct access from the internet can be risky. You should be prepared to update your system regularly (perhaps even daily) to apply new security fixes; you should also make sure your web server config doesn't have any unnecessary modules loaded or allow any unintended access. My final advice would be to make a backup of the working system, and be prepared to trash the running copy if it is compromised in some way.