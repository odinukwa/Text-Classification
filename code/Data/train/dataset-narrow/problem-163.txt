I would however advise you to use a library for talking NETCONF, like ncclient for Python. The framing format (ending messages with ) used in NETCONF 1.0 is deprecated and a new chunked framing mechanism is introduced in 1.1. You need to know the length of the message so it's much easier using a lib than doing it manually. Also, looking at the capabilities announced by your XR device you appear to be running a rather old version. 6.0 is available and offers a quite decent set of YANG modules, see $URL$ 

The default load-balancing of JUNOS is to set the next-hop for a BGP route over one of the IGP paths, i.e. not to install multiple IGP next-hops for a given BGP route. If you add a second prefix in addition to your 77/22 you will see how it picks another next-hop for it so to achieve load balancing of your traffic on a per-prefix level. This works well when you have a lot of prefixes and your traffic is spread over all or many of these prefixes. If you are only looking at one prefix though, you will not achieve any load balancing of traffic. This behaviour can be changed. If you want to install all IGP next-hops you can set load-balancing to per-packet (which really isn't true on most platforms, it's hash-bashed). See this document for further explanation on load-balancing in JUNOS. Exactly how to calculate which IGP next-hop is picked for a given BGP route is trickier. I don't know the internal workings of it but I assume it is based on a hash of the prefix. 

Yes, only user plane traffic (GTP-U) is offloaded directly from RNC to GGSN with 3GDT. Signalling (GTP-C) on Iu-C and Gn-C interfaces is as normal. 

Indeed, they are quite different. Don't expect code compatibility between the two. Any experience you pick up on network simulations working with NS2 will be applicable to any network simulator so it's not all in vain though ;) 

IOS includes ttcp, albeit it might not be supported officially by Cisco it can come in handy in situations like this. JUNOS does not support ttcp as far as I know, but it's probably not too much hassle adding one central Linux machine connected to the PE that you can do measurements with. On IOS, you simply run 'ttcp', like so; 

A voice call is isochronous as it is transferring bits of your voice at regular intervals. The second part of the sentence 

There are a number of ranges that are reserved for various use cases. IANA has the authoritative and comprehensive list. It includes RFC1918, RFC6761 as well as more recent reservations like the 100.64/10 CGN block. If you find any addresses in there they are likely somehow used in a private network and should be discarded in favour of the others in search of the first public address. 

From this information we can then compute the shortest path by starting the tree at our own node (R2-4). It's also possible to deduce loop free backup paths by rooting the tree at an adjacent node. This is called LFA (Loop Free Alternatives) and is a way of achieving IP FRR (Fast Re-Route). The flooding of LSPs happens verbatim. Ie the LSP is not even interpreted before being flooded. It is therefore important that the size of an LSP is equal or smaller in size to the link in the network with the lowest MTU. 

Timestamp is based on NIC time. I believe you can modify the NIC clock but the more common way is to let the NIC clock be free running (guaranteeing monotonic time) and do any adjustment in user space. Adjustments could include working out the offset with system time and adjusting all received timestamps to system time. The kernel can/could (was a long time since I checked) do this for you but I believe recommended way is to do it yourself in your user space. In other applications you simply don't care about absolute time as the relative time between packets is the only important factor. Two colleagues of mine wrote a SLA measurement application relying on this. You'll find the source at on GitHub. There's also MoonGen which is a DPDK based framework with Lua scripting abilities for packet processing. They have an excellent paper including information on timestamping. 

From a technical perspective perhaps the "telephony network" should refer to the transport network that is carrying those calls, in which case it might not be isochronous (SDH definitely isn't) but when just looking at the calls themselves they are isochronous. Regardless of underlying carrier you will have bits coming in at regular intervals, representing the audio stream, thus making the voice calls isochronous. I agree that the sentence is a bit weird but depending on your interpretation it isn't necessarily incorrect. 

I think you are looking for the --retain argument, which allows you to retain routes in the kernel across restarts of the daemons. 

As the name implies a multi mode fibre can carry multiple modes of light. This is not the same thing as multiple signals. The multiple modes of the same signal only leads to modal dispersion which stretches out the signal in the time domain, due to the different propagation speed of the modes, making it more difficult to detect at the receiver end. This leads to a lower speed both in theory and practice than a single mode fibre which doesn't suffer from modal dispersion. Both MMF and SMF fibre can carry multiple signals through the use of wavelength division multiplexing (WDM), although this is much more common with SMF as its characteristics allow it to be used over longer distances where it generally becomes more economical to use WDM equipment. 

LSAs/LSPs (OSPF vs IS-IS speak) are flooded through the network. You are indeed correct that a LSP (I prefer ISIS) only contains information for adjacent nodes + certain IP reachability info from the node that sourced the LSP but flooding solves this and allows you to gain a full picture of the network. You can look at the LSP DB in a router. Here's some output from a virtual environment I'm working with: 

You are correct that on a layer 2 level all computers will receive broadcast packets, including ARP requests for IP addresses of networks other than their own. The IP stack of those computers will however discard those packets as they recognise it is outside of their own local network. 

This is rather rare in modern networks as mobile carriers want their customers to use as much data (they are getting paid for it after all) so you don't want to tear down connections. In addition, the UE will very likely send PDP create request so you will only increase signalling load by trying to tear down the PDP of an active UE. 

I think everyone is everywhere of how to get the number of available hosts given a prefix length of a certain size, for example with an /24 IPv4 prefix, you have 32-24 = 8 bits for hosts, giving 2^8 = 256 hosts or 254 "usable" ones. This is usually taught in any networking class or explanation of subnetting. The inverse of 2^x is log(x)/log(2) so to get the number of bits for 22 addresses, you just do: 

I suppose you don't want to put public addresses on your server, so you need to create a network connecting your different locations. Either purchase a VPN from your ISP or build your own IPsec VPN. To get a VPN from your ISP, ask for a "IP VPN" or "L3VPN" according to RFC2547/RFC4364. Feel free to throw in "MPLS" in the same sentence. They will often be able to provide you your VPN connectivity over a VLAN on the same physical circuits over which you purchase your Internet connectivity. IPSec means you need support in your routers and you need to manually configure those yourself (or bring in a consultant). Beware of MTU issues. Google is your friend :) 

The PDP context can be actively torn down, i.e. the UE sends a PDP deactivation request or there can be an inactive timeout in the GGSN. The timeout typically starts counting from the last transferred data on the PDP so for a PDP with continuous traffic the timer will be reset all the time. 

The timestamping happens in hardware based on a clock in the NIC. Depending on your NIC there's either a NIC register where your timestamp will be written or some card (Intel 82580) can prepend the information to the packet buffer. For cards that write the timestamp to a register you have to read the register before it can timestamp the next packet, effectively limiting your throughput, while the 82580 can timestamp all packets. In Linux, you will receive the timestamp in a data structure outside of the packet itself. Here's a bit from the kernel docs on it: 

We can see that we have received LSPs from all other routers in this topology and obviously we also have our local information (R2-4). It's possible to look in more detail of the LSP: