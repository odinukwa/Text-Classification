Both of these techniques are very powerful and have been used by many instructors over a long period of time. Of course, they may be combined to good effect. 

You could ask advice from one or more of the instructors, explaining to them your long term goals and seeing how the course contributes to it. Any of these three courses could be hard or easy, theoretical or not, depending on the teacher and institution, so I won't make more specific suggestions. 

Note a couple of things about this class. First it isn't very interesting since it has no methods representing actions of any kind. It is just an information carrier. Note that it is, however completely encapsulated. It has two mutators (setInfectionProbability, and update) and an accessor for the infection probability. This is not completely desirable, since in order to do anything with a disease you have to retrieve information from it and then carry out the action elsewhere in the program. It is preferable, if you can arrange it, to have objects actually carry out actions on a client's behalf rather than giving out information and having the client do the action, hoping that the client does the right thing with the information. This is the "Tell, don't ask" principle, which is important, but is not exhibited here. Note also, that the probability set in the mutator is "normalized" to assure that it is indeed a valid probability in the range 0.0 .. 1.0. Also, when a method body is intentionally left empty it is documented with a comment so that a future reader needn't wonder whether the original programmer just forgot something. A VirulentDisease is similar, but has an interesting update method: 

However, don't neglect the fact that the first and last of the three sections between the parentheses can have (in C, anyway) multiple statements separated by commas (comma is an operator in C). 

How would you do it yourself? If you are already effective at it, then show them how you approach it. Tell them where you look, and tell them how you decide that it is ok to stop exploring further for an individual resource or for the overall search. Otherwise, assuming you are less skilled at this than you'd like to be, give them (paper or electronic) a list of resources you have found with some added metrics that you would find useful for judgement. It needn't be comprehensive, but complete enough to cover their own needs at the moment. In the latter case, along with your list of resources, you can list one or two advantages and one or two disadvantages of each. Since you want them to learn how to acquire resources, rather than just pick one of yours, you could also say where you found the resource and where you got the most important information about it. It might be worth some face-to-face time for discussion of your list and your criteria with opportunities for students to ask questions. 

Unfortunately SAUS went dark in 2012 but back additions can be found at the Census Bureau. The latest numbers are old, but not yet irrelevant. Sorry that this is just links, but I don't know what else to say. 

The problem you pose is a difficult one. Every graduate student researching for her/his dissertation faces it. Suppose you have a particular paper in hand and want to learn from it. The normal solution can be expressed recursively: 

A note on "sameness". When we say $x = 3; y = 3;$ we don't imply that there are two threes. When we say $x = 3; ... x = 4;$ we don't imply that three has somehow become four. In the first we simply mean that we have two distinct references (names) for 3 and in the second we mean that the (old) reference to 3 is now a reference to something else. While every experienced programmer understands this, it can become a bottleneck for a novice. Three is three. 

Lots of misconceptions can be dispelled with a "play acting" active learning exercise like this. "Play the computer" is often helpful. Doing this proactively, as part of introducing return or print is probably not a good idea. Most students will "get it" from a simpler and shorter explanation. So this is the sort of thing you have in your kit bag for emergencies. 

Here is an odd historical note about medicine, that I'm pretty sure doesn't really apply here: In a few cases it isn't ethical anymore not to use some relatively ancient practice, so science is blocked from advancement in that area. The Pasteur Treatment for rabies is like that. It works, but is a dreadful process for the patient. But rabies is nearly always fatal, so it is unethical to set up a scientific experiment in which the control group gets Pasteur, but the experimental group gets (only) a vaccine. 

I'm pretty sure that a general answer isn't possible here and it depends too much on at least (a) what the student has seen before, and (b) how the prof and other available materials describe things. In strong OOP languages (or with a strong OOP style in a weaker language), I can give students a mental model of computation that doesn't depend on a map to a machine. There is no post office boxes metaphor or equal size boxes, etc. The student can go quite a long while with this model. In particular, all data can be owned by objects and each object has a dictionary (informal concept) that maps variable names to values. The dictionary may be editable (variables) or not (constants). An array can be defined as a function from an index set [1..n] to some set of values. The function may be modifiable, or not. etc. A variable isn't a box, but a mutable reference to a value. A constant isn't a box (or even a value) but an immutable reference to a value. My reason for doing this is that when they depend on a machine memory model and when they are presented with a problem they have to (1) map the high level concept in Ruby/Python/Java into the machine model, (2) think about how it works there and then (3) map it back to the code level. Avoiding the maps altogether seems to be an order of magnitude simpler. Just give them a single, high level model in which they can think consistently without errors of interpretation. But yes, many teachers were taught with a C-like model and so solve most problems in a C-like way, so they teach their students to do that as well. To me, a somewhat more interesting question (for your java <-> python example) is, does learning to program in a language with fewer rules but more dependence on style and testing for correctness (python) first help or hinder later programming in a language with lots of enforced rules that even make some legal problems illegal (since the type checker isn't omniscient). OR, does learning to get along with the type police (java) first, help or hinder later learning in a free world, where certain types of correctness are suddenly on the back of the programmer. Python programmer like to rail against the java checker. But they can also fall into holes that the java compiler would shunt them around. I like types and the checks they provide, but you may not. And of course, it matters more for some students than others. Finally, your model is unlikely to be a very close match with reality anyway. How many levels of cache? It is a low level artificial construct. I prefer a high level artificial construct. Of course I really had to know those things, just after the Chicxulub incident when I was writing FORTRAN. But at least the dinosaurs were gone. 

It took me a while, but I learned over the course of my career that the main job is to teach students, not to judge them. 

With these definitions, the invariant is true with the array in state [ any* ]. Solution: The solution is to run a loop that takes the any* section from "all" to "empty". You can do that either by (a) increasing , which breaks the invariant, and then re-establishing the invariant, or (b) by decreasing and re-establishing. Looking at $flag[index]$ will tell you what to do. Swap two cells as needed. A three case "switch" or equivalent is the body of the loop. The invariant along with is the postcondition. Therefore the while loop test condition is QED Note that it is a linear pass over the array, but with two variables moving toward each other from the end. Cool as a moose. 

A somewhat lesser idea is to prepare for a topic not normally in the course and prepare for it. A good time for the presentation may be on the last day of the course, especially when the final exam has already happened. Tension may be less and you often need something go pique the interest of the class on the last day anyway. Any of the three methods suggested above could be used, of course. I would personally choose the method based on the personality of the person and his relation to his fellow students. If it is especially open and friendly, the first might be less fraught/scary than otherwise. 

Every field has its own key issues and methodologies. History and Literature, for example, are very different from Computer Science. However, it is in the interest of those in other fields to promote computational thinking. It is a skill that their students need and it can be a tool in their own work. However, to do this two things are necessary: 

tl;dr: This isn't an either/or sort of situation. You have a lot of options for structuring the exercise. There are a lot of possibilities and which works best depends on the specifics of your situation. Don't lose track of the fact that your goal is educational, however, and not code production. If the students learn but not much code gets produced it can still be a success depending on other parameters. Since I'm going to try to cover a lot of options it will be something of an IFTTT answer. For all of the cases below it might be best if you don't have one triple or one solo and the rest pairs. It will probably work better for your own learning about this situation if you have, say, three triples and the rest paired or three singles. You then get a better picture of how pairing itself differs from other options. If you are willing to have some programmers work alone A few days prior to the exercise let each student make a written bid on whether they want to pair or not. Have them give reasons for their preference. Let them know that their preference may not be able to be honored. Look at the bids and decide based on their reasons and your judgement about what would serve everyone best. If you have a single superstar who always makes perfect marks It is possible that he/she doesn't actually need the practice of this lab so give that person a different task, perhaps as a resource to the remaining pairs, answering questions, prompting, helping you watch over the flock. Someone needs to answer questions as they arise anyway and it might be an opportunity for a person to learn at a more meta level. If your superstar has expressed an interest in teaching eventually this might have additional payoffs for the person. Likewise if he/she is a language lawyer it might help them dig deep into their knowledge on the fly. If you have a single struggler (or 3) You could put him/her into a triple with others not terribly far advanced from that person's state. In this case, be prepared to be a fourth member of that team to help them keep the situation moving and the process easy and friendly. Don't let the struggler avoid the programmer role. Your choice of teams here might have to depend on personal qualities. Don't put him/her with the arrogant monster. If the lab is long (say 3+ hours) or if each pair contributes differently to a larger goal This one is a bit riskier with youngsters but works fine with professionals. Choose teams in any way that suits you (see above) and let the process run for a while (half hour to one hour). It needs to be long enough that switching roles has happened a few times. Then change the teams. Note that some people will move to a team with new code they haven't yet seen (the risk factor). At the switch point, the current driver stays with the code and the navigator(s) find new seats. The current driver for that code just continues after the break and the new navigators(s) spend some time catching up. If a person has been solo or in a triple in one iteration they are in a pair for the next. In many ways this is the most realistic scenario and matches how pairing is done in organizations. The advantage of this in the classroom is that students learn to read and understand new code - a useful skill on its own. However, you may need to map out in advance who the pairs/triples will be for each segment. Each student caries a card with them listing who they worked with and if you want to do peer evaluation, each can mark at the end who they thought was their most effective partner. If they work with at least five others, I would ask them to mark their two most effective partners. Don't ask for criticism of partners, just for who contributed the most. Make sure they know in advance that this will happen - to encourage good behavior. A more elaborate peer evaluation is to also ask why they marked the people they did - who was most effective and why. In any case Don't neglect to set aside time at the end or in the next session to have a retrospective on both the project itself and the process. You could also ask for a written assessment from each student on what worked and what didn't. And don't neglect... Don't lose track of the purpose and benefit of pairing. The driver takes a tactical, microscopic view of the code being produced and the navigator takes a strategic, macroscopic view. Work to keep this concept going as well as possible. It is the essence. Additional advice If you poll the student preferences as suggested above (even in conjunction with a different option) it would be good to announce your decisions a day or so in advance when you can't meet all desires. This gives you a chance to explain (privately) to some why their choice couldn't be honored. "I really need you to ..." And be clear in your own mind, and let the students know, what is the main goal of this exercise. Is the project itself more important or is learning something about the process. When you have to make compromises do so with that goal in mind.