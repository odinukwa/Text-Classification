About the readability, no need to make things more complicated than they are, a simple comment before the line should suffice. Since escaping special regex characters is a basic task, and if you project to use it several times, you can build a function: 

The main problem of your code is that you performs two replacements for each strings. Indeed when you pass arrays as pattern and replacement parameters to , the whole string is parsed once per item. These two replacements are not needed. You can avoid them if you replace all groups of characters that are not letters or digits with an underscore: 

About pattern performances: Remove all that is useless, don't capture when you don't need to capture, try to limit the number of groups, branches in alternations. Be careful with subpatterns references : even if the pattern looks shorter, it has a cost (the creation of a capture group, the call to the subpattern). Also, rewriting the subpattern is better than adding a quantifier to it: (one call per repetition). One of the main cost in a pattern are the alternations in particular when they are at start the pattern. The reason is easy to understand: in the worst case, each branch is tested for a position in the string that doesn't match. Obviously the best cure is to avoid them, but unfortunately it isn't always possible. You can also try to reduce the number of branches. However, several tricks exist to reduce this cost: 

For more complex cases, I generally create both classes in the same package and make instance variables for both package visible (this leaves of course the responsibility on me that what I inject into the frozen part is actually immutable, but I deal with it ;) EDIT Right now the methods are called and , to reflect the pattern's intents; do you think of better names? EDIT 2 Objections from @bowmore: the SRP (Single Responsibility Principle) is violated; this is true: the frozen instance has the added responsibility that it must generate a pre-filled thawed instance. The suggestion here is to create an additional constructor/static factory method/method (pick your poison) on the builder class so that it be able to "swallow" the contents of the frozen instance. 

First step, start with a simple solution: divide all in simple tasks, keep the patterns short and easily understandable. 

About special characters: , and are not special characters and don't need to be escaped. Note that is read as a literal character too, but only if it isn't the start of a quantifier , , . Except for these special situations, you don't need to escape it when you write a pattern by hand, but here it's easier to escape it systematically instead of testing if it is or not the start of a quantifier. (if the escape is useless, it will be ignored) Since you will use the RegExp constructor with a string as first parameter (Since ECMAScript 6, this parameter can also be in literal notation), you no longer need to escape the delimiter that is only used in the literal notation. You can remove it too: 

Delegate the computation of and to a method, say, . Since we want to spy this method's execution, we will suppose that we have Guava and its useful annotation, and make the method : 

This pattern means that if you have a frozen instance , you can obtained a thawed instance of that instance by calling , modify it (since returns a builder) and freeze it again: 

Then have a in which you would pair keys with implementations of . If no entry exists, of course, the method call is wrong. While this is easy, however, it is not practical. Many frameworks, including light ones, include annotation systems which will do the job automatically for you -- you should try and find one, and use it. There is also another solution -- since this is JDK 7 you are using, you'll have it: . It also requires that you implement an interface, but using this, you can load your method implementations easily. This is what I use in one of my projects, and it works quite well; the only trouble with it is you need to create a file in , but it's a trouble you only have to do once for each method you create; or if you use Maven, there is a plugin to generate it for you. 

The second approach is totally different and uses a regex approach. If it uses more memory (~3X) and is a little slower when you try it only one time with a little string (less than 10 characters), it becomes faster when you use it several times (whatever the size of the string) and is more efficient than the other way with long strings whatever the number of attempts. In other words, you need to pay the cost of the regex engine, but only one time. 

Your code works well for all the cases. After many tries and tests, I obtain two different ways to write the function. The first comes from your approach with several changes. I have, in particular, removed the test for foreign characters from the main loop: 

I use this pattern a lot; I find it useful. Do you? What would be your gripes against it? Sample implementation of a simple pair: 

If you are intent on using a builder, then I'd suggest either making it an inner static class to the main class or a different class in the same package. If the first solution, then the constructor for the built class can be made ; if the second, it can be made package local. First scenario: 

OK, this question may seem a little strange at first; however I'd like to have your comments on it. Background: I do Java. A lot. Java is a statically typed language, it has means to restrict visibility of instance variables, etc. And as such the builder pattern (see here) is quite adapted to it. I took this pattern a step further. The builder pattern is a one-step process: once you , you obtain an instance, preferrably immutable; but once you have the instance, there is no going back. The freeze/thaw pattern is a "reversible builder". I implemented it in Java and this gives the following interfaces, which I use quite a lot in my own projects (one-sided discussion about this pattern here): 

Here you can find a test script for the different pattern sets, (you can also pass a callable to the constructor instead of an associative array of pattern/replacements) and useful functions: $URL$ About ReDoS attacks: Except if you finally choose a pathological pattern and doesn't limit the size of posted data, I don't think it's possible to crash your script with your patterns set. It isn't so expensive to run, no more than any other script that filters and validates form data. Other thing, when a pattern is badly written it reaches quickly the backtracking limit, the script doesn't crash and a warning is emitted. You can even retrieve the error using . If you want to increase the security against DoS, start at the server level, with the apache settings. 

Here is a solution which replicates Guava's interface. Since this interface is really easy, here is how it is done: 

I'd just say to go with your implementation; just because it is easier to read! Also, you only from the list once, whereas the proposed solution does it twice. Shorter is not a synonym for better! However, the generics are not good; you should at least use . Not sure why the proposed solution uses as a lower bound... 

You may want a static method in your class, named, for instance, taking a as an argument and returning an : 

Note: the way your class is currently written, it is NOT thread safe. The quick, coarse way to fix it is to make . EDIT Discussion on a different design to get the value of This requires a creation of a new factory class for instances of class ; it would have the responsibility to create new instances and compute : 

First, is the literal notation of a RegExp object and not a string, is a string and nothing more. If you want to concatenate several strings to build your pattern and then to obtain a RegExp object, you need to use the constructor: 

(Note that when you pass a string to the RegExp constructor, you need to escape the backslashes, since to figure a literal backslash in a string you need to escape it.) ( is a method, not a method: ) 

Note also that the escape sequence isn't a character nor a character class but an alias for or (depending on the mode). In other word is an hidden alternation. I build a set of patterns/replacements that fits your requirements to illustrate these techniques: 

There is no need for the else at all since you don't do anything if is not odd. Also, there is no need at all for two lists. Just one is enough: 

One advantage is that if two instances created for are equal (ie, the same and parameters), computation for happens only once! 

The "drawback" here is that it is up to the caller to remind what predicates where in what order in the calling lists, of course. As to your hypothetical class: 

Now, code written using Mockito and TestNG (with test file in same package than class , so that the method is visible): 

Easy to adapt in the second scenario. Second remark: I fail to see why is an illegal value at all for your predicate; as your code reads right now, I can very well input as an argument to the predicate and it will work. Why not just "let it be"? After all, it is the user's fault if a correct predicate is not provided, isn't it? Third remark: calling a an ? Uh... Why not just ? Also, remind that any interface obeying the prototype of a can be used, so you can define and use instances of this interface. By default, you could supply an empty one, or one that s, for instance