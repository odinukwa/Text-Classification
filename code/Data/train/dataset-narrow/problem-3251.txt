"The raspbian desktop environment" is actually LXDE, so you might want to investigate that way. If nothing turns up, as a last resort GIMP will take screenshots and should be available via . It is a bit of a sledgehammer in this context: 

Unless the modifications you've made involve incorporating the tweaks that make the Raspberry Pi kernel what it is (I think this is more than simply "ARMv7"), this is doomed to fail, but it is simple enough to try. First you need a card set up for the pi, the easiest way would be to just use a Raspbian or some other image, and then you can overwrite the root filesystem in the second partition as you see fit (with Android I guess, but again: this is certainly doomed to fail). The important part is the small first VFAT partition, which contains the bootloader code, etc., and the kernel. There will be a text file in there, . Copy your kernel onto this partition, and add a line at the top of the file: 

Notice there's now no second field. This means there's no password and all you have to do is type at a login prompt and you are logged in as . You can then use to set one. So, you have two choices here but they both require you take the card out of the pi and access the second partition from another system (that can read/write ext4 partitions). 

This implies you are running something in the foreground because it is not persistent so you feel there is no point in backgrounding it. However, if it takes that long to do its thing, perhaps you should fork it to background as soon as it starts instead. The issue here is simply that it is more likely to benefit your boot time than leaving it in the foreground is, although it may not make any difference either way. However, if something else depends upon it completing (as opposed to simply completing initialization successfully, which is more applicable to a persistent service), then you should leave it as. 

The maximum heap size is not the maximum amount of memory the JVM will use, but the heap size is what Xmx actually sets. Regarding settings, it seems there maybe issues with , a more bulletproof method would be to add this to : 

According to this, it shouldn't be, but I notice some of the other defaults there might be inaccurate, e.g.: 

Okay, so if there is one lesson you learn from all of this, please let it be that if you have things you absolutely cannot lose, you absolutely need to keep them backed up properly. I know that programming is much more fun and interesting than learning to use tools like and but once you sort this mess out, before you go back to programming anything, you MUST sit down, look at options of that sort, and start learning how to use them. No system is bullet proof. If you dump a coffee on a pi and SD card you just lost $40-50 bucks, that's irritating. If that pi had two hundred or a thousand hours worth of work on it and that's now gone it is going to be way beyond "irritating". That's why things like and exist. Anyway, what you need to do is focus on the priority of retrieving your irreplaceable data. To do that, you have to have a look at the root partition on the SD card. To do that properly you need one of three things that are within reach but, again, may require some doing some not-as-fun-as-coding stuff: 

I have a model B in a nice prefab case with a slot through it to connect a 26-wire ribbon to the GPIO header. However, I'd like to leave a small I2C based device inside the case as well. I've thought about soldering leads from the bottom of the board, but the tight fit on the case makes this awkward -- there's no simple place to bring them out to the top because, e.g., the mounting screw holes are compartmentalized underneath to add structural integrity. I've thought about soldering onto the male header, but this would be hard to do without leaving the ribbon connector raised, and the clearance inside the case is quite tight. It also commits me to attaching another plug and cramming that in loosely, or else permanently wiring the device in. So I've thought about just wrapping the wires and putting the ribbon connector over top, but that seems prone to disaster. Are there any other options here? 

Steady green ACT on a model 2 is an unusable (e.g., not formatted correctly) or absent SD card. Try taking the SD card out and turning it on. You'll get the same thing as you are now. 

I need a package that's in jessie, the newer version of Raspbian, but not in wheezy, the one I have installed. Can I use it somehow? Can/should I just upgrade to jessie? 

No you cannot use more than 1.2 A in total for the USB regardless of supply. Beyond the USB is where things get more interesting, because I don't think the pi sans USB can use 1.8 A. According to this site, which I put an amount of trust in I won't try to justify (you'll have to do that yourself), a maxed out Pi 2B would would use 200 mA for the processor. Which seems very low, but these are the same kind of things that are used in much more energy efficient cell phones -- I think the pi's power hog is actually the RAM, which is cheaper and less power efficient. Then there's the GPIO pins. Officially the limit here is something like 15-20 mA per pin and 100 mA in total. So not including RAM and other circuitry, we're now at a max of ~300 mA. But that doesn't include the 3.3V and 5V pins! I think the 3.3V is still limited to 50 - 100 mA, so to be liberal in our estimate, let's go with 500 mA total not including other circuitry. This is still short of official total numbers which are more in the range of 7-8 hundred mA not including (??) USB and peripherals. Call it a day at 1 amp, which makes sense since all the pis I've tried will run off a quality 1 A supply. I would guess the over-estimation in recommendations has to do with the fact that not all supplies are of the same quality. But the 5V pins are not regulated, so if you want to try and run a 15 amp circuit that way, go ahead. I am sure you will see sparks and smoke pretty much instantaneously, though. The max safe limit with the 5V pins is a bit of a separate question I won't try to answer, but I think somewhere between 0.5 - 1 amp should be okay. 

I'll expand a bit on my initial comment on the question by dividing this into two distinct approaches: 

I believe WiringPi, like other Pi specific GPIO libraries such as pigpio and libbcm2835, works by ing part of kernel space into user space using (or the more specific ; beware not to mess around casually particularly with the former or you could cause just about anything, including serious filesystem corruption, to occur). You can find an example of this technique on elinux.org if you are interested. This provides access to hardware registers normally only accessible to the kernel. What you are asking for -- to set the value of eight arbitrary GPIOs in parallel -- would require hardware pathways and the SoC, being organized around a CPU with 1-4 cores, may require code to manipulate each execute linearly on a processor core (one instruction at a time). [See joan's answer for more details about this -- evidently you can set GPIO values as a whole via hardware, but I'll let this answer stand for the general outline]. Even if this were the case, very likely you could do it in few enough instructions that on a single core Pi running at 700 Mhz, eight GPIOs could be set within a microsecond, which is pretty much but not quite literally instantaneous. If you have to do parallel busing at a higher frequency than that, again, a special hardware feature would be required to implement it and the Pi does not have an 8 pin parallel bus. It does mean if all you want to do is set the value of 8 gpios more or less at the same time, just do it with 8 procedural calls in code [or in parallel using the library features mentioned by joan] and the time it takes them to execute is what it is, but it probably will not be anything relative to a human scale. 

It means the voltage is dropping when too much current is being drawn. Although this is obviously well within the limits of the charger, since it is sold for charging it may not be great at dealing with a fluctuating demand for arbitrary amounts of current, which charging will not do. Recharging a battery is not a super voltage sensitive scenario, especially since the batteries in phones etc. are usually much less than 5V anyway (more like 3.4 - 3.7, I think). I suspect, however, this is a multiport charger and you are using a microUSB cable that is the real culprit. If so, try with a few other cables. I have a bunch of phone chargers, someone of them small and of dubious quality, but they all actually work with Pis -- however, I have a few (maybe 1 in 5 or 10) microUSB cables that don't. 

My Pi 2 sometimes does not power on properly -- just the red LED comes on and there is no further activity. I've done this a bunch of times and there is a consistent pattern. If it happens with no HDMI cable attached, flicking the power (it's on a switched power bar) will restart properly, i.e., it will only happen once, then on the second try it's fine. If it happens with an HDMI cable attached (the other end of which is to a display that is not on the power bar, and is on constantly -- and, as per comments below, that display has another, already active HDMI connection...), it will happen over and over (i.e., the pi will not power on properly). However, if I turn the power off, unplug the HDMI cable, then plug it back in, then turn the power on, it always restarts properly.1 I have been through this literally dozens of times in a row over the course of a few hours (turning off frequently in order to take the SD card in and out, for unrelated reasons). This workaround with the HDMI cable is fine for me right now, but would be a real hassle under other circumstances (if this is a genuine issue, I'm guessing more people will show up here eventually asking about it). The fact that this involves plugging and unplugging with no power implies something about a static build up to me -- but my understanding of electricity is pretty crude, and of the pi's circuitry, non-existent. I don't expect a solution here, but I am curious as to what the potential cause is. 

I'm presuming the context here is on a pi. The error is from the C compiler, not about it. If you examine you'll notice it's a symlink to . That's not a cross-compiler, that's the native compiler. 

The runtime executable path is the full path name of an executable. In the case of a python script beginning with , it's just the path to the script, eg. . 

You should plug a monitor and keyboard into it and boot it that way to see what is happening. At least a monitor, if you don't have a keyboard. Reflashing the SD card is NOT a good solution to every single problem and roadblock. For starters, it means you have given up on trying to figure out why there is a problem, so if it is because of something you've done wrong, there's no reason you won't just do it again. If it is not your fault, there's still no reason "whatever it is" won't just happen again. You have to learn to troubleshoot. 

$URL$ You don't have to download and install from there, there is a package in Raspbian () and every other linux distro. That's just the official home page documentation; it may not be the easiest point of entry. A dhcp server (usually -- beware this is NOT the same as , which is a dhcp client used for normal networking on Raspbian). 

It sounds in fact then like you have a different question than what you actually asked -- you would like to know how to turn an LED on ASAP. If so, please do so in a new, separate question. Likewise if you have a more specific question about device tree overlays.