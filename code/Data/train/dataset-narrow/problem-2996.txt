I, too, was going to form part of my answer around the article Aurora shared on the development of Scratch. Snap! makes its debt to Scratch explicit. In the "About" section, the its creators discuss their design choices for that which is an extension from Scratch: 

I currently coach our school's CyberPatriot team. (You can find information on the CyberPatriot competition here.) We are heading into our second year of competing. Last year we did pretty well for being a more casually organized team, but I'd love to bring in a stronger curriculum. There are helpful training modules provided for coaches, but for more advanced vulnerabilities, independent study and research is necessary for achieving at the highest level in the competition. In particular, the images students must "secure" encompass a wide range of operating systems. Last year had Windows 7, Windows 8.0, Windows 8.1, Windows 10, Windows Server 2008, and Ubuntu 14.04. Additionally, students used Packet Tracer to learn networking security through the Cisco Networking Academy. The bottom line is that there is a ton of potential information to cover, and there is a precise way to succeed at CyberPatriot. This page explaining how the competition works details the point system: basically you earn points for doing a precise task in securing the system and lose points for making it less secure. My question is this: what resources can I use to strengthen my students' ability to succeed in this competition? For context, they are doing it as an extracurricular activity, and any resource that is engaging for students to work though on their own is a bonus. They are highly-motivated, but since there is so much out there, it's hard to know where to begin since cybersecurity is not my background. 

In terms of integrating ethics, the way to start in my mind is discussion. Early and often. Share news stories. Discuss implications of new apps students download. The first 12 minutes of this CS50 lecture cover the the Volkswagen/EPA scandal from 2015 and mention Ken Thompson's lecture. It is essential that awareness is built right from the beginning that software is everywhere and there needs to be an ethical code to guide that development. In my mind, while I wouldn't consider myself Kantian, I do think his point about means and ends is essential. The AP Computer Science A curriculum outlines the following requirements under the major topics of the course: 

I'd like to expand on one source in an answer offered above: The Collection of Really Great, Interesting, Situated Datasets, or simply CORGIS. From their About page: 

This can be a point of divergence between a markdown language and a programming language. Selection via conditionals and Boolean operators and iteration via loops are constitutive elements of a program, not a document styled with a markup language. A markdown language may use sequencing -- I'm thinking particularly of and in HTML -- yet one could not implement an algorithm (using the above three elements) in HTML or CSS. There's (maybe) selection in terms of ids and classes with CSS but not in the sense of Booleans. Also, the idea that an algorithm solves a computational -- viz. mathematical -- problem allows one to stress the notion of computation itself, which is intrinsic to a programming language and which separates it from the styling of a document. 

I don't think this is the software in question, but one product that can produce similar results is Explain Everything. I used it to create short grammar review videos back in my English teaching days, and they were very similar in style to this. That was back on a second generation iPad, so I can only imagine how much sharper results would be on, say, an iPad Pro. I was able to write, draw, include images, advance slides, and narrate all my activity on the screen, which could then be exported to YouTube, for example. I would encourage you to explore their education page and to read some of the "success stories" linked there about how it has been used in the classroom. Even if it's not identical to the video in question, I would bet it could serve your purposes well. 

Using topics like design or hardware might be a good direction to go since a discussion of UI could build up into a more abstract understanding of the notion of an interface. It is important to note that this documentation makes use of the same contract analogy you mention: 

For learning recursion... A student with some programming experience might just need a brief tutorial. Since I teach CS50 AP, I make use of CS50 Study which has a page dedicated to recursion here. There is a slideshow with speaker notes as an overview, tips and tricks for using recursion, and sample problems with solutions. The language in question is C, but any student who knows Java will find the syntax familiar. Additionally, on YouTube the Computerphile video on recursion is excellent as a supplement to this page. For practicing recursion... I'm a bit surprised this hasn't come up already, but CodingBat has a handful of recursion exercises in Java ranging from the most basic to some that are quite challenging. There are two sections of problems: Recursion-1 and Recursion-2. The site doesn't have much in the way of a tutorial (other than solutions to the first two exercises), so it's mainly useful as a practice tool. The nice thing for an instructor is that students can log in to track their progress. If you do want the student to complete x number of problems, you can verify completion by having her either print out her progress while logged in or share her account with you so you can see what has been completed from the teacher view. 

Now, to get into the details of pointer arithmetic, passing by reference, syntactic sugar vis-a-vis arrays, pointers do become more complicated. However, always keep in mind the simple definition that gets at their essence: pointers store addresses for other locations in memory. 

It's a simple struct, but since students can easily error-check their own work with simple math, this assignment provides a great way to actually start using a stack for something meaningful that also builds on students' prior knowledge. 

I'm exploring iOS App Development as an elective for students, and in perusing Apple's iBooks on the subject, I see two similar books: App Development with Swift and Intro to App Development with Swift. On the surface they look quite similar. Are there significant differences between the two that I should take into account when selecting one for a course? 

The value of this exercise is it gets student moving. Differentiation is essential for teaching students to think in a new way. Get them moving and talking to each other. Make it relevant to their everyday experience. 

TL;DR Use the Python module to show students Python's bytecode alongside Java's bytecode. Avoid the "compiled v. interpreted" rabbit hole to start (because it may lead to more confusion than clarity) and instead show students what's actually happening underneath the hood. 

I teach a short introductory unit in my course that uses Scratch to get students familiar with programming concepts before introducing the syntax of a text-based programming language. For context, we move from Scratch to C to Python. My question is this: what can students be taught in Snap!, as another block-based programming environment, that they cannot be taught in Scratch? I read on their site that it Snap! combines Scratch with Scheme, but as the latter is not a language I've studied, I don't quite see the motivation for this combination. 

If you want a full framework for Ruby, you go with RoR; if for Python, Django. I taught my students the basics of Flask this year, and using some great tutorials, I found I could get students up and running with a basic Flask page in no time at all. It was a powerful and simple way to combine HTML/CSS with Python without having to set up virtual environments or do any configuration beyond installing the framework. From an educational/pedagogical perspective, I see two advantages to Sinatra: 

In my mind the first and most foundational lesson to impart is this: software, computers, technology -- these things are more about people than about code. There is a trust from the end-user, whoever that user may be, that must not be violated. Users are not means to an end; they are the end. The code is the means. I am reminded of the Second Formulation of Kant's Categorical Imperative: 

From the official CS50 notes from last year's Week 0 lecture, the following three bullets explain what this phrase means: 

You can access the first two chapters of the book here as an evaluation of the approach. If you explore those chapters, you'll see that there is a lot of starter code provided for students. (Indeed, you can download the code for all the projects from the website for your perusal.) That is the key for how you structure a course this way. Students have to have pre-baked programs that they can interact with. BlueJ as an IDE makes this extremely easy with its graphical interface for creating objects and calling methods. If Eclipse were your IDE of choice (or if you preferred to compile via CLI), then this wouldn't work nearly as well if at all. The idea it seems is that students can start to understand methods, return values, parameters, etc. by exploring a fully functioning example a program that follows the principles of OOP. Additionally, all syntax is taught in the context of classes and objects. That said, it is dependent on the choice of IDE and the ability for students to work with already-completed programs. 

As you can see, it was elementary. That way they had mastery of HTML basics (i.e. the DOM) and could then grow to build something more sophisticated and aesthetically pleasing. With the second, they had to include the following: 

I suggest a slightly different approach: have students solve puzzles. Sudoku. Crosswords. Logic puzzles. Lateral thinking puzzles. Anything that requires critical thinking, analysis, decomposition. Then show how these same skills (and the same enjoyment) is found in programming. (For example, have students speed-solve a sudoku puzzle then have them formalize an algorithm in pseudocode for that process.) In my time teaching CS, I have seen a strong correlation between students who enjoy and are skilled at programming and students who enjoy the intellectual challenge of solving puzzles. For me personally, the New York Times crossword is an indispensable part of my daily routine. When I have a program to write or a concept to think through, I approach it as a puzzle to piece apart and ultimately "solve." As a teacher of CS50 AP, I use puzzles from CS50's annual Puzzle Day throughout the year. A quick search will reveal many puzzle packets to choose from online (here's one). These puzzles are great as a fun activity from time to time, and I do think they align with skills needed for computational thinking. Some students instantly see puzzles like the ones linked to above as a problem they simply must solve. They instantly focus and try to break it down from every angle. The same skill of logical, ordered thinking is found both in solving these and in solving algorithmic and computational challenges. I'll think you'll get a good sense of a student's potential interest (and potentially aptitude) in CS with puzzle-solving activities. 

Teach students to read the documentation. This site covers Java programming for the 2017 FRC Control System. FIRST programming, while requiring general programming skills, is specialized for the roboRIO and for the competition as a whole. We ran into a couple issues this year whose solutions were found by methodically reading through these documents. There can be a rush to jump right to coding, but it is essential to understand the WPI library and its API fully. This also serves the purpose of seeing which programmers have the discipline to follow documentation to the letter. Having the patience and thought to do so is a necessary condition for being a successful programmer. Use a simple chassis for coding/driving practice. Each year's game has its unique twists and challenges. However, underneath the superstructure is a drive base that in many cases can be used from year to year with slight modifications. Treat this as essentially a learning robot. Give it working code, let students drive it, then teach the code itself. Make changes from one run to the next. Since the code has immediate, real-world consequences, show the results of minor changes in action. This way you can then go back to the classroom/IDE knowing that students have a context in which to operate. Have them observe and reflect on what happens from run to run when one variable, say, is changed. Research other teams' code. Most, maybe all, strong FRC programs have well-developed websites and numerous GitHub repositories. Look at best practices from these teams. Reach out to them. Have students try to read and understand their code. 

Similarly, in AP CS Principles, students, as a part of the Explore Task, have this on their rubric for the assessment: 

A prerequisite to understanding pointers is a basic understanding of memory. At least on the broadest level, students need to know that when they declare a variable in their programs, that variable is stored somewhere, so they can use it, access it, update it, etc. Where that variable is stored also has some address, so it can be located (specific addressing techniques need not be introduced yet). The specifics of heap v. stack, memory size (int v. long long), and other such concepts are not necessary to understand what a pointer is (but they certainly would help). All this background established, here is the easy way to think of pointers: 

In sounds good in theory and can be good in practice. The challenge is making sure those passive elements are well-received and are instructionally sound and effective. As another resource, the hashtag is a great place for exploring flipped classroom content on Twitter. There is a weekly chat every Monday from 5-6 PST (IIRC). 

Thinking skills aside (since I think everyone here would argue for the value of logical, order thinking learned through computer science and programming), there is tremendous relevance for computer science and medicine (a huge draw for my students) or for CS and music. The more our world gets digitized, the greater the importance of understanding technological growth and knowing how to work within digital innovation. Another part of it too is this (and getting students to believe this is tough): there might be relevance you see later that you couldn't possibly predict now. Not everything you study or learn has an obvious connection to a future class. Who knows what field will change because of technology in the next 5-10 years. By studying computer science, though, you can be ready for wherever that evolution takes us.