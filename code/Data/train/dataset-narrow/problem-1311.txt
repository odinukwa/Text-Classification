Upon reading your posted solution, it seems you want to have the flexibility to modify the number of leading and trailing words around the needle. This ramps up pattern complexity, but I think I managed to pull it off. Code: (Demo) 

As an aside, I would like to suggest some micro-optimizations that I use as a matter habit... When you are writing loops, always cache the by setting it to a variable in the first expression. This will ensure that you aren't calling on every iteration. 

It seems you wish to batch the posted messages together into threads. In other words, create a "parent - children" relationship. This can be achieved simply by using one loop to generate the new data structure and one smaller loop (I use ) to display the text. Code: (Demo) 

Regarding multibyte functions, it is important that you realize the serious drag that all functions have versus their non-multibyte equivalent. See the benchmark comments below the documentation. For this reason, it would be reasonable to build another parameter into that asks and fork the process from the beginning. If forking the function was not desired and this was my project, I would think seriously about whether their is any actual benefit to ing with versus . My gut feeling is that measuring with multibyte accuracy is not worth the cost. I am happy to strikeout this claim if anyone can demonstrate otherwise. Here is what I've been toying with: (Demo) 

Since I assume you are not in control of the javascript code blocks being inserted in your code, you'd better play it safe and just use dots instead of negated capture classes like . The reason is: Google may write a "less than" comparison between and and the match will fail. As a side note, when your pattern includes a symbol that is also what your pattern uses as a delimiter, then you can avoid the need to escape your in-pattern by changing the delimiters to a valid delimiting symbol that does not occur in your pattern, like . Your regex demo link uses sample input that has two occurrences of . Only one of them is trailed by . If you want to match both occurrences, use this: Pattern Demo 

It is important to mitigate the effect of smaller needle substrings existing inside larger needle substrings. I think you have ironed this out in recent edits. has this innate "special power" but unfortunately the function doesn't have a case-insensitive version. Because there is no word boundaries included in this function, regex functions should be avoided. (you have also edit your code to fix this) The simplicity of will cost efficiency, and I don't think that is the point of this task. 

To conclude, your coding structure seems suitably segmented/clean. It only requires the logical tunes ups that I mentioned before my snippet. 

If I spent some more time refining, I could probably write my function more eloquently, but for the purposes of this question it is sufficient to reveal (to me at least) some of the fringe cases. I found in my development and testing that it was important to test against: 

On huge arrays, statistics have shown out performs but that would certainly be less beautiful and if you were dealing with big array I'm sure you would have mentioned that. 

About the logic of assessing victory: After each player's turn there can only be one winner, so no matter how you want to write the functional parts it would be best practice to write a as soon as a victor is found so that you don't do any surplus processing. The sample data: 

These changes not only shorten your code block, they improve readability with curly brackets and tabbing, and improve efficiency by reducing the number of loops. 

This is probably the most sensible approach as it provides the two desired strings with a single function call. Using to name the generated elements is fine if you place a high priority on speed of human comprehension, but it doesn't seem necessary to me -- given that the task is so overt. You could also implode like this: Method #2: & w/ 

I'm not sure if "more beautiful" means you want a one-liner, but here are two more concise ways to perform the task: *note, this doesn't validate the as being one of the element values -- if this is a necessary component of your project, then please clarify in your question. Code: (Demo) 

Once the pattern extracts the desired set of words, the handling is quite simple. Code: (Demo with a battery of $needles) 

Assuming your input array is pre-grouped and pre-sorted as your posted code represents, then you can use a single loop with some conditionals like this: Code: (Demo) 

Please do some realist benchmarks with the input strings that may hit your code and let me know how this fairs (I'm curious). 

First, I'll offer three more methods that will provide the same/desired output, then explain some pros/cons: Input: 

I'll provide a snippet with some sample data to demonstrate a few of my suggested techniques. Code: (Demo) 

Yes, my method uses 4 separate patterns rather than 3 like the OP. This is for improved accuracy. I believe the OP's method had some gaps in accuracy, so that is the justification for the additional pattern. The output from the above method is: 

If you copy the above into www.phptester.net it will render the html so you can see what is happening. Now an itemized list of suggestions: 

Regex Demo Link This will reconstruct the full name strings with optional suffixes including , , and Roman numerals from 1 to 13 (that should be sufficient). Pattern Breakdown: 

I don't code in java or python so I don't fully follow the methods provided in the commented link under the question. I've decided to write a method that avoids the incremental checking for palindromic integers. Instead, it uses arithmetic based on a few preliminary string function results to discover the closest greater palindromic integer. Note, there are limitations to my method because the input and output are integers rather than strings. I can conclude after testing that my method will stay true into the 10's of trillions. Code: (Demo) 

p.s. I experimented with one other method based on your posted input array. In attempt to write a snippet with fewer lines, I leveraged , , , and ...although it is technically shorter, I do not recommend it because handling array data as strings is not always reliable. This method does NOT work on a shuffled input array. Code: (PHP Demo) (Regex Demo) 

This approach doesn't add any new variables to the scope, but requires 3 function calls which doesn't seem very "tidy". Method #3: Limited 

*note, the flag that trails both patterns declares that dots should also match newline characters. My non- pattern will successfully match both occurrences in 561 steps. My pattern more than triples the step count at 1979 steps, but will be more reliable/accurate if Google shakes things up as I mentioned. Ext3h's pattern is also very fast at 572 steps and suitably matches only, but if it ever lets you down, you will know it can only be because Google added a in just the right wrong place. My assumption is that if you are going to bother to remove one googletagmanager script block, you probably want to remove all of them -- in which case, you'll want to use my first pattern for both accuracy and speed. 

In conclusion, I would personally use and recommend Method #1 as it is lean and clean. Many developers advise against blending the processing and displaying portions of code into the same line as a matter of cleanliness. (Here is a demo link) That said, I'd like to make two more points: 

The same logic is applied to the sequences that start from the upper-right corner. To crystallize... a 3x3 grid will have a total of 2 diagonal sequences, all other grids will have a total of 8 diagonal sequences. The diagonal sequences obey a simple pattern, so you will have no trouble in generating the correct for your function. My tinkerings: I experimented a little with what I understood of your concepts and tried to employ array functions rather than for loops (though they are sometimes slower, I think they are better descriptors of action). It is not a very tidy snippet (consider it a "napkin" draft), I didn't bother refining it because I am not 100% sure of your usage nor what is the best way to display the result. 

I've prioritized accuracy and endeavored to provide the most robust patterns considering all possible character sequences that may be submitted from the textarea. Then I've attempted to write each pattern with greater efficiency (without impacting accuracy). Finally, I've tried to reduce the overall length and convolution of the regex patterns. I want to be clear that I don't have any experience with recursive patterns. I don't know how/when to use them effectively and so none of my patterns employ them. This is the sample input that I used which has whitespaces, newlines (single and greater than double), and control characters: 

I will echo what Radu posted as a comment. I find a combination of with to be concise and easy to read. While foreach loops can perform slightly faster, using purpose-built native php functions can improve comprehension based on their names. Lines of code are reduced as well, if that is important to you, because bundles the array iteration, condition statement, and the return/break tasks. Code: (Demo) 

For my own confidence, I wanted to have a way to confirm the existence/absense of whitespace and control characters in the string before and after the method. I found a very helpful function in the top comment at the php manual's ord() page. Here is a PHP demo that iterates the string and identifies each and every character to prove effectiveness. Here are a few relevant regex links that I visited during my research: $URL$ $URL$ $URL$ On the matter of ReDoS and Catastrophic Backtracking, the threat is minimal (if not non-existent) because of my use of character classes and the structure of my alternatives. In case you haven't already visited it, here is a good page to read if you want to investigate further. Finally, I humbly ask that if anyone has a string that breaks my method, please provide it to me so that I can update my answer. And if any of my assertions are incorrect, please correct me. 

p.s. When all of the dust settles and you are happy with your finished non-regex method, you should compare it to your leanest version using just to see if all this messing around is actually worth it! 

This can be a concern if you are doing multiple edits, thinking you are "replacing", but you are actually "bloating". After a few calls, what started as might become . 

Once I isolated the patterns that exist with certain sequences, I could declare the correct "bump" or adjustment. Some bumps are static, others depend on the length or value of the left-hand-side component. As for your relevant numbers to check using your method, I can't think of any that would cause trouble because you are looping and checking each iteration. Perhaps the challenge was assuming that you would try to write a method without loops as I did or run "inside out" string comparison checks on each side's digits. As for checking "large-ish" numbers, I found that once I had perfected the bumps from to , all integers above that were accounted for. Possible Output: 

You can iterate (and reduce with each pass) the input array and group the like-names in the result array. I am assuming all of the values are already in the correct order. See inline comments for how it works. Code: (Demo) 

If you want a one-liner with conditions (or without functions), then this is what Billal was mentioning: 

p.s. I don't like to bounce in and out of php tags ( and ) over and over because I think it looks messy. Since my snippet spends the majority of its time using php, I just stay in it. 

Xiaoy312's suggestion is one of the common methods used to generate comma-separated placeholder strings. It generates an array containing valued elements, then joins them into a string using commas as glue. Another common method is: 

I personally find switch statements to be too clunky/verbose with the ing. While it is nice that it only evaluates once, that is of very little benefit in your tiny use case. 

You can maintain the same level of accuracy and reduce the "step" count (improve efficiency) by replacing with character classes / negated character classes where appropriate. As a result of using character classes, you can use greedy quantifiers without negatively impacting accuracy. Also, by incorporating the flag at the end of your pattern, you can reduce your upper and lower case alphabetical character ranges to one or the other. is also shorter than (albeit, only by 1 character). I would recommend this pattern: 

Running conditional checks on and is completely unavoidable for this task. This second method will make just one function call: to complete the pattern! 

Selecting the "best" method in this case is likely going to come down to personal preference. If you wish to use a condition-less one-liner, then insertusernamehere's offering is brief/elegant. However, it is not instantly comprehensible for the next developer. 

I may have flaws in my suggested code (because I didn't test it), but it seems to me that you could afford to implement the DRY principle. Writing a loop, to generate an array of items, then writing another loop to traverse the array of items just doesn't make sense to me -- just perform all necessary processes in the first loop (no temporary arrays). I recommend curly brackets for your conditionals and loops; not because they are essential, but because they improve readability for most people (never assume that you are the only person to see your code). Untested Suggested Code: 

I can appreciate wanting to avoid regex because you need to write readable / maintainable code. Unfortunately, there is unavoidable complexity in your task -- regex or otherwise. That said, a regex function like (or possibly ) is perfectly suited for your use case for several reasons: 

Alternatively, if you are seeking pattern accuracy with fewest function calls here is something new to consider: Code #2: (Demo) 

Some missing diagonal checks: and have values of . This is accurate on 3x3 grids only. Because is , all grids larger than 3x3 will have 4 winning diagonal sequences in each orientation (running down-to-the-right & down-to-the-left). Considering a 4x4 grid, the winning sequences from upper-left to lower-right are: 

Assuming your actual project arrays will be a relatively small size (like your posted input arrays), there is going to be an unnoticeable margin of speed between the many ways that this can be done. Here is a method that doesn't use a loop or . The else portion of my function could have been condensed into a one-liner, but I've declared to make it easier to read. Code: (Demo) 

Now, I don't know what kind of validation you are running on the ahead of time, so I'm using a couple of sensible precautions. If your validation makes one or both of these functions redundant, just remove them. 

PHP Demo I've prepared a regex pattern comparison to display the efficiency gains (in terms of steps). Note, I had to slightly modify your pattern and my recommended pattern to prevent unintended newline matching within the negated character classes. I have used the same 8 test strings as in my php demo. My pattern: 83 steps Demo OP's pattern: 145 steps Demo