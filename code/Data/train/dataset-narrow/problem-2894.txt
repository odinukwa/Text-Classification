However, I prefer this way because you also need to transform the TBN basis and this way you can reuse the same matrix if you don't care about non-uniform scales 

Yeah, I think this is valid and one of the big nice properties of spherical harmonics. Bilinearly or trilinearly filtering the data doesn't have any cross-channel operations so it will preserve the 4 separate sets of coefficients fine. Basically evaluating the SPH is like this right: 

Or just pass a second boneTransformsInverseTranspose[] to the shader, which could be faster depending on whether you are bottlenecked on uniforms or shader math. EDIT: Also, another thing I noticed is that your index attribute seems weird. You have a float shader input but you are using glVertexAttribPointer with type GL_INT but with normalization turned on. So you are actually getting float(idx)/float(INT_MAX) in your shader. You should try passing false for the fourth argument or alternatively using an ivec4 in your shader and glVertexAttribIPointer directly. 

Edit: My original answer did not really follow MVC, sorry for the confusion. If you look at $URL$ then you will see that controllers don't listen to models. So for the cases where you don't have a user involved, you either don't use MVC pattern or you replace the user by some Logic Class. My updated design (pseudocode): 

If you want the game to cater to specific audience, you need to know what the audience is looking to get out of the game. I always refer to this article when planning out content and game interface ( $URL$ ) The FPS gamers, on average, do not care about the exact numbers for their armor, health, damage etc. They will most likely shoot each other to a point where they can figure out which build is good for which situations, the min-maxer players that will dig out stats and chart them will always be there but they will be a minority. The RPG players, most often need stats to build their character. Stats are kind of important for two reasons, you want to invest in your character and you want to understand the consequences of your decisions. Stats play a big role in mechanics, especially skill tests. Lack of stats in RPGS may frustruate an RPG player because they will often have to reroll to get something that works, or they won't understand the game at all because mechanics are not clear. My approach to designing the game interface is therefore understanding who the audience is and what they are looking to get out of game play, and exposing enough stats so that the rules of the game are clear, even to a newbie. If I choose to hide exact numbers from the users, then there should at least be some written rule or hint like (using armor-piercing rounds allows you to do more damage to vehicles). I may not need to give exact stats, but at least the player may not get confused why one weapon does damage and others do nothing at all. The only stats I usually hide on purpose, are the random chance ones : lucky hits, loot drop, random events etc, but those things player's will most likely know or expect from the game. 

If your OpenGL version is new enough you can use the textureSize intrinsic to get the dimensions of the texture: $URL$ Then you can divide your pixel coordinate by this to get the UV to sample at for that pixel. If not you can just pass it as uniform but that may not be as clean depending on how your code is setup. 

You need to weight the samples by the cosine of the sample and the forward direction of the hemicube. This is because the amount the texel contributes is related to what its incident angle is from the normal. You can precompute these cosine values offline for each pixel since they are the same for every hemicube, assuming all your hemicubes are oriented the same relative to the surface normal. That's what the "multiplier map" contains. However this only is accurate for a polar projection In the code you linked they also add another term which accounts for the perspective distortion of storing the texels in a cube which is rendered with 90 degree FOVs. This means that the samples near the seams are less direct facing. This makes sense if you think of the distance to a plane perpendicular to your viewing direction. It's closest in the center. So they combine these two terms together into multiplayer map. Finally, they normalize the map. Since each hemicube is the same resolution you can bake in the constant 1.0 / ( hemicubeWidth * hemicubeHeight ) term. This makes the integration code very simple: 

It can be useful for driving/simulation games where walking and driving controls may be different. I.e. Battlefield games. When walking on foot you may use a keyboard. When flying you may use a joystick. And like someone else has mentioned, if you have alternative input devices, you don't want to remap or reload your configuration, you want to have flexibility to use both whenever you feel like it. 

AI Manager (you probably don't want to use a controller, because you have no view or user, so essentially you are merging 3 functionalities into one class, it is no longer MVC, but something different. 

Manually generated games use these, so for example if you want to scavenge a particular area for ingridients or craftings parts, the loot table for that area would contain particular parts (i.e finding food in jungle areas, finding electronics in junk yard) etc. Standard Deviation: Some games use standard deviation for loot drops. For example the more common the item, the close it is to the average. The more exotic items the further it is from the average and closer to the sides of the curve. This can be used with loot tables, or it can be used for the overall game. If you are making a space shooter and the only things that can be dropped are power ups and parts, then you don't need a loot table, you can just use the standard deviation and define the probability threshold for the items. Example: 

This might be a pretty dumb question, but after googling a lot i still came up empty. Only i a lot of people who are not doing this on purpose. EDIT: Maybe the question can be asked in another way: Is there a way to define an empty PixelShader? If i define the return value as void it notifies me, that i have to at least return the 4 pixel colors. If i don't give it any Semantics it does not work either. 

Now this works fine and my shadow-map also produces the desired result. What bothers me though is the constant warnings in the debug-window. Is there a way or trick to disable that warning? 

So to render into my shadow map depthstencil buffer i only bind a DepthStencilView to the Output Merger. Like this 

I think what you're looking for is called "Conservative Depth". There is an AMD OpenGL extension at least: GL_AMD_conservative_depth But there is also a DX11 semantic which I have used in the past and works on both vendors, although it is poorly documented. It's described here on slide 81. As for OpenGL on NVIDIA, I'm not sure. There is GL_ARB_depth_clamp, but I don't think that will help with your situation. EDIT: Oops, looks like AMD_conservative_depth has become ARB_conservative_depth since I last looked. So you should be good to go for most cards. 

Which means, yes, you can filter the coefficients texture and get the same result as filtering the result of the evaluation. Also this implies that you can apply any constant scale or sum up sets of coefficients arbitrarily which is useful. 

If you want to send multiple messages in one packet you may add additional details to your protocol, for example 

You don't really need a game controller, all the logic on how to play the game, should go inside your models, most likely your state model, inside nextTurn() function. Which leaves you with the remaining View and Controller 

3) Serialization You need to have a good handle on understand serialization, as it will also help you write save/load game functionality as well. Essentially it is taking your objects and storing them in a different format. So for example you want to serialize movement message. 

These are the three approaches that I would take: Loot tables: Build a table for each zone and sub-area. Loot table should be approximately close to the theme and difficulty level of the enemies, I.e. if it is intro level and mobs can range from level 1-3, then so should the loot. You can make different loot drop tables for specific sub-areas as well. If you have a dungeon and a small area specifically where the orks hang out, then your loot table for that sub area may have items specific to orks, i.e. "ork swords, or ork shields" If you are editing a level or automatically generating it then the loot tables should be generated the same way your terrain/mobs are. Your loot should be proportional to the difficulty of the dungeon level (or the mobs for that level). For game balance you should take into account risk/reward. Boss gear should be given when fighting tougher enemies. Otherwise you risk getting the best gear from simple mobs and removing the fun element from your dungeon. Here would be an example of a loot table Zone 1 loot table: 

i am currently trying to dive into 2D programming with DirectX, especially bulding a tile based sidescroller. I have worked with some chapters from a book (Advanced 2D Game Development) but always tried to create something on my own (to get the most out of it - because you never will learn anything if you are not doing it yourself). But now i am kinda stuck with the camera work in 2D. I do realize that there different matrices to tranform the objects to world space, then the world space to view space and then to projection (camera) space. Do i really need all of those for a 2D game? I have a camera class (out of the book) and was trying to use it to "roam" around with the camera (i am currently drawing a grid, with D3DXLine - bigger than the screen - and i would like to float over it with my camera): 

Your JFRAME will have a combination of various gui elements, so when you build it it might be something like this. 

The common items, statistically, should drop more often then the rare ones. Pure Random I would actually use this method when starting to make the game because it is the easiest to implement. You do not want to optimize your game when you are still making it, you can always worry about balance and mechanics a bit later in your development cycle. Also having random drops may seem amusing and might also give you ideas during play testing. For example having super loot drop when you are in the tutorial may give you some ideas to create some quest named "Holy Quest to get Super Loot". I.e. it is good for brainstorming. 

I am calling the Update() in every game_update() Now i am wondering why there is no SetTransform(D3DTS_WORLD, ...) according to the camera movement. Is it just missing and i would have to implement it by myself, or do i need to set it elsewhere? I am kinda lost of how the "normal" set up would be to implement such a thing, and maybe a camera following the player (i guess i would have to the the World Transform according to the player position, am i right)? Maybe someone can give me some clearance, or just a little tutorial EDIT: Forgot to mention that it is not working right. I am currently Drawing two things: one Sprite with the D3DXSprite and the grid the D3DXLine. EDIT2: Here is how i transform my sprites and set the world Matrix. It is still not working though :(. Any ideas? 

I actually like Aron_dc's answer, but i thought I would add an answer to provide additional things to consider. 1) UDP vs TCP - You have to choose a particular protocol and understand the cost and benefits. Picking UDP is quicker, but you have to create your own control code on top of UDP, common problems with UDP : packet loss, firewalls, packets out of order and knowing when the client has disconnected (using timers and "are you alive" packets). With UDP you may have to think about storing packets, numbering them and resending them if they don't get acknowledge. It maybe a bit of a headache for the first time. 2) Multiplayer component design: 

My initial research showed the most people prefer to use UDP protocol and build a control code on top of it for multiplayer games. It seems like a good design at first, but I am wondering if it is really the best in the long run. For example, what happens if your game goes from 64 players to 500, 1000, 20 000 Is the UDP port going to overflow and start dropping incoming packets? Is the overhead that you wrote for UDP-reliability going to be less optimal when you start using more bandwith? (I.e. the server will spend significant cycles managing features that may already be present at the hardware and network level that are built into TCP) I am considering re-writing a server that initially used UDP+reliablity protocol and splitting it into two cluster servers to handle different regions as well as introducing a load balancer in the middle. The UDP design is starting to look a little more complicated and having a large number of NPCs and state synchronization that may have to take place is making me reconsider UDP.