Now, with the above code, you are giving this the details it needs to get the data, and you don't care how it does it. The fact that it is on multiple hosts, with block-lists, or whatever is not the point. That URL_RETRIEVER is what your code should implement, and, my guess, is it will look something like: 

With a slight shift in the way you think of your search method, instead of updating the number of paths, you should instead think 'how many paths from here?' Also, lets fix the static variable issues too (we will need two methods for this): 

The last point is significant.... The ReadWriteLock does not specify the implementation details of the lock, it is simply an interface. Additionally, it explicitly says that implementations can impose restrictions: 

Now imagine if you also want to select an interior color, automatic, or manual transmission, etc. What happens when you have a lot of inputs is that it becomes hard to 'align' the values with the parameters of the class.... you have to cross reference them, and count the values to make sure you are putting the color in to the color parameter, etc. Finally, what if you want some default values as well... or you need to validate combinations of choices.... like, you cannot select 'abc' and not have > 150? Validating that all in the constructor is ... hard. The builder class is the solution to this. It makes the construction of the class a sequential process... you add the data to a builder, it accumulates, validates, and isolates the inputs until you have captured all the information you need. Making sure the right parameters are given the right values is easy because the method has just one argument, and a logical name: . Then, the builder organises the data in to a single call to the constructor (often private) of the Car class. It is common to make the Builder class a sub-class of the class that is built, too. Putting this all together, the builder has special permissions to access the Car constructor, the builder accumulates and validates the inputs in to changable values. It then calls the ugly constructor itself, creating a single, immutable class instance, and only one place in the code has to have the ugliness. 

I really like how you have set up a system for running your tests. This is a worthwhile investment. I have taken your system, and extended it quite a lot. I have made the performance tests a bit more structured. Also, I have rearranged the class. This is a compliment for your code... not a criticism... it's good. I just want to use it differently from you. On the other hand, you may like what I have done, so have a look. I did find some problems... you are doing long-division on the time values: 

would be much better. Validation It would be trivial to break your code by giving it a negative value as input. Testing for a negative value, and throwing an exception, would be acceptable, but determining the abs value of it would also be a good start, but, note that would cause a stack-overflow for the input value because you cannot calculate the absolute-value of that.... A different trick would be needed there. Primitives Keeping values as primitives instead of (or worse, ) is a very important factor with performance. When Java 9 or Java 10 arrives, this may change, but it is not there yet. Recursion Recursion is an elegant solution to a number of problems in computing. In general though, it is important to separate the three components of all recursive structures in to discrete logic points. All recursive structures consist of: 

Algorithm Since you are comparing two files byte-by-byte, the hashing will make no difference. If the two files were on different machines, and you have a slow network between them, and if you could run the hashing algorithm remotely, then it probably makes sense to hash the two files on each side, and then just compare the small, and easy to transfer, hash result. Something like SHA-256. So, there's no need to hash, just do byte-by-byte comparisons. For large files like yours, why have such a small step size? Use something much larger like 4MB, not 4KB. It will make it much faster. Alternatives File IO is always slower than you want. Java has the NIO framework for higher-performance IO using Channels and Buffers. This would be a great time to learn how to use them, because, a 4MB Memory-Mapped IO operation on the two files will likely give you the best performance. See the MemoryMapped IO JavaDoc I ran up a test using NIO, and produced the following code: 

Your concurrency/integrity of the code, and the way you have shown it used, are fine. The design, on the other hand, is very questionable.... I would recommend that you do not use this pattern at all. If you are going to use it (your comment here says it is used already), then I recommend changing the name. It is not a wrapper, since you can't actually access the lock through the wrapper. Instead, it is a 'Locked Session', which can be closed, and downgraded. The following code looks/reads better to me: 

which is the accumulation of all the previous inputs too. I have spent 20 minutes trying to figure out why my code is wrong.... but it's your code. 

The way the above code works, is each time you have a value \$a\$ that is a factor of \$n\$, then there must be a value \$n / a\$ that is also an factor. Thus, for large values of \$n\$, like 1000000, you only need to iterate from 2 to 1000 (exclusive) to sum the factors. Now, because 1000000 is an exact square, the root is an actual integer too, and the last if-statement above adds in the value 1000 to the sum. In addition to the above, you can also rearrange the double-loops so that the inner loop is limited by the outer loop, and then add the pairs twice to the results. This changes the order of the results, but not the actual content.... Finally, your use of should be replaced with ... 

note that this handling of System.err is a problem.... you will never be able to multi-thread until you fix this. All the best, I hope this makes sense to you. 

exception traces will be printed to STDERR (the console, not a file). If the console output is discarded, the error is lost (eg. ) the exit code of the application may or may not be set to an error code if one of your sub-systems succeeds before another one fails, and it starts a non-daemon thread, then your application may not even terminate at all. 

Steps 2 and 3 should happen as one safe thing. We want each message to go in to its own index. If two messages are created at the same time, and just before each message is created, the current index is at . one possible order-of-execution will be: 

Testing a URL to see if it is accessible is not a great way to test for an internet connection. There are a number of things I can see that can go wrong (or things you may be testing other than 'the internet'): 

Your assertion that this is a replacement for BigDecimal, is.... ambitious. You are limited to about 18 significant figures, and your code will throw odd exceptions for values that exceed that will throw a NumberFormatException, as far as I can tell. Additionally, your class is not immutable, which is slightly concerning, since by convention, Java classes are immutable. You override the method, but do not override the method, which means you cannot safely use this value in a HashSet, HashMap, or many other constructs. The method is duplicated as both a public static method, as well as an instance method. There should be only one (the instance method, I presume), or the other should not be public. The method looks broken: 

We can solve a lot of the complexity in your loops by doing a couple of tricks. Here's a suggestion: 

Apart from that, the immutability looks fine. Good, even. The package name you have chosen though... is lacking: . You could not name your package something better? 

This is because all the other tables were joins, and their values are never 'selected' or used for 'projection'. Thus, they were just redundant .... 

The static Scanner is a problem, a better way to do it is with the Java try-with-resources. If you add the scanner as an input parameter to the prompt function, you can do: Change your prompt method from: 

There are no strings in the above, the loop iterates one time for each decimal digit, and well, just works. A second issue I want to point out is with your line-by-line algorithm. You read an entire line, split on the spaces, and from the list of strings, you create a list of numbers with . You then iterate this list, and sum the reverses. A much neater solution is to do a map->reduce operation: 

Regarding the two different methods for the encrypt/decrypt, yes, you can reduce them to just one function. The and classes both extend the interface, and that's what's needed for the function. Note also, that you are doing some code-style things "wrong". Your try/catch code should be using the more modern try-with-resources mechanism, and there's no need to declare the array outside the try block. So, reducing it all down to a single method, with improved code style, it would be: 

Then, statistically, there is no value in doing the md5 on the password before the concatenation. It actually may make things worse because it makes the input value to the outer md5 a predictable length.... I would just simplify things as: 

you have not commented enough you have commented all the wrong things you have commented too much. your comments are in the wrong format you are missing the formal comments. 

Then, because that is private, noone else can ever lock on it, only you. Who knew that bare Objects would ever be useful? Now you can use it like: 

the temp table probably does not have statistics up to date, and is not indexed at all the primary table probably has some indexes on and/or when Oracle optimizes the query, it will likely decide the temp-space required to store all the name-concatenated values will require too much memory, or even physical IO 

You need to rationalize that. I started with the spaces and slashes first... using a bash regex/replace for to be replaced with an underscore. 

Essentially, build an array with a direct 1-to-1 mapping between the char value, and the phone key number. Until this point, the fastest transform was by doing a calculation, but comparing that calculation with: 

they can be compiled, which makes them fast, and reusable they can replace what's between characters, not just the characters themselves. 

If you expected , then you would be wrong..... because the output is . To avoid static initializer surprises I strongly recommend: 

is an interesting one. It may, or may not be more complicated to consider, but XPaths can be compiled, and reused. You can also have variables on them. I would consider the following: 

The above code initializes 1000 boolean members, and sets them all to true. Now, with your sieve like that, you can simply: 

Interesting exercise. I think you missed an easy solution to it which I'll get to, but a code-review first... Vertical whitespace is a critical part of the readability of code... and you are missing a lot of it. Code like: 

I would probably take that inner stream and make a real out of it. I would also make the printing a separate function ... it should not be part of the parsing/decoding. Conclusion I put together a working example program here: $URL$ Note that the version of the code I was happiest with separated out the various functions, and converted the to a . Note that the map also has the "Space" value in it. Additionally, the reading of the file, and converting to is expected to be outside the function (in the main method) which cannot be done in . Here's the code in full: 

The above code replaces the second character, through to the last space, and replaces them with nothing (deletes them). The regular expression is what's called a zero-width positive lookbehind - See a tutorial here The following examples/outputs: 

The method's function captures the of the request, but does not use it. If you are simply trying to force the close of the body at the function end (and not the beginning), you can replace: 

is buggy. Your code will create the sublist in the wrong place if, for example, and are both . Bugs in clear() clear() is not modifying the modifiedCount. It should (but only if the list was not empty) General, small things 

-> The method, and the control flow for selecting (and notifying) numbers. -> This controls what the card state is. Changes to the state will be communicated to any listeners. -> This is the visual representation of the . It implements the interface. 

The above query reduces the complexity of the column/table table joins, and reuses the result. Further, by using instead of on the table-name anti-join, it removes your duplicates. 

Going through this code again, it appears there are a few things that could be improved. Use #Temp Table for User Selection Instead of doing a cheap-shot UNION select to get the set of users to process, the right way would be to create a temp table, and then conditionally populate it: 

Unless you have exceptional reasons, don't extend , "compose" it instead. Have a class that does not extend ArrayList, and have a class field instead, like: