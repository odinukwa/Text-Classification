After a lot of research and continuing development using Slick2D, I have decided that the only way to do this in libGDX would be a fundamental re-write. After some tests, it also turns out that this is a Good Thing. The solution I have tried is to hold the data for the graphics in arrays, use TreeSet indexes to be able to quickly locate which items should be on screen at any one time and then draw these once per loop. Per loop, this removes the getSubImage() call and repaint of this sub-image to the main graphics canvas. Having tested the approach with both the old graphics-based class and the new array/TreeSet-based class the difference in performance is significant. Using the graphics approach the game runs unchecked at about 205 FPS. Using the new array/TreeSet approach it runs at around 280 FPS. I've included an edited version of my Stars class here to show how this works in practice. This is the simplest case since the stars are simply dots on screen. It gets more complicated for other shapes, but the logic is essentially the same except for having to check for objects being partially on-screen, i.e. check all vertices. I've also included a small class below that I use for the TreeSet indices used to search for on-screen objects. Both use dyn4j (physics engine) co-ordinates for the stars and also for the edges of the screen (picked up as an Observer of another class) to calculate what should be shown on-screen. 

I have then just disabled or enabled the length option (which gives a fixed duration to a particle burst if enabled) depending on whether thrust is engaged or not, i.e. if thrust on then disable length, otherwise enable it (I have this set to 10ms in the xml config file). This gives nice, organic puffs of thrust when I 'feather' the thrust control, which is exactly what I wanted. (From my ship class) 

If you want to move on lines (not curves), your implementation is almost good enough. I would edit your code this way: 

I don't know if this is what you need, but you should write just one general class Stage and all of your questions are defined in some XML. When your game starts, it will create for example array of stages, which it will go through. And in each stage you can have loop which will just increment question number. 

Maybe I just don't understand your question, but if you want to draw text, you can use function glutBitmapCharacter. 

Because your kernel is 4*4, it's even count, it could be still shifted. If it's odd (for example 3*3 or 5*5), it would be better. 

Blue vector can be calculated easily: red - black (the sign between vectors is minus). But if you want just to interpolate between black and red vector, you don't have to calculate it. Linear interpolation is just linear combination. So you can just take: alpha * black + (1 - alpha) * red, where alpha has to be from interval <0,1>. If alpha will be 1, then you will get black vector, when alpha is 0, you will get red vector. And if I understood it right, you will interpolate between these vectors in time. So just choose right increment of alpha in time. Did I understand you right? Or did you meant something completelly diffent? 

I don't know, how it's in named games, but in Mafia 2: Whole world is just a world. And missions are levels. Each mission can contain few "sublevels" (go from here to there and do some action) and special parts like buildings, items, characters, behavior, etc. World is streamed as it is needed. I think that level should represent one part of game (story), which can be "entered" (started) and completed. And because you can travel freely around the game world, it's not a level, but environment. Level should be one mission. 

I don't use GestureListener, but rather track fingers in my own InputProcessor overrides. This allows huge flexibility, and gives me a rich set of input data, without worrying about some of it being stolen by another listener. I can't make out exactly what you're trying to accomplish, but by doing something similar, you can do just about anything. The designers did a good job on the interface, so with just a bit of creative calculation and keeping track (in class-level variables) of things, you can implement just about anything. For instance, I implement an On-Screen virtual D-Pad. Where I treat the first touch via overridden touchDown() to be the origin of the D-Pad, storing the origin and the "pointer" (finger id) in class-level vars. When the class is initialized, the finger Id is set to -1, so I can easily check uninitialized state. Then, using those state variables, and processing touchDragged() and touchUp(), I can tell when the user is dragging around, calculating a "heading vector" as the delta from the stored origin to the current screenX and screenY passed into touchDragged(). I can tell when another finger is tapped (which I treat as an "action button"). My current game doesn't utilze fixed-position controls, rather wherever the user wants to touch on the screen becomes the origin of the D-Pad until that finger is raised, then the origin becomes wherever they touch again (likely a different place than previously). This is to avoid controls getting in the way of in-game action. For instance: It's easy to implement a radius of "dead spot" around the origin to filter of superfluous jitter around the origin. By using the pythagorean theorem to calculate the distance from the origin to the current screenX, screenY, and ignoring values with a distance less than some value. It would be easy to implemnt a follower that just cached the screenX, screenY at each call into touchDragged(), and compared that cached value to the current value, so you could derive a detla-vector. Good luck! 

You can try to use other way: if you know direction of enemy and position of ship, you can compute angle between current direction of enemy and new direction (ShipPosition - EnemyPosition): , dir and newdir should be normalized. Also compute "up vector" of this rotation by cross product: . Then try to make rotation matrix according to this page in section Rotation matrix from axis and angle. 

I think it would be easy to implement BFS or DFS to search same colors. You can just go to all of it's neighbours and then to their neighbours (if they are of the same color) etc. So you will create graph, where every point is connected to its four- (or eight-) neighborhood. 

What I have seen, you are using Display lists. They are already few years depricated and you should use vertex buffer objects. It maybe could help. They work on this princip: You create buffer in graphics memory. Still in init phase you copy your data there (vertex coordinates, texture coordinates, normals etc.). And always in display function just use these data to render all geometry. It's fast and most used in these days (I hope). 

I unfortunatelly now don't have time to read about that SAP algorithm, but what I have read few months ago (but I don't know, if it's suitable for your problem, it's much more suitable for points - not objects): You can use some special case of kd-Tree - for example octree - which uses half partitioning in each axis (in article I have read, they were using quarter partitioning - each axis is split to 4 peaces). You use dynamic version of it. First you build your structure at the beginning. This means, you split space into kd-Tree. Leaf of tree should have some limited number of objects (for our example let's take 64). Each node knows of course how many objects is in it. When you update positions of objects, you transfer them also in structures nodes. After that, you update whole structure according to these rules: 1) When inner node has less then limited number of points (sum of its leafs is less then 64), then you merge leafs and inner node becomes leaf. 2) When some leaf has more then 64 objects, you split this node. If you want, I can try to find that article - when I will have some time.