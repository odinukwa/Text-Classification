Put that in and call it . Make sure that and the script are owned root, the easiest way to do all this is but since user has such broad permissions you could do it that way and use . The script must be executable: . The service file doesn't, the default mode should be fine. Now: 

Simple enough -- the green line is the 5V rail, tested via the breakout. The load is additional, i.e., sunk via a pin, and the Pi itself (actually a B+) is headless and idle. Part of what this illustrates is the 5V rail isn't as well regulated as the 3.3V rail (it isn't regulated at all, in fact, beyond some overcurrent/overvoltage protection on the microUSB jack). If you look around, I think you will find a Pi 3 needs nominally ~450 mA to operate properly, because it will draw that much when the processor revs up high enough. Based on the graph, if the rail were providing an even 5V, at 450 mA it is going to drop to 4.6V -- not so good. At that point you run the risk of Pi #2 cutting out (or both, since as per Steve's comment the voltages will probably match up). Why that drop occurs is debatable (see comments below) and maybe somewhat inevitable (due to "some 5V components [being] subject to changes in resistance and conductivity under load"), or may be in large part because a linear supply is used (for which "the voltage provided...will vary with changes in load impedance", which has been frequently observed by users here particularly WRT the greedy Pi 3). I.e., YMMV -- but it should be easy enough to check your own scenario with a cheap multimeter. Just busy loop (x4) Pi #2 and see what happens. 

Download the 2017-04-10 raspbian image, copy the image via dd or windisk32imager on your SD card and modify the cmdline.txt (see your first link) echo program_usb_boot_mode=1 | sudo tee -a /boot/config.txt Boot the image from SD card which will enable the USB boot mode on your Raspi3 forever. Check with vcgencmd otp_dump | grep 17: 17:3020000a Copy the 2017-04-10 raspbian image via dd or windisk32imager on your USB stick Plug in your USB stick,remove the SD card and reboot. Your Raspi3 should now boot from the USB stick successfully :-) 

There exists a backup tool for Raspberries called raspiBackup. If you restore this backup on a different SD card you're actually cloning your Raspberry. 

Check whether your ssh daemon is up and running and listens on all interfaces. Execute following command as user pi on your Raspberry sudo netstat -tulpen | grep ssh 

This question is old but I think it's worth to add another answer: There is a tool available called pishrink which shrinks an image to it's minimal size and will expand it to maximal size during boot. Just shrink your image, copy it to another sd card and you're done. 

I have a very nasty issue with Jessie :-( Background: I wrote a tool called raspiBackup which backups and restores a Raspberry and because it works fine for me and helped me multiple times to recover from a SD card failure I decided to publish it. It's already used by a lot of people. Issue: When I restore the clone/backup of Wheezy created with tar the system comes up with an IP address. When I restore the clone/backup Jessie created with tar the system doesn't receive an IP from my local dhcp server. If I start the original image everything works fine. When I restore the clone/backup Jessie created with rsync the system works fine. Backup options used with rsync: -rlptgoDWDEHAXx Backup options used with tar: -cp --selinux --acls --xattrs I also compared the two logs /var/log/syslog from the original Jessie system saved with tar and the restored Jessie system which doesn't get an IP. Original image: 

To explain about : It's a bootloader ("grand unified bootloader") but it is not used on the pi. The only messages it would display would (normally) last a fraction of a second when the power is first turned on. 

I need an ARMv6 cross compiler for my B and B+ pis, primarily for building the kernel since this requires many hours on the pi itself and sometimes requires trial and error to get right. I would also appreciate some explanation of how to use the final product to compile a kernel for the pi, since cross-compiling is a new topic for me. The host platform is also linux. 

A debatably useful thing to do, since the complete X11 install is probably only a few hundred MB. Interesting to note the reference to "dependency problems, but doing as you requested anyway". I'd say there's then a bug in apt/dpkg that shows up, but this is debatable too based the extent to which: 1) A tool should allow you to shoot you in your own foot. Or drill a hole in your own hand, or whatever, if you misuse it. 2) Appropriate warnings were provided. 3) This is really a consequence of having done something the wrong way, or just coincidence. It appears you are still in a GUI so I presume this is from an SSH or other remote terminal. 

This is also part of a stack trace (noticeable because there's a <memory address> there too); they are not necessarily indications of a fatal error. Point being, yours will be tagged something like that (your hostname may not be ) and if you can't find it in syslog then you can at least find the last thing there (also, with a little math you can correspond kernel timestamps to syslog timestamps). "The last thing there" will be immediately before the messages for the next reboot. The very first one of those will include (again your hostname may be different), then a long block of kernel messages tagged . On the Pi at that point the syslog timestamp will be since the clock has not been set properly. 

Addendum: It's also new for me the new raspian image supports direct boot from USB. I have already some Raspi3 enabled for USB boot. I was keen to know whether the new raspbian image boots from USB and I just downloaded the new raspbian image, copied it on an USB stick, plugged it in and I was able to boot from the new image via USB immediately :-) 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

If you use Windows the boot partition will be mounted as soon as you plug in the SD card. Open any editor you are familiar with on Windows and create a file called 'ssh' and save it. That way your Raspi will enable the ssh port when booting :-) 

I never used etcher. Whenever I prime a SD card I use the dd Linux command. Windows guys use win32diskimager. Anyhow: The etcher doc states it's checking the cloned images. If that's true then it seems the image you use is somehow broken. On the raspbian download page the sha1 is listed. Please use sha1sum to verify the sha1 of the downloaded zip file matches to the published sha1 and download the image again. 

You also can use tar to backup your root and boot partition. tar will backup only used space. To backup the root partition you can use following command: 

Which doesn't mean it is going anywhere, but you might as well use , which will also show everything. If it still doesn't show up, it's probably because of this -- note no available linux driver. That's unusual, but to spare yourself grief you should check around before buying. My recommendation about wifi drivers is to get them from a brick and mortar place close by that will take a return or exchange no questions asked within a short period of time. However, grepping through the kernel source, I found the ID registered and "Linksys WUSB6100M" in corresponding comments. Unfortunately, it is for the driver which 

Please read and do your best to understand the wikipedia article on page caching. Do not pass go otherwise. All contemporary operating systems do this and have for a long time, because for a long time it would be considered idiotic not to do so. In a nutshell, based on a few sequential premises: 

Then . This will open the sshd port. Of course, if the firewall was really blocking it, presumably raspmc is not running the sshd server by default either, so: 

If you do build against that source, the module created may or may not work with your current kernel; it likely may not. This will be clear one way or the other when you go to load it, because it will say something about "mismatched" symbols. If so, you need to use a kernel built from the source you used to build the module (the issue is versioning; you can't use a module built against 3.17.1 with 3.17.2, and sometimes this gets even more finicky). In this case, possibly the kernel was already built when making the module -- the unfortunate part will be that it was not configured properly if you did not run earlier. Check for a file in the top of the source tree, and if it is there: 

Assuming pi_0 has IP 10.0.1.1 on the external network and www is the connection to the internet. Just enable routing (add net.ipv4.ip_forward=1 in /etc/sysctl.conf) on pi_0, define a static route on the router to the pi_n subnet (route add -net 192.168.1.0/24 gw 10.0.1.1) and set the default gateway to pi_0 on all pi_n (route add default gw 192.168.1.1 eth1 ). 

The exists a nice tool called pishrink which reduces the size of a dd image as much as possible by shrinking the root partition. If you start up the restored image the first time the partition is expanded to it's maximum size again. If you run Windows just use your Linux on your Raspberry to shrink the image. 

The way to boot from USB has changed. The latest raspbian image 2017-04-10 supports direct boot from USB and you just have to copy the downloaded image via dd or windisk32imager to your USB device. In the past you used an SD card to boot and then switched the root device in cmdline.txt to /dev/sda2. That's the way for Raspi1, Raspi2 and Raspi3 to boot from SD card but run everything else from USB stick. Raspi3 doesn't need the SD card any more. There is one important step you don't have to forget when you want to use Raspi3 to directly boot from USB: You have to enable boot from USB only once in your Raspi3. It sounds you didn't do this. You wrote you want to setup a clean system. So I suggest to execute following steps: 

Look, two separate packages. I don't have either of them installed, but if I try , it concludes with: 

That will not work. "i386" refers to the Intel 80386 instruction set architecture (ISA). This was the prevailing 32-bit ISA used by chip makers like Intel, AMD and IBM until the development of the x86-64 (aka. AMD64) ISA now used in most personal computers. However the SoC (there are actually three slightly different ones) used on the Raspberry Pi, like most low power mobile and embedded devices, is built on a processor designed with an ISA from the ARM family of architectures. When software is compiled to machine code, that machine code is ISA specific. The prevailing operating system used on the Pi, Raspbian, uses the lowest common denominator, ARMv6, since this will work on all three SoCs (the BCM2835 used on all models except the 2 and 3, the 2836 used on the Pi 2, and the 2837 used on the Pi 3). ARMv6 is actually relatively obscure, but the next version up, ARMv7, is very widespread, so most major linux distributions have an existing repository easily adapted to the Pi 2 or 3 (ARMv7 will not work on the other models). The Pi 3 is actually designed on the ARMv8 64-bit ISA, but ARM architectures are backward compatible. There is also a collection of ARM 64 distros that target the Pi 3 specifically. CentOS has both ARMv7 and ARMv8 distros for various dev boards. Unfortunately, as just explained, these will not work on a B+. There is a more limited selection of operating system compilations for the ARMv6 models. The most prevalent are Raspbian and Arch. Our fairly exhaustive list is here: Definitive List Of Operating Systems Beware there are distros specific to the 2 and 3 in there, hopefully they are all clearly labelled. Whatever you install, make sure first it is an ARMv6 version. Sometimes they might be referred to as ARM1176JZ(F)-S since this is the particular ARMv6 implementation used in the BCM2835 core. 

QEMU has an ARM emulator. It's a SW emulator and you should have a powerful Linux box. I personally use QEMU to run a test suite on raspbian to test a shell script. I didn't try to run a web application. But I would give it a try. I published the steps I executed to create the QEMU image on my Linux desktop on this page. Hope it helps you to get a QEMU raspbian image up and running very quickly :-) 

Update 7/13: This is an important issue for me. That's why I posted the same question in this forum and consider that post as the primary post for my issue from now on. 

I found out you can fix the dhcp issue on the cloned image by starting the dhcp server manually to get an IP from the local DHCP server and then uninstall and install the dhcp client again with 

By accident I detected this question. raspiBackup can also be be used to restore the backup created by raspiBackup (See $URL$ So I'm wondering why you're asking how to restore the backup. Anyhow - a main design principle of raspiBackup was it also should be possible to restore everything with just plain Linux tools. raspiBackup saves the boot partition in an img. The root file system can be saved with dd, tar or rsync. So in order to manually restore the backup 1) you have to recreate the partition layout with the information available in sfdisk file 2) format the root partition 3) restore the img into the boot partition 4) restore the root partition with dd, tar or rsync Hope this helps even my answer it's quite late :-) I suggest to place all questions about raspiBackup on the website in a comment because that's monitored by me. Update 11/5/2017: One user of raspiBackup manually restored a backup and described the steps in detail. See here for details 

I use sudo there because I don't mean for you to put this in a script; just run it once and init will add this to the start-up services -- i.e., mysql will now start at boot and get shutdown properly on halt. I have no idea why mongod would not start at boot, but you might want to look at for errors. If you installed mongodb from a raspbian package, it probably has a service too (look in ), although it looks to me like there is no package :/ 

Some of the tools in the ImageMagick suite () will help. The animate command will display animated .gifs: 

Chances are it includes , which is world readable, so you can create a writable directory in there with ownership and permissions appropriate to the process. Remember, obviously that doesn't persist across boots, and it will require superuser privileges to create the directory regardless of who is then allowed to use it. Hence, doing it via init is sensible; if the directory isn't used it doesn't matter. is commonly also a tmpfs filesystem, but it is not on Raspbian. You can find the maximum size and current usage stats via . Beware the max size is probably a considerable potential chunk (e.g., on Raspbian it looks like has ~250 MB), meaning you have plenty of space but if you get out of control, that's RAM you're using. It sounds like you do not need much. 

You've partially fallen prey to an idiotic choice on behalf of the creators of Raspbian to give the normal "pi" user superpowers, although to be fair people will find ways to do this kind of thing on normal linux systems too. Permissions are significant, as is . If all you did was , you can easily fix it but you will require another POSIX system where you can act as root to do it. That would include OSX which uses the same permissions scheme and commands, although you would need to install software to read the ext4 filesystem (and I cannot promise this is really possible as I've never tried it). A much better idea is to get a linux live CD. Anyone with a pi who doesn't have another linux system and thinks figuring out how to use a live CD is a waste of time is probably wasting a lot more time other ways. You might as well use Debian, since that's what Raspbian is based on. You probably have an "amd64" computer (aka. x86-64), within that you'll find a bunch of choices with regard to desktop; the one on Raspbian is LXDE but you can choose any of them (gnome/kde/mate/cinnamon will be snazzier, I believe cinnamon is intended for ease of use). Those are standard files that can be used to create a DVD (it's actually not a live "CD" anymore) on any OS. Somewhere in the applications menu you will find a "system" submenu that includes "root terminal" (or console) as a choice. You should then be able to mount the SD card and . Beware that running an OS off a CD is very slow.