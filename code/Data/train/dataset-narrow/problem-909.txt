Python isn't fabulous at handling large numbers of math operations, but hundreds should be feasible. I agree that this doesn't look like it's primarily the fault of the collision grid. That said, it should be possible to speed up the grid calculation. I'd switch the grid to a really crude modulus of the object's position so that you don't calculate distances accurately until you need them: instead, sort everything into buckets by just dividing the entity position X and position Y by a scale (maybe with an offset so you can 'center' your grid in the world) this is cheaper than calculating distances ( no square roots) so it makes a good crude first pass. In the interest of simplicity I'd stick with default python lists for the grid and cells too. Plus, updating incrementally instead of a clean wipe should mean less memory shuffling. Here's a sketch of how I'd do it, though I doubt I'm covering your whole spec: 

By sticking the result into dict you don't have to override getattr yourself, which limits the intervention to a single place although it does deprive you of the option to do guard checks for bad values, etc. This example would except on name collisions and get you off the hook for manually redirecting double-dotted attribute queries. 

You don't really need to maintain a big empty grid, the empty cells aren't telling you anything. Instead, you can use a dictionary to store grid points that are contained by a particular circle, then just collect all of the dictionary entries with more than one reference. @200's class is a great approach, so I'll steal it but I'm switching to itertools to generate the point lists 

I think this will be faster than your current update routine (among other things, using itertools is usually faster than hand-written loops) -- though depending on the data the incremental update might end up slower for data that doesn't cohere in time. The other obvious optimization would be to cache the collision checks as has been suggested. You'd maintain a dictionary of entity-entity pairs (this assumes entities are hashable, but they probably are). Inbetween steps set all existing pairs to a neutral value like None or -1; then as you do the checks for a given pair, you check the dictionary to be sure you haven't done that particular check before. I'd also do a two stage check for collision to cut out the square roots: 

There is probably some perf overhead in the generators here, but they do have the pleasant property of hiding several different selection styles behind a neat facade and also minimizing the index mongering. You could easily parameterize the windowing code to support larger or shorter sequences too. 

This is the sort of thing that Python is really good at. Your code seems like it functions, but it will be very inefficient for large data sets. For each input value you have to check every line in the the master list -- and the way you have it set up here you're going to read the master list off disk for each input value as well, so it will be really slow. The first step obvious fix is to load the master list into memory and keep it around for the duration of a session. This is a fairly simple change to your existing code. First, change your pull_lines so it returns a dictionary instead of a list: 

This makes sure the code only fires when the file is executed as a script, not when it's is imported as a module. 

2) using dual inheritance to get the functions of SlideShowBase into SlideShowPics seems more complex than needed. I'd think about just including a SlideShowBase into your SlideShowPics and letting it manage all of the image paths by delegation, while SlideShowPics handles the display. The old saying here is 'prefer composition over inheritance' 

The advantage of pushing the comparison down into the RPS class is that the behavior can be extended without going ELIF crazy. For example the above can be changed like so: 

Bisect is the 'right' answer for serious applications where speed matters. It sounded to me like you're asking a style question. On that assumption: 

In general I'd try to avoid functions that are open ended on both ends -- in your case, taking a variable number of inputs and returning a variable number of outputs. In this case, returning a dictionary means you should always get one answer to the question your asking and not have to write too much conditional logic to parse the answer later 

and so on. The 'ui' for the program then really amounts to creating custom filter functions and returning them. You can manufacture them easily: 

DictReader is especially nice since it automatically parses the first line as the headers and returns a dictionary so you don't need to create a custom class to organize your data (as an aside: you could also do this using the sqllite module, which would let you read and write the entire database directly and query it with SQL. I'm not going to go into that since SQL is it's own thing - but for bigger applications it would be the right thing to research). Writing out the data is the inverse of the above: 

There are a ton of good template rendering libraries out there, but I'd leave it to you to figure out if they are better suited to your needs than hand rolled code. Assuming you still want to write this yourself, I'd look for ways to make the code more completely data driven and also to make it more readable. On the data driven side, you might want save your design as an html file. That way you can use whatever styling or graphic layout tools you want to produce the layout. You merely need to leave template placeholders where you want the data to go and apply the substitutions. Django's templating system offers a great example of what you'd expect: vanilla html data with placeholders where the data's gonna go. Going data driven will reduce a ton of the code here (since so much of it is just string assembly). You can do some nice syntactic tricks to clean up things like writing html tags, for example 

I'd strongly suggest moving the HTML content out of the code and into separate files; I know you want to keep this simple and single-file but in this case there some real benefits to treating the HTML as a resource rather than as code: 

with minimal effort and no changes to the overalls structure of the program. In a real application you'd probably return something more definitive from the 'fight' method than a string - a result class with its own message, or something -- but by keeping the details of the comparison out of the main flow of the program it's easier to extend as needs change. Overkill for rock paper scissors, but a big plus for rock, paper, scissors, lizard, spock. Unfortunately real life is more like the latter than the former ;) 

update grid is creating a copy of the working grid You could try to collect the list of born and survived cells and only update changes: 

Rather than making the game a class, consider making the choices a class. This makes it easy to define the behaviors: 

Conceptually this is halfway between 'traditional' inheritance heavy OOP and @MichaelUrman's data customization approach. All three have their applications, and the neat thing about python is that it's very good at both @MichaelUrman's method and mine -- which is not true for languages obsessed with type-checking and signature maintenance. 2) On the strategy level, in the long term you'll benefit from a finer grained approach. Engines, transmissions, and tires for example might be their own classes instead of aspects of vehicle (a station wagon and a sedan, for example, might share everything but body styles). The class hierarchy becomes less of an issue as you do more mix-and-match customization by creating collections of components. The usual pretentious programmer way to say this is 'prefer composition over inheritance' 

before the string is converted to a float (this will also filter out negative numbers for free as written) In terms of style and construction, the conditions for the mileage and consumption are the same: positive numbers > 0. The only differences are the prompts and error messages. So it makes sense to write one function and pass the prompts in to it twice: 

The first version will be faster but you're storing redundant copies of the indices, which might matter for big data sets Usage: 

In the comments to @MichaelUrman's example, OP asks how to create a specific class of car. A common python idiom (which is less common in other languages) is to create 'thin' subclasses that vary primarily by default content and then occasionally override default methods. This is common in cases where you want a lot of classes which are mostly the same but differ in details and you don't expect to manage lots of subtle hierarchical changes. From the 10,000 ft level this is the same using helper classes, since you're just populating a set of variables in a structured way; I prefer it to using helper functions because it allows you to add custom methods as necessary while keeping things data driven. For example: 

The biggest thing you can do to improve the code is to find ways to make the relationship between the game flow, the data, and the code more concise. Right now the whole game is a series of if statements, and you're using variable names as the equivalent of old-fashioned GOTOs to jump around the code. For something this short that's bearable, but it won't scale to any larger size. Moreover, your structure is going to force the user to make one-time-only decisions at each point - you don't have a way for users to, say, go to the window and THEN look at the wristband. Or to go back, for that matter. That might be your design intention but if you change your mind the current structure will be a lot of work to fix. Last but not least, you don't have any error handling - if the user enters a wrong choice, the program will just move on to the next prompt without assistance. On a very general level you need to establish a structure that reflects the nature of the game. Most text adventures are really a series of linked containers; the container (a 'room' in the old school dungeon game, a 'scene' in a conversation based game, etc) contains a descriptive text and a set of options for the user which link to other containers, and so on. The contents differ but the structures are basically identical; it's a good idea to write the code in a way that reflects the way the game actually works. If you're familiar with object oriented programming, this is a perfect problem to tackle with classes. If not, you can still make your life easier by creating a function that handles the repetitive part and putting the data into clearly labeled variables. Here's a very rudimentary example that uses dictionaries to represent each room and a dictionary of rooms to represent the map. The 'code' is just to keep calling the same function on whatever rooms the user gets from their choice of actions. 

I would avoid inlining the actual constants in the list comprehension tool - that's bad for readability if it's not sitting on the outermost outline level. On the philosophical level, I'm ambivalent. I hate all the quotes etc too, but this only works for strings, so it's not a general purpose idiom. You could extend it with exec or eval to get non-string values, but that's a whole big can o' worms :) 

You're doing three things here: splitting up the listing into sentences, parsing the listing, and recording the results. You can clean this up by separating these out into separate functions functions or classes. This keeps the code less nested and easier to follow. To keep things simpler I'm using regexes for the room names as well as for the dimensions. This will actually be a bit slower - "in" is really fast - but it is more flexible (for example, if you have to support plural endings or something else besides string lookups). I'm compiling the regexes using re.compile to make them faster and re.I to make them case-insenstive. Lastly, I'm returning the results as a list-of-dictionaries, where each dictionary includes the room, dimensions and the sentence from which they came. This lets you keep the printout display separate from the parsing. In practice I would probably use instead of a dictionary but I didn't want to get too far off topic 

The results include a printout of the point and the circles which it overlaps. Or you can just get the points which are included in more than one circle with Note that there are no bounds on the grid, although it would be trivial to add them (probably by setting a range on the and rejecting points outside that range in the add method). 

Map is handy for shortening ths common pattern, but I think Guido has officially disowned it for the future 

I'd see what happens if you refactor drawing code out of the cel update loop. Let each sprite image maintain a list of bools corresponding to all of the available tile position (as the other commenters have noticed, make separate images for the different alpha versions of the same sprite instead of tweaking it on the fly.) As each tile updates, see if it's state has changed enough to warrant a sprite change. If it has, toggle the corresponding entry for the old sprite list off and the same entry in the new sprite list on. In general you won't be changing the lists that much (and by keeping them as fixed size lists instead of adding and removing them you won't have to worry about moving a lot of memory around). Once all the sprite image lists are set, just loop through each and draw a tile for every true value (you'll need a formula to get the 2-d position from the 1-d index of the bool, but that is basically just (tile_height * floor(index / columns), tile_width * int(index % columns)) Hopefully this means (a) you do a lot less moving of memory around - the biggest category of changes is bools toggling on and off in fixed sized arrays - and (b) you can draw the same sprite many times, which should be more cache friendly for the graphics hardware, instead of constantly cycling different art in and out of memory. in this context you might want to google the phrase 'Data Oriented Design' or 'Mike Acton' 

If you've learned object-oriented programming, you might see how the residential and business functions could share code by becoming classes (or more likely a class and a subclass) If you haven't looked at OO, think about refactoring the way 'business' and 'residential' work to avoid having methods which differ only in hard-coded constants. 

All of these filters automatically return lists, so you don't have to loop or create temporary variables to collect matches. I think it's easy to extrapolate from this how to write the program very compactly; using standard library functions means you can concentrate on logic and user-facting stuff (do you want to include partial name matches, or regular expressions, for example? Do you silently ignore bad input or scold the user? etc).