Questions of this nature can be posted in StackOverflow. You may post such questions in the DBA StackExchange as well. 

The next paragraph says that with SERIALIZABLE, one transaction cannot modify rows if another has merely read them. SUGGESTIONS 

MySQL restart not needed. See MySQL Documentation about join_buffer_size OPTION #3 : Make sure is indexed Since you have a reference, this is a rather moot point. If you do not have the , make sure link is indexed: 

The source of the problem was removing the log files before flushing everything out of the logs You should run this to shut it down (using innodb_fast_shutdown) 

The SQL thread in MySQL Replication processes SQL commands from the Relay Logs as a FIFO queue (i.e. first-come, first-server basis). Once the SQL thread see a command, it processes it to completion. Meanwhile, the Seconds_Behind_Master just keeps creeping up. While the SQL thread on the Slave is running , once you run it SQL thread has complete the running before the SQL thread can terminate. That's why hangs. To verify this, open another mysql session and run , You should see a line that has with the status . Your Second Question 

GIVE IT A TRY !!! It's better to insert 4 Million Rows than join 3,311,651,902 (396178 X 8359) rows. 

If MySQL were up for 2 Billion Seconds, MySQL would have to running 62.4196 years for to be a noticeable issue. MySQL has only been around since 1995. Notwithstanding, Uptime and Uptime_since_flush_status status values could be possible culprits due to the 32-bit nature of InnoDB and retrieval of this information is from . SUGGESTIONS SUGGESTION #1 : Since you are using MySQL 5.1.51, you should install the InnoDB Plugin (available since MySQL 5.1.38). SUGGESTION #2 : Upgrade to MySQL 5.5 (not 5.6 just yet) CAVEAT In either case, you just need to upgrade the InnoDB Storage Engine. Before doing so, please check for any release notes on the Latest Release of InnoDB to see if this was resolved. Just so that this perspective is to be taken seriously, notice that negative results can be retrieved even in MySQL 5.6.7 (Negative values could be erroneously reported for some columns in the buffer_pool_pages_in_flush row in the information_schema.innodb_metrics table. (Bug #14090287)) This was also a noticeable problem with the Windows version of MySQL 5.1.55 : $URL$ say This issue with goes way back to MySQL 4.0.26 : $URL$ 

Run the Column Query and Collect the Results in STEP 03) Perform Unique Sort ; Check For Duplicate Table Names 

Root Cause foreign_key_checks is not a global option you can preset at startup. Why ? When you click on that link to the Documentation on foreign_key_checks, there is no chart that says it is global or session scope. Other options will specify the scope in a chart 

You will see the combined sum of all index pages being as large or larger than the table. From a physical standpoint, the file acl_actions.MYI will be bigger that acl_actions.MYD. Here is where random I/O would come into play: Notice your index Notice that you have it defined as 

Upon installation of mysql, you will see two rows that give full access to any database named 'test' or whose first 5 characters are 'test_'. Why is this a problem ??? Try running this command: 

Yes, you can view the relay logs. Since they have the same structure as a regular binary log, just run the mysqlbinlog program. For example to view the SQL within any of you relay logs, such as the last one, do this: 

Run this command : This will give you a display of the SQL needed to create the table. It will also show you the indexes and constraints for that table. The first index () in that table must have a column called . From the error message, you are being told that there exists a row in that has already present. You can verify this with 

These must be resized. Since you are using MySQL 5.1, please do the following: STEP 01) Convert all InnoDB tables back to MyISAM STEP 02) STEP 03) Add the following lines to after 

Unfortunately, the correct answer is YOU CANNOT STOP A ROLLBACK. You have to let InnoDB clean up after itself. If and are in the same database and you want to load from in segments, use mysqldump: 

SUGGESTION #3 Once you make the table MyISAM on the Slave, you could create a dedicated MyISAM Key Cache just for as follows (Example: Setup 512M KeyCache for ): First create a script on the Slave 

Make sure these script exist on both DB Servers Simply run dbvip on whichever server you choose. . So the failover process and protocol are the following: 

If is 0, then is a count of Primary Keys that do not have a Foreign Key To be 100% homogenous, should never show up as zero() (In a Perfect World). Count of Foreign Keys Used By Primary Keys 

STEP 02) Parse the text Every CREATE TABLE would mark the next databse Every USE dbname marks the name of the next database Have each CREATE TABLE description in a text file STEP 03) Do a LOAD DATA INFILE of each of the parsed files into a table of your choice (such as mydb.mytables) STEP 04) Query for the structures 

Just remember to set the @GivenDate to whatever date you need BTW Your last line is based on midnight the next day. Therefore, the is 145 not 25. If you have a knock-off time of 10:00 PM at th eairport, then change 

The idea here is to make sure all binary logs and relay logs are time synchronized. The NOW() function could then be correctly interpreted from these logs. CAVEAT Be very careful about changing clock times when it may not be necessary when it comes to Daylight Saving Time. Since the clock time is written in binary logs in seconds since Jan 1, 1970, it may not be necessary. Since the clock is 75 minutes off, do this ASAP. Don't wait until DST kicks in. 

Also, set the Buffer Pool Size (innodb_buffer_pool_size) to . Change that value in . If you have MySQL 5.7, simply run 

STEP 02 You would then or all these packages. That still won't nix the files for MySQL. What next ? STEP 03 Move the old datadir aside: 

MySQL can also perform GRANTs and REVOKEs on column privileges. In fact, the mysql.columns_priv and information_schema.COLUMN_PRIVILEGES contain those privileges at that level. mysql> show create table mysql.columns_priv\G ************* 1. row ************* Table: columns_priv Create Table: CREATE TABLE ( char(60) COLLATE utf8_bin NOT NULL DEFAULT '', char(64) COLLATE utf8_bin NOT NULL DEFAULT '', char(16) COLLATE utf8_bin NOT NULL DEFAULT '', char(64) COLLATE utf8_bin NOT NULL DEFAULT '', char(64) COLLATE utf8_bin NOT NULL DEFAULT '', timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, set('Select','Insert','Update','References') CHARACTER SET utf8 NOT NULL DEFAULT '', PRIMARY KEY (,,,,) ) ENGINE=MyISAM DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT='Column privileges' mysql> show create table information_schema.column_privileges\G ************* 1. row ************* Table: COLUMN_PRIVILEGES Create Table: CREATE TEMPORARY TABLE ( varchar(81) NOT NULL DEFAULT '', varchar(512) NOT NULL DEFAULT '', varchar(64) NOT NULL DEFAULT '', varchar(64) NOT NULL DEFAULT '', varchar(64) NOT NULL DEFAULT '', varchar(64) NOT NULL DEFAULT '', varchar(3) NOT NULL DEFAULT '' ) ENGINE=MEMORY DEFAULT CHARSET=utf8 

You should startup mysqld with log-warnings (it should be on by default) and also the max error count 

@Sebastian, I put the query back in the original join order. Please try this as well !!! UPDATE 2012-02-21 17:11 EDT Make sure the datetime field is indexed 

I highlighted that sentence because your query is as simple as it is going to get. You are doing a join on an integer which I assume is already indexed in both tables. If id in table us not indexed, please index it ASAP. I would suggest raising join_buffer_size to 4M. You can change join_buffer_size in your session and rerun the query 

There are five(5) methods you can do METHOD #1 Don't run restart. Delete the binlogs between shutdown and startup. Let's say is in . Run the following: 

Above this output are histograms of these 20 top worst-performing queries Example of the first entry's histogram 

and see if this is or . mysqld may be capping it. It is entirely possible that open_files_limit is getting autoadjusted. The Documentation says and . Here is how and interact: 

Possible scenarios are endless !!! Remember, whatever you allocate for, leave enough RAM for DB Connections and the Operating System. 

How could a SLAVE produce different results? If you have a several hundred INSERTs commands occur on a Master, they get serialized in the Binary Logs. Even if a DB Connection 1 completes an INSERT before DB Connection 2, it is possible for DB Connection 2 to write its event in the Master's Binary Logs before DB Connection 1. This is particularly true in a write-intensive, heavy OLAP environment. This would make a Slave's copy of physically out-of-sync with its Master. Running queries can hide this. OK, you are probably thinking it's just a SELECT. SELECTs are not in Binary Logs. INSERTs, DELETEs, and UPDATEs are. Did you know you could do a query like this ? 

Aha !!! The NULL value is being mishandled in net_store_length() when dealing with the field. If the is a DATETIME or TIMESTAMP, using NULL is most likely not being permitted. Perhaps changing 

There are three(3) ways using file timestamps: InnoDB Buffer Pool If you have innodb_buffer_pool_dump_at_shutdown configured, look for the timestamp of the file that was written. The default filename is . Mentioned this back on (Control InnoDB buffer pool allocation in MySQL (5.7+) is usually written in folder set by , you can run the following after shutdown: