Only in exceptional circumstances will players notice or care about the accuracy of your physics simulation. Most games fake calculations like these, which has several advantages; fake calculations are easier to code, computationally less expensive and most importantly, they allow the behaviour of the game to be tweaked in favour of fun rather than realism. If playtesting reveals physically accurate bullet drag is less appealing than some other model, faking it becomes a deliberate design choice. If you still believe realistic drag is an important feature for your game, here's a bit of physics. The drag equation can be solved analytically, though if you should want to involve other forces on the bullet, you require numerical integration. Combining the drag equation with Newton's second law of motion, we get: m v'(t) = -½ v(t)² ρ A Cd, the solution of which is: v(t)=2 m / (ρ A Cd t + 2 m v(0)-1). This gives us the bullet's speed as a function of time, not of distance, but we can integrate v(t) over time to get the distance travelled x(t), then invert that to get the travel time as a function of distance: t(x) = 2 m(eρ A Cd x / (2 m)-1) / ( ρ A Cd v(0) ). The many symbols in this formula obscures its relatively simple exponential nature, which becomes apparent if we simplify v(t(x)), the speed the bullet has when it reaches x: v(x) = v(0) e-(ρ A Cd/ (2 m)) x. The plot below shows the bullet velocity against distance with the parameters you supplied (air density: 1.225 kg/m3; bullet radius: 11.43 mm; initial speed: 251 m/s; drag coefficient: 0.45; mass: 10 g). 

I have two long Box2D bodies, that can collide while moving one of them around with MouseJoint. I want them to try to hold their position and rotation. 

Create your own thread that will be checking the array of enemies and adding them to the game. Also sort the enemies by time they are supposed to arrive and stop on the first enemy that in not supposed to arrive yet - then you don't need to check all of them. You can implement this by using stack. Push the enemies to the stack in the opposite order and pop() them when needed. How to do this in cocos2d, I don't know, but this should be the general idea. 

Use the line and bear the consequences (I do that in my game btw) Use line texture + sprite Temporarily show something (draft using 1 or 2), then create a bitmap from it and load it to texture memory as a new texture and then show it. 

I am often in need of a fast prototype box2d scene where I can play with parameters. I work with AndEngine on Android which doesn't suit me for prototyping. It's good for the final game, but prototyping is slow. My requirements are: 

I have used Parallax background in my game and I don't understand, why should the vertical and horizontal ratio should be any different. I have only 3 layers. Static background, parallax layer that moves half the speed as the front (game) layer. In my game, there's a lot of vertical and horizontal movement and it simply looks the best when the vertical and horizontal movement is the same. Now adding one more layer that moves 1/4 of the speed horizontally (so it is further), why shouldn't it be the same ratio vertically? If I just consider mathematical point of view, parallax layers are like slices of the real world. We make a lot of simplifications when making games, so let's do some: Draw a hypothetical line from your eye all the way the infinity, so the line is perpendicular to your body. The point in infinity never moves. When you move left one meter, the start point of the line moves one meter to the left. The point that we will consider placement of parallax layer with horizontal ratio 0.5 (let's call it X, it moves half the distance) will move half a meter left. Now go back and duck. The line will move 1 meter down (depends on your height, really...) and the point X moves half a meter down, doesn't it? So doesn't it look "weak" simply because your run left and right for a long distance, but you jump only a little? 

The yellow line indicates the intended behaviour. You can see the blue line (timesteps of 0.1) starts with the right slope, but isn't updated for a while. It's a little high, but doesn't cause any major issues. The red line has more time in between steps (0.2). By the time the slope is updated, the rotation has overshot its target. There are more elaborate ways of tackling this problem, but you are somewhat handicapped by the fact that the target rotation might be changing too. The simplest way would be to specify a range around the target where the rotation is 'close enough' and should stop moving. How large this range should be depends on your timestep and maximum angular velocity, but I suggest some experimentation. 

You can invent your own algorithm, as simple or fancy as you like. It'll be horribly broken, but it will have to suffice. You're asking for good ways to secure save-state passwords. There are none. At best, you can try to frustrate the player until he gives up. The reason these methods don't work is that they fundamentally try to do something out of their control. Assume I'm a dishonest player. If you tell the game not to do something (e.g. start in a different state) and I say otherwise, I win. My pc does what I tell it to do. To put it a different way, you can't trust the client. Perhaps more importantly, as long as my cheats don't harm the experience for other players, any effort you put into securing your password system goes straight to making the game less enjoyable. After all, if I didn't want to manipulate my saves, I wouldn't do it. In conclusion, unless you have a multiplayer mode to protect, this is a lost battle for a bad cause; I advise you not to fight it. 

I wanted to say, its Separating Axis Test, not Theorem. You'd use SAT on non moving polygons (2D), although you can extend it to cope with relative linear motion. $URL$ Don't use GJK in 2D, I found its actually slower than simply brute forcing SAT. Another technique you can use is Minkowski Difference, which shrinks one object down to a point and 'grows' the other by the shape of the first. Then you test the combined object against the point which is a lot easier - this gives you penetration distance and normal. I find this tool is conceptually very useful for approaching new collision detection problems; easier to visualise than SAT. For moving and rotating polygons (and polyhedrons) you can use Conservative Advancement to find the exact time and point of contact. $URL$ You can read more about these techniques in this blog post which I wrote a while back: $URL$ Hope that helps! Cheers, Paul. 

Most platform games have multiple layers of these maps; background tiles generally have no collision information associated with them and are purely decorative, mid-ground tiles can be used to mark locations associated with game-logic, like entrances and exits, or for placing AI characters. Foreground tiles are used for collision information and the main body of the actual platforms. Maps can be connected together using special tiles which indicate an entrance or exit, when collided with the system can unload the current map and load in the new one. You can read more about platform games in general here: $URL$ Hope that helps! Cheers, Paul. 

According to your current code, both the x- and the z-component of my movement need to be pointing up the slope for me to start climbing. Consider a slope with the normal (0,1,-1) normalised, and my horizontal motion (0,0,1). I would not pass the conditions in the x-direction, even though I'm going straight up the hill. I doubt that's what you're trying to accomplish. The dot product will tell you whether you're going up or down and by how much: 

To make things easier, I would probably cut the requirement the algorithm should be able to generate tracks of different lengths. Since you've specified a range, it will need to keep track of the length anyway. You might as well pick one before, at random if you like, keeping in mind the starting and ending locations determine whether the length will be odd or even. Imagine a checkered board to see why. Start out by drawing any one of the shortest possible tracks. If it is too short, select a random point on the track, then a second point a few nodes (Q) beyond the first, break up the track in between, and redraw the section using the two points as start and finish, but this time with a length of (Q+2), for instance by moving up at random until the traveled distance plus the minimum distance between the current node and the finish equals (Q+2), and start moving one tile in the direction of the finish every step after that. If at any point, you get stuck, revert to the last valid track and try again. This algorithm will probably try to draw a lot of invalid paths, but leaves a lot of room for optimization, allows you to balance efficiency against 'flatness' of the probability distribution of all theoretically possible tracks, doesn't use relatively expensive tree searches and scales well, because you can make the redrawn sections as small as you want. 

I am looking for 4-6 color schemes for three factions, good, evil and neutral (in a space strategy if that matters). I'd like the player to choose which side they want to play and each side will have an optional ally. Each team can have one or two colors (major/minor), if that makes the problem easier. EDIT: I know that color perception can be subjective, context sensitive and influenced by culture. I am looking for a scheme that majority of players would see as a traditional fight between Good and Evil (Blue and Red comes to mind when having only two colours, two factions). 

It looks to me that you want your animated sprite to be driven by the physics body (you register the connector) but then you are setting its position to some and . The physics body might be jumping, but the Sprite is drawn always at [pX, pY] due to this code. 

You are either asking, how to set z-index in the scene higher than a z-index in the HUD, or how to set the highest z-index in the scene. If it is the first option, bad news. There are three layers that have separate z-index. Background, the scene itself and HUD. Actually each Entity can be a layer with their own z-index. Background is always rendered first, then the scene and then HUD. If you set z-index to anything in the scene, HUD and its entities will always be rendered on top of it. If you are interested in highest z-index in the current scene itself, after you sort the children by the zIndex, simply call 

Implementing any constraint in an impulse/velocity solver comes down to finding the relative velocity between the two connected bodies that you want to remove. In the case of the distance constraint, this relative velocity is always in the direction between the constraint anchor points. 

To answer the platform game specific part of your question: Platform games are traditionally tile based. Tiles are fixed size rectangles which comprise the building blocks of each level; they can have the appearance of stone, or grass or any surface you can imagine within reason. The best way to design them is to ensure that when two identical tiles are placed next to each other, the texture seamless repeats. A good example of how to design repeating tile sets is here: $URL$ Tiles are laid out in memory in what is called a 'map'. Each tile is given an identifying number; maps are rectangular arrays containing numerical tile references. An example map might look like this: 

Its perfectly acceptable to use TCP instead of UDP - if you turn off the Nagle's algorithm. Once you turn off Nagle, you have most of the speed of UDP and will be fully able to make a twitch reaction game. Indeed, I have made such a game using TCP in Flash: $URL$ Hope that helps! 

Then, all you'll need is an equation which lets you remove velocity by calculating an impulse. Plug in the velocity to remove and out pops an impulse which you can then apply equally and opposite to both rigid bodies. If you'd like to read more about this process, I wrote an article a while back which covers designing a constraint in a impulse/velocity solver: $URL$ Hope it helps! 

There is a similar expression for drag as well, and it is obtained in the same way: by solving the differential equation . It yields . Note that coefficient needs to be a negative number, because drag accelerates against the direction of the velocity. Assuming the coefficient does not change over time, the resulting velocity is independent of the timestep. Though the calculated velocity might be accurate at every step, by numerical integration, the position is not, but since is a known function, we can integrate analytically too: . 

A win rate of 50% is the only number a matchmaking system can possibly aim for. As an example, if the system were set up to create matches in which players have an estimated 60% chance of winning, then from the pigeonhole principle, it follows that there must be a probability of at least 20% of the match ending with both teams victorious. League of Legends, as most competitive games are, is zero-sum. For every match you win, someone else must lose. Regardless of how your matchmaking system works, if the total number of wins equals the total number of losses, the average win ratio will always be fixed to exactly 50%. That doesn't mean everyone is winning only half the time, but if your win rate is above average, someone else's must be below. Better players will naturally gravitate towards high numbers, worse players to low. That's fun for neither. It means better players are insufficiently challenged and are conditioned to expect a win, decreasing the rewarding experience when they do and increasing the frustration when they don't. On the other end of the spectrum, frequent losses disappoint, people feel they are not given a fair chance to compete and new players are alienated from the game. Generally, the less certain the outcome of a match is in advance, the more exciting the game will be. That is what a matchmaking system hopes to achieve. By putting players against opponents of their own skill level, it does not ensure the win rate averages close to 50%, but it lowers the variance in win rate across skill levels. Not necessarily to a minimum, by the way. A matchmaking system could actively have new players face veterans instead of other rookies, so their win rate starts off low and increases as they get better at the game. This pushes the ratio of seasoned players to an optimum between 50% and 100%, whereas new players experience a sense of progression. In conclusion, why aim to keep everyone winning only half the time? The alternative is to have some win too often, others not enough. 

Setting a velocity directly is frowned upon and should be done only in a few exceptional cases such as adding a new body to the simulation that has some initial velocity. Otherwise use forces or linear impulses. Third, what does this code do? 

In a simple platformer game I want to rate the player's performance in a level based on score. Very common in a lot of mobile games is "three star rating", probably the most notorious example being Angry Birds. My question is: Should I use the same type of rating or use something else? Is it better to be original or use something the players are used to? If three stars, should I avoid 0 star rating? (i.e. give player at least a star for finishing the level). 

You can use method from the Entity class. The whole Scene is an entity and you attach all objects to it, so if you call all attached children will stop updating. Of course, you can selectively call this method only on Entities that you wish to pause. onTouch events should still work. 

Well, why does the things you said feel awkward? It's the way to go. You can create the assets for the closest zoom level for the best quality. When zooming out, you will see scaling (down), but that usually looks ok. In my game I simply create full HD textures and thanks to that, my game looks ok on all mobile devices. You can also use LOD (level-of-detail) techniques to change the graphics when the zoom level reaches certain threshold. This is not implemented in AndEngine, but you should be able to write the code yourself. The LOD techniques can involve blending between the high detail and low detail graphics, so you won't see a "jump" in the quality.