A pulldown resistor basically ensures that if the line is floating, it will get connected to Ground (0V) and always read LOW. Similarly, using a pullup resistor ensures that if the line is floating, it will get connected to 3V3 and always read HIGH. The value of the resistor is high enough (in the order of 50kOhm) to effectively block the path to 0V/3V3 once the line is connected to a circuit, current is flowing and the line no longer floats. 

Check out Volumio [Note: currently returning an empty page for me so they might have an issue on their servers, so you might have to check back later]. Volumio is a full OS with an audio playback server controlled via a web interface, and runs on the RPi. I use it on an RPi model B. It has a Spotify client, but you need a premium Spotify account for it (won't work with the "free" Spotify). I've written my own custom Pandora server for use in Volumio - but that code is not yet ready for primetime (needs a webUI :)). On Second Thought: This might no longer work as per your libspotify comment .... I'm not a Spotify user myself so I cannot check. 

Net - this is not straightforward (but also not difficult). You might get better answers on the Electrical Engineering Stackexchange site - however, they will not design this for you - there are tons of people doing aquarium pumps with Pi's/Arduino's so you should easily find reference designs in a quick Google search (e.g. this one) 

This screen uses an RCA type input. If you have an older style RPi (model A, model B), all you need is a standard male-to-male RCA cable, as the older Pi has an RCA-style composite out. 

A microUSB-to-USB adapter - there is also this one but it might not have data connections as it is intended for charging. 

I'd like to know which cable adapter you have that claims to be "passive". From what I know (check $URL$ for a good summary, especially the last post), there are 2 "definitions" of active vs passive: 

You could consider a powerbank like this one to deal with power interruptions, provided they are no longer than a few hours. This power bank is also a wifi router, though you might be able to find one that isn't. Most important feature is the fact that it can be recharged by plugging it in to an outlet - so you can insert the powerbank into an electrical outlet, and it will power your rPi directly from the outlet when there is power, and from the built-in battery when there's none. Just note that this is an indoor item, so you would need to build/buy an enclosure for the unit to keep it safe. 

Plug 2 into 1, then 1 into the RPi and you have Wifi in a smaller size than your usual USB Wifi dongle (excluding the Kootek/Edimax of course). 

It doesn't really shrink the size of your SD card, it creates several partitions on the card, out of which only one is recognized by Windows (the 60MB boot partition). The rest is still there, but only visible to Operating Systems that can read ext3/ext4 file systems. The initial size of the main partition on the SD card will be limited though - once you boot into Raspbian you will need to use (or use the GUI from the Menu) to resize the root partition to utilize the full remaining space on your SD card. 

First you want to make sure that "Username" is a valid user on your RPi. Easiest way to do this is to ssh in as "pi" (since you said you can do this) and then type , replacing "Username" with whatever username you are looking for. If this gives you a list like this (not necessarily exactly the same of course), the user exists: 

For this community to do more troubleshooting you would need to provide more details on how you are connecting to the rPi, e.g. What it is connected to, the type of computer you are using to connect, the network settings of this computer, the OS version, and how you are connecting to the outside world. The resolution to your problem varies based on all these factors. 

The RF24 library needs to be updated to have a different BCM2835_PERI_BASE argument (from 0x20000000 to 0x3F000000). (In the bcm2835.h file) Then change the Makefile to have the correct armv7 architecture flag () Recompile the library and test it out 

Even though this question is better asked on Electronics.StackExchange.com, here are some thoughts: You could get nine 8:1 Multiplexers/Demultiplexers like this one: $URL$ which costs $0.52 per item (so less than $5 total). Use three lines to activate the master multiplexer (choosing which one of the 8 other multiplexers is active), then use three other lines which are shared across all the other 8 multiplexers to determine which input line from the multiplexer you listen too). Connect a single ADC to the output of the first multiplexer and read your signals one at a time, switching inputs using your 6 data selector lines. Of course you need to make sure that your signal voltages fit the multiplexer specs (and same for Wattage), and know what latency your ADC has between measurements, but this might be a cheaper solution than getting a single dedicated 64-port ADC like the Texas Instruments DDC264 (which costs ~$120 on DigiKey). 

What is likely happening is that by connecting directly to 3.3V, your device is trying to pull max current from the rPi, which in turn triggers a protection mechanism (as the 3.3V pin is limited to 50mA). Putting in the resistor should limit this (3.3V over 1kOhm = 3mA). You could try to do option 2 as well by connecting to 3.3V with the same resistor, but by using a GPIO pin you have more control. Actually, you should give both ADXL345's a GPIO pin, and explicitly set one to 0 and another to 1. Otherwise the ADXL's input might float sometimes (unless there is a pulldown resistor built in) and you still get a conflict. 

First of all, Kodi is not an OS, it is an application. OpenELEC on the other hand is the combination of Kodi and an OS, bundled in such a way that Kodi is the only interface you work with. So, you could just simply install Raspbian, pull Kodi using apt-get, and tweak the kodi install as per the wiki on kodi.tv 

will list the necessary parameters for your monitor. The format of the new lines you need to add to config.txt is: 

The basics: The Raspberry Pi's GPIO pins work with 0V-3V3 differential from GND, and can work in either Output (the RPi sends out a signal) or Input (the RPi listens for a signal) mode. In Output mode, if you make the pin HIGH in your program, the GPIO pin's voltage will be at 3V3 compared to GND. If you make the pin LOW in your program, the GPIO pin's voltage will be at 0V compared to GND. In Input mode, the pin has a value corresponding with voltage supplied by the component attached to it - either 0V or 3V3 compared to GND, provided the component is connected to the same GND as the rPi (otherwise voltage levels are "random") [Technically, there are thresholds between 0V and 3V3 below which the pin is considered LOW and above which the pin is considered HIGH; Also, make sure the component supplies 3V3 signals, not 5V or higher, because applying a voltage that is too high could break your RPi]. If there is no component connected, or the connected component does not complete an electric circuit using the pin's wire, the pin is considered to be "floating" and the voltage can be anything between 0V and 3V3. You can remedy this situation by enabling a built-in pull-up or a pull-down resistor on the rPi end through your code. A pull-up will make a floating pin read 3V3, a pull-down will make a floating pin read 0V. Connecting your switch The simplest way to connect your switch is by connecting one end to the RPi's 3V3 pin, and the other end to a GPIO pin. In your program, make sure the GPIO pin is set to Input, and make sure you have a pull-down resistor enabled to make the pin LOW when the button is not pressed (without a pull-down resistor you might be detecting phantom button presses). Now monitor the state of the GPIO pin in your program and you will notice it will be showing as HIGH when the button is pressed, and LOW when not. There is however an important caveat: your switch is rated for maximum 50mA, and so are the GPIO pins. It is not fully documented how much current the 3V3 pin on the RPi can supply - some say 50mA, some say 100mA - but the net is that this setup pulls as much current as possible from the 3V3 pin through the switch into the RPi's GPIO pin. It likely will not damage your RPi (otherwise I wouldn't even mention this setup) but to be safe, you should put a resistor in the switch circuit (either between 3V3 and switch, or between switch and GPIO pin - the latter is most typically done). The resistor will limit the current through the circuit as defined in the V=I*R equation. Since you know V (3V3) and want to limit I to as small as possible (let's say <10mA), the equation gives 3.3 = 0.010 * R or R = 3.3/0.010 = 330Ohm. So any resistor bigger than or equal to 330Ohm will do (470Ohm, 1kOhm, even 10kOhm). Multiple Switches: Wiring up multiple switches is now simple - use the same 3V3 supply wire, branch it to each of the switches, and connect the other end of each switch to a different GPIO pin. Follow my earlier instructions and you can now programmatically monitor the state of each button. You might want to look at events in the language you'll be using so that you do not have to write a program that actively scans the GPIO pins all the time to see if a button was pressed, but rather have it wait idly until the event associated with the button press fires. PS: Never, EVER, set your GPIO pin to Output and then treat it like an Input. Setting the pin to Output disables a bunch of protective circuits inside the RPi, and when the current from the input signal arrives at the rPi it goes straight to the Broadcom chip, potentially frying it as a result. 

I can give you some pointers, but not a full answer as that would be me designing this solution for you - you need to do some more basic research as what you are asking is very common technology solved in thousands of blog posts, instructables.com articles and more (I know because I recently added an IR receiver to my rPi for Media Center purposes). First of all, let me assuming you want the phone to be the controller, and the rPi to be attached to the projectile launcher (you're not spelling this out in your question - maybe you could edit it in). 

I would start with creating a dummy serial device which will capture the output of your Java program sent via serial. You could program this in Java. Since you are running the same program on Windows and on the rPi, I assume the issue is with the values the serial device receives, not a problem in the Java code itself. Perhaps the value gets sent over as a signed byte on the rPi (vs unsigned on Windows), and becomes a negative number, which leads your device to display the incorrect terminator instead of . 

You are using the variable pfr twice, so the first assignment gets lost. If you change your code to use different variable names like so: 

If you already have an RPi that you want to use, or if you just want to try Kano out, you can download the Kano OS image directly from their site. Of course anything using their peripherals won't work, but most of it is "normal" software. Note that their image uses an RPi2 - so it won't work on an RPi-B(+). 

Audio CDs are NOT mountable media. They can only be read by utilities that are able to interpret their data - they don't have a "filesystem". And, as correctly noticed by , an Audio CD is Read-Only - you can suppress this warning by mounting with the flag. As per this forum thread "Audio CDs don't contain filesystems. They actually resemble phono tracks, which spiral inward and have gaps to mark the track boundaries.". The answer to "How do I get this to work" hence depends on the exact definition of "this": 

The error is in the raspberrypi.org example. It's missing an import. Add the following line and your code should work fine: 

Your wiring diagram is correct, as (per the Sainsmart.com website you linked) the specs of the device are: 

For the controlling of LEDs and such through the GPIO, check out ScratchGPIO. Scratch itself has network broadcasting capabilities out of the box, through a feature called Remote Sensor Connections. All you need to do is right-click on the () Sensor Value block in the Sensing section to enable this feature in your program. 

Once that is complete, you can do . I must say, the whole arduPi library and shield setup is marked as "Expert" level on the site you linked - if you do not understand the workings of the c++ compiler and how to link code libraries, it might make sense to read up on that first and get familiar before tackling the arduPi library. 

Pin 4 is 5V supply, so you can use this for your transmitter as well as for your display - BUT note that this will draw additional current. You'd need to see if the rPi can supply sufficient current to both. CORRECTION: The article says "Pin 4" but you can see clearly that they mean GPIO 4 (which is physically pin 7). As per your Display wiring, this pin is not used (I assume NC = No Connection). You could see if you could bend the antenna around the display and use it the way it was intended in the tool. I looked at the source and at the original PiFM wiki and it clearly says this FM transmitter trick works only with GPIO 4, so there is no way you could go into the source of the PiFM code and change the port to one of your free GPIO pins unfortunately. ONE note of warning: This antenna can broadcast on already assigned frequencies, and even if you set it to an unused frequency it has harmonics that interfere with assigned frequencies. So be careful or else government agencies might come knocking .... 

Finally - the board seems to have 3 pins directly exposed (labeled #4, #5 and #6). Pin 6 on the Pi is GND - you could try to connect your ground there after first confirming with a multimeter that that pin is indeed ground. 

Go look at IR receivers online. Adafruit sells one, so does Radioshack (in the remaining locations they have in the US, you just have to browse through their component racks yourself as their personnel is totally clueless). If you're not from North America, there are tons of hobbyist electronics stores in Europe and Asia that sell these, either in store or online. Adafruit also has a short tutorial on how to wire it up, just forget about all the LIRC setup they mention. Most IR receivers have three pins - a ground pin, a VCC pin (you need a 3V3 source) and an output pin which contains the received information. Just wire those up to GND, 3V3 and one of the GPIO pins. I don't know your solenoid, but it will likely have a VCC input and a signal input, as well as a ground. If the VCC is 3V3 and the current requirement is very small (<100mA) you can connect to the rPi's 3V3 pin. If the VCC is 5V and the current requirement is 0.5A or less, you can use the rPi's 5V pin. If the VCC or the current requirement is not within those specs, you need to look for articles on how to use a relay with an rPi (thousands abound, just google). Now, using a library like RPi.GPIO, you can read the incoming signals from your IR receiver GPIO pin, do your logic and then send the right signal to your Solenoid. Again, boatloads of documentation on this at uncle Google.