That's a cool approach to thinking about updating your game objects. I don't know Scala, but I say give it a shot and see how it turns out, and even better post your results! The main questions that spring to my mind are: How do you manage how frequently some game objects update versus others? Will you need to worry about the sprite actors taking up too many cycles such that rendering system doesn't have time to draw a frame every 1/60th|30th|24th of a second? Another thing to consider is how this will affect resolution of player vs. AI interactions that rely on the order of a sequence of very quick events. Depending on the type of game, this may not probably won't matter much. 

If you can guarantee that no writing will be done to the grid during this process that will cause any deadlocks or race conditions or invalidate the calculation, then pass the reference. But I'm guessing you can't guarantee this, so copying the grid is usually worth it. 

You'd probably be happier going with what mheona recommended. But if you're going to use Unity's physics, then you probably want to use . Example: 

Using a child object in your mount point is possible but unintuitive with a transform hierarchy. Treating your top-level object as your mount point will make your life much easier. 

First and foremost, Corona SDK is lovely to work with. Lua's a great language, Corona's a very thorough framework, and the documentation's been great thus far. In my opinion HTML5 game development isn't worth it yet. Both on desktop and mobile browsers. If your goal is to make an awesome game to run on desktops and mobile devices, then don't bother. If your goal is to make an HTML5 game, then go make it and use one of the frameworks people have mentioned (also look at Crafty or Gee for more of a drawing-type interface). The primary reason is that when I make a game, I want to make a complete and polished game. Part of making a complete and polished game is good audio. Although the tag is supported on major browsers (assuming you provide enough different formats), managing your soundtrack programmatically with is kind of a pain. SoundManager 2 is a band-aid, not a solution. In many cases it will just fall back on using a Flash object for desktops. At which point I ask, why not just make the darn thing in Flash? On iOS, unless you use a hack like in Zynga's Jukebox library, you're actually limited to only playing sounds in response to user input. It's ridiculous. Also, unless you're packaging your HTML5 game up as an app, people need a connection to play. The time I spend playing mobile games most is on the subway--no signal. And if you do package your game up, won't it be weird to not have sound? If I'm downloading a game I expect a certain level of responsiveness and polish. Read: a native app. Until HTML5's further developed and mobile browsers are faster and HTML5 audio stops sucking, I will have fun playing with Javascript and and all that, but I will not go so far as to produce a polished game with it. It boils down to what your goals are. Very few I know who play games and are not developers even have mobile HTML5 games on their radar. Again, if you want to make awesome HTML5 games, make HTML5 games. If you want to make and sell awesome games, make the quality of your players' experience a priority. 

Don't Change Anything You missed one serious PRO of calling your entity manager explicitly: easy predictability. Well, you did mention "can't be removed," but it's so much more than that. Given that in order for this entire entity system to work, you require that and collaborate to manage the lifecycle of objects, and other objects being able to subscribe to events is merely a way for other code to hook into this event, your initial approach is what I would have done. What if you unintentionally add a listener in the wrong order? What if you unintentionally remove the listener? Yeah, the answer to those questinos are "Don't do that!" but separating a call that is absolutely required from calls that are purely optional is a good, and pretty basic, defensive programming technique. Don't cause problems for yourself in order to adhere to some sort of pure architecture. Maybe Change Something You might want to actually consider putting the calls after you've iterated through the listeners. This would be treating the as part of the "dying" process by convention. You could even provide and signal slots/virtual calls. 

Now to play devil's advocate, why Ruby over another "beginner-friendly" language? Python has pyglet. And Panda3D. And how about Scala? It seems much more friendly to start with compared to Java. Hello World is just this: 

There's also Alice from Carnegie Mellon. It's centered around teaching programming concepts through a visual interface to create 3d animations and games. 

Also maybe consider plotting the data so you can visually spot anomalies (like going outside of the -1 to 1.0 pre-quantization). If it sounds good at each of these stages, then maybe it's time to revisit how you wrote the WAVE header. Also agreed with Ray Dey, a compare/contrast soundfile would be helpful. 

This is really quick & convenient in C++ and C#, but Java enums are special, so you may find it more convenient to create a KeyCombination class or something that will store all of this information without worrying about enums. But the idea is still the same. I'm using this in an XNA game, and I like the facility a lot. You can also use it to separate input regions, which is useful for comparing different parts of the keyboard or gamepad independently (might be useful for two players on one keyboard). 

So now you've got all this infrastructure. How does this apply to the level editor? Well, notice that really the only thing that a TeleportTriggerProperty needs to work is a Point and a Group ID. These are the two fields that you can expose in your level editor. Then you can presumably export your level structure in XML or some other data format to look like this (I used XML, since its hierarchical nature makes sense in this scenario, and as3 parses it natively): 

At the end of the day, XNA games are just regular .NET applications. Read the docs on Main() and args. You can also use (link). 

From what I gather, HTML 5's audio potential has a long long way to go. Firefox 4 Beta apparently has a cool audio API but it's going to be a little while before we see the major browsers provdie comprehensive support for the W3C Web Audio API Standard 

Does simply checking for an not work? You can't have an before an . If is not working for you, then you should assume it is not reliable and not use it. Build your own key-repeat handling logic like lionesmiz hinted at. If I were you I'd build an abstraction layer on top of this. Polling for SDL events is an app-wide thing, and you should be asking an input module (something like ) about the state of the keyboard. Keep a that maps values to some sort of value so you poll once every frame, then all the rest of your code just goes to this input module for this information. But however you do it, just provide some sort of sensible API for your state classes to use. Why keep it wrapped up inside this nonsense? You want INPUT dammit! 

This depends on the combination of frameworks you are using. Sometimes a 2D game framework makes it very difficult to work with coordinates that are not bound to pixels because they were designed specifically for designers to think about their game world in pixel units. However, it's not a requirement. A game I'm currently working on relies on Box2D units being 1 unit in world coordinates, with each 1 unit grid in world coordinates being able to generally contain one tiled sprite, which is 128x128 pixels. This is strictly by our convention though, as you could simply scale the quad on which the sprite is rendered up or down to your desired size in screen and world coordinates. Regardless of how your sprites are rendered, you should have a matrices for transforming your sprites' world/rendering coordinates to Box2D coordinates and back. Even if 1 meter == 1 world unit, if you make this flexible from the outset (not that difficult), you'll appreciate the flexibility. 

The naming of your functions is hard to determine, and looks like you've just covered the 4 boolean cases. For example, what is the purpose of ? The only case I can think of is where you want to keep a flag for a player holding down a key to charge something up. But you'd probably want to keep that flag stored elsewhere. For checking inputs, I like to do something like this: 

You should also apply global gravity in your project's Physics settings, and for objects that you want to fall faster, add a Constant Force component. is similar but is affected by the rigidbody's mass. Makes it harder to tune. 

Edit: With regards to math, I'm also a little shaky on my foundations. A good resource for these general subject areas is Khan Academy. For other free stuff, just browse GameDev.net, and possibly the MSDN articles for XNA. 

We did this specifically because enabling and disabling colliders that were children of rigidbodies can really screw things up in some circumstances. So you can't reliably disable part of a compound rigidbody collider, but you can reliably swap around the layer of one of the compound collider parts. Now your specific situation To reduce the impact zombie collision has on your car, consider making your zombies kinematic rigidbody triggers, or otherwise making their mass very very small (like float.Epsilon), so the impact has zero effect on the car's momentum. On impact, you can also do this layer switch, so that subsequent collisions aren't triggered, even if the first one applies a negligible force to the car body. You could even switch them to a layer that just doesn't collide with the car. You could also put another collider on zombies that get activated on ran-over. This way you can fake impact forces OnTriggerEnter. You can't get as accurate with it, but you can approximate where the contact normals may have been well enough to throw the zombie somewhere fun. You have to ask yourself: 

This started as a comment on Steven Stadnicki's comment, but grew too big so I figured might as well answer it fully. As for your question on whether to use a class or module-type thing with a namespace, I don't think it actually matters. Rid yourself of this need to constantly be object-oriented! Whether you should use a namespace or some kind of global/singleton/dependency-injected class depends on how you're using namespaces in general. If you'd have multiple journals loaded at one time with different state, then yes it should be a class. Otherwise, it might be unnecessary. I presume that the general flow for setting up and using the journal is something like this: 

Are you talking about 2D or 3D Textures? When you're drawing 2d graphics with SpriteBatch.Draw(), you have the option to set a source and destination rectangle. To keep track of a collection of smaller textures, you'd have an array/list/whatever of Rectangle objects that represent the source rectangle of your loaded Texture. See MSDN's documentation for SpriteBatch: $URL$ I haven't done any 3D in XNA, but I presume there's a similar mechanism. 

TL;DR: Typically, yes. But maybe not. Javascript MVC frameworks are primarily for making it simpler to cause an update in a model to trigger a UI refresh or a save call to the data store, or similar tasks. From playing around with them, it looks like MVC architecutres (ie: Backbone and co.) are really just prebuild object prototypes with some informal protocols for updating data. The concepts and features are powerful when you're making basic GUI pages, but are less impressive when looking at them from a gamedev angle. In a game, you generally want to go through as few significant layers of indirection as possible. Just give yourself a top level object-namespace type thing that contains all your game variables and access them directly. Getting some object to notify some bit of code that it has changed isn't terribly useful if you're polling the state of that object every update frame anyway. Those blocks aren't free. Choose which specific properties of an object for which it's absolutely necessary that events happen (instead of just polling and keeping a "previousVal" var for each specific bit of code that needs it), and limit your events to only update on that set. You can even make a reusable mechanism like Backbone's attributes so long as you keep an eye on how often you're triggering events. It's silly to send events and check if the value is already not equal for position changing, because you're going to redraw most of these things every frame anyway, so just keep writing it into memory, even if you write "position.x = 142" thousands of times (although maybe at that point you can have a collection of "static" objects ;) ). Libs like underscoreJS are probably a good thing to take advantage of, since it's primarily about providing functions that make data manipulation easier and doesn't appear to make assumptions about your architecture. And you may even be able to keep using Backbone as infrastructure for just exclusively emitting events for those properties that really need it or would really make your life simpler if you had them. But don't go to the other extreme and refuse to ever abstract around an object property. 

You need to ask yourself what are the requirements an entity must satisfy for it to be "targetable". Saying, "it must have the " isn't useful. You are really trying to answer, "what additional information and behavior is required for an entity to be considered targetable?" If all the information you need out of a targeting system is a back-reference to the owning entity from which you can access the position, maybe you're better off putting together a list of s for your targeting system. No really new information is being added, and the is just being used as a "marker component." That is, it exists solely to add a single bit of information to an entity: whether or not it is targetable. Marker components aren't inherently bad, but in most cases seeing them seems like a case of "to a hammer, everything looks like a nail." In this case, I would have some sort of flag/tag system (a [Flags] enum could work well for this, you can have 64 different flags if you type it as a long), and arrange it such that I could quickly query an area of the game world for objects for which the following is true: . If you need more than 64 tag/flag/whatevs, then that's what lists of tag IDs are for (they could just be hashes of the string name). I'm assuming you need much more than one bit of information for your though. Maybe you need to send events when an entity becomes targeted, need to know how many other entities are targeting this entity, and all sorts of stuff. In which case, don't feel guilty for using this pattern. Whether or not it's better to use marker components versus some sort of tagging depends completely on how you're planning to use it in your game. Do you want to dynamically check for the presence of on entities? How frequently are you doing that? If it's as frequent as every few frames, is that an expensive operation in your system (ie: Unity)? Are you pre-populating a list of targetable entities by scanning all entities at level load for those who have ? Or does itself maintain a static fast-access list? Bottom line: Keep doing what you're doing so you can make progress and better define your problem. If necessary, you can redesign this system later to better handle your requirements. 

You'll notice that IntermediateSerializer doesn't even bother specifying the type of or , presumably the Content XML importer knows what to do when it sees a collection. This is an XML file I generated using the IntermediateSerializer documented on Shawn Hargreaves' blog. The solution is split up into the Content project, and Engine project, a Game project and one Editor project. The only difference between Editor and Game is some #ifdefs that determine whether to export the current state of the scene as as an XML file, or to load an XML file from the Content project so I could see exactly how it was getting serialized and deserialized. Here's the stripped down game class to illustrate what I'm talking about: