At the same time you use a little compile trick with the to get the property name and based on this the actual query string name that will be the key of the dictionary that the class is derived from. It also overrides the method to generate the query string. Lastly you need a downloader to get the data: 

Don't you think that currently is not a very useful class?. You create an instance with a concrete model and all you can do is to repetedly call the method. Shouldn't the (or better ) require a model to add? What happens if you call it again with the same model? Is it still new? You can fix it by changing the method to require a model. At the same time you can remove the and put its content inside the method. You won't need to override this one any more. It calls the other methods in the right order allowing you to implement them and do something with the model along the way. 

If performance wasn't an issue you could nicely solve it with LINQ and the new anonymous tupels in C# 7. The first extension would give you the items backwards: 

And again an abbrevaited name. Does stand for result, resolution, rest or restaurant? You won't know this in a few days/weeks anymore. 

No, no, no, don't you dare! I guess you are the first person on Code Review asking for advice about how to better worsen the code ;-) 

or alternatively you can add a new event to the and handle it accordingly. You may also try to create a command for it like . 

Lastly don't do it like this at all. Create a single repository where you put all the queries you need and you're good. There's no need to create a repository for each entity type. I bet most of the APIs you'll never use anyway. Entity Framework is already a repository so creating a CRUD wrapper for all entities is just a waste of time and having repositories just for the sake of having implemented the CRUD repository pattern is pointless. This repository virus spreads like a disease infecting all projects. Everone thinks they need a repository but they don't. What they need is just a bunch of queries to get the job done. 

It will make the maintenace much easier as you can now adjust only one feature at a time witout affecting the others. I hope I have the logic correct after all the refactoring. 

Tests should be testing very specific things. This test however isn't doing that. I looks like it's not simply testing the event. If it was, then a single would be enough to tell whether the event fires or not. It seems to also test some conditions that might prevent it from firering. Such tests should be done separately because here it's not clear what conditions you are testing. 

and are the only operators I've implemented so far and I would like to hear your opinion about it before I fully dive into at and implement the other ones too. 

The old method can be splitted up into two methods. One will only calculate the cost und utilizes the new switch with filters. To get the right value you just need to check the upper bound and start with the lowest one. You don't need to specify the range. 

The . It's a collection and for collections we usually just use a plural noun. In this case just would be enough. 

The initial comment: not clear what is entering (deducting it's about byte ) and I would rather use "arguments" or "input" word. Not clear the description is about bits. Not all arguments are described (the code does use also address for ). Typos. Modified registers are incomplete too (again ). Etc.. 

Peter Cordes did leave you several review comments in the original SO question, so I will post the code-only here which is sort of adjusted by his advices (and my small modifications). Commands to compile: 

I had only some limited quick look, just cherry-picking some things to comment on: Entropy level: I'm not expert on this topic, but I think using time stamp as additional entropy source every time you produce a number is not a very good idea. But I'm even afraid you use it as only source of entropy in some cases, which is definitely wrong. I was unable to quickly show what's wrong about it, as you have weird way of updating, masking the problem out in your example. But after you change this I'm afraid it will become obvious this needs rather some "seeding", and building up upon seed data. About : You do great deal of pushing all around into it, yet only pops from it, and only once. So after running this for a while (using it as output stream, without calling RNG) the buffer will grow a lot, eventually running out of memory. If this one is supposed to be a buffer of pre-generated random numbers, then the should generate new buffer value only when buffer is empty, and then it should pop value from buffer and return it. But I would do something different, I would change buffer into single number, used as seed. At any point of your current source, where you end with buffer.push, you would instead use old value of buffer as input for the transformation (in some way), storing result back to buffer. Then will do yet another transform over it, and return the value. But at this moment the timestamp-every-call will start affecting the statistics of random numbers a lot for particular date-time and RNG calling period. So I would use timestamp only for initial seeding, then the RNG would work as any common pseudo-random arithmetic RNG, with added twist of output stream being further source of entropy. About output stream as entropy source: well, you should check the common output stream byte values first, they are not "random" bytes. From the code it looks like you are aware of that, trying to build an unsigned value ORing 4 shifted values, but the result is only 20b wide for ASCII, and the values are overlapping, so the upper bits of ASCII (not varying much) will affect the lower bits of next character (I hope I did read the source correctly, didn't debug it, BTW for better readability you should put these transformations from string to unsigned into some function, so you can test it on it's own). I would probably take only 3 bits (or maybe just alternating 2+3, to avoid ASCII specific values definition to affect the entropy of such value too much) of each output character, and cumulate them in 32b buffer till it's full (the overlapping 1-2 bits kept for next value), then use it for transforming the seed buffer (so roughly every 10 output chars the seed will get additional entropy). This may still go quite wrong with UTF-8 or unicode16/32 output stream variants, just imagine somebody using it with UTF-8 Arabic texts, having every second byte something like or what's the actual prefix (too lazy to check). About : 

There should be a way to exit (maybe if you don't type anything when it asks which dictionaries?) You should probably use instead of . You should probably use recursion instead of using then always ing or ing You don't need parentheses when returning tuples. Bare statements are for reraising exceptions. Otherwise, it gives you . Don't use bare . I would probably use a list of tuples instead of using . You could pass around the whole list instead of its length. You can use instead of . What does is create an iterable that when iterated, yields tuples of increasing numbers starting with 0 and the next item from the iterable (in your case a list) you are enumerating. More info at the Python Docs. You should handle the logic for in one place. Contained the logic for handling numerals within the function. You should probably name your main function instead of . Don't combine multiline strings and . It might be good to have it display the result directly in the console instead of the webbrowser, but that would be a whole other project. I might have made a few other minor changes. 

Point 2 should provide about double the speed; the others probably won't change the speed much, put should still probably be made. Result: 

Separation of the MVC components. It would be nice if the prompt for the difficulty was GUI-based and it was displayed after each reset. 

I would probably create the following methods (I have left undefined so I don't end up writing the whole thing; should do the check for the empty string): 

The game looks great! The code looks pretty good as well! I definitely agree with Gareth Rees about actually separating the parts of the MVC. What I changed 

I added type hints to all the functions. I fixed a few typos, as well as adding periods to the ends of the comments. I changed most of the initializer function calls to be functional-ish (changed from assigning within the function to returning the value from the function and doing the assignment within the initializer). I changed a lot of the loops to iterator 'math'. I extracted out the list of adjacent cells to its own function, as it was repeated a lot. I changed some of the data types from lists (or strings) to sets or tuples. I replaced tuple indexing with tuple unpacking. I attempted to reduce the repetition within the main function. Maybe a few other smaller things as well. 

The IO code is mixed with the logic code. I separated them. Also, I made a few other changes including removing useless comments (the code should speak for itself, your comments don't add much; if you need comments, that probably means you should simplify your code). I also converted the numbers as soon as they are input. 

Note: this ended up catching a typo instead of fixing what I said below: it was not meant to be executed immediately. Why do you need something that's effectively an IIFE? Can't you just use: 

Shouldn't the method be called ? / only needs to iterate over half the string: . (Make sure to test it, it might be ) You should use instead of for . There's no need to create a temporary variable in . would probably make more sense than . The whitespace seems off. Keep your indentation consistent (I'm using 4 spaces since that's what I prefer and it's hard to tell what you prefer [I actually prefer tabs, but spaces are strongly recommended on this site]). Stay consistent with your brace style. I personally prefer K&R/Egyptian/whatever braces (the style you use around the class), but it seems you prefer ANSI/Allman/whatever braces (the style you use everywhere else in this code), so I'll use that. 

As you can see, I removed the array ( not needed) and I use the know state after last to avoid . So this is certainly more efficient, but also harder to read and comprehend. 

I would refrain from using as general purpose register. This is limiting you in using / subroutines, and you risk memory corruption caused by interrupt happening in your program context. I would also refrain of such heavy LUT tables usage, as the program will be more likely limited by the I/O operations speed, so that tiny amount of calculation will quite likely hide in the buffered I/O waits. Here is my version, avoiding those things mentioned above: 

And the other three too (modify target register "edi" to "rdi"). And the instructions into glibc themselves require extra ELF setting to make the linking dynamic ("abusing" a bit directive "with regard" and special keyword ): 

You don't need to check size() for even/odd value, the integer division will work in your favour in this case, so 3/2 = 1. And random_access/bidirectional/forward iterators have overloaded operator, so you can add the result directly to . The would be helpful when you would use container which has only available (can increment, but only by single step). Then it can be still somewhat simplified to: 

I also modified the code to be PIC (position independent code). This is first time ever I tried that with assembly, so I'm not 100% sure I did+linked it correctly, but the code works, in debugger I see relative addressing, and stripped binary has only about 6kiB, so looks OK to me ... and now I tried to run it multiple times in debugger, and the code address is randomized, so the ASLR works too. And fixed some of your comments. And I test return value, so now the code upon invalid input will simply output the current sum, and the program can be terminated early by entering non-integer, or Ctrl+D. 

(I would also write as , but I think the compiler will optimize that one anyway, just old habits from ASM times die hard). 

I never did MIPS Assembly, so I decided to try on this simple one. I will comment on your code mostly from performance point of view (as smac89 covered simplicity/readability variant well). In your case I wouldn't be afraid so much of branching (and it's not trivial to lower amount of branches down), but about number of integer divisions () and also syscall outputting integers (hidden divisions). From the limited info I was able to found about real world MIPS architecture implementation it looks like for example PIC32 MIPS32 M4K Core does use about 1 cycle for 1 bit during divide operation, maybe with some early exit optimizations, so in worst case it's about ~32 cycles for 32b/32b divide. I tried to use MARS and it works OK, but I don't see any serious performance information except simple instruction counters, plus is not counted into the stats at all. So outputting integer is "for free", while in real world it would hurt so much that it would be probably better to keep just string representation of and increment it as string, avoiding binary integer (at least with my code it would work, as I don't do on it, so I don't need integer form of "number"). Anyway I didn't go that far, only reworked your loop to avoid divisions, and also to avoid pseudo instructions when possible, so the amount of real instructions generated is similar to the source code.