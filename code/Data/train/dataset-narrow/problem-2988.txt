You should easily be able to find an abundance of concrete examples, let me give you some that come to mind: 

When: As soon as you introduce one of those operators... On the "how" - I'd try to not beat around the bush, so to speak, but to point out straight away that only because we use the same symbol, they still have completely different meanings. 

For me, the most important part is teaching why we talk about "naming" at all. I won't go into what are good reasons since you demonstrated in your question that you already know that. Make sure your students know as well. You could, for example, concoct a few good and bad examples. For example, naming a variable is bad because...; naming something is bad because...; naming something is good because... Language X uses CamelCase-with-uppercase-first-letter to denotify constants. Why is it bad to use the same style for a variable name. And so on. I would not teach any one specific naming method because there are quite a few different ones, and some current languages tend to use either. For example, CamelCase and Upper-SNAKE_CASE in the Java world; and snake_case combined with CamelCase in the Ruby world. UPPER_CASE in SQL, and so on. I would want my students to know at least these variants, but make very sure that they know that those are just examples. I would accept if they write software using any convention, in a test, as long as they adhere to their own choice. There is a very easy guideline on which one to use: if they program in an existing environment (i.e., in existing source code), they must use the same convention that they already find in the code. If they create a new program they should use the generally accepted standard for that programming language (if there is one). They must take into consideration the standards of the business (or open source project, or...) they are working with. So this kind of flexibility is an important thing for you to teach as well. 

I would begin with practical, everyday topics which every student can relate to, and which are (should be) absolutely practically relevant in todays world from day #1 for every developer. Maybe based on current newspaper-level discussions. 

Real-world motivation I have a neutral opinion on visual programming. I have dabbled in it and decided that I am not interested. But. It is simply a tool. Tools are complicated to motivate. Just enter any room of programmers and give them the exercise to, once and for all, decide on whether vi or Emacs is better. You might as well ask them to choose the new Pope... On the other hand, in my opinion, an intelligent person (which your pupils certainly are!) does not need to actually be fond of or deeply knowledgeable of a tool to appreciate its merits. In the same vein as being able to learn about war and famine (which are decidedly not fun), they should be able to learn about Visual Programming even if you do not find a "fun" exercise for it. So, you can easily teach them that there is a place for almost every tool. Visual Programming has its place in certain niches (depending on viewpoint, obviously) where you just do not need the expressive power of a general programming language. For example, if you are into Business Process Management, you can achieve a lot with visual programming. If you are using one of the game engines which focus on higher level creation, the same is true. A program like Blender can go far with a very domain-specific visual "programming" for what it does (physics simulation and so on). CAD/CAM systems are largely "programmed" with very, very domain specific visual tools. Pick a few nice examples, and maybe you find some open source / free visual programming environments where they just play around, as a bonus. Even if they never touch them again, they will at least know that such things exist, and they may appreciate that somebody out there (who, likely, would never "program" anything at all, if they couldn't do it visually) puts them to good use. "Convince"? Try not to convince them. Show them what is real, what exists, and that in itself should be convincing enough. This might sound like nitpicking, but in the business world, if people start to try to "convince" someone of something, then it's usually a red flag. I prefer if they show me that something so I can understand and appreciate (or deny) it myself. 

To make them really understand what you can do with CSS alone - with only substituting another CSS file - take them to the CSS Zen Garden. With exactly the same HTML for each page, and only the .css file replaced, you get absurdly wild pages. From serene small nothingness to 3D-scrolling cubes... Then explain to them that the skillset needed to make the HTML, vs. the skillset for (especially extreme like those) CSS is vastly different, and that the HTML functions as the information carrier only. A further goodie would be to install a screen reader (for the blind) - there are ones with limited free use - to show them how the same HTML "looks" when spoken aloud. Also point out that those tools for the visually impaired are able to for example extract link texts and so on from the HTML if it is well structured, and this also makes it possible to navigate a page with keyboard only - which can be useful if one is so inclined, even if the eyesight is fine. Finally, point out that a page with good separation of content and styling has a higher chance to work on portable devices - the key word being responsive design, where the content can freely flow into any resolution as needed. 

Motivation I'm seeing a bit too many answers with "programming is not supposed to be fun", and I disagree strongly. OP wrote: 

Background: As a senior in my IT company, I am often teaching fresh colleagues on-the-job, so I know where you came from. On the other hand, as teamlead, getting people to work together (i.e., tough things like being able to ask questions and actually listen to answers...), is very important for me, as there's only so much of myself (in the first role) to go around. 

If your "CS" is the same as what "Dipl.-Informatiker (Univ.)" is in Germany, then, frankly, I expect nothing from a fresh graduate that is really related to the job, since I work in a real world IT company that consults other companies (the "real world" type consulting, i.e., try to understand and solve their problems, not the golf-related consulting) and first and foremost creates software on every level. I understand and experience day to day that the universities, at least in my country, do not see teaching that as their task (rightly so, it is called science for a reason). Now, don't get me wrong. I have studied those things myself (albeit before they changed the university system in my country - these days we have Master and Bachelor as well, and the university education is much more school-like than it was before). I, also, although I was very happy with my studies, learned almost nothing that I ever actually directly used in decades of work. What I brought to the table back then, and what is a huge bonus for current applicants, is private, real-world related effort. Be it programming in the context of an open source project, your own software, digging deeper into programming languages than the curriculum would need of you, having a Linux box or three in the cellar, playing around with your own VPN, programing Arduinos or Raspberry Pis, configuring a small enterprise-level NAS involving XFS or whatever. And yes, be prepared to answer in-depth questions have a fascinating discussion about each of those topics if you bring it up, because although your interviewer may look like Dilbert-like "pointy haired boss", he just might be doing all these activities at home right now... Of course, I also delight in just chatting about CS, so I might throw in a question about functional languages, lambda calculus, temporal logic or what have you, just to test the modern curriculum. ;) I need to see a real self-motivated interest in the topic. If I find that, I know that you will pick up whatever you need on the job. A successful CS degree helps, of course, but I might rather pick a mathematician with all those attributes than a CS student who gave me the impression that he did study and finish CS but has zero interest in the topic. 

It find it extremely important to teach them the principles behind those (or similar) data structures first, and I'd go so far as to pick any one of the more complex ones as well (0/1-trees or even B-Trees etc.), just for fun (maybe skipping some details, if time is an issue). I'd also stress some "outliers" like ones that have O(1) in some of their operations; or at least one that is good not only for fast random access, but also for storage on slow media. You did not tell us which kind of students you have (high school? University? CS or "Programming"? I'll assume CS at a beginner level.). But they will be able to find out how to use the API of their language of choice just by reading the reference documentation (or, alas, these days, more likely, some online "tutorial", which leaves away all but the barest syntactical information). The reference documents will also tell them a little bit about when to use which, but not quite in a way that compares all of the (theoretically possible) structures side-to-side. That's your job: show them what the world has to offer, and have them get a gut feeling for when to use which. There are several aspects: O-complexities of the operations (insert, delete, search, ...); space-usage aspects; aspects related to storage (i.e., is random access cheap or not?) and so on. I find it very important that you are able to teach them on a board or paper; i.e., draw boxes, draw lines and so on, so they really get an intuitive feeling about all of this. After that, the actual implementation of most structures and operations should be a snap; and using pre-made libraries even more so. Whatever you teach them in this way will stay valid and useful until the end of their lives. It gives a good foundation and reinforces structural thinking, branching out to the algorithms later working on those data structures. It's the same reason why one would rather teach a handful of abstract sort algorithms instead of the Java SDK functions for sorting. For me, a solid knowledge about data structures is one of the few parts of my CS education (which is a few decades gone) that stays with me until today, and has almost everyday applications in both software development, analysis, design, architectural work etc.; and I have certainly, in the past, implemented complicated data structures without having to resolve to libraries (when there were none in the language at hand) with confidence, having a sound background about these topics. I see no disadvantage with teaching how to implement those structures, whatsoever. I'd rather have someone teach only structures with not a single line of code; than a lot of code in a language or library which is likely obsolete in short time anyway, and no solid foundation for it. Have them find out how to use the API of their choice in their homework assignments; they should definitely be able to do that with any modern, well documented language (and if they are very young, give them a few handy pointers, like the names of the relevant packages/modules in the library or something like that).