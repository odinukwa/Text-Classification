You mix business logic with UI code. Normally, you'd go for separation of concerns and move the conversion functions into a separate class which is used by the UI, but does not belong to the UI. Running a separate thread: how long does the conversion take? 1 ms? 2? I really doubt that the overhead of thread-creation is necessary here. (Though it may indeed serve as an excercise!) Binary to ascii validation: if the amount of bits does not match, you overwrite the user input? Thus, if I, the user, make a little mistake, type 319 bits instead of 320, you actually force me to start over? /me pissed user :-) 

Then this is the actual code to run the functions, I think it should work outside of Maya. is how long forks are allowed to grow before ending, the rest is fairly self explanatory I think. 

For any Maya users, this doesn't include the animation or colours yet, but here's a class to build it in 3D. You only need to iterate through to use and , so if you have a different 3D software package it'd still be easily possible to display. 

It's been a while since I had a bit of fun getting something useless working, so I thought I might as well ask if there's anything to improve about how I do things. The original idea was to convert to a higher base for more efficient storage, before I realised I was hashing the value anyway so that would be pointless, and you can simply do to achieve the same effect. Anyway, I got it working for all bases from 2 to 221, with the option for higher if you can find any other characters to add. The padding was a bit of a headache, but I figured out the maths to get the maximum expected length, though it's only really useful if you were doing a database input with a set column length or something. It also works with seeds, so it could be used for something similar to hashids I guess. 

I am having trouble getting this to be more scalable. Adding a row/column would currently require adding another two lines to the code, so for a larger number (128 / 256 positions), this would become unmanageable. Also, for each added row, the print() function in draw_graph needs another line. If anybody has any suggestions on how to simplify the graph matrix or draw_graph / update_graph functions, or otherwise on how to improve the code, I'd love to hear. 

As is, if I import the module, I get a bunch of text printed to the console. This can have nasty side effects. It's best to assure that part of the code only runs when being run from the command line. Here's where a name guard comes in handy: 

Search method: Search needs to loop to topPointer, not to size. As topPointer is already smaller than a starting i = 0 for an empty stack, you can leave out the precheck for emptyness: 

OK, the data-structure looks a little wierd here, because your list consists of map-entries, but this was the main work. If you print this result, you already get (format added manually): 

And my personal thanks to you for posting something that is not "programming-challenge" on codereview :-) 

Process.waitFor will terminate the current thread until the process is terminated. Thus, at the place where you commented it out, it does not make any sense at all. You might consider putting a p.waitFor() after the loop, as to continue with your program only when the process has terminated. Apart from that, sorry to say so, your code is a mess. You use a very outdated method to start the process, you do not read stderr (which may lead to blocking conditions on stdout), code format is all over the place, p is declared outside the try block without any reason, exception handling is not present. To at least cover the basic necessities of reading both stdin and stderr, you should go for process builder and redirect stderr to stdout: 

I use Python 3, so I am unsure if all of these suggestions apply to Python 2. String module You can use the string module instead of manually typing a, b, c / A, B, C / 1, 2, 3 etc. Naming Your function should have a more descriptive name. As it is, looking at your code, I wouldn't understand what the name had to do with the actual code. Maybe . This goes for your other functions too: and especially are really bad names. "".join() You can make use of in , to clean up the code. Answer in [] Instead of , use . This is much more clean- Comments Some of your comments are, frankly, useless: , . Decoration Get rid of this: 

Disclaimer: this has not been typed in an IDE or compiled, but just done on the fly, thus it might include bugs. But the concept should be clear. 

Volatile won't do anything here, as this basically only affects the reference to the map, not the contents of the map. As for ConcurrentHashMap (as opposed to explicit synchronizing I suppose): this depends. If you want to make absolutely sure that no digest is ever computed twice, stick to your approach. If you just want general concurrency, but can accept that eventually in race-conditions, digest is called twice for the same input (sidenote: I suppose digest is deterministic, so that two calls with the same input yield the same result), you may simply repace the map with a ConcurrentHashMap and the whole method with: 

: What type the input is : How many bytes to look at for . Because this number will always be quite low, it's stored as a bunch of 0s, ending with a 1. : How long the data is : The input stuff As to why there is both and , for example, if the input has 255 bytes, the current way would result in 9 bits to say the length is 255, whereas having only 1 value would result in 255 bits to say the same thing. When reading the data, instead of splitting the string up, it just uses offsets on which part to read. I'm not so happy with writing it but didn't know a better way, as I just store it as a string and basically use or . The en/decode functions work with the string of binary numbers, and the and functions just get it to and from a human readable form. For the record, I'm planning on having something in , just haven't thought of what yet. Example: 

Furthermore, you can cut a bit of execution time by replacing the auto boxing and unboxing you do by using a mutable value class, something like this: 

Funny how nowbody seems to know the class... I agree with the previous answers, that try-with-resources is a good thing to do, but to perform the task in a real simple way, use : 

With this code, you filter your list over and over for each rule you encounter, which seems sub-optimal to say the least. I'd rather construct a single rule, which gets applied to the list once. Here, you can use the Predicate combination via "and" as this is basically what you do with chained filtering. Something along the lines of: