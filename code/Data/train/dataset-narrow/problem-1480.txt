Don't use fields like that, that one should be . It's good to restrict the visibility as much as possible. 

Wait, what's that!? is in the list!? It's our lucky day! We've found a matching ! So this will return . I will leave the fun part of implementing the code up to you :) I hope your understand this approach. As for the time complexity: Significantly faster than your current approach. As for the real time complexity, ask @rolfl. 

I'm sorry, but I have to ask: If you're not sure about exactly what the Set contains, why are you storing it in a set in the first place? Consider instead something like where can be a , a , or something else that can tell you what type it is. When adding items to this map you could use: 

If so, you don't need generics at all (as Karolina answered). However, in my example here it is the Node that has the important generics. It can be a node of Points or a node of Cards etc. And as a KDTree of Card-nodes should not work with a Point-nodes, the KDTree also have generics. However, a KDTree probably always uses some kind of nodes so there's no need to use the Node itself as a generic type, unless you want to be able to change the implementation itself. 

JavaDoc You comment some methods by adding a comment before the method, a better alternative would be JavaDoc. Entering and pressing enter in your IDE will probably create a JavaDoc block. Here's how JavaDoc looks like: 

palacsint's answer is good, but it's missing just a few things. All in-built Java collection classes I can think of has copy-constructors, and an method. So your method can be a one liner, when using a : 

Many of your methods and variables are self-explanatory, I think you are using an overly-excessive amount of comments. 

Do I even have to comment anything about what I think about this implementation? You use Objects.equals above, you can use here. It is preferred if and use the same fields for their operations. Set or List? Whenever you use a in a program, ask yourself the question: Does the order of the elements matter? In this case, they don't. Use the interface and create as for your variable. 

Where the implementation of those methods could either be or , if you add such private fields that you initialize after you've read the config file. Testability, Dependency Injection Why is this even a singleton? It's good that you have a method that takes a so that you can use different configs, but your code leaves some things to be desired. 

This will provide the possibility to have multiple problems in the same class, which IMO provides a nice overview of the problems: 

Additionally, instead of a I would use a static factory method. Here's how to use it as an static factory method, although I hope you will take my other advice as well about extracting an interface etc: 

What I did was to skip the declaration of a local variable and process the string (by calling ) directly when adding it to it's destination. 

enum improvements I would use a constructor for your enum to make things more consise. I would also use the instead, which works directly with the primitive type. Additionally, you might as well make your method public and your map private. Applying these changes will make your enum look like this: 

I would not JButton. It is better to use composition/encapsulation and store a inside the class. Right now you can call plenty of methods from outside the class that is totally irrelevant to the itself. Just check the many inherited methods that a JButton has! 

Variable names What on earth is ? What type is it? It seems to be one variable used for all kinds of things. I'd recommend making these separate variables and using more descriptive variable names. Result This will clean up your code a bit at least, to this point: 

Many of your methods are both returning and modifying the array. This feels strange to me. It can be more preferable to create a copy of the list and sort it in a specific way and return that. 

Preferably, to avoid double-negation, you should use instead of However, there's no way of having to do a method call to (or a similar method call) on your line. 

It depends I personally find a method that returns it more flexible and more of a separation-of-concerns approach. And by doing so, you could even move the method into another class, such as a class that perhaps can provide you with other monster arrays. However, it is perfectly reasonable to use a method that returns if: 

Play my game! Having the name that I do (Simon), of course I have to participate in this challenge! (Even though I am a bit "late", but Simon says "have forgiveness!") This is an implementation of the Simon Says challenge using libGDX. I started using this framework a couple of months ago, and I love the fact that it can create games for Desktop, Android, iOS and HTML5, at once. As it is libGDX, and Android support is needed, I'm limited to Java 6. As I'm also using GWT, there's some restriction there as well. Class Summary I have not included the several different launchers here, as I am just using the defaults that comes with a LibGDX project there. 

That is a really bad name for that class. Here you have to write the fully qualified class name because of Android's class, which is not something you'd want often. Moreover, I don't really see the purpose of that class at all. It is just a wrapper for a , and an unnecessary one. This part can be changed: 

My approach I wanted to make the game flexible and general. It should not be necessary to change much to create a "normal" Rock-Paper-Scissors implementation. It should also be possible to add elements such as Water balloon if you'd like. Technically, it should also be possible without too much effort to modify the elements at runtime (this is currently not supported in the below implementation, but there's not many changes needed to make it a reality). Players. All players have a score that gets increased when they win. A player should have a method to return which item the player chooses, this implementation can vary (a human can write input, an AI can return something random, some other AIs should perhaps always choose SPOCK...) Code Because I am lazy, I have put all the classes/interfaces in the same file. Of course, all of them could be placed in their own files as . The code is stand-alone, just copy it and paste it to your favorite IDE (Eclipse) and run it as a JUnit test case. 

Adding to the things Max wrote, to make sure that you don't make the same mistakes again I wanted to point out several things regarding your current code: 

That all really depends on one thing and one thing only: How costly is the operation? Secondly... OK then, maybe two things: How often do you plan on calling this method? If the operation is cheap, I would use the return directly version. If the operation is costly, use the approach with the variable. Additionally, if this is a multi-threaded environment - or rather, when this possibly becomes a multi-threaded environment - the first approach goes out the window unless you synchronize on some lock (which will add some additional overhead). The first approach as it looks today is not thread safe at all. 

There is one big section of code duplication in your code. The cases for and are almost identical. There are a couple of solutions to solve this, one of them is to put them at the same label and use an for the small part that is different: 

According to a PHP blog post, yes this is exactly the way that it should be done. Even w3schools (whom you normally shouldn't trust too much since they're not related to the real w3 at all) recommends it. I like that you are using instead of . I am not so sure if you really need the though. I recommend you read the documentation of the include function (which also applies to require, require_once and include_once) to make sure that you really are aware of how it works. Note that if you are using any PHP scripts inside the included files, any global variables (which you should try avoid using too many of overall) also gets included to the calling script. 

Now, imagine that you hade your if-else switched so that you wanted to check for non-existing user first: 

Yes, there is a more elegant way of doing this. (That's all you wanted to know, isn't it?) First of all, here's some general comments about your code: 

Approach You are looping through the array multiple times and cutting until there are no more elements to cut. This makes your code have worst-case complexity \$O(n^2)\$ (if all elements would be unique, you would loop \$n\$ times over \$n\$ elements, so \$n^2\$). It is possible to reduce this to \$O(n * log(n))\$ by sorting the array first, and then looping through it. For example: 

The idea is to replicate the same way Factorio show signals in the circuit network. The code works by determining a prefix, which simply is a potential minus sign. It then determines the middle part (the numbers and potential comma separator to use) and the suffix (the letter at the end). The code seems to work perfectly fine and now I simply wonder: Can I improve this code somehow? 

However, simply writing this would be so much simpler, and a whole lot easier to read: (Especially for people who are used to reading HTML) 

I would actually, not care much about the right aligning there. This is just my opinion though, I am not aware of any conventions regarding this. If you like it then feel free to continue doing so (for now at least). Inconsistent Spacing. Compare 

Then create a Create some implementations of (possibly one for each action, or some actions might be possible to group together). 

After reading the problem description and before reading your code, I implemented something that was very similar to what you already have, which means that your approach to the problem is perfectly fine. Spliterator - of unknown size Instead of using 

I'm not quite sure why you left that variable name unfini I'd recommend naming it . Cutting the last two characters helps no one. 

Excellent little interface there, I'm just afraid that with this naming you'll end up with ten interfaces named . Naming it would be better. 

Overall, very nicely done. I'd recommend you to implement the things, and then get back for another review. 

A possibly faster, and at least more compact version than using a is to use a good old integer array. A can actually be typecasted to an , which gives it's ASCII code value. 

Generics I'm not so sure that the generics of the class does you any good. It's used in a anyway so I don't see that the type safety of generics gives you anything. Consider removing the generics and use a inside it instead, and have the method return an . Of course it'd be neat if it was possible to avoid the auto-boxing that Java does on primitive values, but I expect that would require some code duplication, and I'm not sure if the potential performance gain you could get out of it is worth the code to add it. (I bet you can answer that better than I can, but you have taught me that auto-boxing does affect the performance a bit)