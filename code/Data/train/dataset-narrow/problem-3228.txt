If the command is not found, . However, ideally you should use LXDE's mechanism (presuming LXDE really is your desktop environment), if you can find it, since this will make it easier to keep permanent. 

In the later case, don't use ; instead, use . If the network is encrypted but you can configure the router, you might try turning WPA off temporarily (i.e., leave the network open) and try the same thing with . If none of these seems to be the issue, try . This will take a few seconds and will spit a list of all ESSIDs in the area -- obviously this should include yours. 

There's no difference on the application level between ethernet and wifi, so yes, if you can do it one way, you can do it the other. 

I'm going to connect the dots and assume since you could not do the initial set-up with the Pi running, you did this by editing the folder on the second partition somewhere. If so, then that won't work; is a mount point for the first partition when the system is running. You want to put that file in the first partition on the card, which is small (~60 MB) and contains a (V-) FAT32 filesystem with a dozen or so files and a single folder (). OR You created a folder on the first partition and put it in there. If so just move the file one level up and remove the folder you created. 

You need to understand how unix modes and permissions, used on POSIX operating systems such as GNU/Linux and OSX work, otherwise your life is going to be full of awkward problems like this. There are already lots and lots of introductions online, I will not bother regurgitating them. However, I'll give an example of applying the concepts in this case. First, you need to know some id numbers for your current user: 

You can [as of Sept/2015, you probably should], but read the caveats below first. First add the line as above above to , then: 

Since you've said the drive has DNLA functionality, and there are various DNLA servers and clients available for GNU/Linux (including Raspbian), the simple solution is to set up a DNLA client on the pi. 

Ground in a DC circuit refers to either an actual earth ground (i.e., 0 volts vs. anything) or a common ground for different components that may be working at pretty much any voltage relative to it. I think what you would really want to be concerned with on the Pi is the amperage, if the "common ground" to the Pi is the primary ground for whatever you are connecting -- but it is hard to imagine how an arrangement like that is possible without intending to do so and jumping through hoops to accomplish it. My point here is if you wanted to fry the Pi that way you probably could, but only if you actually wanted to (by shorting a high amperage supply to ground through it). Anyway, a common ground between between circuits running at different voltages is fine (and necessary, if there is any other connection between them). This doesn't automatically make every circuit using it safe, it just means that using a common ground doesn't by definition make it unsafe. 

Since this is a fresh image, the long and the short of it is basically you did not write it correctly to the card. Since the first (boot) parition is VFAT, you should be able to look at it in any computer. If not, this is another clue that the card is messed up. 

Here's the code. To see this in action, place both files in the same directory, set executable (), and run (also note the different extentions, and ). You'll have to use ctrl-c to exit and there's no clean-up, so the directories will still exist in . You can restart it without closing those, however. test.pl 

You could not use the Pi kernel (which includes all the hardware drivers), but that is not a big deal since Raspbian is only tied to it in superficial ways. Presuming you can compile or get a kernel for the Fire (which a quick look around implies might be possible; the Kindle OS is a version of Android and so uses a Linux kernel, the problem would be getting the proprietary bits), the Raspbian userland might then work, since the fire is ARMv7 based. However, there would not be much point in trying, since once you got to this point there is likely some more appropriate, near identical GNU/Liux distro. If the general meaning of the above two paragraphs isn't clear to you, I strongly recommend you do not try this. 

I installed and ran . This replaced a lot of files in , and, I noticed, installed a lot of modules for a 3.10.24+ kernel, which I wasn't aware existed (my git clone of the archive was fixed on 3.6.11, and that's the latest one I had on the pi). So I built 3.10.24+ (the current stable for the pi) using from my 3.6.11 kernel -- i.e., I did not change the configuration at all. This potentially overwrote the stuff in installed by , so I ran that again (first removing to make it do everything over). Unfortunately, the modules from rpi-update did not jibe ("disagrees about version of symbol module_layout"). I couldn't resolve that,1 so I went back to my vanilla modules directory from the build. Rebooting at this point solved the problem. It is worth noting that it persists with the old kernel, so it was not simply a matter of the firmware in ; also I rebooted after the firmware revision, before building the new kernel. However, the rpi-update README does note "some firmware updates might depend on a kernel update" (although AFAICT, rpi-update doesn't provide a kernel update!). To summarize: 

Again, that's , not . And very important: that file should contain one line. No more. It can be quite long and you should add that to the end separated from the previous parameters by a space. There are some other possibilities here but try that one first. 

They don't need to be unique, no. I.e., you can clone the card and change or not change them afterward as you like. It is normal to use the same public key on multiple devices to save the hassle of keeping one for each. As for the sshd server private key, this is not really a big deal unless it is open to the internet beyond your LAN and you are worried about people cracking into one device then the other. However, the best protection against that is to prevent it from happening -- if they did it to one, simply having a different key probably won't stop them from using whatever technique they used a second time (which likely has nothing to do with the server keys). An exception to that would be a static IP if you have one hardcoded and intend to plug in both pis on the network at the same time. Note also the ethernet MAC address will be different, although this should not have any consequences. 

I don't have a thorough answer as I have not done any benchmarking or deep investigation of such, but the only thing that could be significant here is the difference between something compiled for ARMv6 (e.g., Raspbian), something compiled for ARMv7 (various distros targeting the 2/3 including Ubuntu variants), and something targeting 64-bit ARMv8 (Pi 3 only; there is nothing pi specific here, but there are distros you could adapt to it). I run an ARMv7 distro on the 2/3 and TBH I do not think that amounts to much if any difference performance wise. The version of ARMv6 implemented on the single core models, for which Raspbian is compiled, is actually very close to v7. Further, the fact that the Raspberry Pi Foundation did their benchmarks on the 2 and 3 using Raspbian implies that they did not see a huge advantage in using anything else (I do not have a direct reference for that but it is implicit in the material on their site). A quick search regarding "aarch64" distro benchmarks on the Pi 3 at first seems to offer a modest advantage, although if you look closely at that page you'll notice the tests weren't done on a Pi 3, they were done on a Cortex based Juno board -- something to watch out for if you do your own research. At this point, if someone had demonstrated aarch64 made much difference on the Pi 3, I think that information would be easy to find, so the silence implies it does not. 

To . Remember that that file should only be one line, the various parameters are just separated by spaces. This is effective at boot. 

However, the warning from perl about locale is not necessarily the reason you are failing authentication. 

Those instructions target the OS, Raspbian, and not any particular pi model. So if you are using Raspbian, they should be fine. If you have a screen and keyboard attached, you don't have to do the thing with when you compile, just leave it running. That's this part: 

If you don't understand what that is about, find out. Also, change the shebang at the top to . It's probably just . This doesn't make much difference beyond allowing for a lazy style of output redirection (the line below). Then add: 

This may take some time, as a quick search implies to me that even the non-wifi version is still hard to get -- some distributors are currently out of stock, and most or all of them will limit you to buying one per order. Meaning you would have to pay shipping separately for each pi. 

The is tacked on to indicate this isn't from a vanilla source tree, and that it was compiled specifically for the Pi 2. 

This is probably not worthwhile. Think of it like your smartphone; I have never seen one with fans on. And your smartphone probably has more heat generating potential. People do add fans to the Pi though, and there are other people around that will happily sell you a little 5V one if the Pi all by itself is too quiet for your tastes. The Pi 3 is the only model with serious potential to overheat when not overclocked. You can tell by touching the SoC, if it is accessible; it should be noticeably warm but not uncomfortable for your skin. You can also check with . Idling, it should be 40-45 C. When it is busy, it may get into the sixties. If you notice it getting to 75 C or more, try a heat sink before you bother with air. Air without heatsinks is not very effective at cooling small dense chips. 

The best thing to do is to search online for the make and model and "linux", e.g., "acme x42 webcam linux". You want to look for things that people report as working out of the box, microphone included, and do not require the installation of an additional driver. At this point in time, since there is a generic USB class interface for such devices implemented in the kernel, most things should be okay, but some odd things (such as "an old webcam playstation eye"), or cameras with special features that require OEM software, will not. The problem with OEM software/drivers is that even if they have a linux version, it is most likely only available pre-compiled for x86(-64) and will not work on the Pi hardware. Even if the source is available, if it is something that has not been incorporated into the vanilla kernel tree, it will not be available pre-build for the Pi, and compiling modules for the Pi is not something I recommend unless you have investigated the process and feel comfortable doing it. I.e., do not buy something thinking this will be an simple formality to deal with. There is always the possibility that a particular driver that is available in the vanilla tree is still not pre-compiled for the Pi. However, again, most plain jane, reasonably new devices of this sort should use a generic USB video and audio class interface, meaning a driver unique to the particular make/model is not necessary. If you find something and do a little searching that indicates it will probably work, feel free to ask specifically here about it and I or someone else can attempt to verify this. Of course, it is probably not possible to say for certain unless someone with that device can confirm it. If possible, I recommend you buy from a nearby brick and mortar store that will take a return within a short time period, no questions asked (or if you simply say that it did not work for your purposes).