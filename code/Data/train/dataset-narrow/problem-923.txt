With this you do not need to call , either. Assuming you added the parameter you should add in my interface critique (let's call the new parameter ), you could make sure you don't write more than this size with something like: 

The benefit to this kind of style is that you can add any type of allocation you want (in between the other stuff, before it, after it, whatever), and you just need to add a quick line or two in the cleanup block, and suddenly, all success and failure paths get the resources freed. If any of the intermediate steps fail and you wind up in the cleanup block, you can be assured that you're not leaking anything, and it won't feel repetitive to make that happen. There are other variants of this, for example if you or someone you're working with has some religious objection to (even though it's the cleanest way to do error handling in plain C), on the slightly more repetitive side you could repeatedly check to see that you're still succeeding: 

Have you given thought to more of an in-place approach? Here's a quick example (I took one shortcut by taking , which means an extra string traversal): 

It could be that at 100 connections you won't notice, but you should be aware that the 1-thread-per-connection model does not scale well and is not in line with the current state of the art. See what is written about the c10k problem. With a thread-per-connection approach you will have high memory overhead from each thread's stack, and you will spend a lot of time context switching. What scalable network code does these days is: 

What if is not big enough to hold file size? For example if were 32-bits, and the file were greater than 2GB. The type of is which is likely to be at least 64 bits in sane platform. 

These integer operations can overflow. Maybe that's not a huge deal (I'll admit, I myself write a lot of code that doesn't handle overflow), but something to be aware of, should you be allocating sizes around the boundaries of the type of the size variables. 

This problem screams "semaphore". Have a semaphore whose count represents the number of slots available in the queue. Enqueuers decrement the semaphore. Dequeuers increment it. This effectively caps the amount of nodes in the queue to some maximum, namely the initial value of the semaphore. Likewise you can have a different semaphore represent the number of items currently enqueued. In this case dequeuers decrement it and enqueuers increment. For this one, the initial value is zero. This allows dequeuers to block until an item is available. 

In this particular case the assignment to is a no-op, since 's value came from . However, I would argue that doing something inside every block (like your assignments to ) get tedious to maintain. One style would be to not have early statements, and do the assignments you want at the end. You can still check for errors, just don't heave repeated s, example: 

You should be aware that you're re-writing functionality present in the standard library. This is all right if you're learning, and I would encourage you to continue to do so (it's a great way to learn), but here are a few thoughts from this angle: - this is basically . - this is what does. (Note the extra r in there means "search in reverse") - you can use as a boolean expression. (If the result is non-NULL then it has that character.) - it seems a bit redundant to call before . You can use the result of to determine both that there is a space (result is non-NULL) and where the last space is (using the result as a pointer). As a style point I would argue that it would be more "C-like" to talk in terms of pointer arithmetic rather than offsets. (i.e. Take the result of , do something with that pointer, rather than thinking in terms of "give me the offset of the next space".) 

OK, that's a really goofy-looking example... But here you see that these blocks inside are really composable. In between each of them you can add and remove more operations that can potentially fail, and your cleanup block handles releasing resources in event of either success or failure. If you're working in C++ this would be done via RAII wrappers, i.e. in destructors of classes and possibly with or an early . But C has no such features to make that easy and correct... Moving on to other code: 

However I'm not sure if this will work right if you do it on memory mapped from a file by . Keeping this kind of atomicity in a page fault handler seems complex and I'm not sure if the standard guarantees that it should work. 

This is a common portability pitfall. A cannot represent the full range of characters and also . Depending on the environment you may not be able to distinguish between and byte 255, or you may not be able to detect at all. Store the result of in an , because that's what it returns. 

Check for errors in , , , and , to name a few. If the exec fails in the child you should call . Do you really want the in ? This is not guaranteed to be the same as the you just -ed. If is your will look for a file at and it will likely find the program in . I would use and either do that lookup yourself or simply omit that part and require the user to specify a full path for something in (eg. instead of just ). The + observe state + thing is a race condition. Another process can change the attributes on the file in that timing window. This may or may not be important to you. Given that this is a security-ish program I would say it may very well be. Instead of returning 0, you might want to return the child process's exit code (which you can get with .) You might also want to return nonzero when the functions I mention in #1 fail. This way a shell script or something calling you programmatically can determine success or failure. 

When programming for Windows, you should almost never want to use the ""/"ANSI" versions of functions. This is legacy from Win9x and you should be using Unicode. Windows is not like Unix where the C library can assume UTF-8 and everything can keep chugging along with the full set of Unicode chars accesible: by restricting yourself to the "multi-byte" encodings you will (1) see inconsistent behavior depending on what the user sets their language to and (2) not be able to access some Unicode filenames that the user may have on their filesystem. You should define the and macros and use instead of 8-bit chars. (Since it seems you want to use the C++ classes I believe works instead of here.) Second: The class looks weird to me. Not all Windows APIs use - some of them may return or do something else. From that perspective you have not captured the full generality of Windows errors. I would also say, perhaps controversially since this is not the path everybody has taken, that wrapping Win32 errors with exceptions is a bad idea. There are some Win32 errors that are not error conditions at all, for example will fail with when you reach the end of a directory, or I/O will fail with to indicate that the I/O is happening asynchronously. A Win32 program will occasionally have to react to such errors and I would say the way you've done it loses some of that information, or makes it less convenient to work with. But maybe it's OK for your use. YMMV. 

From a memory perspective I wouldn't worry. A few extra machine words in your class is unlikely to make a difference, and allocators out there tend to pad upwards anyway. From an OO perspective, you can always make a subclass to add the field. 

You don't have to write . You can just write . Or you can just write . This is a style thing though, different people make different choices. 

The question is whether or not it's safe to call while another thread does . According to Microsoft's documentation it is safe: 

Don't bother casting a to another pointer type. This is a C++ thing. In C you don't have to do it, the conversion can be done implicitly. 

If is , which I'd expect most callers to do, the library uses its own default implementation, . , with some exceptions for ancient MS-DOS compilers and so long as is greater than 1, ends up calling . by definition zeroes out its data. So, I'd say it's safe under the following conditions: 

Error handling in C looks very ugly when done poorly, but if there is a general approach to coding style it can work elegantly.. The trick I like to use is to make your failure paths mostly the same as your success cases. This typically means that there's a part of each function that does "cleanup" - deallocates everything you've allocated, releases whatever's been acquired, etc. Kind of like the RAII pattern in C++ where your locally-declared quantities will do their cleanup in a destructor. This would get run regardless of success or failure. If some allocation or resource acquisition outlives the function, then make the success case be the special case, because this will ultimately allow you to make more fluid code modifications vis-a-vis complex error handling. In case I'm writing too abstractly, an example of this would be: 

You need to observe the return value here too. It returns the number of bytes read, or on end of file, or on error. 

I think the suggestion in the link you mention is to not bother with making your object files "intermediate". I tend to agree. If deletes the object files after the link step then it has to re-build them all at the next invocation of . Without this, the next time you , it can look at the dependencies of the object files (as specified by the makefile, the part after the ) and only rebuild them if the stated dependencies have a later timestamp. You might also want a target to remove the objects via , so that you can delete them when you really want to. But the typical workflow for using is to keep your object files around for extended periods and type when you want to build what you've changed. 

You might want to consider working line-at-a-time rather than pixel-at-a-time. Looking at the documentation this would mean calling and rather than /. Each call to either of these functions must convert the coordinates you specify to an offset into the buffer (eg. ), and if you do this for every pixel in a large image these multiplications can add up. So something like... 

This seems to work for your ASCII art test data with ... No idea how it performs with large quantities of data [though bit shifting and AND is cheap, right?], but it's a lot simpler than what you have. I got this approach from the way some FAT drivers handle FAT12 (treat it like FAT16 with 16-bit dereferences, but truncate the extra fuzz). Update: Looking at this again, my original code didn't handle some edge cases, such as ... So I switched to 32-bit quantities rather than 16.