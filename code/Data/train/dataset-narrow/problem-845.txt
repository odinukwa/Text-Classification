Is there any way to refactor out the repetitive and parameters, and the call to ? There are two obstacles to refactoring I can think of: 

It's MVC so the Actions are the first port of call - it may not be possible to have a refactored method that is called before the Action. The GetSignature() method is called using all of the Action's parameters, so it may be difficult to refactor. 

I want to keep things DRY, so I'm trying to figure out: Is it possible to remove repetitive parameters and code from ASP.NET MVC Controller actions? eg given these Actions: 

TL;DR; Don't calculate the possible moves every single time. You've overlooked a key concept: the potential moves for a knight on f1 are the same regardless of what move number it is. It doesn't matter if it is move one (the N is on f1 because it hasn't moved yet) or if it is move 199 (the other N has wandered all over the board and ended up at f1). If you calculate the potential moves every single time you consider a move, then you are wasting a significant amount of time - it will always return the same value. And then your chess engine will be very very slow. The solution is to precalculate the potential moves before the games starts, and then for every move you take the precalculated potential moves and subtract the moves that are not possible based on the actual position. You still need the function, and to make the improvements others have suggested, but you need to pass in the piece as well. Source: I have written a chess program. 

this I don't think you need to use the keyword in front of everything. Namespace - Utilities is not a good name space, nor is or or anything else vague. These are namespaces that scream "hey, put any old class in here, I don't care!" would be much better. Dependency Injection Instead of creating a you can have it automatically created for you by dependency injection. But that's a subject for another day :) 

Modifiers You don't have any modifier in front of any of your class declarations, which by default makes them internal. If you meant to make them internal, that's fine, but at least write , so its clear that you didn't do it by accident. If it is an accident then decide on a modifier and add it. is usually a good choice. If you are implementing an interface, make the interface public and the implementation internal or protected. Then it is only accessible by using the interface. Naming does not actually check if value is a valid price format. Format implies that it is a string used to format the display of something. Your function actually checks if the value is a valid decimal >= 0. A name of would be more correct. If you were actually intending to check that the price is in a valid format ( string does say to the user that it has to have a comma eg "10,00"), then your method is not implemented correctly, since a value of "10" or "10.00" would also pass the is valid test. only validates the price, so it should really be named Handling validation The way you handle validation is a bit unusual with the repeated check for and the repeated handling of the validation. Try refactoring the duplicate code out. 

So I am using a for-comprehension over the tweetsfile to each line in the file to its corresponding number. So my question is, how would you rewrite the above the maximise speed and minimise memory usage. Any other comments on the Python would be welcome too. I realise that I can use a single-producer -> multiple-consumer pattern to speed up the processing of the file, but I would for now like to stick with a single thread. 

Scope It is generally good practice to scope variables in the minimum possible scope. I don't like this: 

Set everything to as you don't know if anything is a composite. This isn't really required as in Java is by default. Starting with to , if , loop over for while in increments of and set . You now have an where anything that is () is a prime. 

Using Caliper this method has a runtime of around for . I have done a few experiments with speeding up the code. For example, using the Prime number theorem we know that there are approximately prime numbers between and . Using this information we can create the used for storing the primes to almost the right size: 

Others have covered bad practices here, I am just going to demonstrate a Java 8 solution to the problem - as Java 8 is the current version of Java; I believe this is what should be written in modern Java: 

This way they are outside of the running code and clearly constants. Similarly should (almost) always by an instance or class variable as having more than one is (almost) never useful. Use for outputting formatted messages: 

it's recursive - Java doesn't handle tail optimisation and recursion is slow It makes a rather large number of copies - copies the underlying it's very long 

As runs in a separate , we need to consider visibility and atomicity of any variables used to communicate. So an seems the natural choice: 

I'm happy with this code - it's pretty clear and I'm not worried about its speed and memory usage as the file is small. Using the created I now need to process many tweets. Lets say I have 1GB of then in JSON format - from the live stream. What I need to do is: 

Are horrible! If you need to label a variable declaration with what that variable is, you have picked the wrong name. Further, if you are going to use inline comments, avoid the case where the comment makes the line so long that it's illegible. 

But (and this is a big one for style) you should only use one type. You have got one type in some places and the other type in other places. Set a preferred style in your IDE and stick to it. Also, if using Egyptian brackets (the first style) please leave a space between the statement and the opening bracket. Comments Comments like this: 

So we check whether the game is over after reading a new value from the user. In the winning condition we call which interrupts the clock thread and causes it to exit. 

I would also suggest that you always use brackets for your statements. It's generally accepted common practice and with good reason - the few lines that you save by not doing so lead to some very insidious bugs. On an algorithmic note: why reverse the at all? Use one loop and read the both forwards and backwards simultaneously. For further improvement, walk through a comparison manually: 

Reading the tests, I do not really see how a single slot is to be used. I only see how multiple slots inside a page are used. Also, I only see tests for several GET methods. If I want to verify that the results that are coming out are correct, I somehow have to read the config fixture file - a secondary source of information. This situation actually is bad. I want to be able to read the tests, and actually CHANGE some input values in a certain test method to see whether or not it changes the output and breaks the test. If I cannot see the input, I cannot play with the values. One final improvement: If you include files, they can actually return a value. You do not need to define a global variable that will transfer the config values. 

You are doomed! Basically you try to allow an attacker to define which code should be executed, and you try to find out if you are smarter in detecting malicious code than him injecting and hiding it. The "EXEC" mode is completely insecure, we need not discuss this. But I doubt the blacklist mode is of good use either. I feel it to be insecure as well, but I cannot prove it in 5 minutes. For example, I can try to read any file on the webserver by calling . I can try to overwrite any file by using . I could install my multipurpose script this way that is called a second later, and you get owned. In the end, only the whitelist mode seems reasonably secure, but this is just a generalized form of AJAX RPC calling - and a very dumb one, because it is limited to single PHP functions, you cannot do anything more sophisticated. And if you really think about it: There are already plenty of working solutions to allow Ajax calls to do more useful stuff within one single call. Some of them are called "restful webservice". 

Your classes do too much different stuff Your classes do not implement proper dependency injection. But if they do, they have very weird dependencies that will fit a certain use case, but not all. 

(we started with the 50 USD object from above, the conversion rate is completely arbitrary). What have we got now? We can add amounts of the same currency. We can convert an amount into a different currency. We can also add amounts in different currencies via wrapping them into a converter first. That's pretty much all currency stuff should do. Now how do you get this nice converter? It is simply a call to a class that generates it for you. This class should only deal with generating the proper conversion object when asked to provide one for conversion from currency A to B. To fulfill this, it needs access to a resource of knowledge, but this resource could be anything. For example, a HTTP client. But the client cannot be universal, it has to be customized for the web service you are using. So in reality you need to create something like a factory that is able to make a request for converting currencies to a certain web service. This call triggers a basic HTTP request with some parameters. Caching should be done as decorator pattern as well. Decorating an HTTP call with a cache means that in the decorator you see if there is a matching entry in the cache that is still valid (might expire to fetch new updates), if not, it forwards the function call to the real client. I apologize for not going into details for these tasks at this moment. I hope you got the idea of how to split up responsibilities between classes from the currency conversion example. 

Essentially we take each and we it that gives us a . I then you the method to append all present instances to a . If the `StringBuilder is empty simply append the current integer too. An alternative, not sure if it's better, is: 

This leads to fewer string concatenation problems and is easier to read. Here is where the problems really start: 

Iterators Kudos for correctly using an to from a while iterating. But, as described above, this is not the correct approach to implementing a Sieve. Programming to the I don't link this method declaration: 

So whilst I have a lot of tweet data, I only need a list of integers. This is obviously much smaller. I want to be able to stream the data from the file and convert each line to its sentiment value in the most efficient way possible. Here's what I came up with: 

never create a in a loop, and always close resources. never write this is ugly and error prone ( also compiles). you only need to check once; after reading user input. 

I don't like this. I think if you are going to down the route of using then use it for all references that won't change, that includes: 

Firstly because of the scope of and also because loop indicies should be incremented inside a declaration unless you have a good reason not to. I would prefer the following construct as it show that I have two variables used in the loop, that the termination condition is and that I increment every iteration. 

Here we do the to get the , we then out and to a . We then use the (often overlooked) to first the resulting and then to return if the joined is empty. The main work now becomes as simple as: 

I have some code that calculates the "sentiment" of a Tweet. The task starts with an AFINN file, that is a tab-separated list of around 2500 key-value pairs. I read this into a using the following function: 

And yet you continue with your program knowing that it cannot possibly work. Either throw an exception (which will be reported to the user, and be ugly) or simply to exit and terminate the program: 

So now you can easily add new "transformations" to the list. In order to transform an to the correct in Scala we would simple use as is also a collection. No such luck in Java. I came up with this thing, it's a little ugly but I think it's clear: 

This should reduce the amount of time the spends resizing itself. This reduces the runtime by about for - so has little effect. These sort of micro-optimisations should always be tested using benchmarks to see if the additional code complexity warrants their addition. A few comments on the code: Use of You use sometimes to delimit references that won't change: 

The other comments cover the code quite well, I have a few points to add. First, obviously this is a critical error: 

You're close to a sieve, but you're missing some points. First and foremost your is incorrect - this should step though the range in steps of ; this very fact precludes the use of a . The usual approach uses a , on which you carry out the following steps: 

read a tweet file, with a JSON tweet on each line parse each tweet to a using extract the field from the tweet - giving the content of the tweet for each word in the content, check it if has a sentiment for each sentiment word in the tweet, calculate it's value (from the AFINN ) and sum across the tweet store that number