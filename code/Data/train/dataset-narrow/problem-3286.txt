At a PWM frequency of a nominal 10 Hz I'm not surprised you can hear clicks. You will be switching the fan on and off 10 times a second. Experiment with frequencies in the range 100 to 1000 Hz. 

There is no delay between pulseOff() and the pulseOn(). It might be clearer if you write it without the . 

Use jumper wires between the I2C device and the Pi or solder in place. I2C needs a stable connection. 

The first thing to check is the permissions you have to access /dev/i2c-1 ls -l /dev/i2c-1 Typically access is allowed to the root and i2c group. If you are not a member of the i2c group try sudo adduser your-user-name i2c You will need to logout and login for the group change to take affect. 

The Raspberry Pi 2 has a 2.2 amp polyfuse which limits the power which may be supplied via the microUSB socket. This is more than enough to power the Pi and the USB sockets. Initially the USB sockets can only draw 600 mA. At worst this leaves 1.6 amps for the Pi2 and anything connected to the gpios. By changing a setting after boot software can configure the USB sockets to draw up to 1.2 amps. At worst this leaves 1 amp for the Pi2 and anything connected to the gpios. You haven't mentioned connecting anything to the gpios or the USB. The only meaning to the rainbow square in the top right of the screen is that the 5V line has dropped beneath 4.65V. If you trust the power supply to be accurate the other cause of low voltage is thin wires in the microUSB cable. 

From the description it seems likely that the white pulse wire is an open collector output. In other words it floats to an external voltage and is pulled down to zero at each pulse. Instead of 

Perhaps look at $URL$ Kernel patching/building requires self learning including the ability to use a web search and interpret the results. 

Many ways. You can sort of bit bang the slave selects, i.e. connect all the devices with shared MISO/MOSI/SCLK and ground but separate CS. Just set CS low for the device you want before calling the SPI driver. The SPI driver will try to set an CS but won't know it is not connected. The Pis with the 40 pin expansion header have another SPI device with 3 chip selects. My pigpio library supports that device. You can software bit bang the whole protocol. You can add additional hardware to switch the CS line to any device you want. Etc., etc. EDITED TO ADD The "proper" Raspberry Pi Linux SPI driver is currently going through review to allow arbitrary gpios to be used as CS. EDITED TO ADD 2 The current Linux SPI driver (spi_bcm2853) is said to support arbitrary GPIO as chip selects. See /boot/overlays/README. 

Put it where you want, it really doesn't matter. A lot of people would use a sub-directory under their home directory. It may be simpler to download the master.zip file for the git and copy that to the Pi. It will be simpler to unzip on the Pi rather than unzipping on the PC and then copying the directory structure to the Pi. 

The code assumes that the echo signal cannot go high then back low between the GPIO.output(TRIG, False) and the while GPIO.input(ECHO) == 0: line. That assumption is wrong. The target may be very close or the script may be rescheduled at that point. 

I guess the question is why does it segfault. I guess it's because you are not using the library as it is intended to be used (as far as I am aware). Change 

I think you may be running up against an inherent problem with SMBus commands, they are not great at talking to I2C devices. I suggest you try reading the device with my pigpio library. If you have a recent Raspbian this may be preinstalled or available from the repositories. To check try 

It would be helpful if you link to the spec of the device rather than relying on people to search for you. The device requires two bytes. Try to read the product id. The result (23 or 0x17) should be in . If that is not reliable you are going to have to drop the speed to accommodate the 50 Âµs delay between bytes. 

RPi.GPIO uses software timing for PWM (Pulse Width Modulation). It is not suitable for servos. You have several choices 

You can check how much RAM your Pi should have by checking the board revision. The board revision can be found by examining the /proc/cpuinfo file on the Pi. E.g. on my B+ 

As far as I am aware the only Python modules which have a cleanup function are RPi.GPIO and RPIO.GPIO. The others expect you to tidy up when you terminate. None of the C libraries that I am aware off have an equivalent. If you want to change the mode or level of a GPIO when your program terminates you have to explicitly do so yourself. 

Have a quick look through breadboards. The problem appears to be having the LEDs leads and resistor all connected in rank 23. All the 5 holes of each rank are connected together (but not to the same numbered rank on the other side of the board). A solution is to move the non ground lead of the resistor and the cathode lead of the LED into rank 15 which is the only unused rank on your breadboard. 

The SPI driver (spi-bcm2708_dma.c) appears to be written for the earlier model Pis. The Pi2 model uses a different base address for the peripherals. I didn't look at how the driver is using DMA but there have also been changes in this area. I'm not sure if the DMA changes affect kernel modules. I haven't looked through the rest of the code. You'll at least need to find a version of spi-bcm2708_dma.c tailored for the Pi2. 

For general device tree help see . In future make sure you are using an up to date tutorial as things change quite quickly on the Pi. 

One of the good points about Python is that you can use it interactively. From a command prompt type python. Then try out the commands. 

Aternatively my pigpio library supports I2C from the command line usings pigs, see the i2c* commands, e.g. i2co. 

I'm only interested in the first of your 5 questions. Probably all 5 have been answered multiple times. You need to identify the GPIO requirements for each sensor and attempt to resolve each clash. For example, you mention RFID reader, Hall effect sensor, GPS, and some push buttons. 

I copied pigs and pigpiod from the Pi 2 B to the B+ and the executables appeared to run ok. Read into that what you can. 

The fault you refer to is in the software. It can't handle the timing required. Try my $URL$ There seems to be an actual fault with the DHT22 - it stops responding after a random time. The only solution I know of is a restart - see my $URL$ 

You won't be able to use the microUSB to interrogate the voltage as only the power lines are connected at the Pi end. The data lines are not connected. Your best bet would be too identify the manufacturer of your power bank and google to find out if it provides a management interface (unlikely I'd say). If it has, and it has another USB output, you could interrogate the pack by plugging the other cable into a spare Pi USB socket. 

The only questionable item is the soil moisture detector. It may have an analogue output which is not readable directly by the Pi. All the Pi's gpios are digital. 

See page 102 of the Broadcom spec reference above. There are various ways of setting a GPIO mode. My pigs utility uses the M command. E.g. pigs m 18 5 will set GPIO18 to mode ALT5. 

With difficulty. Those FFC/FPC cables aren't used with the hobbyist in mind. I suppose if you are an expert wirh a soldering iron you could attempt to solder jumper leads to the contacts. Otherwise try googling for FFC/FPC to jumper leads. 

I used to use I haven't tried recently so I'll assume that no longer works as you have tried using it. Perhaps try in 

No. You will need to put an ammeter in line with the power supply feed to measure the current flowing in to the Pi. 

The operation of the clocks is described from page 105 of the peripherals document. That explains the registers. More example code at Minimal clock access. EDITED TO ADD More info about PWM/PCM clocks at clocks addendum Another useful source is the eLinux errata 

EDITED TO ADD To the best of my knowledge, based on Adafruit information, the 3V3/1V8 converter (as I think used on A+, B+, Pi2B, Pi3B) can supply up to 1 amp shared between the 3V3 and 1V8 (internal) rails. 

You need to connect the grounds. In this case there is no connection between the Pi ground and the battery and servo grounds. Connect a wire between the battery ground (or servo ground, which is the same thing) and a Pi ground pin. This gives a circuit to allow the control signal to flow. 

You can connect as many as you have spare gpios, so potentially 26 on the 40 pin expansion header Pis. There is a variant which claims to use the I2C bus (it has a designation of something like AM2321). You could potentially connect a hundred of those. However I2C is a short distance bus (50 cm say) so your multiple sites will have to be close together. Also I have seen doubts raised about how well the device implements I2C. All the Pis gpios are 3V3. For any distance you should be powering the devices from 5V and using a suitable divider to feed 3V3 to the Pis gpios. You can feed multiple devices from one 3V3 or 5V pin (port in your terms). Please remember the Pi expansion header has many pins, not all are connected to gpios. You connect the output of a DHT22 to an individual gpio. You power the DHT22 from the 3V3 or 5V power rails and the ground (0V) rail. 

If you go route 3 I would solder all the connections and glue or otherwise mechanically attach the components to a rigid base (to minimise stresses caused by flexing). 

There will (or there certainly should) be a simple method to switch a GPIO on and off. The LED method probably comes with additional baggage to set PWM on the GPIO and blink etc. Have a look at OutputDevice. 

You just need suitable resistors and a transistor to interface it to a Pi. I power mine from the Pi's 5V rail and switch it using a GPIO. I used a NPN BC548 transistor. The LED is driven from the 5V line. As I had no details on the IR LED I assumed it had a forward voltage of 1.7V and that it could handle 100 mA. If my calculations are correct I'm feeding it with about 70 mA. You can find plenty of schematics on-line. Anyhow, it works. LIRC should handle everything else, i.e. sending the pulses with the correct carrier wave modulation.