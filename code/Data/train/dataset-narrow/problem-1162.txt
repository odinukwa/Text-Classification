I am creating user profile logic for a blogging platform. I have the model and then two separate models, and to control the user's various social media contacts (i.e. Facebook, Twitter, Google+, etc...). I am looking for feed back on the execution of the methods used to new . Is this the way you would handle it? Is there a better way? What are some of the issues you see with my methods (specifically in the service class)? The Models 

Feedback #6: You have no error handling around your request, but on an app this simplistic that may be by design. 

I am writing an application that either mirrors a file/directory into another location or creates a zip file "snap shot" of a file or directory and stores it in another location. The user is able to create "rules" where they define the source file/directory, the destination file/directory and if they are archiving how many archives to keep. The user is also able to exclude files/directories if they so choose. Now this service class is a lot of code and I am wondering if there is a better way to do this. Of course all of the methods that can be called by the interface are called with a BackgroundWorker.RunAsync() method. Any feed back on how to make this more efficient would be super appreciated. 

The idea being that if a record changes the log table would indicate all the fields that changed with their new values but leave fields that didn't change for the record null. In order for this to work I need to grab a copy of what the record looked like in the most recent log version vs the current source version (the problem being that some of the values in the most recent log will be null) In order to accomplish that I am using the current query inside my stored procedure: 

Ah, the age old pragmatism vs. purism. While it sounds like you have a healthy amount of skepticism, I think this is actually one of the few instances where it's OK to use a global variable. The core of your problem is you need to share data (state) between two routes. A global variable is the simplest way of doing this if all you're doing is appending the number 4 each time. Here's some things to consider: 

As far as I know, Meteor's reactivity is one-way: changes in data are reflected in the DOM. To go the other way (DOM to data) there's two common methods: 1) grabbing data directly from the DOM when it's needed (i.e. to save it) as you've done above and 2) binding DOM elements to data models, and using the data models for CRUD operations. 1 is simpler to implement, but 2 gives you more control over data-flow, subscriptions, and life-cycles. 2 has plenty of great libraries you can use, so you don't have to reinvent the wheel just to leverage these benefits. Backbone.js is probably the most well known plain-JavaScript library for this sort of thing (also check out Lo-Dash and Exoskeleton if you haven't), but the Meteor ecosystem may have a preferred library for this. 

$this->get('feed_parser') is just a fancy way of getting a SimplePie object from the PIMPLE container - you could just instantiate a SimplePie object yourself (if you want code you can't test). After running this code, $item would be a PHP array (or some collection class) containing the details of one image. In my case, I then exposed this as JSON and a REST API endpoint for use by JavaScript, but you could just as easily have PHP output the appropriate HTML. 

Feedback #1: Angular can actually build the select for you without the repeat via the ng-options attribute directive: 

The stored procedure requires you to pass it the log table, the source table and the primary key that ties the two tables together (usually the source PK). And is a temp table created before this is executed in the stored procedure that simply stores column names that match between the source table and the log table (not all fields from the source are being logged). Now this code behaves as intended, the problem is the query takes about 10-20min to complete (just this part of the stored procedure). The heaviest query this is used on is looking at 48 fields in a table that only stores 300K records. There has got to be a way I can make this query faster. 

I have one entity that depends on another however in my API service class I would like to just deal with the dependent entity. Am I doing this correctly and is there a better way to go about this? Post Entity 

I have a service class called , the service class is called using an interface . The service class simply does CRUD methods for the in my context class. In my service class constructor I have: 

Can someone please show me the light. I would preferably like to be able to update singular elements within the class without destroying and rewriting the file every time I have to update it. 

Feedback #2: Angular provides a filter for formatting numbers, $number, so no need to write your own. Feedback #3: Use proper camelCase for function names (i.e. instead of ). As well as don't mix your snake_case and camelCase. Use snake_case for CONSTANTS (of which you have none) (i.e. instead of ). Feedback #4: Remove unused properties. You never set nor call , so get rid of it. Feedback #5: You're making a request without having all of your . If I change the value of the first select, but haven't changed the value of the second you are firing the promise each time. This can easily be fixed with a simple statement: 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting. 

This will make sure that sure only one $db is ever created. Here's the source code from Pimple's method for demonstration purposes: 

I ended up using the decorator pattern. The report view and each graph object now implement a method. When the report view's is called, it iterates over each graph, calling the graph's . The latter method receives the report view as a parameter, and this provides access to convenience methods for creating/retrieving DOM elements for the graph to attach itself to. New report view: 

Likely, just has a single default state, but if you ever want to construct this object yourself, you should consider return-/exporting the definition from your module, rather than returning an instance of it. A simple solution here is to simply return the result of . Use a template. In the future, you can use additional templates to support other platforms. e.g. start with a desktop template, later on create a mobile template, and choose the template dynamically at runtime based on the environment. 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

People do this sort of thing all the time in the JavaScript (this.arguments) and Python world (*args); however, by removing type constraints from the parameter list, you have to be wary that you're always providing the types of parameters your function is expecting. If one of your parameters is supposed to be a string, and someone passes in an object, bad things may happen. Conversely, some very respectable projects use multi-line parameter lists. It's fine to have a lot of parameters, as long as they're all necessary, but it's always good to be skeptical. Long parameter lists is a good code smell – if you see them, the code may need refactoring, but not always. As far as the attributes of Box's, forget about programming for a second. Conceptually, what are the properties of a box? Can a box still be a box without a color, tileW, tileH, walkable, speedY, and speedX? Can a box still be a box if it doesn't know how to draw itself? If your answer is no to all of these, then your code is fine, and requiring parameters as a single collection/object vs. individual parameters is (arguably) a matter of preference. That being said, I would move the three lines to a separate method . It's best to only do construction in the constructor, and leave the rest – like rendering – to other methods.