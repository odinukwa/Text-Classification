When you start a new game project, what do you do first? How do you begin? What gives you the best head start toward completing the project rather than burning out before it gets anywhere? Mods please help with the tags... I have no clue how to categorize this... :) 

If you have the money, invest in yourself: buy a drawing tablet. Personally, I am a terrible artist, I just can't make good graphics, but it sure didn't help that I was stuck trying to do things with my mouse, sloppily drawing lines or clicking pixel-by-pixel. I can at least roughly sketch something that works, and my Wacom Intuos4 is amazing for that (but surely overkill if you ask a professional). The Wacom Bamboo tablets are "entry-level" consumer models with slightly less accuracy, but they start at $69 (Wacom store; you want one with a pen, not the $49 touch model) and would be just great. So if you are able to somewhat draw things by hand, try getting a tablet - it won't improve your art skills unless you work at it but it can at least make it easier for you to make crappy programmer art. :) 

You can find the video memory of an Nvidia card using the NVX_gpu_memory_info extension, or an ATI card using ATI_meminfo. Here is a snippet of code I found which might get you started. 

The "famous" Amit (with the giant page of various game programming topics) has a game programming blog, and he just completed a 3-part tutorial of an interesting method of map generation. I really enjoyed the reads, and there's a working demo in the bottom of the third article which is pretty stellar. "Polygon map generation" part 1, part 2, part 3. This may be a technique that you want to adapt to your needs! At the very least, he mentions the algorithms he uses at each step of the process: he starts by generation Voronoi polygons, relaxes them to a more even distribution using Lloyd relaxation, uses "a simple function to divide the world into land and water", and then flood fills to determine oceans and lakes. It sounds like you can stop there, or read on for mountains and valleys and turning it into 3D and so on. 

Take the relative intersection and divide it by half the paddle height. Now our -5 to 5 number is a decimal from -1 to 1; it's normalized. Then multiply it by the maximum angle by which you want the ball to bounce. I set it to 5*Pi/12 radians (75 degrees). 

What means do you use to get your game dev book fix? Do you pony up the big bucks for the thick books, or do you budget yourself and buy one at a time, or do you rent or limit yourself only to your library? Do you prefer to read them on your eBook reader? How do you obtain your game development books? 

You'll want to search for tutorials on "terrain", which is the technical term for a 3D map. Also "heightmap" might return results. Here is one possibility (notice the "Contents" section on the right bottomish): $URL$ 

RuneScape Classic: two brothers (Paul and Andrew Gower) and a couple years. Very inspiring, if nothing else; of course, nowadays the current RuneScape game is managed by a large staff of which I could not find a number. 

You're thinking ahead of yourself, trying to implement everything before you actually use it. You don't even know what your Sprite class needs to do! Why are you writing it then? Classes are meant to serve a purpose. You don't write them ahead of time; you write them as you need them. Start by actually starting on your game. You'll reach a point where you need to use a Sprite class. So then make it (or use it as it currently is). When you run into something which needs to be in the Sprite class, add it. But stop what you're doing, don't try and write a do-everything Sprite class because you'll just end up with a bunch of unused features that waste your time and probably aren't tested or implemented right. For example, right now. That entire class is unimplemented. There's no point to it until there is something using it, and once you start using it, it will be clear exactly what you need and don't need. 

You would be much better off using Canvas. Neither of them are supported in IE, and canvas is known to be a viable web-based game technology; plus it has decent rendering speed, especially in Chrome (and apparently also in IE9, according to the early demos; I haven't tried it recently). If you need to target older versions of IE and/or mobile platforms, stick to plain old DOM, which doesn't have very good performance but it's still acceptable for simple games (e.g. Pacman). 

If you are going to be implementing the idea then they will have the most questions about staying on schedule; involving things like estimates of development time and of milestones or prototypes, test plans and the equipment (test devices) you'll need to develop the app, and other technical resources you might need (if you need to purchase any development software or libraries). Also you might be fielding some questions regarding staff members; for example, do you think you can develop the app yourself or will you need to hire some team members for graphics, programming, testing, etc. If they are smart they will also be looking to the future; how will you ensure the app can run on future Android devices or even take advantage of new features that are yet to come? And how much maintenance will the app require? How often will it update? (updates are a great thing, they help remind users that the app is installed and I think they might bump your app to the top of the new list in the Market, though I'm not sure). 

Keep in mind the differences between game development (the all-inclusive process of making a game), game programming (writing the code that makes a game happen), and game design (designing the game: plot, characters, mechanics, etc.). You seem to be using them interchangeably. But it appears you are looking for iPhone Game development/programming, not game design. The major book at the moment appears to be Beginning iPhone Games Development. There is also iPhone Game Development: Developing 2D & 3D games in Objective-C which has a wide range of reviews, good and bad; I'd give it a second thought before purchasing. The problem is, if you're looking into iPhone development, Objective-C is your only language option as far as I know, and development for the iPhone is considerably different than PC development. I think in this case you'd do best to try one of these two books, rather than starting with a PC game development book. 

You're right, that whoever is contractually established as the owner, is the owner. I get the feeling that you want the rights to the project. If that's the case, then be aggressive! In the end you need to come to an agreement with them, but if your hope is to keep the rights to the game and you feel it is a fair stance (or even if you don't), then state it from the beginning so that you can start negotiations to come to an agreement. Maybe they're okay with that; after all, if they are in desperate need of a project and yours is perfect for the situation, they may be willing to forgo the rights to sell the product in exchange for exclusive rights to develop it, for example. Most likely you'll need to meet them in the middle, though. I'd say just set up your formal meet, and meet with them. Discuss it, and come to an agreement that you're happy with. And then get it all in writing. As usual... IANAL (I Am Not A Lawyer)... 

I'm pretty sure it is most often done in a proprietary (binary) format, just writing each variable from whatever game state struct you use into a file, or reading that file back into an instance of the struct. In C++ for example you can treat an object like an array of bytes and just fwrite() it into a file, or fread() from the file and cast it back into its object form. If you are using Java or another language you can opt to use serialization to make the task really easy. The Java explanation is at the bottom of this answer; other languages (higher-level than C++) surely have their own serialization libraries or built-in functions as well, which you should opt to use. No matter how inefficient the serialization routine might be, hard drive space nowadays is cheap, especially when the game state shouldn't be very large at all, and it prevents you from writing and maintaining your own serialization routines. You should absolutely not use MySQL (just read the first sentence of this review). If you really need a relational database for some reason, use SQLite; it is a lightweight database system and exists in a single database file. But for most games, relational databases are not the way to go, and companies which try to use them usually end up using them as a key-value lookup table rather than a true relational database. Any sort of encryption of local disk files is only obfuscation; any hacker will just sniff the data right after your program decrypts it. I'm personally against that sort of thing, ESPECIALLY with one-player games. My view is that the owners of the game (paying customers, mind you) should be allowed to hack at the game if they want to. In some cases it can create a greater sense of community, and "mods" can be developed for your game which drive more customers to you. The most recent example that comes to mind is the Portal in Minecraft mod that was recently released. It's published in gamer news sites all over the internet, and you can bet it drove up sales of Minecraft. 

Finally, calculate new ball velocities, using simple trigonometry. This might not quite be the effect you're going for, or you might want to also determine a speed by multiplying the normalized relative intersection by a max speed; this would make the ball go faster if it hits near the edge of a paddle, or slower if it hits near the center. 

If you need an active connection and literally real-time gameplay, then go with WebSockets, or a similar technique like Comet. Note that WebSockets requires a recent browser, while Comet is probably good enough for most purposes with better support for older browsers. For example, Facebook and Google use Comet for their technologies (Facebook Chat, Google Docs, Gmail, etc.). If you don't need this, then you can choose plain HTTP. It's probably easier to develop, but you lose the real-time nature of a constant connection. In this case, "turn based game" is not enough information. A turn based game like Draw Something is only going to have a few turns per day in an average game, so you could probably do just fine with plain HTTP, polling occasionally. A turn based game like chess, you'd probably want to have a little less latency, so I'd probably choose Comet. For some sort of action turn-based game, you might want the real-time nature of WebSockets.