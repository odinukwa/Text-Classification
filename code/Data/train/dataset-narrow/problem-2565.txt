The standard library function invokes the host operating system's command processing facility. For Windows this is essentially the console you get when running which lets you run DOS-like commands such as to clear the screen. Other than the function's existence, everything about is platform-specific. If you're using Xcode, you're using a Mac, which means you have Terminal.app or similar, which will use some shell (bash, by default). is the program for most *nix environments to clear the screen. However, when running the program under Xcode's debugger, the environment variable isn't set and the program won't know what to do. So it won't clear anything, even though the program would if you ran it directly from the terminal. All the program does, generally, is either print a bunch of newlines or print a bunch of ANSI escape codes to manipulate the cursor and write over the console output buffer. You could do the same; the newlines in particular would be easy enough. As for your second question: Most games don't use terminals for their main interface and so have no need to clear the terminal. Even games that do, like Nethack, use libraries like to interact with lower-level terminal APIs and "draw" to the terminal. If that's what you're going for you should investigate those sorts of third-party libraries. Most games use the underlying OS APIs to create windows and draw into those using platform-appropriate APIs. 

If you pretend a pixel is a square (see A Pixel is Not a Little Square), then the center of that square is the pixel coordinate. This is documented in Direct3D 9's rasterization rules (emphasis mine): 

A simple implementation of the replacement might be along the lines of for example (to remove all characters). To implement the specifics of your request, you'll probably want regular expressions. 

Move the simulation of the wave height to the CPU. Depending on which works better for you and your logic/performance needs, you can move the entire simulation to the CPU and simply send the computed coordinates to the GPU (avoiding duplicate work) or you can do a simpler approximation of the computation on the CPU. 

One (of many potential) ways to handle spawning on some condition is to check for that condition during the periodic update and spawn creatures as needed. Of course, you can't just check for the condition directly (for example, doing in the update loop would spawn a new enemy every frame that the score is still 1, which probably isn't what you want). Instead, consider storing information about what you need to do during the update. If your game object had an integer field for , you could do something like: 

Those three different vectors can be used to perform three different cube map lookups, which can be mixed together similar to how the colors were mixed in the simple example: 

Don't write a demo for an interview if you can avoid it; submit existing code or projects if you can. Demos and code samples are important for a lot of reasons (which vary by reviewer), but mostly they are about showing potential employers the kind of code you write in the wild and the kind of problems you are interested in solving. They also help demonstrate your level of interest in the craft of software development. It's much better to submit some code you've already written for a previous project or game you've written that you are proud of, or that demonstrates a clever solution to a problem -- anything that is interesting or difficult or that can serve as the basis for a good discussion. Writing code explicitly to submit as sample code tends to come across as contrived and fake; it can be surprisingly easy to tell, for example, that a programmer thought that a potential employer would want to see "well documented" code and thus put really detailed comments on everything, striving for what they believe to be perfection. Real code isn't perfect, it has warts and rough edges, and when you write code explicitly for demo submission you tend to polish it so much that it becomes obvious you didn't write this because you loved the writing of it. You just wanted a job. That said, if you don't have any work you can submit -- either because you haven't written any yet or because your previous job prevents you from submitting any of the code (under NDA) -- you don't have a lot of options but to write something new. In that scenario I would encourage you to focus on writing the thing for its own sake, and forget about what employers "want." Write a game because you want to write a game. Write a cool tech demo because you want to explore that tech, because that's what you are interested in. 

If you are using the effect interface, you'll need to obtain a to your world matrix variable (for example, by calling on the effect. You can then either convert your matrix to a and use the matrix-setting call or leave the value in its raw form and call the raw value setter. Note that to do the latter you'll need to extend your array anyway, to include the missing elements, otherwise they may be unspecified values. If you're not using the effect framework, convert your matrix to a use the method on your device using as the matrix type. 

Then you can register the binding between strings keys and delegate functions at game startup, or somewhere -- somewhere higher-level than the component factory, so you no longer need to modify it when you add new components. For example, if a running instance of your game was represented by the class, you might register all your components during startup: 

Maybe. Fundamentally I think you're asking the wrong question and possibly for the wrong reasons. The skill you want here is not the skill of understanding a particular engine, but the skill to be able to understand any particular API -- in other words, the ability to take a look at code or technology that isn't your own and start developing familiarity with it. Especially when you start as an entry-level developer in the industry, you'll be doing that more often than not. I would generally say not to bother trying to learn an "engine" and just keep doing what you've been doing -- working on projects and releasing them on your own time. In my opinion as an engineering lead in the industry that's far more valuable than somebody who can tell me all the API calls you need to make to get an Unreal game working (I can read documentation and I expect you to be able to as well). It is still useful to work those parts of your brain that are used to understand other people's code though, so along those lines pick an engine you are interested in (perhaps you like the games built with it) and start learning that, or find an interesting open-source project and think about contributing to it. 

Use a (single dimension) array. You can treat such an array as "2D" for the purposes of accessing tiles with some simple math: 

You mention this "text file" that you save the state into after every change; that seems unnecessary. Unless your levels are massive you should keep the entire state in-memory at all times, and share it with the renderer. Disk is one of the slowest forms of memory so having to hit it twice per frame on average is undesirable. Since your game is running in a P2P context there is no central authority to validate the moves or resolve races (two players clicking the same tile at the "same time"). To help alleviate this, especially if your game is real-time and not turn-based, you can synchronize each player to a known good clock when the game starts, and have players transmit the timestamp on that clock with each move, which can be used to resolve races. This can also be done with a sequencing number, or consider an approach where every client gets a vote on the correct state of the game and that majority vote wins (this is sometimes useful in cheat detection as well). Note that you may need to buffer some moves in memory on all clients to account for the possibility that other clients can "replace" locally-made moves.