You wrote a generic constexpr function, but the only thing you ever use it for is , which can already be written in constexpr form as . Use the simpler form, both for clarity and to reduce your compile times. If you were going to keep , it should have gone in your namespace anyway, to avoid cluttering the global namespace. 

You're missing a space after ; and you don't need the test anyway, because is already guaranteed to do the right thing. Simply write 

Modulo some missing constructors, I think the above 26 lines of code addresses all the constraints of the Gilded Rose problem. However, this system is unable to express the concept of a "legendary backstage pass", nor of "legendary cheese". In Java, you might solve that problem by making an adjective that wraps a noun; for example, 

Syntax nit: missing semicolon after . This is legal of course, but I think many linters will flag it as an inconsistency. Why do you do this thing with instead of just saying ? I might be exposing my own lack of knowledge here, but I thought was supposed to do the right thing in "member" functions called with the syntax. Is your use of actually working around a problem with , or is it just an idiosyncrasy that could be cleaned up? 

Again I may be exposing my own lack of knowledge, but I'm about 75% sure that cannot possibly throw an exception. What case are you worried about here? 

Your question is, can we somehow remove the requirement that be a named variable in this code? Well, the short answer is "no"; 's constructor takes a Container by non-const lvalue reference, and so we have to have a non-const lvalue for it to refer to. What's more, in order to keep from being a dangling reference, we need the referenced Container to live at least as long as itself. Otherwise, we could get away with something like 

I may be biased, but I think some excellent advice for anyone trying to program in C is "Learn C++, and then write C++ in C." This immediately leads to a lot of minor improvements in your code... 

At this point, if either thread C1 or C2 is still waiting, it's a bug in the standard library. They should both be awake and waiting their turns to grab the mutex lock and process one item each off of the queue. Similarly, the at the end of should not be needed, because if you've got two threads waiting on , you might as well wait for the second before you unblock the second producer thread. So: 

Notice also the replacement of with ; the optimizer will likely generate the same code either way, but without the optimizer's help, making the name of the array itself instead of the name of a pointer to the array will remove one level of pointer dereferencing. 

This won't change the codegen, but it might be worth doing if it helps with the "localization of concerns": If is useful only to , then it doesn't necessarily make sense for it to be visible to the entire program. 

This is harmless (in this context) but unnecessary, so you should remove it. In general, if you grep your codebase for the phrase , you should find zero instances of it. The one legitimate exceptional case I've ever seen in real code is 

Taking the latter approach (two values by return) and applying all our rules except "no raw and ", we end up with this: 

Now there's only one tree lookup! If you have benchmarks for your trie code, you should see a ~3x speedup from just this one little refactor. 

Anyway, I'd say you should learn about and and so on, before trying to invent your own string-handling library. Start with the tools that are provided to you and get good with them, first. 

which never hits and so your inner loop (the loop) never terminates. In this particular case, you can fix the infinite loop by checking for instead of , so that the inner loop will stop on overflow-to-negative as well as on reduction-to-1. However, this will not solve the general problem that can overflow to a positive number; and it won't remove the undefined behavior that results on signed integer overflow. (Which is to say, the compiler is allowed by the language standard to assume that overflow never happens, which means that if overflow does happen anyway, all bets are off. It's your job as a programmer to make sure overflow can't happen.) So what you need to do is check for overflow before doing the multiplication, like this: 

One reason you think you require a lot of helper metafunctions is that you haven't clearly separated the code for solving the problem (filtering a list) from the code for testing the solution (e.g. and , , ). Your actual solving the problem code, with redundant comments and newlines removed, boils down to this: 

Now if we change the string in from to , we'll get a compiler error. But we've still got two instances of the magic number separated by a fair number of lines of code. Let's inline this helper so that we're malloc'ing and memcpy'ing in the same place: 

Real code wouldn't contain this kind of hard-coded string comparison, unless it was written by someone trying to end up on The Daily WTF. If you were really writing an inventory system, you'd try to make it general enough to handle any kind of item, because, well, that's the point of an inventory system. Otherwise all you've got is a handful of nested statements. In general, beware of "Test Driven Development"; as you can see, it's led you into a bad place. Just because you wrote some code that passes your tests doesn't mean that you've written good code. 

You're all correct except for that last sentence. Yes, a hashtable would be better than this code. But practically anything would be better than this code! This code itself is so bad (big-O-wise) that it's just not a plausible motivation for anything. Not to mention, what use is a dictionary that can only store words of length k? Surely what the user really wants is a dictionary whose keys are strings of arbitrary length. Your array-based implementation can never provide that functionality. As it happens, about 12 years ago I needed a dictionary that could store words of (up to) length k, where k=9, because I was doing a lot of crossword construction. The data structure that I used was a very simple one: an array! 

Next, a style/safety note: For metaprogramming, you don't need to provide full definitions (i.e. class bodies) for your types; a declaration is usually all you need. Furthermore, providing just the declarations will prevent the user from accidentally trying to define variables of those types. So, for example, you should write 

Notice that we will only ever use this function with integer-literal and arguments, so the is testing a compile-time-known value and will be optimized away by the compiler. On the other hand, neither Clang nor GCC seems smart enough to figure out that the math in the "else" branch is equivalent to the math in the "if" branch; so by providing the optimized "if" branch explicitly, we're helping Clang and GCC save a couple of instructions. Here's the "x" rotation: 

I'm not sure what you're asking here. Obviously the first version is fine; obviously the second version is pretty silly (because it does the same thing as the first version but in a more confusing and verbose way). As for "using indexing", doesn't the first version also use indexing? What do you think is, if not "indexing"? It sure seems like you've got the hang of "indexing" well enough. :) 

The "cookie" parameter can be used to pass data from the caller, through the generic algorithm , into the comparison function. In this instance we're using the cookie to pass the user's original function pointer through to be used by . But the user could just as well use on their data array directly, with no indirection through s. 

from inside the inner loop to outside it. There's no point doing all that computation every time through the inner loop. Just do it once, after the end of the inner loop. 

You're not really asking for a code review here; you're more like asking the community how they would write the code for this problem. So, not really on-topic. However, here's a hint (partial answer) for you. Consider each of the four shapes in isolation. Write four functions, one per shape, each taking an parameter that indicates which of the 9 lines (top to bottom) the function should be outputting. For example: 

Compile with to produce an assembly listing, and read that assembly listing. This should answer your question. :) 

Your class is merely a type-erased wrapper around a callable. We have a name for that in C++11 and later: it's called . Consider: 

Actually, a candidate's not knowing that concatenates lists in Python would also be cause to fail the interview, where I'm from. So it probably wasn't just the repetition of code that was the problem. 

This way, if the caller actually doesn't care about the values in his original matrix anymore, he can it into place for you: 

Much cleaner! And a tiny bit faster in the case that you call multiple times, because you don't have to check anymore. (And much slower in the case that you construct a object and never call the method — but why on earth would you construct this single-purpose object if you're never going to use it?) 

I don't see anything in your code that corresponds to this sentence in your explanation. I think you have no "prioritization" going on here. The only thing determining which threads get to run when is the OS thread scheduler. And there's nothing at the algorithm level that could be described as "priorities"; this isn't like a rwlock where one side can "starve" the other. Contrariwise — each side here is "feeding" the other! 

For the same reason, I write even when is just as fast for integers. (Well, in that case, it's also because the verb comes first in English. "Increment " reads better than ", increment".) C++ isn't C89; you should never declare an uninitialized variable if you can possibly help it. Write: 

Could you add some more explanation of what kind of pattern/construct this is intended to replace? I played around with your Coliru code a little bit, and it seems like this is the thing you're replacing: 

However, both of those snippets I just pasted have formatting "bugs" besides the indentation: In the second one, you have a trailing that shouldn't be there. In the first one, you mix brace styles: 

But I could totally be missing something here. If there's a good rationale for "yield and load again later", I'd definitely like to know it. (No comment on your explicit memory orders, or whether my preferred loop above could be safely used with any memory orders besides . I'm not qualified to talk about explicit memory orders.) 

Notice that is just an alias for , and I don't think your function ought to be concerned with flushing the stream, so either ought to flush unconditionally after the ladder, or else you ought to push the responsibility for flushing up to your caller (the approach I took). 

In fact, you should read up on X Macros and consider whether the above code would be more readable and maintainable (particularly regarding what happens if you want to support unsigned types, , etc.) if you wrote it as 

(You might need to cast to or ; I don't know. You might also want to see whether the third argument to can be ; or, if not, maybe you should use a temporary variable and assert that the new value is exactly the same as the old value, since it would be Very Bad if that weren't true.) 

(The comma at the end of each line is just a habit I've formed through long exposure to unclean output; presumably it would be harmless to drop the final comma in this case, if you're sure there will never be any more arguments added. But then, in software engineering we're always "sure", aren't we...?) 

a good compiler will optimize away the condition (since obviously you can't get zero by adding a positive number to 3); but if you have a bad compiler, it might actually be generating that extra test every time, so replacing that condition with would help in that case. 

So: is never true. It looks like you're wanting to check the size of the message itself (like, number of bytes in the message); so, you need to add a function parameter to get the message size. would do fine. In C++17 the new party line is probably to use a . 

The nice thing about removing the inner loop (as above) is that it's easily readable by a non-expert (say, someone coming from Java, C#, or Python). But if your target audience is C++ experts, this would also be okay: 

In C++11, we need to use the "trailing " trick to get the compiler to accept that code, since C++11 can't deduce return types (except in lambdas). 

No different in the code generated, but significantly easier on the eyes, and there's several fewer places for typos to lurk. You could make it even simpler, of course: 

You could also introduce a helper class implementing the method, and have inherit that method from . That's called the Curiously Recurring Template Pattern (CRTP), and you've already seen it in action, in above. This would be useful if you're going to have the same kind of view on many different kinds of data: 

This way, your header includes all the headers it depends on, recursively, and you never have to worry about whether your caller included something else before you or not. 

Now, I can't imagine how you'd use in your codebase where any of these quirks might matter; but then, I don't quite see how you plan to use at all. Your only fleshed-out example is just using as a verbose way of writing , which doesn't seem very useful. 

This reduces the size of the array by half, and reduces the amount of work actually being done from to . Benchmark again; is it fast enough now that looking ahead several moves is feasible? If so, the next step is to implement the cell type.