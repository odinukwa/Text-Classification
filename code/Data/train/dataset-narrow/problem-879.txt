An alternative design This is based on my experience writing a go program in C#. It focuses on clean design, sacrificing some performance. But features that need extreme performance, mainly bots, need specialized data-structures anyways, so I don't see that as a problem. Go game logic only depends on the coordinates of a point for a single function: determining the neighbours of a point. If you use an immutable type, you don't need to pass around (x,y) pairs all the time. You don't need 2D arrays to represent the board state either, you can use a simple . The board topology can be described using two functions and . To avoid creating new instances of all the time, you can create all points when initializing the board and add a function to obtain it. Chains are simply a collection of points, there is little gain in representing them as their own type. I wouldn't use persistent chains updated each move either. Chains are only necessary to determine which stones will be captured, you can compute them on-the-fly for the neighbours of the point you're playing on. To compute chains, start at a point and recursively add all neighbouring points, eliminating duplicates. Similarly I'm not fond of having a mutable class. The class together with a couple of functions on the class representing to board state should be enough. 

You can simplify it by replacing all those streams with a call to . You don't have a MAC, so an attacker who can send a modifier message to the decrypter can probably exploit a padding oracle to decrypt the message Why ask the caller for an IV? You could generate it internally. If you want to keep a deterministic implementation around, at least create an overload without IV. and should have a name that says which encoding (hex, Base64, etc.) they use. I'd use and . 

How to convert a byte array to a hex string in Java? lists a number of alternative/better implementations. 

I believe C# 6 will add a feature for "readonly properties" that combines the advantages of these alternatives. 

An important design question is if you want to provide functionality similar to but following C# and .NET conventions, or if you want it to be identical to Excel. 

You're hiding instead of overriding it. You're ignoring empty input strings, the spec doesn't require that. Curiously you're not ignoring input strings. Using a as accumulator leads to quadratic runtime since it has to create a new string which contains all current data for each append. Use in instead. Don't return a string from , else you lose the performance advantage. Call in your operation. This has linear runtime. You're returning if no value has ever been added. I'd expect the empty string instead. 

You're filling the first half of with , but you're missing the rest. This can't be right. A useless mask: 

If you don't use the above redesign, you should rename your current and , because they don't represent those colors, they represent a piece with that color. So call them and . 

My biggest issue with your code is that it doesn't achieve anything useful. It's pretty much a thin wrapper over that doesn't add any abstraction or features. Btw your function exists in the BCL, in the form of . If you want to use it without having to instantiate (which prevents you from using the underlying stream) I'd rather add a extension method to instead of adding it on your TcpClient wrapper. Passing in arrays as buffer is idiomatic in IO code and avoids unnecessary allocations. So choosing between returning a new instance and writing into an existing is a performance-simplicity trade-off. In my experience using existing buffers is preferable in low level code, since you don't know how it will be used and returning new instances is preferable if you write high level code and know that you don't need much throughput. As a variant of passing in buffers, you can pass in an . 

At this point it's so short that it might not even deserve its own method anymore. Since you call before sorting you're relying on the items being sorted by the in descending order. If that assumption is correct you don't actually need to sort again, you can simply reverse the order to ascending. 

I don't know what they meant by calling your code "not detailed enough". You could add documentation for corner cases, possibly in the form of unit tests. For my observations 3 and 5 it's not clear if your code is behaving like you intended. Documentation and/or unit tests would have clarified your intent. 

"properties are better than fields" only says that you should prefer public properties over public fields. It does not say that auto properties are better than properties with explicit backing fields. 

I'd separate all those format parameters from the formatting call, like t3chb0t suggested. The formatting method would become an instance method on that type. I'd split this into two overloads. One taking two required s and one that takes only one, defaulting the other to now. This separates the deterministic logic from access to external state like clocks. I'd add a to the format parameters This code has very sloppy time-zone handling. It implicitly assumed that the inputs are in Utc, but does not verify that assumption. I'd consider passing in a timezone in which to do the data comparisons. Note that time differences can differ between Utc and local time, because local time can jump due to DST switching. In my software I decided to compute differences in Utc when the unit is hour or smaller and in local time when the unit is in days or longer. I don't like calling this function normalize. This function tries to produce a user friendly string, not a canonical form. I'd favour over string concatenation. e.g. 

The biggest flaw in your model is that you don't model as a type. If you do that, you can eliminate a lot of duplication in other pieces and can make most code color agnostic. The second big change I'd make is not coupling the coordinate so tightly with pieces or spaces. I'd only add this information in the places that require it. 

Consider parameterized queries over building a query string. If you really want to use encoding, do the encoding directly before passing it to mysql Factor out the password strength rules into a separate function. This function could output an array of violations. Don't mix logic and IO. 

The first thing I don't like much is that you walk the callstack to find the caller. It's faster and more robust to find the assembly via a type that's part of that assembly. Since your methods are called on a controller, you could use to find it. The next issue is that you only store a single value and you do so in a non threadsafe fashion. I'd use a threadsafe dictionary that maps an assembly to the data instead. Omitting details like argument validation, my code would look similar to the following: 

You can use LINQ's method. As usual, it's a bit slower than manually written code, but unless this is in a hot spot it rarely matters. The cost of vastly exceeds the cost of LINQ. 

What's the point of the masking? If a byte of the output were larger than that, that'd mean that you're running on an unusual architecture with large s and OpenSSL has a bug. You could use if you want to be explicit about using 8 bit bytes. Many crypto libraries use these typedefs. 

You should extract the hex encoding into its own method. See How to convert a byte array to a hex string in Java? for various implementations. uses the locale dependent legacy encoding. So you won't get reproducible results on different systems. Specify an encoding explicitly, I recommend utf-8. 

is dubious because it uses the locale dependent legacy encoding. It's generally better to use a fixed unicode encoding, preferably UTF-8. But in this case I see no reason to read the input as string instead of raw bytes in the first place. 

Why the ? There are hex digits. So you need at least chars. Since you want a null terminated string (the rest of your code assumes it is), you even need an extra character for the terminator. So this should be char A partial initialization: 

loads the whole file into memory. That's prohibitive for large files and puts a lot of pressure on the GC even for moderate file sizes. I recommend hashing a stream instead. 

Most of your comments are completely redundant. They only bloat the code without adding any information. For example for you write: 

is seeded by a 32 bit integer. So there is little point in generating a 384 bit string. You'll still only get 4 billion different salts. PHP's bcrypt API will ignore anything beyond the first 128 bits and expects a Base64 encoded salt, so your salt isn't usable for that either. To generate random numbers you can either use or or ( in php 7). Note that with the openssl variant you should check the second parameter to see if you got back good random data. Then encode the output with Base64. Just use the API (php 5.5) or its polyfill on older versions. Its easy to use and secure. 

I want to emphasize how important it is to override is when you override . If you don't, all hashtable based collections/algorithms will sometimes fail in unexpected ways. This includes , and LINQ functions like or . can be simplified: 

Use native interop to call a high performance native library. While and have a high per-call overhead which makes them slower than , this isn't true for native interop in general. In a different project I called OpenSSL's MD5 from C#, which was much faster than any implementation built into .NET. Use an existing managed implementation of PBKDF2-HMAC-SHA-512. I think BouncyCastle includes it. Start with an open source implementation of SHA-512 and tweak it to your needs. 

You can then implement it with or . Converting to a different time zone is a separate responsibility from getting the time, so I wouldn't solve it by injecting different clock services. Instead you should pass in a and convert the utc time to that timezone before printing it. You should probably go one step further and first create an instance of a class that contains an UTC timestamp and other information (message, severity,...) and then convert it to a string using some kind of which handles time zone conversion and different string formats for date times. 

No MAC => say hello to padding oracles. This is fatal flaw that allows decryption of the message in many usage scenarios (when there is an active attacker). You use CBC mode with constant IV. A new IV must be chosen for each message. It should be unpredictable and random. Your keying is only secure with really strong passwords (over 100 bits of entropy). I recommend using an actual binary key drawn from a secure CSPRNG encoded with Base64 instead of a password. A related stylistic problem is that you don't clearly distinguish between keys (which should be uniformly random) and passwords. Does the key ever leave the trusted systems? It looks like you're hardcoding a key into a client, which might run on an untrusted machine. Even if it stays on the server, put it in a config file, not the code. Your program should be secure even if the whole code is known. Logistically it's also much easier to keep a config file secure, since it doesn't need to be checked into version control. Why would you choose 3DES over AES in new code? AES is faster and stronger. It also has 128 bit blocks instead of 64 bit blocks, so it doesn't weaken once you encrypt a couple of gigabytes using the same key. All those streams are unnecessarily complicated. Simply call on a byte array instead. 

The reader learns nothing from this they can't already see from the the definition. You could instead document what being "alive" means. There are several possible definitions with subtle differences, telling the reader which you are using is helpful. It's the same for most of your other comments. It's confusing to have public members called When you construct a or with the default constructor, it owns the underlying stream and closes it when it's closed. So closing the stream is redundant. You also have two objects (the reader and the writer) which own the stream, which I'd avoid. is useless if your class has no finalizer. This also means doesn't get called with as parameter and can be thrown out. In general I'd recommend against using this disposing pattern. If you own unmanaged resources directly, implement a . If you only own them indirectly, there is no need for and the finalizer. Don't silently swallow unexpected exceptions. They indicate a bug and should be rethrown or not be caught in the first place. You call without ensuring it's not . Use a property for instead of a method.