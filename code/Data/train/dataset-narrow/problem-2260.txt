For a given input $ w \in \Sigma^* $, the accepting value of $ T $ on $ w $ is given by $$ f_T(w) = f A_{w_{|w|}} \cdots A_{w_2} A_{w_1} v_0, $$ where $ w_i $ is the $i$-th symbol of $ w $. (Remark that $ f_T(w) \in \mathbb{Q} $.) In the other words, $ T $ starts its computation in $ v_0 $ and then read $ w $ from the left to the right symbol by symbol and for each symbol it applies the corresponding transition matrix. At the end, it takes inner product of the final state with the final vector and it gives the accepting value (it can also be seen as a weighted sum of the entries in the final state). There exists a TuFA $ T $ that defines the language $ L = \{ w \in \Sigma^* \mid f_T(w) = 0 \} $ if and only if $ L \in \mathsf{SL^=} $. By using a TuFA, you can encode a binary string. Let $ w \in \{0,1\}^* $ be a given binary string and $ e(w) = 1w $ be its encoding. The initial state is $ ( 1 ,1 ) $. For symbols 0 and 1, it applies the transition matrices $$ A_0 = \left( \begin{array}{cc} 1 & 0 \\ 2 & 0 \end{array} \right) \mbox{ and } A_1 = \left( \begin{array}{cc} 1 & 0 \\ 2 & 1 \end{array} \right), $$ respectively. After reading $ w $, the new state vector is $ (1,e(w)) $. Then, if it reads symbol 0, then the new state becomes $ (1,2e(w)) = (1,e(w0)) $; and, if it reads symbol 1, then the new state becomes $ (1,2e(w)+1) = (1,e(w1)) $. The language $ \mathtt{TWIN} = \{ w \# w \mid w \in \{0,1\}^* \} $ is in $ \mathsf{SL^=} $. We can design a TuFA using the above encoding. Let $ w_1 \# w_2 $ be the given input. Otherwise, set the accepting value to a nonzero value. Encode $ w_1 $ and $ w_2 $ in the values of two states and then set the accepting value to $ e(w_1) - e(w_2) $. Thus, $ f_T(w_1 \# w_2) = 0 $ if and only if $ w_1 = w_2 $. If we tensor $ T $ with itself, then we can also set the accepting value to $ (e(w_1) - e(w_2))^2 $. In fact, one can easily play with different combinations. Let $ \mathtt{COPIES} = \{ (w\#)^k \mid w \in \{0,1\}^*, k \geq 1 \} $. We design a TuFA $T$ for $ \mathtt{COPIES} $. It is trivial to detect $ k=1 $. Let $ w_1 \# w_2 \# \cdots \# w_k \# $ be the given input for some $ k >1 $. Encode $ w_1 $ into the value of a state and keep it until end of the computation. Also reserve the value of a state for the accepting values, which is zero at the beginning. After reading $ w_i $ ($ 2 \leq k \leq k $), add $ (e(w_1)-e(w_i))^2 $ to the accepting value. The accepting value ends with 0 for any member and with some positive integers for any non-member. More precisely, $$ f_T(w_1 \# w_2 \# \cdots \# w_k) = \sum_{i = 2}^k (e(w_1)-e(w_i))^2 $$. Therefore, $ \mathtt{COPIES} $ is in $ \mathsf{SL^=} $. 

It is a well-known fact that $ \mathsf{NL} = \cup_{k>0} \mathsf{2NFA[k]} $, where $ \mathsf{2NFA[k]} $ is the class of languages recognized by two-way nondeterministic finite automata with $ k>0 $ input heads, shortly 2nfa(k). I have two but similar questions: Is there any known language in $ \mathsf{NL} $ requiring super-linear time, where the model is a standard space-bounded NTM having a read-only input tape and a read/write work tape? Is there any known language recognized by some 2nfa(k) in super-linear time but not recognized by any 2nfa(k) in linear time? 

Your language can also be recognized by realtime universal one-counter automaton and realtime private alternating finite automaton (DHRSY), deterministic set automata (KMW), and one-way deterministic 2-head finite automata. Currently these are the ones that I could remember! 

Moreover, the quantified max word problem for matrices was recently introduced and shown to be PSPACE-complete by Demirci, Say, and Yakaryilmaz (2014). Here is the related part: 

You can check the recent survey by Ambainis and Yakaryilmaz: Automata and Quantum Computing. It is comprehensive and points the essential literature with some open questions. Moreover, here is a list of papers published on quantum automata until 2015. 

Yes. I think the main reference is Turing Machines with Sublogarithmic Space by Szepietowski (1994). (Link to books.google) 

You can find many characterizations (particularly on space-bounded verifiers) in Condon's famous survey: The complexity of space bounded interactive proof systems. Here is a list of some of them: 

There are two well-known mapping reducibilities: polytime and logspace. In both cases, the length of the output string can be at most polynomial in the length of a given input string. If we allow to use more space (super-logspace), then the length of the output string can be super-polynomial. Therefore, it seems interesting to me to ask whether this blow-up helps us to reduce some difficult problems to some easier problems when using super-logspace $ \left(\omega(\log n) \right) $. I am not interested in the "cheap" tricks such as padding. More generally, is there any literature on super-logspace (or super-polynomial) mapping reducibility? 

A two-way deterministic (nondeterministic) multi-head finite automaton can be simulated by a logspace DTM (NTM), and vice versa. So, for including class $ \mathsf{NL} $, you do not need a counter! The value of the counter belonging to a two-way nondeterministic multi-head finite automaton with one-counter can be bounded by a polynomial, otherwise, the computation enters an infinite loop. Since both such a counter and the input heads can be simulated in logspace, $ \mathsf{LOGCFL} $ upper bound can be replaced with $ \mathsf{NL} $. Note that any language recognized by a two-way deterministic (nondeterministic) one-head finite automaton with one-counter is in $ \mathsf{L} $ ($ \mathsf{NL} $). There are many papers on these topics, e.g. this paper. You can find more after some googling. (Check also Lemma 1 of this paper.) 

I have found an answer to my own question. The result was given in Section 5 of Karpinski and Verbeek, 1987. For any input of length $ n $, a PTM can construct $ \Theta(\log \log n) $ space with high probability (Section 4). (With a very small probability, the machine can also construct logarithmic space, and this might be seen as a "drawback" of the algorithm.) Then, the PTM can decide whether the numbers of $a$'s ($n$) and $b$'s ($m$) are equal with high probability by using $ O(\log \log n) $ space in polynomial time. The idea is as follows. If $ n \neq m $, then $ \exists k \leq 4 \log(n+m) $ such that $ n \not\equiv m \mod k $ (Alt and Mehlron, 1976). The PTM can pick a random $ k $ by using $ O(\log \log n) $ space. $ O(\log \log n) $ is also sufficient to keep a counter and so trying more than half of all possible $k$'s. The case of $ n \neq m $ can be detected with a probability more than $ 1 \over 2 $. 

The tight bound is $ n(n^n -(n-1)^n) $, which was given in Removing Bidirectionality from Nondeterministic Finite Automata by Christos Kapoutsis (2005). I am also putting a figure from this paper giving a clear picture: 

DEFINITION Language $ \mathtt{A} $ is $s(n)$-space mapping reducible to language $ \mathtt{B} $, shown as $ \mathtt{A} \le_{m}^{s} \mathtt{B} $, if there exists a $ s(n) $-space DTM $ \mathcal{D} $ outputting $ f_{\mathcal{D}} (w) $ for a given input $ w $ such that \begin{equation*} w \in \mathtt{A} \mbox{ if and only if } f_{\mathcal{D}} (w) \in \mathtt{B}, \end{equation*} where $ \mathcal{D} $ has a two-way read-only input tape, a two-way read/write work tape, and a one-way write-only output tape. 

If you allow the repetition of matrices, i.e. there exists $ 1 \leq i < j \leq n $ s.t. $ A_i =A_j $, then your problem is actually undecidable. Let $ EMPTY_{PFA} $ be the emptiness problem for probabilistic finite automaton (PFA). A PFA is a 4 tuple: $ P=(\Sigma,\{A_{\sigma \in \Sigma}\},x,y) $, where $\Sigma = \{\sigma_1,\ldots,\sigma_k\}$ is the input alphabet, each $ A_{\sigma} $ is a stochastic matrix, $x$ is a stochastic row vector (initial distribution), and $ y $ is a zero-one column vector. Each word, say $w \in \Sigma^*$, corresponds to a sequence of the matrices from $ \{A_{\sigma \in \Sigma}\} $ by allowing repetition, and vice versa. The accepting probability of $w$ by $P$ is as follows: $$f_P(w) = x \cdot A_{w_1} \cdot A_{w_2} \cdots A_{w_{|w|}} \cdot y, $$ where $w_i$ is the $i^{th}$ symbol of $w$ and $|w|$ is the length of $w$. $ EMPTY_{PFA} $ is the problem of, for a given PFA $ P $ and a threshold $ \lambda \in (0,1) $, whether there exists a word accepted with a probability at least $ \lambda $. $ EMPTY_{PFA} $ was shown to be undecidable. It is an old result and you can start digging from this article: $URL$ $ EMPTY_{PFA} $ can be reduced to your problem. So, if your problem is decidable, then $ EMPTY_{PFA} $ is also decidable. But this is a contradiction. So, your problem is undecidable, too.