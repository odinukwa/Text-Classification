I don't remember where I saw it (maybe one of your other posts) but I recently saw a technique for ensuring uniqueness of array elements - iterate over the elements and just return the equality of the current index to the value returned by calling Array.indexOf(). Using that technique here, Array.every() can be used to ensure each word is unique. With that technique, there is no need to count the number of occurrences of each word and hence the reduction can be removed. Thus can be eliminated and can be simplified like below: 

That can be removed, since the ruleset above that contains the same border style. class Instead of adding the style to the elements with class , make it a class like that can be added and removed in order to hide various elements (e.g. the outcome message). Rewrite Below is how I would simplify your code. Hopefully the explanations above support all the changes, but there may be a few things that you might have to research in order to figure them out. I also removed the class from the table cells and updated the code to check if that class exists on the table cells - instead, the member variable can be used for that discernment. Then there is no need to remove the class and later add it when restarting. 

PHP Separate endpoints It would be wise to separate the code in the function into two different endpoints - one for fetching messages (which should perhaps use the HTTP verb), and one for creating a new post (which can stay as a or a request). That way isn't concerned with creating messages, so as to adhere to the Separation of Concerns principle. Laravel code? It looks like some of the Laravel facade and Eloquent methods (e.g. are used, which makes me believe this is a Laravel controller method. If that is the case, it would be wise to access POST data via the Request object. Then lines like 

As far as making the code "secure from exploits", that might be tough to do with JavaScript, unless you take tactics like minification/obfuscation, etc. The suggestions below should allow the code to be more robust. Naming , and aren't very descriptive. Better names might be , , , etc. Additionally, the variable in the loop (i.e. ) is not declared using var so it is put into the global namespace. Allow number of population columns to be dynamic Currently the code only allows two columns of populations, and hard-coded to years 2000 and 2005. The table headers could have a class added: 

After reading over the code snippets you included, it looks pretty simple. The only concern I have is that if the switch statement reaches the default case, then is called , and then just after the switch statement, is called... If a status is sent, then it doesn't seem appropriate to send the response data (even though wouldn't be assigned in the default case. One other improvement I see is that the response could be made consistent by moving that into a function and calling it in the two places where a response is sent. So in the example below, that is defined as the function inside the callback to , or that could be moved outside the callback and would then likely need to accept the response object as a parameter. 

And then it can be referenced with-in the constructor to add the image and counter elements. If the value was assigned at the time of declaration, then const could be used instead of var. 

Appears to look for submit buttons (using the jQuery :submit selector - so you might have to look for elements matching ) and adds a click handler to each. When the click handler runs, it removes any select list that doesn't have a value - and then apparently sets the disabled property to . 

"More readable" is subjective. One could argue that it might be easier to read if a separate variable was used to store the integer: 

@Roland Illig has a good point: the field names can be put into an array. Perhaps it would be best to use one array for the labels of the fields and then use that array to generate the field names. 

See that portion updated in the snippet below. Note that it doesn't have the AJAX call because there is no local endpoint to supply that. Instead, the function is called with the sample data structure Louys suggested. If you weren't using jQuery, a DocumentFragment could be used to create the elements and add them all at once to the page. See the section "Use a DOM DocumentFragment in this article for more information about that. 

Cache DOM lookups When iterating over the elements with class name mySlide in the loop, there is a look-up for the dots container (i.e. ). Bearing in mind that the example only contains four slide elements, that could lead to excess DOM queries. It is good to store references like that and then utilize the reference: 

The original code already uses functional techniques - i.e. array.forEach()- for one loop. Perhaps you are already familiar with functional techniques like that and others but if not, I recommend going through these exercises. That inner for loop can be re-written using array.forEach(): 

1 and note that it actually contains a todo-list example, which you could have based your code off of... 

Additionally, the first iteration, to count the occurrences of each element, could be simplified using a ternary operator: 

And as you suggested in your jsfiddle via comments you could just omit the call to . In a large web application one might want to explicitly use but it is probably fine to omit it in a small script like this that you are likely the only one who will maintain it. Notice how I added . In your code, and are global variables because "Undeclared variables are always global."1, which could have unintentional consequences - for example, if the wikipedia JavaScript had a variable with the same name, then it would be overwritten. One style tag for each ruleset? Why not just add one style tag for the whole set of rulesets, instead of one style tag for each? To do this, just combine the three strings and call once. Template Literal Going along with the advice in the previous section, you could use a template literal to add the styles. With expression interpolation, there is no need to terminate the string to add the arguments. That way there is no need to worry about appending strings together. 

DOM references If you are using functions to lookup DOM elements (e.g. ) for elements contained within the root element (or component), it might likely be the wrong way of doing things, as far as VueJS code goes. With VueJS, you can use v-model to bind the value of the input to a data property - for example, the for the new list item can have a attribute added, like: 

Alternatives to , , I am not sure if it would work but you could consider using cURL wrapper functions or - that way the parsing of individual characters could possibly be eliminated. Reading characters in I haven't tested it but in theory the (outer) loop could be simplified to a loop: 

So why bother returning anything from that function (besides exiting the function early)? Assignment of before returning a value That function has many cases where a string literal is assigned to (with scope beyond the function) followed by a statement. This seems unorganized. Why not merely return the result (I would suggest adding an additional tie case, for the scenario where player2 has the high card). That way, the message can be set in the click handler (or another function), so that isn't responsible for checking the result and setting the mesage (refer to the Single Responsibility principle). That way, the messages can be set in one place (instead of repeated, as they are in both cases) - adheres to the Don't repeat yourself principle. To change this, the case could be added to the result set: 

A note about using parseInt() If you are going to use parseInt(), it is wise to specify the radix using the second parameter - unless you are using a unique number system like hexidecimal, octal, etc. then specify 10 for decimal numbers. 

And that function could be pulled out of if is accepted as the first parameter, and then playerIndex can be sent on each iteration using Function.bind() - i.e. using a partially applied function. 

One alternate approach would be to have the store the newly added user in a property (e.g. ) and then have the method look for that property - if it is set (to something other than ) then add the rendered template of the new user and clear that property. When the page loads, is there an existing list of users that gets added to the list? If so, maybe those could be stored in a different property and the existing code in could look for that property for rendering the existing records. 

This could be simplified using array_shift() to pop the first row out of the array of rows, and preg_split() to separate header names by 1 or more white space characters: 

only applies to and not all of the variables combined via the OR operators. You probably know this but one could omit the , since anything that doesn't evaluate to a boolean will be considered 1. 1$URL$ 

The feedback below won't likely prevent time out errors, but hopefully will clean up the code. Description-code mismatch The narrative in your post states: 

See it demonstrated in the snippet below. As was mentioned in comments, there was no sample input supplied so I devised a sample. 

Sorting I did consider sorting the array of values in each row using Array.sort(), which works, but the values all need to be converted to integers first (e.g. using , or just a function that returns the number added to 0), which slows things down a little. But with that change there is no need to call and then - simply sort the numbers, then add the last element to the cumulative total and subtract the first element. 

I would suggest that whenever you create a lambda/anonymous function/closure to simply call one other function, use Function.bind() to create partially applied functions instead. That way, there will be one less function call in the stack. So for instance: 

D.R.Y. There is a widely accepted principle amongst developers: Don't Repeat Yourself. The following block appears three times (with varying spacing): 

See a demonstration in the sample below. Notice how there is now a clean separation of the event handling logic (JS) and the markup for display (HTML). 

Using vs For values that aren't re-assigned after use, could be used instead of . For example, in the method of , the value for doesn't get re-assigned - it is merely used in the return statement immediately after being assigned. Some developers default to using unless re-assignment is mandatory 

That should prevent excess loop iterations. While the difference may be negligible for small lists, it may be very helpful to reduce the execution time for larger lists. Demonstration Check out this playground example for a demonstration. And compare the time output at the end with the original. 

Edit Bravo to Gerrit0 for using Array.filter() and having very concise code! The performance results appear to be similar. Utilizing filter() instead of reduce for the second iteration can eliminate a few lines: 

Sets the inner HTML of the unordered list tag to a text string. That is technically unpermitted content for an unordered list. Perhaps a better solution would be to have a separate element for the error message. P.S. Here is the output from that AJAX call using that image of Tesla, so you could fake it now that the key is invalid: 

Over-complicated The addEvent function creates two functions (i.e. and ) which basically just call passing the event object to the callback. These steps are superfluous. It could simply add the event listener, passing to the parameter: 

One could also perhaps add each coordinate to an array and then join those with the new line characters (i.e. ), and also utilize Array.map() to construct . Redundant variable declaration, assignment I see these blocks: 

This is because the parameter of Array.reduce() is omitted, which causes to be used as the first time 1. This can be observed by inspecting the values of in the callback - for the sample data, it starts with and ends with . In order to not mutate the first element of , a deep clone of the first element can be used (e.g. with JSON.parse() and JSON.stringify()). 

There is an Underscore helper _.pluck() but that is used to collect a value from each item in a collection at a given property (similar to Array.prototype.map(). Lodash also has the same helpers: _.filter() and _.includes(). 

If you really wanted to shorten the code for the promise callbacks, you could abstract those into methods. 

Then, (Back in the Javascript change callback) in order to calculate the total price, iterate over the select lists and look for a selected option under each select list. The code below uses Array.reduce() to get the sum of the prices by iterating over the select lists. It also uses the spread syntax (i.e. ) to get an array from the jQuery collection. 

If you wanted to use Underscore.js, _.filter() and _.includes() could be used to filter out any object in without a value for the value property contained in . Expand the snippet below for a demonstration. 

So that can reduce those 4 lines to 2. It may be desirable to break those up into multiple lines for readability. 

That means that there are 9 lookups on the Document Object Model (the DOM). Those can be take considerable time in the context of browser operations! A better approach would be store those elements in an array (well, actually it is a nodelist) as soon as the DOM is loaded: 

So I would suggest not using the ArrayObject class, always have that controller method return an array and simply pass that array to . Something like the (untested) code below in getnewscat.php: 

That way the (which is 0-based, since it is a JavaScript Array) will be available for the attribute. Removing items in constant time That mentioned in the previous section can be passed to the method, which could then use that index to call the JavaScript Array method instead of . As the list grows in size, the approach would take more time, but calling would be quicker because it would know the location of the element to remove. See this working in the snippet below. 

Single element with class notification Because the code won't add a notification element if there are already elements with that class name notification, the code could instead add a single hidden element when the DOM is ready, show it when the notification class is instantiated, and then hide it when necessary. That way the DOM wouldn't be manipulated as much. For more information, check out Stop writing slow Javascript. I know it bashes jQuery a bit in the beginning but later it has some useful information that I wish I had read years ago. Removing _this One could use Function.prototype.bind() (not to be confused with the jQuery method ) to bind functions to the context of , which would eliminate the need for the extra variable . See an example below, also utilizing the function names instead of calls in simple closures. 

Like I alluded to in my comment, I considered voting to close your question because point #8 looked like a request for help implementing code that doesn't work. Alas, I will review the working code. Feedback I agree with the points in the answer by Simon - especially that there is no point to only setting if it is falsey. Below are some other aspects that I noticed. Rendering a list without a key See the section key on the List rendering page of the Vue JS documentation1: 

However it apepars to never be re-assigned. It is wise to default to making this a constant with until a valid reason to reassign that value arises. Using jQuery and then If jQuery is loaded on the page, then why use , as in: 

Using a functional approach, an array method like find() could be used to look for any value that is outside that 0-255 range. If any such value is returned, then return , otherwise if is returned, return : 

Object-oriented code The OO code looks like a good start, though for a larger application, some separation of model and view logic may be necessary. Also, the constructor of the Building class is a bit long. I would recommend abstracting out the code to add elements into separate methods- a template might make that process simpler. Properly accessing the DOM Before accessing DOM elements, it would be wise to wait until the DOM has been loaded. EventTarget.addEventListener() can be used on to wait for the DOMContentLoaded event. 

That sounds like a better choice, though if there truly are 26+ values in each row, that line of code would get very lengthy. Perhaps a good choice would be to define a mapping of indexes like below, or just assert (/use error handling) to ensure the expected data exists in each line. Or, as Claudio mentioned in a comment could also be utilized to simplify things here.