Here is the code as posted in your question. On my machine, I get a time of 0.8s. How much better can we do? Suppose we could cheat and use the following method: 

I would stick to the guidelines and increment (decrement) by 1. TryParse You probably want to use the character class instead of in your regular expression. This is because matches Unicode decimal digits. So this code will throw a : 

You might want to check the parameter in to check that the card is not null, is not already in the deck, won't make the deck have more than 52 cards, etc. 

Now let's define a method on to remove the repetition. I called it , but there's probably a better name. 

Ahhhh... integer overflow in our counter? Not good. So what can we do? Let's look at the problem statement again. 

There are already some good answers here, but since this is for a job interview I'm going to imagine I'm looking at this as a potential employer. Stylistically, there are a few things that jump out: 

If I understand correctly, you're looking for the Cartesian product of the attributes in each attribute category. To get the Cartesian product, I've adapted* Eric Lippert's solution from his blog post Computing a Cartesian product with LINQ. 

You're creating a new for every node in the tree, which is a lot of garbage for the garbage collector. Each value will also end up getting appended to many temporary lists. Let's kick the can down the road and assume that the work of creating the list has been taken care of for us. We take the result list as a parameter and append to that 

The solution can be made cleaner by re-arranging the order of the arguments and using pointfree style. 

In which case, you don't need the . Other , , , , and can be made readonly. is a convenience method for , and reads a bit nicer. 

There are a couple of cases where using isn't gaining us anything. For instance, can just be written as 

Now let's just handle the simple case, where there are no escape characters. Let's write some unit tests 

We start by solving the more general problem of finding all indices of in . Let's look at the skeleton of our solution. 

These show a lack of attention to detail. It's a job interview, you want to make the best possible impression. This comment in particular 

Output: The solution uses a sweep-line algorithm to find the points where the height of the outline changes. is a silly class to parse the ridiculous input format. In an ideal world it wouldn't exist, but it shaved off a significant amount of time. 

to calculate Fibonacci numbers, as it takes exponential time. Instead, we can calculate Fibonacci numbers in an iterative way 

Welcome to the world of F#! Your code is looking good, and thanks for posting the LinqPad file. Here are a couple of pointers: 

There's a problem with the original method, which is the interaction of and using a buffered writer. Let's try to write up to 400 bytes: 

This code doesn't rotate the image 90 degrees clockwise. We can see this by making each entry in the matrix distinct (the important part is moving inside the inner loop) 

Here I've used instead of so we can pass it a , again saving on the creation of string objects. (Consider using instead of depending on the behaviour you want.) We can save a call to if hasn't changed. Not sure if it will help much in this case, but it's something to consider. 

However, the way the increment and decrement operators are written, they increment (decrement) by . This leads to confusing behaviour. For example, how can we make this assertion fail? 

Now, has an overload of that takes a starting position. But where do we start searching? We start searching one position after our last found occurrence. 

How do you know that the proper encoding is UTF8? Let the client pass in their own and use that. You could use the more general in place of , by checking for the end of the input using instead of . 

It seems that is always sorted by . If so, you could insert into the list at the appropriate place here instead of re-sorting the entire list 

The third case of each function definition seems to be there just to get rid of the warning about incomplete pattern matches. Since the second case of the match is incorrect, and the third case should never run, we can do away with the pattern matching. 

From your problem description, I would expect the output to be , but it's just . So I'm going to assume the problem description is correct and the code is wrong. Here are some other notes: 

I would consider making the methods take a () instead of a . You can then pass a () from your unit tests, while client code will normally pass a (). This will also allow client code to choose the encoding (which they really should be doing) instead of being forced to use UTF-8. Another reason to consider doing this is that someone calling might want to write to the stream after the call returns. But they will get an exception, since disposes of the underlying stream. For example, we get an when we call here: 

Besides being a little shorter, we are creating fewer objects. Let's say there are \$n\$ words returned by , \$d\$ of which are distinct (up to case). The first version creates \$2n\$ string objects (the \$n\$ returned by and these same \$n\$ words lower-cased) and \$d\$ instances of the anonymous type. The second version creates \$n + 1\$ string objects. This might not be a concern, but since it's an easy win, we should just take it. 

I don't see the need to check that each ancestor is of type here. If we remove that check, I would write 

I would recommend against names like , , , , etc. You should also use consistent casing ( instead of ). 

Where are these numbers coming from? Introduce named constants for them, preferably with a comment explaining their derivation. Working backwards, I guess you've come to 225,000 from 225,000 * 2 bytes = 450KB, a bit under the 500KB limit you mentioned. If you encode the strings as UTF-8 instead of UTF-16, you will probably get a lot more bang for your buck. On that note, consider zipping the log files before sending them. 

Now we could end up creating a lot of substrings. To avoid this, we can pass an index into the string 

For a method like this, don't worry about performance until you have evidence that performance is a problem. Either way will almost certainly be fast enough. I would suggest instead for readability that you separate the data (key-value pairs) from the construction of the string. If the order of the pairs is not important, you can write 

That is redundant and can be removed. Using a for is roughly twice as fast on my machine. Avoiding strings altogether is faster still: 

I wrote the code above based on your description "remove non-ASCII characters in a text file", but now realise your requirements are more specific: to remove characters outside the range 32-126. It can be easily modified to support that requirement: 

might be overkill for the situation; I find it to be of most use for its method, which we're not using here. You might want to consider something like this: 

Beside's @ratchet freak's suggestion to use a more suitable data structure for (e.g. a ), you can change from an \$O(n)\$ operation to an \$O(1)\$ operation by making a . Once you've changed it to a , the method returns a indicating whether the item was added to the set, so you could change this 

Consider adding a constructor so that client code doesn't have to allocate a byte array or string, or manually convert the bytes to a . 

If you want to test that your implementation matches the behaviour of , I would suggest introducing a helper method for the tests. Something like 

Each evaluation of will take time proportional to the length of the list, which will slow this down. We know that there will be sublists of of length . We can use this to make the code much faster. 

(I've been a bit fast and loose with this, there might be bugs present.) With all that in place, we can rewrite to delegate to 

If the text is potentially very long, you may be better off doing just one pass of the string. You would need to profile against the sort of data you have, but it could look something like this 

Here I'm assuming there's a method to extract the data as in your code. It might be more performant to write your own extension method to do this for you. Here I've provided an overload that allows you to specify the comparison, but you might not need that. (You would also want to add argument validation if this is being used in the real world.) 

You can find another implementation on Robert Sedgewick's Algorithms website. [Edit: @psaxton has a much better suggestion to use .] Shuffling multiple times will not be of any use, given a good shuffling algorithm. 

Much of the original code is concerned with whether or not the object has been disposed. I don't believe it should be the responsibility of this method to check if the has been disposed; I would suggest instead to restructure the client code such that is not disposed until the notes have stopped playing (or play has been cancelled, see below). Unfortunately, it's hard to be more specific about how to do this without an example of the client code. I would also recommend removing the class. You might want to support cancellation with a : 

In case this is not homework or a thought exercise... Don't do this. By using recursion (and ) to solve this, you're simultaneously making your code less efficient, in terms of both time and memory, and less readable. As @Guffa pointed out, it may even blow the stack. The function has no reason to exist. Just use where appropriate. 

There is a canonical solution to this problem that makes one pass through the string, and uses a stack. A search for "balanced parentheses" will turn up hints/explanations, if you get stuck. 

I would very strongly recommend against using a regular expression for this. There is no clear mapping between the list of requirements you posted and the code. Imagine another developer looking at this. Are they able to deduce the list of requirements? Given the list of requirements, are they able to verify that the regular expression is correct? How long would it take to convince them that it's correct? In fact, it's not correct. The character class is not the same as (unless you specify ECMAScript-compliant behaviour), and your regexp matches the username (that's an ). (It doesn't match on the link you posted, but that's a Ruby, not .NET, regexp tester.) Now suppose one of your requirements changes -- this code is going to be tricky to maintain. Instead, I would recommend writing a series of tests, each corresponding to one of your requirements. Here is the code I came up with. It still uses regular expressions where appropriate, but very simple ones. 

If you don't want to go to the trouble of implementing a skip list, I think you can fake it with a combination of and . I couldn't find guarantees of the run time of the relevant operations on MSDN, but it runs much faster on this test input: 

I would recommend seeing if RxJS is suitable for your purposes. One of its features is that it allows you to write async-await style code, which can be easier to read and write than using callbacks directly. I've taken your code as a starting point, but changed a few things for the sake of demonstration. We're going to: 

Beside's @janos's great point about inheritance being for is-a relationships, you can imagine slowly getting cluttered with methods and fields that some activities need, and other don't. Eventually it all becomes a mess. With dependency injection, an activity's reliance upon a can be made clear: 

I wouldn't go so far as to call this a bug, but it's good to be aware of. I consider the current behaviour to be surprising just because no other whitespace is allowed. 

Semi-perfection (is that a word?) is defined only for positive integers; infinity is not an integer. Now as for the code. Deleting from and inserting into a is terribly inefficient. What we want is a way to enumerate the \$2^k\$ different sums of the proper divisors, where \$k\$ is the number of proper divisors. Here's a way to do it that uses as a counter. We let the counter range over \$[0, 2^k)\$, and at each step add the \$j\$th divisor to the sum if the \$j\$th bit of the counter is set. 

Having a named makes me think you really want a . Especially since you're later calling which will take time proportional to the number of elements in the list, while for a queue it would take constant time. 

You're missing some cases, for example what should happen when ? Or ? I think this is valid representation of your current code: 

Let's think about this geometrically. Since we're treating a pair of neighbours as equivalent to , we can think of our neighbour-relation as being directed. That is, from up/down we can pick one (let's pick down); similarly for left/right, up-left/down-right, and up-right/down-left. Now most elements have three neighbours: down, right, and down-right $$ \begin{pmatrix} 0 & \rightarrow & 3 & \rightarrow & 6 & \rightarrow & 9 \\ \downarrow & \searrow & \downarrow & \searrow & \downarrow & \searrow \\ 1 & \rightarrow & 4 & \rightarrow & 7 & \rightarrow & 10 \\ \downarrow & \searrow & \downarrow & \searrow & \downarrow & \searrow \\ 2 & & 5 & & 8 & & 11 \end{pmatrix} $$ We can find those neighbours with the following code: 

Edge cases As @nhgrif hinted at, you should throw an exception in the constructor for a zero denominator. As @nhgrif mentioned, you need to be careful handling zero denominators. For example, 

The constructor uses a default initial capacity. When the number of elements in the list goes beyond its capacity, the list must be resized. We can avoid resizing the list by setting the initial capacity of to . 

You have the right idea, but there are some overloads we can use that will make the code a bit nicer: