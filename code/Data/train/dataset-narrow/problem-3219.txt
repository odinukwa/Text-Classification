If it does exist, look for that line. It's probably there with a in front of it. Remove that. If it is not there, add the line. Now run . Now the locales are hopefully straightened out, before you run vnc: 

is only sourced by "login shells". What makes a login shell a login shell is basically the options used to start it; e.g. with bash , or (from ): 

I'm not a mono user and hopefully you get a more detailed answer, but there is a bit of a logical caveat here: 

The SD card controller has no concept of what data "rightfully" belongs where in the sense of coherent filesystems and parititions, and, The SD card is a black box into which the OS cannot truly see, 

Again, if you are doing this from the command line you are interested only in what is inside the parentheses. The above presumes you have set up correctly (and that the kernel module for your wifi adapter loads automatically, which it should). 

Can be broken into two distinct, separate problems that can be solved in parallel. Contemporary processors are not designed to analyse tasks and decide if and how they can be parallelized (to the extent that this might be possible, I am sure the cost of such runtime analysis would make the whole event less efficient). For this reason, and because making such judgements in advance spares any runtime analysis costs, programs can be written to exploit parallelism -- but this does not mean they always are. GNU Make (and possibly some others; it's not specified by POSIX) includes the switch for potentially running component tasks in parallel. Normally, it will do them in a predetermined, logical order, but if run with it is often simple enough to do some of them at the same time -- for example, if an executable has a set of prerequisite independent binary objects that also need compiling, those can be compiled independently in parallel first. However, if they're already compiled and the only thing that has to be done is compile the executable, then from make's perspective there is no potential parallelism and using will not make any difference. If you're not sure, it can't hurt. A common rule of thumb with this is to use one more than your total number of cores, because it's fine to have the OS queue them if tries to do too many things at once. Some tasks run by may themselves involve parallelism, and this will apply regardless of . 

The OS will do a filesystem check at boot if it has reason to believe it was not properly unmounted during shutdown before. This will add some seconds to your boot time and should be noticeable if you have a screen attached and are using a non-graphical boot. If after that everything seems okay, it is probably okay. If you are paranoid you can always take it out and run on the root filesystem in another computer (you cannot do it effectively with the card in the pi because that filesystem must be mounted). 

No. You could (I believe this is what something like berryboot probably does; I haven't used it) load a minimal root fs, possibly from an initramfs, present the user with options, and then switch the root filesystem (which is what initramfs kernels always do), but obviously there is a bit of work involved. Alternately, you could write your own bootloader code, but this is even more work, and may require some proprietary knowledge (I'm not sure). 

The recording stops when you call , or when something goes wrong. The purpose of is to check that the recording process hasn't stopped due to error, which will otherwise go unnoticed until you call . It apparently will throw an exception. That being the case, you probably want to wrap it properly: 

1. Sometimes hardware also has direct access to system memory without having to go through the CPU (and OS) as well. I believe video memory works this way, and the camera may also. 

Of course this mean tweaking some source; almost certainly that for the Adafruit board is available. Likely both of them use a device tree layout which will need tweaking as well. Neither hat is stackable though, so using them both at once is going to get a bit messy. Further, even if they were stackable, those pin correspondences are hardwired on the hat, so presuming the tweaks above work out, at least one of them cannot be put directly on the Pi's breakout. 

1. Note, again, you can't simply "keep reading until the message is over" because there is no way to say when it is over unless you know how long it was supposed to be to start with. 

I don't think it would be particularly different than a regular x86 machine (it is a "modern computer"), except, as you point out, it is single core. Although it is not so long ago most desktops were too. The linux kernel predominantly used on the pi does not appear to be significantly modified beyond adaptation to the hardware, and the userland is completely standard. So that's a modern, multi-tasking, multi-user, multi-executing (except, again, there's actually only one core in this case), general purpose OS, the source code for which is freely available. In short, I don't think there's anything special about the pi with regard to this purpose, either in the sense that it would be especially good or especially bad. However, one thing to keep in mind is that if you want to compile on the pi, it's slow. Way, way slower than a decent desktop. Cross-compiling is not a problem, but if for some reason you want to use a simulator, your choices are going to be limited because it is an uncommon architecture (although a lot of older android devices, including the original Samsung Galaxy, are armv6). On the other hand, "limited" doesn't mean non-existent, since QEMU apparently has a option. 

If the driver works well enough for that, most likely it will work in general. If the driver did not work, the interface would not be listed at all. 

Some of which are empty mountpoints -- e.g., the first partition is in when the system is running. However, if you are looking at the card on a windows machine you will not be able to see the second partition, so it may appear as if there is not much there. 

You need to compile Stunnel from source; it looks like it is only distributed precompiled for android or x86-64, which is not uncommon. Fortunately there is a package on their downloads page. Open that up: 

By definition there is a simple logical reason this is not possible for anything. It is not possible for your car. It is not possible for the International Space Station, you, your cat, your house, or a Raspberry Pi. I'll explain this by analogy to the car. Let's say a car manufacturer decides to develop a phone app which allows you to remotely check "which parts are not functioning". Obviously this is possible to an extent. For some things (e.g., proper compression) this may require the car's engine be started remotely. It also obviously requires a complex array of sensors be deployed throughout the car. Depending to what "an extent" we want to go, it may also require the car drive around remotely. Doing this very thoroughly could add tens of thousands of dollars of cost to the car. What's more, as you add complexity for the remote sensing of non-functioning parts, you increase the potential for the remote diagnostic system itself to malfunction. Having a car drive itself around remotely in order to check if it works properly is not sane. If sanity is not a concern, you could then set out to spend an infinite amount of time integrating an infinite arrangement of redundant sensors to check the sensors that check the sensors that check the equipment, etc. The further you go down this path, the more absurd it gets, and the less interested consumers are going to be in your car. People do not want a car where millions of R&D dollars have been wasted on a system to check whether or not the car works. They want a car where effort is focused on making sure the car works. Going back to your actual situation, in comments you have made it clear that what you want to check is not really just a servo, it is, more generally, the state of anything connected to an output that does not have a corresponding input. The answer to this question is: No, you cannot verify an output is connected to anything without a corresponding input. However, you can make sure you use appropriate quality components, attach them properly, and do testing and quality assurance on site, before they are shipped out. This may mean hiring skilled staff, etc. There is no magic bullet by which you can overlook poor practices and insufficient resources. If you aren't sure whether something is going to work or not, then you should be honest with the people you are selling it to, or else admit you simply cannot provide what is required.