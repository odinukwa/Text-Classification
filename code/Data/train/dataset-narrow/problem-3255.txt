We need to make sure the USB is connected when we setup your sub directories, so we can assign permission to the folders on the USB. The funny thing about USBs in linux is that you can create the sub directories without the USB connected and the directories will really be created, but once the USB is connected, those directories will not show up until the USB is disconnected once again. So what is happening is the pi see's those directories as real directories, because they are, but when you mount a USB on top of those directories they no longer exist since the USB is now actively showing its directories. So, we need to make sure the sub directories are being created while the USB is connected so we can setup proper permissions on the directories. There are several ways to determine if your USB is connected and working. The first and easiest is using "lsusb": 

Basically, we want to mount the USB drive on boot at the right mount point and with the right permissions, and skip mounting if it's taking too long or not physically connected so the pi can boot the machine just in case the USB is disconnected. I like to reference the Ubuntu Community Fstab document, since it's pretty good. The syntax of your file would need to look something like: 

Be sure that your Operating System uses systemd before writing a systemd service file. The howtogeek article uses init.d scripts instead of the newer systemd service. The delgue article I linked shows how to convert init.d scripts to systemd if your Operating System supports it. The only changes I made in my config file,"/home/cjohnson/.config/deluge/core.conf", are location options where I want to store my data. In your case, these need to point to your External Drive once we are sure it's setup right: torrentfiles_location autoadd_location download_location move_completed_path Once the drive is mounted, we need to create the sub directories that you would like, in the howtogeek article it's the folders under /media/USBHDD1/shares, and we should be able to use this command: (We will have different folder name rather than USBHDD1, I'm just using that as our example and our $USER will be whatever user we determined to run deluged at boot) 

What user account are you using to login to the pi? The boot script and deluge auth file from howtogeek are setup for the user "pi." Is that the user account you are logging in with? If not, we need to find out who you are logging in with so we can get the right settings in place. I personally prefer to run deluged as my user I log in with because of all the permission problems I ran into. The command "whoami" will print to the terminal who is the currently logged in user. 

Individual crimp pins in heat shrink work well. A wire wrap tool can also be very handy for interconnecting boards in prototype systems - although not designed for it, it will typicall work on 2mm headers as well. 

The 5v pin on the Raspberry pi is simply not controllable, at all. Your edit provides a picture of a relay module with an optocoupler input. It is quite likey that you can successfully drive this from a pi GPIO output (I've used similar ones with an ATmega at 3.3v), ideally using where the pi connects to the cathode of the LED and the anode goes to the 3.3v rail through an appropriate current limit resistor (the resistor can really go on either side as long as it is in the path). You would then output a "low" to enable the relay. Ultimately you should determine the part number of the optocoupler and check its data sheet for the required current. If that is more than the pi can handle, you can use the pi to enable an NPN transistor which functions as a low-side switch in the optocoupler LED's drive circuit (much as how TV remote projects typically drive high brightness IR LED's), but that will probably not be necessary 

The properties of a USB serial converter have nothing to do with the hardware of the hosting system, but only with the USB serial chip itself, and the software stack of the hosting system. The pi should be using stock Linux USB serial drivers. Therefore, you can enable/disable the linkage of DTR to port open/close via the usual Linux method of clearing the setting as documented on the Arduino site and elsewhere: 

Yes, you can use multiple input circuits driving multiple GPIOs, provided that the voltage range is appropriate and all share a common ground with the pi. No, this is not a particularly good way to do time measurements, as the pi typically runs a multistasking operating system such as Linux (or, if you must, Windows) and that is notorious for resulting in a substantial and variable latency in responding to external stimulus. In theory you could overcome this by doing the timing in the kernel, or better yet using a realtime kernel - but it is a lot of effort for marginal results when the real issue is that the wrong platform has been chosen. Theorectically, if you wanted to do it in the simplest way anyway you could use another checking the other photogate input, or better yet use something blocking on a read of the interrupt node for that gpio, and hope that this results in the scheduler waking you up as quickly as possible. But it will only approximate the timing. If you want to build a good photogate timer, use a barebones microcontroller and/or feed your inputs directly into a counter timer block's capture trigger. This could potentially be a $1 class part accessorizing the pi, if you really need the capabilities of that for other purposes. (Or to put it in hobbyist language, this is properly an Arduino problem not a pi problem, but you could potentially use a baby Arduino to accomplish it and report the time difference to a pi). 

Using the lite image instead didn't make a difference. I also bought a new cheap Fujitsu card that only has 2GB and that card flashed just fine. My Micro SD cards: 

Any ideas what I could be doing wrong? I mean the Raspberry Pi is quite obviously running and even connecting to my WiFi and responding to pings. It seems like the ssh service is not running or maybe there is a firewall rule blocking port 22 on that device? 

First of all the correct place to put the ssh file is not the directory as the official article claimed. The right place is on the other partition which is called , right in the root directory. The reason why it did not work for me initially, was that the Micro SD card that I was using was broken in some way. I can't properly read from the card anymore and the main partition just disappeared over night. I repeated the steps from my question using a new Micro SD card and everything worked fine. Not even a single problem. 

It almost seems like there are issues with cards bigger than 2GB. What am I doing wrong? Edit: The output of : 

Edit 3: I just bought another 8GB Micro SD card, this time from the brand 'Intenso'. - Same issue with that card. Edit 4: Tried it with Etcher instead of dd. - Same results. Edit 5: I tried it with dd on a different computer and it was able to correctly flash all my cards. But I still need this to work on my system... 

I have a couple of Micro SD card here and it seems like only some of them can be flashed correctly. No errors during the flashing process, but only the boot partition turns out to be mountable on my Linux computer and so the RPi fails to boot it (). At first I assumed that the issue was just with a very old card that I had lying around (broken sectors or something like that). But now I have bought a brand new 16GB MicroSD card (SanDisk 16GB 80MB/S), and I get the exact same result: Flashing seems to work, but only the boot partition becomes mountable. I flashed using: 

I have a Micro SD card with on it. I confirmed that the cards content matched the img file exactly. Now I put the card into my Raspberry Pi Zero W and connected hdmi, keyboard, mouse and finally power. When it was finished booting, I clicked the WiFi icon in the top right corner of the screen and selected my WPA2 home WiFi, entered my password into the "pre-shared key" field and clicked ok. Nothing happened. It's not connecting. In the past I have always connected by manually adding the credentials to . And that works fine. So what is going on here? This must be a bug in the image, right? Is there a known way to fix this? Btw another problem most likely related to this one is that I cannot use raspap-webgui. I mean I can open the web interface, but when I click something, for instance the button that enables/disables wlan0, nothing happens. Also, I should mention that I'm currently unable to re-flash my cards properly because of another unresolved issue. So flashing a newer image is not an option atm. 

It doesn't sound like the geometry of standard breadboards and especially the connections within is likely to be a good fit for your project. You might be able to use one of the smallest breadboard modules everywhere you need something. Or you could buy just the terminal strips usually found on the outside, and not the "IC" modules that form the core of most breadboard setups. But you might also want to look into other prototyping technologies, such as point to point wiring, pre-drilled generic PC boards, wire wrap, dead-bug construction, even prototype PC boards. 

You should not be running the power for a stepper motor (or any other moderately hi or pulsed load) through the pi, period. At the least give the load its own wiring directly back to the supply. While it is true that higher voltage supplies can yield much better stepper motor performance, a boost converter is going to be a poor way to do this. If you want to run your motor at 12v (say with a ) you should use a 12v supply, not one upconverted from a lower voltage where higher current would be required. If you have a good supply in the 12v range you could consider using a buck regulator to also power your pi from it, but you may find it simpler to use independent supplies for the pi and motors driver. 

First, your diode is misplaced. It should be placed in reverse orientation, in parallel with the FET. Where you have it in series, it is simply reverse biased and will prevent the circuit from operating. Next, an IRF510 is a dubious choice. It is both delicate (subject to damage from static discharge) and has a threshold voltage which may vary from 2-4v, while the pi only outputs at most 3.3v. To utilize this FET well you would really need a gate drive circuit - it's specifications are characterized at a gate drive of 10v. What current does your solenoid draw if you connect it directly to the 12 supply? If it is not too much you may be able to use a simpler NPN power transistor circuit. Or you could use a small relay (driven by a small transistor or the optocoupler version importers sell everywhere) to control it. 

Or replacing /dev/ttyUSB0 with whatever device file actually corresponds to your USB serial port (for example, the first Uno connected would likely be /dev/ttyACM0) Even with regard to the PI's own native serial port, this behavior of DTR is ultimately under software control - anyone who argues otherwise is ignoring the fact that it is only the Linux driver, and not the hardware, which has any knowledge of the port being opened or closed. The actual port hardware can only tell that it is being read from or written to or reconfigured, none of which are actually synonymous with opening the serial device.