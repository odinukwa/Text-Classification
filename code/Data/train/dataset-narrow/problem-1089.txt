Good, you made it this far. If you're anything like me you should be almost translucently red with anger by now. Please understand that I was in the same place as you are now - probably worse, as I didn't know much about NaCl or authenticated ciphertext. Unfortunately I don't think your code has any value. You should see it as a good learning experience and a reminder not to write wrapper classes. And you should not do this even if you're going to be an absolute expert in crypto. Otherwise you are going to spend a significant amount of time in the future trying to remove your wrapper class from the code base. Been there, done that. 

You're creating a CBC wrapper, but your wrapper uses HMAC for authentication. This is great, but you would not expect HMAC for a CBC class. Even worse, you're making the mode of operation part of the interface. This is the wrong way around: a mode of operation uses a block cipher to be implemented. And a block cipher certainly doesn't include HMAC. Furthermore, you're also adding HMAC for CTR mode, which has many uses for specialized encryption constructs, which would not be available for your class. I don't think you should do this, but if you do you should do this by creating a separate class that performs the calculation of the authentication tag. Inexplicably, you're not adding HMAC for the old CFB mode that nobody uses anymore. That means that your code is not symmetric. Fortunately you do use encrypt-then-MAC. So your complete design is off, to the point that it should not be used. 

Your constructor calls swap, which receives a reference (meaning you are actually creating a copy here). Either way, you don't need to write your own swap for this class. For this constructor, consider this implementation: 

do not use and (use and instead) the code comments you use are mostly useless (comments should add details on "the why" of things, not on "the what"). Example of bad comment: 

I renamed the APIs you used from callback1/2 to on_data (same name) and unified the implementations of fireCallback1 and fireCallback2. 

This is good enough to be used widely (IMHO), but it could use some small improvements :) : Since you are using it to measure execution time, I'm not sure you need to support both milliseconds and microseconds clocks (I would just remove the template arguments and work on microseconds). As it is, the class does too much (timing code, string manipulation and measuring arbitrary intervals). Consider how your client code would look using this public interface (this is a similar class I wrote a few months ago): 

As a general rule, never use macrodefinitions to write code. In this code, you are better off writing the output code directly. Also, you never use err macro (so you might as well remove it). You should also refactor this code: 

If you want two versions of the code, consider using templates (instead of conditioning the code to the macro): you will only compile once, and without imposing flags on the compiler/build system/ide. 

Your code contains code to perform transport security and - what I presume is - in place encryption using passwords. It's therefore try-to-do everything code. That kind of code should not be written in the first place. Cryptography related code should be written with a specific use case in mind. Generic crypto code should be a very well written API so it can be used for those kind of use cases, and this is not it. Your transport mode security seems to contain key agreement but not authentication. There doesn't seem to be any warning about this in the comments. 

In general you should try and avoid floating point operations for any cryptographically specific code. Floating points have issues with regards to precision, and even I don't see any issue for this specific code, they always require special attention, e.g. during reviewing of the code. Similarly, using recursive code is strongly discouraged for cryptographic algorithms. If your code can be coded using loops and only local variables you should really do so. I imagine that goes against the idea of Rust (and is thus up for debate), but crypto code generally requires special attention. If you keep to recursive calls make sure you document them as such, both inline and in the function description. Although you nicely implemented the destructor it makes more sense to create either a class with just a (now called I presume) or simply keep all the data in parameters / local variables. The idea of just keeping the is that you may reuse the object to derive other keys using the function but with different salt / info. In that case you obviously need to retrain the to clear the input key material. Note that the internal key handling (padding, initial hashing) of HMAC is always the same. So a sneaky speed up is to perform pre-calculation on the salt which acts as the HMAC key (mainly useful if there is a lot of output expected, this speedup matters more for e.g. PBKDF2). 

Now, generate reads like prose. You don't really care when you look at it that print_body is a template method (at least, you shouldn't). You can follow the steps of implementing just by one look at the code. Just think of as client code of your private APIs, and then the functions are APIs that need to "tell you what they do", in their names. Basically, I focus on what the function looks like in client code, instead of what kind of place it has in your class hierarchy (or most other technical/implementation details). Note: I didn't know what name to choose for the generate function (the "PrintReport" in your code) until I wrote an example of client code (and I thought "of course, you generate a report!" - it comes naturally off the tongue :) ). Maybe for you, "generate" will not sound natural at all. Edit (addressing question update): 

For a professional cryptographer (which I am not), it would be very easy to crack, due to the following factors: 

The algorithm is a shallow comparison between the documents: it is possible that one of the children of site_entries has a corresponding child in the other document (by name), but other changes are present between the two (like subnodes). Was your intention a shallow comparison algorithm, or is your implementation incomplete? That said: 

All these can be avoided by not returning a raw pointer from your class. Consider returning a instead, and using other means to edit or set the buffer, than this API. You say: 

A different idea of handling this (for you to ponder over). Define your protocol somewhere and store a protocol version in your hash string. You could even use that to replace the salt size, iterations, hash type etc.. Then if you choose a higher iteration count you could just update your protocol version. 

You are allowing direct access to the elements rather than just the content. This allows the user to create any kind of structure, including lists that keep going round. Instead of going through the elements by exposing them, I think you should create an iterator that allows you to go through the elements and then retrieve the contents. If you remove the first element with a specific content then you should probably call that function . Note that you are combining two things here: searching for an element and removing that element. Although a linked list is generally not fast when it comes to indexing elements, you could still implement indexing. Keeping the size is definitely a good idea. This is obviously a bit of problem if you allow direct access to the elements. Functions like are dangerous as you don't know the size of the list or its elements (besides that, how do you know that T enables this function, am I missing something?). If you allow direct access to the elements then you may be able to delete the element while an outside user still holds onto a reference to it. 

After making head and tail private, you will need to add iteration and/or data retrieval API to your class. When designing a class, consider how you will look at it from the perspective of client code, not how it is implemented (i.e. you are implementing a "list of instances of T", not a "list of instances of Node"). That means you should not have a constructor receiving a Node*, but a constructor receiving a T instance. Your print and printBackwards functions should (probably) receive the output stream as a parameter (then, you can use the same code to print to a std::ostringstream, std::fstream, std::cout and so on). Your copy&swap implementation of assignment should be written like this: 

The interface doesn't indicate ownership and makes you interrupt your coding, to look at the implementation, just so you know how to write client code that doesn't leak or crash. Solutions: You could change your interface to take a instead. (Similar to passing by pointer), the only drawback is that you need to make sure the tasks you pass to ScheduleTask must still be in scope until the ThreadPool stops running (in other words, you can still write the nice function). This is better, as at least you don't need to wonder if it will delete the task (which passing by pointer may, or may not suggest). Better yet, change your interface to take a std::unique_ptr instead: