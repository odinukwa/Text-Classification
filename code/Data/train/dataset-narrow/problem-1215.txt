It's not clear to me whether you need to store the variables ... etc. Assuming that you don't, you can make the function a little bit simpler. 

An Ace is to be put before a Two. Use the following order of Suites: Clubs, Diamonds, Hearts, Spades (the ordering used in the game Bridge). By that logic, Ace of Diamonds is greater than an Ace of Clubs. Using the ordering used in Bridge, Two of Diamonds is greater than Thee of Clubs. 

Suggestion 2: Remove redundant data You are using to keep track of whether a slot is open for placing a marker. You can just as easily use to keep track of that information. If is , it is open for placing a marker. Otherwise, it is not. Suggestion 3: Make a array You are using an array for board simply for the convenience of printing the . The true state of the board is a array. Hence, I would suggesting using: 

If you have to modify every time a new type of is introduced to your program, it violates the Open/Closed Principle and is a symptom of sub-optimal design. My suggestion will be to make -specific functions external functions and not member functions of . 

I understand that the reason for your post is to find a method that will be faster than the one you already have. However, the posted code has the potential to access memory that is beyond the valid limits. For the sake of making a point, let's say that on your platform, is . Your input strings are and . Given that, evaluating will end up accessing memory past the terminating null character of . In theory, that is cause for undefined behavior. Here's my updated version of your function to make sure that you always access memory within the valid limits. 

Update, make the name of a It turns out the name of a can be a consisting of characters for which is . Changes needed for that: Change to 

This will work only if you declare the function a friend of the class. Move parts of the class to the bottom The users of the class care only about the section of a class. Hence, it makes sense to put them first in the class. The section of a class are, to a large extent, implementation details. It is better to put them last in a class definition. 

unnatural. I would expect to act like a pointer to since it's the value returned from a function named using an object of type . It would be more natural if: 

With this approach, doesn't need to have any knowledge of as a class. If there is a possibility of conflicting global names, you can put in a unique GameManager.h 

Since you are dealing with only integral numbers as input from users, I would create a helper function to get input from users. 

If you would like to use a for that function as well, you will need to use another class called . That is analogous to the use of and in the container classes in the standard library. 

After seeing your code the first time, something didn't feel right. I couldn't quite put my fingers on the problem. However, after going over the code a few times, I came up with a few things that can be changed to improve the code. Using the right nomenclature I think the nomenclature is wrong. Metre, kilometer, and mile are better thought of as units of distance instead of being distances. 12 metres is a distance but metre is not. Your use of distance and quantity is not quite right. Distance is a quantity + a length unit. When we say distance from point A to point B is 5 kilometres, 5 is the quantity and kilometre is the length unit. Design of the and various classes It occurred to me that your design violates The Open/Closed Principle. You have the following that's the lynchpin of your entire program. 

Other suggestions: Add functions instead of This may be a matter of stylistic preference but I think it is better to use: 

I am going to suggest couple of changes to your code. Providing a clean way to terminate the program Your code does not provide a clean way to terminate the program. Once started, you have to terminate the program by pressing the equivalent of Ctrl+C, killing the process form the Task Manager, or some such indirect mechanism. There are lots of ways to terminate a program cleanly. One of the easiest things to do is look for or as the first character of the input to exit the program. However, if you allow for such a method, you'll need to change how you receive user input and process them. Instead of 

Such default values don't really make sense if the value is not valid. Imagine if you call the function like this 

Note that here I am using instead of string concatenation, YOU SHOULD always use command parameters to avoid . Moreover, the proper way for closing a connection is not calling explicitly nor calling it in a , the proper way is using statement. And as mentioned in previous answers your queries can be reworked to stored procedures that accepts parameters from your application, and there is a lot of benefits from doing that. 

suit and rank fields should be declared private, no need to share things and deal with infinite number of states. 

has a high dependency on , why not to inject it and make the code flexible (easier to test and change). 

This code here is a bit dodgy, you shouldnt never trust values you getting from the , so you got to handle the exception and refuse the request if the value is not parsable to 

Note: I don't claim to be an expert in principles, I do understand a bit though. Back to , violates the principle (The most frustrating concept to me). That is, when you add a shape you have to go and modify the code by adding an , this can easily solved by using , 

Please note, that CircularLL is not the best name for this class, I would call it instead. One more thing, initialising instance variables to is useless because it's done by default. 

and by doing so your types will be responsible for converting to in their own ways. The code smell in your code is adding to the factory. are factories but in a way, so instead of returning converted object immediately, I will return you a function that knows how to convert to objects. 

Looks fine for me, but such a class should be , because it does not make sense to be able create instances of this type. 

Because of the short circuit here the function will not be called if value is , which is not the case if you pass the object directly. 

The first thing you expect from a queue is to be able to , and for some reason you are hiding this function by declaring it where this should be . Do I really need to care about growing and shrinking the array in this queue, I am not supposed to know that they exist, so these should be declared . 

There is no much code to review here, but I spotted that is not . You can use an AtomicInteger instead. 

You might have notice that I called it instead of , because a map is a collection that holds things and things are plural. Note: If you need to iterate over a map, don't use iterator, use instead. 

Your code will be easily broken if someone adds a node to the , and your code should be as flexible as possible. Never do such an assumption (It's gonna be the first node) Your method is blocking, consider making it . 

You mentioned OOP, and thats great, and OOP is all about code reusability and extensibility,and this code is a good example of a Candy Machine Interface. And that is, users of this class might do mistakes while using it. users could call the static the method before calling instance method and this would lead to wrong routes because weights weren't computed properly. You should try your best to force right behavior. 

I wouldn't start this Task in the constructor as you doing with the ,thats quite dangerous, I would rather have a method called Start that does the heavy stuff where I am sure its gonna get called after the object got constructed properly. ADVICE: Such a data structure is reasonably hard to implement properly, I would try to find something implemented and tested. 

But the most important thing is, forget about using a for that. Open a new connection and close it afterwards, and will take care of connection pooling,you might need to add to your . 

Generics would be quite useful here, because your only works with , so your classes could be reworked to take type parameters 

. note that your connection is never closed, and thats a memory leak, you could make your class and close the connection there. 

The contents of will be different from your posted code due to use of an array of to hold the data. That will simplify to: 

Does not use . Does not use dynamic memory allocation. Does not use virtual member functions. Uses class templates for and . Defines the units in an extensible manner. 

you allow multiplication of matrices that don't result in a square matrix. However, if you multiply the following matrices with just that change, 

P.S. I have left out the code dealing with angles since they can be updated in a manner similar to distance. Here are the files and their contents: length_unit.hpp 

Notice that does not know anything about specific types of units. It is able to implement its functionality without knowing about them. cartesian.hpp 

That produces a compiler warning from g++: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] I suggest changing that to: 

Using vs hand crafted function to reverse a string You can reverse a string or part of the string using like you have in your code: 

Then, in GameManager.cc, you can define as a or even a . You add member functions that capture distinct functionality and don't have to worry about whether a function needs to be or The implementation of can be: 

length_unit_impl.hpp This file has couple of helper function templates and a class template to make implementation of concrete s as painless as possible. 

Remove the member variables and With a as the member variable, you have access to and . There is no need for storing redundant data. Argument types in the constructor Since it makes no sense to have negative values of or as inputs to the constructor, I would make then an unsigned integral type. 

That will also allow you to print a to any . Use manipulator in the spirit of the standard library Instead of using 

I don't know that they compute but they compute four different things. It will be easier to understand your code if you can give those computations a name and put them in a function. 

The only thing I could think of that would make your program potentially faster is: Initialize the member variable using initialization list syntax 

For the same reasons as above, can be removed from being a member variable and used as a function local variable. For the same reasons as above, can be removed from being a member variable and used as a function local variable. I don't see the need for as a member variable either. You are asking the user to provide it at the time of encrypting the password and decrypting the password. Why store it in the class and the file at all? It can be used as a local variable in the functions where it is needed. 

This resolves both issues. Suggestion 2 The member function seems a misnomer to me. What's being "added" in the function? A better name would be . I would go further and create two functions and . 

I think or is a better function name than . When the function returns, the input indices are sorted/ordered. 

Main Suggestion I think it will be useful to have couple of overloaded functions, one for working with s and one for regular s. With a , pay the cost of making a copy, reversing the copy, and returning the copy. With a , you can avoid all the above costs. You make all modifications to the string in place. 

It is inefficient since you can avoid half the work by realizing that if the number is not even, it will never be divisible by 2, 4, 6, etc. Here's my suggestion for an improved version: 

The generic target building rule will take care of building the executables from the dependent .o files. 

It's not clear to me what you are trying to do here. I think you should change the type of from type to and have just one line to increment its value. This is how I see the loop. 

Make a base class You can simplify the code in a few places by making a base class and creating two sub-classes: and . Refactored Program 

Now, you can use a class that captures results of an operation or a function call. It depends on and as its member variables. Of course, you can add as many convenience functions as you see fit to it.