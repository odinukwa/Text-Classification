Your second option is a little more legible than the first but the best way to improve both the legibility and the clarity of your code is to completely separate the code which generates the default parameters from the logic which decides whether or not to add the default parameters. Consider the name of your method: CreateDefaultParameters. This name is misleading. It will not always do what its name declares. Another consideration is that you have mixed different levels of abstraction in this method (the low level work of generating each parameter and the higher level logic). This is only made more clear if you take Ben Aaronson's good advice and create a function to check the parameter status. My advice would be to 

Rectifications can only be actioned once a car is added Cars are not removed from Rectifications once added 

Your code will tolerate or as input lines, converting them both to . That is because it asks for the first two elements This can be avoided with pattern matching and a partial function. So the second, transformation could be rewritten with 

But there's more. To actually make numeric, you have to implement the rest of the type class. Here's an extended version of the companion object, which does just that, without adding any more methods to your original class: 

As a general point of Haskell style, you have "take N from a list" upside down. You are generating a list of numbers 1 to N but ignoring each number (replacing it with a function that takes no arguments) simply because you want N items in the list. It could be N of any given integer. It could be N of anything if you are just going to throw it away and replace it (hint, hint). The idiomatic (and more flexible/reusable) way for those tasks in general is to generate an infinite list and take N from it (since laziness means that the elements you don't take aren't actually generated). So both 

(Your k and t variables are mutable vars rather than immutable vals, to no purpose, but I shan't be keeping them. But never use a var unless you really have to. Go immutable by default.) One way to address point one is in a for...yield block. This code 

Some of the individual gsub calls are fragile in themselves but none of that compares to the basic flaws of the approach. Having said that, the way you are using regexes is duplicating code. You have typed each matched pattern twice: first in the regex, then in the closure. This would not be necessary if you used capture groups and back-references. 

My example above is probably a little over-specific. It would be more flexible just to have a conditionList onto which could be pushed a sequence of functions returning booleans. But you get the idea. By the way, I used traits in case you wanted to be able to create classes which did radically different things but also implemented checks. However, if you made indexCheck a class rather than a trait, you could do things like building maps of anonymous classes, like this: 

Meaningless output Your function as written does not seem useful. There is no way to assign meaning to its output for two principal reasons. 1. Non-matching sequences reduced to single item lists As @janos pointed out in his comments, any sequence of items which fail the predicate will be transformed into a sequence of single-item lists in the function's output. While this does mean that any list in the output with size > 2 will contain only matching items, there is no way to tell whether a list of size 1 contains matching items or non-matching ones (without reapplying the predicate to each). If this were fixed so that non-matching sequences were not broken down, then the output would be alternating matching/non-matching sequences, which would be marginally more useful. Except that... 2. Nil in (Nil, _) output from span is discarded If returns - showing that not even the first element satisfies the predicate - you discard that . This means we cannot know whether the first list in the output matches the predicate (without reapplying the predicate). This means that, regardless of whether the problem in point 1 were fixed, gives the same output as Possible Improvements Minor: still returning List[Iterable[T]] If we stick to your basic design, returning , but 

Your base class is a node when it should be a tree Wrapping the nodes in a tree class which knows nothing other than it contains nodes is artificial and obstructive 

Recursion usually makes backtracking easy. If it doesn't, your recursive function is probably doing too much. Yours does. The reason you built it that way is because your helper function returns a binary (boolean) value but you actually have 3 possible states at any one time 

As gallais has mentioned, the cost of your calculations increases as x increases. I'm always struck by how few people, when faced with fizzBuzz or similar challenges (like finding the first numbers which are divisible by 3 and/or 5), realise there is no need to work backwards from x to the original primes. It's much more efficient to work forwards. After all, you know the starting primes, 3 and 5. One might consider, for example, generating a map where the keys are the numbers 1 to 100 (or x to y) and the value is . Then iterate over the multiples of 3 between x and y, replacing the value with and so on. Then iterate over the keys of the map in order, applying the value (a function) to the key. There are smarter (and more efficient) ways to work forwards, but it illustrates the principle. Here's a relatively naive forwards-iterating implementation of I just thought up. 

calls the description print method prints a list of the text of each , labelling them , and so on, in sequence asks for input. returns the contained in the field of the chosen decision. 

You have the right basic idea - pass a list of conditions - but the implementation is wrong. Yes, you should avoid ; it is a dangerous source of potential error (and performs poorly as a non-bonus). You might put anything in there. You might not even notice a typo which caused nasty side effects, since Python has a very tolerant definition of truth and will be happy as long as the expression evaluates to something. Instead, why not pass a list of lambda functions? Then you just call each function in turn. Much safer. For example, you could build a list of tuples (condition, error message) like this: 

Note that it can work from any starting point (even negative n) for any range, within the limits imposed by . Now, there are smarter ways to do this kind of thing (and certainly more idiomatic and generalised), but that example is still more efficient than 99% of the fizzBuzz attempts I see, Only does any arithmetic once. Work forwards, not backwards. Don't go looking expensively for things you can easily generate. Challenge: consider a solution using 

Once you have implemented add you can throw away isBST because your tree can't be created invalidly (Well, rather than throw it away entirely, move it into your tests). Other methods you need to consider implementing: 

Done. Annoyed that the final result is in reverse order? Reversing one final list is cheap compared to appending to each list in the map, every time. Note that you can dispense with having to manage the index-accumulator by folding over 

Compare this with the complexity, lack of clarity and fragility of your if...else if chain. It is hard to compare your different conditions, hard to see if you have been comprehensive and nothing about an if chain even compels you to be testing related conditions - you can have anything in each condition. This is a naive example but it is a good place to start. That said, Ben's is the best answer. There is a very small amount of code duplication in this version. The final three pattern matches do the same thing with only a minor change to the input parameters. In such a small, easy to read set of code this is really not a sin (and addressing that would make the function structure more complex and less clear). Replacing the recursion with a fold, however, would remove the duplication, because the fold would take care of the repeated application of the function,which could be reduced to a simple closure adjusting the level. Other notes about this solution: 

You may balk at that last point but modifying the data held at any one node is a dangerous and pointless thing to do. The way binary trees work, it doesn't even make sense. When adding a value, the only places you would want to change left or right is at the node where you insert the value in place of an empty tree (possibly having to move the left branch to the right branch, to preserve ordering). Adding a value to an immutable tree is only marginally more complicated than to a mutable one and much safer. Also, you regain the option of variance (if you want it, although I recommend against). My final recommendation: throw away that isBST/isValid method. It's pointless... That's not an implementation Nothing in your code actually implements a binary tree. All you've done is provide a shell into which data has to be manually inserted, with a validation method to check whether the manually-constructed tree looks like a binary tree. But the rules for adding values to an ordered binary tree are simple (OK, more complex if it's a balanced tree). Your type should know how to do that. If you think about it, it shouldn't be hard to create an add method along the same lines as isValid. I'll start it off for you 

Io has no switch or case function and the community doesn't want one. lists (using a numeric index lookup) or maps (using a string key) are sometimes used for very simple switch-style control flows but that doesn't work here. 

This will return Option[List[(String, Double)]], containing either a real list or None. If any of those stages returns None, the following stages will not be executed and you just get your None back early. You can pattern match against this output to return the contents of Some(list) or List() if the output is None. Note: I took the annotated val list out of there, so you would either need to have specified the return type for a val to which you assign the output of the for comprehension or put it back into the yield block. Note how I turned your if...else expression into guards. Can you see just how much simpler the code is and how each conditional is paired with the appropriate object? Particularly since the else was just returning another empty list. This way, it fails and returns None. "for comprehensions" can be overused in Scala, but this really is where they shine. You correctly chose Option, but possibly the best thing about Option for any Java coder is the way it can remove boilerplate and defensive coding. Your code still has the defensive coding, while the for comprehension just throws all that away. Learn to be free ;)