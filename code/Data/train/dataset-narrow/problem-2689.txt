I want to write a shader/filer probably in adobe Pixel Bender that will do the best job possible in emulating the fill of an oldskul monochromatic arcade CRT screen. Much like this here: $URL$ Here are some attributes I know will exist in this filter: 

I don't understand why they XOR the subtraction of A from that formula? I don't understand what it means to do exclusive or a substructed set?I want to understand it better. 

Now, considering you already have that system in place, you wish to extend it for items that are variations of these items like enchanted versions and perhaps cursed versions and what not. The issue is that we don't know exactly what kinds of enchantments are available in this game. In your specific scenario, I would list the enchantments of each item, after it's Enum id. for instance, if up until now: 

The question is, could you please provide any other attributes that are beneficial to emulating an arcade CRT feel and links and resources on coding these effects. Thanks 

Working solo on your own on making something that has already been made will not make you a valuable developer to anyone because you will not be productive in truth or a good learner for that matter, you will just copy existing bits of code and maybe learn to read and understand them. As the old Pokemon saying goes, "It's not very effective...". The worst part is that this kind of approach is not easy to keep up with because there is not gratification in it so you are running on raw will power which has been scientifically proven to be a limited resource to human beings. You need to do something that provides daily gratification or your will probably not be able to keep it up. So to sum things up, an Engine is emphasized because you can get things done with an Engine and you are far more likely to succeed that way. Even great game creators relied on someone elseâ€™s previous work and such is the nature of progress. You need to understand the big picture and know how to play with the Lego pieces provided by others before you make your own custom Lego pieces. 

If you need to optimize this because of performance issues which is possible since you need to create this array several times every second, use a global one. I am not sure why you would clear it? Where does the data come from? Could you not overwrite the existing data without clearing explicitly? 

Instead of having a switch statement, you could use 'low resolution attributes' to keep things simple. For instance add a density to each collideable object. It could be a Enum to reflect the needs of the game. 

First If you don't want the "small box" to move a lot just increase it's density a lot. Why not do that? Other than the obvious: If I recall correctly, you can detect collisions in Box2d (i.e. set a callback) and there return false to not have the collision handled by the physics system. I think you could have it so when certain things collide with the player, the player does not move at all while when other things collide with her, the behavior is different. 

The only real solution here is to use bilinear filtering. The idea is to let the GPU compute the value of each pixel based on the four sprite pixels that are overlapping with it. It's a common and effective technique. You simply need to place the sprite on a 2d-plain (a billboard) as a texture; then use the GPU to render these plains. This works well but expect to get somewhat blurry results and lose the 8-bit or 16-bit look if you were aiming for it. pros: Already implemented, very fast, hardware based solution. cons: Loss of 8-bit / 16-bit fidelity. 

Should the clients receive a snapshot with all the data in the first place? What about items outside their line of vision? What about fog of war in RTS games? If you send all the data, the client could be hacked to display data that should not be available to the player (depending on other security measures you take). If you only send relevant data, the issue is resolved. When is it vital to send changes instead of sending all the information? Considering the bandwidth available on modern machines, do we gain anything from sending a "delta" instead of sending all the information, if so when? 

Just to be clear, when I say remove I mean that if the lava pit spawns 20 lava balls per 5 seconds and your test character touches two of them, remove these two spawns from the timed spawner. If you can't avoid a specific spike that is there 100% of the time, you could remove it completely or turned it into a timed trap that is active only 50% of the time (like an electrical barrier, a flamethrower or a laser). The same principle regarding the lava balls applies to turrets as well. Also it's assumed you already have an idea for a level design. Racers 

Meaning the camera center is positioned on top of that point. If there's a point in Xc, Yc it is positioned in the center of the screen. The rotation angle is: 

Assuming your grid is represented as a 2d array of booleans (0 for path, 1 for wall) or integers (n for path, m for wall), and the player is smaller than the tiles, you need to check if any of the four corners of the player are inside a wall. If the center of the player's "square" is and the width is then you need to check in 

There are other ways to accomplish what you describe but they require very advance techniques and a very large amount of computation power. For instance, you could: 

The circle class stores the basic needed data for the circle as well as it's collision square index to keep things simple. This could have been stored in some collision class as hash from circleId to collision square. 

When the ship is heading down to the desired landing spot, you can check every frame for the following equality: 

I think a more precise metaphor would be this: The Engine, the body, the lights of the car and all that stuff you probably should never touch (if all you want is to get somewhere) are the Engine. The API is the keyhole in the starter, the wheel, the break pedal, the stick, the gas pedal, the clutch and little plastic handle that you use to turn on the lights and the one for the windscreen wipers and air-conditioner's knob and the radio buttons are the API. You don't need to know anything about the Engine, air-conditioning, radio signal or the light bulb in your headlights to get the car running, playing music, air-conditioned and functioning really well enough to get yourself from point A - to point B. You also don't need to build anything new or modify any of the parts of the car itself. So the car is like the Engine, the Scripting API is like all the controls you take for granted when you ride the car that help you forget how complex the technology behind them is, abstraction. So in short, a scripting API is an hopefully easy way, to control a very complex system you possibly have little to no knowledge of by the use of abstraction, a preferably easy to learn interface and sparing you the need to build these services yourself. You can however still modify things "inside" with some Engines depending on the contract between the company (creator) and the end user. 

I think I know what a specular map is and what it's used for (here is an example). $URL$ One of the models of specularity that are highly popular is Phong. In Phong there is a parameter sometimes called "shininess" which basically controls the size of the highlight. A large value yields a tiny highlight. How is that value expressed in the specular map? It appears to me it is common to use the specular map to control the brightness but not the size of the specular highlight in games. Am I wrong in thinking so? Mind you I'm not adept in game rendering and well aware that the naive implementation of Phong (with ray-tracing) raises the dot product of the vector from the camera source with the reflected vector of the light beam by the power of shininess which appears computationally heavy but still I wonder: Are specular maps by definition without Phong's shininess value? Is that rarely or never used at all in interactive rendering? Is the value simply set to a small constant? 

To increase density, loop again and pick two vertices and each iteration where and connect them until the number of edges is satisfactory to your needs. If you want a very dense graph, it is better if you assume all vertices are connected and pick ones to disconnect instead. 

It is fine to have lots of instances. An instance of a class without virtual methods is just like a C in terms of memory consumption which is similar to . It is no problem. Your concern when instantiating many instances of a class are resource related I would think. 

new answer: In the real world, since this field is not densely populated, simply tell the characters to move in the desired direction and once they approach an obstacle, to go clockwise or counter-clockwise around it (depending on which way is shorter). 

Would personally suggest the following KISS technique to convert uniform distribution to slanted distribution: Randomly (uniformly), draw a number between 0 and 1. Now raise by some const predetermined value (likely) in the range between 1.1 to 7. The larger is, the more slanted (and less likely to hit extreme results) it'll be. Lets call by the power of our . Now randomly pick a (i.e plus or minus [negative, positive]). OK, the of your desired range is 10 == the max from the center. 

This should do it. What we are doing here is computing how much time will it take the ship to reach the ground if it could slow down and stop the moment it touches the ground? If the ship linearly decreases its descent speed and stops completely when it reaches the ground then by average it would travel at half it's current speed, hence which is basically saying -> . We use this to check if indeed with the current engine power, it would take the ship this much time to slow down and stop on the ground: => (how quickly could the ship slow decelerate). needs to be zero when we touch ground. so we get that this needs to occur Please notice that I assume all values are positive scalars. 

If you are not adding something that moves with higher frequency or a different frequency at least then the game is not actually refreshing at a frequency greater than 0.1 seconds. 

The way to achieve a seamless world as big as you could fit on the hard drive, or server's hard drive for that matter is more complex. 1.Yes, first you divide the world into tiny pieces you can load quickly. 2.Then, in run-time you divide the loading process into tiny parts that fit in a frame, so that each frame you only spend the limited x% resources you can afford on loading nearby areas while still rendering the world and perfoming the game logic. 2*. You can also use threads instead of dividing the loading process into chunks, however I found that they could be hard to control and dividing it into chunks offers more optimization. 3.Sometimes the world is randomized, in these cases you may want to save the world slowly back into the hard drive as it is being generated. *Having the world load from the server hard drive may be unreasonable considering the world complexity and the bandwidth allotment and costs. 

Do you need a specific version of Visual C to compile Unreal 4? If so, why? I read in a lot of places: 

Calculate the normalized vector between the interceptors current position and the targets current position . Find such that the length of equals . is the desired speed. It will take time to intercept. If you get a negative value for then they will never intercept. 

When we rotate a object in 2d, each corner is a vector (x,y) away from the center. That vector has an angle. Get the offset of the selected corner from the center: 

Pools are like a recycle been for objects. They are used to avoid unneeded memory management (free and malloc in c, new and delete in c++ ... garbage collection activity in Java and AS3 and so forth). You basically use a container to store objects (or in c / c++ pointers to objects) that are currently not in use but might be needed soon. For instance, instead of firing the CTOR (constructor) to create a new enemy instance, only to fire the DTOR (destructor) to deallocate resources once it's dead; you put a bunch of enemies in advance inside a container called a pool. When they are needed, you remove some from the pool and when they are no longer needed (dead or just suspended) you put them back in the pool. Later you can start resetting the appropriate values and reuse these objects. From what I could tell, the 'AddComponentFromPool' is used when the component inherits from 'ComponentPoolable' which basically means that is relying on pools to help with memory management. 

This should work find with a map that has less than a hundred rooms but could be improved in computational efficiency in many ways (that are irrelevant to the question). To draw a non-straight line use the following pseudo algorithm: The code was taken from here 

There is rarely one correct way to accomplish anything when it comes to design patterns. There are of course properties that we as programmers deem useful. When we are required to reuse or extend code we tend to cherish flexibility. This property is often attributed to decoupling objects. Hence I don't believe the third option is strongly advised. The other issue that was brought up is the amount of granularity that would be preferable; As in should we react to each separate change or instead render the model in it's entirety. This is a tradeoff between additional flexibility and optimization vs. robustness and simplicity. This is nearly entirely opinion based and is heavily influenced by the requirements of the project and the technology that is being used. I always lean towards simplicity because of time budget and debugging concerns. If the system is well made it may leave the issue of granularity to the game designer or rely on the robust solution. I would not advise to force the high granularity approach and I believe it is not forced in any engine I used this far. 

I hope I understood the question correctly, you are asking how to help the zombies navigate to the player? Basically in your game all the zombies do, is find a path to the current location of the closest player? I would recommend running a 'Probabilistic roadmap' beforehand (not during game) and saving the resulting graph data to a file for that map. Than navigating the graph using a BFS or a Dijkstra algorithm for each group of zombies to the node on the tree that is closest to the player. You can find the node quickly by dividing the map into sectors (like a spacey grid) and only checking for nodes in the four sectors closest to the player position. To speed things up I would recommend breaking the Dijkstra process into chunks and running only a little of it each frame. You can then repeat the process once it is finished if the player moves to the proximity of a different node. If you would like more info, please comment and I will gladly elaborate. 

This may not be relevant anymore but I found some useful information about this subject. The gist of it is that you need to program a server (in a programming language) in order to allow multiplayer for users of your game client (the game your users are running locally). The server allows users to to connect with one another (indirectly) and is required to store each user's state as well as send relevant information about each user's state to all users. Writing a game server is outside the scope of one question by all means. It requires a basic understanding of Network programming which you could begin to learn by reading Beej's guide. Bassically, this is pretty advanced stuff. 

If you want a simpler solution still, since the rooms are simple and circular you could do this instead: 

Otherwise, when the object is too close to the first destination, you have to deduct the distance from that destination from the and use the rest of the to move towards the next destination.