Data types I don't mean to repeat my self with the obvious. BUT.. Dont repeat across data types. You have names in HTML and names in Javascript, though not always possible you can often use the data from one to provide the needed info for another. For example the id of the user clickable images "rock, paper, scissors" contain the info you need to name the hands. 

A different approch This answer is not intended as a better solution, just a rework to present some alternative coding methodologies to the problem. Some refactoring. I have done a bit of refactoring, more for my own sanity than out of sound reason and can be ignored (just can't be bothered changing them back ATM) Symbol is a JavaScript type and using it (lower case ) just feels wrong so replaced it with (for want of a better name). Rather than instantiate the object with the object named I used . The rules get converted to operators when the object is created. Tonkenised numbers. One major change is that I tokenized the numbers before processing, the convert the tokens back to numbers when done. As you had it the results made it impossible to work out which numerals belong with which. Though I have not included fractions eg 0.2 that is easy to change in the regExp used to tokenize the expression. The code. Rather than go into detail here is the code as I have modified. I guessed at the type of input you expect, so it may well not handle some inputs. The only place I deviated from your logic is highlighted 

Yep that is a concern, First getting the max integer size even if done in a single pass adds an extra pass on the array that is not needed. 

We only want this to play once. So remove the event from the button. When events are called references the element that triggered the event 

No way! A few displays worth no more. No two devices have the same resources, be that due to hardware limits or current process requirements. You simply can not rely on client devices to give you more than a few screens worth of fast access pixel data. Even a top end machine may have resources tied up in other applications/processes and not be able to handle you page's need for fast random access pixels Consider the needs. A million images at medium resolution (2MegPix) will require 1,000,000(Image count) * 2,000,000(pixel count) * 4(pixel channels) = 8e12 bytes (8Tb of RAM) Nobody is going to download that much information, nor are any consumer level devices able to handle random access to such a large data store in any timely fashion. The solution This type of application need to be coupled to a server. The server holds all the images in a format that allows resolution independent access to the pixels (eg variation of wavelet image compression) the client then requests a view with details about the zoom and the server delivers the images at the resolution required. At no time does the client need to store more than the display size worth of pixels. Some examples of this approch are Google Earth / Google Maps and Microsoft's TerraServer 

Alternative solution The following reduces the number of calculations to about half by exploiting the symmetry of each row. Further improvements can be made by using and pre-calculating the triangle size, then indexing directly into the array, avoiding the expensive array creation and and concatenation for each row. But that would only show any real benefit for very large triangles, where he need to hold all the rows would be questionable. 

The rewrite. So with all that said let's put it together, (I can only guess at the overall requirements of the object so the rewrite may not suit additional behavioural and state management needs) The variable cx, cy, and radius dont need to be exposed so we can close over them, the function getPath look like it is only used internally so again I will close over it. 

Someone that needs the comment to understand the next line would never be reading the code in the first place. Comment only abstract concepts that are not self evident in the immediate context, or comment for machine readers like linters, documenters, builders... etc. Comments are dangerous, as they are never vetted by compilers/interpreters and the debugging/testing cycle, they remain forever in the code. You may change some of the code and forget to change the comment. That comment remains in the code and one day when someone new comes to the code they will be faced with contradicting information. What is wrong with the answer? There is a trap in programming that is easy to fall into and that is over complicating the solution. And you have given a classic example of over engineering a simple solution. Complexity has many downsides. 

Or dare I compound the ternary, i find it much more pleasing to the eye. Warning some will not like this. Note that when you compound ternary expressions it is best to wrap sub expressions in (...) to clearly mark out each condition. 

Javascript is a lot better at handling numbers than strings. Though I am not sure of the range of numbers that the problem will present. If they fall outside the precision of Javascripts double (Number) then you will need to use strings. If not then the following will improve the performance significantly by working with numbers rather than strings. 

How you expose the properties of an object is up to you. In the following the values , are not critical to maintaining state. They can be any value and your code will run fine. 

Running example The following snippet contains an example use. Creates a SVG node, adds to DOM, small delay then updates node properties, adds additional nodes, and starts an Javascript controlled animation. 

When an object (an array is an object) needs to be converted to a Javascript calls its method. For the array the method does the same as the function. Each item in the array is also converted to a string, if needed, and using its . So an array of arrays will be converted to a string by just assigning the array to a string. outputs This means all the work your function needs to do is mostly done for you. You just need to make sure that you add the line break tag at the end of each array. For that you can use the function directly. Delimiting the output. There remains one problem. If you call it will put a break between each item. So you need to still have the test. Creating a second array is overkill as all you need is what delimiter to use. This can be done with a simple expression. 

You will need to use the and traps to get them. The one you don't see. Also you will not see modification that are indirect. 

Ugly is somewhat subjective (2 spaced indents are ugly in my book), and sometimes unavoidable, as long as it is readable then looks don't matter. Code duplication is not a code optimization problem, in fact it is often code duplication that creates the optimal performance. Duplication is a source code management / maintenance issue. Case in point 10th line the join string missing a space while the duplicated line 18 has the space. Duplication is a easy place to introduce a bug, it is a place where the brain will say "same" for what is just a little different Duplication is simple to rectify using functions. You have two identical blocks of code (lines 7-11 and 15-19). You can wrap those lines in a function and call the function rather than have the code inline. You may opt to pass the function the arguments or use closure to hold the variable and access them directly. 

this will enforce some stricter parsing standards and help you avoid making mistakes such as "forgetting to declare". It also has the benefit of running your code quicker. Which way to iterate. There are many ways in javascript to iterate over a set of items in arrays, objects, iterable objects, and array like objects. Using built in statements , , , , , and more The one you use is about the worst for the situation. The problem with is that it will iterate over all the arr/object enumerable properties, including properties that are inherited via the object's prototype. This means you can get almost anything for each iteration, and thus need to check every item to see if it is what you intend to be handling, and if it belongs to the object or has it be inherited from another. This is just a pain, so much so I never use it. For your code you should have used 

Errors, bugs, and precision. This is not a complete review, just pointing out some problems with the code. its Buggy The factorial function is buggy and will throw a call stack overflow for negative inputs, and incorrect values for values over 22. Also I don't know why you have all the underscores, seems like you don't trust the language. 

This will produce the smoothest possible animation. If it can not keep up and drops frames then you need to reduce the complexity of the animation. 

Vet To fix these problems you need to look at the document content and remove unwanted formatting/styles. You need to check the selection before calling a command and not allow counter intuitive actions. You need to remove empty (thus invisible) tags as they will interfere with formatting and making editing counter intuitive. 

Inferred object type Or the ad-hoc construction approch can be called polymorphic using a factory function (or frankensteiner as I like to call from time to time) Objects are created from parts Each part on its own is barely a usable object, only together do they become a usable object (alive). The resulting objects are in a sense typeless objects that share polymorphic functionality. 

Using to find the or empty string and then and to add objects to the stack. loop to iterate the values of each object. Pushing to the stack objects as needed. 

Create a projection In that projection matrix is all you need to convert from screen space to world space (the reverse of the above function). So when you define the projection matrix you also define the inverse matrix 

Your code did not show where and came from. But they should be handled in the same way as above, without making function calls or creating objects. Everything is immediate and on the heap, and not making allocation requests. The beauty is that it is also has binned the data for you as the pixel array. You can make a copy and next time you need that data set just dump the pixel array to the canvas, in less than 1 ms 

Simple solution The problem is trivial as there is only one hub station. This means that there is only one root between any two stations. You need only find which line each station is on. If not the same line then find the root on starting line to the hub and from the destination station hub to the destination station. If the problem involved a configuration that allowed more than one root between stations it becomes much more involved but your code does not show that is an issue. Simplify using functions. The reason why your code seams long is because you have not compartmentalised functionality in the form of functions. You can break it down to 

Yes always smart, but then all JavaScript is OO so a little hard to avoid OOP when writing JavaScript. The thing you need to ask is "Am I being smart and using good OOP practices" for which the answer is. You need to start creating objects that define and encapsulate the various parts of your application. Currently you are only using objects and indirectly creating them (functions are objects) JavaScript is very flexible in this regard, there are many ways to create and use objects. This type of application does not need to be defined as an instanceable object, as you will never need to create more than one copy of the game per page. In the rewrite I wrap all the code in the event function. This encapsulates all the data and functions, effectively making it a self contained anonymous object. I have also added an object at the top to hold all the settings. This makes it easy to make changes, as you do not need to go through the code to change each setting (particularly handy when the code starts to run into 1000's of lines) Some notes 

Vet style commands. I would like to say "Great stuff!" as the code quality is good, but unfortunately it has some problems that make using function not as straight forward as it could be. The problem is that it does not check if the formatting requested makes intuitive sense. This can badly messes up the document and make it near impossible to correct. Examples 

Use strict mode Adding the run-time directive to the first line of a function or first line of a script allows the execution environment to make some assumptions and take some shortcuts improving performance (also forces you to write better Javascript) Iteration Loops are faster than iterators 

The design. There are some that will argue that adding to a built in prototype is inviting disaster, others will argue its a great way to extend the functionality of the API. As I see it there are two types of environments. 

Yes and you make copies of the input array and several places that are not needed at all. The javascript Array.sort sorts in place. With the buckets the radix sort can do the same. 

...correct. But all the rest is not helping solve the problem. Step by step. So lets step through the code Set result would be 

The string is used several time in your code. But then someone thinks that is not a good class name and changes it. You then have to find each string and change it. As you may also use it as a variable name you cant just replace you have to go by hand and change them all. 

Typed arrays for better performance. Using the accepted answers method you can triple the performance. Running the winning answer on my machine gave benchmarked 

As the click events are the only place (currently) that make changes to the task list. This is where you check the flag. If true then update the DOM, remove unwanted object, and finally set the flag to false All the changes to the DOM should be done in one place. 

Tips Setup the game using a function so you don't have to use the very hacky script tag. See the rewrite. For games polling IO state as needed is far better than reacting to IO events as they happen. The event listeners just set the state of an abstract controller. This lets you easily change the type of input. See rewrite for example. Use objects to simplify code. For example the snake can not move back on its self so you have a set of four if statements to check. That can be changed to 

A word about jQuery A word of warning. JQuery is a popular library, and in its day was a good solution to the problem of cross browser compatibility, and has some relevance today (dam IE11). Unfortunately it has produced a generation of front end coders that are unable to use the DOM directly. As a beginner you are training your self for the future, jQuery is struggling to stay relevant now. Don`t invest precious time where you don't need to. The step from vanilla to JQuery is a lot easier than the other way around, so be careful where you invest your time.