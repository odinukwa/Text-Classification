Edit Even if you don't want to use probabilities (which are just there to give a little extra bit of variation) you'll still need to work with a radius and combine it with your perlin noise in order to get something that looks like an island. The very least you need to do is take your perlin noise, and apply a radial filter to it so that pixels closer to the border become water. Using a radius will be better for sure than your idea of doing for instance "x < 5 becomes water". And another thing you could do is ignore the height values in your perlin noise for now. Set a thresold and let the result decide only where there's land and where there's water, nothing else. You can add mountains as a second pass (e.g by measuring the distance from the coast on each pixel). Then add some lakes, rivers, different biomes in separate passes. Your perlin noise doesn't need to provide all the information at once. I just found an old link I used before when I worked with this: $URL$ I'm sure you'll enjoy it. 

Notice that the method also follows a naming convention so that you can access it later by name using reflection. I'm just shooting out a few ideas though, I'm not entirely sure whether this would actually work though. :-) 

I don't have much time to try it at the moment, so if someone does, it would be helpful if you could leave some feedback about it. 

Short Answer First invert the view matrix. Then fetch the translation from the last row/column. Long Answer One way to deduce the contents of a view matrix is to start by considering the camera as any other object in the world, and calculating a world matrix for it: 

Now, you can implement both Perspective and Isometric projections using methods already available in the XNA API: 

So in order to move a point from sprite A's local space into sprite B's local space, you first transform it using sprite A's world matrix, in order to get it into world space, and then using sprite B's inverse world matrix, to get it into sprite B's local space: 

There are more complex ways of handling the problem depending on whether you need to loop horizontally and vertically at the same time, or if you need to zoom and rotate the background. You can use these as reference if needed, although I'm not sure how you'd translate it to your platform: 

Add a reference to to your project. Create an instance of to store your map. I don't think there's a size limit using , because I even tried with sizes over 15000 pixels wide and it worked. Write your data to the . The easy but slow way is to use . The harder but significantly faster way is to use (documentation). You'll also need to convert your colors from to but that is easy with . Save as a PNG to file by calling with as the second parameter. 

Now interpolate between these two orientations using spherical linear interpolation. There's a method for it so you don't have to implement anything yourself: 

The trick is to encode the negative number as positive one, by transforming it into a different positive range. For instance if you need to store values in the range in the texture, you'd start by mapping that into the range before rendering to the texture. You can do this for instance, by taking the original number, adding one to it and then dividing by two. 

From the SpriteSortMode documentation you can see that sorting by depth only happens in or modes, while sorts by texture, and the other two don't sort at all. Since you wrote that these modes bring you problems elsewhere, my recommendation is to divide the draw call into two layers, and stop relying on the parameter. The easiest way is to keep two separate lists, one for paths and one for nodes, and render them in that order using the default mode which is : 

If there's more than one element with a certain name, use the method instead to retrieve all of them at once. 

From what I understood you're now storing the value as part of the , but you need the ability to store more than one in each array position. 

That makes things easier than the process you described and you just need to update those values whenever there's a phase change. Other than that, it seems okay to me. Also... 

As for creating that rotation matrix, I think something like this should work (I hope so, I'm a little rusty with cross products): 

With this you can see that your enemies will probably need a state machine to manage the different states they can be in, and each state will have its own behavior to execute each turn, either hardcoded into the enemy, or data-driven by a scripting language. There's a lot of variation even between turn based JRPGs, so there is no set of rules for all of them. For instance, you can issue all party commands before any of them taking place, or they can take place immediately after choosing. Attack order might be random, or more often determined by the Speed stat. But for instance, let's say you have a purely turn based battle system, where you issue all party commands first, and then all the action happens at the end of the turn. You could approach it like: 

Your reasoning is sound, and pretty much all I can give here is opinion. Any of the alternatives you gave seem reasonable, although my recommendation would be to keep it simple at first, and stick with the enum, unless you really expect a lot of different gameplay states from the start. But you are right, what you have already implemented for screens is indeed just a finite state machine (in this case using a stack based implementation) whose states are screens. Naturally, a finite machine is not limited to managing screens, and can just as well be used for managing all kinds of game state. This includes, for example, what you refer to as being gameplay states within a screen, or more specific concepts such as artificial intelligence states of a game entity. You could abstract the screen manager into a general finite state machine class, but screens have separate update and draw methods in order to match the framework, while a state in a FSM will typically only have an update method. There's also a few other features here and there that might useful only to a screen manager. Then again, you could have a generic finite state machine base class, and make the screen manager inherit from it to provide the additional features. But your screen manager has a stack based implementation, and a regular finite state machine usually doesn't need it. So instead of trying to cover all the bases at this point with the most flexible design possible, I'd say to just keep it simple, and use the enum. Chances are, the amount of gameplay states you'll need will never grow large enough for it to be impractical. Unlike the action chaining method I spoke about in the other question, which I find to be extremely useful, my experience so far with this particular problem of higher level gameplay state management, is that over engineering it doesn't really pay out that much. 

For more information check the following link: MathWorld - Disk Point Picking. And finally here's a simple JsFiddle demonstration comparing both version of the algorithm. 

In the example that you wanted to achieve, you used a enumeration, but unfortunately there's no such type in XNA. Nonetheless, I would actually recommend you to go ahead with your idea, create that enumeration yourself and branch on it. It's what I do on my projects and it's also useful when I want to store which mouse buttons were pressed inside an event. And if you mark it as you can even store and check for multiple buttons at once: 

Personally, I like to wrap this up in some separate class and provide methods such as versus to distinguish both scenarios clearly. 

I started by adding an helper method inside the class that moves the entity towards some goal, and returns true if that goal was reached: 

I had a coroutine in Unity3D that downloaded a zip from a server, extracted it to the persistent data path, and loaded its contents into memory. The flow looked something like this: 

Simple! Just draw those elements in a separate SpriteBatch block without passing the matrix. For instance: 

Create a backbuffer that has a stencil buffer. Clear the stencil buffer to zero. Draw the sprites you'd like to tint white and whenever they pass the alpha test, set the stencil buffer at that location to 1. Draw a white quad covering the entire screen, but only where the value of the stencil buffer is 1. 

If such a simple example in 2D managed to reduce 44 edges to 8 edges, imagine the gains in a large 3D world... This is the approach described in this article, which I recommend you to read, despite being aimed at OpenGL. The concepts should be pretty universal though. You could also probably use a geometry shader to generate the vertices on the fly on the GPU, eliminating the need to store them in memory, but I don't have experience with that, nor do I know how well it would perform for a large world. 

I think the main optimization you can make, is based on the fact that not every cube will actually need all 24 vertices. In fact, the only cubes that need 24 vertices are the ones that are floating in midair, which is probably a rare occurrence. In general, only generate quads for the faces that are in contact with air. This means that if two cubes are touching each other, you don't need to generate any vertices for the face where they're touching. The image below demonstrates this concept, but in 2D for easier comprehension. In the image there are 11 occupied blocks (represented by the filled gray circles), which would normally require 4 x 11 = 44 edges to represent (4 because it's a square, not a cube). But as you can see, you only really need to draw the edges when they're in contact with an empty square, which in this case, is only 8 edges. 

Adding to Samaursa's list, but trying not to get too long, I'll just add a few of the ones that really stood apart from my library: C++ For Game Programmers LINK 

And so far it seems to be working, even when trying different player sizes and movement speeds, and "hugging" every wall in every direction. I've also noticed that as long as I cap the maximum instantaneous speed to the smallest value between the player's size and the tile's size, then he won't ever funnel through the walls. And that's still moving pretty fast! I intended to clean it up a little, maybe make it completely generic, and release on my blog one of these days. But meanwhile I'll just drop every relevant bit of the code in a pastie, albeit unorganized, so you can read through it: $URL$ And here's a little video of that code in action, where I'm forcibly trying to push against every wall. I used normal a player size slightly smaller than the tile, and a normal movement speed, but I've also tested with many different values. Edit By the way, I'm using a custom method to get the intersection depth (basically the one from the Platformer sample modified to work on 1 dimension at a time) instead of . That's mostly because while gives you the depth, it does not give you the direction of the intersection, so you'd need to do some extra checks to find that out. 

Most APIs represent the Sprite's origin in local space, not in world space. This is supported by libgdx's documentation which states: 

This will be hard to fix in so little time, especially since you're using such a peculiar structure, but well, let's give it a try. I'll post and edit as I notice the most glaring problems. Step 1) Proper Camera Panning The first thing that jumped out of your post like a madman was the part where you said: 

Also, since he's getting started, I do recommend starting with 2D games before moving on to 3D games. I think RPG Maker would be a great place to start because while you don't need to write code directly, the way the event system is set up makes you need to think logically which is a must for a programmer. You basically create events, set up the conditions for them being triggered, and add a series of actions with configurable parameters. You also have flags to set which would be the equivalent of variables, and you can control the flow of these events using conditionals and loops. All in all this sort of thinking will translate very well to real programming later on. Visionaire Studio is also very similar to this but for another genre!