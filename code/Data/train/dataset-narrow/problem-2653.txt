Event based design mostly involves implementing the Reactor design pattern. Before starting to design components you should give a look to the limitations of such pattern (you may find a plenty information about this). The first and foremost of the problems is that the handlers have to return quickly, as every one that did some serius work on GUI based frameworks and javascript based applications knows well. When you develop every application with a decent complexity you will, sooner or later, face some handler that does a complex job that requires time. In these cases you can distinguish two situations (not necessarily mutually exclusive): Complex event-related responsibilities and complex event-unrelated responsibilities. Complex event-related responsibilities: In the first case you merged too many responsibilities into a single component handler: too much actions are taken in response to an event or there are running synchronizations for example. In this case the solution is to split the handler into different handlers (in different objects if necessary) and let an handle to fire events instead of call directly the handling code. This will let you to allow an higher priority event to be managed before since your primary handler has returned after appending events to the event queue. Another solution is to let an external entity to fire events and let the others to subscribe if interested in (the timing event is the most trivial example you can generalize). Complex event-unrelated responsibilities: The second case happens when there is an intrinsic complexity in the action to take after an event: you have to compute a fibonacci number after an event for example. Here the Reactor pattern basically fails, worth little to split the fibonacci generation algorithm into little chunks that fire events upon termination in order to trigger the next step. Here the solution is to mix a threaded design to the reactor, the good news is that if the complexity is intrinsic (so you are reading the right section) it is very likely that it is possible to start and independent thread that does the work and that needs to know little or nothing about the rest of the Reactor-related components. To handle this kind of situations, I found useful to adopt a job queue over a flexible thread pool. When an handler needs to start a long action, it encapsulates that action into a job unit to be put into the job queue. This encapsulated action needs to have a mean to trigger events into the reactor thread. The job queue manager may run into its own thread or in the reactor thread and react to the "newJob" event. The job queue manager does the follow: 

rethink how the things work (design issue) and then rewrite the modules better (+1 knowledge) rewrite a module in a lower level language (interpeter issue), the module is a small part of software with a limited and well defined boundary and responsibility (+2 knowledge, +3 focusing) seek a better framework (framework issue), since the frameworks runs the most of the time in native code, probably the one you choosed was not so good. You have to rewrite some part of your application to deal with the fact that the framework changed: less changes => good designer (+4 knowledge, +2 learning speed) vaporize everything without leaving a trace and restart the project using a lower level programming language. You learnt so much from this failure that ultimately it's worth the efforts. 

Things simplify considerably if you're willing to use quaternions. In this case you have to simply store a "direction" unit vector(D) and an "upside" unit vector(U). Optionally you can store the "right" unit vector that points to the right direction (R) or you can compute doing the cross product (D x U). When you want to change your pitch or bearing or orientation you simply have to construct a quaternion using the right vector and multiply the other two for that quaternion. With this strategy you can store a "direction" vector that even points where you are going and rotate without the problem you may encounter if you touch some nasty rotation pole. [EDIT] Quaternions are 4-tuple of real numbers that represent a real part and the coefficients for tree orthogonal imaginary parts i, j, k. A quaterion may be write as (s,v) where s is the real part and v is the imaginary 3D vector. A point in 3D (p) may be represented as the quaternion (0,p) and the rotation of θ rads about the r unit vector is: q = (s,v) where s = cos(θ/2) and v is r·sin(θ/2). now p* = q · p · q' is the rotated point where q' is the inverse of q. The inversion of a unit quaternion equals its conjugate so q' = (s, -v) The quaternion multiplication shows a little complexity: while the a quaternion can be written as q = w + x i +y j +z k thus p · q is a simple polinomial multiplication, there are the relations so: 

Here a simple method to compute the center of the intersection circle between two (hyper)spheres that works for every dimension (but 0D) using some vector notation. Let C1 and C2 be the center of your (hyper)spheres, r1 and r2 the radii. D := C2 - C1 is the vector that moves C1 to C2; the leght of D (|D|) is the distance between centers. Now d := |D| -(r1+r2) is the distance between the (hyper)spheres: positive menans no intersection, 0 menans point intersection, negative means intersection. In the latter case, -d is an usefull measure of how much the spheres compenetrate. Now the distance between C1 and the center(C) we are looking for, is r1 - (-d)/2; being -d/2 the half distance and being substracted from r1 because r1 is "responsible" for "half compenetration". Then C = D /|D| * (r1+d/2) 

Under those circumstances there is conservation of total momentum and kinetic energy. When a collision occours, there is a contact surface between the colliding bodies: they can exchange energy only through this surface; in other words the impact forces are always perpendicular to this surface. The main conseguence to this is that you can decompone the kinetic energy vector in a radial component (perpendicular to the contact surface) and a tangential component (parallel to the contact surface) seeing that the tangential one stays the same. Knowing the value for a component, we can consider the collision be monodimensional, restricted to the radial direction. If we consider the second body to be still, we have some formulas for the velocity after the collision: 

My opinion is to use the Box2D units over the pixel of none of the two. You Have to use a non pixel based units because of the engine implementation issues and "have" to use the pixel unit because of rendering issues: neither of them (may) constitutes the reality of that you intend to represent. So the answer: use the box2D unit system as "user" system if it make sense for you; you will store this kind of values in your entities, your graphics facilities knows this and will convert in pixel when necessary. If the box2D units do not make sense then use a metric that does. Again, store that values everywhere is necessary: your graphic engine knows and does its conversion - your phisic engine knows and does its conversions. Edit: Graphical user input processing (clicks & touches) has to be done in the graphics subsystem and should return the position in a consistent way i.e. the unit system you choose. 

That vector can be obtained simply by summing up the normals of the boxes faces and normalize. The normal vector even point outside the box so the sum vector points toward the direction where the boxes exit from the intersection. along with the vector you need the intersection segment too (if you still don't have it) 

For each step you make in x direction you will move 35px left and -15px up to your canvas; For each step you make in y direction you will move -35px left and -15px up to your canvas; 

where V is the speed of the body (the lenght of the velocity vector); being the acceleration of a body due a force being: 

so q1 · q2 = Q · A in term of matrix multiplications. You can see that a rotation using a quaternion involves 32 multiplications and 24 sums Vs the 9 multiplications and 6 sums for the rotation using the standard matrix rotations. This difference is due to the fact that a fourth dimension is used to avoid the pole problem that often makes the matrix rotation unviable: the euclideans matrix rotations is not faster, it simply compute less things and you pay this if you pass through a pole. 

hence the mean of "projective" space; You should notice that here the euclidean space is 2D (the cyan region) There is a particular set of affine vectors that can't be put in their canonical version (with ease) the one that lies on the (hyper)plane w=0. We can show it visually: 

You should keep your elaboration balanced since there is a syncronizzation at each step. You can choose to statically or dynamically allocate areas to processors. This is not a big issue if your space is unifomly covered by active particles but i belive that it can be untrue in this case as collisions deactivate the particles.Changing the allocation requires an heavier communication step; some shortcut can be taken if all the processors shares the cross-border informations but you have to do some consideration about it 

I assume that A and B are the centers of the two spheres: Sa, Sb. V = A - B is the vector that moves the center of Sa to the center of Sb: you see that A + V = B. ||A - B|| is the magnitude of V or modulus or length - as you prefere - that is the distance between the two spheres' centers: p tells you how much the spheres are "too close" to each other. N = V / ||A - B|| is a unit vector (length = 1) that shares the same direction of V so P = N·p si a vector that has the same direction of V and the length of p. You don't want to move Sa toward Sb a little more so you will add P to B moving Sb far way from Sa in the right direction (N) and for the correct amount (p). 

The better answer I can give you is to do this preliminary steps: 1. Evaluate the offort required to build a prototype. Your prototype should be playable, limited in space (levels or map size or whatever space-related), in features (non customizable colors or static version of dynamic features). A pro if such a prototype may be evolved into a demo version easely. 2. Evaluate the target. You have to do this before even try to start a such thing using one of the most valuable things you own: the time. 3. Find a cheap/free pretest comunity. If you want to make a social game you have to reach a relative consistent number of people who are willing to try your game for free. How to obtain this may vary a lot, generally games are appealing things but your prototype may be less actractive as as it could be. If your target is young enough, you may think to add some educational aspect - even forcing it a bit - and try to propose it as project for a school: you can receive a lot of very valuable feedbacks. To be honest, "volunteering" something good for children is itself something very rewarding and a good way to spend time. If you can reuse the codebase of an educational project - that you give for free - in a profitable project, you absolutely are on the right track. 

The black line is the axis where the center of circles may lay: it is perpendicular to the current facing of the vehicle and passes through its center of rotation. The green segment represents the line that is perpendicular to the one that connects the center of the vehicle with the target and passes through the middle of that distance. The green line crosses the black one exactly at the center of the desired arc. The length of the orange segment tell us the radius of turning that can be achieved by regulating the velocity and turning at maximum steer or regulating both the velocity and the steer to stay under the constraint 

If rank is a normalized score, you can run all ranked bots angainst the new one. If not you have to ask why the score was not normalized and then re run the tournment. 

[Appendix] To speed up the interval query match you can test only A- and B+; when you find a match with A- then you get the upper end of the segment that matches and measure the distance with A-: if the distance is greather then 2ε this means that the overlap is too large to be considered a touch so you don't have to continue. The same has to be done with B+ but this time you have to check the value of B+ with the lower end of the matching segments, again to see if the overlap you find with the extended segment is too large to be considered a simple touch. A balanced interval tree takes ~log(n) iterations to check if a point hits against n intervals, this means that if you keep (by using red black trees for example) your trees balanced you can check against a huge set in reasonable time 

We can spice up the simulation by removing the geometric simplification. First you need to compute the contact surface and to find the contat point. (I left the problem to you but you can consider to simplify the contat mode to colliding boxes) With your contact surface you can compute the resulting kinetic energy vector - as explained before - but then? We have to "allocate" this energy because a rigid body can move and rotate and some energy is required to change linear or angular velocity. To know around what point our body will rotate, we need to know the position for the center of mass: this can be precomputed since depends just by the object shape and mass distribution. If you have a collision bitmap you can consider to sum up the position for each "on" pixel then divide for how many "on" pixel there are: this implies that the object has the same density in each point. If you like you can use a graymap to store the density for each point: black for 0 density (body absence) and white for maximum density; by multiplying the position by the density, you can compute a weighted average: your center of mass When you know the center of mass you need to know the moment of inertia: multiply the density of each point by the square of the distance from the center of mass and sum up. Knowing the center of mass and the collision point, you can decompose the kinetic energy vector in a radial component (starting from collision point and pointing toward the center of mass) and a tangential component. The radial component tells us how many impact enercy becomes kinetic energy, while the tangential component tells us how many impact enercy becomes rotational energy. As well as the velocity is bounded to the kinetic energy so Et = ½mV², also the angular velocity is bounded to the rotational energy so Er = ½Iω², where I is the moment of inertia and ω the rotational velocity in radians per second. Using those two formulas you can compute the velocity vector and the angular velocity to add to your body. The last triky part is how to know if ω has to be clock/counterclok wise, since you will ever get a positive value. Let I be the impact point and M the center of mass point, compute d = C - I; Let Er be the tangential component for the impact kinetic energy, compute , this will give you a right-handed perpendicular vector. Now compute d·E if positive the rotation is CW else CCW