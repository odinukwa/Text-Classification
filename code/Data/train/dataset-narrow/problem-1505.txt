Some small stuff: is initialize to 0 as it is in global memory. Given the enumerated list starts with -1, then : 

Heavy pollution of name space. , , etc. can very well collide with other code. Consider names less likely to collide. 

Other notes Notice how the below size works without even knowing the type of the pointer. This is less error prone and easier to maintain. 

gains little here as the certainly of null character termination relies on the prior code in a not so-obvious-way. 

Generality If this was not a function, but for general use, should returned a with all its fields in a consistent state. 

Allocate to the size of the de-referenced pointer, not type. Is the correct type to use here? Maybe -maybe not. A review needs to go someplace to the definition of field to find out. OTOH, the next line of code is certainly allocating the correct size. 

Recommend adding an enumerated value of to distinguish the initial state and explicitly initialize . 

See little value in the vertical line spacing. Removing a few of these blank line to group common elements together would make more sense. 

Crap happens lacks a way to indicate something bad happened like out-of-memory or error is reading data. Consider returning something to indicate failure or not. In general, the entire function assumes "no problems". To me, this is not robust. Error checking pays for itself as good code is expanded to ever more applications - and things happen. 

Like #2 above, a function to seed more than 64-bits would be useful. Bug. Re: "The integers generated are uniformly * distributed." with . Function only generates uniformly when is a power of 2. Function with that limitation is not that useful. Inconsistent style: vs . Recommend for both. Mask or cast is superfluous. Simply use one. 

Pedantic: Rare machines allow allocated memory more than via . Thus may overflow. The solution relies on implementation dependent code. 

Rather than support only 1 list, re-architect to support multiple lists. Consider passing into each function, a pointer to an opaque list type and "hide" implementation details from the user of your functions. Develop a naming convention that begins with the function set's name. 

Robust code does not assume the first in is not . This is a pedantic point, but user IO is a hacker paradise - best to code defensively. Instead of: 

Thought for a likely next assignment: Consider how to make 60c change when the available coins are only 50c,20c,20c,20c using the below algortim. 

Use of as Code uses return value of to indicate an error, yet a is not necessarily wrong in a general sense and so with a return value of , it is ambiguous if that is an error or ? To support , the architecture of this code may need significant re-write. Is this important? - Depends on coding goals. For a general purpose function set, I say yes. 

Calling twice on each string is wasteful in time. Current code make 3 trips down each string, once for length, once for copying, once to determine new length. 

To avoid the wasted memory A and member are not both needed for a circular queue. One is enough. This may be advanced for a someone who "never done something like this before". Although conceptually the and works wells, code can get by with only and have point to the "head" node. With an empty queue, . With an item queue, the last node points to the first, even if it is itself. The end of the list is determined by rather than compare. This approach reduces the memory need by one pointer/queue. In realizing this code, I have found it to be the same speed or a bit slower. This approach is most useful in reducing memory when there are large count of queues, perhaps many empty ones, in a program run. 

Deeper review of indicates it has more issues. It isn't allocating memory correctly, and linearly re-sizing. Suggest simplification: Do not allocate memory in calling function. Pass address of . Pass address of . Use positive logic ( Untested code follows 

Allocation test good, but needs an exit. Good to test, but then what? Suggest returning a failure code too. IMO, better to include some diagnostic info like , , etc. 

Code uses a fixed , yet uses templated code. A value of is quite arbitrary and not justified in code. Might make sense for , yet not . IMO, the assessment detracts from this code. 

Unclear why in 2 of the 4 functions. Suggest none or all 4. A comment in concerning the meaning of the return value would be useful. Assume user of does not have access to . Not clear is success happens with or . Using and is a bit too similar - differentiating only on 1 letter case. Maybe want to add a query? is not needed in . Suggest moving to Maybe allow where is to pop without saving. 

Surprised signs and were not allowed. Surprised optional leading whitespace was not allowed; very idiomatic in C. Tests. I would have like to see the coding goals specifics and some of your sample test data to assess how thorough the claim "function works exactly as I want it to". I suspect input like will pass. Advanced: as decimal point and as thousands separators is locale dependent. Research for details to make a function that works outside the locale. 

Suggest using for instead of any other type. is the Goldilocks type for array indexes - not too narrow, not too wide. Error messages are better sent to . 2 advantages: will not get lost in code's typical output and the stream is flushed ensuring output is not mixed after later input. Idea: Using a after the has merit when the free'd variable is still in scope for a long time. Although not needed, a decent compiler will optimized it out, but errant subsequent use is easier to detect when than . Minor: in a loop is sometimes a problem when trying to print more than some environmental limit number (e.g. 4095) of characters on the same line. Liberal use of or including a in the text usually solves this. A key comment missing is: is this array row or column major? With some analysis, that is discernible, but from a header only interface, knowing which dimension moves in the smallest steps is important in how higher level code will want to use this array for cache hit efficiency. Coding style: No need to introduce a variable until ready for assignment. Consider the 2nd style. 

Strictly speaking, the function, does not, by its declaration, indicate that and should not overlap. It could fail in bizarre ways should they overlap. C provides to 1) indicate pointers should not point to overlapped data and 2) allow the compiler to perform additional optimizations that require that assumption. 

Bug: Conversion to may be too late to prevent overflow. Perhaps code works for OP as may be 64-bit. Yet in general, it may be narrower. 

The names on the functions benefit by having the leading text indicate the grouping. Avoid function - too generic. 

always appends a to the output. This prevents and others from printing without a line-feed if desired. Suggest allowing such formatting to occur without an obligatory should the user opt for that. 

Incomplete declaration. A declaration without parameters conveys no information about the parameters. Thus a call to before the definition of will not flag an error. Use . 

Conversions to/from may need different sizes. The extra in looks wrong. Guess I am not a fan of . Why not use 1 function call? 

: Use meaningful variable names. Since the value returned is likely for an array, use . has incorrect functionality. If the file consisted of only "1234567890", the function would return 0 rather than 10. Code needs to consider that the last line might not end in . 

A solution in liner time, as answered by @janos, is do-able, yet a few changes are needed to handle an ever decreasing list like . For each element from 1 to , find if the difference of that element and the prior minimum is a greater difference. Then update the minimum. 

Out of range constant. is out of range of most compilers, even when exists. Portable code would use a different way to set the as well and a different type. Good that it work for you. 

Use rather than . Code is limited to files or less in size as code uses . Yet code mixes with with various calculations. This only makes a difference when 1) , and 2) the file is huge. Yet this is precisely the scenario to use an in-place sort: when the file is huge. 

Profiling will tell, yet I doubt reading a file twice is faster than reading a file sequentially once and performing as needed. returns . Code should be . is a signed integer whose positive value might not fit in a . But more importantly, may be insufficient for a file's size. Consider and instead. It is important to check the returns of , for errors. Rather than , consider or . As the intention is to return a pointer to a string, needs termination. negates the need for , but that is subtle and likely deserves a comment that the string is properly terminated. I could see an update replacing with and not then explicitly terminating the string. Curious that code does not save the . With this code running in binary mode on various machines that use an alternate line ending like , maybe the entire file would then be 1 line as the is no . Or in Windows with , each line ends with . Recommend amending this code to work with more line ending than or insure only text mode is used.