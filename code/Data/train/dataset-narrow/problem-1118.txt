While it might be ok to be able to exceed the upper bound by up to the maximum number of producers - 1 the same race occurs in . Except on the consumer side it has the nasty side-effect of potentially trying to remove an object from an empty collection. In this case gets returned which the caller might not expect since doesn't accept objects. Based on the check in I would infer that you never expect this to be instantiated on a value type but only reference types. I don't see any reason for it but if this should really not be allowed then add the type restriction to the implementation to make it clear. In the end the bounded capacity really doesn't mean all that much since it's randomly exceeded and one can dequeue randomly from an empty queue. Overall you should use to wrap the which implements the bounding capacity correctly. Just make sure to use the and methods accepting a so blocked operations can get interrupted nicely when you want to shutdown the application. 

Obviously the check is redundant because you do the same thing in either case. So it can be further simplified to: 

Also in you use a which seems to be a class member (property or field) and hence by convention should be or - is traditionally used for local variable or method parameters. This: 

These changes will be removing another 130 lines of code and make it much nicer to read as well. Will all of the above the code is now about 80-90% shorter than before and it should be much easier to handle and add new functionality. Disclaimer: I haven't compiled it so there might be the one or other typo hidden but hopefully you should be able to get it to work. 

Note that the code above is not robust against malformed input ( might throw). Also it requires that the passed in are complete and no new file with a new index is created in the meantime. Note: When you use Linq then imagine your were to write a loop instead and try name your loop variables accordingly. had me slightly confused when looping over files - I think is more intuitive than as is generally something related to a loop index rather than an actual object. 

Apart from that I think your approach should be fine. You may want to consider adding support for cancellation via 

This should be a simple refactoring on your service class and not expose any more json to the business logic than before. 

This makes it more explicit what if happening. can accept a client any time. In which case you can add a new user while a send operation is in progress which happens to iterate over the user list. You are bound to get a stating Last but not least probably the biggest issue: I admit that I'm not having a great deal of experience with the async framework however: Tasks are not synchronization primitives. They are an abstraction aimed to make asynchronous and parallel programming a bit easier and less painful. You are using them to synchronize read and send operations and I'm pretty sure this will be a source of pain. A owned by the room would seem a better tool ( readers, writer, don't write while reading, don't read while writing). Don't expose the lock though - this should be encapsulated. Each user should call something like or so which internally enters the lock. 

For this example, the use of is not necessary, but on the other hand gives you something like a lightweight object which could not only contain lables. On top is very readable. 

Here is the fiddle to play with. To make HTML-generation less painfull and a bit more JS-stylish I define what is called a higher order function : simply a function returning a function. A call to generates an anonymous function (a function without name), which returns every time it's called ""+ +"". The same goes for the other tags. This allows me to do something like a DSL: 

It's been a while, since I've been on the ASP-Road, but I hope to provide you some help: 1) Read the Documentation of DataTables, especially the paragraph about Ajax source data. There you learn how to use Datatables with server generated data. Serverside processing might be of interest too. 2) You are free to use a html-skeleton (as you did), but you could use Custom Column Definitions 3) In order to get the Datatables Plugin to work you need a) an Element in your DOM, where the Datatable can hook on: does that; and b) you need data to display. There are two basic formats: I) You have loose data, which is represented as an of . Each representing a Row, which consists of an of columns as in this or this example. II) You have structured data, which comes as as in this example So when I get your example right: 

So if I am getting it right: it puts, what it finds in values. I think, you have a lot of work to do. 

Um. There is verry little code, so one can not say much about your code. It does, what it should, I assume. One thing, I see is, that you are alerting a message, which has nothing to do with the validation. So if you are looking for SRP - the separation of concerns, you take the alert out and put it elsewhere. Of course you could shrink the whole thing down to 

Supposing, splitting by \w+ gives in most cases, what you want. Another solution would be . Depends on your demands. Go play with it! 

Besides what Flambino wrote I have a small remark to (3): Why are you storing unnecessary information in the DOM? I would prefer a solution, where you use a simple variable to keep track of whether the button performs an action or not. So you wouldn't have to update the DOM twice for nada. The DOM is a bad place for storing the state of your application. 

Then your function could fill in the structure passed in and also return error code in case the reading failed (i.e. source is too short): 

: Printing the list in reverse order recursively is an academically interesting solution but if your list is sufficiently long then your stack will explode. Use a to temporarily store the elements and then print that. : Currently this is O(n) because you iterate the entire list to find the last element. If you store a pointer which points to the last element in the list in addition to then you can avoid that and this operation becomes O(1). : Keep a length property in the class which you increment/decrement when a node got added/removed. Again reduces an O(n) operation to O(1). : 

Now design: I find it a bit odd that your class represents a descriptor for a status code and acts as a container for all status codes at the same time. This looks to me like an SRP (Single Responsibility Principle) violation. I would split it up and maybe put some generics in the mix (unfortunately enum can't be used as generic type constraint). So something along these lines: 

has a subtle bug: For the last instruction in the this will read one byte past the array if the last instruction only has one operand. Depending on memory layout and compiler this could lead to an access violation - although in most cases it will just silently work and read garbage. It probably won't matter in your case it's still not very nice. Given that there are only 256 opcodes I'd consider creating a jump table for all the opcodes (like the main table here) with a function pointer to execute it. The function pointer could take a pointer to the current machine and a pointer to the current instruction stream and return the pointer to the next instruction to allow the function to read additional bytes required for the operation. Then your function could look like this: 

If the files are very big you even might want to consider reading the input line by line and writing it to the output line by line. This will be less performant but also use much less memory. In the end it's a trade off between speed and memory consumption (as it often is in software development). The other advantage with the write as you go method is that you open the output file first - so if there is a problem with writing to the target you will know before you do any work at all. 

Which seems weird. There should only be one upload with the given id anyway and I'd consider it an error to have multiple rows with the same upload id. So why do you loop here? 

EDIT: I just saw a discussion in another answer: I was assuming random was generated somewhere else and had some variable seed. If you just need a random class with a static seed, I would inject it as it has been suggested. 

Async void should be avoided, but they are acceptable when in an EventHandler so it's fine. Why are you copying the keys of the dictionary into a list? Do you want a snapshot at a random point in time? If you have potentially race conditions, I would change the Dictionary to a ConcurrentDictionary. 

Don't call find twice will save an extra database access which is important and code style wise I would use the ?? operator as you see above. What the View("Error") is doing? Do you have an error view or is it just raising an exception? In both cases I would be more specific. I would also make the view strongly typed as it will prevent errors and give you IntelliSense. 

You don't need to create the database file if it doesn't exist, the driver will take care of it; to ensure your table does not exist on creation, you can just add to the query. I would also close the connection every time, this has already been covered by other answers. In addition I would make the class stateless as it doesn't need a state if we open/close the connection every time (Being stateless brings a lot of other advantages). I would also remove any logic from the constructor, to do this you will need a state or you will have to check on every command unfortunately so I left it to you. Here is my 0.02: 

I would definitely remove the database access from the Category partial view and move it to the Controller (you can add it to the view model or have a separate action for returning them which is even more clean). Views are supposed to be dumb layouts and not perform any business logic. Removing the database context shouldn't affect the compilation of the views. Small refactoring suggestion for the Controller: 

I focused on simplifying the implementation rather than the actual algorithm: Many of the method exposed by your Roulette are just proxies for the Dictionary so you could just inherit from the Dictionary. You could simplify some the Edit by using ConcurrentDictionary, but I don't think you really need it concurrent anyway; your choice. If you have C# 6 you can make the code less verbose. LINQ can simplify most of the implementation, hopefully didn't make the code unclear; but usually it's even more understandable in a functional fashion. I removed some duplication in the constructors as they can call each other. The equals operator between floats can easily fail for the precision so, as my ReSharper suggested I changed it to have a tolerance which you can set. The default of KeyValuePair shouldn't cause any issue unless you have a default of both values in the dictionary. Maybe worth a runtime check. Don't remember if I made other changes, too. 

So if the user is not logged in you load the view and then you load the view again unconditionally? I'm not PHP expert but I'm pretty sure can be condensed into 

You should check the return value of . It returns the number of items successfully converted. You initialize with so any invalid input will yield in a single output but it might be good to indicate failure anyway. Using and are more portable ways to indicate success/failure upon return to the OS. is is not representable by an 8-bit type. The binary representation is 1 0000 0000 - so the 9th bit is set. An 8 bit unsigned type can only hold 0 - 255. Multiplying an integer by a power of 2 can be done by a left-shift. So for example is - this eliminates any need for multiplication or even invoking . You print out the order of bytes in big endian notation (the highest ordered byte is printed out with the smallest index) while for example x86 is a little endian architecture where the lowest ordered byte has the smallest index. Actually scratch that. The data in memory is laid out little endian so your code will print it in little endian order. Your size detection works on the assumption that a char is 8 bit. This is not guaranteed by the C standard which requires to be at least 8. For example there DSPs where is 16 and in the past there were architectures with 9 and 12 bit bytes. Your size detection only goes up to 4 bytes however is 8 bytes on many platforms. So if someone puts a large number in the it will simply omit the upper 4 bytes. 

Your worker method writes directly to the console. What happens if you want to run this code in a windows service process where this should be logged instead? So you should pass some kind of to the method and use that to output the status/log messages. You hard-code your output directory to . This should really be passed in as destination folder. 

Your queries are only different in the type of homework they look for. Also the processing of the data seems common. The basic way to refactor code like this is to extract it into a method: 

As to your question where to declare - it best practice to limit the scope of variables and declare them as close to their use point as possible. 

Pass via the constructor as an external dependency (preferably an interface). This will make the current implicit dependency explicit and visible which should yield in better maintenance in the future and easier unit testing. Pass the tick handler in as an parameter - no dependency on a specific object at all. Expose a event and raise the event handler on tick. This way anyone interested in the clock can subscribe and the clock doesn't need to know about them at all.