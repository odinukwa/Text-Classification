Joey has a couple of choices here. He can consider you've got a fair point, and might go for it, or, better yet, Joey will present the list of arguments as to why he has it on a single line (maybe 'no-one else will see my code' or 'I'm doing a contest on fewest bytes used on code gold'). At which point you can either explain why not building it for other people in mind is bad, or concede there is a reasoning behind it. This approach I find is excellent in team situations because the suggestions aren't forced, and it allows people to argue for/against a particular criticism. A dialogue occurs, instead of an argument. Objective This is where real problems begin. It's not because Joey has made an error, but if he continues with the error, stuff will catch on fire, the world is going to end and goto loops will become fashionable again. As a result, you're required to put your foot down. Before approaching, I find it works extremely well if the opening dialogue starts 'this is nothing personal, but...'. Psychologically, people think it's reverse psychology and thus terrible, but when you point to the code, this helps reinforce it's actually not. The criticism should be kept short, matter-of-fact 'if this happens it will do this' (if this has no try-catch and it throws an exception, the stack is going to crash and the system will go boom). Explain what-why and how to fix it. You can help reduce the sense of it being a personal failure (the main driver of being defensive) by either indicating it's a common problem or that it's a hard problem to spot. Joey might still get defensive, however: trick is to not rise to the argument. So, for example: 

I think the first port of call would be to bring up the subject of handling criticism as a dedicated class session, including how to extract useful feedback from poor criticism, and how to make criticism (which they would be expected to do in the event of a code review, both reviewer and reviewee). They're adults, bring them on the level of both giving and receiving, and they should understand both sides. On the other side of the fence, how to criticise I find boils down into two categories: 

I find some people hate being told what to do, and will spurn it even if it's the most logical choice. By alerting Joey to the problem, the solution, the reasons for that solution and the fact there might be other solutions, allows Joey to see the problem as an impersonal thing for him to solve (he didn't create the mem alloc error: he has to solve it), he has one known solution, and the freedom to research other unknown solutions. Joey can either see your solution as the easiest, might devise his own solution (which might be surprising - as a student, he should be learning, not merely copying), or might just choose to ignore it, in which case he suffers the consequences (bonus points if you can create a scenario that causes the error), including any subsequent markdowns on program's performance. Final trick If you want to be really hands off, there is one question that will get most people to reconsider a piece or line of code that doesn't require explanation: What happens if ... What happens if this ProcessArray hits a mem alloc error? What happens if this switch statement encounters an unknown case? etc 

It's not too much difficult to make non-C/C++ programmers understand about pointers if we take the above points and start from some basic examples like URLs being used to point to web pages etc. It has worked for my case (a great deal), hopefully it will help you and others too. 

C/C++ in PF, followed by either C# or Java (more frequent one) Universities which start right from Java 

C/C++ Pointers are a nightmare for programming students - whether they have any Java/C#, etc. experience or not. It's the syntax of the pointers (the terrifying*) which is more difficult for students than its semantics. Every student of Java/C#, etc. knows that variables are stored in the RAM (and they have studied in Intro to Computing about RAM addresses etc. basics) 

I have been teaching Operating Systems basics in a class and after Processes, Child Processes and Threads, we have managed to move to "Process Scheduling" Now, ironically, as we know that it is not the Process which is scheduled, but the threads precisely (we are following Linux Ubuntu there). Here is what Silberchatz book (by the way, the title of the chapter is also "Process Scheduling") says about it: 

Now I would talk on general terms, @Buffy has a good idea of giving them projects. I like it but I would like to add little bit more: A complete/successful project doesn't always guarantee that a student has covered all the basics of even OOP (assuming he develops project in an OO language/paradigm) or SQL, etc. (I am coming from a Pakistani background where OOP and SQL still have lion's share in market, this suggestion may vary depending upon the industry you have) I think if I were to give any student a suggestion, it would be to firstly cover OOP and SQL properly and then complement it by project I agree that now SW industry has much more technologies and not everyone gets away with such a luck, but my experience still tells me that OOP/basic algorithm development and SQL are almost necessary for lot of jobs. So my conclusion is, both OOP, SQL, etc. (Theory) and Project (Practical) are necessary for you even if you are Final year student and water has reached near your throat. P.S: @ctrl-alt-delor's answer has a detailed analysis of technologies road-maps and I would like to refer to it for choosing a specific tool(s). 

Despite all this, I still feel there is no alternative to a Paper-book. I used to hear it since long time, but there are some reasons behind it: 

I have experienced the same problem and I found a pretty easy solution by dividing the lecture into two parts: Theory (usually taught on the board) and Practical Demonstration (on IDE). Now I come to the important point in your question (I had similar views to yours) on: 

I got a chance to teach Introduction to Computing & Programming course to Chemical Engineering entry students and their syllabus included both Programming concepts & Excel. I began the course with just Algorithms and after 4 weeks, switched to Excel & then on programming. Off course they are different to your target audience a bit but I found Excel('s functions) pretty helpful for them to comprehend the syntax (after a couple of weeks of Excel, I switched to Visual C++), so the pros you mentioned are really there. Cons Using Excel alone can make students thinking in terms of sheets/tables which can make them picking the concepts of arrays,etc. pretty tough later on and even if you go in some depth of Excel functions, still I don't feel its worth an entire course (even to learn programming). Conclusion/Suggestion My personal experience of using Excel as catalyst was really good one and I think using an user-friendly/easier IDE like Visual Studio with Excel is worth a try 

Students need (a) motivation, and (b) a useful language. For (a), use a high-level language, preferably one in which graphics is easy to handle, and cross-platform (yes, a few will be running Linux, mostly a motley of distributions/versions; most will swear by Windows of several batches; then there are Apple-lovers...). If they can build something fun in a few hours, that is more than enough motivation. Build some simple game, have them participate in some of the one-weekend game building competitions once they are further along. For (b), today Python wins hands down: there are libraries for anything imaginable, and then some. Much "real work" in e.g. astronomy is herding a bunch of data-munging scripts (with FORTRAN or C++ backends) in ever changing combinations, orchestrated by Python. Much of the "user friendly system administration tools" in my Fedora system are written in Python with nice GUIs, and hand the grunt work to the traditional commands. Check out some text like Think Python, there you'll see how far you can go in an introduction course. 

It is just that we think procedurally. We "go to the store", we "cook dinner", we "do the dishes", and so on. The functional, recursive, based on induction, mathematical, thinking is very far from natural (ask any teacher of mathematics to students in first-year calculus courses, take a peek at what the colleagues of the math department think about their freshmen). Sure, programming is (thinly disguised) math, and so math style (functional programming) is more "natural" if you have groked math. Most people never get it. 

Part of the "teach OOP" problem is that OOP (and modularity, and top-down design, and variable-naming discipline, and consistent code layout, and...) is practically useful for large programs with a long life, and in the time allotted you write tiny throwaway programs. Perhaps a way around that is reading (good!), hopefully modifying/extending, programs written in OOP style. Open source is a godsend... 

Prolog promises "programming in logic", but you end up worrying about the order of your predicates, and have to be acutely aware of the order in which they are recursively (procedurally!) tried by your interpreter. Too much confusion, even for a non-beginner. 

In modern systems (e.g. Linux for a long time now) what the kernel schedules directly are threads. A process is just a bunch of threads sharing some extra stuff, like memory areas and open files. Way back a couple of experiments were run under Linux on userspace managed threads/hybrid systems/kernelspace managed threads (back when the way to use threads was the userspace pthreads library), and kernel threads won hands down. Solaris used to champion a hybrid model (mostly for herding thousands of Java threads in some applications), and silently migrated to kernel threads That it is called "process scheduling" is just a remnant from olden times, when there were no threads and everything was processes. 

"Group work" is hard to handle. One of the first courses I taught here was structured around a bunch of homework programming tasks, to be done in two-person teams. Around midterm one of the students showed up complaining he had done his half of the homeworks (his mate didn't participate), and now it was the mate's turn... and the mate had left the class. The problem is that as long as you want to grade the work (and you, much less your students, rarely have the time for "non-graded work") you have to assess what each one did. A much worse problem is that in the later "real life" group work is a must, and you have to teach that somehow...