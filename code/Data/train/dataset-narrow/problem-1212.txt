There are a few things I would change. Some are performance related(though in your case they wont make any real difference, its good practice though) and others simply reduce the amount of code. Another change should make your code less likely to not find words. OK Here it is. 

`BuildWordArray is better as a Function than as a Sub for readability and later on in larger programs, maintainability. 

the next two lines have been moved to the top of the Class - it's often good practice to have your variables at the top of the definition so they are easier to find. Also, this is the bit that uses Regex as mentioned above in the imports at the top of the code. This line removes everything that is not a space or an alphabetic character. For example, if your sentence is "The cat is big, fat and hairy", if you try searching for "big", using your original code, you won't get a result because the word stored in would be "big," not "big" 

This line enforces proper programming practices in the case of type conversions and sever other things. 

Well, I do not want to be the one always hammering on using s, but your second solution was almost immediatly clear to me, whereas the first was not. It does help that with the second one you split it up into methods, a very good thing! Nontheless, I still think you can improve the second solution: 

I think it makes the loop implementation a bit confusing, because this is only called once to add the first element to the merged elements. I wonder if using and iterating over that would be better, or a manual iterator... Also, should the s become immutable, it would change the implementation a bit. Note that you are now changeing objects which are coming from the outside. Your method assumes that the start time of first is always the smallest start time, and that the end time of second is always the greatest start time. This would be wrong for e.g. first = [8, 12], second = [9, 10]. It will return [8, 10], when it should be [8, 12]. The overlaps method also is a bit incorrect, because multiple meetings starting at the same point in time will not be merged. Also is the same as . Finally, your show method ends each line with a comma. Should you want to simply delimit each meeting with a comma, but not one at the end of the line, you could solve it for example as: 

Rather than use a loop and still use a variable as an index, just just a loop and use it's index. So here there is no definition of `intIndex1 until the loop here. 

The message box in you original version of the code showed an incorrect message. Earlier on in the new code, the search textbox has already been checked to make sure that it wasn't empty, so the Message should simply be that no results have been found. Telling the user that the box is empty would confuse them. 

This line enforces declaration of type rather than having the compiler infer them from other code. You'll get less problems in future programs if you always have this off. 

See my explanation above about converting strings to lower case earlier on In the statement you now only have the one instead of two statements. This will again, in larger programs improve performance. In this code it's simpler just to keep adding the variable. The method could be confusre with an array or some other collection, so it is better to use .There is no need in this case to have the extra check with regard to the adding of commas, Just trim off the last comma after the loop has completed. 

Why are we enumerating anyway? Enumerating is for enumerating. But here, the round number doesn't actually correspond to the letter number. It should just be an external variable: 

That said, I doubt any version of this (unless it's particularly egregious) wil end up being a bottleneck in the performance of your code. 

There is no way that anybody will know what does here. I didn't until I read the implementation. A much better name for this would be . But I'll get back to implementation in a moment. First, let's start with: 

That way you don't need error-checking, since there's no way to do it wrong. One thing you don't error check is the unit name. Should make sure I can't even construct something like: 

In addition to the double free, you get the other issue in that the user might expect a deep copy but actually is basically just a Java-style reference to . Fixing this is an absolute must. Resizing This is definitely non-functional. You delete your member , then, separately from that, you create a locally scoped array that you write stuff into. At the end of , the object will have a deleted local array! The correct way to is to allocate a new array (only have to do one!) of double the size, to copy/move from your member into the new array, and then simply change your member to point to the new array. This should be one allocation (of the doubled array) and one deletion (of the old array). Off-by-one The first writes into . What goes into ? 

This example may be used when the method this code is executed in does not declare to throw a checked . But it all depends on the case at hand. 

To me this is probably more elegant than a traditional loop. With s it is possible to write it in a declarative way. In a lot of cases they are also trivial to parallelize, requiring only a function call on the . Furthermore, they are lazy which means the processing can stop early, only the necessary data will be processed. Note that in this case, we have to process each element (each character), so it makes no difference here. 

I can't think of a way with better time complexity, you have to know all values before you can sort. Though with some Java 8 stream capability added to the class, you could implement it quite cleanly as follows: 

I think overall it is a nice implementation. It is clear and readeable. The use of constants is nice, makes it easy to refactor the code to make it more generic later on (e.g. replace with given character, not just space). Clear variable names (although I'd try and be consistent, and use , or , most likely the former). I have two remarks: 

But this is error-prone (and relies on global state). Instead of modifying , what we can do is provide a new object to each recursive instantiation. This leads me to... Your algorithm Now, you want this to be entirely self-contained. You're right in wanting to avoid global variables - and you have most of the right idea in that we want to recursively call down with the next word. The one change is the last argument. isn't really meaningful here. What you want instead is the path you've come so far: 

Template metaprogramming is all about rewriting your program to be functional instead of imperative, and then not worrying about caching since the compiler takes care of that for you. The other important guideline is that the return of a metafunction is a type named . Template metaprogramming is about types - anything that isn't a type is just really annoying to have to deal with, so stay in the type world for as long as possible. So how do we write this functionally? Let's look at the loop - which is the only really interesting part of the code: 

I have a feeling there is a direct way to compute this amount, but I am not really into all the mathematics, you could possibly look it up. I'll talk about your code as is: 

Without the link, I can only make certain assumptions, so I am going to give a couple of global comments: 

The reason for this is that now we only flip while it is necessary, because if the bottom of the remaining stack already contains the largest pancake, we do not need to flip. Meanwhile, we are also keeping the implementation clear: you first look for the largest pancake in the remaining to sort stack, move it to the top, and then to the bottom of the remaining stack. Using clear variable names makes it so other people can understand your implementation more easily (and even for yourself, if you would come back later). 

A short comment about your first approach, using a would be a good thing, because concatenating s with each time builds a new object, whereas with a , you would only make a new when you concatenated all parts. In this very case though, pure performance wise, it might get optimized under the hood to use a anyway. 

By making it const, they can't edit it anyway, and then they can display anything that they want to display. 

Your runtime complexity grows commensurately with the second column. According to Wikipedia, that means your algorithm is something on the order of \$O(e^{\sqrt[4]{n}})\$? A better approach Rather than checking every individual number (which leads to terrible runtime complexity), we can build numbers up from the bottom. The numbers we want are basically \$2^a3^b5^c7^d\$, for all \$a,b,c,d\$. Of course, that's difficult to iterate over (how do you know which one to do next?). But a different way of writing that is each humble number is either 2x, 3x, 5x, or 7x some previous humble number. And that's easy to iterate over: 

Catching is questionable - it'd be better to use and a cast that returns a specific error. Otherwise, what if we had a syntax error? You'd hide it from yourself. Once we have that, we can use that to call into our constructor: 

And have a member variable , and add constructors to let the user pass in a . You should then drop your Interface should return , not . For performance, typically instead of providing , you should provide: 

Note that will bring you to the same spot as . You can see that each of those share the same second parts as well. This is duplication which we can use to speed up the algorithm. If you think about it, there are generally multiple ways to get to some point . If you think of this as the starting point, the possible paths to the destination will obviously be the same, no matter how you get there. So what you can do is create a lookup table for a calculated location, so you calculate each one only once. This will give you an extreme amount of speedup I would think, on problems with a big amount of possible paths. Which you will get to quickly, even for small values of . 

Perhaps instead of using a to keep track of the merged meetings, you could use a stack (though do not use , rather something like , refer to the docs why). Instead of getting the last element from the list, you just the top, and if you have to merge again. I am not sure how I feel about