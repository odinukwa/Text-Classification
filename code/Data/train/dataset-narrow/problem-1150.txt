etc. This eliminates all need for looping. This also eliminates need for row by row deletion from source table, you can just or the source table after your operations are done. You may even consider performing this whole operation within a transaction if you want to only commit the change after the entire series of actions in the migration is complete. By the way, I agree with the comment in other answers around prepared statements - you should always use these on those rare occasions where you do need to query in loops or when you are injecting variables into where, sort, order, etc. clauses - but, in this case, I am guessing you can get away from either of those circumstances. 

Why would you even even try to process the file if is not properly defined? Why must this condition be checked on every iteration through the loop. It seems this conditional should be designed out of this location. You have similar possibly unnecessary conditional around 

Now this certainly is not optimized from the standpoint of operational complexity (in that you have to perform \$O(n^2)\$ iteration twice, but it does break down the problem into the logic space of setting up a board and then displaying a board, which has more real-world applicability than building a chessboard directly into a string. 

I would encourage you to use meaningful and specific variable/class/method names. For example, is not really a meaningful name. is not meaningful (and redundant) as one can obviously see this class is meant to be used in a concrete object context and is not very specific and tells the reader nothing about what this class does. Since this class is only designed to work with , I would think that, at a minimum, should be in the class name. I have a hard time thinking of what you might call this class based on the fact that it does too many different things, but even would be more specific (but defaulting to a name like "helper" should be a red flag that the class is doing too much). 

You are doing nothing of the sort here. You are really only storing database configuration here in the class, something that really should be split out into separate application configuration functionality and not hard-coded in a class somewhere. My recommendations would be: 

Of course this eliminates the echo altogether. But this makes sense if you are committing to the pattern of having all end user messaging delivered on files page based on value. Why would you need messaging here anyway? 

First, you should strive to separate your PHP logic from your HTML output. Right now you have the classic "spaghetti code" which is very hard to maintain over time. Do your very best to write all the information you need into PHP variables, such that when you get to rendering your HTML (ideally in a different file from your main code), all you are doing is simple variable insertion and perhaps some looping in your HTML template. 

Your public methods really do nothing to validate that the arguments being passed are suitable to be working with. You should never get so far as to prepare a statement on the database (a relatively expensive operation) if you have not validated that you have reasonable values to work with. I would suggest you add guarding code at the first few lines in this methods to validate the input and fail with or similar before you get to executing method logic. Fail early and fail loudly. 

This code is no less concise/understandable/maintainable than it was when using your wrapper, so again, what value is the wrapper adding? 

Do you really need username for these methods? Shouldn't unique answer id be enough? Method name seems wrong. You are not getting a "vote", you are getting a "vote type". Also, you are not using the "current" values based on the current object properties at all. A more appropriate name might . Should this be a static method, since it has nothing to do with object context? Perhaps with signature like: 

This makes it to where the class that needs that dependency can never even be instantiated if the appropriate dependency, which is type-hinted in parameter declaration, is not passed (an would be thrown). Your code fails loudly, which is what you want. 

If just looking for a single character in a set of strings, I would think basic string manipulation would be sufficient. What is not clear to me from your question is why you are using word boundaries in your regex definition when the array itself is just single words. Is your intent to analyze individual words in each of the array strings (with string perhaps consisting of multiple words) or are you only truly going to have single word string in the array? For now, I will provide answer given the assumption of an array of single words. To do that, I would simply use in combination with . 

To your DB schema itself. You may want to consider not using camelCase for names of database objects. snake_case is more or less a de facto standard for MySQL which has some peculiarities around how it handles casing in database objects. 

Do you really need this in javascript as opposed to setting form's action or using a simple styled similarly to button? If you really need to apply javascript here, consider moving away from in-line usage. Over time you will begin to realize that separation of application display and behavior code allows for a tremendous amount of code re-use. Consider putting this in handler and applying it to element based on class or id. 

I also don't understand the lookup mechanism and comparison mechanisms here. It seems obscure upon first read to have key/value positioning determine how the string is mapped to true/false. I think I would be more explicit like: 

Why have superfluous comments? If your code is well-written with meaningful function and variable names (I think you do a good job of this), then you should not need such comments. 

I would suggest that you might ultimately want to consider splitting this functionality into different classes. Perhaps with classes such as: 

Here you pass all dependencies to a factory-type method which could: validate input (and fail if appropriate), insert record in DB, and return instantiated vote object (with information such as id, count (1), vote type, etc.). Let's look at your read case now. Let's say you wanted to get the vote count based on unique identifier (title in this case) from question class Currently, that might have you doing this: 

You are falling into a conceptual trap of trying to define javascript behaviors for each element on the page by numbering each and every one with a different id or class name (i.e. ). Any time you see this pattern in your coding, this should be a red flag that there is probably a better approach to your problem (which is why I think you are asking for this review). With jQuery (or really javascript in general), you should be thinking in terms of what the behavior of an element is supposed to be using classes to identify elements which need to exhibit similar behavior, much in the same way you use classes to define elements that have common CSS stylings. For example, all of your choice buttons fundamentally have the same behavior. That is, they hide other options and expose a new situation. Because this basic behavior is common, there is no reason that you need to duplicate code for each of these buttons. So the question then becomes how do you generalize your code to have a single onclick handler for all of the choice buttons? To do this, you have to have an understanding of which buttons expose which situations - something you are now implementing via class naming. In jQuery/javascript, there are probably two main strategies to do this. One is to tie the elements together via their hierarchy in the DOM and to traverse the DOM hierarchy to hide/show related elements based on their location relative to each other on the DOM. For example, when hiding/showing elements, you might hide all the siblings in same level of DOM as the one you are trying to show. The other main approach is to use data attributes to describe how elements should interact with one another. I will focus on the data attribute approach here as I think this makes the most sense for your use case. You have a potentially complex set of interactions in a "Choose Your Own Adventure" style of game where you ultimately may have multiple story branches each which could lead to different situations via different paths. This would likely be hard to model via HTML hierarchy alone once you move beyond just a trivial proof of concept. Data attributes are also a powerful tool for a budding javascript developer to learn. I would propose some changes to your HTML to make each "situation" its own self-contained set of HTML elements, like the concept of a page. You could then hide/show each situation (including choices) as a single entity. I also think in this case it makes your HTML much easier to read and maintain. 

To expand on my suggested usage above, you might leave it up to class to determine what to do about an unknown error type - does it throw exception, or does it apply default messaging? If it applies default message, then you could use my example above as is, but if it throws an exception, perhaps you need to modify to be like this: