You can setup the Wi-Fi completely headless. As stated on The latest update to Raspbian you can provide a on the /boot partition to setup the Wi-Fi. Don't forget to also create an empty file to be able to actually access the pi as mentioned in A security update for Raspbian PIXEL. Then you should be able to find your Pi on the local network. You can try something like to scan your local network. 

This is obviously nothing related to Raspberry Pi but to Linux and Bash scripting. The for-in operator operates on a space separated (line separated? You can change it with ) lists. 

Upgrading to a new version is a or whatever the new version is. Switching to another version is something like . All is saved in ~/.nvm so it does not pollute your system and can be easily removed. 

There is no globbing or thatsoever. So instead of your glob you will have to get a listing of the actual files. Something like So you should be able to achieve your intent with 

I had the same problem lately. In my case the FFC ribbon cable was damaged. But as I tried to acquire an image, the red LED went on and stayed on forever. A new cable resolved the issue for me. 

You should not be using netatalk at all. Apple has deprecated AFP in favor of SMB. So samba is the way to go. As of OS X 10.11 Yosemite I also experience issues with other AppleTalk devices. On my old Lacie EthernetDisk mini I could not even connect using AFP any more. 

You can sort of. But it is not working really well. At least in the command line you can turn off the HDMI port and get it back on with a different resolution. So you are good for Raspbian Lite. Here is what you have to do: 

To me it looks like ser.write(1) has an implicit conversion to string. So your 1 becomes a "1" which is 00110001, which perfectly fits into your observation. 

You can place a file named in . So you can plug the SD card into any computer that is able to mount the FAT file system and create the file there. But I don't know in wich stage of booting your panic happens and if you will reach the fsck stage before it. So it might or might not work. EDIT: A quick search on the raspberry pi forum suggests that has to placed be on the root and not the boot partition. instead of . I think the latter will run fsck only on the boot partition. 

Have you tried it outdoor? GPS has very low to no reception indoors. Also you have to receive a signal from at least 4 GPS satellites. Smartphones overcome this issue by using the WiFi and cellular strength and a map service where each WiFi network and cell is mapped to GPS coordinates. 

Hopefully that is helpful and also other will start using the features of systemd. As Linux is very old now I know myself that there are plenty pages and tutorials that are not state of the art and some even outdated. So I try to fix that here for automatic mounting. 

Yes and/or no. Yes, there is a good solution for streaming sound over AirPlay with shairport-sync. You don't need Kodi for that. No, there is still no good solution for video streaming. :( 

Then you should be able to open a connection. (Assuming your bluetooth device actually supports the required SPP protocol.) 

The Pi does not have anything like power-down or sleep. It is active and running all the time unless you turn it off. So if it is running there is no need to "wake" it from sleep with WOL (Wake On LAN). If it is turned off by , it also powers down the ehternet port thus not accessible from the network and therefore cannot be powered on again. You still can reboot the Pi over SSH. But for selecting another OS you have to be right in front of the Pi. So I don't get the whole point. 

You may want to try this script $URL$ It mounts the image file, resizes its partitions and truncates the file afterwards. You have to run it on a linux machine with enough space. If you want a simpler solution. Use some tool to overwrite unused space on the SD card with zero and then you can simply compress the image efficiently. 

I'm not sure about the file naming. But I read there is a convention that the file name is the path to the mountpoint with replaced by . I don't remember if it was mandatory. The content should look like this: 

I recommend you to tryout NVM (node version manager). It allows you to install Node.js and global node packages in your user space and easyly install different versions and switch between them with ease. The documentation is a bit owerwhelming at first but it gets all down to: 

To me they look like analogue cameras. So you will have to get an USB video grabber and set it up with UV4L. 

Since Debian 8 is using systemd you might want to take a look at the current method to automatically mount devices on boot and as they get connected as well. While udev and fstab also work, they are the old way and not that easy to understand for beginners. So here is how you automatically mount a device using systemd: 

I've burned the new Raspbian Stretch Lite image onto a SD Card and use this as my development system. I was used to turn off screen blanking on the console by changing the in to . In Raspbian Stretch there is no such file and I cannot find an equivalent on the entire file system. So obviously the old behaviour has changed. kbd has been either removed or replaced. What is the new way to disable screen blanking? 

The easiest thing to do is to use an Raspberry Pi Zero as a port expander for your computer like here. This takes advantage of the ability of to access the GPIO pins of a Server via network. So it actually works with every Pi model on the network not just a Pi zero connected directly. I think you can enable the server in . But for not I think it only works with Python. 

What you need is an LCD Driver Board that is compatible with your panel. You can find such things on AliExpress and they look like this. But this is only a pointer. This particular board is NOT the one you need. You will have to do your own research. Usually you will have to take apart your laptop and seek the model number of the panel and search for it. Once you've got it, you simply connect it via HDMI/DVI to your Pi. 

MKV is just another container format. If it contains H.264 you can unwrap it and repack it into MPEG-4 using ffmpeg. 

Let's do some basic calculations: Assuming you want to transfer Video from RaspiCam and are capturing at full HD at 30 FPS. That will give us 1920x1080 (Pixels) * 3 (RGB) * 30 (FPS) = 186.6 MB/s or 1.5 Gbit/s. This is insane. To be more conservative assume 320x240 (pixels) * 3 (RGB) * 15 (FPS) = 3.5 MB/s or 27.7 Mbit/s. Even this cannot be achieved by GPIO as it can reach at most 22 MHz with bare metal programming (benchmark). The OS has almost no time to do anything other than toggling the GPIO port. In order to be able to capture the video you have to go reasonably lower than 22 MHz. I'm not even sure 1 MHz will be reasonable. But let's say 1 MHz is practical. That would limit your bandwidth to theoretically 128 kByte/s. But to correctly decode your signal by let's say using "Manchester code" just to not need to have another GPIO port for synchronization (clock). This will cut your bandwidth in half so you have a theoretically effective bandwidth of 64 kByte/s. Even compressed video will hardly fit. TL;DR I don't think it is practical for video. While it might work for some low data-rate scenarios. 

IMHO the audio quality never was great on the original Raspberry Pi model A and B. It even got worse with the introduction of the A+, B+ and all following models. There are only two things you can do to improve the sound quality: 

At home I've got Philips hue and along that I've made some custom Pi and Arduino powered LED lighting which I would like to use in the same way by using the hue App. I want to use the Pi as some kind of proxy to the bridge but have no idea how to accomplish it, nor knowledge about the commands needed and so I need some pointers into the right direction. The Pi is able to control everything (the hue lamps on behalf of the hue bridge) and I don't really want to mess around with ZigBee. The idea is to put a Raspberry Pi with a second Ethernet port between the router and the hue bridge. The Pi has the state of all hue lamps by getting the responses from the hue bridge and the state of my custom LED lighting. Queries from the App pass the Pi then the response gets enriched and returned to the App. This way it appears as there are more lamps in the hue App. For that the Pi needs to intercept HTTP requests to the hue bridge (and perform requests on itself), respond to them accordingly and not block any other traffic. That includes DHCP, SSDP (UPnP) and other stuff that are required to access the hue bridge over the internet. 

As you are using v4l2 loopback, you can search for general streaming of camera video. and are keywords you might want to search here. But unless you use HLS (HTTP Live Stream) which is not that easy to set up (at least I did it once and was not convinced from the results regarding quality and delay), you will be stuck with VLC as one of the few players that can open the stream. A more practical approach would be to use something like "motion" that provides your v4l2loopback as a webcam in the browser. (Currently I am aiming for the same goal with an own implementation but it is still not ready for general usage) The latter idea won't work as you'd have to implement a "webcam gadget" for the Pi Zero first. Only more primitive things like ethernet and mass storage are available out of the box. 

As the model A supports back-powering through the USB port, you will bypass the fuses. So it is not a good idea in general. BUT. As long as you do not connect other devices to GPIO and as your only USB port is occupied, you will hardly run into the situation that you route too much power through your Pi. So to my best knowledge your Pi will be save but potentially underpowered. Smartphones don't provide much power through USB OTG. My iPhone is limited to USB devices about 100mA (showing an alert stating a device draws to much power otherwise) which is WAAAY to low for a Pi. As the USB port on any smartphone is protected you will also be save on that side. As I am confident that it will cause no damage to any of your devices I don't take responsibility. To my best knowledte your Pi will be underpowered and run unstable (potentially damaging the file system on the SD card). 

No, not with this multicamera adapter, and not at all. That adapter is a multiplexer. So at any given time you can pick on of four cameras and take a picture. You can switch to the next camera afterwards and take a picture and then switch to the next... you get the point. I am not sure about the speed but if all cameras stay online, it should not take too long. Like grabbing 1 garbage frame and then a complete frame. If the cameras don't stay online, then it will take approximately 5 frames to adjust brightnes and such each time you switch. You might want to consider USB Webcams for that. Those are actually more expensive and offer a lower resolution if you try to come somewhere near the official RPi Cam, but definitively can run simultaneously. I had a setup of 3 very cheap 640x480 webcams running well. 

for that, where X is a letter a-z and Y is a (usually single digit) number. If you don't know what your device is, unplug it, run , then plug it in again and run again. Compare the two outputs and you will see that some sdXY has been added. X stands for the physical drive and Y for the partition. On a Raspberry Pi that would usually be . Create a systemd mount service file with