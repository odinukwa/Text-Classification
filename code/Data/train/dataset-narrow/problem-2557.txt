Your physics don't need to be realistic to be more enjoyable - there have been a few games with unrealistic physics (for example in Prey you could shrink and control gravity); however they were realistic within the universe described by that game. Another good example of unrealistic physics is space simulators: flying a space craft is actually really tricky business; however they really dumb down the physics for the player - so that they can have dogfights without having to fight with the physics at the same the time. If you can logically explain the physical constraints of your universe (and keep them enjoyable) any player will happily accept them. Physics, just like the graphics and sound, are a form of escapism. People play games to escape the constraints of reality; games with realistic physics sometimes do some pretty crazy things (that you would never attempt in real life). With all that being said, the reason that games with realistic physics (according to our universe) are enjoyable to players is because the game so happens to be set in our universe; and therefore the physics are believable - and don't get in the way of the player (because they already know how to interact within those physical constraints). Your first priority with any game component is to make sure it enhances the enjoyability of the game. If that means your physics need to be realistic; then make them realistic. 

You are very close to understanding how the system works. My answer won't necessarily be how Starcraft works - but most moddable games work like this; and Starcraft is either very similar or the same. Firstly the mod system would have some form of a header file for each mod. This would list any 'base' dependencies: in the instance of "Liberty Multi" it would list "Liberty" as the only base mod. This is basically used to build a chain of names and nothing more, so what you are looking for at the end of the day is: 

Side note: Good thinking with using a normalized vector to determine movement, this is probably the 'best' way to do something like this. 

Your solution to the problem is correct - hold your own references. In my games I take it a step further with . Basically: 

The MCTween animation types page will let you see these as animated graphs/values. XNATweener has an elastic tween implementation. Springs An elastic band in physics is usually represented by a long chain of very short interconnected springs, that are connected using a revolute joint (you may limit the angle) and that have a very high dampening factor. This means that each spring: 

Distance-Based You will basically need to take two things into consideration: a threshold (inversely a deadzone) and the dominant vector. Given an like the following: 

You should use a as your pool (unlike most implementations which use a ). The reason for this is because with a if you return an object to the pool and something else immediately grabs it; it will have a much higher chance of being in an active page - or even in the CPU cache if you are lucky. It's just that tiny bit faster. Furthermore always size-limit your pools (just disregard 'checkins' if your limit has been exceeded). Avoid Creating New Lists to Clear Them Don't create a new when you actually meant to it. You can re-use the backend array and save a load of array allocations and copies. Similarly to this try and create lists with a meaningful initial capacity (remember, this isn't a limit - just a starting capacity) - it doesn't need to be accurate, just an estimate. This should apply to basically any collection type - except for a . Use Struct Arrays (or Lists) Where Possible You gain little benefit from use structs (or value types in general) if you pass them around between objects. For example, in most 'good' particle systems the individual particles are stored in a massive array: the array and and index are passed around instead of the particle itself. The reason this works so well is because the when the GC needs to collect the array it can skip the contents entirely (it's a primitive array - nothing to do here). So instead of looking at 10 000 objects the GC simply needs to look at 1 array: huge gain! Again, this will only work with value types. After RoyT. provided some viable and constructive feedback I feel I need to expand on this more. You should only use this technique when you are dealing with massive amounts of entities (thousands to tens of thousands). In addition it must be a struct which must not have any reference type fields and must live in an explicitly-typed array. Contrary to his feedback we are placing it in an array which is very likely a field in a class - meaning that it is going to land up the heap (we are not trying to avoid a heap allocation - merely avoiding GC work). We really care about is the fact that it's a contiguous chunk of memory with a lot of values that the GC can simply look at in a operation instead of a operation. You should also allocate these arrays as close to your application startup as possible to mitigate the chances of fragmentation occurring, or excessive work as the GC tries to move these chunks around, (and consider using a hybrid linked list instead of the built-in type). GC.Collect() This is definitely THE BEST way to shoot yourself in the foot (see: "Performance Considerations") with a generational GC. You should only call it when you have created an EXTREME amount of garbage - and the one instance where that could be an issue is just after you have loaded the content for a level - and even then you should probably only collect the first generation () to hopefully prevent promoting objects to the third generation. IDisposable and Field Nulling It is worthwhile to null fields when you no longer need an object (more-so on constrained objects). The reason is in the details of how the GC works: it only removes objects that are not rooted (i.e. referenced) even if that object would have been unrooted because of other objects being removed in the current collection (note: this depends on the GC flavour in use - some do actually clean up chains). In addition, if an object survives a collection it is immediately promoted to the next generation - this means that any objects left lying around in fields will be promoted during a collection. Each successive generation is exponentially more expensive to collect (and occurs as infrequently). Take the following example: 

Now your logic would look something like (notice I have improved the layout and made it easier to understand): 

You have somewhat answered your own question :) (everything after "so basically"). I don't have XNA here so YMMV with my code. Furthermore - it's (from what I can tell) usually a 1px border. Using Rectangles What you first need to do is determine the position in terms of your . What we do is create some rectangles and check if the mouse cursor is in each of them. If it is we use the associated to move the camera. 

I'm going to look at how some pre-existing implementations work (that I have actually used) - and hopefully that will give you some ideas on how to integrate it with your game engine. Operation Flashpoint Operation Flashpoint (original release) has a command and control system for entities. This is essentially a list of commands that entities had to perform - the AI system would be responsible for carrying out the commands. Entities could be anything: an enemy, the camera, the player, etc. All the entities had to exist 'before the fact' (but there is nothing stopping you from making a 'create entity' command). Let's take the example of two people meeting, having a conversation, getting into a car and driving off. 

Real time strategy games routinely deal with this problem (take, for example, Starcraft 1 which was pseudo-3D) - maybe you could find some literature on how they managed it. What I would do is probably pre-calculate some form of a 'visibility mesh' (akin to a navigation mesh). Each region of the mesh would link to regions that are visible to it. You should be able to lift a lot of logic from light-map generators (or possibly find a light-map library). Ideally you would place a large amount of lights in 'walkable' areas and calculate the light map for each, following this you would resolve similar areas into a single mesh. This would probably result in a large amount of regions near corners - but corridors should be nice and clean. To determine if two entities can see each other merely check if the meshes that contain them are connected; and that they are within field of view range. 

Now we need to figure out how opaque to make the second texture based on that distance and the time. The distance will be in the range 0->1 (because of how texture coordinates work); and we want the 'bright spot' to move from 0->1, reset and repeat - this sounds mightily like a modular problem. The returns the remainder of division - and it conveniently restricts a value to a range (in a repeating fashion) - so for example will do this: