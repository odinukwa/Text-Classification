I don't blame them. It can be very hard for novices to know what's important. You're throwing a ton of information at them (even if it doesn't seem like a lot to you), and it's hard to know what's going to be useful ahead of time. Even if I do know what's important, coming up with a glossary seems pretty tedious and honestly seems like one of those things that you only have to do in school and would never have to do in the real world. (Not trying to criticize, just trying to understand your students' perspectives.) So, my suggestion is: Instead of having students come up with a glossary, give it to them. This can be as simple as a list of classes and functions that might be useful for the current assignment. Don't just send them to the Java API, as that can be very overwhelming to novices. 

Here is a link to a search page that lists every open issue with the label. Here is one for the label. You can further refine these lists to focus on a specific language or look for keywords that you're interested in. Another way you might approach this is to find an open-source project that's maintained by something you already use. For example, did you know that Spotify and Netflix both have GitHub accounts with a bunch of repos? Finally, keep in mind that there is no such thing as too small of a contribution. Found a typo in the documentation? Cool, make a pull request that corrects it! Have a feature request or bug report? File an issue for it! Then start commenting on other people's issues. Maybe start looking into the code if you find one that sounds manageable. 

I don't think this question can be answered in any meaningful way. There isn't a finite list of skills that you need to be a programmer, or that make you a better programmer. Computer science is a huge field encompassing just about every job you can imagine, and each of those jobs requires a different skillset. No matter what your interests are, chances are you can find a place for yourself in the industry somewhere. Skills that make one person a good programmer won't necessarily benefit another programmer. One programming job might require an artistic background, whereas another job might require a mathematics background, or a managerial background. The best answer to this question is going to be very broad. 

One thing to keep in mind is that topics that seem obvious to you (who presumably has years of experience) are not at all obvious to novices. Stuff like: 

You've got a lot of really broad questions here, so it's going to be a little difficult to unpack them all. Consider only posting one specific question per post. Also note that the answer really depends on you more than anything, so a lot of this is hard for us to answer. But I'll offer my two cents: 

This is what you're asking the student to do in their head, so maybe the intermediate step of actually writing out the breakdown like this would help. Make sure the student uses descriptive variable names so they can more easily keep track of what each step is doing. If you do this process of breaking a line down into smaller sub-lines enough, eventually you'll become more "natural" at it, and you won't have to explicitly break it down anymore. It's worth noting that if I saw a line like the original in "the real world" I would ask the author of the code to split it up into multiple pieces, or at least add a comment or isolate it into a self-descriptive function. 

My approach is designed for Processing, but hopefully it generalizes to other languages. Hello World is really a lesson in how to call functions. After they understand the basics, I'd show them how to lookup other functions in either the language reference or in a beginner-friendly list that you give them. In Processing, I'd have them draw a circle or a rectangle, or an entire scene using basic function calls. If your hello world is a console application, then maybe have them display a popup box, or display a message in a window. The specifics of this depend on the language you're using, but the idea is to get them looking stuff up in a reference and playing around with their own code. From there I'd go to using variables. This is different than creating variables. Instead of having students create variables, have them look up whatever predefined variables your language offers. Processing has and variables, so I'd have them make their scene scale to the size of the window. But you would use whatever variables your language exposes. Again, have them look stuff up in the reference or in a list you provide them. From there I'd have them create their own variables and their own functions, which I've explained in more detail in the above questions. But if you're just looking for a follow-up to Hello World, I'd use the above approach of revealing more of the reference and asking them to do their own projects based on what they just learned. 

The first thing you need to do is break that down in a set of smaller steps, in English. I might start that like this: 

Then introduce the IDE and point out specific ways to solve their specific problems. Throwing them in the interface and saying "here are 100 different things this can do" is going to be overwhelming. Build on what they already know, and solve the problems they're already experiencing with a more basic editor. This makes sure that they understand what's going on behind the scenes, which helps demystify the process. It also gives them a good reason to use an IDE, by framing it as a tool that helps make their lives easier, which is what it should be. 

Not sure why you're saying "yes, functions" here, but this is a reasonable thing to include. I would maybe go a step further and try to get to creating classes. Here is the order I suggested in my answer to the related Order to Teach Topics in an Intro Programming Class question: Instead of using "pure Java", I would use a language called Processing, which is built on top of Java (and can be used as a Java library) and allows you to create visual, animated programs without any boilerplate code. Even if you can't use Processing, here's the order I would talk about topics: 

You shouldn't "test" somebody to check whether they're interested in something. You should give them some stuff you think they might enjoy, and you let them decide for themselves. There are a ton of programming languages designed for novices, including: 

Like I mentioned above, whether they're a good way for you to learn programming is more up to you than it is us. We can't tell you what's best for you. I will say that the only way to learn how to program is by programming, working through the process of taking a big problem and breaking it down into smaller steps. Whether you get that practice from tutorials, or from an online course, or from a university, is up to you. The important part is putting in the work. 

I wouldn't limit this to printing text. I would frame it as a lesson on calling functions. Printing text is one example. Showing a simple dialog box is another example. Come up with a list of basic functions, and get them into the habit of looking stuff up in that list. Basically you're training them to look stuff up in the Java API. 

If these are school computers, why isn't Python already set up? Why isn't there just a shortcut on the desktop to the editor? Why isn't the starter code organized in an easy-to-find location? (As in, so easy that it doesn't require an explanation. Like a folder called on the desktop.) Hopefully these rhetorical questions demonstrate my point: if I were you, I would purposely choose tools that make it easy to get started, and I would try to eliminate as many setup steps as possible. This is one of the reasons I love Processing, or if you're tied to Python, then Processing.py. You get a simplified, easy-to-launch editor that includes everything you need to write and run code, and it comes with a bunch of examples that you can get to by just clicking one button. See also: 

I would absolutely not start them out in Eclipse. Start them out with a basic text editor and the command line. They need to understand what the compiler is doing, and how their code is being run. Eclipse is great for advanced coding, but it hides way too much of the fundamentals to start out in. 

Everything you've mentioned is also true of more "traditional" classroom environments. Novices (and non-novices) often have trouble "thinking in a language" or following best practices. This is not specific to self-learners. The only way you fix this is through practice, by actually writing code. You should spend more time writing code than you do learning about it. Try giving yourself homework assignments, or look for assignments online or in a text book. The rest happens more naturally than you might expect. For example, any code you write now will look like garbage to you in 6 months. This is perfectly normal, and it's a sign of how much you're learning and improving. I think trying to learn about "best practices" and shoehorning them into code you're writing now is a bit of a wasted effort. Instead, move on to the next topic, and then revisit your code in a few weeks to see if you notice anything you could have done differently. Take those lessons with you when you start your next project. You should also try to read code, which will also happen pretty naturally as long as your "homework" assignments are at the right difficulty level. Your homework assignments should require you to consult documentation and tutorials, and read the code in them. Honestly I don't think you should worry too much about this, especially if you're just starting out. Focus on writing code that works, does what you expected, gets the job done, and that you understand. Do that as often as possible, and then rinse and repeat. You'll pretty naturally learn "best practices" just by reading documentation and examples and incorporating those in your own code. 

If the students haven't encountered these problems, then they might not be ready to start using a version control system. Another consideration is that students need to understand basic directory and file structure interaction before diving into version control. Do they know how to navigate a directory structure? How to edit and copy files? This is less "common sense" than you might expect, but it's definitely a prereq to talking about version control. All of that being said, I think you should start by explaining the above problems. Discuss how they might "solve" those without version control. Ask them if they've found themselves trying to manually merge files where multiple people were contributing, or if they've found themselves with files named . If students have seen these problems, they'll naturally see the benefit of version control. Present version control as a solution to the problems that they're already experiencing. In other words, don't make it theoretical. Make the lesson practical and pertinent to what the students actually do. Go through some example scenarios. Explain how they might use Git to solve the above problems, and focus on real actionable things they can do: 

Ask them what they expect these to print. They should print , right? But when you run them, they print ! Then explain that this is because values can only hold a relatively small number of significant digits. Change the values to be values and run the code again, and you'll see that is printed like we'd expect. Explain that for many purposes is enough precision, but not for this class. Explain that has the same problem, but with much more precision. Explain that precision is enough for this class, but if they need more precision in the future to use or something. 

This is where a lot of programming lives, in the process of breaking things down into smaller steps and then taking action on those steps. The steps need to be smaller than the student thinks is interesting, that way they can actually write code that accomplishes that particular step. There is a bit of an art to both kinds of planning, and they're both required by anybody who writes code. They're also very hard to teach, other than having students work through the process themeselves over and over again. I like to say that anytime a student has been given a homework assignment where they didn't know what to start, the real lesson was not regurgitating syntax: it was teaching the process of breaking a problem down into smaller pieces and then taking those pieces on one at a time. Shameless self-promotion: I've written a tutorial on this stuff available here. 

Students should understand branches (bonus points for using branches to do pull requests and code reviews), but do you really need to get into this level of detail? Imagine students writing this down as you lectured. Would they really need to know this later, or is it just clutter? 

The list goes on, and the related articles at the bottom of all of the above are a vertiable black hole of fascinating stuff. Artificial Life From Wikipedia: 

I think this depends entirely on the programming language you use. Or maybe more accurately, you should choose a language that allows you to introduce the concepts in the order you want. I would use a language called Processing, which is built on top of Java and allows you to create visual, animated programs without any boilerplate code. I'd start with calling functions. Here's an entire Processing program: 

List the projects you've worked on. Create an online portfolio showcasing the stuff you've actually done. Don't tell me what you know. Show me the projects you've completed that demonstrate what you know. Keep in mind that this won't happen overnight. You won't get to this point just by reading one book or breezing through one online tutorial. You have to spend some time working on a project. 

Why do they need to follow these lengthy instructions? Why haven't you chosen tools that have a simplified setup process? Why isn't that setup step already done? 

These topics can be covered in Java, albeit with a ton more boilerplate code than if you used Processing. 

This stuff is obvious to you because you've had years of experience. But these students have taken a couple classes so far. That's not enough experience for this stuff to be obvious or come naturally yet. So you're going to have to hold their hands a little bit more, especially at the beginning of the course. Spend a class reviewing the stuff you assume they already know, or walking through what you expect them to do. 

Shameless self-promotion: I wrote a series of tutorials for Processing available here. I'd love to talk more about using these in a curriculum. 

The activity that occurred to me was categorical logic puzzles where you're given a list of hints and have to figure out a set of facts using a grid. These puzzles are solved by breaking the hints down into boolean expressions and then filling in the grid. 

This program shows a 500x500 window, and 60 times per second it draws a circle wherever the mouse is. This allows users to "draw" with the trail left by the circles. This leads you to pretty easily talk about stuff like statements and user input. These programs are much more engaging than the typical hello world programs of other languages. Think about all the boilerplate code that you'd need in Java or JavaScript to get a window with a 60 fps draw loop and user input. Processing also lends itself to "graduating" to other languages pretty easily. It's built on top of Java, so it leads to developing "pure Java" or even using Processing as a Java library. And it can be deployed as JavaScript using Processing.js, which leads to developing HTML and JavaScript (which circles back to developing P5.js). Other than that, I love the community built around Processing: it's geared more towards artistic and creative coding, and makes an effort to be inclusive and welcoming to novices. Shameless self-promotion: I've written a series of tutorials on Processing available at HappyCoding.io.