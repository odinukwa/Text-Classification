The problem with academic examples is that unless they are thought about to the same level you would think about your production code the usefulness of the example is reduced. To get the most from the site, you're better off posting your actual code (or as close as possible). Option 2 is broken As it stands, your option 2 doesn't work. There are many issues with it. You've defined as , however you're initialising it with which doesn't compile. The most likely fix would be to change to . Unless you need to know the concrete type, depending on the abstraction seems to make sense (it's hard to be concrete about that, since you don't include the code for ). You also haven't included the code for . The way that you're calling it however suggests that you're trying to assign the return value from into the string value of a cell. This again seems wrong. It should probably be: 

Then I know the error should be thrown. If you want it to behave the way you're expecting, you need to use Overridable functions (as in my example) so that dynamic dispatch from the base class works. 

Your code is pretty straightforward and easy to follow. There are several things that you can do, some of which I've suggested below, to make it easier to update and to form a basis for future programs. main You've written all of your code in the main function. This is a fairly typical approach for people that are learning the language. You keep adding the logic as required until you get to the end. It can quickly become difficult to extend or update. Ideally you want to break main up into logical elements (other classes & functions) that can be connected to form your program. Each element should have a distinct responsibility and should be named accordingly. This will make the individual elements easier to understand and make it easier to identify candidates for reuse in the future. Remove duplication You've written a lot of code. A lot of it is however very similar to other bits. Where you notice duplication it is often a good sign that you're missing a building block (such as a function). Looking at your code, you could break the code up into a structure like this: 

or using the expression bodied auto property suggested by @Risky Martin you would end up with simply this: 

Different people prefer one or the other, but don't mix and match pick one and stick with it. Termination It's unclear to me how you're expecting your threads to exit. Both your consumers and your producers go into loops, which don't have any break conditions in them. This is inconsistent with your , which attempts to join with the consumer and producer threads. Pointer Assignment My compiler isn't a huge fan of this line: 

Similarly, after the move, if I input again, the and will again swap positions. static So, the other thing that screamed out at me when I first opened the file was that it's kind of odd that all of your variables are state variables are , apart from . It seems like it should be static as well, unless I'm missing something? Also, you're not marking any of your methods as static and you're including them in the header file. Is this because you're preparing for another consumer of your functions? Or should these methods really be static as well? 

NPCFactory.java Stores templates for creating normal and boss enemies and provides methods for creating random creatures. 

The application processes two strings "How is it going?" and "duplicate input". The thing to notice in the output is that when the initial three items are added and executed (from different threads), it results in three sets of processing ("duplicate input" is processed twice). If at a later point, "duplicate input" is added again, the existing item in the map is used and so the processing doesn't have to be done again. How important is this? You can detect that you're in this situation from within your , by checking the value of the call: 

First up, I'd start by wrapping your code in a function. This will help to define what it is your expecting to be passed into your algorithm and what you're expecting back out of it. This in turn will make it easier to reuse the functionality if you decide to ask the user for the note information / read the information from a file instead. I'd also think about the comments you're using. Generally I try to use comments to describe why something is done, not what is done. Programmers can tell what the code does by reading the code, so the why is the missing bit. This also helps to stop the comments from getting out of sync with the code if you refactor. For example, this comment adds no extra context: 

The inline comments in the method also seemed unnecessary. If you need to, then explain your algorithm in a single block, but you shouldn't need to comment what every line of your algorithm does. I'd consider renaming to to be more explicit about what the variable is being used for. Node Once constructed, you don't change the member of your class. I'd consider adding a constructor to initialise it and make the member . 

Your tests as they stand aren't great, they are probably adding friction rather than value. That said, it depends a bit on what you're trying to get out of testing in this manner. As an example: 

This seems counter intuitive. Perhaps it should be or something and called by where both of them sit in the class... Player Construction contains an array of players, which it creates on construction, however it isn't responsible for populating the players. This tightly couples the class to in your class. If is called before the players are created the program will crash. A better approach might be to have actually create an array of players and then have the array passed into the constructor of , rather than the number of players. That way, is in a completely constructed state and is ready for other methods on the class to be called. 

Look out for duplication If you look at the code above, it's clear that there is some duplication. Fetching a value from the user, checking it for 0, exiting if it is. This strongly suggests that some of the code can be refactored to remove the duplication. Members Vs Locals Looking at your methods, they are all declaring a local variables (with the same name as the class field) and then returning it, at which point it is being assigned to the class field. All of the methods are private and have access to the private fields. If they updated them directly, it would allow the flow of your program to be simplified. Alternately, you could change them to be more generic input methods so are driven by parameters. Putting some of the above together Using some of the above, you might end up with input code that looks more like this: 

It all fits nicely on the screen, which again aids readability. Comments Some of your comments are helpful, but others don't really add much and some might actually be misleading: 

I can't see anywhere that the thread is told which block it is supposed to check. So, instead of starting 9 threads, one to check each block, it looks like you're starting 9 threads and having each of them check all nine of the blocks. You could partition the blocks and then start a thread to validate each block, but this seems like overkill. Simply starting a single thread to check the nine blocks is the smallest change and probably the right one to make, since checking nine blocks is almost the same amount of work as checking the nine horizontals/verticals. With that in mind, you can simply change the code to the following (an achieve the same result with 8 less threads): 

This isn't a full review, it's just a couple of initial thoughts: Unlike Java, Interfaces in C# are usually prefixed with 'I', so becomes . If you aren't committed to using the microsoft test framework, you might want to consider using something like Nunit, which supports the attribute. If you use the NUnit Test Adapter, you can still run the tests from within visual studio, but it would help you to remove some of your loops, for example: 

It's basically saying write s to the Console, but only until you find an error that isn't an . Then throw that exception. I don't like it firstly because it could have different results based on order that the exceptions have been added to the queue and secondly because it discards any exceptions after the first one. Exceptions for program flow Having which is a private method return void and throw an aggregate exception, which is immediately caught in the public caller, feels wrong to me. You've already collected the exceptions into a queue, why not just have the method return the queue? The caller can then decide what to do based on the collection being empty or not. 

By definition, if is 'F', it can't be 'E' or 'D', why bother testing the isFalse condition, it just muddies the water? The is particularly confusing as to what the intention of the test is, because you're not only testing true and false conditions one one of the variables, you're also calling the function under test with multiple strings. Keep your tests simple and try to focus on just testing one intention per test. Naming Naming is also quite important in tests to help the purpose of the test across. Rather than , perhaps would have been a more expressive variable name. 

Only Read What You Need So, the first thing I noticed was that your method is fetching all of the rows returned by the database. Since you're doing a pretty board full text search on two columns, my guess is that it's returning a fair number of rows. The method itself is then throwing all but the first record away. If you don't need the rest, don't fetch them. Changing the query to only retrieve the first row might help: 

Again, this may be acceptable for your usage scenario (it doesn't matter if processing is occasionally done multiple times, you only add from one thread, the likelihood of a duplicate input is low), or you may need to think about some kind of locking around read/writes. 

Some initial thoughts... The board It seems a little odd that the board array is being passed into the class. I think if you really want to inject it as a dependency into the class, then you'd be better off wrapping it in a class. Alternately, the simpler option would be to make the board a private member variable of your class, which it then has complete control over. As it stands, both your and your class have intimate knowledge about the array and it's size, although the class doesn't validate this in anyway, so if the caller creates an array that's too small things will start going wrong. Checking for tie When you're checking for a tie, you're checking for upper and lower case players ('X' and 'x'). If it wasn't for the fact that the array is being supplied you'd be guaranteed that 'x' wouldn't occur, since you only insert 'X's into the grid. You do the same 'X' or 'x' check when allowing the player to make a move. Winning condition When you're checking for a win, you're trusting the caller to pass in the correct player ('X' or 'O'). If the last player to take a move was 'X' and they placed a winning move, but checkForWin was called with player 'O', it would declare 'O' the winner, even though there is actually a line of 'X'. Checking for line wins (horizontal + vertical) is easily modelled with loops, which will help to simplify your checkForWin method. I'd also suggest taking the winning player from the board, rather than from the supplied parameter. Prompting You convert 'X' to 1 before prompting the player to make a move. Why not just have it be X's move?