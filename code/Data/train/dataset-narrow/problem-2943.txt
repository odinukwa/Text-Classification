Let me note that this question is actually more general than the presented context. It also applies to, say finding an IDE and to finding a suitable language for some project. Finding useful tools is a good skill to have. 

I'm afraid my answer here will suggest that you completely revamp how you teach. The sort of problems that result in issues like this, seem to me to be problems that treat the computer as a fancy calculator. Problems given to students are of the "math-y" type. Some require tricky thinking, of course, but they are unlike the sorts of problems that people in the real world write programs to solve. My suggestion, is to, instead, use simulation as the basis of your teaching. There are many ways to do this, but one of the best and easiest to introduce is the Greenfoot system. It provides both an IDE (for Java) and a simulation framework. There is also an organization for users, Greenroom, who contribute simulation frameworks that you can start with and modify. There are hundreds of such simulations, some with teaching materials, even videos. Note that the Greenroom is a membership site. You will need to join. Here are a few examples. I have used some of them, but not all. Create Flappy Bird Game Fuel Depot Question from APCS-A Greeps - A Programming Competition One of the originals. Karel J Robot meets Greenfoot A robot simulation - from the book. 2d Platformer Similar to Mario. There are hundreds more, both at the main Greenfoot site and the Greenroom. Only the Greenroom requires (free) membership. With these sorts of frameworks and the programming that it involves, the problem you discuss simply won't arise. 

While I agree with this answer that the conditional expression is more than just sugar, I think the following consideration is important in many languages: While the student can be led to always writing with a consistent and clear style that avoids tricks and obfuscations, he/she will also need to be able to read code of others who take less care. So, especially in a language like Perl, which seemingly has an endless number of ways to do things, being able to read may be as important as being able to write. After all, the text of a program is normally read more often by humans than by computers, especially if the program is important. That is all the more reason to develop a good style, but also shows why the less-explored corners of the language need light shed on them. Note that in some organizations, not using an approved style will (WILL) get you reprimanded. Some might treat the idea that you should fully brace every compound statement (if, while,...) in Java as syntactic sugar, but I treat it as essential. Moreover, some things that look like syntactic sugar are really well developed idiom in that language. 

Test taking is a skill that not every student has. It should be learnable with practice, but not everyone comes to the same level. This is independent of subject. Some people just freeze up, some spend too much time on inessentials, trying hard to "get it right." Some students just panic and nothing you say will alleviate that panic. Every exam is like their first ride on a zip-line or their first rappel down a sheer cliff. Like anything else, all of your instruction about strategy will only reach some and everyone's response will be different. However, There are two things you can do. First, my own preference is to avoid stressing tests in favor of projects for grading. Tests are useful for advising, provided that you do advise the students singly when the fall short. For grading, however, projects let students do their best work in a more measured mental state. However, I found that open-book exams are far from optimal. The only exam I distinctly remember badly failing in College was an open-book test in Physics. The problem is that the student will study wrong before the exam and will come to depend on the book in the exam. That is why you heard the page flipping. The "facts" were in the book. I don't need them in my head. Prior to any exam that "counts" you want students to review and practice with the material in a way that mimics what they are likely to see on the test. They can/should provide their own review materials, or you can provide them (not as effective). The nature of the problem is that test preparation for an open book test is insufficiently active. They don't do much to reinforce their own knowledge beyond, perhaps, knowing a bit about where they can find various things in the book. Moreover, your test isn't likely to just ask them to transcribe the book's information, but to do something with knowledge learned. Open book tests actually discourage the actual learning part. An alternative to open-book is to permit the student to bring one standard sized sheet of paper to the exam on which they may write anything they like prior to the exam. The paper should be signed by the student and handed in with the exam (largely to prevent student B from using a copy of student A's sheet). This forces them to be at least a bit active in their prep. A second, possibly valid, use of open-book testing is the following. Assuming that the test period is about an hour, announce beforehand that for a five minute period starting at the 30 minute mark, students may consult their books and/or notes. The open-book segment needs to be short and it needs to be after students have had a chance to consider each question. tl;dr: Consign open-book tests to the dust-bin of history. 

This isn't really related to your question, but I note that many language designers start out with a lisp- (scheme-) like syntax to try out ideas in the language before they think very hard about its concrete syntax. It turns out to be very good for such experimentation. 

I'd still have missed it, of course, since I didn't RTFD first. But if you can make such things lead to student A-Ha moments they are valuable. Forehead slapping may sting a bit, but is likely good for you. But on an exam or quiz, especially a timed quiz, there is too much pressure to get to the answer quickly. On the other hand, there are different sorts of quizzes. If you have a quickie quiz on most days, where each quiz counts very little toward grading, don't worry too much about making every question perfect. This is true even when the little quizzes collectively have a substantial contribution to grades. On major exams, of course you need to be much more careful. If you find that a substantial proportion of your group gets it wrong, or the folks you expect to get it right don't, then you might need to exclude that question from the computed totals, with an explanation and discussion soon after the quiz. 

This may be a result of students not relating their everyday usage of some words to their formal meaning, of course, but the issue really is that you can use teaching strategies to improve that. Some students will fail to "get it" on any given topic no matter what you say, and if you continue to repeat yourself in the same way, especially with the same words and techniques, they will continue to fail to get it. Every student learns differently and most learn differently from the way that you do. Therefore, you need to approach nearly every topic repeatedly but in a variety of ways. A purely logical approach, for example, reaches only a few students. Use a variety of things like metaphor and analogy (such as the one you give in the question and examples along with your explanations. Make it visual (not just textual) if you can. Make it active if you can. There are lots of tricks. Use them all. In the particular example you give, a small improvement might help a few students: 

Pretty printing is good because it lets me see the structure of a program without first fighting to get it into shape. Not typing close brace lets me think about what I'm trying to create, not the requirements of the language itself. Writing a test for a nonexistent feature and then having the system enter the skeleton for that feature is just marvelous. No cut, switch, paste, or mis-spell and correct. It just works. It lets me get into a flow of creation that I can't do if I'm writing just text. Nor can I find a language that I can't write in Eclipse, since it isn't really an IDE, but a workbench onto which you can plug nearly any tool. Like Emacs, it has a lot of headroom (and isn't unique in that, of course). 

Lying is good. But advertise it when you lie. Make sure students make a note of it that you are lying. Pedantic is bad. If you try to explain everything you will wind up explaining nothing. Let me take a simpler example. In java we have a special incantation 

might be preferable and it also better clarifies your intent. None of the above uses of var is necessarily a mind-killer, but an alternative use of what I want to call sloppy typing is. Suppose you declare a new object reference as follows: 

Caveat. Those who work at startups that define their own product have a different view. There, it is often the case that programmers participate in defining the product, but that isn't the common case. 

It just occurred to me that a discussion of Haddock's Eyes can be valuable for making the distinction between a name and the thing to which the name applies (also aliasing, ...). x isn't 3, x is a name that refers to 3. 3 itself is a number. (or if you want to delve deeper - a symbol representing a number...) 

You can make it a small-team effort rather than a whole-class thing. Say, a team of about 5. The team reviews everyone's code in sequence so all get to participate. Instead of a "code-review" it can be a "code-quality-workshop". The team has to write up the results of the review, with an addendum by the code's author about how the code was improved. (Writing is good.) A whole-class retrospective on the process and its effect. (Retrospectives are good.) 

I don't actually think it is necessary to show the differences (or the similarities). Treat Java as a new thing rather than trying to connect the new thing to the old (for these students only). Instead teach Java as a stand alone complete language. My preference would be to teach it from a high level rather than a low level, stressing abstractions via classes and (for you) the interfaces defining the data structures. There is no reason in a Java course to discuss pointers or the preprocessor. Objects are "referred to" by reference variables, not "pointed to" by pointers. Learn and use the Java vocabulary for things. Once sends a message to an object, not "calls" a method. In this way, your C students have a leg up on syntax, and the places where the "look of the language" helps them without getting into, likely only partially correct, analogies that may confuse them. Work on the big ideas, encapsulation, abstraction, information management (hiding), polymorphism, etc, not the (possible, but likely not completely correct) explanation of the implementation. Treat a variable as a reference, not a "box". An object is a thing. The thing responds to messages, just like people do. Use Java analogies, not C based or assembly based analogies. There is no need of the higher to lower mapping. It will confuse some of your students. It buys you nothing. It may be the way you learned, but it is not optimal. The purpose of a compiler for a high level language is to make it unnecessary to consider the mapping to the machine. Too many people forget that and try to teach as if that mapping is essential to understand to use the language. For them, computing is always and only about moving bits. They have learned nothing since 1955. Learn the language, learn the abstractions. Fly, don't crawl. 

The structure is the same, but the relationship between the three variables is much clearer now. (Yes, $index$ is from the solution space, I realize.) If you are developing an example in real time (black/white board...) you can have a mental metaphor before you start. It can even be fun to ask for suggestions from the students for a "problem space" in which you will create names (or even ask for them). This is based, of course, on the idea that students will naturally emulate what you do. If you normally and naturally just use abstract names for things, then they will be lulled into thinking that it is ok to do so. So try, with beginners, to always give them some semantic context in which to think about problems. The above goes for quizzes and exams as well. Give them (only) problems, even quite small problems, in which the names at least potentially mean something in a supposed problems space. In doing OO programming the understanding of a program can be enhanced by using good variable names for objects. If you have a declaration 

Here I think the teacher's instinct and experience is the best judgement. You know your own students best. Your worry, of course, is well founded, especially since the two languages are so different. Learning to think functionally is a big deal and a mind expander. In some ways doing it cold-turkey (with no support) is good to do, since the students need to just thrash about until the see the A-Ha. But that can be very frustrating. It isn't good to leave your students frustrated, of course. Another reason for not using the technique you suggest is that you don't want their functional code to be just misspelled C#, using ideas from imperative and/or object-oriented thought patterns. Code in one language based on knowledge of another can be truly ugly and the programmer can miss the elegance of the new language. And functional program can be truly elegant and mind expanding. To balance the trade-off you can, of course, use "Rosetta Coding" only sparingly. And only when it seems really needed. Perhaps you could start out without it at all and use it only in situations in which the students are struggling, rather than as a main-line technique. You could also use it only when working with individuals (office hours) rather than with the larger group if a student needs to be reminded of the basic structure of an algorithm. Personally, I wouldn't use it as the main structure of the course and am happy to let my students thrash a bit in mildly turbulent waters. But that needs limits also, of course. Salt is fine, but don't over-salt. Judgment and a bit of restraint, perhaps. 

Expanding my comment and those of others to a full answer seems to make sense now. The short answer is, as Ellen Spertus notes, there is no reason not to, but it isn't enough. Young people need good, and honest, guidance about what they might expect from their choices. But the future isn't necessarily determined by things we can see at present, so in many ways the best advice to a student is to "be flexible." Their future will be determined both by circumstances and by a series of choices that they make; not just one choice. Right now, tech salaries are high and job opportunities abound, but a secondary school student's career is years, even decades, away. The world is not likely to look the same over that period of time. In particular, advances in AI may make many software development roles obsolete. At one time, a huge fraction of people in the US were involved in farming. Now it is a tiny fraction. The same is true in manufacturing. While we still have farmers, most farming is managed by giant corporations employing unskilled and low-paid workers. The same could happen in computing. While there will likely always be a need for software development, it might, in the future, be entirely managed by a very small cadre of highly skilled folks. One of the trends in evolution is specialization. Organisms become more and more specialized to their environment as long as it doesn't change. However, when the environment does change those specialists are normally wiped out and replaced by others better adapted to the new situation. If you know one thing well - better than anyone - you may be well placed in some environment, but if it changes you are lost. However, if, along with specialization, you also foster generalization, you are better prepared for change. This is why a liberal education which includes some specialization but a lot of generalization is such a good thing. If you can be good at two or more things you are probably better off than if you can only do one thing well. But, even more important is an attitude that your education won't end at some determined age or milestone. If you truly believe that you can and should learn throughout your life, and learn things sufficiently different from what is needed in your profession, you are well placed for most foreseeable futures. I have an unproven theory, that in the real world, most specialists have a boss (or a boss's boss..) who is a generalist. The one who knows a lot of things and can see the bigger picture is likely better placed to lead than the one who sees the world through a microscope. If you teach, it may well be that the least technical person in your course will end up being the employer of your uber-geeks. However, those with few resources, have a different problem. While it is great to say Do What You Love, you also need to temper it with Do What You Must, or even Do What You Can. But even if you need to compromise for monetary or familial reasons, the attitude of a lifetime of learning can still benefit the individual. This is, more or less the mantra: Yes I Can. Also, for those in unfortunate circumstances collective action and mentoring by peers and others is especially needed and especially powerful. If "daddy" is a millionaire you can probably do what you want, but if you come from a more modest background (as I did) you need to gather the resources you can - mostly other people.