I think a big first improvement for you will be to start DRYing out your code. You should create a function which returns the ratio of two sides -- there is much too much repetition in your code. Something like: 

I think there's serious readability issues with this, and I also can't think of any time I've ever seen a function/method being called inside another function's signature. I'm going to go out on a limb and say this is a Bad Idea -- for one thing, I suspect that automated code documentation tools might have trouble parsing this. More fundamentally, a function/method's signature is its interface with the rest of the world. It just seems like a very bad trade off to muddy the readability of a signature in exchange for saving a couple of times of code. I would refactor to something like: 

Simply put, from an idealistic standpoint, fancy-pants code is always better than cowboy code, but from a practical standpoint, fancy-pants code can sometimes be much worse. So, as a general rule-of-thumb, I would say that you should always fancy-pants-code unless you have a good reason not to do so, and you should accept that there are some very good reasons not to do so, sometimes. I have a lot of experience with this, and I can tell you, designing code well up-front, is WELL worth the effort. It's true, as you said, that good design has more up-front cost, and poor design has more back-end cost, but to say that the two are equivalent, because of that, is fallacious. It all depends how much back-end work will need to be done. As you say, a simple statement isn't really that bad, and if adding more statements to the statement is the worst of the back-end cost that you are going to incur, then it's really not worth the time to add a bunch of complication to avoid something as trivial as that. But if the project grows and changes over the years, a little shortcut like that, to save a few hours of development time, could potentially cost months of development time in the long run. It all depends. Another issue which often muddies the water is that not all fancy designs are actually good designs. You could develop the most impressive fancy code in the world, but if it doesn't actually solve any problems, such as making the code more stable, flexible, or maintainable, then you've actually made the problem worse by all your fanciness. As much as I am a believer of good design, I am also a strong believer in the YAGNI principle. If you haven't read the wikipedia page on YAGNI, I'd strongly recommend it. YAGNI simply means "You aint gonna need it". Simply put, don't add features and complication that you don't currently need. YAGNI does not preclude good design, but it does preclude unnecessary fanciness. Again, the issue isn't whether or not the design is fancy, it's whether or not the design is good. A good design will follow the YAGNI principle. It is definitely possible to "over-design" something. All that being said, if there is no good reason to cowboy-code on this one, as it sounds like their might not be, allow me to offer my perspective on what a good fancy design might look like. My way is by no means the only right way, but hopefully it will be helpful to you. I'd like to think that my fancy way of doing it does solve a lot of future problems and would therefore be worth the relatively small up-front cost. My Way to Do It (Dependency-Injection) Your first instinct was to think that the Factory Pattern would be a good solution to this problem. That was a good instinct, but I don't think it quite goes far enough. Dependency-Injection (DI), which relies heavily on factories, is perfectly suited to this type of problem. Personally, I think it is well-suited for almost all problems, but there are certain problems, like this one, which just scream dependency-injection. In general, the principle of DI is that a class never creates it's own dependencies. So, for instance, if you have a class, and it needs an object, you wouldn't have the class create its own object. Instead, you would have the class request that the (it's dependency) be given to it (injected), usually in its constructor. For example, rather than having something like this: 

Anyway, here's a full program that does comparison benchmarking. Ignore most of it, and compare the and functions against your function. They are largely agnostic. The primary intent here is to back up the 20x performance benchmark above, rather than just stating that without proof. It will also allow, if you so choose, to provide a baseline reference for any recode/tweaks you may wish to do 

If you need your function to be non-destructive of the original matrix, at your function end, to undo this, you could loop on: 

A single simple in-place 2D matrix is much faster than what you have coded (20x faster in fact). Thus, it's all about performance. And, the algorithm matters. IMO, it's appropriate to talk about alternatives because yours is not in the ballpark range as to what is possible/required in performance. It doesn't meet the "most efficient" criterion. In an actual interview situation, this would probably be flagged by the interviewer. Note that, if you were [much] closer, say within 10%, this wouldn't be an issue [and I wouldn't have posted]. I'm not sure that you can meet the objective without a full refactoring of your code. Your solution puts an additional strain on the processor's cache and seems to have more complexity than would be needed. It also seems to use more memory than is required as well. And, a number of the STL primitives you are using, by their nature, appear to access the heap a lot (i.e.) they're slow. I'd say that simply clearing out cells as you traverse would be better than adding the complexity you have [or see below]. Also, for your algorithm, do you have benchmarks on and analysis of how much performance is taken up by each of the STL components you're using. That would probably be required when discussing the time/space tradeoffs. As it is, they are a bit of a black box. Is there a better alternative to for your matrix? I think it adds an extra [internal] pointer dereference [that the optimizer might be able to elide] for each cell access. And, for example, I see a better alternative to using a separate to keep track of visited nodes. When a node has been visited [used], simply OR it with 2. Eliminate your altogether. Then, you can replace: 

If I understand what you're looking for correctly, it's the cheapest rate for a particular phone number. If you already have the rates of each operator as a dictionary of key/value pairs, then you don't need a regex at all. The following code finds the cheapest rate in a set of dictionaries: 

That decouples the interface of the function from its implementation. One nitpick about your above code, which I only noticed noodling around with it now in a shell session: That's a very long function name. It's generally good to be longer than shorter and more explicit than less, but also consider it can be tiring and people have to remember the names of your functions. Try to find the shortest name that accurately and specifically describes what the logic does. I would probably name that logic something like . 

As you can see, that would certainly be undesired behavior. There are three ways to fix this problem. The first way is to use one of the available synchronization techniques to make sure that only one thread uses the object at a time, for instance: 

The advantage of doing this is that, just as in real life, you have made the situation much less complicated, and much more flexible, by separating the business logic (i.e. how the car actually functions internally, what it does, or, more simply, what makes it a car), from the construction logic (i.e. how to build the individual parts and how to wire them all together). You'll notice that in the DI example, the car and engine implement interfaces. Interfaces are very important in dependency injection. The point is, that as long as all engines implement the same public interface, the car shouldn't care which engine is actually injected into it. As long as they all serve the same purpose and are called in the same way, their internal workings are irrelevant to the car. In other words, as long as when you press the accelerator, the engine speeds up, it doesn't really matter if it's a jet engine, an internal combustion engine, or a hamster in a hamster wheel. In other words, the car's engine is plug-and-play. Their are many advantages to this methodology. For instance, DI is used heavily by unit-testing enthusiasts because it makes it very easy to test each class in isolation. For instance, if you want to test the car class, you are in full control of what you give it as an engine. You don't even have to give it a real engine at all. You could give it a fake (mock) engine that just reports back to the unit tester whether or not the car was sending the correct signals to the engine at the right times. Another major advantage of DI is that it avoids spaghetti code and buggy-ness in the long-run. For instance, lets say, in the future, you keep adding more and more different kinds of engines to your code. With DI, you'll possibly never even have to touch a line of code in your car class to do so. The less you have to modify the code, the less bugs you will create. The alternative is to have, right in the middle of your business logic, a whole bunch of construction logic which keeps growing in complexity with each new engine type that you add. Your Project, the DI Way So, what does this all mean to you in your situation? Here is a basic idea of how I would implement it with DI principles. First, I would create a simple interface which would be common for all of your printers: 

If the statement (e.g. ) is wide, this burns a lot of horizontal space and the comment will probably exceed 80 columns. Consider such a comment to be the "topic sentence" of the paragraph. When it's a sidebar, it's effectively like putting the topic sentence at the end of the paragraph. Most style guides recommend keeping the width to 80 columns or less. I prefer ANSI comments (e.g. ) over K&R (e.g. ) as they're much easier and faster to edit. Try to avoid "if-else" ladders if possible. I replaced one of yours with a and the other, in the loop, using a I prefer to put the return type of a function on a separate line [in column 1] and so the function will appear in column 1 on the next line. This makes it easy to find them with a regex like which can make things easier when editing or analyzing source. Never put multiple statements on a single line. This is very hard to see visually when looking at a lot of code: 

To quote an ancient truth, "To every thing there is a season, and a time to every purpose." There is a time to fancy-pants-code, and there is a time to cowboy-code. Experience is what has to guide you in determining which method is better suited for a given task. There are many things that can impact that decision, for instance: 

The beauty here is, you are free to implement these printer classes however you want. If some of them all work very similarly internally, you could create a base class for them that those classes derive from. But if you need to make a new printer class, sometime in the future, which doesn't work the same way at all, you're free to implement it anyway you want. As long as it implements the interface, that's all that matters. It doesn't matter what class it derives from, how it works, what namespace it exists in, or even what library it comes from. So, for instance, if you do have a bunch of printers that all work by sending the same kinds of basic commands, you could create a base class, like this: 

We've already used datetime.now(), it's both simpler than timestamp.strftime and it's nice to not have to introduce new functions unless necessary. There's an even shorter alternative you could use, which trades off a little readability for space: 

If you actually need to parse strings such as '46732 1.1' into dictionary key/value pairs, a regex would be a good fit for solving that problem. A little quick fiddling suggests that something like would capture what you're looking for. This RE matches: one or more digits, zero or more whitespaces and one or more digits followed by zero or one decimal points followed by zero or more digits. You can use this pattern by compiling it, folloed by python's method. 

Also, it's generally considered bad practice to use : if new fields are added to the model they will be rendered for the client by default. It's much safer to use explicitly whitelist fields using the attribute of the meta class. 

Here is your code cleaned up for style as I've mentioned above. Also, look at some of the changes in vertical and horizontal whitespace: 

Edit: This was my original opening section, which has been getting dinged. I'm leaving it in, for reference, but after rereading it, although it might have been tightened a bit, it does talk about the performance issues Caveat: This isn't a critique of your code style [as Zeta has already done that], but rather an alternate algorithm that can be 20x faster. A single simple 2D matrix can be much faster than using the primitives. As you were doing a interview question, demonstrating proficiency might be paramount and this might be a moot point. But, when the performance difference is an order of magnitude faster, that may make the difference. I've had a few related interviews and speed sometimes matters more. Assessing such a tradeoff may, in fact, be part of the requested/desired solution. To eliminate boundary checks, I've created an oversize matrix that has a border of zeroes on all sides. The actual data matrix is inlaid from . This is a technique used in some video/image processing. By using pointers instead of index variables, this also eliminates a number of multiplies within the loop. 

This looks pretty good -- views should generally be pretty minimal. These seem pretty short, and most of what you've done so far seems appropriate. One pattern you might think about is using a mixin to dry things out a touch more. Eg, you have all your methods decorated . If you created a LoginMixin, with and just decorated the method there, you could loose a few repetitions. Mixins are also nice to have, as you can stash other repetitive elements in them as needed. 

Importing is generally considered bad practice, because you don't know what's being imported into your local namespace. For you case, I believe you can get away with just doing . In the general case, if you only need a few things from a module, you can do: