The usual way to handle this is that every time a bullet is fired you set some variable to your cooldown time. Every frame you decrement that variable by the frame time. If you try to fire and that value is greater than 0, you just ignore the fire input event. If that feels bad, a next step is to queue up a "they want to fire" action if they try to click when the cooldown is happening and execute on it when the timer passes zero. 

The thing is, your animated is coupled to the state of the other components in the system. So there really isn't any problem with having your animation component knowing about, or even querying directly, relevant components that contain what kind of internal state you need to represent in an animation. For basic movement stuff, usually what I do is set up some kind of observer pattern. Every frame I check the velocity vector of the object (in whatever component it's stored in) and use that to determine which movement based animation to play. For other oneoffs, I just have the components that handle them see if there is an animation component, and plays an appropriate animation from there. 

Level scripting is generally done through Kismet, not through Unrealscript. Kismet is their visual scripting language that ties triggers/entities together and so forth. $URL$ 

Sure, it's a little more verbose than just saying , but you get used to it, and it doesn't look as nasty as the generic properties. And yes, you would have to do it the roundabout way for your client components, but the idea is that all your common "engine" components (renderers, colliders, audio sources, transforms, etc) have the easy accessors. 

It seems like what you want is a factory. $URL$ What you can do is have your various components register with the factory what name they correspond to, and then you have some map of string identifier to constructor method signature to generate your components. 

It's important to do your research. Playing other peoples' games is a great way to get some case studies. See how their controls compare to yours. See what features you have that they don't, and vice versa. You can also pull from these games to see what gamers expect who play that genre of games. This is particularly important to controls. That being said once you get the core feeling down, the rest of it is usually just details that can be skipped over. You don't need to know the storyline, settings, or particular puzzles that other games in the same genre employ to make your own game. But if you're making a platformer, you'd better know that your movement and jumping is as good as the other games. If you're making a console FPS you should play games that get aiming down properly. Modern RTS games all have a "select idle resource gatherers" key binding, which unless you're making a game without resource gathering you should also include because the players expect it. So no, you don't have to play games religiously in order to make good games. You do have to have an analytical, player-focused mindset, and most players do play other games and have certain expectations. Not fulfilling those expectations can lead to disappointments. 

They both have their pluses and minuses, and I don't think that the little detail you've specified can really narrow down between the two which is better. It would probably be better to pick one based on desired workflow, tools support, cost, and experience of the team, I would think. 

Without knowing much about RL, I'll attempt to answer your question with other questions: Using RL, can you determine if it's possible to reach point A from point B? Can RL guarantee reproducible/consistent/testable navigation behavior? How does memory and CPU run time requirements compare vs. A*? Likewise, how much can you precompute compared to, say, nav meshes? How does RL fair in an environment with dynamic collision? How much more difficult is it to understand and implement RL correctly vs, say, steering behaviors? Are there any good middleware providers for RL? Maybe those questions can help you with your answer. 

(Notice that I specifically didn't put "more control" up there. That's a loaded phrase that could range from "I don't like code I don't write" to "I need to be able to see, understand, and tweak all the variables in the physics engine to achieve this particular effect." The first one isn't really a valid consideration, but the second is.) Personally, I find that rolling your own tech for a low-budget game is hardly ever worth the effort. The amount of power you get the cheap engines these days is ridiculous. You're not at a point where you're deciding on a multimillion dollar triple A engine license or not. You're not going to be able to beat what, say, Unity offers to you for $3k. Or Cocos2d for whatever it costs (isn't it free?). Now, if your game is mostly focused around some kind of tech that other engines can't provide, or can't provide at a reasonable framerate, then it might be worth investigating what you can do. That doesn't mean you throw out the other middelware entirely, though. Just because you need your own, say, renderer, doesn't mean you can't use some other middleware for physics or sound or UI or what have you. 

I can't say enough positive things about FogBugz. It's the best bug/task tracking system I've used. As of FogBugz 8 it even has a decent Wiki based of CKEditor. It supports plugins so you can extend it to do a bunch of stuff (like a Kanban board), or customize its workflow, or do more extensive timesheet reporting, or whatever. You can do self hosted or pay them to host. Now the base solution isn't free, but you can do a "students and startups" hosted solution which is good for 2 users. They have a separate product, Kiln, which is basically Mercurial but tied in Fogbugz (optionally) and has a pretty slick code review pipeline. I talked to one of the guys that worked on it and they said it had pretty decent tools for dealing with the "big file" problem with DVCS solutions (namely that every client has every version of every file, and that not scaling for, say, giant zbrush files), like filtering "big files" by extension, and that sort of thing. 

The guys at Unity are spending a lot of money doing R&D, as well as licensing 3rd party tech to include in their software. The only reason it's free in the first place is that they want to get as many people using it as possible, so when the big boys (read: people who are actually making money doing this and can afford to actually buy software) are investigating tech to use, there's a large group of people who are experienced with using it and can recommend it to the people who have control of purse strings. Plus they have a vested interest with their web plugin to have as many people developing games for it as possible, and most web games don't make a lot of money. The concept is very similar to a lot of software that's "free for non-commercial use". In this case, it's "free for insignificant commercial use". 

There are two very different questions here. All puzzles are games to some extent. Not all games are puzzles. Calling Sudoku a "game" or a "puzzle" doesn't seem to make a difference to me, and I don't think it's a very interesting question. Unfortunately it seems to be the bulk of your question. Maybe there's an argument that a specific instance of a sudoku board is a "puzzle" whereas the sum total of the rules and the concept of sudoku is the "game". What makes a game a "toy" is a bit more interesting to me, if only because some of the iconic games of recent times have very toy-like qualities. Minecraft is a toy. So's The Sims. So's Garry's Mod. Toy-type games are typically heavy on some kind of emergent behavior. Often times it's physics related, sometime's it's AI related, but there's a pretty common theme of a lot of user direction. The idea is that you're not trying to hit some specific game-designer-given goal, but instead you're put in an environment with certain rules and playing around with those rules is what gives you your enjoyment. 

What the error messages are saying is that 1) You can't add a camera to the existing game object because you can only have one camera component per game object (a limitation of Unity) 2) because of 1) the return value of your is null and therefore 3) is failing. Your code doesn't really make any sense because you're trying to add multiple cameras to the same game object. changes the name of the game object the camera is attached to. Components themselves don't have names. Basically, you don't want to use . That's specifically for creating instances of prefabs. Just do and then add the camera to it. The rest of your code should be the same. E.g.: 

I don't think there is a mathematic solution. You probably don't have enough data in the 2D world your items are living in. If your walls were mirrored on X they would be in the "correct" order. Then again you might be able to do overlap testing with the bounding box of the image somehow, but this is an area I'm not familiar with. You should probably sort by screen Y per-tile and say that anything more complicated is a "design problem". For example, if you're authoring the content, just tell your designers the sorting algorithm and to shove wall2 2 pixels up to fix the problem. That's how we had to fix it in the isometric game I worked on. This might include taking "long" items and breaking them up into tile-sized chunks. If you are allowing users to edit the content, the completely safe thing to do is to make everything tile based and at most one tile large. That way you avoid the problem. You might be able to get by with making everything larger than a tile, but possibly only if it's square. I haven't played around with that. 

Some other games do sublists for different types of entities. Like there's a list of projectiles in the world whose loop is treated like the above. This way you don't necessarily have to have everything in the world have a singular base class. 

(I'm assuming you're talking about vertical shooters a la 1942). The gold standard seems to be what cave did in do-don-pachi resurrection: $URL$ Basically all movement is relative and basic firing is automatic. Special firing (i.e. bombs) is done by a touch button off the side of the screen somewhere (do don pachi had different configurations where you could put it vertically on the left or right or on the bottom from the left or right). Relative movement means that if you drag left X pixels on the screen, your ship moves left X pixels. Or maybe X * some constant pixels. Some games have some success with sprite-based control, but you have to make sure that the actual sprite is pretty far above where the actual touch control is so you can easily see your ship. If you do it do don pachi style you kind of get that effect if you start your relative movement on the ship itself, but you get the benefit of being able to touch as far away from the ship as you're comfortable with. 

The iTunes App Store already has a process in place for adding custom terms and conditions to any app you upload. $URL$ Scroll down to "Providing an End User License Agreement". Tell your lawyer about this if he doesn't already know. I'm guessing there's language in the iTunes EULA that says by downloading any app you're already agreeing to its EULA (a standard one is provided). 

Your best bet is to probably use rigidbodys and capsule colliders (a script to get them to behave similar to a character controller can be found here) and then use to get them to pass through each other. 

The Ogre3D rendering library is pretty close to engine code and from all accounts I've heard is very well designed and very OO. $URL$ 

First off, the only time this question is applicable is for Windows-based PCs. Console, smartphones, and mac platforms all have a singular API (or a singular API and a "closer to the hardware" API), so your question doesn't apply to them. "Better" is a terrible term anyway. Better for what? As far as I'm concerned, DirectX is better for Windows since OpenGL drivers are generally terrible. Or at least that's what the Unity guys discovered with their cross-platform engine. I really wish I had a link for that. Maybe at some point in time API X has feature Y which is really attractive (and therefore might seem "better")... but you can't use it because nobody would have a video card to support that feature. And if you made a game that really needed that feature it would be much harder to port it to another platform that didn't use that API. 

You're going to have to break up the image into multiple sections. Probably 1024x1024 for maximum compatibility (source). Then you can just place them in the background in order. 

I think it heavily depends on the kind of experience you want to give to the player. As a player, I didn't like the way Oblivion handled it. One of the positive feelings as a player gaining power and abilities is the fact that you can now dominate what used to be difficult. With Oblivion and it's constantly tuned-to-your-level difficulty system, you lost the feeling that certain areas were safe and other areas were dangerous. Sure, you were fighting harder monsters, but why they showed up felt unnatural. Personally I prefer the more traditional mechanisms. Areas have predefined difficulties, and as the player progressed areas that were previously impossible now opened up. And areas that used to be hard are now a cakewalk. It gives you a better sense of progression. That's not to say that all dynamic difficulty systems are bad. I just think that they need to be more subtle. On Sin Episodes we did a very complicated system that didn't turn out too terrible. The gist of it was that there were a lot of little factors that played into what knobs would be adjusted as the player goes through the game. If the player got a lot of headshots, more enemies would spawn with helmets (which meant you had to shoot them in the head twice). If you were proceeding through the game quicker than our par time, the difficulty knobs got turned up. If your average health was lower than what we would like health packs would drop more often. Unfortunately the curve wasn't linear. One of the switches we implemented was to level up the kind of guys we would spawn for difficulty. The last jump (assault rifle to machine gun) was a lot more of a jump than some of the earlier ones (pistol to assault rifle), and you could get into a situation where the designers would place two assault rifle guys and the game could spawn three machine gun guys (which is a much, much more difficult kind of fight). But compared to Oblivion, it felt like there was still progress through the course of the game as the designers were mostly in control. The dynamic difficulty system itself accounted for only adjusting it up or down a certain amount based off player performance.