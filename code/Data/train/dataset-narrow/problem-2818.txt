Handling 2D coordinates and scaling in Unity is fairly simple, but non-obvious and as you've noticed it's unlike how other dev tools work. Why this happens is because Unity was a 3D engine that recently had 2D graphics grafted in. In particular, 1 unit in Unity is not necessarily 1 pixel in the image. When you import images as 2D Sprites there's actually a Pixels-to-Units setting that could be made 1:1 but I recommend leaving it at the default 100:1 for a couple reasons (the physics engine doesn't work right at 1:1, and the default is better for compatibility with others' code). This scaling setting means that all positions are divided by 100. It's pretty easy as long as you always remember the scaling; when you want to move a sprite 256 pixels (say) then you move it 2.56 You may also want to write a utility function to round numbers to 2 decimal places/the nearest pixel: Mathf.Round(float * 100) / 100f 

You need to provide your own server for hosting your database. Google App Engine is free to start using but kind of tricky because the database is Google's Big Table rather than SQL. So the option I recommend is Kodingen: $URL$ 

Your problem is probably that you had animations nested inside multiple objects; the "Export PNG Sequence" function only works on the base timeline. Fortunately a variety of tools exist to make exporting Flash animations more robust. Many of these tools also turn the images into a spritesheet rather than a sequence of separate images. You'll want your animations in spritesheets (ie. all the frames are assembled into a single image that you display portions of) because that's a lot better for performance. One such tool is Animo (formerly known as SpriteLoq) although that tool has gotten crazy expensive after some updates. The best free tool I know of is Zoe. Note that both tools say they are built for a specific development tool, but they simply output image files. 

I'm not sure what "spatial" or "meta" mean, but diegetic and non-diegetic are actually terms that originated with film music and mean essentially the same thing in the context of game UI. Diegetic means it's part of the scene, whereas non-diegetic means it's not part of the scene. So a diegetic UI is interface elements that are in the game scene (think the ammo display on Halo guns) whereas non-diegetic UI is buttons that aren't part of the game world (ie. the majority of game interfaces). 

"we just need something where we can check files out edit them and then check them back in and build from the same set of files" Use version control; a version control system (VCS) is exactly what you described, with the added bonus that it stores a history of every change anyone has made. There are lots of popular version control systems out there: $URL$ $URL$ $URL$ I don't use Visual Studio personally, but I am completely certain that Visual Studio has support for all of these version control systems. 

So you just need to calculate the direction vector and then do what they said. Now how exactly you should calculate the direction vector will depend on your specific implementation; since you haven't provided us any code I'm not sure what you are doing. However I'll give an explanation based on one common implementation; you simply store the scalar speed of the moving object, and every frame calculate a movement vector based on that speed and the rotation. In that case the movement vector is calculated using simple trigonometry, something like: 

Although I disagree that a flame trap being triggered is something that would only happen once (I could see this trap being reused for many different objects) I think I finally get what you meant about entities that react uniquely to user input. I would probably address stuff like making one door in your dungeon have a fireball trap by building all my entities with a component architecture (explained in detail elsewhere). This way each Door entity is constructed as a bundle of components, and I can flexibly mix-and-match components between different entities. For example, the majority of the doors would have configurations something like 

You probably don't want to be looping through SelectedUnits (not at all, and definitely not twice!) So something like: 

Answering the question in your title, units in Unity are arbitrary. It's just a number; the most common interpretation is that 1 unit means 1 meter, but that's just the most commonly agreed upon value. You could decide 1 unit = 1 foot, or 1 unit = 1 inch, etc. As for why you would use the default setting of 100 pixels, it's because the physics system doesn't like values that are too large. If you set 1 unit = 1 pixel, then the physics system would be moving objects hundreds of units per frame, and the physics calculations tend to break down in that situation. By setting 1 unit = 100 pixels, then physics will be moving objects more like a couple units per frame. 

Well first off you loop through the entire array, when you only want one customer. If you only want, say, mcArray[2] then only manipulate that value, don't loop through the entire array. More generally however, it looks like you are writing the code outside of any function, which doesn't make any sense in this case and even in situations where it works it is a really bad idea. Whatever you're doing on the timer has to be inside the timer function. 

I wouldn't stress out too much about not knowing stuff in advance. I've spent years hearing people talk about stuff I didn't already know (I didn't study computer science in school) and it used to intimidate me, but the pattern I eventually started to notice is that people almost always talk like they knew it forever and everyone should already know it, but that's rarely actually true and it's not a big deal for me to simply make a note "someone mentioned X; learn about that" and then figure it out. You may have heard that a programmer needs to learn new stuff constantly and one of the most important skills a programmer needs is the ability to learn new stuff quickly. Well here's why. 

(I was waiting to see what other answers come first, but it's been a couple days. I've been doing 2D in Unity for a while using 2D Toolkit, but am relatively new to the built-in 2D features) 

Right now I'm not in a place to go over your code thoroughly, but at a glance I'm wondering if you need to declare your code with C linkage as explained here: 

It depends what "performance" you are attempting to optimize. "Performance" is an umbrella term that could be referring to many things. Like, if your load times are too long, then sure not loading will eliminate that wait. But if you mean how fast the game is running during gameplay, then no this makes no difference. Or rather, it certainly won't make the game run faster. It's possible for your game to run slower after making this change, because now you aren't cleaning up everything in the scene and filling up memory. Of course, then your real problem is that you have lots of extra objects filling up your memory, and the memory wipe from loading the scene was covering up this issue. 

Your method is mostly correct but misses one step. You can't simply use the point's position as the vector to get a dot product with, you need to create a direction vector from a point on the plane. Any point on the plane will do (the direction doesn't need to be exact) so just use one of the corners. 

(because I had an older version of 2D Toolkit installed I had to do this in order for this to work; I believe the latest versions don't have this issue) 

You can't be objective in playtesting your own game. Do play your own game frequently to make sure features work, but to test "fun" you should be recruiting new people. 

Realize that setInterval() is more of a target framerate than the actual framerate. As in, the browser will attempt to hit that framerate but may end up slower than that if is doing a lot of work. Thus you really just use setInterval() to set your game loop in motion and then use delta time for all movements. That's where you determine how much time has actually elapsed since the last frame and then multiply all movements by that delta time factor. 

Read in the data when loading the animation, and have the animation code dispatch the event when it's on that frame during playback. 

Unity provides functions for LERP/SLERP and those would probably work well. Basically create a target point at the same position as the enemy except moved to the tower's height, and then slerp the tower to that location. For an example, look for the command Vector3.Lerp() in this code: $URL$ BONUS: You can say "I'm slerping the towers!" 

It depends what you mean by "the page functioning normally". Assuming you mean a browseable webpage within a game, then no. You can make HTTP requests from Unity and thus download the data, but Unity isn't a web browser and won't display the HTML as a webpage. Similarly, Unity can open a web browser to a specific URL, but then that's not "inside Unity". 

There are a number of tools for this purpose. Flash itself has an option for something like Export to PNG Sequence. Texture Packer also can import a SWF. Yet another option, which I used to create the spritesheets for the HTML5 demo on my site, is Zoe, the spritesheet tool that comes with CreateJS. 

I once programmed AI for Tarneeb, a card game very similar to Spades. The person I was working with wanted to do a pattern recognition thing involving lots of stored games and stats on the outcome based on what moves were done in different situations. In essence, the AI would become better over time the more games it played. However, from playing many hands and analyzing my own thought process, I determined that there were just a small number of "algorithms" I would employ to figure out what card I would play. Thus the approach I took was to have the computer use a different algorithm depending on the following situations: making the first bid, making a bid after the first, playing a new trick with Spades in hand, playing a new trick without Spades, playing into an already started trick with Spades, and playing into an already started trick without any Spades. In each case it was pretty straightforward to go from the computer's current hand to deciding what play to make. 

Presumably you hit "Build and Run"; that will cause Unity to first generate the APK, and then attempt to automatically install that on the connected device. Personally I recommend "Build" to just generate the APK and save it somewhere; then you can install it yourself after the APK is generated. 

old answer Personally I would go with option 2 because you don't need this to be 100% secure. That is definitely a lot easier. However, are you sure you don't care about cheating? Whether or not cheating on the mini-game matters depends on the reward for successfully completing the mini-game. If successfully completing the mini-game has any affect at all on other players, then I would consider cheating pretty important and go with option 1. And note that "any affect" can be very subtle. Let's say that completing the mini-game just earns access to a new level for that one player. In that case, I wouldn't really care if they passed the mini-game by cheating. If however the mini-game earned them some visible trophy (eg. a badge on their profile) that other players can see then I would want to protect against cheating. And if the mini-game earned them a special weapon then I would definitely want to protect against cheating. 

When I evaluated JavaScript engines a little while ago my favorite was Crafty: $URL$ There were a loooot of options I had to consider, and some others I liked were: $URL$ $URL$ $URL$ (Incidentally, another option that looks pretty slick initially is $URL$ but considering it costs money and the other options I looked at were open-source engines there were some glaring omissions, like the inability to attach display elements in a heirarchy.)