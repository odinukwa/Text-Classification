In general your code is a good start. Keep going :) However the class should be refactored. Issuelist: 

This is an addition to other reviews. Code Quality: include 'home.php';: In the context of your shared script it's not obvious what it does. I recommend to rename it to e.g. . Further depending on the content there are other more beautiful ways to handle "that". require_once 'class.user.php': Including classes manually shouldn't be practiced anymore. Okay, maybe in an application which has like 3 files in total. However, in larger applications you should use feature provided by PHP using . So, when you try to instantiate a class PHP automatically tries to include the class once if it does not exists in the current context. View & Business Logic are not separated: Nowadays view and business logic is separated to provide a better overview. Further it grants a better maintenance if implemented correctly. Check patterns like which stands for Model View Controller. Other header("Location: index.php"); You perform a redirect without specifying the reason like . 

There are both empty methods and methods that return always true : When a method body is empty it usually means you have not implemented its logic yet. It is possible that one forget to include its logic but calls the method which can leads to a difficult to identify bug at a later time. Therefor I recommend to throw an with message . , : Why does this method returns true/false anytime? Does it switches tags on/off? , : These methods rather append, do they? Or does this word describes appending as well? 

Think about it. Take any 3 numbers (even 3 the same) and run them through that function in any sequence you like. You will always find the two largest. So now we can put all this together: 

You perform a series of maps. Each one creates a complete new collection before the next is applied. If the first line is poorly formatted and there are 20000 lines in the file, your first will all 20000 lines before crashing when it cannot parse that first line. Worse, if the first line is "1/0", which is well formatted but not a valid , the code will split 20000 lines, then parse 20000 s and only then halt on the first invalid input. The solution is to start with . A view is a lazy version of the collection. If you apply a transformation (e.g or ), what you receive is not a transformed collection but a new view with all the original items, each of which will not be transformed until you access it. If you apply a second transformation, you receive yet another view, still with the original items but now with with two transformations which will be applied in sequence (in other words, they have been composed into a new function) to each item as you access it. And so on. So if we change your code to 

Which would give you N copies of the number 1. That's one step closer to what you need. But you don't want integers, you want your function. By now, you have probably worked out that 

PHP-tags are closed It is not recommend to close the PHP-tag. It can happen that you have an empty space after the closed PHP-tag which leads to error. Not closing them reduces headaches :) 

You include an autoloader in the test class. From UnitTests I am aware of a bootstrap file. If such a class exists/can be registered for functional tests as well you should move it to a respective file. 

There are global attributes with the access modifier An object is responsible for its valditity. As of that its attributes has to be setted via setters always and the attributes has to have as access modifier either or . 

Classes are included manually Instead of including classes manually it is recommended to make usage of the autoloader function ($URL$ The advantage is that you don't have to worry about including a class. 

Description: This section describes missing setter, multiple returns and if-conditions. In the constructor of the class Route are multiple returns. This makes the code less maintainable. Having more than one return means there are multiple scenarios when the constructor can be stopped. In case of a bug one need to debug through the whole method to figure out the return-point. So, at this point a switch to if-else-if-else should be performed. Below you see a minimalistic sample. 

As you notice it is better readable. From here there are two approaches how the code can be optimized further. Approach 1: IsValid-methods should be created. These kind of methods performs a validation. 

So, you are generating every possible permutations of the array, which is a O(n!) operation. This is huge. I think this can be done with an O(nÂ²) algorithm. I would do : 

What is the purpose of your class ? You are just using its constructor to run some code which is completely unrelated to itself. You are doing the same thing with the two other objects you instanciate : and . When writing a GUI in Swing, you generally write classes that extend , and the constructors contains the code that initialize the inner components. It's a bad idea to let the constructor have a side effect (the display of a frame) like you have. Also, try to follow the Java naming conventions : variables and types names use camel case, and variables start with a lowercase. When initializing a , you might be interrested in calling the method (generally with or ) 

You can replace by For the rest of the code, it would help if you explain the algorithm you are implementing, or if you name it (if it's a known hash algorithm) 

The function is actually a pattern matching function. It just uses a different syntax than the pattern format of . I suggest you to convert your pattern string (the one with signs) into a valid . 

A big performance killer in your code is the use of mode to open the file. The forces every write to be synchronously written on the physical disk. A quick benchmark gives me a 500x speed improvement just by removing the in your code. I did a profiling of your code, and it appears that the majority of the time is spent in the function. This is because internally calls eight times, and each time a physical write is performed ! You should remove this mode and insert flushing instructions at strategic places. I think is the right method for that. Adding this instruction in , and gives me a 12x speed improvement compared to the original code. 

Now all I need do is create functions which can add to, prune or walk the tree. These will do so recursively, using pattern matching to do the appropriate thing depending on the type of the node. There is more than one way to do this, but first let me say a few things about the example code above: 

This can be optimised to remove the duplicated iterations of fast.next but I left it like this for greater clarity. 

This would be better done with a , with the letters as keys and the corresponding digits as values. The whole chain of would then disappear and be replaced by a single, simple lookup. Chains of are almost always a bad sign in any language. In Java, sometimes is more appropriate, sometimes polymorphism (that is, letting the appropriate class/object decide what is right). In this case, choosing the right data structure greatly simplifies the code. 

then you should have two different classes to represent them. The first type should not have a car field at all. The second should not be creatable without being passed a non-null car object. Depending on the rest of your code, the second class could be a subclass of the first (with the addition of a car field amongst other things) or share an interface with the first (preferred option of those two) or the request could be an entirely separate class, replaced with a car-containing rectification by a factory. Either way, only need specify the second type as input. And immediately a whole category of errors is eliminated. There is no need to check for the existence of a car when it is guaranteed to be present. If you do it this way, you never have to check for the presence of a real car. Any method that depends on the existence of a car simply has to specify the car-owning type. I would not be surprised if other stages in the lifecycle of rectifications can be treated this way. If you create a common rectification interface but 

Not every method has a self-describing name : What does it return? Object Length, Current Line Length, ...? I recommend to rename the method to what it does - . 

Variable definition You sometimes define variables in camelCase and sometimes with underscores. I recommend to use one spelling type only. PHP If function is not part of a class consider developing a database class that handles it. Another option is to add a function to each of your Model classes. This makes your code easier to read. For more details check mvc pattern. In the function you establish a new database connection with each call. You can avoid it by promoting the function to a proper class and define a global attribute holding your database connection. JS In your javascript you have html code. I recommend to either load it with rest of the dom and hide it by default or load it using ajax. I personally compare it with inline css. HTML In html form you have an attribute . It should be in a javascript file. I compare it with inline css as well. "QUOTES" Also see CodeX answer. As tim mentioned and other variables not provided by yourself have to be validated and parsed by htmlspecialchars e.g. to avoid XSS. A bit about security I've added this section due to mentioned XSS. Security is a very complex topic and must not be underestimated. There are a lot of options to implement and grant security. What kind of options you choose depends on your time/budget but also kind of project and data that are going to be stored in your database. I kindly ask you to think wise about the data that will be saved in the database and make researches about proper security measures. There are a lot of PHP Frameworks. I recommend to take a look into some of them as those provide security standards. 

And then you can use to find the content of the groups. There is still one thing missing : the fact that the numbering of the original pattern is lost. For that, you can parse the original pattern string to extract those numbers, to create a mapping table. When you convert your pattern string into a Pattern, be careful to escape the substrings between the using . I don't know if this solution would be an improvement of yours, but it's an alternative to consider. Edit The implementation of my solution : 

Short answer Use a state machine. Longer answer I haven't read your code in detail, but I already worked with the Java's non-blocking sockets. So I can say it's pretty difficult to get it right. I once inherited a codebase that was similar to your code. My task was to write unit tests, in order to be close to 100% branches coverage. I tried to write tests without touching the code, but there are so much states to track (the selector, the buffers, the socket's state) that I was not able to reliably test the code. So, I re-wrote the code, using a state-machine to encapsulate these states. I ended up with 7 small classes, each one representing the state of the sockets, or the state of the request processing. The resulting code was more robust (many missing edge-cases became obvious), easier to understand and to maintain. Writing the tests was easier, then. If I had to do it again, I'd try to use Netty (as Ihor suggested). Netty encapsulates the states too, and manages the connection errors in a more unified way. 

Now anybody using your code can choose to do , after which will return Pattern matching in explicit recursion As Janos said, the best solution is a higher-order function but if you are going to do explicit recursion, pattern matching is often much more expressive and clean, as in 

Do not break down non-matching sequences but preserve them Do discard an initial (as in your code) Wrap failing iterables in and passing iterables in 

but the Scala style is to omit the brackets and braces except where essential. Your BFS method is similarly over-populated. I've slimmed it down a little without altering the basic way it works: 

I would like to draw particular attention to the second for...yield block. By adding a filter to the list expression, I have no need for your inner if block. I also have no need of mutable state; I simply generate a list of counts and add that up. However, while this is definitely more idiomatic Scala and does a little to reduce unnecessary work, it really does nothing to address point 3. One way to do this would be 

From discussion elsewhere I know you don't want to change the basic implementation, so I'll confine my comments to idiom, style and tweaks. I would replace the loop with a 

(for simplicity, assume we have created 3 functions which implement your 3 transformations) then will still be untransformed in reality, waiting to apply all 3 transformations to any item you ask for. So if you then do