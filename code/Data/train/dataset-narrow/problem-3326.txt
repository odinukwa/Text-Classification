Mind you that you will have to switch a voltage in the range of 50 to 100 V - 30 times the forward voltage of each individual LED - thus a high voltage is required that poses the risk of electrical shock. That alone might be reason enough to change the plan. Furthermore it will not work directly off the GPIO pin but requires an additional switching transistor that is able to handle a voltage that high. Other than that a circuit of series LED with a single resistor is, in principle, ok. For this application however I would suggest to limit the number of LEDs connected in series according to the voltage of a suitable power source, i.e. 12 or 24 V, whatever is available. The number of resulting strings then determines the number of GPIO pins required. Again connecting this many LEDs directly to the GPIO pins might not be a good idea either depending on the desired current through the LEDs and the current the Pi can provide. See Raspberry Pi Power Limitations and What are the Electrical Specifications of GPIO pins? for more (emphasis mine) 

As far as I can tell, there is no significant impact on the performance of a RPi-2. I cannot tell the difference in resource usage between this method and the use of a loop; the added advantage of my solution being that the response time for a button press is better. (Recall, if the user presses the button while the sleep function is called, it will not be registered.) 

I find using a console cable very helpful in this circumstance, and much of my time interacting with an RPi is done this way. Use the instructions in the link above and get a terminal program such as putty. Note that the cable currently sold by Adafruit doesn't work with Windows 8. 

Disclaimer: I am not using any HiFiBerry boards as of now, so this answer is based on the available documentation only. 

Check out the community driven Razdroid project that is however - as of today - far from being able to provide a finished version of Android for the RPi. It is stated that they mainly suffer from a proper port of hardware acceleration drivers for the Broadcom SoC used on the RPi. So - again as of today - depending on your usage the RPi might not be the best platform to run Android at a high performance. Update May 2016 Arstechnica found some evidence of future Android support for the Pi3: 

One solution, which I do not find very elegant, is to create a new user and start under that account. The benefits of this approach is that it avoids messing with the configuration files (and, at present, it's the only way I've gotten it to work...); however I suspect it will not be of much assistance when I move from a test-bed (starting the server when needed) to a production-level solution (starting the server at boot). 

I have been using the epiphany browser beta for a while, having installed it using these instructions. Now that the browser is part of the raspbian distribution, should I continue to include collabora in my /etc/apt/sources.list? If not, is it safe to remove this line and expect epiphany to still be installed/updated since it would now be served from a different repository? 

the max. resistance of the wiring is 0.5 Ohm. Or considering the length of the cable (20 m) - 0.025 Ohms/m. With this we find that a cable with at least AWG18 (0.823 mmÂ²) will be required. Expect a typical price of approx. 1 $/m. That's the kind of cable you'd use to wire speakers to an amp. For comparison, network cables have typical strands as thin as AWG22, 23, or even 24. 

After making sure that the system is not compromised: Disable access via ssh by putting the following line in : 

The answer to my first question, is there a way to properly implement in a systemd service is no. Documentation for systemd states that input is not allowed: 

I am attempting to create a safe reset switch according to these instructions. I have implemented the interrupt-based solution (listing 1) which runs fine if I start the script from the command line, but I am unable to get it to work successfully when run from startup. The article was written prior to the implementation of systemd on the RPi, and the suggested use modifying rc.local is not working for me. In debugging the command, I have found that the issue is with this portion of the script: 

Using simple logic gates to kill SCLK for any unselected slave on the bus is exactly the way to go. Turning SCLK flat should suffice, no need to also flatten MOSI. Since Slave Select (SS) is active low an OR gate, e.g. 74HCT32 (a quad 2-input OR gate) should do the trick to or SS with SCLK. HCT should allow for 3V3 supply voltage and logic levels (please check the AC/ACT, HC/HCT families). 

While I understand to premise that the transmission cannot be faked I think that the "build an artifical finger" to press the button is the most complicated way to go. I would like to propose to modify the remote control but in a way that the manual use of the device as a fallback is still possible. Despite it requiring to open the remote control I strongly believe that this significantly simpler to to. 

I have come up with a very "hacky" workaround that addresses question 2, are there other resource-light methods to prevent a python script from exiting. It involves two steps, the first is to create a temporary file and the second is to tail that file: 

The function is used to prevent the program from exiting without using a lot of system resources. Trying to start a service based upon a script with this command, however, fails. I am able to use the while loop in listing 2 in a script assigned to a service; however I'd like to avoid the loop if possible in order to minimize resource use. Questions: (a) Is there a way to properly implement in a script to be called by a systemd service? (b) Are there other resource-light methods to prevent a python script from exiting? 

It would seem that TightVNC isn't part of the official repositories any more. TigerVNC is a fork that is supported by the standard Arch Linux repositories. as root should install it with all necessary dependencies. 

Assuming Ubuntu LTS 16.04 running on the Pi: The default login username is "ubuntu", password is "ubuntu" for Ubuntu LTS 16.04 (Source). This is the clue that there is no user : 

If you need something like I2C (in terms of typical data rate and ease of use) and want to avoid ethernet some other serial connections come to mind. For home automation, the typical distances in a home and the necessary data rates I'd go for RS-485. It supports quite some distances - up to 4000 feet (it's electrically a differential signal) - and also multiple devices on the same bus. Both the Pi and your Arduino can easily be made to work with RS-485 using their internal UARTS and a simple RS-485-Transceiver (a $2 device). Wiring could be done with essentially any twisted pair cable (UTP, STP, FTP) whatever you have available. For full duplex operation - if necessary - you need two pairs otherwise just one. So if you have some network cable around (even Cat3) that should do fine. The two additional pairs could even be used to power the remote device if it is low powered (otherwise the voltage drop might be a show-stopper). 

Sorry to drudge up an old question; however, I recently encountered a similar problem and the various answers here suggested that we need some clarification. I was able to reproduce the OP's problem by disconnecting power to both my router and RPi, then starting the RPi prior to the router. Under these conditions, the NTP service did not have internet access and apparently relies on the hardware clock. tzdata was correct at the time of the problem. 

Rebooting the RPi once the internet connection was restored solved the problem. If for some reason the RPi cannot or should not be shut down, one can restart the NTP service with .