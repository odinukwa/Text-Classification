When passing parameters to a method, you always need to assert that the isn't , otherwise your code will throw and nobody likes them. The generic types and should not be named this way. The "non-written" convention is that the default letter is . That doesn't mean we should use any letters! :) If we check the .Net framework naming, we should rename your parameter type name to , . I think you should switch and for interfaces. By using an abstract class, you prevent the child to inherit a class that might be more useful, especially considering that there are no properties or methods in both the classes. So, using an interface, every child will be free to decide if they need to implement another class. In the class, you duplicate code. There's a method that contains the same code that is called in your constructor. You should call in the constructor instead of calling the same code. By the way, is this method really useful? The variable is , so no one else than you can decide to set it to another value. But you don't change the seed of , so why expose a method for this? I don't think you need that method. And instead of exposing , why don't you expose a method that would return . I think that would be clearer. Also, are you sure isn't an implementation detail? Why would be in your base class? What if the child don't want to use ? I think should be left out of the base class, the child will create their own if they need it. Do you really need this property : 

You got the good start, and some methods don't go hand in hand with that "convention". But, some do! Ex : 

Then, if this method returns , you can throw a custom exception. You need to figure why this didn't work, 'cause I don't know because of lack of context. Is it because of wrong credentials? A user that doesn't exist? Find that out, throw a custom exception. is the worst exception you can throw at the moment (Excluding , of course). The argument isn't null (in your case, in my method it can be), the argument lead to wrong results. You should also wonder if it's normal that you throw an exception? Think about it, Outlook probably doesn't throw an exception each time I mess up my email/password. Maybe that a implies that you should show a message to the user? 

Ok, I'm changing the answer now that I understand what you are doing. The main problem here is -- while Scala people, in general, don't mind special operators, they don't add operators just because they can either. You can replace with the existing just by adding to any one of the terms. Views aren't often used either, and it's important to have a very good understanding of how they work if you are going to use them, and it's not that easy to gain performance with them, since the machinery they use to support non-strictness is quite heavy, and not everything takes advantage of it. For example, will create a new collection before and are applied. Views can gain when you have many mapping/slicing steps, and few elements of it are ever used. Most of the time, iterators will gain you much more performance, at the cost of the mutability problems iterators have. If you want to reduce the number of times you iterate through the list of proportions, there's at least one place where you can simplify: 

We'd usually make the solution more functional. That is, move the "fizzbuzz" logic into something that returns a string, and use that: 

And, yes, was a good start, and for new comers to FP it is not obvious to implement something that will stop at the first incorrect size in functional style -- at least on a strict language like Scala. You'd either throw an exception or use recursion. 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

Much shorter isn't it? Your indentation is flawed, I don't know if it's related to pasting it here or if it's this way in the IDE. Try to respest the IDE's indentation, why is more spaced. Space is cheap, use it ;) Your Connection String shouldn't be hardcoded in the application, get it from a configuration file (web.config or app.config) or at least receive it as a parameter somewhere. 

The code's indentation is pretty terrible. Keeping a good indentation is the key to keep maintainable code. With any good IDE, you can auto-format your code! Also, considering the naming conventions, your variables should be , not . So . And holds multiple files, so you should pluralize it! You should import the instead of typing all the time. You do this using (if you didn't know already). Instead of having : 

When you write code, it is very important to make the said code as clear as possible. Methods named and aren't self explanatory. Think that when you read code, you should be able to understand what a method does without reading the code of the method. To show you a good example of what I mean, I wrote a really long answer about the method being about selecting difficulties but I found out at the end of my review that it wasn't the whole point of this method. I'll attack the method for now. It's sole responsability is to prompt the user for a number. Meaning a better name could be , or something like that! When I name my variables/methods/classes etc, I think about what my method does, resume it in 2-4 words max and that is my method name (works most of the time). In this method you currently have 3 parameters, is quite good, though I might have named it or something like that, just to make it even more clear, but that might be nitpicking. The interesting point is about your two other parameters, and . In your cases (prompting for a difficulty and for a guess), you only validate if the number is within a range. But you might need other kind of validation in the future, for example any number greater than 1 (which is a little excessive I might say). In this case you'd have to tweak your code to make it work. My solution for this is to use . I'm not sure if you have seen those before since they are a little bit more advanced. This would give you the opportunity to let the caller of your method define the validations to be made on the input. For example : 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

The name of the identifiers here suck, and I could have written without trouble. I choose putting them in a because it shows how well it can scale. One could also make and chain them with , for the cases where you want only the first condition. You see this kind of thing used in web frameworks, such as BlueEyes, Lift or Unfiltered, for example. 

As to the objection: in idiomatic Scala, you don't use . If there's some API which might return you a string, then, at that point, you turn it into an , and handle the elsewhere as needed. Handling (or even ) at the method is misplaced. 

Note that doesn't know a thing about or -- it applies to the pattern. Well, anyway, take your pick. Sometimes a problem just isn't worth the trouble, but it is useful to know how to handle the trouble anyway. 

Finally (unless I missed something), the inside can be avoided simply by using multiple , and statements like this: 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

I think you might want to rename your class to since well, the class itself isn't about a missing integer, but about finding a missing integer. And the name fArrayDuplicate doesn't mean much to me. There's nothing talking about duplicates in your code, why is it prefixed with a f? I have a hard time to find a better name, someone might find one. But for now I'd name it or... something like that. 

Check the text change Verify if the input contains a number Potentially change the state of the input (disable/turn red the input) Re-enable it. 

Now that is great, your prompt method doesn't need to know how to validate, it just uses the . Now, this is how we use it : 

Now, I don't have time to go for a longer review, but I suggest you think about the following points : 

A unit test is split in 3 steps. Arrange-Act-Assert. Usually, to make it clear what is being tested, you write as a comment in which step you're at. 

Your code wouldn't compile because you give two arguments but it expects only one. Also, I think your parameter names should be a little clearer than . You say it's in a range, so let's say it in the code : 

In your input you ask how much damage should be dealt. There are much more options that are invalid than valid ones. I mean, I can enter but I can't enter any other number, so there are much more chances I face the error message than anything else. If the only options are the values from 0 to a 100 that are multiples of twenty, you should specify it in your message : 

That is kinda disgusting. First, the indentation (I'm guessing Resharper placed it like that? It always does this to me) isn't cool. I understand that the ternary operator () is good to be split on multiple line, it's clearer. But I really think the definition should be moved to a variable declaration for readability. 

What do you usually expect? An , or that ? The thing is, if a user of your method inputs something, they want exactly that to be done, not a fallback scenario. Let the user know it didn't work, it's better this way. Don't think about recursion, your loop is a very good way to tackle this problem. Recursion has no easy way in this problem I think. I think your solution is very fine. 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

The on can be replaced by using . I'll let you work out for yourself how to do that, now that I called your attention to that method. And, yes, it that method works on as well, though it doesn't appear on Scaladoc for Scala up to 2.9.2 because it is added implicitly. I suggest you use the nightly scaladoc to look things up -- the documentation there is better, though it may show things not available on release versions, and so is the tool itself. 

Looks ok. A is a more interesting way to do this, since you can then auto-close the resource. There's one thing I took an issue to: 

This is longer, and handles nullness in two separate places, and doesn't protect against nullness, but I think it reads much better. To get more than this I need Scalaz: 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do.