Don't worry about the temporary variable. The compiler is going to remove that and it helps with readability. If your delete operation is safe to run concurrently on many objects then it may be slightly faster to run it like this: 

The problem is that — because of array's value semantics — this doesn't account for changes that happen to the array since you started enumerating it. In short, you're swapping in a stale value from before you started sorting the array. Now, what you're really doing here is swapping the elements at two indices, and that is best done with . It's also documented to have no effect if the two indices are the same, so you can get rid of the surrounding if-statment: 

If you're following along step-by-step you'll notice that the of the enumerated array is now unused, so you can change it to only loop over the : 

I see that you're reading the from the array as you're enumerating it and writing that at the , presumably to avoid having to get a to swap the two elements: 

2. You have a lot of unused variables Your variables such as: , , , , , , , , and many, many others are not used. Note: You don't need to make a new for every input. Just declare one privately, and that's all you need. The same goes for , and most other variables. Also, you do not need variables like , , etc., just declare one variable privately and use it for all of your yes/no questions, and you will find much shorter code. 3. Your code indentation is poor It looks like you've indented 2 spaces, however you are supposed to indent 4 spaces after every open brace. Check the JavaDocs 4. Don't use or for varibles Instead, do something like - (while is ), or (while is ) 5. Give variables meaningful names our variables have names that are not very helpful, such as and . Give them memorable names such as for the number to be guessed, and for if they want to play again or quit. is also popular for "play again" variables. 6. Your code is way longer than it needs to be I have made the same program but a lot smaller. This should help you understand how to use methods, indent, write efficiently, and more. Check it out: 

You could consider creating a class that holds the indices for a larger amount of text (for example a paragraph or a section or a subsection in the text). That class would have the absolute index for where in the file it begins and relative indices within the paragraph/section each line begins. Whenever a new line is added or removed only the lines within that paragraph/section would have to be updated and the absolute start index of all the following sections as well. (I don't know what text you write or what you use the line starts for). You could still find a specific line very easily (and probably very fast) by enumerating the absolute indices of the paragraphs/sections and when you find the right section enumerate it's lines. 

This alternative works, if it's a style that you prefer. However, it's iterating the slice twice; once to find the element and once to find the index. To address that I'll use a to iterate over both the elements and the indices at the same time and find the minimum element-index-pair by comparing the elements. Since only the minimum index is needed to swap the elements I'll use tuple destructuring to only reference the once it's found. 

Made your main part the , rather than the . This removed the need for an completely. It keeps looping until is 0. Simplified and shortened(a lot). Changed names of method and variables. 

I created a method, so it is easy to adjust the height of the pyramid, and the output it gives is just as you asked. This code is shorter and easier to understand in my opinion(maybe just because I wrote it), but the main difference is that it is easy to change the height of your pyramid. I named my function . Try changing in the main method, and you will see that the pyramids easily adjust. This program makes one line at a time, prints it and repeats but the line changes slightly. can be even or odd, it works the same. Here's the program: 

This program prints the countdown until it is 0, then it starts a new line, decreases by one, and repeats. 

Welcome to Code Review, and thanks for sharing the code! Your code is alright for a beginner, but there is much work to do. Here are some things that will help in the future: 1. Use methods to avoid repeating code. Here are two examples which should help you: Here's on for when the user wins: 

Finding the index of the smallest element I'll make two small syntactical changes to the code that finds the , partly to leverage Swift features but also to prepare the code to be generic (which I'll discuss later). First, I'd like to describe what this loop is doing as "iterating through the indices of the slice of elements starting from the current index". In code I'd translate that into: 

This change was greatly simplified because I had already moved away from the assumption of indices and instead got the index type from the collections associated type (implicitly). In other words, here is of the type rather than . With this strategy each sorting algorithm can be added separately with the type constraints it needs, and a user of this API would have access to only the sorting algorithms that are available for the type of collection they are using. At this point I don't see any value in the wrapping struct, since these algorithm could be added as extensions to the collection itself in the same way. This solutions also has a more convenient and more "swifty" call site syntax