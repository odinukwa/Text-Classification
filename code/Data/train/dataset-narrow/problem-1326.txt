I was in the process of answering your question on StackOverflow but it was moved to Code Review -- so I'll answer it here. You might be able to avoid using or multiple conditions if you build a data structure that fits your needs. 

I am trying to wrap my head around how to properly use OOP in PHP when dealing with form submissions. The example below is a form for editing course information. I have a class called Course which has methods for loading the class with information from the database and saving information into the database. Everything works but I feel like I am doing this all wrong - any critique/suggestion would be nice. edit_course.php 

Everything is working fine but I feel.. stuck with how to use this object properly with a session. Below is an example on how I am currently using my class. course_catalog.php 

So I am working on a LMS project and I have a User class that will handle everything about the user such as registration, login, showing list of courses that they are subscribed to, etc. User.class.php 

I know there are many existing uploading classes, but I have yet to find one that is exactly to my liking. So I wanted to try and write my own. My goal with this class is to be able to validate files (for now, images and PDFs) and upload files. Though this class is probably not as strong as existing ones, it works as intended. So, any suggestions on how my class can be improved, especially when it comes to error handling? 

A note on performance As for the performance. I can not imagine that this is a particular fast implementation. You use a lot (which means a lot of scattered allocation) your memory access patterns are not very cache friendly and so on. But this is a VERY hard problem to solve generally for all graphs since it is so dependent on its details. solves this with a lot of trait classes and a Visitor concept and is IMO quite hard to use too... and these guys have a lot more experience than both of us. A cheap trick one can do to boost its performance is to supply an allocator-overload to your function. This way you could preallocate a memory arena or even use the stack. 

Since stylistic comments are also welcome I will start very simple. I prefer to reserve upper-case names for macros. Instead of 

If you want to initialise your data from any range use templates and constrain its type to guard for errors at compile time. Prefer regular functions for computations This means, that an implemented function is also a function in the mathematical sense. Same input data produces same output data. I found that this almost always leads to evaluations which do not change an inner state. Thus it smells to me that 

Even if your cache doesn't have enough write activity, with enough read activity the expired entries will eventually be removed. But even if they're not removed yet, the will never return entries once they're expired (it wouldn't be doing a very good job otherwise). The only reason why you may need to call in your case is because of the nature of your : you want to send some information back to the peer, so you want to do it in a timely manner after the entry has expired. It's up to you to define what "timely" means depending on your requirements, but in my opinion, it could be something between 15 seconds and 5 minutes. Anyway, the way it's implemented now, if you have a single, inactive peer (so no calls at all to the methods of ), it'll never receive a logout, whereas with a scheduled task it would happen no matter what. And on the other hand, if you have enough activity in the application, the clean-up will happen naturally with the writes or numerous reads, and an extra, scheduled call won't cost much, whereas calling on each and every call will cause contention because the clean-up needs to sequentially lock all the segments in the to clean them one by one. 

instead. Make use of move assignments Currently you have to copy values into your optional. But what, if you just want to move something big that you want to return from a function? You need to add constructors for rvalue-s. 

Makes a copy of while returning . Imagine val_ is a very big . This could be very expensive in code which calls multiple times. If you want read-only access, prefer to use 

always copies the arrays , deeply can be misused by passing and trusts the user that is chosen correctly. 

Here is an example of how to use to use uninitialised memory. I think this could help you as well. Do not return by value if you can The line 

Note that copying is very cheap since its only a (pointer, integer)-pair and doesn't have any ownership associated with. 

This data structure maps values from intervals of some type which satisfies to values of some type . I remembered this kind of data structure from an interview question. My current use case is a distributed vector where I want to keep track which MPI rank owns which parts of some global index space. I am not sure about the . Explanation I use a where empty optionals are my sentinel for intervals, i.e. marking their end. So when mapping some interval to some value I do this by inserting