The same can be done with the conditions and in the upper levels. The name of the string is a little misleading. is usually used as an index. I think would be a proper name. The resulting code could be transformed from: 

The current method does a bit too much IMO. It parses the string and also finds the solutions. I'd split that in two parts: one which gets all the possible numbers starting from the original string and one which finds the solution based on the numbers taken from the additional method. 

Obviously it has to be translated in Java and to be readapted/debugged/tested/etc. The end result for the string should be something like Let me know if something is unclear. 

should be moved to another method (in order to follow the Separation of Concerns principle). In your methods, you access too many times (even in cycles). Given that the length doesn't change I'd suggest to memorize it in an variable. For readability's sake, you could transform into That being said, if performance is key, I'd overload the methods with some other methods that work directly with instead of and contain all the logic and call those from the methods working with . 

Also, regarding the magnitude of the numbers, I'm assuming you're going to use s once you get the algorithm up-and-running, otherwise you won't be able to manage the range of numbers you indicated. 

I'd say that there's a flaw in the logic of the code in the cup :). It should be more like the following: 

This change allows you to remove the line. So, in short, the method should become something like the following (not tested): 

Personally, if I wouldn't want to refactor the code too much (because the project is too small or whatever the case may be), I'd go with: 

As for the chosen algorithm and possible alternative I'd suggest Iterative Deepening DFS. It has the best of both Depth-First Search and Breadth-First Search - it's complete, finds the optimal solution, and doesn't use too much space. Let me know if anything's unclear. 

IMO this method does a little too much. It: checks if the parameters are valid (, which I think should also be given the context) and also takes action to prevent the application from going on (throws exceptions, in this case). I'd change it into something like the following: 

can be executed in \$O(1)\$ time instead of the current \$O(n)\$. The resulting code after the change should be something in the lines of: 

Start with an empty tree with a single root Expand the root (insert the nodes for the first level) with the possible elements of the first bag If sum from to is then there is no need to proceed further on this path. If sum from to is increase counter and stop expanding this path. If sum from to is repeat point 2 with the current node instead of the root and by expanding the node with the possible elements of . 

I'd approach this in a different way. Looking at the problem I'd sum the different bag capacities until they are \$<= n\$. The moment the sum becomes \$> n\$ I have to stop incresing this sum as it would be useless. Doing this kind of reasoning I'd go with a tree structure. The max level of the tree should be the number \$k\$ of bags/buckets. The spanning factor for each node in the -th level is (from 0 to max capacity of the bag). So, the operations of the algorithm should be the following: 

Transform it from the original format (in this case ) into the format of your choice (in this case ), Get the two s representing the two sides of the . Parse the two s and build the resulting object. 

In order to transform the original string to an accepted string you just have to do some substitutions and then by splitting the accepted string by you get the values. So, to recap, in order to parse the you get in input you have to: 

This approach has a time complexity of \$O(n)\$ in the worst case (when \$n\$ is much greater than the number of cached elements) and \$O(1)\$ in the best case (when \$n\$ is smaller than, or equal to, the number of cached elements). In the average case the number of calculations is reduced, but still remains \$O(n)\$. The space complexity, on the other hand, is \$O(n)\$ in all cases. Let me know if anything's unclear. P.S.: The same logic applies to \$G(n)\$ and \$W(n)\$. Also, all code is pseudo-code, it's there just to better explain the idea. 

I'm developing a web application for simulating electronic circuits and I'm trying to add backward propagation options (guess you can immagine why). During refactoring I came up with a base class for logic operations and wanted to ask for some feedback (whatever pops up in your mind) on it. The class code is the following: 

In my opinion, there are a few improvements that can be made. I'll address only some readability issues here, not the performance or algorithmic ones. Remove regions There are a lot of discussions on this, just google it and you'll find a ton of discussions. The methods are too long Try to reduce them by using already existing object or methods. For example: 

Just taking into account the code that's present in the question here (and not considering a possible extension scenario in more tasks): Being that you have to wait for anyway, I'd suggest to rewrite the code in the following way: 

There are a few things that popped in my mind seeing this: Generalization The method can be used to split any enumerable/collection/array, but this is just a minor point. 

I'd go with removing the block. In the conditions you just have to check that is smaller than the array's length. I'd also avoid throwing the and instead just return a that cannot exist in any maze, if such a point exists, or , but that's just a preference of mine (I don't like throwing many exceptions and tend to keep them to a minimum, especially if we're talking about checked exceptions, see here why). 

Talking about performance, the block costs. I would change the way you handle errors in your code. For one example, I'd change: 

Given that the sum of \$n\$ matrices is independent for each couple of matrices you can sum the \$n\$ matrices in groups of 2 in an async way. You just need a queue of objects. 

For more ways to handle exceptions I would suggest to read this article. That being said, try to avoid creating new objects inside cycles where possible. For example: 

because I find the control not really useful. I mean, if the is then nothing happens, remains . Better yet (in my opinion), if you add a constructor: 

This class is used in the following way in a second class which should be the class that is used from the various gates: 

and, by taking a look at the delegate, you could transform it (but it becomes a little less readable/understandable) into something like: 

As for a review for your code, I don't see any major issue. I'd just suggest to be consistent with spacing - you sometimes put 2 empty lines between methods and sometimes 1, and also sometimes put an empty line before the end of the method and sometimes don't - and also to be consistent with brackets (put them even in 1 line s). As for the solution, I'd just transform it into an iterative one. Your solution (which is the same one I came with) is similar to the Insertion Sort for arrays, so I'd argue also about the complexity you came up with. Let's discuss about the algorithm here. We have the following statuses in different times: 

The methods are not tested, they are just an idea of how to approach the problem for a single prefix. In the case of multiple prefixes we could also execute the method in a different thread for each prefix. Also, I'd suggest you transform into or, better yet, into (see point 1 and this page for the reason why). In the last case we could transform: 

In addition to what's been already said, I find the method way too long and that it does a little too much. Too make it easier I'd start with transforming the original string in a format that makes it easier to parse, for example by using only to indicate the range. The intervals become something like: 

and let the management of special cases to the caller. In this way, the first line of the method becomes something like the following: 

Reduce the space between the lines of code. Right now is a bit too much. Reduce indentation. Reduce width. 

Regarding the complexity of the algorithm we have that time complexity is \$O(AvgBagCapacity^{NumOfBags})\$ (that is reduced a little by breaking the computation early). Regarding the space complexity depends on the approach used to expand the tree. Personally, I'd suggest to use a depth-first approach as it reduces the space complexity to \$O(AvgBagCapacity * NumOfBags)\$ (if you don't keep the already expanded nodes in memory). If you want to furtherly reduce the space complexity you could use lazy initializations of the nodes so you use only one node at a time. By doing so, the space complexity is \$O(NumOfBags)\$. For the sake of clarity I wrote some code which does what I described. Obviously it has a lot of room for improvement (starting with the naming :P ). I also included some tests (the first two are the same as two of your examples) so you can do comparisons and play with it. 

First of all, I don't know python, so my answer will be pretty generic. That being said, let's address your doubts: 

The former should be extracted and put into a method or just return the longest sequence if you're out of the loop (and this takes care of your concern #2). The latter can just be taken out of the condition. The code inside the loop can be written as follows: 

To answer your question In my experience, there's (almost) always a better way :) As a review to your code Everything looks good to me. The one thing I'd change is the following piece of code: 

In my other answer a discussion was born on the performance of 2 methods. In this answer I decided to post the code of the tests I ran for whom may be interested: 

You declare variables inside cycles in a lot of cases. Bring the declaration outside of the cycles and assign them values in the cycles, in this way you create the object only once. Also, don't concatenate strings using the operator when you are in a cycle. Use the object. You also do some operations that are not optimal, like which is equal to . Also, can be written as which could also be put inside a block to catch overflows if it's needed. Regarding the objects, try to replace them with s. In the case of the method that you use in the code, you could just define a extension method for s. After this refactoring the code would look like the following: 

I agree with what @BCdotWEB said. In the first point though you could continue using and if you want to just improve readability transform it from 

Avoid wrapping all the code of the method in a block. Here are some ways to deal with exceptions. Also, be consistent with spacing and indentation in order to improve readability. 

Another optimization I would suggest is to try and change the method into a set operation (try to get all items via a LINQ query). Just keep in mind that doing it in this way passes the burden to the database. 

As usual, I'm open to any type of feedback, even though for now I'm concentrating more on functionality and readability rather than performance. Let me know if you have any questions. 

Except for indentation (which I'm guessing is like this only on the question) the code seems pretty readable. Regarding performance I'd have some suggestions: 

and set the and as fields/variables (they seem kind of magic numbers now). Basically, the refactoring just reduces the depth of the code, but that's just personal taste. As an alternative method The critical point, IMO is to know what the input string represents and seems like you've already taken care of that (if I understood it correctly). Everything else should be pretty easy. The way I'd go with it is the following: