I have this shader that works well on my computer (using an ATI HD 5700). I have a loop iterating between two constant values, which is, afaik, acceptable in a glsl shader. I write stuff in two arrays in this loop. 

And here is the more detailed config that doesn't work (should also be compatibility profile, although not indicated): 

I tried my program on another computer equipped with an nVidia GTX 560 Ti, and it fails to compile my shader. I get the following errors (94 and 95 are the lines of the two affectations) when calling glLinkProgram: 

Then simply write an initializer in c++ that will instantiate each of the three interface and bind them to LibRocket. Call it from Java at the beginning: 

Also, Wavefront .OBJ format specifies that the index of the first vertex is 1. In OpenGL, it is assumed to be 0. So you might want to decrement each int of your vector to get correct indices in your array buffer. 

This might be tough and I'm not convinced that you will have acceptable performance on android devices at the end, but it seems that at least one game has been released on android using LibRocket. You can write a few wrapper classes in c++ that allow LibRocket to use your own rendering functions. These classes can call back the proper java functions of your engine. You will also need, on the other hand, to forward input from java back to LibRocket using the provided method. Here is a more straightforward description of the steps: 

I think my code is valid, I don't know if this comes from a compiler bug, a conversion of my shader to another format from the compiler (nvidia looks to convert it to CG), or if I just missed something. I already tried to remove the statement and I still have the same error. However, if I just write this: 

At first, you must know that you can run a given version of OpenGL in two different profiles: Compatibility profile is supposed to be compatible with the previous versions, and Core profile which doesn't support previous versions but might be faster/smaller. There is also a forward compatibility mode, best for you is to check on OpenGL website for more details about them. Assuming you're using wgl to create an OpenGL context and glew, here is a code snippet that gives you access to advanced options such as version and profile: 

Don't forget to include to get access to . If you're not using glew (or something equivalent), I think you should do, especially if you're working under Windows and want to avoid a lot of pain. 

Then I don't have the error anymore, but it's really unconvenient so I would prefer to keep something loop-based. Here is the more detailled config that works: 

You can't make Kismet function in the sense that it will exists once in memory and can be called from several places at the same time. Every time you want to have the same piece of script, you must duplicate nodes. However, you can use sub-sequences to clean-up a bit your Kismet canvas. A sub-sequence is a single node into your main sequence, which contains itself several nodes. It can have inputs, outputs and also variables. At first, right-click on your Kismet canvas, and create a new sequence (which will actually be a sub-sequence. Now you can select the subsequence in the Sequence treeview. Do it and add some action nodes. You can create an input to this subsequence by adding an event "Sequence activated". You can expose variables (for exemple, actor references) by adding a variable "External variable" You can create an output by adding an action "Finish Sequence" (in the Misc category) You can see the subsequence in the parent canvas with all the inputs/variables/outputs you created. When you're done, you can copy-paste it as much times as you want to make a copy of the same piece of script, and simply links the corrects input/variables/output to it. But remember that if you want to modify this sub-sequence afterwards, your changes won't be propagated to the other copies. You have to modify one of them, then delete the other ones and re-do the copy-paste for every other instances. To be clear, this won't improbe the maintainability of your Kismet script, only the reading of it. Finally, it is also possible to export a sub-sequence to a package to use it in different level. However, it won't be editable anymore after that (you can't open a Sequence from the Content Browser with Kismet), and by experience you may have trouble to import it in your kismet scripts if you do this. 

We can stop reinventing the wheel by... ceasing to reinvent the wheel. Use external libraries, game engines, etc. I get the sense that people do reinvent the wheel to: 

Where each state on the stack references its sub-items. When a button is clicked, it's corresponding state is pushed onto the stack, and becomes the top-most item which is drawn and interacted with. Usually, you would only draw that top state, unless there is some kind of transparency between layers, in which case you would draw from the bottom of the stack up until you draw the active state. 

ROAM stands for "Real-time Optimally Adapting Meshes." It is a level of detail algorithm for rendering large terrains. It's somewhat complicated so I'll link to some more in depth explanations: Here is the paper: $URL$ The following is a slightly less academic explanation: $URL$ 

One way to do this is to add "markers" in the scene geometry file itself. You would use a specific naming convention on these markers (which are just pieces of geometry) to represent various things. For example: 

I would agree with you on this one. If you spend all of your time building a cross platform game, it will never get out the door. I think it's best to try to predict which market it would succeed best in, and built your game to target that marker. If the game does really well, then you should consider porting it to other markets that make sense. If the game doesn't do well, and you think it could do well on another market, you might consider porting it anyway. 

This is usually done using a stack of game states. For example, each item listed above would be pushed onto a stack as follows: 

The XNA collision series is very thorough for 2D collisions, covering collisions between bounding boxes, heightmaps, and per pixel collsion. The sample is for XNA but the concepts can be transferred elsewhere. $URL$ 

An MMORPG using XNA over Xbox Live is currently not possible. You can't access servers other than Xbox Live and even then you can't have a dedicated server (although technically you could use another Xbox if you wanted to but even then you would have no external access and would need a really good internet connection) to manage your game state. The marketplace is not available either except for downloading the game itself. If you develop the game for PC you can have whatever networking code you like, however on Xbox you are very limited as far as multiplayer. 

I'd say match it to the way you want your game to be perceived. If you want it to come off as a casual game, name them something like casual, normal, tough, hard, etc. If you want the game to come across tougher, name it like gears of war--casual, normal, insane, etc. It's really up to you. Keep in mind that how you name your difficulties will also somewhat affect how the player feels after finishing them. It's much more rewarding to complete "insane" than "hard". 

If drawing your dynamic objects all the time doesn't provide too much of a performance hit, it can sometimes be better to just dispense with recalculating a tree for them every frame. Another optimization is to only recalculate the tree when objects have moved a certain distance or are traveling at sufficiently high speeds, otherwise you'll probably end up with the same tree every frame anyway. 

Well as far as C++, C#, and C# with XNA are concerned, Visual Studio has excellent debugging tools--pause the application in real time at any point in the code, see the values assigned to variables at any time, step through function calls, analyze the call stack, and more. In addition, tools like Pix and the CLR Profiler make development with DirectX (Pix) and CLR based languages (CLR Profiler) great. In addition, one especially useful part of working with games is that we have this giant area to write debug text, graphics, etc to. Realtime graphs of memory usage, number of objects/vertices drawn, framerate, etc are common things to draw to the screen.