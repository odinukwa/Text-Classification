Sure. In fact, presuming it's been updated to include recent kernels, you could put it in any model of pi -- except it probably won't fit most of them, unless you happen to use a microSD card with an adapter. However, that doesn't mean there can't be any snags. Most of those would apply to the quad core models though, and in particular the Pi 3. The only thing that would impact the 256 vs. 512 MB models would be if you had a software stack configured to run at boot that required more memory than the former could provide -- which is easy enough to check. 

For #1 (seg fault), no, not unless you can fix the program. There is no logical reason for a program to try and access non-existent memory and anyone who programs in a language which would permit this (many of them don't) tries their best to avoid doing so. If they fail, then this constitutes a bug in the program, which is what your problem actually sounds like. Such bugs can always be fixed, but this does not mean they all have been. To make sure that last point is clear, although technically it is the OS that kills the process, this is a bit like shooting yourself in the head and saying technically I did not kill myself, the gun did. There is nothing else that can happen. With regard to the out-of-memory issue, you should first identify this is actually the problem. If, before you hit the button, shows almost no memory available, then after the system crashes, run . If it says anything, then this would confirm what is happening. If that is the case, again there's not much that can be done if there is some bug in this program that keeps gobbling memory, or if it simply needs more than the Pi can provide. 

If this situation is unavoidable and long term, your best bet would be to get another pi that you can put on a network and then take it along to update the other one. If you have a long dependency chain you've fetched using the method, you might save yourself some time by sticking the in and just running on the one package; otherwise you'll have to them individually. 

Reboot/shutdown can be triggered wirelessly if the system is connected to a wireless network. You could also attach an IR receiver for this purpose, or use a physical button on the casing, etc. You can do it however you want, as long as what you are doing results in the OS being told to shutdown or reboot. 

Which restricts incoming HTTP (port 80) requests to a single IP if there is a default rule that incoming packets not ACCEPT-ed will be REJECT-ed. Rules are generally grouped in order into a file and then fed in via -- once you have these worked out you can append that to to load them at boot. Keep in mind that firewalls are your first line of defense, not the last nor the most important, and they are limited in what they can accomplish. This is discussed in the footnote ("the most important part of network security takes place at the application level"). 

As per the comments, this has probably happened because you wrote the script on a windows machine. Windows/DOS uses 2-byte CRLF ("carriage-return line-feed", aka. ) line endings for text, whereas unix derived systems use 1 byte (just the ). This is why if you read text written on a unix derived system on a DOS system there may appear to be no line breaks (I don't know if some windows tools now automatically compensate for this). Wheras the other way around, there are line breaks, plus an extra character () at the end. converts one way and converts the other. They are in a package together on Raspbian: 

If a card works in one rev. A pi but not in another, the second pi is broken. Of course, it could be faulty anyway, even if it is made in the UK. The Chinese ones (which are no longer being produced) have a black headphone jack, the UK ones are powder blue. There is so much material already online about creating and using the SD card -- and it is very simple -- I do not see a point in repeating it here. If it doesn't work, it doesn't work. You could obviously try another SD card to rule that out, etc. The way I would deal with this, if you decide it is the pi, and you can afford the $50, is to order another one, possibly from a distributor that only does the British ones (Farnell/Element 14). If you can't get either of them to work, either you are really unlucky or doing something wrong. But if one works and the other doesn't, you have a pretty good claim to send one of them back. 

You can reliably get 1 Mbps (i.e., 125 KB/s) duplex connections using the UART, but this is much slower than normal networking. 

So you might be able to boot Windows XP in under 4 minutes! In reality I think it will be more, presuming XP doesn't really exploit multiple cores much in boot (maybe it does, I'm just guessing). The only way to find out for sure is to try...but I think you are going to be very disappointed. 

The 17 is for the gap between the partitions (look at the start and end sectors in the table). The image, however, is only 47676928 bytes (presumably the actual filesystem is smaller than the partition, so this is a trivial discrepancy that will not matter if you are writing it onto a larger SD card). 

Wait ~5 seconds between the last two commands; you'll see a bit of output that might include some inscrutable warnings but ignore that. Now try . Hopefully, you see wlan0 listed with an associated address. You're not connected. If that works, leave a comment and we can possibly automate that. 

Then add the pi user to the group. The new group, and the pi user's membership in it, are permanent (until you change them again). However, the dev nodes are actually created at boot, so any changes you make to them will not persist. You can make that permanent by adding a udev rule. Create a text file in called mydevice.rules (or anything with the suffix ) and add a rule: 

There is plenty of material around on the web if you search "linux access point" and not "raspberry pi access point" (feel free to try both of course, but don't restrict yourself to just the latter -- most of it is regurgitated from the former, sometimes in excessively terse and garbled form).1 You probably will run into a problem or something you don't understand, but at least then you can ask a more specific question (like the other one). Do not expect someone to just write out yet-another-access-point-tutorial for you ;) Web server Running a web server is a completely separate issue -- and almost certainly there are tens of thousands of pages online about running a web server on linux; 30-40% of the internet is linux based web servers. The most popular option for beginners is probably Apache; and the usual introduction to that is via the LAMP stack. Note you only need an SQL database if you want one, and the "P" could really be "_" to indicate just about any language can be used in place of PHP (the "LA__" stack: linux apache blank blank). Looks like there's even an experimental lua module which is probably worth trying if you like that (except it will probably be shy on tutorials). You can also write a webserver directly in lua using the luasocket library, but this requires you understand a certain amount about how HTTP servers and networking generally work. Another very popular choice on the Pi (and everywhere else) is Node.js. 

X would run, but then shutdown would run too, right away (obviously pointless). You don't have to use that trick if you don't care about having shutdown come in -- as mentioned the user will just end up with a login prompt. But it does seem like a useful idea, since then you can just turn it off with . Another idea, if your app is closeable, would be to use in the init script, which backgrounds it and allows init to continue normally (this is fine; X will still be running and have control of the display -- "backgrounded" is a maybe a confusing term). Instead of in the init script, put in the xinitrc instead: 

Presuming you are using Raspbian jessie, there should be something you can add to . You can override the default target of systemd to use a non-graphical target: 

1. Note that it does not match up with the from , or . But if all else fails you can try those and whatever else you want, e.g. . In my tests none of these resolved to a commit from the public repo, but the chance of ending up with a hash that's coincidentally both an actual commit and not the one you want seems pretty slim. Or (see the last paragraph of #2 above), you can just browse commits via the web...