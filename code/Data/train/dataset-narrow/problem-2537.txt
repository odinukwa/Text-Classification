Sockets are truly real-time; messages are pushed across the wire and received very quickly. Comet can make PHP more real-time, but it's still a more complicated process to use MySQL as shared storage for message-passing. I personally implemented the second method some years ago, when I didn't have access to run a server but had a shared web host which supported PHP. Nowadays, I would probably use the first method, writing a custom server and hosting it on a VPS or some other server I had access to; perhaps even a "cloud application" service like Heroku. 

I think it's a great idea. The language is certainly capable of it, and especially if it's what you know, don't spend a bunch of time learning a new language just because it's "faster". The real bottleneck of your server will be network latency; an extra millisecond or two because you used C# instead of C++ won't make a difference. 

As for your other two sub-questions, just store them however you want to store your data. You already found the different ways to store data, as you posted in your answer, so read through them, figure out which ones will satisfy your requirements, and then pick whichever one you think would be best and go with it. All of them survive shutdown and reboot (thus the concept of "storage", versus just an in-memory variable), and the ability to extend them is up to you to engineer. 

Here is a list of genres, description of possible gameplay/activities, and an example game demonstrating that genre/gameplay: 

texture becomes the output sprite, as a Texture2D. The code isnt really doing a change here to the spriteTexture. But it illustrates how the spriteTexture is rendered to a new RenderTarget. The actual change would happen just prior to the spriteBatch.Draw method call, where some effect, or modification to the spriteTexture would be done, eg, removing some pixels because of the explosion. 

You need to add fog as parameters in a gpu shader file. For example, set various parameters in your code: 

You're starting point is to look at the Game State Management tutorial provided by Microsoft here: $URL$ In that example, you can create and use global variables in the ScreenManager class for score etc. This would provide a simple method of persisting across the various states. 

"HoverText" should be in the Resources directory in the project. The gameobject itself should have a GUIText component added to it. 

In terms of flexibility, I think you answered your own question: "Frameworks can make things nice and easy for development, but then you're locked in." This doesn't mean frameworks have to be inflexible; every game, for example, has a game loop. Microsoft's XNA framework is 99% library, but your game extends the Game class which just provides a few blank functions for the things which are guaranteed to be in every game: , , . It's a prime example of a nonrestrictive framework. One might say a framework is nothing more than a library combined with a template class(es) that are hooked into the library, at least this has been my experience. I tend to prefer libraries over frameworks. jMonkeyEngine, for example, is great but it's a framework and as a result I've noticed it receives tons of flak. SDL, on the other hand, is amazingly popular; it's just a library. It provides what you need but gets out of your way to do whatever you want with it. With a library, there's not necessarily a lot of gluing to be done on a game-by-game basis -- especially if you write parts of your library to support each piece of the game loop; a Frames-Per-Second timer/counter, for example, would prevent that commonly-rewritten part from needing to be reinvented with every game. Also, libraries can be as general or specific as you want to make them. If you're making a racing game and you want your library to have racing-specific features, that's fine. It's your creation and you get to choose exactly how flexible you want it. This would be very feasible in a situation where you're in a long-term contract with Nascar to develop numerous racing games, for example. You wouldn't necessarily want a framework to potentially tie you into a classic racing-in-a-circle game when Nascar comes up and asks for an offroad game, but you would want a racing-game-specific library since you know Nascar isn't going to ask for a shooter. Here's a tip for development, too: if you write the library alongside a game, you will inevitably end up accidentally coupling the library to the game, or making it too inflexible, no matter how much planning you do. You'll figure it out as soon as you try to make a different game with it, and you'll spend time separating it; this isn't necessarily a bad thing and you might consciously decide to do this, since you'll have more free time after your first game is released. But if you're aiming for a stellar library from the get-go, try making two totally different games at the same time, and extract the similar pieces into your library. You'll get a LOT less coupling, it will be a lot more flexible, and your third game will probably still expose some weaknesses but your library will be much better in the end. It is, however, obviously much harder and more time-consuming to do. 

If we look inside the ContentVaultServiceClient class, we can see a constructor that accepts both binding and endpointaddress parameters: 

Assuming that the sample tutorial from MSDN here $URL$ works, you might want to look at this from Blender $URL$ on exporting to XNA 

Just to be sure you are setting the width and height for the fullscreen mode resolution. Then, you might want to look at reducing the x and y position of the lower hotbar by 1. This should move the hotbar one position towards top left in both axes. Its hard to tell what else is missing from the lower part of the screenshot. 

// 0.5f = min distance to check // 8f = max distance to check. Further, there wont be a selection block 

This is not your problem, im guessing. You need to create a single vertex array for every block in the view frustum, and send that to your gpu shader in a draw call. The code you pasted is probably part of your generation call, which usually isnt as much of a problem as the tesselation call. Look at my Techcraft code on codeplex.com for an example of how this can be done single threaded. 

For going the built-in Graphics2D route, look at the source code to Metagun (click to play in applet form). It's a small but very well-written 2D Java game, and I think it's an excellent example of a small game; copy its structure and you have your optimal game loop/framework. 

From what I've seen, the internet is not a very good place to find programmers, especially if you're looking for them to work for nothing. But it sounds like you perhaps just need a programming task to be done (like making a specific game based on your art), rather than needing to actually form a group. You might try the following: If you have a single specific task that needs to be done, you can post it on vWorker (previously Rent-A-Coder) and programmers (or programming groups) will bid on your project; accept the most viable-looking bidder, they do the work, and then you pay them once you receive the work. It's well-made to keep both sides fair; for example, your money goes into escrow, so that any foul play on your part and the programmer still gets paid; but any foul play on the programmer's part and the money comes back to you. Communications should be done through the website so that everything is documented, and their moderators are pretty quick at resolving issues, should you need them. There are many "outsource" workers and groups who will do your task for very cheap and quickly, but watch out for bad quality code. Also make sure to have crystal-clear requirements, and document everything through the website. Anything said on there is like a contract, and if you put complete requirements up there, the coder will be required to complete them before they get paid. Conversely, the programmers NEED a clear specification of what needs to be done in order to accurately bid and estimate their time, and poor requirements are often the source of buyers taking advantage of coders, making them work extra before they get paid just because there was a misunderstanding. I've had both good and bad experiences as a coder on the site, but it seems to me that buyers are treated very well; they are certainly in the position of power. Again, if you have a very clear idea of what needs to be done and you post all of your requirements upfront, you won't have any problems; coders will complete your task as you ask for it, or they don't get paid and you just try again. 

So, we are able to make reuse of the memory allocated on that object, and still allow the gc later on to delete it. In a way, we are informing the gc that it is safe to clean up the memory footprint of that object. And for clarity, a link to explain them a bit better, with a code example: $URL$ 

In one of my voxel engines, the voxel block explosion was done by creating a defined amount of minature blocks at the explosion point, and applying physical properties to them, eg velocity and gravity. Then, set them at random directions, and draw them. So, the actual voxel model wasnt really being disintegrated, but the voxel particles gave that impression. That is one approach. Another approach is to actually break up the voxel model. To achieve that under testing, was to detach the smaller voxels from the model, and apply the same techique for the previously mentioned explosion. No new voxels were created. In relation to pixels, I would imagine it possible, yes. An approach might be to look at using a rendertarget for the sprite, and where the texture pixel coords match the explosion points, store those coloured pixels in a dictionary, with position and colour values. Then, the rendertarget would form the source of the sprite without those pixels present. Use finally some type of custom particle manager to explode the pixels from the dictionary, using a technique similar to the explosion of the voxel model that I mention in the second part of this response. Edit: As requested in the comment, here is an example of using a rendertarget to regenerate a sprite: 

It seems you want new types of Materials to be able to be created at runtime. Then I don't see the problem with having a pointer to the Material of the object; it's how I would do it. Perhaps elsewhere in the program (e.g. in the factory class which creates these Object instances) you would have an array of all the Materials, to keep track of them and allow for choosing between them. Also you would need to either never delete a Material once it's created, or keep track of the references to a material so that if you want to delete the material then you reassign new materials onto all the objects which were previously using that material. You certainly don't want to a Material in memory, only to have Objects still pointing to that memory location which is now invalid! The problem with the integer ID which is a position of an array, for example, is if that array is manipulated, for example if a material is deleted, then you need to either put a 'null' in that position and never use it again, or you need to loop among the objects and change their material ID when you change the array. So for example if you have three materials, and an object points to material 1, then if you delete material 1 you need to either put a null in that place, or change the object id to e.g. -1 before you allocate a new material in position 1 (or else the object is magically given a new material!). Also an std::map seems like unnecessary overhead in this case. It seems to me that you don't really need the map when you could use a pointer and reference counting as mentioned above. You could certainly use it though, keeping in mind similar downfalls such as mentioned in the previous paragraph; e.g. you still need to make sure the IDs are unique among all materials deleted or not, or else you could get objects whose materials get reassigned just because the material gets deleted and a new one gets put in with the same ID as the old one. If however Materials can't change at runtime, you could of course make an enum with the material type, and the object would have an element of that enum (or a pointer to that element; my c++ is rusty). 

The block then, is quite compact, but not defined for extremely low memory here. To do that, I needed to look even further, for example: 

If you are looking into designing the platformer, consider other parts of platformer design too, as mentioned in this blog post: $URL$ Collectibles arent necessary in platformers. They are a choice decision by the game designer, in the overall design of the platformer gameplay. 

I've been developing procedural voxel terrain engines for a few years now in XNA. In most frames, the engines are transforming literally hundreds of thousands of quads. In my profiling, i've found that frustum and occlusion culling make performance boosts. XNA HiDef profile (not Reach) has an OcclusionQuery class that is used to perform Occlusion Culling. Occlusion Culling removes those quads from a viewport that are hidden from view by other quads. Something else that you should consider is theading both the generation and tesselation separately. So yes, when you approach a very large number of quads in each frame that are being transformed, you need to think carefully at how you can apply culling and threading techniques to maintain the frame rate, by reducing the traffic to the gpu shaders. 

These are sure winners, especially in the iPhone market! More seriously though, I can imagine Minesweeper, Tic-Tac-Toe, and the Guess the Number game are examples of games which could indeed be made with this library, along with most (if not all) puzzle games and many casual games. Games can exist on just about any medium in some form. Maybe not the games you're thinking of, but then you should perhaps look up the definitions of "game". 

Otherwise, if your small game is running at 200 FPS even though it has an inefficient algorithm in it, do you really have a reason to optimize? You should have a good idea of your target machine's specs, and make sure the game runs well on that machine, but anything beyond that is (arguably) wasted time that could be better spent coding or polishing the game. 

This is not uncommon; for example in Java's Swing GUI system, the BoxLayout LayoutManager requires knowing about the component that it is laying out; so you must first initialize a component (which assumes a default LayoutManager), and then initialize a BoxLayout passing it that component, and finally do a setLayout of the BoxLayout on the component. It looks like the following (taken from this Java documentation page): 

It looks like your attempting a voxel based terrain game built using cubes. Forgive me if I'm wrong, but if so, you are welcome to look at TechCraft, which I coded a few years ago: $URL$ The simplest form of single threaded xna/c# based code in that project, that demonstrates procedural terrain is found here: $URL$ (set the NewTake project as startup) Incidentally, the project also includes a voxel terrain that is pregenerated, in the TechCraft project. I hope it helps in you learning about cube based voxel terrain in XNA. It uses matrices, so the code has examples of how to use them also in what you are attempting. Good luck! 

I would like to say that the errors you are getting have now changed from the first post you made, which highlights now the fact that it is becoming a service configuration problem in .NET now, and no longer an issue with trying to get DLLs working in Unity. I would strongly suggest that this question is not drawn out any more, as it deviates from the original question too much, and might confuse readers in the future. You're more than welcome to contact me directly on Skype, at coombes.jason, where I will help you further if you need.