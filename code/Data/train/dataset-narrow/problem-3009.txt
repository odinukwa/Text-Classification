Teachers are sometimes called upon to teach something with which they have no experience. Don't laugh. Doctoral level education is often exactly like this. The student's advisor may have no background in the student's topic, but must still provide effective guidance. At the other end, teachers are often called upon to teach something like APCS-A when they don't themselves even know Java and have little, if any, experience in Object-Oriented Programming. How can they proceed and be effective. I don't think that "Keeping one day ahead of the students" is any sort of answer to this and will likely leave the students frustrated and confused. If you are in this situation, I assume that the obvious solution (DON'T) isn't available to you. Similarly "Fake it 'til you make it" isn't a solution since the future of your students is at risk. It is possible, of course, to borrow a syllabus and book list from some other teacher, but the deeper issue is about how you respond to student questions and concerns when your own knowledge doesn't provide an answer. What would you do in a situation in which you know very little, to provide effective learning among your students? Past successful experiences would be especially welcomed. So would caveats. 

I find the "box" aspect is far more important than the named aspect. Maybe it's personal bias. However, we can combine the two: it's a named box. So you can say "Go look in the 'object color' box." If you're working with pure data (no objects), it may be effective to set up a white board, and mask off a few "boxes." Each box gets a name like "number of chores done today." Concepts like "Add 1 to the number of chores done today" start to become really meaningful that way! And it just so happens that the word for these spaces on the whiteboard is "box," which is similar to the 3d boxes you might put objects in. Even better, it puts her in an excellent position to deal with the nuanced behavior of reference mechanics when she gets there. If you're used to thinking of variables as spaces on a whiteboard, writing references to objects, like referencing the members of your family by name, is easier. For many people, the jump to reference mechanics is a real struggle because they got used to the idea of "x is my bear, that's in a box on the shelf" rather than "x is a variable referencing my bear. Y also references the same bear." (I personally have struggled to help people with reference mechanics because it forces them to unlearn whatever models they used up to that point, and unlearning is hard) You can even use different color markers for references and data. That starts to get them used to the idea that there is some fundamental difference between the word "dad" and a reference to Golo Roden. 

The Pedagogical Patterns community has collected and published quite a lot of work on Feedback. The book referenced describes practices that have been vetted by the community. There are many more as well. Not all are related to exam grading, of course. Some that apply here are: 

There are many ways to motivate students, but it is a personal, not a group thing. The first thing to keep in mind is that your job is not to deliver material. Wikipedia etc. can do that just fine. You have a different job. Teaching requires a personal relationship between teacher and student Think Socrates and the Socratic method. You need to speak, somehow, to each student. Some students will be motivated by you, personally, and your story. But that requires that you open yourself to them. Some students are motivated by solving hard problems. Some by visible progress as they learn. Some by any success, no matter how small. Some students are motivated by a relationship with their peers. Some by competition with their peers. Some students have hidden motivations (in life) and you might be able to find out a bit about that. You can exploit all of that depending on how you teach the class and think about each student in front of you. Hopefully it is a reasonable number. But an additional problem you face is that many of your students don't really know how to learn. I've noticed that in recent years many students have been neglected. They don't know how to listen in class or how to take notes. They don't know how to separate the big ideas from the details. They don't know how to review. They don't know how to ask for help without losing "face." You may have to teach them how to do all of those things. There are many ways to do all of these things. Group work has helped in my courses. Student research on problems they propose themselves. Asking questions at the end and beginning of a class period helps ("What is the big idea today", (What were three big ideas yesterday?", "Why is ... important?") Praise them in public and privately. I once had to scare a group of students, but was careful to lead them to a better path immediately. 

Can you see how murky that would be if you blurred the 3 hats? It needs to be clear that, in this process, you will have at least 1 person in your corner: your Scrum Master. If they can't see that, they may rebel against the idea. Now sprint planning will be the last major challenge I think. There's a few issues here. One is that you have too many people on the team. SCRUM teams work best in small numbers. A classroom is likely too many. You will probably have to adapt the sprint planning process to fit reality. The other challenge in planning is that your students aren't the experts here. You are. They don't really know enough to break down the backlog items into tasks that can fit into the sprint. As a result, you may have to help. As part of the Product Backlog, you may want to provide suggestions for how to approach each curriculum item (such as "Lecture" and "Problem set A" and "Problem set B" and "Research"), along with some way of estimating how long the task should take. Let them assign the story points -- it's an essential learning process for SCRUM. If they want to try to learn the curriculum in a different way from what you provided, then you may need to introduce the concept of the Sprint Goal, and explain how they can use that to provide cohesion. Also, do remember flexibility. As a PO, you are going to have to demonstrate to your customers that these students learned the material. That's all. If you can work with them to find clever ways to demonstrate that they are learning what they need to learn, then always let them deviate from the obvious curriculum. If you're teaching sockets, do you really need the backlog item "Learn to use ?" Or can we add a new item "use asynchronous threads to add functionality to the awesome product produced last sprint?" The answer really depends on how much freedom you have in your curriculum. 

I'm not a big supporter of your underlying concept here and it seems like you are overly dependent on exams. I prefer a teaching/grading system in which students don't feel so much at risk. It also has the benefit of making your core concern much less important. And even if you can come up wit questions "quickly" it is impossible to say they are really good questions without some verification. Your first link is about courses with hundreds of students. I don't think it applies at most people's scale of things. The second link about testing leave a lot of it valid even if the "testing" isn't closely coupled to "grading". In other words, weekly quizzes could count for a tiny fraction of the overall assessment and still be valuable. In that situation, the criticality of getting a quiz "right" goes down dramatically. Who cares if a poorly worded question gets through if it counts 0.001%. You can also agree with your students that such questions will be dropped. In fact, any question in which a substantial fraction answers wrongly or doesn't answer at all is suspect. Another option for reducing risk is to simply drop some number of low grades for any student or allow re-testing (makeups) for poor answers. Dropping the lowest grade, for example, just recognizes that students aren't superhuman. This also reduces the need for the instructor to spend inordinate amounts of time on questions that are difficult/impossible to vet properly and for which the grades may have little to no correspondence with learning. When I took Calculus 1 (back in the dark ages) the instructor gave a "pop quiz" nearly every day. Just one or two questions. We hated them (and often him as well), but they counted for very little overall and they encouraged us to review the previous lecture before the next one. He didn't take a lot of time preparing them (I'll guess), but he did have to review them - class size about 30. We didn't like him much but he did force us to learn (stick like, not carrot like). But other teachers were able to actually inspire us to learn without the stick. So rather than "solving" the problem you state, I'd rather you find a way to simply make the problem go away altogether. 

I'm not a teacher, but my experience is that OO (and other related encapsulation techniques) teach you to write what you want the computer to do, while procedural coding teaches you to write how you want the computer to do it. OO is a powerful way to ignore the how until you need it. As a result, anyone learning in an objects-early approach is going to struggle unless there's some benefit to learning to think this way. If your course starts with several helpful libraries (like perhaps a sprite-manipulation library), it could benefit from object-early (or any form of early encapsulation). Personally, the challenge I've had with object-late is the side effect of telling the computer how to do tasks: you get used to the idea of telling the computer exactly what to do. The mental models which are built around telling the computer exactly what to do are tricky unless you're willing to take the time to push all the way down to the transistor level. At some point you have to admit that you're just telling the computer what to do and you trust that it knows how to do it. Objects-early teaches you that lesson from day one. Objects-late teaches it later. 

Here is a page of interesting links about Scheme and how to use it. $URL$ In particular, there is a link to another page showing how to set up emacs for scheme. There are also links to instructor materials, such as exercises. 

I'm going to present an orthogonal answer here so that you have some perspective. I don't know what the current demand for CS employees is in Portugal right now, but assuming it is high and has been for a while the following effect starts to occur and lasts for a while. When a field is HOT, students with no strong preferences or goals will tend, more than normally, to try to get into that field, thinking that their future is assured. It doesn't matter if they have aptitude or skills. They just want to go there. In fact, those students might be very able in general but their interest isn't really in that field, other than what it might provide them as a livelihood. These students might actually test well on any aptitude test, but later drop out as they learn, too late, that they don't actually like what they need to do. It may not even be that they find it too hard. It just isn't fun. So more than aptitude is needed and more that strong prior academics is needed. This is desire. You have to actually like the tasks that a field requires to want to stay in it, as not all the tasks are inherently fun. This is just a warning that an aptitude test may not help you as much as you think it should. If you are overwhelmed with applicants then trying to find out why the students want to study this field can be a better predictor of completion than intelligence or aptitude. Why do people go in to Medicine. Some are driven to help people or solve some interesting medical conundrum. But some are just driven by money (or the expectation of money). Who do you want to spend your time and effort educating. Find people with desire. That can overcome a lot of other things - even natural ability. We sometimes think that star athletes do what they do easily and without effort. Nothing is farther from the truth. To excel they need to practice constantly. Their natural ability may give them a start, but they will fail without the desire that carries them over the hard parts and keeps them going. The same is true in academics. 

It's almost impossible to convey a sense of wonder when they don't appreciate what they have. My personal favorite approach is to point out that the Apollo Guidance Computer (AGC), which sent us to the moon, was a 2Mhz processor with 2k of RAM. The original Game Boy had a 4MHz processor and 8k of RAM. The old game boy was more powerful than the AGC! Well, almost. The AGC did have triple redundancy on all circuits, so you would have to duct tape 3 Game Boys together if you really wanted to compete with it! And, of course, a modern cellphone chuggs along at 1800Mhz! I find it helps to first appreciate just how blindingly powerful and fast computers actually are. Then we can talk about where they came from. One of the calculations I did a while back was comparing the speed of a cache hit versus going out to memory to get the information. It turns out, due to serendipity, that the difference in speed between a L1 cache hit and a round trip to memory is actually the same speed difference as that of a Cheetah at full sprint vs. the top speed of a snail. No joke! Of course, that doesn't help if you don't have a sense of how fast either of those are, so let's compare them both to something we can appreciate: how long it takes to load a web page. There's a latency associated with going across the world over fiber optics. It turns out that your round trip ping time from America to Europe (the absolute bare minimum portion of loading a web page) can be put on this scale between cheetahs and snails. This web page access proceeds at the speed of the San Andreas fault slowly opening in California! Yes. On this scale of speeds, California actually starts sinking into the ocean! 

Depending on your overall situation you might consider asking the student to collaborate with you on something that uses their skills. I'm assuming that they aren't too overextended by their study patterns. Or you could ask a small number of students with similar tendencies to work on something together, giving them orthogonal skills. One simple example comes to mind. Ask them to write problems and exercises for you that you "might" want to use in the future. To make it more interesting and useful, ask for solutions as well. But ask for a couple of paragraphs of writing on each, in which the student evaluates the question. If you write academic papers another avenue opens of course. Caveat. This was just a thought experiment. I haven't tried this, though I have had graduate students work on projects that I needed done, and once took two of them to a conference. 

Version control is most effective in an environment where at least one user understands it quite well. As long as you have one individual on the team that understands how to recover from a messy situation, everyone else can comfortably learn as they go. However, if one does not have such a knowledgeable individual, there may be no clear way to recover from the sorts of situations that VCS is supposed to help you with. For example, if I'm not on your team, and you come across a "Tree conflict" in Subversion, it's unlikely that anyone has bookmarked the StackExchange answer that lists each tree conflict and the series of commands which resolve it. Instead, "Tree conflict" quickly becomes "wipe out your repository and do it again." In a commercial setting, there are typically senior developers or team leads who are actively monitoring the state of the repositories and can guide you down your path. In an academic setting, one is not so lucky. If I were to introduce VCS to a curriculum, I would use it in the context of group projects, and I would want to make sure the VCS tools are actively maintained and used. This may call for extra effort on my part, or that of a TA (which may not be an acceptable cost). I'd say 95% of the value of VCS becomes apparent when one is working on a team, rather than on their own. 

Note this post is "owned" by the community so you are free to improve it as well as comment on it. In particular, I'd be interested in hearing from the OP whether making these shells/levels explicit would be considered to be a good or bad thing in his environment. 

However, your use of ellipsis also confuses me. Do you mean to do something only if the reference is originally null or do you mean to put the additional actions outside the closing brace where I put a comment. Also, as ctrl-alt-delor points out in a comment, you have created a new local reference variable within the block, so what occurs after the block is possibly a bit chaotic. It may not be a problem if that is the end of the program, but might be otherwise. To teach , you need a lot of examples, not just one. Examples that clearly show the possible execution paths. They need not always be programming examples. Your door example could be couched in programming terms, for example, to connect the analogy to the programming language