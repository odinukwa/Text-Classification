The resulting 3D array is full of 0's and all documentation suggests that I should have a buffer full of 1's EDIT: Very curious behaviour ... so I am using compute to generate sets of voxel data and then generate meshes for the data, I created a simple voxel gen to fill only the center voxel in a 3,3,3 array like this ... 

Case 1: unity has built in networking code to handle this in full 3d if need be. Case 2: there are likely a ton of solutions to this already on the unity store for cheap or free. Personally if i was building diablo I would do something like this: When kicking off a new game my custom server would pick a random "seed" value. Any clients that join the game would be sent this seed value. Using the seed value I would use a 2d perlin / simplex noise based generator to build the tiles / chunks of the map that are in view and generate more as needed. All clients would then be able to gen the same map and not need to have map data sent from server. I would then add unities built in networking scripting to any moveable object I choose to add to my game so all clients in the same area see the same behaviour from them. Seems like a pretty standard unity game to me. 

investigate potential options for terrain generation. implement a proof of concept. design the solution. Begin development on terrain component (basic form only). Add trees, buildings ect to terrain. 

Try not to take the stuff you read in books too literally and apply concepts only where you think they really fit rather than just because you are trying to follow some pattern. In my case I design my entities to have properties based on what makes logical sense. I would not loop through every object in this manner because doing so per frame will get very costly very quickly. Instead look at using a component based event driven design for your code. When some condition is met (event occurs) on an entity update it. You could event have different events resulting in different changes. So for example a "collision event" might result in a health drop but also may result in a position change. Also I keep telling people this but: stop using arrays where you don't know how many things you have in a collection. If I do this ... 

How do the two tie together? I am however using sharpDX not XNA so my code for setting up the buffers is different slightly ... I created my own mesh class that does this: 

As already stated in others comments I think you might be using the quadtree concept to solve the wrong problem. I spend most of my time managing massive amounts of data working with voxels and even I don't touch quad trees for anything related to generating my world data. The purpose of the quad tree is to help manage and work with your rendered world so it really has no place when thinking about generating your world. The concept of building dungeons in the way you mention though is well known ... $URL$ $URL$ ... Once you have your algorithm implemented for generating the raw data that represents your maze you can start to think about rendering it, for that you may or may not need to a quad tree. If it's a typical rogue like you could get away with not using one at all and avoid the complication of it altogether, most I've seen building these sorts of games simply uses an array of cells that they move around in a grid loading and unloading the edges as needed. My advice: Go back to basics and only use a qudtree if you absolutely need it. 

The compiler will go and allocate me 1000 Entities worth of ram, but unless I definitely need 1000 Entities of ram right now this is a pointless waste of time and system resource. Use Lists or Dictionaries instead as their dynamic size means your code will only use the resources it needs. 

This is the "simplified version" of course. There are other things like validation taking place but from your question I guess you are referring to something like minecraft where a player at any point can click to add or remove a block. In this situation the server makes a client call to each client to say "player x added/removed this block" then also makes an internal call to say "save this change to the world data". that internal call may make the change immediately however it may not ... most game engines due to load / possible file locking / thrashing problems stack up commands and perform them in a batched fashion but there's no law that says this must happen. So in short ... The server always has the current up to date state of the current area in which all players are operating, and is able to "own them as you would expect from a server". Clients react to event notifications as they are given. With the predictive movement case exception. Prediction means that I can (for example), when player hits forward key, send packet to server to say "player begins moving" then start the player moving. If the server comes back later and says "oi that's stupid there's a wall in the way, go to pos xyz and stop" then I react to that but in the meantime assuming I as a player didn't do something stupid then all is good and later the server confirms my good choice. This is why on some games if you get a lag spike you can walk through walls temporarily. 

It appears at a glance to be creating the stream references and buffers on every send ... creating that can be time consuming as there's a sort of negotiation / resolution process that needs to happen under the bonnet and of course the time spent creating objects in ram that you then just bin. Do you have a garbage collection issue with this ... my thought is yes if you use this a lot? I have a network client class that holds on to a stream and a buffer that when I call send gets reused. I then have a second buffer for receiving which again is reused on every receive. Much more efficient IMO. 

setup a vertex buffer setup a shader stack set some constants (world, view, projection) for the frame and object 

EDIT: Based on your change of question (not recommended by the way) I would say that what you should do is declare a new variable of type Transform and in unity (before running) drop your bullet prefab on to that in the inspector. That gives unity a reference to the asset not some instance of an object. You can then call instantiate on the ref ... 

can you not just log something in a file or something that says "pending event at time X". Then when the game is next loaded do the required "add building" if the time is passed? Failing that, if the game is server based surely all that happens is when the game is next loaded the change is picked up because the server already did it. It's more a case of ... Is the game running or not? If it is, then it likely has a UI, if it isn't then me as a user, i don't want that game doing stuff i'm not expecting. Seems suspicious when devs try to this sort of stuff. 

I would go for a model that allows the actual state to be easily determined. Something like ... Create a character component that has all the various properties like health, mana move speed ect. Create your buff objects and hand them to the Character as "child components". Whilst active (which the buff component should be able to figure out for itself by seeing if it is attached to a chracter) the buff would examine its parent and ensure its effects are applied (as needed, or possibly on attach) to the parent character objects properties. Then when it ended it would revert its changes and remove itself from the parent. Each update cycle in the game would result in the character calling update on each buff to allow it to "redetermine" any thing that needs to be done (like applying damage, or removal) Taking this approach, the current value for any property on the character is always the fully calculated one "rollup of all buffs and the base stats". This is of course very subjective as it very much depends on your engine design. 

Using my code I don't appear to get any locking problems. The key difference I can see is that I limit the number of threads my tasking system can use, other than that it's pretty much the same approach. 

Since these are possible solutions I figured why not ... HP in my experience has always been something that increases very slowly, XP required for next level tends to be the big exponential. I would go with your second example or you could try reducing the 1.17 in your pow call to something like 1.02 for a more gradual increase. You could also consider using a float instead of an int or using a level cap :) 

This may add a little complication to your scenario but typically in games we use positions in 3D space even when working in 2D by using a transform. Every object should have a local transform and is a child of the world transform, these transforms represent "model space" and "world space". When determining an objects position the hardware needs to determine its location in world space by performing the translations in the "transform tree". With 2D positioning typically we use a ray to determine a location of something by firing a ray from our camera we can determine a relationship between a pixel and an object in 3D space. If you think about how your game will be rendered, you are sending information about a camera, its location, rotation, and the point it is looking at, you then define the object you want to place in your scene position it anywhere you want, it might be in front of the camera it might not, the hardware is really only concerned about what colour each pixel should be, how it determines that is based on a lot of information. However ... All that said and done i am making a lot of assumptions here that basically depend on you taking a typical game engine and trying to implement something rather than say trying to place something on a windows form which is in fact based on a 2D coordinate system. 

In the case of the unreal engine ... yes in a sense, "unrealscript" is a language unique to the "toolkit" that the engine provides to enable you as the developer to put games together. Hopefully that solves your confusion? 

You're confusing Entity Heirarchy with Scene Heirarchy from what I can tell. It Works something like like this: 

The sync would happen in the same way in both situations a list / list per player is built and at the end of each turn the list(s) are processed by all. The 2nd approach seems to be a bit better in that at the end of the turn its all action and no waiting for network sync however lists are in a sort of "fluid state" until the end of the turn as a player may chose to undo a previous command I guess as it's technically not "official" until the turn ends. That said its just a "undo" request each time that happens. I'm sure there are many other ways to do this but this is essentially how I would go about it :) By having every client periodically dump key information to disk you could then effectively reload the game if any 1 player had their copy of the data intact. 

This works for me because I take an agile approach to my design, I pick up a small chunk of my project at a time and build it, then move on to the next. Waterfall based development means you must have the full details of your project from start to finish before you begin. My experience is that this is falling out of favour in all but the most elongated dev processes because of the time taken to plan such a project. Typically waterfall based dev process involves just as pmuch planning time up front as the dev time that follows. Simply put ... Waterfall: Planning time - 1 year Dev time - 1 year Scrum / agile: Planning time - 1 week dev time - 2 weeks You also have to factor in testing time and other process based time allocations (proof of concepts, meetings, design time, delays). My advice (best i can give) ... Build a plan for a unit of work, then build to that plan. If the plan needs to change you should stop all development work and consider the impact of the change, update your plan then begin again. Once the unit of work is developed ensure it gets thoroughly tested then repeat. The agile approach (it works well for me).