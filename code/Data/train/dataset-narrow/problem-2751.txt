Yes, it's perfectly fine to use a string as a key to look up resources. The "efficiency" of the check (the string comparison) isn't that damning on its own, especially if you do it intelligently and employ reasonable caching behavior, and so on. A string has several advantages as well, such as affording you more data-driven flexibility than an enumeration will (since adding or changing enumerations usually means rebuilding code). If the string look-ups ever do become a problem, according to your profiler, you can consider changing them to something else at that point. 

Yes, software design for games is very similar to non-games -- which is not to say that game developers create UML diagrams (because not all software design involves UML diagrams). Software design is a very varied process and the methodologies employed will differ widely between companies and individuals. But at the end of the day, games or non-games, it's all just software. The requirements may differ but the fundamentals are similar. 

You can always index a 1D array with 2D semantics. Given the and you'd like to look up, if you know the of the "2D" interpretation of the array, use the following indexing math: 

There are many alternative to the GPL. For starters, there is the LGPL. However, there are several other more permissive and straightforward open-source licenses such as MIT and BSD. OpenSource.org has a large collection of open-source appropriate licenses available for perusal. In my opinion you would do well to avoid the GPL and its derivatives (LGPL), instead opting for the MIT or BSD licenses. The GPL family of open source licenses are extremely complex as well as viral, and as a consequence are hard to use correctly, by both licensees and licensors. 

All of the canonical rotational formulas used to derive your rotation matrices are for rotation about the origin. If you would like instead to apply that rotation around a specific point, you must first offset the origin -- or, equivalently, move the object so the point you want to rotate about is at the origin. Consider the 2D case first, because it is simpler and the technique scales. If you had a cube of width 2 centered on the origin and you wanted to rotate it 45 degrees about its center, that would be a trivial application of the 2D rotation matrix. But if instead you wanted to rotate it around it's upper right corner (located at ) you'd first have to translate it so that corner was at the origin. This can be accomplished with a translation of . Then you can rotate the object as before, but you must follow this up by translating it back (by ). So in general, to achieve the rotation matrix for a rotation of about point you do: 

Yes, a system where your health regenerates is fairly universally known as a "regenerating health" system, but that doesn't appear to be what the asker is talking about. The description and screenshot illustrates the mechanic where blood smears (or similar fuzzy metrics) convey how close the player is to death, and don't speak of regeneration specifically (just healing, which is more general). 

Your goblin is initialized in a state such that is true. Thus, the first time you call you will assign a new direction and step total to the goblin. The next time the goblin will change direction is when the current step count equals the step total. This will never occur, because you do not appear to ever increment anywhere. You probably want to do this once per loop. Note that this is a problem you could easily solve yourself by mastering your debugger and stepping through the code line by line. You'd see that every time you check for the step count to equal the step total, you have the same step count as last time. You could also achieve a solution by analyzing your logic backwards: you know the problem state is that the goblin doesn't ever change direction after the first time. So look at the conditions in your code that cause the goblin to change direction, and work backwards from there figuring out what causes each of those bits of code to execute and why they might not. 

One simple options is to just draw everything twice. Consider a screenful of your background clouds and other stuff that you want to scroll: 

I don't have hard data to back this up, but I firmly believe that offering a copy of the game as a reward is actually a bad plan from a long-term perspective. It can effectively soft-caps your sales, and since it's often the lowest reward level, similarly restrict your capital. The Kickstarter (or what have you) campaign will act as a marketing push for your product, through which you'll generate some word-of-mouth and a grassroots fan base. If you offer what is essentially a pre-order, then you're burning a huge portion of that grassroots activism because your game isn't actually available yet, and you won't let that interest reach its full potential. Thus, you'll have a localized clique of fans who are very interested now, drive some "sales," but then don't gain you a whole lot until the game ships months later, and which point they may have mostly moved on and won't be as likely to help drive actual sales. Additionally, offering pre-sales as a donation reward restricts a lot of your flexibility in adjusting your initial sale price to help cover and cost overruns you will have inevitably had during development. To offset some of the "sticker shock" potential donators may feel by not having a pre-sale reward, you could offer to make their donation "count" towards the purchase of the final product when it ships (although this will likely involve management overhead on your part to support). Obviously, the ideal reward in a crowd-funding pitch costs you much less than it costs the donator. Ideally it costs you nothing, but that's impractical once you factor in the opportunity cost of your time. You also want to eek the most value out of that donator's mindshare, so things that can keep them engaged during the development cycle are good. Cheap things you can offer involve things you already have to do yourself (mainly oriented around content creation): 

Since you don't get an error handler callback invoked, you can probably discard the second reason (it's the only one that might fire an error handler call, and it should be pretty easy to verify on your end anyway). This means the likely options are that you didn't initialize GLFW correctly or correctly check the return value of the initialization (you don't provide your source, so it's impossible to say) or your ask for invalid context options via the window hints system. 

There are no rules or industry standards; structure the document in the way that will be most useful to the people who will consume that document, keeping in mind what the purpose of your document is. Personally I would expect there to be portions of the document that are better suited to using "real sentences" to convey your idea, as well as portions that are better suited to being written as a bullet-point list of features. Who is your audience? If it's just you, if this is just supposed to help you focus your thoughts, do whatever works for you. If you are working with others, ask them how they'd prefer to see the document broken down and how they would expect to use it. I would expect to see a prose description of the salient points of the game: it's main concept, style and feeling. I would then expect to see a section for each major feature of the game. Do not go overboard with detail and statistics, remember that a design document is typically something that will evolve over the lifetime of the game as you build and iterate. It's impractical to think that you'll write it once, up front, and it will be perfect, so focus on what you need the document to convey now and how you can best convey that to the specific consumers of that document. It doesn't matter what other people do, you want to do what works best for your team. 

The MD5 file format assumes unit quaternions, which are of norm one. The norm of some quaternion is: 

That's all. Nice and simple. Keep your solutions simple and add generality as complexity increases; don't start with something more involved that it needs to be. 

The desktop GC implementations in .NET are somewhat less deterministic than the implementations on the Xbox, so even if there were any rules of thumb that specified particular numbers of collections per frame (there aren't, the most likely applicable rule is still "a few as is reasonable") they'd be a little harder to hit. Your best bet is to program normally -- perhaps a bit conservatively with respect to allocations and GC induction -- and don't spend a whole lot of time worrying about it. If you profile frequently you can determine where bottlenecks start to creep in to your game and address them then. There are plenty of excellent profiling tools for .NET applications, including CLR profiler and WinDBG with SOS.dll (both free, the latter is rather difficult to use though) and ANTS Memory Profiler (non-free, but it's awesome and so are the rest of the Red Gate tools). You're correct that there are methods in SlimDX that "force" allocations and it hasn't really been a huge deal. It's a tradeoff -- even if SlimDX didn't allocate a heap object (DataBox) in that case, it would still need to allocate a stream object anyway, or some of the memory that backed the stream, otherwise the library would have to either provide a much more difficult-to-use interface to the mapped memory or worse, would have to jump through some extra marshalling hoops that would probably more negatively impact performance more frequently. However, if you do find a scenario where the heap allocations performed by SlimDX are a performance issue, please file a bug. The developers (I don't work on it any more) would be happy to address it, I'm sure.