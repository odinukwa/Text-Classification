Create you omx looping script. (Keep it simple keep it easy. No need for omxd etc. =) The script will be and its content will be: 

My best guess is that Smartcard Reader is not initiated and known by the system when your service is started. To wait for the device management to be completed, you can simply add or service (don't know the exact one) to your service's line as follow. 

It is not the proper and right way to overcome your problem but you can give it a chance. Use to copy template img file to your sd card. It should fail for the last bytes if the sd card is smaller than the image file. But if you are lucky, that sd card will make your pi boot up. 

If you are on a ssh terminal (not the console), start your ssh with -X or -Y argument (i.e. ) and do not forget to execute command mentioned above before your command. It is required that X server is running on your local. If you are on the console, try to start without as suggested at Start JACK without X. You may need to install in addition. Before your command, execute: 

Assumption: You have access to the source codes of FanController application. Even if you sorted out everything on the system layer, I suggest you to do some changes on the application layer. The most convenient and solid way of making is to use . Example Java Code (exception handling is not included): 

As it is seen in your outputs, your raspi tries to access internet over LAN, not WLAN. To make it access to internet via WLAN, just set route priorities of LAN and WLAN. Append the following lines at the end of file. Lower metric means higher priority. (Don't forget to reboot) 

Individual crimp pins in heat shrink work well. A wire wrap tool can also be very handy for interconnecting boards in prototype systems - although not designed for it, it will typicall work on 2mm headers as well. 

The 5v pin on the Raspberry pi is simply not controllable, at all. Your edit provides a picture of a relay module with an optocoupler input. It is quite likey that you can successfully drive this from a pi GPIO output (I've used similar ones with an ATmega at 3.3v), ideally using where the pi connects to the cathode of the LED and the anode goes to the 3.3v rail through an appropriate current limit resistor (the resistor can really go on either side as long as it is in the path). You would then output a "low" to enable the relay. Ultimately you should determine the part number of the optocoupler and check its data sheet for the required current. If that is more than the pi can handle, you can use the pi to enable an NPN transistor which functions as a low-side switch in the optocoupler LED's drive circuit (much as how TV remote projects typically drive high brightness IR LED's), but that will probably not be necessary 

GNU screen may give you an interactive terminal to a usb serial device such as an Arduino, but for use in a program you want to use the serial APIs for C, python, or whatever you are writing in. There is very little distinction between the pi and other Linux (or even unix) systems in this regard, except that some runtime framework too heavy to have a practical pi port wouldn't really be an option. What the Arduino does in response to commands on the serial channel would depend entirely on the sketch which you create and load into it; out of the box it will do absolutely nothing. An Arduino by itself probably does not exceed the pi's USB peripheral current limits, however an Arduino with accessory shields might. Powering the Arduino from a hub is one option, but some Arduinos/Arduino-like boards will allow you to use an external power supply for the board, even when USB is connected. 

Amendment #1 - Start The highest version in Ubuntu Mate repo is as the question owner says below. Build having version equal or higher than as described at Qt for Linux/X11 - Build from Source. Be sure that you have enough space to compile Qt from source. Here is the link to source of Qt 5.7. Amendment #1 - End Set installation path to whatever you want. The default prefix is /usr. Detailed explanations about this configuration and about many others can be found in . 

If you don't want X Window System installed on your raspi: (While being unsure) you can try the followings: 

Now, forget about and focus on . We are on . Step #3: Be sure that the OS level owner of is . Step #4: (as root) Mount onto with the credentials of . We don't need to have a user on . We just need to know its credentials. Here is an example of mount command: 

Even if it is technically possible to read info from the card and to start a transaction with the related back-end, I think it will be really hard for a solution to be EMV or PCI compliant (or more importantly legal). In countries, there have to be a regulatory authority who gives permission or license to solutions which will be used in payment processes. Without the permission/license, a solution cannot be used in payment processes. These authorities have strict specifications/conditions. EMV or PCI standards are included in their minimal set. 

For the first 2 steps, forget about , we are on . Step #1: Be sure that Linux system permissions are OK for to read and write , because system permissions have higher priority than Samba permissions. Step #2: Check your Samba permissions for and . It should be something like the following: 

If you want to make a full keyboard to actually type on, you'd probably be best off with the IC out of a USB keyboard. Either retain the PCB itself buried deep in your system where it can't be seen and run wires up to your switches, or fabricate something custom with the same matrix. If you really need to change the electrical matrix then you might need to make your own design from scratch, but otherwise it's not really necessary. Even with a custom board, you can still end up with something that enumerates and functions as a USB keyboard, removing the need for custom drivers. 

Floppy and IDE interfaces are extremely different. I'll address the IDE as it is much more practical: GPIO-based communication with an IDE drive is most likely possible provided you operate at a low data rate and use passive level translation. IDE is actually a very simple interface; it (and it's close cousin compact flash) have been interfaced to lots of legacy microprocessors, you just don't hear as much about that since the price on SD cards dropped causing most of those projects to be done with spi (or bit-bang spi) to SD cards instead. Additionally, if not enough I/O lines are available to talk to the 16-bit IDE interface, it's actually possible to use only 8 data lines, since the commands are all 8-bit. Not having the other 8 bits means you waste half the storage capacity, but disk is cheap, so that's not necessarily a problem unless you need to read a disk created by something else. (You can however copy a normal filesystem image to or from such an 8-of-16 disk connected to a normal linux box, by manipulating the devices as a file) 

To build it from source, follow these steps (as root): Download source of the latest version. (For now it is v2.0.1) 

According to comments under the question (shame on us, it was evolved to a chat room), you should look for a solution of the problem having title Bridging Lan and WLan on Windows 10. The problem is not raspberry pi related. 

It will be hard for you to complete the last 2 steps via command line. I suggest you to use a GUI for bind. Here, there are many alternatives. 

As @Billp3rd says, it seems that the binary () is not compiled for ARM architecture. You need to compile it from source. To do so: Install on your raspi, because is developed in Do not use . If it has been installed from repo, remove it by . in the repo has known bugs. Instead download arm distribution of which is 1.7.1 for now. 

Compile and install. Some dependencies may be missing on the system. They can be easily installed with . 

By the way, to play videos continuously you may want to add an infinite loop out of the for loop. Make the script executable: 

First of all, you are expected to post some of your system logs. We ignore it for now, because it seems that it is your first time with the stackexchange. According to your story, I guess some kind of overwrite may be performed by user on the files (mostly lxde confs) which are supposed to be owned by . Give the following command (run as root) a chance: 

The properties of a USB serial converter have nothing to do with the hardware of the hosting system, but only with the USB serial chip itself, and the software stack of the hosting system. The pi should be using stock Linux USB serial drivers. Therefore, you can enable/disable the linkage of DTR to port open/close via the usual Linux method of clearing the setting as documented on the Arduino site and elsewhere: 

Or replacing /dev/ttyUSB0 with whatever device file actually corresponds to your USB serial port (for example, the first Uno connected would likely be /dev/ttyACM0) Even with regard to the PI's own native serial port, this behavior of DTR is ultimately under software control - anyone who argues otherwise is ignoring the fact that it is only the Linux driver, and not the hardware, which has any knowledge of the port being opened or closed. The actual port hardware can only tell that it is being read from or written to or reconfigured, none of which are actually synonymous with opening the serial device. 

Yes, you can use multiple input circuits driving multiple GPIOs, provided that the voltage range is appropriate and all share a common ground with the pi. No, this is not a particularly good way to do time measurements, as the pi typically runs a multistasking operating system such as Linux (or, if you must, Windows) and that is notorious for resulting in a substantial and variable latency in responding to external stimulus. In theory you could overcome this by doing the timing in the kernel, or better yet using a realtime kernel - but it is a lot of effort for marginal results when the real issue is that the wrong platform has been chosen. Theorectically, if you wanted to do it in the simplest way anyway you could use another checking the other photogate input, or better yet use something blocking on a read of the interrupt node for that gpio, and hope that this results in the scheduler waking you up as quickly as possible. But it will only approximate the timing. If you want to build a good photogate timer, use a barebones microcontroller and/or feed your inputs directly into a counter timer block's capture trigger. This could potentially be a $1 class part accessorizing the pi, if you really need the capabilities of that for other purposes. (Or to put it in hobbyist language, this is properly an Arduino problem not a pi problem, but you could potentially use a baby Arduino to accomplish it and report the time difference to a pi). 

But you have 2 main problems (which should be answered in other threads) to use your raspi as HTTP proxy: 

The message Unable to autolaunch a dbus-daemon without a $DISPLAY for X11 in the first verbose log means that your DISPLAY variable is not set properly. Before your command, to set it properly just execute: 

Then edit your bash script which will be executed on startup as it reads the text file and updates the mentioned config files according to its MAC address. For now, I don't have time to create an example bash script. I hope to share it soon. Update #1 By the way at the very first step to easily gather the MAC addresses, just create a bash script which will be executed at startup and boot each device once: 

In normal circumtances, the binary should be created under . Copy or move binary compiled for ARM. I prefer to put it under . 

Because there is no sufficient info about your system, I'm editing my answer based on these 4 assumptions: 

The message Autolaunch error: X11 initialization failed in the second vebose log means that cannot init an . I guess you are working on a raspi which does not have a running . If X Window System is installed on your raspi, just start before your command: 

To be able to connect to (in other words the loopback IP) does not mean that the server app is bound to all network interfaces of the system. To listen all existing or will be existed interfaces, an app should be bound to the address . By this way, remote clients will be able to connect to the corresponding IP adresses. 

You should not be running the power for a stepper motor (or any other moderately hi or pulsed load) through the pi, period. At the least give the load its own wiring directly back to the supply. While it is true that higher voltage supplies can yield much better stepper motor performance, a boost converter is going to be a poor way to do this. If you want to run your motor at 12v (say with a ) you should use a 12v supply, not one upconverted from a lower voltage where higher current would be required. If you have a good supply in the 12v range you could consider using a buck regulator to also power your pi from it, but you may find it simpler to use independent supplies for the pi and motors driver. 

First, your diode is misplaced. It should be placed in reverse orientation, in parallel with the FET. Where you have it in series, it is simply reverse biased and will prevent the circuit from operating. Next, an IRF510 is a dubious choice. It is both delicate (subject to damage from static discharge) and has a threshold voltage which may vary from 2-4v, while the pi only outputs at most 3.3v. To utilize this FET well you would really need a gate drive circuit - it's specifications are characterized at a gate drive of 10v. What current does your solenoid draw if you connect it directly to the 12 supply? If it is not too much you may be able to use a simpler NPN power transistor circuit. Or you could use a small relay (driven by a small transistor or the optocoupler version importers sell everywhere) to control it.