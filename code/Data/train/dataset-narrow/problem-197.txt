Can someone tell me what I'm missing? It's a really simple configuration but from what I've read it should work. Thanks, Muff 

I have a server and a client on different machines and on different locations. I'm trying to capture TCP packets with tcpdump on an interface of the server machine. I've injected an identifier in the payload of the packets to I can identify those packets when the output from tcpdump is displayed. The full command I'm using is: 

The routing table on R1 shows that it should send the requests with destination of 10.0.2.0/24 to R2 on ip 10.0.1.6 and routing table on R3 shows that it should send the requests with destinations of 10.0.1.0/24 to R2 on ip 10.0.2.5. This is also confirmed with the output from above. Below is output from the ip route and configuration from R1, R2, R3 ip route for R1: vyatta@R1:~$ show ip route 

If I give tcpdump the option (display the whole packet) together with the other options shown above, tcpdump seem to miss packets arriving at the interface. However, if I give tcpdump the option (display the first 100 bytes of the packet) together with the other options above, tcpdump seem to give me all packets that I expect. The larger packets I send over TCP, the higher ratio of missing packets I experience. An import note is that I receive all tcp packets on the client and the server as I'm expecting, I just can't see all of them arriving on the interface if I'm specifying the flag to tcpdump In the situation when I'm losing packets and turning off tcpdump I get this output from tcpdump: 

Is it possible to get support for BFD for OSPF on vyatta 6.2? I cannot find any information about it on the internet. The only thing I've seen is that the support is available on Brocade Vyatta 5400 vRouter. Does anyone know? 

I'm trying to setup a very simple OSPF network with Vyatta. From the best of my knowledge they let all traffic in by default, and I haven't set any firewall rules. The vyatta instances are launched as virtual instances inside DevStack, and I've allowed ICMP messages to get inside them. The network looks like this: I'm able to ping from: * 10.0.1.4 (R1 eth1) to 10.0.1.6 (R2 eth0) and vice versa * 10.0.2.7 (R3 eth0) to 10.0.2.5 (R2 eth1) and vice versa However, when I try to ping from R1 to R2 on the address 10.0.2.5 I never get back any reply on R1. When sniffing traffic with tcpdump on R2 I can see the following: 

I'm trying to connect one end of a L2VPN tunnel to a VPLS instance on a Juniper MX router. The L2VPN should act like a local interface in the VPLS instance. Is this possible at all? I can't find any information about how this could be done. 

This is not possible on JunOS as the AS-Path regular expressions do not support back references (Inserting (part of) a matched expression back into the regular expression itself). 

Mind you that this is only for the default forwarding-classes. If you have defined your own forwarding-classes you have to do it for these as well. 

There is no XML output for Juniper ScreenOS devices. Only Junos devices have XML configuration output as the underlying management system on those devices uses XML. 

To begin I looked at the "Configuring Match Conditions in Routing Policy Terms" document from Juniper. First I thought about combining a to only match routes from the customers prefix-list and a to limit the accepted prefixes to /32, like so: 

TCP keepalive uses the TCP protocol in a special way, sending a duplicate ACK with no data attached to it. Thing is: You can't count on it being available. Also some firewalls filter TCP keepalives. For BGP to function correctly you need a way to implement specific timers for keepalive (how often do we send a message) and hold (after which time do we declare a peer to be non-responsive) that are reliably sent. So BGP is using it's own keepalive message which is not a lot of overhead (19 bytes) compared to TCP keepalive. 

The MX platform does not have the general concept of a "VLAN" that is present on the whole platform. The MX only "sees" VLAN tags on incoming packets and can then act on these tags. What you want is to bridge packets from two ports that have the same VLAN-ID in the L2 header and then add a L3 interface to that bridge. On the MX platform you have two ways of configuring bridges. Service Provider Style and Enterprise Style. As I'm more familiar with the SP style I'll answer your question that way: Juniper MX SP Style Bridging First you configure your interfaces to accept packets with the right VLAN tags: 

Mike offered an excellent answer but not exactly to what you were asking. Bandwidth, by definition, is a range of frequencies, measured in Hz. As you've said, the signal can be broken down (using Fourier) into a bunch of frequencies. Let's say that we've broken it down, and saw that our signal is (mostly) made up of frequencies 1Mhz, 1.1Mhz,1.2Mhz,1.3Mhz... up to 2Mhz. That means that our signal has a bandwidth of 1Mhz. Now, we want to send it through a channel, such as a copper wire, or an optical fiber. So first, let's talk a little bit about channels. When talking about bandwidth in channels, we actually talk about passband bandwidth which describes the range of frequencies a channel can carry with little distortion. Say I have a channel that can only pass signals whose frequency is between f1 and f2. Its frequency response function (the channel's reaction to signals of different frequencies) might be something like this: 

One important thing to note however, is that the Shannon-Hartley theorem assumes a specific type of noise - additive white Gaussian noise. The upper bound will be lower for other, more complex, types of noise. 

The bandwidth of a channel depends on the physical properties of the channel, so a copper wire will have a different bandwidth from a wireless channel and from an optical fiber. Here, for example, is a table from wikipedia, specifying the bandwidths of different twisted pair cables. If our example channel has a bandwidth of 1Mhz, then we can fairly easily use it to send a signal whose bandwidth is 1Mhz or less. Signals with a wider bandwidth will be distorted when passing through, possibly making them unintelligible. Now let's get back to our example signal . If we were to perform a Fourier analysis on it, we would discover that increasing the data rate (by making the bits shorter and closer to each other), increases the signal's bandwidth. The increase would be linear, so a two fold increase in the rate of bits, will mean a two fold increase in the bandwidth. The exact relation between bit rate and bandwidth depends on the data being sent as well as the modulation used (such as NRZ, QAM, Manchseter, and others). The classic way in which people draw bits: is what NRZ looks like, but other modulation techniques will encode zeroes and ones into different shapes, affecting their bandwidth. Since the exact bandwidth of a binary signal depends on several factors, its useful to look at the theoretical upper bound for any data signal over a given channel. This upper bound is given by the Shannonâ€“Hartley theorem: