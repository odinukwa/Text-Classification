Answering the "Is a loop required" original question. No, but the alternatives are more complicated, harder to implement and rarely used. Games are by definition interactive. At the minimum, that's waiting on input and updating output. The simplest way to do that is a with a loop. It's not required to spawn a new thread for that. Even though the game you've mentioned appears simple, it has interactive visuals and sounds and it constantly updates those based off user input. There's not a lot of alternatives to a game loop either. Some kind of interrupt based system could be possible. However, such systems increase the complexity and reduce other factors like determinism. There's a reason game loops are so common, they're easy to implement, easy to understand, flexible and do a great job. 

Swap the x and y, then choose one to be negative depending on which direction you want to go. This new direction should be calculated before you update the velocity. Use the new direction to update the velocity if the new direction has been updated, otherwise just use the current heading as you are now. 

So, implementing gravity has some prerequisites. A big one is a time keeping system. One good read for time systems is Fix Your Timestep! by gafferongames.com. The time system ties in tightly to the update loop. See deWITTERS Gameloop for info on implementing an update loop (which covers time step too). Once you have an update loop with a delta time for each iteration, you're pretty much ready. So, you main game will have something like: 

I don't see how that's different from asking "How do I figure out what kind of game to make?" It's totally up to what you want to do. It can't really be answered by someone else. So it's like any other difficult choice, list out your choices and write down what you think are the pros (with a positive score) and cons (with a negative score). Sum the total scores for each item, then go with the item with the highest score. However, I imagine you'll figure out which one you want before you even get to that point. 

This will move them into something like a formation, where the player can easily select an individual unit. That's an O(N) operation with pretty good results. 

On each object you will choose one or more faces that will be removed. In between these faces will be your connection. 

Unity has a full comparison chart on their site. The differences are too extensive to list here. iOS and Android are different flavors of Pro. Android gives you the ability to publish to Android. iOS gives you the ability to publish to iOS. They can be combined for the ability to publish to both. You must get Unity Pro in order to have the additions of Android or iOS. They are "expansions" of Unity Pro. So, if you only care about mobile, you still have to get Unity Pro in order to be able to add the iOS and Android options. 

While I think an Entity/Component UI might work, it would be difficult to make it so. Additionally, it's far enough removed from the components and systems you'd have for processing your game entities, it would essentially just be another entity/component system within your game. I can't imagine there would be a lot of overlap between the two. Entity systems are awesome and it can be tempting to use them everywhere. After all, when you get a really sweet hammer, you're tempted to treat all your problems like nails. However, the EC system is just another tool in your programming bag. For the problems it's used to solve it works really well, but you have better tools for problems like UI. The inheritance structure works really well for GUIs. Not only for creating the UI components but for laying them out too. It's really nice to be able to have UI components be children of other components so they can inherit properties like position, scale and opacity. If you were to try to set that up with a EC system, you'd have to break some rules of the EC system. 

Cast a grid of rays straight down from your game object. The grid should be tight enough to ensure it won't miss any triangles on the terrain surface. For each ray that hits something, you can get the triangle in the terrain mesh with the following: 

If you don't have access to a function, you can create your own, the normalization of a vector follows this equation: 

So, to apply frame 2, I would take the position, rotation and scale from frame 2, create a transformation matrix (call it ) from them and apply that matrix the vertices controlled by at their weights. So I'd stuff into my shader and transform the vertex. Something like: 

Or better yet, add a constructor to set the position of your GuiElement, so you can just call it like this: 

If there are multiple meshes, you'll be able to see them here. If it's all one mesh, it will show up as a single mesh. 

So that's how it can work, but how is it supposed to work generally for position, scale and rotation? 

When exiting the game, write the values you want to save to a file. When loading the game, check to see if a save file exists, if it does, load the read the values in to your program. If the file does not exist, continue like you do now and set the values to their starting/default values. 

Further, there's this paper that describes using Blender game engine and CLAM to get HRTFs. For 2: I'm not going to recommend one, I've not used any of them for development, and this question is already borderline "Which technology to use". For 4: There are signs, given the various research papers and implementations I found, it looks like some people are interested. 

My fonts own the images that represent their fonts. I see no reason to add the image to the general pool of resources. The resource manager doesn't even need to know about it. I use the same routines for loading the image, but it's loaded into the font object. Nothing other than the fonts will use that image. 

If at any point you reach an outside boundary, your castle is not surrounded by walls. If you complete your Checklist without touching an outside boundary, your castle is surrounded by walls. 

Luckily, the BSP file format is well documented (with an overview on wikipedia). While this is great, it's clear from the documentation that you have a good deal of work ahead of you to write a importer for .BSP files. Your first steps should be getting your file parser working through the lumps and printing out when when it reaches each face/vertex. (Make sure you start testing with a very simple scene). Next up start loading the vertices into whatever data structures you're using to store meshes. From there you can pick and choose which features the file includes you want to include in your game. Incorporate each feature one at a time, continuing to test along the way. Good luck! 

If the bones are static and so are the transforms, you only need to apply the transforms once. You can do that in the constructor. However, if you're using the bones to position the model or animate the model, you'll need to update them more often. How often depends on how you're using them. For example, you may be reusing the same model and bones to draw multiple instances of a single model. In this case you'd have to update the transforms every frame. If you're just animating one model, you only need to update the transforms on a pose change. That could be at the same speed as your frame rate or it could be slower, it depends on your animation speed and run speed. 

It's typical to keep them together. Then when you're creating your VBO, you can easily generate an interleaved VBO with all the data. This is very fast and a typical method when creating VBOs. I have a few different data structures for vertices. When I know there isn't going to be any data of a specific type, I will leave out that data type and just interleave the data types present. For example, some of my models have bone information interleaved with the vertex data. Others do not. So I have a vertex structure that has that extra information and one that doesn't. I use both and have separate draw calls for each to set the appropriate pointers. 

You have a second inside your class. This handler has not been added as a key listener. Further you create it again every update. Just create it in the class constructor and then add it to your key listeners. More importantly, learn to use the debugger and set break points. It'll help you a lot for situations like this. If you already know how to use the debugger. Learn to use it better and start using it. It's invaluable for your development career. 

It depends on what you want to do. The version handles multiple touches (as the name implies) so it's a little more difficult to work with, but also more powerful. Use this method if you're dealing with more than one touch, like pinch zooming or rotating. The version is just looking at one touch. This is simpler to use, since you don't have to break apart the events yourself. Both of these methods are part of larger sets of similar methods: (Standard) 

Note that there will be a large amount of distortion at the poles if you don't follow the suggestion above to limit the surface area of the sphere this map is stretched over. 

Note, I haven't used cocos2D, so I don't know how to properly get the y force (so I use , replace that with the correct code). I do recommend using the existing y force there, unless you want your jump to stop from x movement (same goes for your jump). I also find it strange that applying a force of stops the ball, but you said that works. 

That's not the way you do it. Simply draw the things that are on top last, they will overwrite the things below them. Or you can access the depth values and order the objects with that value. 

Obviously not a lawyer, so this isn't legal advice, but my personal interpretation is: The code is licensed under Apache License, Version 2.0. If you read the Redistribution section: 

The vertices are then stored in a VBO and only altered with matrices for rotation and bone animation. Currently the bounds are not updated when the model is altered. So the animated and rotated model has bounds like so: 

I think, but I haven't tested it, you could create a base "single instance" class where you can have your other classes extend it, maybe something like: 

So x=1, y=0 will result in 0, and it's discontinuous at x=-1, y=0, containing both π and -π. Now we just need to map the output of to match that of the compass we have above. Likely the simplest to implement is a incrementing check of angles. Here's some pseudo code that easily be modified for increased precision: 

Each dimension is like a conveyor belt, loading and unloading chunks as the camera moves along its axis. Now, when it comes to drawing, you just reference the chunks loaded around your camera. If the wrap of the world was small, there would be duplicate chunks referenced in the chunk matrix. The view frustum doesn't need to know anything about where the world wraps, it just looks at the loaded chunks. 

Check out OpenTK.Input. From there you can get access to and Some examples from the page include: To check whether a button is pressed: 

If you add the attribute [ExecuteInEditMode] to the script, just before the script class name, it will be run in editor mode. These tagged scripts will have their function called (and I believe the and , though I haven't tested it), and a few others given some conditions: 

So, yes, you can package it with your jar file. And I would argue that obfuscating the code is modifying it. However, one of the conditions of redistribution is: 

In this case, you're not trying to use the symbols as your own, but instead are directly referring to Sony's trademarked buttons, which likely falls under the first category. If you're unsure, talk to a lawyer. If you're taking advice from someone on the internet, talk to a lawyer. 

Use geometry shader to discard all geometry vertices above your slice point. Build a new mesh for each chunk that caps the sliced terrain. 

How can I create a geometry shader that can handle multiple primitives? For example when creating a geometry shader for triangles, I define a layout like so: 

No problem with being new to game development. You just need to make sure to provide enough information so that we can properly help you. Your on the right track with your code and it looks like your function is sound. I'm not sure what the difference between and are and why you're setting one vs the other depending on , so the following maybe isn't what you want to achieve. However, I would suggest this simple structure for moving your character around. 

If you have less than 256 different types of tiles (dirt, grass, sand, etc.), which is likely, you should just write a single byte to store the value of the tile. When you write the data, make you're writing in a binary format. If you're writing characters as numbers, you're not doing it right. When you read the data back in, you check the byte value against your chart, and load the appropriate tile in to the game. Look into how your language of choice can write to a byte stream, or write bytes directly. It's clear that you're writing text to your file because you have new lines for each tile. A binary format is probably going to be unreadable for your average text file editor. But your game can read it, so it doesn't matter. 

In a little game I'm making using Unity, one of my build targets is the Web Player. I had the situation where I wanted to remember the configuration of the last launched ship, and allow the player to save various configurations by name. As you say, standard file I/O isn't supported. However, Unity provides the Player Prefs class for storing data in both Web and native environments. This is a form of restricted file I/O as it writes to a file saved the in the users local appdata. The size of the file is limited to 1mb, but that's more than enough for the data I needed and likely plenty for the data you need too. I think that having the user remember a complex string of random characters to access their save data is a bad idea. (Especially since it's likely that many of the characters are non-standard and not easily typed). Security is still a concern, and, in this case, it's not possible to completely prevent the cheaters from modifying their data to suit. You'll always be unable to trust the client. Further steps to secure these "save games" is to move them to a database. Users would access their saved progress with a username and password.