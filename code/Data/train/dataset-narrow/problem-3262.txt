If it says "Encryption key:on" it will need some sort of password. What type of encryption is later on in the scan results. In this case it says "WPA2" and "TKIP"/"CCMP"/"PSK", which is essentially standard security for a few years ago. 

The foundation has been working on an accelerated browser which may work better. The goals they've stated are to improve rendering speed which may help. Unfortunately the limit you're hitting with display probably isn't so much a browser issue as a more fundamental issue with the frame buffer being slow to update. There's not much you can do about that other than maybe move to OpenGL ES, but if you're working on JavaScript that's probably not the right solution. 

The optimal solution is probably to build a distribution that does only exactly what you want it to on boot, this way you're guaranteed minimal times (using a minimalist init system like sinit). Alternatively, you might consider using the suspend to disk (hibernation) feature of the Linux kernel. Once booted, the suspend and resume operations later on are pretty quick, and the system is entirely off in the meantime. 

I once had a chat with some guys who knew far more about this than me, so I can't give very good directions, but in general here's what they suggested. SD cards are pretty flexible in terms of what can read/write them. I believe they said that could essentially get it down to single wire type communications, which you could then multiplex. So you'd write up an Arduino or something that would read one block off a source SD card, and then write it simultaneously to like 12 cards. Fair warning though, this was a fairly theoretical conversation over tea and biscuits, I'm not really sure this could be done, but I don't know enough to say for certain. 

You can't change the values of multiple GPIO pins simultaneously. Parallel ports don't do this either, they handle it by having an additional control pin (Strobe) to tell the device that the data is ready. If you use an extra pin (I'll call it the Ready pin) you could use a process like this: 

It may be that the GPS module is interacting with the serial console. Try disabling the serial console: 

Although the LAN9512 datasheet says that the pins used to drive the speed and duplex LEDs can be used for GPIO as far as I can tell there is no support in the linux kernel module to actually switch the pins on the LAN9512 into GPIO mode. 

There is no simple solution for a raw display like you linked to. That requires multiplexing which requires constant processing to maintain the display. Perhaps with a threaded library you could make something acceptable but I don't know if something like that exists. As an alternative you could use the Adafruit LCD display with I2C interface. Adafruit has a tutorial for using it with the Raspberry Pi and has a Python library on github that seems to be what you want. It even has example code. 

If you look at the 2 ends of the ethernet jack on the schematic you will see that pins 2 and 5 on the PCB side (left side) are connected to 3.3V to drive the integrated magnetics in the jack. On the RJ-45 side pins 4,5,7,8 are all connected to ground via pins 9 and 10 on the PCB and not used for communication. So on ethernet side it does not use the wires in the cord but those wires do not connect directly to any pins on the PCB. 

If you Pi is a Model A or Model B Revision 2, then you should be fine providing power only to the +5V GPIO. If your Pi is a Model B Revision 1, then you'll need to either short out the 100 mA polyfuse, or use a hacked USB cable as you suggest. If you bypass the Micro USB connector (by powering over the GPIO) you increase the risk of frying regardless because you no longer have the fuse or voltage stabilization that the Pi provides by default. If your power source is pretty stable though, it's probably safe enough. 

Apparently there's an entry in /boot/config.txt called start_x that needs to be set to 1 to enable the camera, There also needs to be at least 128 MB of memory for the gpu (gpu_mem). Double check seems to confirm it. 

By default the RaspberryPi framebuffer is only 16-bit. So at higher color depths in the software you're probably seeing the effects of some integer wrapping. You can set the framebuffer depth higher, but it may not work well. According to this, you can set the Pi to both 24 and 32 bit depths by changing framebuffer_depth in /boot/config.txt. At 24-bit there have apparently been corruption issues reported. 32-bit depth works better, but requires alpha to be disabled by setting framebuffer_ignore_alpha to 1 in config.txt. 

To enable USB mouse/keyboard support in the kernel, run . Go to -> -> and select , which is . I'm not sure it's necessary for the terminal, but you may also want to enable () under if it isn't already in order to be able to use the mouse and keyboard under Xorg. 

A good option for managing a service like this is Supervisor. Install the package with . Then you will need to create a configuration for your script in For details about the configuration read the program section in the supervisor docs. Specifically you can specify and Supervisor will automatically restart the process if it stops. 

Raspbian Jessie uses systemd which reads the /etc/hostname and sets the hostname directly with a system call. See: $URL$ systemd does not use /bin/hostname to set the hostname. 

Kali Linux does not enable any external listening network services by default. If you really want to be able to ssh into the system, you will need to enable sshd and probably change the sshd configuration to allow root logins. (look for PermitRootLogin in /etc/ssh/sshd_config) And be sure to change the root password first. 

Your config file is probably missing. Make sure the file exists and is a valid config file. The path is hard coded in the source so if you want to use a different file you will need to edit The reason you this happens is that the program uses ConfigParser.read() to load the configuration which ignores missing files instead of raising an error. Note: I linked to the Python 2 docs but Python 3 behaves the same way. 

In the second case you are mixing single and double quotes. I suggesting suing format strings instead of the format operator . 

The short answer is no you can't use them together. According to the PiTFT page it uses the SPI interface (SCK, MOSI, MISO, CE0, CE1) as well as GPIO #25 and #24. The Wolfson Pi also uses the SPI interface on the 26-pin GPIO which means it is also using the CE0 and CE1 pins. It looks like it also uses a number of other GPIO pins but I could not figure out which ones. It may be all but 2 of them. Since they both use the same pins there is no software solution that will let you use both. If you really want better sound and the PiTFT I would suggest looking into a USB sound device instead of the Wolfson. 

It looks like you've installed something that added /etc/init.d/mathkernel which isn't correctly formatted for Debian. When it tries to run upgrades it wants to stop the process, but it can't do that automatically because it's non-standard. You might able to get around this by making sure the script has a line reading somewhere near the top. Try comparing it's formatting to some of the other /etc/init.d/* scripts. It's also possible that the file's been corrupted, it may be worth re-installing it from the original source. 

Anything you redirect to gets dumped out an airlock. For example if you were to what's happened is effectively nothing. Of course, would normally just write to the terminal, which is also only a short-term memory cache on the screen. That never gets written to the SD either. There are generally only very specific instances you might want to write to for actual benefit. For example, doing first pass video encoding still prodcues an output file. This you can send to to save writes on the card. When you do the second pass of the encoding then you do the actual writing. 

Unfortunately the Raspberry Pi doesn't actually support OpenGL. It supports OpenGLES instead. The perfect solution would be to port the applications you want to run from the former to the latter. This is unrealistic in most cases though so there are some ways around it. The first would be to get mesa installed and pure software OpenGL up and running. This will be very slow (e.g. impossible to use for games). The second approach is to use an OpenGL to OpenGLES library that catches the OpenGL function calls and translates them to equivalent OpenGLES calls that the Pi can interpret. There are at least two projects that do this, but I don't know if either of them actually supports the Pi yet. And stupidly I can't find the links to them. I'm really annoyed about that. This may be of some help though. 

When started from rc.local Midori is starting before the X server (the graphical display manager) has started. So when Midori starts it cannot attach to the display and you get the error. Using autostart seems like the right way to do it but I'm not familiar with it so I can't help you with that. 

returns either GPIO.HIGH or GPIO.LOW, so it will never be equal to False. Your check should be something like this: 

Yes. You can use the ncurses menu library ($URL$ Which is actually what that python code uses to generate the menu. But making the menu in C will be more work and look exactly the same as the Python version. So unless you have a good reason to use C I would suggest sticking with Python. 

feh is a simple image viewer that should do what you want. feh requires X11. You can give it a list of files or directories or URLs. It looks like you might be able to use the --info option to display the IP address. For displaying images on the console (without X11) you can use fbi. It is not a full featured as feh but it will do a simple slideshow. Both fbi and feh can be installed via apt-get. 

The Broadcom BCM2835 does not have on-board ethernet so just like the standard raspberry pi you will need to add ethernet via USB. On the B/B+ the ethernet was provided via the LAN9512 USB hub/ethernet chip. So for the compute module development board you can just get a compatible USB ethernet adapter. For a device built around the compute module you might want to look at something like the LAN9512 or LAN9514. You could look at the schematics published by the Raspberry Pi Foundation to see how they did it. 

First, I'd double check that the battery is actually 5 V, close to it won't cut it and I can't think of any phone battery off the top of my head that is 5 V. Here's how I'd do it, assuming I had a Nokia 3310. Warning, involves hacking! Basically, all Nokia phones charge off of 5--5.7V, and the batteries are 3.6 V Ni-Mh or Li-Ion batteries. First step hack a high current (at least 1 A) USB charger to also plug into the Nokia. This provides power of the Pi and to the charging circuitry of the phone. The positive battery terminal on the phone then need to be soldered to a 3.3 V Zener diode. The diode then connects to the 3.3V, and a second Zener connects the 3.3V to the 5V. When power cuts out, the Pi should keep going off the phone battery for a little bit, but all the peripherals would stop (including ethernet!) due to a lack of 5 V. Not an ideal solution but a clever little hack I think. More on running on 3.3 V. It might be easier (if less fun) to go for a more ready solution. The MoPi project is billing itself as a UPS, although it currently doesn't provide any battery charging capabilities. It does have an enormous uptime though. 

cv2.so should be someplace within the build directory. You can use to locate it. In order to get to run sucessfully you'll need to ensure that the binary knows where it can find the library file. You can do this two ways: 

You could run PPP over the serial line. To do that you would first need a PPP server on the other computer and make sure the Raspberry Pi is not using the serial port for the console. Search for Linux PPP tutorials and you probably find what you need to get it working. 

You could build a boost converter using a TPS61030 boost converter from TI or you could use this product that uses it. Personally I would be nervous using a cheap converter from ebay to power my RPi. 

They now have 2 versions of the Raspberry Pi camera. One with the IR filter and one without: $URL$ and $URL$ Both are official and available from other distributors. 

The GPIO pin cannot provide enough current to drive the buzzer and the LED. Change your circuit to use a double pole switch with one pole connected to the 3.3V pin to drive the buzzer and LED and the other connected to the GPIO for the Raspberry Pi to read the button state. 

You cannot display the preview image via VNC. VNC only relays the display information from the X server. The preview image is displayed by directly manipulating the GPU overlaying the preview on top of what ever is currently displayed (that's why it works in the text console too). This bypasses the X server and thus VNC. 

Unless you have a need for many concurrent users or processes writing to the database at the same time I would recommend sqlite. It is file based so you don't need a server running, and each project can use its own database file (unless they need to share data). If you use a database abstraction layer you can move to mysql or postgres without too much trouble in the future. And, as a bonus, doing a backup is a simple file copy. 

It may be that the image became corrupted while extracting or writing. Try verifying the file with and comparing the result to the checksum of ade48c874f8e4b694175de4c87d7357960961fbf. You might be able to recovery by simply doing a file system check, otherwise try re-writing with a freshly downloaded and extracted image. To do a check, run . The boot partition on the SD card has to be FAT. The external hard drive doesn't need its own boot partition, because it's on the SD card instead. The only reason you need it now is because you're copying the contents from it to the SD card as you've just written out the image. 

The linear regulator is definitely the sticking point here. A switched mode regulator is much more efficient and therefore won't take a chunk out of your battery life in and of itself. The MoPi board provides one in an easy interface for connecting batteries like yours to the Pi, and also lets you know about charge status so that the Pi shuts down nicely. I'd estimate a 12 V, 2 Ah battery to run for around 12 hours. 

Exit status 4 of GCC means that the system doesn't have enough memory. Which Pi are you running with what memory split? Use the command to see how much RAM you have. If you don't know about the memory split, it's basically how much of the Pi's RAM is allocated to the GPU vs the CPU. You can change it by running , then selecting "Advanced Options", then "Memory Split". Set to 16 MB for maximum system memory. You can probably keep it as low as it goes unless you're doing OpenGL ES, in which case turn it back up later.