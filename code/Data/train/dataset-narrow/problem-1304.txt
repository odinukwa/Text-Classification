Let's first address some of your logic and flow. One thing that strikes me right away is that you have the same logic written twice, this can be made into a function or, in a more pythonic fashion can be made into a list comprehension. A for loop is also to be considered for readability. Moving on you are using if blocks to check a condition and breaking inside of a while loop that is always true. You can clean this up by chaging to instead be . It is important to note in this case that you should recompute these values at the end of the loop, so that their current is checked before loop execution rather than after. There are many different approaches to this. I'm going to specifically break down this part of code: 

because it can be made very elegant in python. Instead of having many if statements, a sentinel boolean, and a for loop we can make this very clean with the following: 

What is going on here? The statement is what is called a generator, it is similar to a list comprehension in python but it is different and may not always make a list. Full Discussion here. In this case the generator is being used to make a list Then we use the python builtin function this function returns a true or false value, True if the passed in list contains no values. The function returns False if there exists any false statement. The python function is the inverse of this, I recommend reading about it as homework ;). But wait, shouldn't taking th On the topic of efficiency, a sieve is normally the fastest method to work for finding primes. it works by finding early primes, and then removing all values that we know are not primes because of our known primes then iterating. Here's an implementation 

Having these filters added to the model builder in , you'll see that whenever you query any of these entities, the filter will be part of the SQL query. Also when using s. If you want deleted items as well, just disable the filters in a context instance: 

Note that this returns an empty string if no occurrences are found. I think that's more correct for a function that returns "everything until the nth occurrence of x". 

Single responsibility: a controller shouldn't also have Unit of Work responsibilities. The context itself is the perfect Unit of Work. You don't always need Use dependency injection. 

I like to see controllers as light-weight doorways to web-independent service methods. The services have their own and execute where necessary and, thus, can be used in other applications than just MVC/Web API applications. Controllers receive services by dependency injection. 

Where's Commit? No, I didn't forget the method. The fact is, repositories shouldn't commit. Maybe this is surprising, but if you think about transaction management it becomes obvious. There may be business transactions in which several repositories are involved. When each repo has the potential to save all changes, it may be very hard to figure out which one is able to save at the right moment. That's the reason why generic repos always come with a Unit-of-Work pattern. This is all explained well enough in the link above. You can see this problem lurking in your code. At the end you have 

The trouble is that with extension methods it's too easy to 'add' methods to a very general type while the scope of these methods is more restricted than the scope of the type itself, even within one namespace. For example, I had extension methods on that I decided to ditch again later, when wisdom finally took over. This phenomenon also applies to your extension methods. They are defined on . Now I don't know how many classes you intend to implement, but who says they're all going to have ? This means that you'd have to confine the extension methods to contexts knowing about . This, in turn, may imply that you may as well replace the extension methods by instance methods in one specific context class. When create a method at all? That's another question. No matter if it's an extension method or an instance method. Is the task even worth creating a generally accessible method? I specifically frown upon this method. To me, this looks like something that should probably be a service method. Remember the single responsibility principle? A context shouldn't have any knowledge about any format. That's a (domain) service's responsibility. It may make the context with all its paraphernalia less applicable (or targeted) to other parts of the application or other assemblies. Or, worse, you may get tempted to enter a range of methods to meet other specifications. Alternatives Finally, there are other ways to deal with this 'soft delete' problem, i.e. the problem that records are deactivated rather than physically deleted, while the deactivated records shouldn't be displayed. Of course (and that justifies your [extension] method efforts) you don't want to add to each and every query. But extension or instance methods supplying a pre-filtered set aren't enough either! Any old time you apply an you'll be in trouble. 

would be a very good substitute. A lot of the code in the gameon() function is redundant, why do you need two counters for player turns? Instead you should use a boolean and set it to True or false. Your high level logic will look like: 

Your game is essentially a simplified version of fizzBuzz. If you want to check if a number is in the "boom" set you can check if it is divisible by your "boom" number. In your example you use the number 3. The set will contain numbers: {3,6,9,12,15,18 ......} until the limit. This is where the modulo operator comes in, it gives you the remainder of a division. So if you divide any number in the set by the "boom" number you will have a 0 remainder. (e.g. 18/3 = 6 R0). Any number not in the set will have a non-zero remainder. Another really cool feature in python is that booleans and integers are pretty much the same thing. Any number not 0 is "true" and the number 0 is "false. for example, 5%2 results in 1 10%5 has a truth value of "False" 

Also I would consider creating a function for a human turn and a function for an AI turn. That way you don't clutter the "main" funciton (in this case it's ) with all of the logic. A very basic rule that normally is good for first time programmers is to keep each function under 10 lines. Normally I would not pass on this advice because it can lead to bad practices but I think in this specific code case you should aim for this. It helps with readability of code and it allows you to start thinking in a more procedural way. 

is a bad approach, you should instead understand that your dictionary is for looking things up, not for iterating over in this case. Each entry in it keys to another value and you want to use it that way. I would instead set up a list of words that have been stripped of whitespace and syntax, and compare as lower case. Then I would use those to ".get()" from the dictionary, in this case you would have to use dict keys that are lower case as well, but this makes behavior much more consistent. a quick code snippet on how to use .get() If the entry is in the dictionary this will return the value, otherwise it will return the key. 

You are close to a standard validation implementation of Entity Framework, which is using . It may be worth the effort to replace your validation by this readily available validation framework. The advantage of using is that it works together with validations applied by data annotations or fluent mappings. If, for example, you have ... 

... EF will carry out the validation when is executed. If validation fails, a is thrown that contains a property showing the validation errors. All this happens without even implementing . If however you also implement this interface, you can add custom validations that blend seamlessly with the ones from data annotations/mappings. Here's how to do that, reducing it to the essentials: 

Now you get only one record per show in the result set and only the required fields are included in the . You'll still see a number of joins, but they don't cause any widening of the query, as s do. 

You evidently want to clone mapped and scalar properties only. Your approach works (if you remember the error sources), but I'd prefer to use a method provided by EF itself: 

To prevent these errors you'd want to ensure that whenever is to be executed is eagerly loaded (using ). Two options: 

Better? Probably... All your repositories look almost identical, only the served type is different. Therefore, you may as well turn to generic repository. In its elementary form, adopting your methods, it looks like: 

So there is a redundant database roundtrip in your code. After this statement you know everything that is going to find out again. So you may as well do it yourself: if the record exist: modify it and its details, if it doesn't: add it. To modify the existing records, use : 

What is this? This is either a copy/paste error or a major design flaw. How can a repository add itself to the it contains? And why the double(!) cast, why the ? "Smelly" is an understatement. Why is 's member internal? The repo is supposed to encapsulate a . What should other classes in the assembly do with it? If you need it to be internal, it's because of something you don't show, and which, again, would be a major design flaw. One method returns untracked entities? (), while and methods don't. That's confusing. It may be useful to have options for applying or not, but a consumer of a repository should not have to know which methods do and which don't. Either the method name should reveal it, or it should be parametrized. in its present form is a useless method. It returns ...