Ari Patrick is right though, ultimately relational db's aren't made for this. The downside is that we have some pretty complex procedures to generate new items (done through an external tool - which I highly recommend, Do not try and manually add these, you'll only confuse yourself) The other option you have is using a scripting language to create the item templates, then you can easily parse those in and use that to create new items. You still of course have to save the item data in the database but at that point you don't need to worry about specifics of creating new items, you can pretty much just copy and old script file, change some information and you're good to go. Honestly, if we were to re-do how we create new static items we would probably go for a much simpler approach using scripting item templates. 

On our project we have item_attributes for the different "extra data" that an item may have. It's laid out something like this: 

The more I research this topic and talk with professional game developers, the more I think it really comes down to a few things. In no particular order: 

One 'disadvantage' would be that with C# if you want to use it on multiple platforms you have to be very careful to make sure that your code will work with mono. If all you care about is running it on a single platform and windows is that platform, then you should have no problems as others have mentioned. 

Every object in the game is on the client side, it's just the server side that says what that object can do. All this involves is finding a program that will unpack the proprietary data files: MPQ's and then extract them. Then you'll probably need to figure out a way to parse that data into easy to an easy to use format (XML), then you can create a program to do whatever you want with it. HERE is an article on how to get Character Models from MPQs, I would imagine any item would be very similar. 

Microsoft provided a very easy to use class for parallaxing backgrounds that should take care of your problem. I changed it to scroll up to down for you (it originally scrolled right to left): 

If I have a series of PNGs that I'd like to use as a single animated texture, would I be able to use them as they are, or would I first need to convert them to a different format, like a single TGA? 

The game I'm creating is a bullet hell game, so there can be quite a few objects on the screen at any given time. It probably maxes out at about 40 enemies and 200 or so bullets. That being said, I'm splitting up the playing field into a grid for my collision checking. Right now, it's only 8 cells. How many would be optimal? I'm worried that if I use too many, I'll be wasting CPU power. My main concern is processing power, to make the game run smoothly. RAM is not a big concern for me. 

I want to be able to use multiple cores in my XNA game, but it seems that Thread.SetProcessorAffinity() is only usable on xbox. That being said, is there any way to run a small chunk of my code on another core, or failing that, share the load between all cores? 

It moves to the second point, but then gets stuck and appears to vibrate in place. How should I be doing this? 

I have a boss that's supposed to continuously shoot five streams of bullets, each at a different angle. It starts off just fine, but doesn't seem to want to use its entire array of bullets. No matter how large I set the length of bulletList, the boss simply stops shooting after a couple of seconds, then pick up again shortly. Here's what I'm using to generate the pattern: 

If my understanding is correct, this moves the memory from VRAM into RAM. Casting the render target to a texture does not move the memory into RAM, so it was still subject to VRAM shenanigans. 

After reading that I decided to convert my midpoint displacement method into what I believe is a proper diamond-square method. However, it still does not look seamless despite me using "consistent initial corner values." The method works perfectly otherwise. Here are two generated maps next to each other: As you can see, there are major discontinuities (even though it looks like they could almost fit together). What I wrote must not be a "true" diamond-square method, or maybe I am misunderstanding the Wikipedia article. So in other words my question is this: What is wrong with my code or my understanding that prevents me from stitching together maps? Thanks a lot! 

My game generates small "minimaps" for each room you go to, which are rendered onto render targets then stored in textures and displayed on the world map. When the game is saved, each new minimap is saved on the hard drive. If the game is in full screen and the user minimizes the game, the minimaps that were generated, not loaded off the hard drive, will become blank. Since I don't know exactly what render targets are doing in the background, I have no idea how to prevent this, or restore the textures if they are lost. How can I prevent/workaround this problem? EDIT: I did do 

I have never seen a game do this either. This is how I would design it so that hopefully there is an incentive to level up: At the beginning, when the character is young, they will be able to use the brute-force method. The character will have no issue wiping out waves of low-level grunts. The issue arises when the player encounters more intelligent enemies who can avoid or outsmart these simple attacks. The player has no means of fighting them because they aren't smart enough. As the player ages they will no longer have the strength they once had. However, they will have gained wisdom, which will allow them to outsmart those highly intelligent enemies. In fact, when speaking in terms of potential, the older player can be more effective. Strategy is more powerful than brute-force. In this design, enemies don't become much more powerful, but they do get smarter and smarter (which possibly means better AI). Here, the wisdom stat is your magical power. You might be able to turn this into something other than magic, but the same basic idea applies. Slowly degrade the players strength but slowly reveal to them new dynamics of strategy. This design gives players an incentive to level up, even though they will degrade other stats. This will also increase the level of challenge throughout the game because it gradually forces the player to use more intelligent strategies. So, to answer your question: The downside to this (well, not a downside, just a challenge) is you have to be very clever with how you intend the player to use strategy. You have to design it in such a way that the player must use strategy to advance. You have to design it so that the ability to use strategy is more desirable (and more satisfying) than the ability to use brute-force. You have to make enemies intelligent as well (or make them seem intelligent while simply having puzzling loopholes in their defenses), which is obviously difficult to pull off. 

Okay, here's what I want to do - when the player is at the main menu, I want them to be able to type in cheat codes. That's the only place I want it to work. I don't want to give them a text box to type into. Rather, I want them to simply type in a word (let's say "cheat", just for simplicity sake) that activates the cheat code. I only need to capture keyboard input when the window is in focus. What can I do to accomplish this? 

MSDN suggested this, but I'm worried about it slowing down the game when there are a lot of objects to check: 

The MSDN is really confusing about this, with all their different versions of XNA jumbled together for my google results. All I want to do is find out, in XNA 4.0, what antialiasing modes are supported by the display adapter. Supposedly, this involves calling GraphicsAdapter.CheckDeviceMultiSampleType(), but that function isn't defined. What should I be using in its place? 

Contrary to what I found searching for the answer, I'm not trying to see whether a character is in view of another character. What I need to find out is the size of the field of view. This is because I'm using Mercury Particle Engine in a 3D space, and while MPE emitters take parameters ranging from (0,0) being the upper left corner of the screen to (graphics.PreferredBackBufferWidth, graphics.PreferredBackBufferHeight) being the lower right corner of the screen, the positioning of enemy ships use Vector3 values, where (0,0,0) would be the exact center of the screen. Since my ships don't move along the Z axis, this isn't a problem. What is a problem, however, is translating their coordinates in 3D space to the correct particle emitter positions when I need to show them exploding. This is what I'm currently using to create the perspective field of view: 

If your projectile has a consistent velocity throughout, here is how to make it stop exactly on the target when it reaches the target: First measure the distance between the starting point of the projectile and the target. 

This sets speed equal to which increases at a rate of . You want the because is negative while t is less than 1 (and greater than zero). Just have start at zero and increase it by or the equivalent every update. Also, for the sake of performance you could store the value of in a variable and use it instead when calculating speed. 

I've never used Unity, so I don't know what it has to offer for this specific problem, but I would create this effect with one of these methods: 

Ok I was able to fix the issue on my own! I figured out that all color values become less as the mask blurs. So where the mask was fading out, not only were the A values fading, but the R G and B values were fading too! I'm not sure why that is, but here is the change that fixed it: 

I figured out how to implement a midpoint displacement algorithm to generate a map for my game. I wanted to create an infinitely large world, so I tried to patch two maps together, but they didn't look very seamless. I remembered the Diamond-square algorithm... On the Wikipedia page for the Diamond-square algorithm it says: 

The solid pixels would be passed into the "tex" variable. I would read the "impacted" and "impact" variables after one pass on a 1x1 texture. hlsl just doesn't want to let me do this. Apparently global variables are implicitly constant. Is there another way of doing this? on the variable syntax page it says "Global variables are considered const by default (suppress this behavior by supplying the /Gec flag to the compiler)." How do I add the /Gec flag to the compiler? I also wrote this, but it slowed the game down: 

And this is how I'm attempting to obtain the X and Y values for the particle emitter from the enemy ship position (however, the positions are not quite right with my math because I have the wrong constants): 

It does work, and I've ensured that at no point does either X or Y equal NaN. However, when Y approaches 0, it seems to go significantly faster. This surprises me, because the Y values are locked to the X, which is being incremented by a steady amount. What can I do to smooth the speed? 

Start at (0, 200, 0) Move to (200, 0, 0) Move to (0, -200, 0) Move to (-200, 0, 0) Move to start point, repeat as long as it remains active. 

You can find the original here: $URL$ I highly recommend going through the entirety of that tutorial if you're just getting started with XNA. 

Picture levelCannon as being a laser beam that goes across the entire screen. I need to see if my 3d model intersects with the screen space inhabited by the sprite. I managed to dig up Viewport.Unproject, but that seems to only be useful when dealing with a single point in 2d space, rather than an area. What can I do in my case? 

I have an enemy that initially flies in a circular motion, while facing away from the center point. This is how I achieve that: 

It doesn't seem to matter if the bulletList length is 1000 or 100000. What could be the issue here? EDIT: This is the code that removes a bullet, when it goes out of bounds. It is inside Bullet.Update() 

Where and represent the position of the target. You'll also need to keep track of the distance travelled, so just make a variable like . Then, whenever you update the position of the projectile, you'll need to add its value to . When exceeds , you know the projectile must have gone through the target point. 

but alas, this conversion doesn't seem to prevent the issue from occuring. I believe this is because is still a reference to a render target. Perhaps I need to perform a deep clone? If so, how? Also, the preserve contents thing doesn't work for this situation either. 

You can then create a doughnut shaped room by subtracting a smaller generated room from the center of a larger generated room. You should keep the walls of the smaller generated room though. Since I found this interesting I went ahead and tried implementing it myself. I would recommend not looking at my code until you have tried to write it yourself though. 

I want to test if my enemy can see the player, however I want this to be pixel-perfect. I already have all of the solid objects drawing into a separate render state. It should be noted that every solid object is changing and warping all over the place constantly. I cannot check individual walls because a distortion effect is applied to all of them. The walls blend together. Essentially it would lerp between the enemy's position and the player's position and see if there are any pixels that have an alpha value of greater than 0. The rotation of the enemy and the player do not matter. All of my attempts at doing this on the cpu have worked, however they slowed the game down dramatically. All of my attempts at going this on the gpu just didn't work at all. What is the most efficient way of doing this? Is there any way to do this in the gpu? Edit: There is no geometry at all. The walls are completely amorphous. I did not realize that global variables were constant in hlsl until after I wrote this: