You could rearrange the boolean expression so the then-block is executed rather than the else-block but that sort of boolean expression hurts my head. If having a boolean expression I can understand means using the else-block then so be it. When I set up my workbook, my equivalent of Sheets("BW TB") ended up in the middle so I have had to change your code in this way. I have had to do the same to the code I am about to show you. You need to isolate the portion of your routine that is taking a long time. The secret to this is the Timer statement which returns seconds since midnight as a single. I have declared some new variables: 

You will know from my last answer that I have created a workbook that has the same structure as yours. This means that with some modification I can run your macro. For me it takes .75 seconds for the loops to complete. In this answer, I explain what I have done and why. I recall that at one stage you were reporting that Sheet("BW TB") was being updated when it should not have been. I cannot find that report so perhaps it has been sorted. No matter, it is an excuse to tell you something. Programs always seem to go wrong in the middle. You want the program to run for 5 minutes and then stop at the problem area so you can investigate statement by statement. The tool for this task is the Assert statement. Most languages have assert statements. The VBA one is of the form: 

(2) Usage of undefined If your requirements state, it has to be undefined, then make it undefined. But whether that's useful, depends on the use-case. I would go with neutral elements of the desired type for each property. (3) Usage of this Also correct, this is the common usage of this. PS: Also bear in mind, this approach tries to emulate classes. However, JavaScript has no real concept of classes. Emulating foreign language features is not necessarily a good idea. $URL$ 

OLD ANSWER: Seems to me, the more optimal concept is to remove multiple occurences once you can. Given the worst-case scenario, that the unique element is at the ende of the array, filter and find would have to loop over all elements. Then, if indexOf and lastIndexOf are supposed to be O(n), you would be stuck with O(n^2) 

(1) Usage of prototypes "from my understanding, prototype should be used when the particular behaviour/property is shared with all objects" Yes, this is more or less correct. Functions on prototype are shared with all objects, which inherit it. They are not recreated, but simpyl executed within a different context (this) for each object. However, it depends on your design, if this is desirable. For instance the Getters and Setters in your case can syimply be by-passed: 

It depends on whether the data elements are required for the object to be well defined or if they are completely optional. My personal preference is for the constructor to have parameters for all the required data elements and use set methods for everything else. I also declare the default (parameterless) constructor to be private. That way the compiler guarantees that no one will create an incompletely defined object. If firstname and lastname are required but address and phone number are optional, I would do the following: 

The disadvantage of using the Builder pattern as recommended in other answers is that the completeness check is deferred to runtime. If you have a code path that is very rarely executed and you change Person so that more data is required, then you could deliver code that will fail in the field. With my approach, you will know about the problem the next time you try to compile your code. 

I would go with the former unless you profile your code and it tells you that the constructor for Regex is using a significant amount of time. Creating the Regex inside your method makes the clear statement that this given Regex is being used by only this method. The compiler doesn't care, but someone maintaining your code in the future might care. Running a profiler is necessary for really optimizing your code. There are some things that are always likely to be bad (O(n^3) algorithms for instance), but I've learned by experience that I can't tell just by looking where the time is being wasted in my code. Profile it and see what you learn. If your profiling results tell you that the constructor of Regex is using too much time, then definitely move it outside the method. If you do that though, you should add comments explaining why. (Keep thinking about the poor person maintaining your code in the future, it just might be you.) 

If you want fullName to be truly private, you would have recreate Getters and Setters for each object. 

(1) Any opinion about this? Emulating language features/idioms which are not supported by the language itself (e.g. classes in JavaScript) does not seem to be a very good idea to me. JavaScript is not an classical OOP-Language (yet), but there are Prototypes: 

This way, you have only n iterations for the first application of remove. Then you reduce the size of the remaining array to at least n-2 for the next recurrence, depending on the distribution of multiple occurences. This should sum up to O(n log n), but i'm not sure when it comes to the exact math. This solution might be worse space-compexity-wise. 

(2) Is this fast? Emulation is probably slower than using native methods - i suppose. However, it depends on the underlying engine. V8 is faster than Gecko. (3) What about correctness? Depends on how you understand correctness. JavaScript is powerful enough to emulate classical inheritance to some extend. (4) FYI If you want a more Java-like access to the parent-prototype with "super"-sugar, you can do something like this: 

I have an anomaly in portion 3 of sheets 1 and 2 that might bear investigation. I should have displayed sheet name rather than sheet index. I leave that for you. If the fault is in your code, this should you enable to isolate the cause. 

That is followed by a boolean expression. Here I assert that the current sheet name is not BWTB. It this assertion is true, execution does not pause. But if it is false, execution stops on the assert statement. Place the assert statement at the top of the suspect code. When it pauses, use F8 (execute single statement) or use F9 (set/unset breakpoint) and F5 (execute until breakpoint) to step through the code until you have isolated the problem. I assume you have made all the improvements people have suggested although my experiments reveal these improvements will not make the difference we all believed. You start with Sheets("4020"). I seem to recall that you said it was important to start with this sheet. Is this because the other sheets depend on Sheets("4020") or because Sheets("4020") is Sheets(1)? I do not like the way you step through the sheets. Your code depends on Sheets("4020") being Sheets(1) and Sheets("BW TB") being Sheets(26). If Sheets("4020") is special you should make the body a subroutine with sheet name or index as a parameter. You then (1) call the subroutine for Sheets("4020") and (2) amend the loop to: 

However, bear in mind, that "super" is also a foreign concept to JavaScript. You cannot type foreign syntax and expect it to behave identically with comparable performance. Additionally, you may emulate "super" as shown above, but you will have to use with great care, meaning 'ParanormalStudent.super' and 'this.super' may point to the same function, however, the latter will result in exceeding the call stack. This seems to me like a bad practice, since as a programmer you will have a tool which may either work or produce chaos. 

The proposed solution by the questioner is the fastest, 2n tops if i'm correct, so O(n). But error handling is problematic, consider the input [2,3,3,2,-1]. Is -1 the correct result or does it indicate an error? Maybe, instead of returning only the first unique element, just return all unique elements 

By returning an array you can still get the first unique by applying [0] to the result and indicate no unique entry with an empty array. It also does not change your complexity: avg. n+k with k being the count for different values, but still 2n tops.