The fact that leaves behind a to a possibly destroyed entity bothers me (right now, moving your entity does not "destroy" it, but you might add destructible components later). In my opinion, should not take its argument by pointer but by reference: 

Voilà! Your program has been converted to somewhat clean modern C++. Now, all you have to do is to provide more scrambling algorithms and to provide a mechanism to tell the user that they have chosen an invalid option and that they should chose again. 

If you killed all the monsters, you can't be dead, so I added a little to make it clear. Also, I would change the name of to something akin to since gives the feeling that we are playing the whole battle. 

Manipulating bits One of the areas where your code may be improved is the way it handles and compares bits. Your are using strings to represent bits while you could have used values and bitwise operations to speed up most of your operations. Actually, you should even replace every representing bits by since the representation of values is known and they are the tool to use when representing bits. 

Here, you are allocating memory for a , then you try to add it at the end of . When inserting an element in an , a new node should be allocated. Unless otherwise specified, uses to allocate new memory, which is based on and . In other words, if there is no more free memory to allocate for the new node, will throw an exception and will rethrow the exception. In , if throws, then the newly allocated () will not be freed. This is a memory leak, and so your method fails to provide the basic exception safety (also known as no-leak guarantee). If you use a smart pointer to allocate the memory, then when throws, your method won't catch the exception, but the destructors of the automatic variables of the method will be called. Therefore, the destructor of the smart pointer will be called and will be safely deallocated. 

Access modifiers There are several parts of the base class that you do not need in the derived class. You could make them : 

That way, if you ever intend to change the signature of or in the base class (breaking changes in an interface are hardly a good idea, but they sometimes happen) and forget to change one of the derived classes, you will get a compilation error stating that and/or are not overriding anything but merely hiding the base class function name. 

Generally speaking, the code seems quite good. However, there are some parts that could be a little bit enhanced. I did not try to understand the whole thing, but I can give you some pointers. 

The first rule of matrix classes in C++ is that you don't write them by yourself; there are already dozens around, often highly optimized with [smart] expression templates and other cryptic stuff: Boost.uBLAS, Eigen, Blaze, Gmm++, Armadillo, Blitz++, etc... That said, I would lie to you if I told you that I never tried to reimplement my own matrix class. I think that I tried to create one at leat two or three times :) 

Size of the heap First of all, you have two functions to obtain the size of your heap, and , which is redundant. is there so that your heap looks like an STL container, however, the standard method name to get the size of a container is , not . There is no need for the function : it is a duplicate, it does not conform to STL naming, and it does not even conform to the case of your other functions. I find the fact that the size of your heap does not correspond to the size of the underlying rather troubling. When I write this: 

With that (everywhere in your code) and some trivial changes, your code will also work for C-style arrays (tested here and it works fine). Naming your function The name is quite long. The function you created already exists in other libraries and programming languages (Python comes to my mind) under the name . You should consider changing its name in order for many users to recognize the name at first glance (moreover, it will be shorter). 

To conclude, one solution would be to make two lists of s. Not only would it be more respectful towards many many people in the world, but you could also get rid of your and classes: that would make your code more generic while probably shorter and simpler too. Everywhere you have variable names containing or , you can replace them by and or and . Moreover, that kind of genericity would allow your code to be adapted to more complex problems (for example, a problem of Ménage à trois speed dating). Never forget that you should treat people as people, and consider how they define themselves before considering how you would like them to be. 

The function First of all, I do believe that should only be a free function that takes any number of mathematical objects and returns whether these objects intersect at some point (or line, or other). I also believe that your shape classes should expose enough properties so that can be computed between any two objects without needing to access the classes internals. Therefore, I would simply define as an overload set of free functions and I would drop the methods in the classes. Handle divisions by zero Your method will consistently make a division by zero with vertical lines. While this is the "expected behaviour" of a gradient method, be sure that your computations using handle this special case before calling the method. For example, your method needs to be fixed. Currently, it will perform a division by zero because of when the line is vertical. Let's add a condition at the beginning of to handle this case: 

If you are willing to write modern code, you should consider dropping and using everywhere instead. It helps to be consistent between regular alias and alias template. Moreover, the symbol help to visually split the new name and the type it refers to. And the syntax is also consistent towards the way you can declare variables: 

Here is your code once refactored. I don't provide a link to an online compiler since none of the ones available has a good enough C++14 support (you just need to add some light library components though): 

When is an iterator, it is first incremented by , then decremented by . Considering that and are not trivial for iterators, computing then incrementing is likely more efficient. We can thus avoid this small albeit gratuitous pessimization by transforming the statement as follows: 

Frankly, there isn't much to say about this class since it is simple enough and relies on another simple clock. The type alias, static members and static methods seem to all rely just like they should on the template parameter so there is no problem. I believe that is nothing really from os this shouldn't be a problem either. The only remarks I have is about the template parameters: I am not sure whether defaulting to makes sense. Is it really the default clock amongst the three standard clocks? If you think so, why. But frankly, defaulting has no sense: doesn't tell anything about the epoch to the user and you already provide the meaningful type alias (note that using the defaults is always equivalent to using , which makes them useless). You can't default without defaulting though because you can't change the order of the template parameters. I think that the best solution would be to leave undefaulted template parameters in but make an alias template with a possibly default template parameter: 

That way, you have some of the benefits of polymorphism without having to pay the cost of runtime polymorphism which I feel you won't need for such a class. That's a little bit tricky to understand and use at first, but it has clear benefits. 

All the other checks are not really useful. The first check to check whether the letter is in the alphabet is not really useful, because the letter cannot be in the word in the first place if it is not in the alphabet (unless you did something wrong, but if you did something wrong, it will be simpler to read a meaningful error message). 

Since type traits generally use many templates, you don't want to add even more extra keywords all over the place. Use alias templates If you have acces to a compiler that supports some C++14 features, you will probably want to use the alias templates for transformation traits to get rid of many and . Unfortunately, the alias templates for the query traits () have not been accepted, so you have to use . 

Self-documenting code is viewed as good by the Python style guide (known as PEP8) and the Zen of Python even says that: 

Define in terms of As pointed by @Yuushi, Boost has a class which will apply a function to the return value of . Therefore, could be define as an alias template: 

Note that I used forward iterators since the operations you use do not require anything more specialized to work. You will have to make some compromises like using to check whether the sizes are the same, which eventually means that the size comparison will only be \$O(n)\$ for random-access iterators. In a future C++ world with concepts and a standardized , you could have a signature like this: 

Therefore, I decided to build some truth tables. In the following table, \$ lhs_{old} \$ and \$ rhs_{old} \$ are possible values of and before the update while \$ lhs_{new} \$ and \$ rhs_{new} \$ are the values of the same variables after the update. I did not take any interest in and since none of them is used to compute both \$ lhs_{new} \$ and \$ rhs_{new} \$; therefore, I simply ignore them in the rest of this reflection. \begin{array} {|cc|cc|} \hline lhs_{old} & rhs_{old} & lhs_{new} & rhs_{new} \\ \hline 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 1\\ 1 & 0 & 1 & 0\\ 1 & 1 & 0 & 0\\ \hline \end{array} We can easily replace by \$ lhs_{old} \$ in the computation of \$ lhs_{new} \$ but we can't use it to compute \$ rhs_{new} \$ since the update already occured. My first thought to get rid of was "can we compute \$ rhs_{new} \$ with only \$ rhs_{old} \$ and \$ lhs_{new} \$?". Looking at the truth table above, it appears that it is not possible. Trying to compute \$ rhs_{new} \$ before \$ lhs_{new} \$ doesn't solve the problem either. However, we already have computed another value in the loop: . Therefore, I injected \$ res_i \$ in the table and looked at what could be done with it: \begin{array} {|cc|c|cc|} \hline lhs_{old} & rhs_{old} & res_i = lhs_{old} \land rhs_{old} & lhs_{new} & rhs_{new} \\ \hline 0 & 0 & 0 & 0 & 0\\ 0 & 1 & 0 & 0 & 1\\ 1 & 0 & 0 & 1 & 0\\ 1 & 1 & 1 & 0 & 0\\ \hline \end{array} We can infer from this "truth table" that \$ rhs_{old} \land \lnot lhs_{old} = rhs_{old} \land \lnot res_i \$. If we inject this new discovery back in the code, we can use it to totally get rid of : 

I won't be of great help for concurrency-related issues but there are some other small things that could be improved in your code: 

This version does not handle negative exponents since you don't need them, but it would be trivial to add. Counting digits There are other ways to count the decimal digits in a number than the one you use. Once again, I didn't time, but if floating point operations are fast enough, you can simply compute \$\lfloor \log_{10} n \rfloor + 1\$ which in C would be: 

Actually, it should even work with any type for which the operations , and have the desired semantics. Catch errors arising from command-line arguments that cannot be parsed as s That one is easy if you look at the documentation of : it says that throws an exception if the string does not represent an integer and an exception if the string to parse represents an integer too big for the type to hold. Knowing that, you can set up a simple / to handle the errors: