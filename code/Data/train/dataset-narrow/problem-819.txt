I'm thinking I would store all the object handlers (perhaps up to a hundred, maybe thousands) in an array for working with them. Is there a better way? This sounds like the source of your original problem! Large arrays can chew up alot of memory. It does not matter if it's an array of arrays or an array of objects. A Relational Database is much better for the job. There are many to choose from, postgresql, mysql, sqlite, oracle, etc 

The main security concern here I guess is protection from sql injection. Good news. You got that part right by using bound parameters. Here is what you should improve and why: Make the name of the class match what it is. In this case, it represents 1 Contact. So, name it Contact. You said "besides no use of getters and setters". However, I'll point out that the reason you should use them is to provide a stable api to your calling code and to encapsulate future behavior. There are more reasons, but those are important ones. Inject an instance of PDO instead of creating it all over the place. For one, all those connections will kill your performance. And, it will separate the concern of making the connection from this class - making it simpler. 

You ignored mseancole's first bit of advice about not using globals. Note that the globals are not only $conf and $DBH but also $_POST, $_SESSION, and $_FILES. All of these globals should be passed to your functions. And your code is still very difficult to read mostly due to heavy indentation. You have heavy indentation because the function is doing too much. It is concerned with ip addresses, input validation, input filtering, db access, view presentation, and probably more. Yes, all those things need to be dealt with. But, dealing with them all in one place makes one huge piece of non-reusable, non-testable, hard to maintain piece of code. 

Add proper error handling for PDO. You can configure PDO to throw exceptions. Or, if not, you should do checks like: 

Have a look at the symfony2 routing documentation. Also, symfony2's routing is a stand alone routing component that you could use in your index.php/front controller. 

Your approach, which is to load a partial view (html) via ajax, is just fine. Yes, you could load something else such as json, xml, etc. The problem you'd face is that you would require additional client side (js) code to deal with the data. Some feel that the lighter payload of json offers faster loading over html. I argue that your users would likely never really notice an improvement. I would offer these suggestions: 

I think that what you have is probably fine. Personally, I'd move the construction of the result array to a view but this is not that big of a deal. That might help with the "clunkiness". With regards to your concern about the size of the json response: You say that all of the information in it is needed by the app. It doesn't look all that big to me. Unless you are actually experiencing problems as a result of the size, I'd leave it alone. If it were too big, you could consider implementing appropriate caching (allow the browser to cache the results and/or use etags) or pagination. Regarding the number of individual sql calls: I'm sure you could put it all into one query if need be. Both of these potential issues, response size and number of queries, seem to me to be pre-optimization concerns. In the past, I've spent lots of time pre-optimizing stuff and never realized any real gain. Now, I implement what is needed and only optimize when the real need arises. The bottom line: I don't see any problems with what you've got and unless the result is unacceptably slow or resource intensive, don't worry about it. Hope it helps. 

You could think of "Category" as a module (or in Symfony, a bundle). The route pattern would be: and ChartController might look like this: 

Design the initial app with 0% javascript in the beginning! Things can change a lot while developing an app. You'll appreciate not having to change both your php and js early on. Separate your data access and presentation layers. Use a templates system which allows you to render a full html layout (everything inside including the page specific content) or partial html (the content in ). Once you decide to spruce things up with some js and ajax, have your controllers load the partial view if it's an ajax request, or full layout if it's a regular request. 

Use oop to describe your domain, provide encapsulation, make code testable, etc. Oop does not inherently make code run more efficiently. An object with 13 properties uses just as much memory (if not slightly more) than an array with 13 keys. My approach to oop is to describe the problem domain first. Worrying about the database at this point will only complicate things. Obviously, I don't understand your problem domain but, for discussion purposes, let's say I have these things: Team, Season, Competition Now, thinking about an api or how these things interact with each other you might have something like this to register teams for a season: 

With the $key invariant satisfied, no need to throw an exception if not set. Remove the setKey/getKey methods (unless you really need them). Cleaner calling code example: 

I think there are two main areas you can focus on: n+1 queries You have 1 query to select all of the teamid's and n additional queries, where n is the total number of games per team. Actually, the problem is more severe than that because you call from , , and . And, is also called from . All of these queries and redundant queries are probably chewing up the most time. Work on creating one query (or fewer) with joins to the games table as necessary. Make sure that columns are indexed appropriately. Serialize, gzip You mention that you are taking all of the results and storing in a serialized, gzipped array. Not sure where you are persisting that (file system?) but, I think you would be better off storing the results in a denormalized table. If fact, if you take my advice and use just one query, you could your results from that one query into the denormalized table. Personally, I'd reconsider the whole approach here. Surely you are not displaying ~17k teams in a single web page. If you are, don't. If you only display ~20 teams per page, you could easily run some aggregate queries against the games table and run your rpi calculation for each. Not only would this cut out the cron/batch process, your users would always have up-to-date data displayed. Edit: To display only a few teams per page, pass the limit and offset in the url. For example, to display teams 10 through 30, use a url like: 

You will likely have other kinds of classes that represent different kinds of rows. Move the common behavior (find, save, delete) into a parent class. Create proper doc blocks for your methods: 

In the tests above, we are ensuring that the message being passed into the send method is being properly passed to the socket. And, we check to make sure that we return the correct boolean when the Socket operation is successful and when it fails. We do these things by directly controlling the "Socket" for the test conditions. Your calling code would then look something like: 

EDIT I suggest using a factory method to construct your instance instead of overriding the constructor primarily because 1) Changing the argument list in any overridden method effectively changes the interface. This makes it more difficult to replace one class with another. 2) I feel that constructors should do no more than serve as a way to inject dependencies that are always needed and initialize default values. In your application, somewhere during initialization/bootstrap: 

Remove direct access to $_SESSION. This kind of global access is very difficult to maintain and test in the long run. Now, having said all this, your approach here (which is sort of an active record pattern) has been done many times over. Check out a library such as php active record and you will save yourself countless hours and hassle. 

The most obvious omission is error handling. You don't handle curl errors or xml parsing errors. A REST api is like any other external service you might use in your application (such as a database). You might consider creating a client library for it (first check to see if one does not already exist for the service in question). Example usage with the implementation details neatly tucked away: 

The Good You use bound parameters. You handle errors. The Bad You filter the email address but then pass the unfiltered value to the select and update queries. What are you trying to achieve with the check of the filtered email? You are not checking the validity of the 'y' param (which I assume is an activation token). Isn't the point of this kind of activation to ensure that the real person at that email is doing the activation? The way you have it, an attacker could register an account using any email address. Here is how: 1) Attacker goes to your registration page and enters someone else's email address (i.e. notme@example.com) 2) Attacker crafts and visits the url: (where the y value is some random string, 32 chars in length) Attacker now has an activated account using an email they do not own, having never received the activation email. The Ugly Your logic and presentation are mixed together. Perhaps for this relatively simple script, it's not that big a deal. But, over time, these things have a habit of growing and getting very messy. Look into mvc. One try catch block should be all you need. Example Rewrite 

Give the class a better name... a noun makes more sense than a verb. Consider simply removing the and properties and applicable setter methods. Instead, your encrypt method signature could be: 

There is much omitted here but the point is to understand how your objects relate to one another and what kind of behavior is needed. Spend some time writing this all out on a whiteboard or paper. Talk it over with others who understand the domain. Make sure it properly describes the domain before writing a single line of actual code. Note that a model is not simply Entities with a bunch of setters/getters. The model should contain actual behavior (such as registerTeam) which usually does more than just set 1 internal value. Behavior modifies the state of the model by performing calculations, checking validity, etc. Once you are ready to persist some of this data, I highly recommend that you use an existing persistence library such as Doctrine, Propel, etc. Some of these work differently from one another but the idea is that they capture the state of your Model by mapping your Objects to your Relational Database and re-create your Objects from the Relational Database when you need them again. Regarding some of your specific questions: Are there any glaring problems? I'm not a huge fan of sticking persistence stuff into my Entities but, this is personal preference. However, if you want to use this pattern (called Active Record btw), the db object should be injected as others have already stated. Also, with passing an id to the constructor, how would one go about creating a new Entity? All of your setters are private. Is the team class considered read only? Since $stateid is just an ID reference to the state, should I store the state name as part of the object? It depends on whether you consider State to be a simple property of team or whether it is actually part of some related entity such as Address or Location. Do I need to store the $teamid? If you use a ORM, let it worry about that. Is there a better way to handle the colorsX? Handle it vertically instead of horizontally. i.e.