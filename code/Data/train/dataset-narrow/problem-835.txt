In the main loop you add overwriten the current values with just the IP address I would not consider this good practice (though it works here because of the simplicity of the program). And since your next step is to convert the array into a hash why not do so directly in the loop. 

When inserting a child into the middle is it intentional to only set the index of the inserted child? 

Next you are implementing a sort of rotation threw the different combinations (using switchDate() and ShiftDate()). This functionality can be achieved using . Look here for a list of standard functions: 

You are not allowed to add stuff to the standard. You will break things. Especially with a name like Put this in your own namespace. Koenig lookup will correctly deduce the namespace of your function. Avoid the use of this If you have to use it means you have written un-maintainable code because you are having to explicitly tell the compiler what to do because you have several names that collide and you are trying to differentiate between them. 

In your code both and return an R. This is not normal. It may be very big object that is returned. You don't want to copy that around. It is more common for the to accumulate state as it visits objects. Then when it has finished visiting then you can access the state from the visitor object itself. 

Is trying to compensate for endianeess. I would rather see a standard function here. Something like or an equivalent. I assume there is a reason that the padding starts with: '\x80`. It would be nice that is in the comment. There must be a technical reason you are not '\0' padding the string. 

Comments on code In C++ code you do not want to be messing with C-Strings. All that memory management makes the code hard to maintain and is difficult to get correct. prefer to use std::string which does all the hard work and lets you concentrate on the algorithm. 

Not this is bound the current scope this you can limit its affect to just a function. There is an easier way to write explode(): This example breaks the string into words using white space as the delimiter. If you want to use another delimiter that is relatively easy; just use a type that reads words by delimiter when using the operator>>. 

While we are on . A variable of length 1 is not very meaningful. Your code should be self documenting. This really means your variable names should be meaningful. Avoid Platform specific includes. 

I would use the header guards because not all compiler support . Note the space between and the is non standard. Most compilers may be forgiving about it but not all so I would not do it. 

More barely readable code. A nice alignment would be good. There are also other constructs that will help: 

I would not have a default constructor. Is there a need to create an special "unnamed" object? Sure you can pass by C-String 

Standard algorithms. Your code will be optimal when you use the standard algorithms. Its worth learning what is available. $URL$ See section 5 I showed you how to copy all but the characters you want. But there is one to remove all elements in-place. I'll let you experiment. 

Algorithm Comments To be blunt I have a hard time following what you are trying to do. There should definitely be more comments explaining what you are trying to do at each step (the only way I managed to decode it was reading the python version). One technique you can use to make things easier is to create structures to hold groups of related information (You should have mimicked the python array). 

For any combination of 3 letter words the distance between any hashes can not be greater than 78. Without doing any analysis I bet the distribution of 3 letter words is actually normal so a whole bunch of words have a hash within 12 places of 234. Writing hash functions is hard to do well so don't. Pick a well known one and use that. Building your own dictionary You use your hash function to build a dictionary like object using a vector. A couple of problems with this. But the main one is that clashes are not correctly resolved. Each entry in hash should be a list (so you can handle clashes correctly). Also 53 is rather a small size (though it is prime which is nice). But there is already a dictionary like object in the standard library. or . The first one builds a structure with the same access characteristics as a balanced binary tree. The second one has access characteristics like a hash table. You can choose either and it will work fine. In your node object you store pointers to the other nodes. 

You are making a copy of all the data to send back to the user. This brings me back the class for encapsulating the raw data (m_data above). If you had encapsulated that data in a class you could just return a const reference to this internal object, thus no copying required. Also I don't particularly like the lines: 

If you pass it pointer to the constructor use those. If you pass in values save them locally but set the pointers up to point at the internal values. When doing operations always use them via the pointers (as the pointers point at the correct place always). 

It adds a line. It is also longer to type than just prefix each swap with As pointed out by @Matt below. There is a good reason to do this. Read his links below for a more detailed description. No point in doing copy-swap idium for a class that is not managing resources. So really there is no need for the copy constructor or the assignment operator the compiler generated versions will work perfectly well. If you can compare against a value: 

Is it safe? To a point. Naming I hope the name is just for illustration purposes as otherwise that is a pretty terrible name. The changes I would make are: Accepting pointers must indicate ownership. Your current interface does not indicate that it is taking ownership of the pointers. So as a user of your class I need to dig inside and find out if you are taking ownership or not before I can use it. 

Calling top() on an empty queue is even worse then returning . It is actually undefined behavior. Which means your code is broken. This though: 

This means it is controlling the memory managed by . And you correctly delete the memory in the drestructor. But you failed to implement Copy/Move semantics of the class (or delete them). Unless you overide them in the class the compiler will generate a default copy constructor operator and copy assignment operator. These do not behave well in the presence of owned RAW pointers and need to be specifically defined or deleted. 

If you do take ownership you need to do some work in the destructor of your publisher to make sure that you correctly relinquish ownership when the publisher dies. If you don't have an ownership claim. This also means that the lifespan of the object may not live as longer as the publisher so you also need a way for the object to remove itself if it dies first and for the publisher to notify the observer that it has dies so it does not de-register itself from a dead object. 

If you know how much data you are going to push into an array. Use the method to prevent reallocation several times. 

All your functions can be written much more succinctly and easier to read if you follow those rules. 

The reason for using is that some function calls are actually macros (yes some people use them still). If they are bad enough to write macros they probably don't know how to do them well and thus they can be compound statements and would break an if/for/while sub block unless properly braced with . So it is just good habit to always use the braces. 

You use lock/unlock pairs for the mutex. This is not exception safe. So I would create an object that will do the lock in the constructor and unlock in the destructor then use this to lock your mutexs. This will make your code more exception safe. 

Design Pattern Comments It works as a chain of responsibility (and the point of patterns is that they are not exact and are chained depending on exact need). BUT saying that I think you could have done it better in this situation. 

The fread() function may fail you need to check the amount read is what you expected (also you should probably re-name to make it easier to understand). 

Since we know that there are no errors this is an indication that you have problems somewhere in your code that still have not been found. A hand written C implementation of a list is not going to be quicker than it is designed for efficiency. Your exception should probably enhierit from 

There is no real need for this. In a terminal the application quitting is not a problem. In an IDE you just have to set a configuration option to stop the window closing. So you really should not need to bother with this. Personally I only return a value from main() if there is an option of failing. 

You don't objey the rule of three (or five). Look them up. This does not handle collisions of the hash. 

Global variables are bad. Don't do this. They make the code hard to test. Side affects will cause problems. Prefer return over out parameters. 

That could would look a lot clearer without the cast. I would only keep it if the compiler is generating a warning. (but then I may change the type of to be the correct type (but I am a C++ programmer and correct types is important to me). This seems like a complicated way 

Now you will be able to refer to then without using the prefix struct. Don't use all caps. A macro (with no scope boundary may play havake with these identifiers). 

======================================================= If you don't do the indentation correctly (as I describe above). You can simplify your current program too: 

Each controlled by a different container type. So I would guess that you probably want to use two different kids of iterator. 

When adding A to a B in you should not need to check if the value passed is a so you should pass by reference to indicate that the value is never (or you should explicitly check for but an object should know its not ). Same applies for When building an is there ever a possibility that the will not exist? Your code does not check so I am assuming no. So you should pass the B by reference to again indicate that the B can not be . This worries me: 

Looks like the functions / ... are practically identical. So this should be just one function. The state could then be incorporated into a class (and the function becomes a method). Then you can represents your roter's by an array of roter objects. 

Yes this is really ineffecient as you are creating multiple arrays and copying stuff around. I would create a new private constructor to solve the issue. 

I think that is more than enough on a first review: Overall I doubt that works (I found one bug in the first function). I checked your github account and there were no unit tests. TDD is a good technique. Set up your github account to build on Travis_CI and add some unit tests. Overall I think you need to rewrite this from scratch using correct C++ techniques. Encapsulate your skip list in a class. The class contains its own class internally that is never exposed externally. First build a doubly linked list get that reviewed here then once you have that correct upgrade it to a skip list. 

Public Implementation: Bad No. You are basically allowing intrusion into the implementation details to implement anything. 

Array access Indexing into arrays starts at 0 (not 1). Arrays/Vectors and containers in C all use a 0 based indexing scheme. So if you have an array with 10 elements then the valid indexes are [0..9]. So this is going to be off by one. 

So you have just allocated as much space as the original. So we are at . But then you make a recursive call. Which will do exactly the same thing (but with half the array). So we are at then you will recursively call it again. Eventually you will allocate a total of space (plus control structures). An easy way to get around this is to make your interface allocate the scratch array then call your internal merge sort passing the original and a scratch area. So the total amount of space you will use is (and only one extra control structure). 

Not sure that heap is the correct structure. Sure it does sound correct initially. But you can increase the count of items that are already in the heap (which means you have to rebuild it from scratch). I would just keep a sorted list of the top n items. When a count increases you at most need to move one item in the list. I can't really review more than that because your code snipet is missing the most important thing. TYPE information. 

In this case is the same as . But the code is written in such a way that any changes by a maintainer can easily result in this being not true. Also I don;t actually see the need for a cast. 

But there is no indication you are passing ownership. The person reading the code has to know how the internals of how your class works. Otherwise they do not know if the pointer passed should be dynamically allocated or not. You need to make this knowledge explicit in the interface. Here I would pass a unique_ptr to indicate that you are passing ownership of the pointer into the node. OK. Parent is allowed to be a pointer. 

Usually it does not matter. But sometimes it does. If you get in the habbit of using prefix increment then you always use the optimal version of increment. Prefer '\n' over std::endl Don't use return 0 in main when it can never error. 

Even though inherits from the shared pointers don't have the same property. is not related to but we want to be able to use them as if there was a hierarchy. Just like you would if there was a pointer. With being the expected pointer being used for (or no object). You should be able to explicitly use this. Trouble is that you can't because has a type of which does not match any of your constructors. Interface Review Identifiers with a leading underscore are a bad idea. The rules around a leading underscore are complex so best to just completely avoid (even if you know all the rules people reading your code probably don't). 

You are returning a pointer to an array that has gone out of scope. Personally I would return a . Don't worry on a simple returning like this the copy back of the array will be optimized out (look up RVO and NVRO). 

This allocates memory. But when the function exits all memory is correctly deallocated (even after early return or exception). Use standard container like automatic variables whenever you can. Notice I did not use . Normally I would use the same type in the vector that I would have used in the array. But there is special consideration taken for that make it less efficient (everybody has concluded this was a mistake by the committee but it is not going to be fixed for backwards compatibility (at least not any time soon)). Also note your original code contains a bug: