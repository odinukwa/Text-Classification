I wouldn't rely on to protect your code from other libraries that use the as well. - Click Event Handler: As was mentioned before, there are several ways to set up your events. The ones that were mentioned were and . The method simply calls the method and passes in the click. The method is incredibly useful since you can use it to set up almost any kind of event - not only clicks. So yes, the one you are using now is "the best" because it saves you a function call. Now saving a single function call in your app won't be a significant increase in performance and you probably won't even notice it. Although arguing over such a small and possibly insignificant changes is really what we developers do best. Using the method directly is hands down going to be faster, but there are many other things you could be spending your time on that will generate more significant performance results. - Don't re-invent the wheel: I strongly believe that if there's a working solution out there by all means use it. There are tons of tabs and accordion plugins available I'm sure you can find one that fits your project. If you can't find an exact fit, you can still always tweak it and make it fit. jQuery it self has an entire UI package with tabs, accordions, sliders, and all kinds of cool stuff just ready and waiting to be used. Also the jQuery UI will let you use your own CSS files and customizations really easily. Making a whole new app from scratch should be done if absolutely necessary, or if you're trying to learn (which is your case). Back to the subject of learning, like you said, you are just starting out with jQuery, and with that I highly recommend this screencast by Jeffrey Way called 30 Days to Learn jQuery. He does a really good job of explain some basic principals as well as some more complex concepts. One thing in specific I'm going to point out is the following: 

Since the function takes a unique_ptr now, you now know you need to pass a pointer and you also know you are passing ownership as well. 

That's a bad call. Ideally, you should only use the preprocessor when no other alternative exists. In this case, many many alternatives exist. 

Very inefficient. First, you allocate buffers with new/delete. You should not do that. Second, you allocate in a loop. You shouldn't do that either. Consider this code instead (function renamed to , as what you do is not parsing - parsing would be the inverse operation - taking a string and extracting an integer from it): 

Create a new base, for objects connected to more than one object, that offers the same interface to client code: 

The algorithm is a shallow comparison between the documents: it is possible that one of the children of site_entries has a corresponding child in the other document (by name), but other changes are present between the two (like subnodes). Was your intention a shallow comparison algorithm, or is your implementation incomplete? That said: 

Your constructor calls swap, which receives a reference (meaning you are actually creating a copy here). Either way, you don't need to write your own swap for this class. For this constructor, consider this implementation: 

- Cache your selectors: As a rule of thumb, if you use a selection more than once, you should cache it. What happens when you use is jQuery has to jump into the DOM and look through all elements that would match that selection. So you should really do a search only once, and save your results for future use. This way you can look and play with them whenever you want. Ex.: 

What I suggest is read the jQuery source. Check out how they do it. In their init method they return this for certain cases, but not for others. Like when there is no selector: 

If you wanted to change your code a bit here's an example with using child selectors. If you have question about any of these methods just let me know and I can explain them. You can also read up the jQuery documentation for each one to get a better idea of what's going on. Also here's a Fiddle: $URL$ 

- You can use $ in Wordpress: If you have your code in the footer (which you should be doing) what you'll want to do is wrap it in a IIFE. "What the hell is that?" you may ask. A basic syntax looks like this: 

For size and emptyness checks, you should consider caching the list size. For iteration you should implement either iterators, or the visitor pattern, or both. Code Style 

For a professional cryptographer (which I am not), it would be very easy to crack, due to the following factors: 

This separates the act of checking for vowels from defining what vowels are (which is good for maintenance; for example, you could decide you also need as a vowel, later). The function alters the value of the argument, but you do not use the resulting value, in the calling code. The function could be written like this: 

For learning RAII/resource management, it's a good idea to write your own smart pointer class. For production code, use std::shared_ptr, std::unique_ptr, or boost smart pointers (if you have to). Here are some notes on the code itself: 

This is not setting a buffer, but selecting a buffer by index (consider the names , , and so on). is a structure. Consider creating it as a class (outside of Terminal) and not exposing it's data. Currently you expose it's data to client code and (because of it) you end up with this client code: 

While the idea is OK, this seems to add very little over a (unordered_)map of strings to functions (created directly). The client code is almost the same as your client code anyway: 

Don't be intimidated be the size of the book, I just like to write out and explain in as much detail as possible. Well anyways, I've pretty much re-wrote the whole plugin. I've applied a more object-oriented approach and re-factored the plugin into the Module Design pattern. It's now much easier to add functionality and debug code. I've also added in some safe guards to properly initiate the plugin as well. At the end of the code, and inside it, I've included a few links for reading and watching materials. I highly recommend you go through them as they can explain the concepts demonstrated here a lot better than I can. 

This works just fine and fulfills all the requirements from the assignment. What I want to know is how can I improve this code while still remaining within the requirements. Also any reading materials/videos that you think would be useful for my learning please feel free to share them. Main Race file: 

Here they don't return the jQuery object, since this utility is for arrays. My point here is that there's no one shoe fits all. It depends on what you're trying to get from your plugin. Also chaining is expected but not on something like $.map(). Also keep in mind, in your callbacks should refer to the element in question (ie. in a click callback refers to the clicked element). If you're not playing with an element, should refer to the global(window) object. 

Yes. You can remove the difference between association and relationship, and define a single concept ("connectable object"). 

The function as it is, depends on the client to check for errors on the stream (either by calling or by checking the stream state, after the call to ). Ideally, I would want to write: 

Edit: here's some client code, that is possible due to the separation of the parsing and the construction: 

Your code can be made smaller and without repeated constructs, by mapping your keys to values in a map: 

All these can be avoided by not returning a raw pointer from your class. Consider returning a instead, and using other means to edit or set the buffer, than this API. You say: 

No. Usually it is a symptom of your class hierarchy not being specialized enough (not covering the functionality it should through virtual functions), or your client code being too generic (i.e. your code working on base pointers or refs, when it should be working on a specialized type). 

Yes (but please refer to it as "template method" - "template function" makes most c++ developers think of ). 

First (1), don't use in C++. There are (arguably) places where it improves things, but in this case, you can simply replace it with a (or ) loop. Second (2, 3), you are throwing a dynamically allocated ERR instance, which is bad (because it won't get caught) and unnecessary. The code should be . Third (3), you should catch a exception reference, and it would probably be beneficial to make a specialization of std::runtime_error. 

It's all probably a lot more complicated than this and articles like this probably explain it all a lot better. As you progress in plugin development you should start to think about implementing design patterns. There are almost endless options of patterns you can use and some you can event make sort of a hybrid pattern. Don't feel overwhelmed with all the options pick out a couple to start with and try them out. I'd suggest the Module Pattern (another good article) since you've already sort of implemented it in this plugin. Also look at the Observer Pattern (aka Pub/Sub) it's great for dealing with custom events. This video by Jeffery Way does a great job of explaining the concept. I'd recommend you'd watch the rest of the episodes from that series as well because he does cover some good ground on plugins. 

This code handles a response from an RSS feed. It organizes and appends to content. If there's a video embeded then separate it from the rest of the content. I would like a review mainly on performance/efficiency but I'm open to any other suggestions as well. That star selector is really nagging me but I don't know of a better way to iterate over all the contained elements.