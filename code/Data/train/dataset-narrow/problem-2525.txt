I think it's still quadratic, for arbitrarily large choice of $c$. Let $\epsilon$ be small, and place two line segments $s_1$ and $s_2$ of length $\epsilon^2$, each tangent to the unit sphere at their midpoints, at distance roughly $\epsilon$ apart from each other. Because the line segments are so short, the Voronoi diagram of the two line segments approximates the Voronoi diagram of the two midpoints, which is just a plane $P$ bisecting the sphere. At the center of the sphere, the two equal closest sites are the midpoints of the segments. Now, place equally spaced points on each segment. This will cause the Voronoi diagram of the points of a single segment $s_i$ to consist of two halfplanes separated by many thin slabs bounded by parallel planes, that all pass near the center of the sphere. These slabs intersect $P$ in thin parallel two-dimensional stripes, whose slope can be controlled by the angle at which $s_i$ is placed relative to the sphere. By choosing the angles of $s_1$ and $s_2$ so that they are skew to each other, the stripes for $s_1$ on $P$ can be made to cross the stripes for $s_2$ on $P$, near the center of the sphere. This in turn means that for each pair of a Voronoi region from $s_1$ and a Voronoi region from $s_2$, there is a boundary between the two regions near the center of the sphere. Thus, the Voronoi diagram has quadratic complexity in a region of space (the center of the sphere) that is far from a bounding box of the generating sites. 

If $a=b=0$ and $r=pq$ where $p$ and $q$ are primes congruent to 1 mod 4, then from the $O(1)$ integer points on the circle one could determine the factorization of $r$. So the problem is not going to be easier than factorization. 

Given a graph $G$ and a number $k$, such that you want to know whether $G$ contains a $k$-clique, let n be the number of vertices in $G$. We construct another graph $H$, such that $H$ is $n$-colorable if and only if $G$ has a $k$-clique, as follows: (1) For each vertex $v$ in $G$, make an $n$-clique of vertices $(v,i)$ in $H$, where $i$ ranges from $1$ to $n$. (2) Add one additional vertex $x$ to $H$. (3) For each triple $\{x,y,z\}$ of vertices in $H$, where $y=(v,i)$ and $z=(u,j)$, test whether one of the following conditions holds: either $u\ne v$ and $i=j$, or $u$ and $v$ are nonadjacent vertices in $G$ with $\max(i,j)\le k$. If either of these two things is true, add another $n$-clique to $H$. Within this clique, select three vertices $x'$, $y'$, and $z'$. Connect $x$ to every vertex in the clique except for $y'$ and $z'$; connect $y$ to every vertex in the clique except for $x'$ and $z'$; and connect $z$ to every vertex in the clique except for $x'$ and $y'$. The gadgets added in step (3) prevent the triple of vertices $x$, $y$, and $z$ from all being given the same color as each other in a valid coloring of $H$. The clique in $G$ can be recovered from a coloring of $H$ as the set of vertices $(v,i)$ that are in the same color class as $x$ and that have $i\le k$. 

It's more about mathematical foundations and less about computer science, but the book Homotopy Type Theory: Univalent Foundations of Mathematics is available for free in pdf form under a CC license. 

Why not expand the HMM to a state graph and apply a k-shortest-paths algorithm to the graph? I have a recent survey on k-best enumeration that includes the k-shortest paths problem at $URL$ 

I'm not sure whether you want all paths from s to anywhere (in which case the problem is not research-level and shouldn't have been posted here) or from s to some specific destination t. In the s-t path case, try my paper Finding the k shortest paths. D. Eppstein. SIAM J. Computing 28(2):652-673, 1998. doi:10.1137/S0097539795290477. It's about a slightly different problem (its input is a count of how many paths you want rather than, as in your problem, a threshold on how long they should be) but your version is easier and can be solved in the same way. The paper describes a way of constructing an infinite tree of constant degree, each node of which represents a path, in which the parent of each node is a better path. All you have to do is a recursive traversal of this tree (e.g. depth first search) stopping and backtracking whenever it reaches a path of length greater than N. The total time should be the time for a single pass of Dijkstra plus constant per path. (The paths are represented in an implicit way that allows them to be output in constant time each, or you could expand them and spend time proportional to their length.) I had some implementations linked from my publication page but the links are old and some of them may have gone dead by now. 

This is sort of an unserious answer in that it's not what I consciously do most of the time, but: Think about what the next paper after yours might be — not the next paper that takes some small follow-on problem from your paper and solves that too, but the next paper that takes it to another level, finds tight upper and lower bounds, shows that it's an instance of a more general phenomenon, and generally makes your paper obsolete. Then write about the results in that paper instead of the ones you already have. 

Ok, I've been holding off since really Sariel should get credit for an answer, but I'm tired of waiting, so here is my cut at a near-linear randomized algorithm. 

As I understand it this problem is interesting even for random graphs (in the Erdős–Rényi model in which all graphs are equally likely): we know that the maximum clique size is $(2+o(1))\log_2 n$, but the biggest cliques we can find in polynomial time (e.g. by finding any maximal clique) have size only $(1+o(1))\log_2 n$. See e.g. the introduction of Alon, Krivelevich, and Sudakov, "Finding a large hidden clique in a random graph", SODA 1998, where they credit these observations to a 1976 paper of Karp and conjecture that no polynomial algorithm can do better than $(1+o(1))\log_2 n$. 

In connection with the Slither Link puzzle, I've been wondering: Suppose that I have an $n\times n$ grid of square cells, and I want to find a simple cycle of grid edges, uniformly at random among all possible simple cycles. One way to do this would be to use a Markov chain whose states are sets of squares whose boundaries are simple cycles and whose transitions consist of choosing a random square to flip and keeping the flip when the modified set of squares still has a simple cycle as its boundary. One can get from any simple cycle to any other one in this way (using standard results about existence of shellings) so this eventually converges to a uniform distribution, but how quickly? Alternatively, is there a better Markov chain, or a direct method for selecting simple cycles? ETA: See this blog post for code to calculate the number of cycles I'm looking for, and pointers to OEIS for some of these numbers. As we know, counting is almost the same thing as random generation, and I infer from the lack of any obvious pattern in the factorizations of these numbers and the lack of a formula in the OEIS entry that there unlikely to be a known simple direct method. But that still leaves the questions of how quickly this chain converges and whether there's a better chain wide open. 

Re your reformulation of the question as "More precisely, what I need is some theorem of the form: A graph $G$ has chromatic number $\chi(G)=k+1$ if and only if...": I don't know whether you will think this is adequately explanatory, but it at least fits the syntax you request: an undirected graph $G$ has chromatic number $\chi(G)\ge k$ if and only if, no matter how you orient the edges of $G$, the resulting directed graph will include at least one directed path of length $k-1$. This is the Gallai–Hasse–Roy–Vitaver theorem. 

The first one is average-case analysis, for sets of keys that are already somewhat randomly distributed (chosen either before or after the choice of hash function but with a probability distribution that is independent of the hash function). The second one is worst-case analysis, for sets of keys that are not random but are instead specially chosen to make the algorithm look bad (chosen before the hash function's random seed is known, for a specific 2-independent hash function that is also chosen to make the rest of the algorithm look bad). So it shouldn't be surprising that with two different input models you get two different results. 

Embedding planar graphs (with max degree four) in an adjacency-preserving way onto a grid is NP-complete, meaning that there's unlikely to be simple necessary and sufficient conditions. Actually that's still true even for embedding trees into a grid. See: S. Bhatt and S. Cosmodakis. The complexity of minimizing wire lengths in VLSI layouts. Inform. Proc. Lett. 25:263–267, 1987. 

It is possible to construct 3-regular planar graphs with $\Theta(n)$ biconnected components (see e.g. fig.16 of this paper), each of which must contain at least one sharp vertex. On the other hand, if you require higher levels of connectivity, you can avoid having many sharp vertices. In particular, if you have a 3-connected planar graph, it can be drawn (e.g. by using Steinitz' theorem to find a polyhedral representation and then forming a perspective projection) in such a way that all faces are convex, which causes only the outer face to be sharp. But every 3-connected planar graph can be embedded in such a way that the outer face has at most five vertices (the worst case being a dodecahedron) so you can draw every 3-connected planar graph (3-regular or not) with at most five sharp vertices. 

There is a preprint by Ken-ichi Kawarabayashi, Yusuke Kobayashi, and Bruce Reed that claims a quadratic time algorithm: "The disjoint paths problem in quadratic time". It is formatted as a conference submission rather than a journal paper so I'm not sure it's possible to verify the details, though (I haven't really tried, myself). A very recent survey by Kawarabayashi cites this as the best known result for the closely related disjoint paths problem: Ken-ichi Kawarabayashi (2011), "The Disjoint Paths Problem: Algorithm and Structure", WALCOM: Algorithms and Computation, LNCS 6552, pp. 2–7, doi:10.1007/978-3-642-19094-0_2. I don't know whether this means that the $O(n\log n)$ claim in Kothari's comment is vapor or whether it means that it's still at an earlier stage of being written up. 

This is really less about graph per se and more about topology. A combinatorial embedding defines a 2-manifold, a topological space in which every point has a neighborhood homeomorphic to a 2-dimensional open disk: the embedding allows a face to be defined, and we can define a topological space by choosing a disk for each face and gluing them together along the graph edges. A well known theorem in topology (called the classification of 2-manifolds) tells us exactly which 2-manifolds are possible, and they are all distinguishable from each other either by whether they are orientable or whether they have the same Euler characteristic (or both) — see $URL$ for some reasonable lecture notes on this subject, that include the proof you're asking for. There are no other 2-manifolds in this classification that have the same Euler characteristic as the sphere, so if you calculate the Euler characteristic and find that it matches the formula for a sphere, you know your embedding must be onto a sphere. Finding an embedding with actual geometric coordinates in the plane, once you have a planar combinatorial embedding, is not entirely trivial but can be done e.g. using the theory of Schnyder woods. I have some lecture notes on this at $URL$ for instance.