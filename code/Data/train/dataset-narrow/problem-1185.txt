Terminating and joining is not the same thing. Check out your task-manager, you should see the processes staying as "zombies". The call terminate() force the exit of the process and join() does something I don't pretend to understand, but I know that if you don't call join on terminated processes, you will get zombies. 

what happens here is that the two files are open at the same time, and since wrong is a generator, it will read one line, in this case word, at the time. If the currently written word is in english it yield it and write it to the file. Pythons enumerate builtins purpose is for these kinda situations, where you want to iterate over something while still keeping track of the rounds. 

You'll have to multiply each of the factors returned with the factors of two that the original number contained. But you remove the need to check even numbers, ending up with only the faster of the two ways your code can go. 

In python, the ";" that you use in the end of some of your rows does nothing, python instead uses line breaks and indentation. You use very many variables, and you probably don't have to, and it seems that you are repeating yourself. If you want to do it that way, there are a better way. Function naming conventions in python is not camelCase, but instead function_name, camel case is reserved for classes. variable naming conventions in python is always lower case, and not B1, that looks to me as a poorly named class and not a button. You should write you variables after your functions, and not into right after your imports. When you top-down a piece of code, you make it dense, and hard to manipulate and read, break it up into functions. 

The main function relies on the fact that if the condition are meet, all following conditions in the current substring are meet and we and we can simply add those. This means that the only check done is the check where the is of equal length + 1. 

Well this was a very satisfying problem, thanks for sharing! First of all, calling external resources is expensive, there for not optimized, which you ask for. Else wise, calling external resources can be preferable if the external resource is something like shell on a platform you have control over. That's the reasons I removed them and substituted them with python built-ins. It's pretty much the only reason this code is slightly faster then yours. I found one small error in your code. What if a file you try to hash has spaces? The problem occurs when you split the return from md5_checksum, it splits to as many values as there are white spaces. The most time consuming function of both our code is walk. It's easy to check these where cpu-time went with profilers. And python has a builtin I like, but there are many. It's the cProfiler, check my code for usage. The biggest change was refactoring the function are_identical for 

They do the same thing, but the any() builtin, is.. as well faster, then iterating over lists. I did remove your function comments, as they can be substituted for good function names and annotations. Do you agree? 

To me it seems like the repetitiveness in your code is the worst problem, you should not repeat yourself and you never have to repeat yourself, and if you are repenting yourself, you are doing it wrong. You could do something in line with this: 

What would be the coolest solution? It would be to have a class inherent ThreadPoolExecutor and override the specific part of the class that executes the the threads inherent to ThreadPoolExecutor whit what you want to do. 

I notice something small, well you know the corner cases. You know that a DNA string will yield a score of that is the same as length. Obviously ^^. So don't check those cases. You make 4 iterations in your code. While only one is interesting. A big improvement in runtime could be to change: 

Valid. But your code is messy. You are taking one step away from the original traditional problem, and that actually becomes a problem form your code. Your actually better off with the one dimensional arrays then the two dimensional tuples. Tuples may be the wrong data type to use for your problem to resolve itself nicely. 

You should refrain from using many variable names, but I like that you used the correct convention.. If you have a lot of data, you should make use of a data structure. If your not going to use the naming conventions, stick with what whatever convention you choose, it's a lesser evil. You should use the conventions, imagine this was maths, and you substituted + for - changing the convention. Seems like a bad idea if this is homework. 

without the much expressive comment is that you wast a lot of space and make your code more hard to read. Of curse you should comment your code, but you don't have to comment on what the names of the function, secretWord, lettersGussed already states. But we don't know what type the parameters is from the names, but annotations can do that. Comments should contain information on not told by the naming or annotation. Don't repeat yourself applies to comments as well. 

Seems like you have background in some other language, your use of global is very weird. It's a unnecessary bad hack. 

The code has two generators, one to truncate the number from the left, or moving the X coordinate of the cruel pair. Another generator to move the Y coordinate. The generator that moves the Y coordinate starts at the same length as the query string is. If the query string is longer it yields 0. 

Dict and sets has there differences, one being that membership testing is faster with sets, they also consume less memory, which will be important for the efficiency of your program. So a pythonic way of defining "english" would be something inline with: 

is also unnecessary because, None is always return from a python function that does not return anything. 

The manager might be unnecessary, you are only ever transferring one value. What you are looking for might be a Queue. 

The and of python evaluates to and respectively. In python if you multiply a str with a number, you'll get that many str, so would be, "fizzfizz". would yield . 

Python provides an argument here: . or is mainly used in if statements but could also be used in line: 

In the problem you've provided each induvidual pairs order does not seem to matter, so load them as such. If you do that, you don't have to sort the in the calculation function. If you don't, you'll resort them later. Again and again. Them more samples you use, there more time is spent doing this. Times: 

Lurking today. I just post this for your pleasure. It might give you some ideas about condensing your code. 

Whenever you are dealing with user input which needs have to follow certain rules, it will always makes sense to separate it from other parts of the code like putting it in a function. So by my interpretation of your code in which I started with your code, with out being as nice as you are, would be this. 

Now that you have a set that you could use for membership testing, I think it's remove the function spell check, since it adds a line of code and somewhat obscures the program. If it did something more then checked for membership, sure, bur right now, no. In that case, you could remove the third for loop and create a generator to let the program deal with only one word at the time and further reduce memory usage. 

Since I misunderstood the question. I offer up a second take. I have not convinced myself that log10 will increase the efficacy of the script but I use it anyway to show the concept of using math instead of len on strings.