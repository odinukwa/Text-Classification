Currently your function crashed when presented with cyclic links. Back to your code. Now lets inprove your code. The code is too complex and very hard to read. 

The is redundant does the same with less complexity. see note (*1) Functional similarities You have four almost identical functions that contain the following 

Code review Not bad, code is nice and clean, and naming is good. Game play has some logic flaws in the way you handle the keyboard and collisions. Some code style points. 

try to define your event handlers as named functions because you need a function referance to remove the event if you need to. 

Do like JavaScript does Look at the previous section, when JavaScript parses the string value "10.0.0" it does not but rather it returns You are throwing where the better option is . A malformed equation results in a value that is not a number, not a variety of errors that would need to be trapped. Personally I would remove all the error checking and let JavaScript throw if it needed (Dont think it would in this case), for the most part it would return on its own. And Please... ...add the semicolons ';' and reduce the risk of bugs. 

See code for more details. You put it in code of course with instructions as indexes into various arrays. THe best way to explain is in code so take a look at the source of the demo. The flow function walks the leds following the instruction in flows.map1 (map1 - map4) You can add other maps but you must make sure that you do not create an endless path. Or you can add an additional check for each step. If the current then you must be repeating so break and exit. It should not happen so I did not include it, but you may make an error entering data and the page will be blocked. Demo draws grid waits a second then draw flow. Waits 4 seconds and repeats using the next flow directions. Circle marks start of flow and cross the end. 

Danger code! Did you do a good job? Well I could not give your function a pass. Your solution works, but I would never use it in any environment apart from the testing environment. The reason is your use of the global scope. Global scope for the browser is . It is also referenced via outside functions, and inside functions it is also referenced by if the function is not bound to another . To put it another way your code is the same as 

No that is not an example of polymorphism as each instance is the same object. Just giving them different names does not change the type. Update. I overlooked the assignment of a new function to the object named . That also does not constitute an example of polymorphism. Super Polymorphism * (*) (not a real term in CS as far as I know) There are a wide variety of ways to define objects and functions for the objects. It is not the object type that determines the behaviour provided by shared functions (more apt than calling them polymorphic) The requirement be only that they provide the correct set of properties and behaviours for shared functions to operate on. In a sense the ultimate form of polymorphism, truly independent of type and thoroughly unsafe as is any super power if you don't learn to use it with care. Examples of polymorphic like JS. Personally I don't like to use the term polymorphic in JS as JS does not really define an interface, however as shown below you could consider polymorphic like behaviours 

General style issues. These are not must do rules, they are just guidelines to think about as you code. 

This is when you hit peek memory use, just before the above return you add another array so you have stored in memory 18 references 

Case 2 For case 2. Do what you want its safe, but be sure you dont forget about it and use it on a public page. In other words do the first case setup to be safe. 

Side step merge. I you inspect the running of the code and the array sizes that merges you will notice that 50% of the merges are of two arrays each of length 1. In effect you are using the complicated merge function to sort two numbers. You can side step the merge function for array sizes 1 with the following The recursive modification 

It has meaning but the functions that rely on being the correct type () will fail. In JS the mutated box is still an and to be safe you would have to vet each property in turn. Not at all a practical form of polymorphism. 

Suggestions only. Adding a settings argument would allow for better control of the behaviour when things get a little ambiguous. 

You are querying the DOM for a variety of elements. The DOM is a separate document and likely to be in many forms. The potential for an element to be missing is high. Your app as a whole will fail if any element is missing. The UI parts of the app are an integral part of the code. The better option is to create the UI components in the code. Use the DOM to provide container elements and add the UI to these elements. 

The need to test. At this point I am 60% happy but by just looking at the code you can not tell how reliable it is. You need to test the function over a large set of values. I have created two test. Testing the random number generator. This is a simple test, and rather than test it for standard deviation I do a visual test by graphing the distribution of the random numbers generated. I compare them to the inbuilt random function. It can give a good indication of the randomness. Why? because it's more fun... 

Object properties. When you are creating objects with dynamic properties you can assign properties directly to the object using This has some performance benefits as well. The following is an example of an instanceable account state machine using object assign to assign the the state. 

Assuming you wrote to spec. I said above that your code was good not great. Lets assume you wrote the function to a specification that required the arguments and flexibility. What could be done to improve the function. Minor issues. The vars and should have been created outside the loop at the top of the code, or where they are as block scoped variables using . Performance is king In my book (and not everyones) if all things are equal then performance is the indicator of the best solution. The major problem in the code are the lines