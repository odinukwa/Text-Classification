Here is another example from this paper THE COMPUTATIONAL COMPLEXITY OF RECOGNIZING CRITICAL SETS: Unique edge-partitioning into triangles is $NP$-complete Input: Tripartite graph $G$ and an edge partition into triangles Question: Is there another edge-partition different from the given one? The paper also proves that $NP$-completeness of this problem Input: Partial Latin square $P$ with a given a Latin square completing $P$ Question: Is there another completion to a Latin square? 

FNP-Complete problem is the search version of an NP-complete decision problem "Is there a Hamiltonian graph in the input graph". The search version which is FNP-complete asks for an algorithm that produces the edges of a Hamiltonian cycle or report there is none. As far as verifying the correctness of the decision problem, you can use it as oracle to find the Hamiltonian cycle and then verify that the cycle is Hamiltonian. 

This survey, The structure and function of complex networks by Newman, reviews techniques and models for real complex networks including concepts such as small-world effect, degree distributions, and random graph models. Also, the same author has a nice paper, Random graphs as models of networks, about adaptations of random graphs to model real networks. References: 1) Random graphs as models of networks, M. E. J. Newman, in Handbook of Graphs and Networks, S. Bornholdt and H. G. Schuster (eds.), Wiley-VCH, Berlin (2003) 2) The structure and function of complex networks, M. E. J. Newman, SIAM Review 45, 167-256 (2003) 

[1] Berstel, J.; Boasson, L. Towards an algebraic theory of context-free languages. Fund. Inform. 25 (1996), no. 3-4, 217--239. [2] Wechler, Wolfgang. Characterization of rational and algebraic power series. RAIRO Inform. Théor. 17 (1983), no. 1, 3-11. 

The terminology rigid seems to be relatively new compared to the term disjunctive used in the late 70's (and probably before, I didn't check for earlier references). A subset $P$ of a monoid $M$ is disjunctive if and only if the syntactic congruence of $P$ in $M$ is the equality relation. Thus a monoid is the syntactic monoid of a language if and only if it contains a disjunctive subset. With this characterisation in hand, it is easy to find finite monoids that are not syntactic monoid of any language: take the monoid $\{1, a, b, c\}$ in which $1$ is the identity and the rest of the multiplication is defined by $xy = y$ for all $x, y \in \{a,b,c\}$. This result is folklore (< 1980). 

One needs of course to specify the signature. There is usually a predicate $\mathbf{a}$ for each letter (and $\mathbf{a}x$ means there is a letter $a$ in position $x$ in the word). Then one can add a binary symbol $<$ (the corresponding hierarchy is the Straubing-Thérien hierarchy) and also a successor symbol (the corresponding hierarchy is the dot-depth hierarchy). Other possibilities include a $Mod$ predicate, to count modulo $n$, etc. See again this paper for an overview. 

Another example is the efficient dominating set problem also known as 1-perfect code in graphs. The problem is to determine the existence of a dominating set $C$ in undirected graph such that the shortest path between any two nodes in the dominating set $C$ is at least 3 (edges). The problem was proven to be $NP$-complete independently by many researchers. The problem remains $NP$-complete even for cubic planar graphs. D. W. Bange, A. E. Barkauskas, and P. J. Slater. Efficient dominating sets in graphs. Applications of discrete mathematics, Proc. 3rd SIAM Conf., Clemson/South Carolina 1986, 189-199 (1988)., 1988. 

The algorithm of Boyer and Myrvold is considered among the state of art of planarity testing algorithms On the Cutting Edge: Simplified O(n) Planarity by Edge Addition by Boyer and Myrvold. This book chapter surveys many planarity testing algorithms and hopefully you find simple enough algorithm. 

I am interested in pseudo-polynomial time algorithms or proving the problem to be strongly NP-hard. P.S. Here is an example (as requested by @domotorp) $p1=\{2,2,3,4,5, 6\}$ and $p2= \{1, 1,3, 4, 5, 8\}$. The second solution is $p1=\{1,2,3,4,4, 8\}$ and $p2= \{ 1,2,3,5,5,6\}$ (the second solution is not optimal as p1 and p2 have equal number of elements). 

Miller showed that isomorphism testing of projective planes can be done in $v^{O(\log \log v)}$. I would like to know whether Babai's techniques that led to the quasipolynomial time algorithm for GI would colapse isomorphism testing for projective planes to polynomial time. 

I think the answer to your question can be found in Theorem 3.1 of [1], where it is credited to Wechler [2]. An algebra is stable if it is closed under left quotient. 

[1] W. Bucher, A. Ehrenfeucht and D. Haussler, On total regulators generated by derivation relations, Theor. Comput. Sci. 40, 2-3 (1985), 131– 148. 

is undecidable. However, it becomes decidable on a unary alphabet, simply because in this case, the classes of context-free and regular languages coincide. My question is to know what happens for unary context-sensitive languages. 

In addition to the references given by Michaël Cadilhac, let me add this paper Berstel, J.; Boasson, L. Towards an algebraic theory of context-free languages. Fund. Inform. 25 (1996), no. 3-4, 217--239. 

There is a polynomial algorithm to answer this question. Indeed a language is commutative if and only if its syntactic monoid is commutative. But the syntactic monoid $M(L)$ of $L$ is equal to the transition monoid of its minimal automaton. It follows that, $L$ is commutative if and only if the generators of $M(L)$ commute. In terms of automata, this is equivalent to check, for every pair of letters $(a, b)$, whether $q \cdot ab = q \cdot ba$ for all $q \in Q$. Now, given $\mathcal{A}$, you can compute the minimal automaton of $L$ in $O(|Q|\log |Q|)$ and then check commutativity in $O(|Q||A|^2)$. 

If you're interested in set families with $n = \omega(2^{d/2})$, then an another solution conceptually very similar to the one outlined in Yuval's answer is to compute zeta transform $$f\zeta(T) = \sum_{S \subseteq T} f(S)\,,$$ where $f \colon 2^{[d]} \to \mathbb{R}$ is the indicator function of the input family $\mathcal{F} = \{ S_1, S_2, \dotsc, S_n \}$. That is, $f(S) = 1$ if $S \in \mathcal{F}$ and $f(S) = 0$ otherwise. Clearly there are sets $S_i \not= S_j$ such that $S_i \subseteq S_j$ if and only if $f\zeta(S) > 1$ for some $S \in \mathcal{F}$. The zeta transform can be computed in time $O(d2^d)$ using Yates's algorithm, see for example Knuth's TAOCP, vol. 2, §4.6.4. The algorithm itself is a fairly straightforward dynamic programming, and it is easy to modify it to give an example of an included set if one exists. 

Let $[n] = \{ 1, 2, \dotsc, n \}$, and let $\mathcal{F} = \{S_1, S_2, \dotsc, S_m \} \subseteq 2^{[n]}$ be the input set family. Unless I misunderstood your problem formulation, we want to find a minimum-size set $T \subseteq [n]$ such that $T \not\subseteq S_i$ for all $i = 1, 2, \dotsc, m$. To answer your question, note that $T \not\subseteq S_i$ if and only if $T \cap ([n] \setminus S_i) \not= \emptyset$. That is, $T$ has to intersect the complement of each $S_i$. But this means that your problem is, essentially, equivalent to the hitting set problem (consider hitting set with input $\mathcal{G} = \{ [n] \setminus S_i \ \colon \ i = 1, 2, \dotsc, m \}$): 

Automata are not really needed to prove this result. Let $K$ be a regular language and let $R = \{w \in A^* \mid h^{-1}h(w) \subset K \}$. Then the complement of $R$ is $$R^c = \{w \in A^* \mid h^{-1}h(w) \cap K^c \not= \emptyset \} = h^{-1}h(K^c).$$ Since regular languages are closed under homomorphisms, inverse of homomorphisms and complementation, $R$ is regular. Now if $L$ is another regular language, the set $\{w \in L \mid h^{-1}h(w) \subset K \}$ is equal to $L \cap R$, which is regular as well. 

Question 1. Yes, there are other ways than using automata. Typically, if you already now that your language is recognized by some surjective monoid morphism $\varphi: A^* \to M$, then you know that $M(L)$ (the syntactic monoid of $L$) is a quotient of $M$. For instance if $L = \{ u \in \{a,b\}^* \mid |u|_a \equiv 5 \bmod 13 \text{ and } |u|_a \equiv 6 \bmod 7\}$, then you can prove directly that $M(L) = \mathbb{Z}/91\mathbb{Z}$ without computing the minimal automaton. Question 2. C. Brand is right. You can still use the minimal automaton, even if it is infinite. You can also just use the definition of the syntactic congruence to get a presentation of the syntactic monoid. You may also just guess a morphism recognizing your language. Three examples: (1) Let $L = \{u \in \{a,b\}^* \mid |u|_a = |u|_b \}$. Then the morphism $\pi: \{a,b\}^* \to \mathbb{Z}$ defined by $\pi(a) = 1$ and $\pi(b) = -1$ recognizes $L$ since $L = \pi^{-1}(0)$. Thus $M(L)$ is a quotient of $\mathbb{Z}$. But every nontrivial quotient of $\mathbb{Z}$ is finite and cannot be equal to $M(L)$ (otherwise $L$ would be regular). Thus $M(L) = \mathbb{Z}$. (2) Let $L = \{u \in \{a,b\}^* \mid |u|_a \geqslant |u|_b \}$. This context-free language generated by the grammar $S \to SS + aSb + 1$. Its syntactic monoid is also equal to $\mathbb{Z}$, since $L = \pi^{-1}([0, + \infty[)$. Update following Stefan's comment (3) Let $D$ be the Dyck language (see Stefan's comment). Its syntactic monoid is the bicyclic monoid, which is the monoid presented by $<a,b \mid ab = 1>$. (4) Let $L = \{a^nb^n \mid n \geqslant 0 \}$. Its syntactic monoid is the monoid with zero presented by $<a,b \mid ba = 0>$. 

My question is, does this latter claim actually hold and if it does, is there a write-up of the proof somewhere? As a background, I've been trying to understand the area around the Exponential Time Hypothesis. IPZ define subexponential problems as ones that have $O(2^{\varepsilon n})$ algorithm for each $\varepsilon > 0$, but this apparently is not sufficient in the light of the current knowledge to imply the existence of a subexponential algorithm for the problem. The same gap seems to be present in the SERF reducibility, but I am partially expecting that I am missing something here... 

This manuscript seems to prove exactly that. (It doesn't; the complexity parameter is $|T|$, not the treewidth.) In general, most NP-hard optimisation problems have polynomial-time algorithms when the input is restricted to bounded-treewidth graphs. These algorithms use the rather well-known tree-decomposition machinery, which is also used in the linked paper. EDIT: The undirected Steiner tree is, on the other hand, known to be fixed-parameter tractable with regards to parameter $w$ the treewidth of the underlying graph. My suggestion would be to try and adapt this algorithm to the directed case, which would in particular give a polynomial time algorithm for series-parallel graphs. 

The maximum independent set problem is a packing problem (you can think it as packing disjoint stars), and it has a well-known algorithm with running time $2^k \operatorname{poly(n)}$ in graphs with treewidth at most $k$.