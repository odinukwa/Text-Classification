If anyone thinks this is snarky or intended to be humorous, I'd suggest you reconsider. At many points in my life I specifically chose the harder path and have never regretted it. At other times I just went along with the flow and was sorry. But choosing according to my goals turned out to be pretty optimal. 

tl;dr Make the mapping between the software and the hardware explicit at the start and then show the code, rather than the other way round. Draw pictures. Give them a mental overall image, not just detail. Detail with no context is hard to follow, and hard to learn. In many ways this question is like another here in that you have a complex system that must be taught all at once. See the answers to that one, including mine. A useful strategy for this would be to turn it around a bit and start out by saying that the code they are about to see is a model of the physical device. The parts of the model match the parts of the device. The robot has two arms and so its model has two "Arm objects". Objects in the model need a description and the description (in Java) is provided by a class: . The physical robot's parts have functionality of various kinds and these are modeled in the class with methods: , etc. Once we have the class (at least in skeleton form) we can instantiate it: . The Robot class itself is built by composition (arm fields: ... So what you do is make a mapping between the code and the physical thing and point out that (as I assume is true of the code) the mapping is pretty direct. This is actually pretty faithful to the idea of OOP, in fact. Modeling is a good first metaphor for OO programming. At this point you can show them some code, but I'd show it heavily ellipsed, with only the detail needed shown in full. In other words, only show some of the methods and maybe only parts of some methods. So the code you show above in your Question doesn't come first, but only now after they have seen the map, even if the map is incomplete. The class is an abstract description of the physical thing and the code completes the description. When you show methods, don't make them naked (as if this were just C coding), but show them as part of their class. I've assumed that the robot itself is an actual object in your framework. It is possible that it isn't, if there is only one. The robot "object" may be implicit. Or possibly your code (above) is really part of a method of the Robot class so you wrote leftArm... rather than this.leftArm... Note that if the "Robot" were not a physical device, but a screen simulation instead, the same ideas as above work well. Another way to put all of this is that you do the integration step for them and present that, rather than depending on each student to integrate the detail into a consistent whole and all in the same way. So, you introduce three big ideas (Class, object, method) and show how they relate to each other and to the physical thing. There are a few smaller ideas also (instantiate, part-whole composition), of course that you incorporate into your lecture. It should only take 15-20 minutes to do this at a high level. 

Here are a few more "interesting" functions that may go beyond what you need, but have interesting things to teach you. Once you understand what f(x) = 1/x does, you can combine it with other functions to get other sorts of asymptotes. For example g(x) = x + 1/x has is asymptotic to the function h(x) = x. In that form it is pretty obvious what it does, but less so if you express it as g(x) = $(x^2 + 1)/x$. Other combinations are possible. If you look at k(x) = $(1/x)*sin(x)$ you get a function that oscillates but is also asymptotic to zero at infinity. One of my favorite functions is m(x) = $(1/x)*sin(1/x)$. As x approaches infinity, this is asymptotic to zero also, but it is much more interesting as x approaches zero. It has the property that it takes on every real value infinitely many times in every neighborhood of zero. The 1/x factor gives it increasing amplitude near zero and the argument to sin makes it oscillate faster and faster. This is a very strange property for a real valued function, but if the student will eventually study Complex Analysis it is an exceedingly important example. I'll leave that explanation for the next course. 

Only concepts can be abstract. Abstraction is about ideas. Animal is a concept. Mammal is a concept. Animal is more abstract than Mammal since it contains the idea of Mammal, but isn't restricted to it. The kitty sitting on my hearth is concrete, not less abstract than Mammal. The kitty isn't a concept it is a thing. Given some ot the examples, there is a misconception about what is abstract and what is concrete. Physical things are not abstract. One can't be more abstract than another. Even things that aren't physical, but which can be manipulated, are concrete, not abstract. A LinkedList (Java) isn't abstract. It is concrete. List, on the other hand (an interface) is abstract. In computing there are many, many different kinds of abstraction. Even the concept of a while loop is an abstraction. In OOP languages classes implement abstractions. Interfaces (even if the language doesn't have that explicit feature) are abstractions. So, Python has interfaces, though it has no language feature with that name. If two classes have the same interface they are realizations of the abstraction, but neither is more or less abstract than the other. If one interface contains another interface then it is more abstract.But we also have data abstraction. Lists and Maps define an interface (an abstraction). They can be implemented/realized many ways. Each realization is concrete, not less abstract. The web site cited seems to be trying to test everything with Multiple Choice Questions (MCQ). I question both the possibility of that and the wisdom of it. Some thing are complex MCQ are simple. Trying to push the assessment of complex things through such a small funnel seems misplaced to me - even foolish. I'm pretty sure that MCQ also advantage certain students and disadvantage others. They are fine for rote memory and facts, but pretty poor for deep understanding. I have nothing against their use unless it is overdone. MCQ are also difficult to validate. The wisdom of groups isn't enough. It takes statistical measurement and cross validation to do a good job of it. The Font Construction example given in the question also seem to be testing specific vocabulary. This example threw me completely. I think I could eliminate one answer, but also think I could justify each of the others if given the chance. If it is specific vocabulary it is just rote memory and hoping that the student "remembered" to remember the right thing. Often, getting a MCQ wrong and then later learning the correct answer can sometimes leave students simply puzzled and frustrated. This results in a destructive game that I'd rather not play. MCQ try to put a lot of thinking into the questions so that no one needs to put any thinking into the answers after the student finishes. This may scale well, but is a sub-optimal form of education. After all, it is the students thoughts that we want to get a handle on in assessment. 

Note that I've used this successfully. Pairing, test-first, product backlogs, and small teams is a synergistic whole. But they need supervised practice or they won't see its benefit nor give it a fair trial. They also need a place and time to work together that won't disrupt their otherwise busy schedules. Finally, make process feedback an important part of the project. You can ask for this to be given live or in writing. I found it useful to provide an anonymous feedback channel so that I could learn things that students wouldn't otherwise say.