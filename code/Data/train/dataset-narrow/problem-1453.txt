is not valid C++. In fact, when first reading your code, I was really taken aback because I thought that this shouldn't ever compile. However, it turns out (after researching) that this is actually a MSVC extension, albeit a really useless and horrible one, in my opinion. Please, please, please use the standard syntax, lest you want a mob of C++ programmers with pitchforks and and burning torches show up at your door. Don't use . It's bad, because a) does the job just fine, and b) actually also calls on your output stream, which is something you very rarely want. Just stick with and call directly when you mean to. Order your includes. Why? Because ordering includes makes it easier to verify whether all necessary includes are actually there, in two different ways: One, it makes it easier to manually verify that all necessary headers are there and two, the compiler will complain if you are missing an include in a header file if that header file is included before its missing header is included (For example, imagine depends on including . However, the author of forgot the include, and now you're using the header in your project file , which also requires . If you first include and then , your compiler will complain that it can't resolve in . If you include first, however, this error does not surface because now the include is there. This is known as include shadowing.) So how should you be ordering those includes? First of all, nearly all people agree on alphabetic ordering. Secondly, it makes sense to group headers into categories such as "files from the current project", "library headers", "STL headers" etc. If you do this, it is recommended to write, from top to bottom, first the header the current file is implementing (if any), then headers from the current project (i.e. local/internal headers), then headers from different projects and libraries (i.e. external headers) and finally standard headers. This is most likely to prevent include shadowing bugs due to each header being checked in its implementation file (given that such a file exists). Always use over ; the existence of in the global namespace is not guaranteed by the standard, but in the namespace it is. Avoid including everywhere. The reason for this is that usually injects static instances for , and which can lead to binary bloat. More importantly, however, is a code smell, because using and family is constraining your users and yourself. Imagine, for example, a bot, which wants to run some 1000 or 10000 games of Keno and log the results to a file, or a websocket, or any other I/O device. Currently, the only way for that bot to achieve this is by redirecting standard output, but that might not always be possible. Also, what if the bot actually only wants to log the output of to its destination, but doesn't care for the rest you write? Currently, it would need to parse the standard output for that, which, again, might be constraining or unfeasible. But if is bad, how do you implement output functions? The answer is by refactoring your output functions to take an as parameter and write to that instead. Syntax-wise, there is no change at all; the offered degree of flexibility, however, is much, much higher. (Don't forget to change to , though). has two issues: 

The last trick I can think of would be to convert these conditionals into instances, and pass them to the LINQ chain. I haven't got a C# IDE on this computer, so this code could be syntactically incorrect, but you get the idea: 

You have not implemented exception handling (the last requirement). Eg. if calling code passes to or , it won't crash straight away, but as soon as you call , it will result in an unhandled once it gets to this null "fruit". Also note that we don't know what calling code may pass in as an argument - could be some object that implements one of the interfaces, but actually explodes once our code calls its or ... The requirement states that it's the responsibility of this code to handle exceptions, so if this was my homework, I'd prefer to be on the safe side here. Less importantly, you implemented as a property of rather than a field (which is what the description asks for), although public fields actually are considered a bit of a code smell, and a backing field is automatically created for properties, so I would leave it. Aiming at good code style you could make it immutable though (as a field, or a property with a private setter), and set it in the constructor - it stands to reason that name of a given fruit isn't subject to change. and could be too, but that's nitpicking already. Apart from the lack of exception handling, it seems okay to me. I like that you used some modern C# features to cut down on verbosity. 

I tried to follow most hints and suggestions I received for my previous question about bubble sort. I am aware of the fact that the algorithm can also be implemented in a way that only requires forward iterators, but I decided to require bidirectional iterators here for ease of implementation. Again, I also provide you a file for simple compilation and testing purposes: 

Do not try to do too much on one line. Constructs such as are difficult to read, difficult to parse and prone to errors. Instead, let each control statement have its own block, and do not abuse the comma operator to do completely unrelated things. For example, the line I mentioned should rather be something like 

This is a follow-up question to Sorting algorithms - Bubble sort Again, for practice purposes only, I took on an implementation of the well known insertion sort as a method to be used similarly to . As expected, the code lives inside a header file called insertion_sort.h: 

I'm not familiar with image processing at all, so I cannot give you any advice about your algorithm implementation. However, there are quite a few things I'd like to say about good practices and code style in general: 

Although this code should be reasonably efficient for relatively small numbers, there are faster algorithms to solve this problem. However, most of these are not as easy to implement, and if you are not planning on doing this for very large integers, then you should be fine with the changes I suggested. If you are still interested in improving effiency, I point you to the Wikipedia article about the prime-counting function for a start. 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

Notice that, instead of passing separately, now points to the beginning of the next word. Don't Cast It is unnecessary and even discouraged because it clutters your code with casts and adds no further information. Omit The standard specifies that is always 1. Although some people advocate for it because it adds some information to your code, the knowledge that the size of is one is so widespread that I wouldn't recommend writing it. Memory Leaks In , you are getting new words by using repeatedly in a -loop whilst not freeing the current word after each iteration, instead only freeing the very last word at the end of the program. You should add a at the end of said loop. Iterating Over A String Writing 

should be the first modifier in most cases. Things like are bad because most people are used to thinking of it as an which is also , in contrast to a which is also (i.e. the first level of categorization is usually , then ). Leave a space between and the corresponding angle brackets/quotation marks. The fact that has a "meanings" comment hints you at the fact that you should probably choose better names for your variables. Usually, typing a few more characters is not going to hurt your coding performance very much (especially not in times of auto completion!) and will make you code much more readable. As a reviewer, I do not want to switch back to to look up the meaning of a variable every time I encounter one. should probably take its parameter by reference, because you are not actually doing any modifications to the object. You should rethink your approach on ownership. Currently, does not own its children, which means that they have to be owned by something else. That means that your whole design structure is not self-sufficient; you always need some kind of class that maintains a vector of all current , to which each of your s only holds a reference. You also need to make sure that none of the objects expire before your , or else you will run into undefined behavior. Also, if any of your are moved, you will need to update their reference accordingly in their , which is cumbersome at best and invokes undefined behavior at worst if you make a mistake. Thus, I suggest you to change the relationship into an owning one, and possible give out references or pointers to other users (also, you still need to face the issue of relocation and thus invalidation, which is why you will probably need another layer of indirection (i.e. a vector of )) If you want to begin your class definitions with the public members, I would recommend you to use instead, since all members of are implicitly public unless marked otherwise (still, this is very much a question of personal style) Use the correct integer types. For example, it appears that can never be lower than 0, so it should at the very least be . However, for variables denoting a length, is generally more appropriate (especially since you assign it the length of a string, which is also of type ). 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

Apart from using upper case for method names (as pointed out by @paritosh), I think it's a reasonable convention to use prefix for methods returning a boolean representing some state that may or may not be. Case in point: $URL$ Note this is a property, meaning you could indeed replace with a read-only property. Not that there's anything bad with leaving it like it is - properties are just more idiomatic in C#. Using a property kind of puts more emphasis on the fact that we're only checking on some state, and there's no side effects to that. (You can still implement a property in such a way that it causes side effects, it's just blatantly against the semantics of it). Last but not least, variables should be named with lower case in C#: 

Code style Magic numbers In "DatabaseManager", I would convert "magic numbers" (connection life time being 5 minutes, command timeout set to 120 etc.) into constants. Fluff / noise 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

They are inherently unsafe. You have no guarantee that the pointer you receive is a pointer to a valid, zero-terminated string and not to anything else, like an array of binary data, or nowhere at all. C-Strings are dumb. They don't contain length data, nor anything else besides the address of their contents. Usually, you are wasting performance here by having to call on a string whose length is theoretically known at compile time. 

This helps eliminate redundant layers of indentation and makes the code more readable. Since you don't write anything to the argument string, you should use to iterate it (in addition to making the parameter , see point 1). Please, don't use . It's horrible. Why? Because it does not do what its name advises and is pretty much redundant. does write an end-of-line character, but it also flushes the underlying buffer, which is seldom what you want (and if you really need that functionality, you should use ). 

would make more sense as a than as a : You have no member functions whatsoever and all data members are public. Since this is usually what is expected of a , you should match those expectations. is not the right type for everything. Especially for things like indices and sizes, other (unsigned) integer types are more appropriate. Why? Because can be pretty limited in size. For example, on my machine an is a 32-bit signed integer, but, since it actually is a 64-bit architecture, I could possibly have a memory address outside the range, which would likely lead to overflow (which is UB!) and the last few elements of the list being inaccessible. Instead, suggests itself here; it is a type made to represent sizes (just as the name suggests). Think about what a parameter means and how it will be used when you define its type. Don't use . You gain almost nothing except an additional chance to break your code in subtle ways by introducing all the names from into the global namespace where they may clash with your own names. If you use C++11 or beyond, don't use , use as it offers improved type safety. Separate responsibilities. In particular, don't have any method from do any IO. Write helper methods/classes to do this (this is known as the Single Responsibility Principle and is one of the most important principles of Object Oriented Programming). Give names to the parameters in your functions declarations. Parameters without names often imply that the parameter is ignored, and names offer you another place for documentation. Don't use . It doesn't serve any purpose, except confusing you about what it does, which is printing a newline character but also flushing the output buffer which is almost never what you want. Use instead. Write out (or ) when you mean it. Please don't write 

doesn't make sense to me. When your code is conditional, DRY (Don't Repeat Yourself) and try to extract whatever is common for all execution paths. Eg. 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class?