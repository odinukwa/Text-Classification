Additional Desired Output Given the example above, the following output would be desired (updated with French example): 

So here's my scenario: I'm working on Localization for a project of mine, and typically I would go about doing this in the C# code, however I want to do this in SQL a bit more since I am trying to buff up my SQL a bit. Environment: SQL Server 2014 Standard, C# (.NET 4.5.1) Note: the programming language itself should be irrelevant, I'm only including it for completeness. So I sort-of accomplished what I wanted, but not to the extent I wanted. It's been a while (at least a year) since I have done any SQL s except basic ones, and this is quite a complex . Here is a diagramme of the relevant tables of the database. (There are plenty more, but not necessary for this portion.) 

Since duration is reported in miliseconds I'm reading this as it taking 69.54 minutes to grow the file. Autogrowth for this log file is set to 512MB (limited to 2TB) 

Backup the registry key Stop SQL services Go to (must do this for each SQL instances on the server) Find the IP# key that contains the value of the address you want to remove where # is a number from 1 to the number of IP addresses SQL found on your machine during install Delete the IP# key found in step 4 If the number in the keyname is not the last one, rename the remaining IP# keys to be sequential starting with 1. Restart SQL Services 

I have 2 jobs whose execution times I find are overlapping each other. They both include the same into this table and frequently the job that starts last fails because it tries to insert a record into with a duplicate index key value. 

Typically you would design the database such that someone coming into the database alone could get a handle on how the application worked. Had they seen such a foreign key they may not be aware of it's implications. You could approach this in two ways: First, you could do as you mentioned. Create two separate tables and handle them there. Second, and the way I would recommend, you would create a table to handle all the common fields between the two, and then two other tables, one for internal-specific data, and one for external-specific data. Each of those tables would have a primary-foreign key to the common table. I.e. a Guid or ID. The downfall of the second method is the application would be required to be aware of the two different tables, and depending on the method you are using to implement it (.NET, PHP, Python, etc) you may find one method easier than the other. I personally use .NET and C# or VB, depending on the project, and in this situation I would go with the three-table design, as I would create an abstract class ("Event") and then two classes to inherit it and all the common properties ("ExternalEvent", "InternalEvent"). The Event class would handle the interaction of the shared properties, and the InternalEvent and ExternalEvent would handle the logic specific to them. The upside to this approach is the polymorphism of it. If you add a common field to the two in the future (for whatever unprecedented reason) you only have to add/change it in one location. 

Might be a little quicker. Essentially it ought to behave much like your original working query did. 

And works fine. Except that the working file, the one with the name generated by tempfile() remains in the working R folder on the server. All the other working files get cleaned up at the end of the process. Im my case, I don't want the image file to remain on the server, as it potentially contains sensitive information. -- I'm pretty new to R, so I've been experimenting with the code in an interactive line-by-line fashion in R console: I find that before running that line with the call to readBin() to assign the contents to the output data set, I can simply use the R command 

OK, just to follow up my correct (yay!) comment answer - in my experience almost everything along the lines of "weird issue" involving data selection, involves a rogue, unparenthesised "OR" somewhere in the where clause. It's always the first place I'd look. Typically you write some code along the lines of: 

I am using event notifications to capture data and log file autogrowth events for all databases on my servers. I'm using the data to for analysis of database storage configuration. In looking at the data I've noticed that the average duration for transaction log growth is well above anything I would expect which leads me to think that I'm either misinterpreting the data or overlooking something related to how transaction log autogrowth works. This is an example of a log file growth event that was captured today: 

All of the databases log to the same volume which is connected to a SAN via fiberchannel. (I'd have to get with our SAN admin for more details on the storage config if needed). The instance is SQL 2012 Enterprise, server is Windows 2008 R2 Enterprise. Why would it take over an hour to grow the log by 512MB? We're not noticing a delay in operations on any of these databases (unless we're just overlooking it). There are a handful of other databases with similar duration; their autogrowth settings are the same. Other databases with smaller autogrowth settings have proportionally smaller durations. 

Horses for courses. Works pretty much the same as your method. I'd write it your way in this instance if I were me. But it IS a good conceptual exercise to try to think of and compare different approaches like you're doing. Keep it up! :) One thing to note: you should really reference the source table in the SELECT clause. To avoid ambiguity or future complications: 

I'm working through some example code from Microsoft's documentation, to work out how to use R to plot graphical output - which in my case will ultimately be rendered in SSRS reports. It all works. Great, smashing, super. Here's my stored procedure: 

Knowing, and understanding, different options to obtain the same results is key to getting familiar with SQL, IMHO. No matter how obscure and esoteric the problem might be. Anyway, I know I'm late to the party, but here's a different take on a subquery method..