In this block, the array key is tested twice. But, unless it's a cli request it's not possible for or to be missing. This code is more approproate to acheive identical functionality: 

A consistent constructor makes it easy to know how to use a class without having to continually refer to the docs or class definition. If that's something you do with none-constructor functions (not applicable here) your code would not be compliant. Having different constructors isn't particularly intuitive, and means you can't have simple override logic like so: 

What is going to happen if $label is or any other innocent string that will cause malformed html as a result? Why is the class not taking care of that automatically? Note that there will be use cases where you want to put html in some tags - such as using an image for a label, or where tags are nested - attributes should always be escaped though. And that's just talking about how innocent users could break your code, not those with malicious intent who submit as their name. Big Point: Write real tests If you write a real test (by which I mean using phpunit) you can quickly test normal and edge case scenarios (What if the property looks like this?), which will highlight any difficulties in using the code. It'll also permit you the confidence - if you choose to rewrite any of the code in the future - of knowing that it still works in the same way as it did originally. Mid Point: Inconsistent constructors You have all these different constructors: 

Template structure The template is clean and easy to read but it is not a good habit to put the layout in the view file. Especially since the reason given is this: 

There are numerous things you can do to make the code easier to maintain. Put code in your models The minimap function calls find on the banners table twice - with config that doesn't change. It'd make things a lot cleaner to do this: 

Don't point at php This script looks like the intention is to point at a php file, that returns the compressed content. Assuming that's the case... PHP doesn't belong in-between a user and a static, public file. Webservers are much better for serving static content. Rather than pointing at a php script that processes the request, looks for and/or manipulates files and then serves it - take advantage of the webserver and point at the cache file directly - or where the cache file should be if it doesn't exist. I.e. change this logic: 

To what floor do the instructions take Santa? There is no need to go character by character to determine that, instead: 

Which is much more concise. This also does away with any need to delimit the code with comment lines (I wouldn't recommend that, if you feel it's necessary put each delimited block of code in a separate method). Note that the auth component stores data in the session, which is accessible in the view. Consider reading the current user data directly out of the session rather than passing variables around which contain information that's duplicated elsewhere. Use caching There's no need to get the banner info from the db on every request, you can wrap that in a cache call: 

DRY - Write less handle more You can make your function half the size by designing it to work with scalar vars only, and handling arrays with a loop: 

Format for readability If you're jumping in and out of php - having lines like this: make things hard to read, especially if there is some nesting in the code. Whether you choose to use curly braces or the alternate (colon) syntax is up to you, but in html code using a style which aides readability (putting the curly brace/colon on the same line as the statement it relates to) helps. No PHP Short tags Shorttags are often considered a bad practice, and as such should be avoided unless the code is your own, and you control where it's going to be used. Note that you can use with PHP 5.4 irrespective of the shorttags setting. Consistent whitespace The following: 

As well as making using the mail class easier, this has the advantage of the backend mailer class only being constructed on first use, it also makes testing easier: 

That's a lot of code It looks like it works but since it's apache specific what's wrong with using virtual? It's an apache-specific php function for serving files. I.e. 

I think you need to look first at the problem you're trying to solve rather than the code you've written. Is a class necessary A url is just a string (or an array if it's split into component parts) - is a class really necessary to represent a url? Or are a couple of functions required in the (e.g.) router class to parse and build urls? Reviewing existing code that does a similar things (php frameworks, pear, github, the blogsphere) would help evaluate whether the uri class is appropriate - bear in mind a web page typically has 10s or 100s of urls on it, and it's not free to instanciate many objects. This is likely to be faster to execute, and effectively easier to use: 

Either invert the test (!) or put some logic in there - e.g. redirecting the user to their profile page. 

There should basically be no super-global references in app-land code - all of the same data is available via , , . None of that will work with the code in the question though, because it's not based on CakePHP's controller class which populates those variables. 

If there's a class tracking all errors (why, what's the use/benefit) - it should either be asking individual instances what errors they contain, or some intermediary logic should be doing that. If the error class just contains an array of strings, there's no context to know why of where an error came from. Using DI is fine, but not having a needless dependency is better. As a related point the function only returns true or null. It would be preferable to always return something: 

In this way you can mock the test class, or simply subclass it and override so that it does not exit execution. 

There are other minor details which could change - but adopting this pattern will generally lead to more maintainable code. 

doesn't do anything for end users. It also doesn't do what you want, as it leads to ugly html. Look at the source of this page and look for "<form>" - if it were left aligned it would break out of the indentation level where it is. If you used similar code to that in the question to build all your html the indentation would be so wayward you wouldn't be able to read the raw html output without re-indenting it. It's something that is of no real value, because anyone who wants to see the html structure can just use firebug/devtools/their-tool-of-choice and it'll indent the code for them. If you really want to have indented html anyway, there are tools for that like htmltidy. 

Note that there's no need to continue to the end once the answer has been obtained - this alone make determining the answer faster. This doesn't defend against out-of-bound problems, but it also doesn't need to. 

The function invoke handles everything - there are 10 "actions" in it. Each of these if statements would ordinarily be a separate action (function) in a controller. include view That's not how views are rendered in CakePHP. Like that there are: 

Write testable code The above point is a pseudo-contrived example, unit tests are possibly a better example of when you'd want to not keep creating new objects. the login credentials are not something that are required at the time the Login class is created: 

Which is in fact set to four spaces. "\t" is easier and shorter to type. Minor Point: Whitespace Whitespace in html is insignificant, so doing this: 

That means in all cases the variable is tested 3 times if it's null, and twice if it's an array. A couple of side points: The first use of is really testing if the variable is a string by inferrance - it would therefore be more appropriate to use . Also by using type-insensitive checks an empty array or empty string are caught by the first if block (perhaps that's deliberate but it isn't obvious). Instead the code can be written as: 

A message inside a class like this shouldn't assume it is to serve html - what if it's responding to an ajax request, in xml, json or even just a log file? Don't sleep I'm not sure if this is just code for demonstration but this is actually the one "problem" with the code in the question. Using sleep will tie up your resources - that's not in your interest. Consider instead bailing early and just returning a 403. Right now before prompting a user with a captcha - you are holding the request open for more than a minute. If you get enough users (and enough could be a relatively small number) trying to login at once and getting it wrong - you're going to take your own server offline by occupying all connections with 1 minute long sleep calls. Don't use empty if blocks Again, not sure if this is just for demo purposes: 

This function simply loops on all the keys that you specify as needing to be not-empty and returns true only if they are all populated. Many simple functions Always strive to have simple functions, that do one thing - for example: 

Putting all your logic in one place is not necessarily the best idea, when the alternative is to write concise (and more efficient) code using php's function directly in functions. As such, consider 'just' using PHP instead of wrapping php functions in some more logic. Make "nu" a separate function Each case you want to handle should really be a protected specific function. Once you do that, consider deleting any functions that are just one line of code as it's better to just use php's own functions. The 'nu' function however, is likely to warrants it's own function. It looks like the main purpose is to strip out XSS attacks. Unless you have exhaustive tests for this logic, it is very likely it doesn't cater for all possibilities - therefore make it a separate function and if you haven't already it'd be in your interest to write some tests to at least cover the most common XSS attacks.