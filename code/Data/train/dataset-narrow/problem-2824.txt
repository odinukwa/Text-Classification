I don't know XNA, but usually the rotation of a sprite is around it's origin. So the lens position should be the center of the circle and the origin should be . That would initially position your lens at the 3 o'clock position (0 radians) 

If that's not a possibility, you could probably just use an integer and bitwise operations to get the color values. Eg something like this 

The native Flash Events such as etc. are quite fast and there's no way around them. If you want to learn more about the event flow, read this article. Personally I try to avoid the event system whenever possible though. Custom events (subclasses of Event) are slow. Using events can also cause memory issues when not used carefully (because a pointer to your object will remain in the event-dispatcher and therefore the memory will never be freed by the GC, even when the object is no longer needed). Still, events are a great way to decouple components. Using public functions and calling them directly is of course much faster, but it means a tight coupling. In an event driven system, you fire an event and be done with it. You don't have to know anything about who receives the event and what kind of function you have to call. Instead of events, I prefer a system called "signals and slots". There's a great implementation of that pattern in actionscript, called as3-signals. There's also the (slightly) faster but less versatile turbosignals. So how does this work. Consider the following example (using as3-signals, unnecessary code bits stripped away): 

Usually shader languages come with special types that hold multiple values. For example GLSL has , , and types which hold 2, 3 or 4 float values... these types are ideal for something like RGB or RGBA values. I don't know which shader language you use, but from your other question I'm guessing it's AGAL (Flash shader). There you use register and every register is 128bits wide. So it can hold 4 float values, which you can access like this: 

There are graphic engines out there (take Ogre3D as an example) that provide an abstract layer on top of DirectX and OpenGL. So as a developer you just use the Framework and don't have to care much about the underlying GPU-API. Some special things like shaders may have to be written in HLSL and GLSL but there are also higher level shader languages that can run/compile to both APIs. My assumption would be that the engine Blizzard uses (they wrote their own) also provides an abstraction layer that makes it easy to swap the underlying graphics API, so that they don't have to rewrite all their graphics code for a Mac port. 

You can use the Facebook Graph API for that purpose (there are several SDKs available). These are roughly the things you need to do: 

To achieve such an effect, you can use a 3D Projection without perspective (called parallel projection). That will render all your objects at the same size and from the same angle, no matter where they are positioned. Something like this is mandatory if you're using a painted background. Here's a nice overview of some possible projections. In addition to the background image, you'll have to store some sort of topological information for the ground. E.g. the height per "cell", so that you can move your characters up/down accordingly. If you have a ramp, you can interpolate the height values between the upper and the lower cell. 

If you don't mind providing your data to Google, then Google Analytics is a great tool for that too. Rather than tracking classical page-visits (which you could use for different Game-screens), you can use the Event-Tracking feature to track/gather all sorts of data. Implementation in Flash should be trivial. Either use the ExternalInterface to invoke JS from Flash, or use the tracking-classes provided by Google. Using ExternalInterface has the advantage, that you decouple your game from the actual tracking implementation. So you basically just send messages from inside Flash to a JavaScript callback. There you would invoke the actual tracking, be it Google Analytics or any other tracking mechanism. That makes it easy to swap/modify/remove the tracking at some other time without recompiling the Game. The advantage of tracking directly from flash is that your tracking will also work if somebody hosts the Game on a different website, without the necessary JS wrapper code. So I guess both ways of tracking are valid options to consider. The easiest route would probably be Google Analytics in combination with the ActionScript tracking implementation provided by Google. 

Done, you've got UV coordinates now. However, these coordinates are most likely not that useful, since you'll end up with a ton of seams. A good unwrapped mesh has less seams, preferably at places where they can easily be hidden (eg. where an uniform color meets) or where the seams will be obstructed by other geometry. That's why you usually mark the seams yourself (in edit-mode select the edges that should be a seam and press Ctrl + E and select "Mark Seam" in the menu). Then use the regular "Unwrap" (not "Smart UV Project") to unwrap the mesh, Good UV unwrapping is hard and requires practice. This video-tutorial might help you getting started. 

The range to is a total range of . So you need to scale it appropriately to get to . Something like this: 

Both are valid choices, but with Unity3D it's going to be much simpler to achieve what you want, mainly because: 

Edit It seems like you want to dynamically paint the actual viewing-area of each cop instead of just a triangle. A way to do that would be to look into 2D shadowing. I once did a quick flash experiment with 2D shadows based on a bitmap image. I integrated your wall map into my code. Here's the interactive result, and here's the source-code which you're free to use as a starting point for your own implementation. 

If you want to have the paddle origin at the center of the paddle itself, then you can do the following to get a point that's always on the circle (the code to obtain the rotation will be the same as above): 

The dot product will be the cosine of the angle of these two normal vectors. It will be when both normals point in the same direction (eg. your plane is absolutely flat), when the normals are perpendicular and when they are pointing in the opposite direction. Your check if a surface is sloping could be a simple threshold comparison, such as: 

While Valke answered your question regarding custom events perfectly, I usually try to avoid Events in Flash for game-development. Robert Penner lists some good points why Events are bad. Custom events are especially bad, when you're dispatching them very frequently (a common scenario in games), because every time you dispatch the event a new object will be allocated and also has to be garbage-collected later on. I found the signal/slot pattern to be a very good replacement for most event-related stuff. There's the excellent as3-signals library or the fast turbosignals library for flash. With as3-signals, your game class could look something like this (I omitted any irrelevant stuff): 

Technical background: You have to use or , because Cocos2D keeps a flag internally that indicates if the position has changed and if the sprite should be moved. Setting components like or directly won't do anything, because the flag only changes when you invoke the setter. 

Short answer: Yes. Slightly longer answer: Maybe you want to add the accelerometer input to the objects velocity variable, so that there are no very sudden movement changes, when the accelerometer fluctuates. Then you would use the current velocity to calculate the objects angle (still using ). 

Update: To actually perform the deflection of the meteor, you can simply "reflect" the meteor normal with the shield normal (using the variables used above, make sure is normalized): 

Personally, I'd build the map using a designated tile-editor like TileEd. This approach yields several benefits: 

I suggest that you don't directly couple browser-input-events to your game-logic. I would do something like this: In your event-handler, read the current screen position and store it as a variable. In your game-update loop, get the latest mouse-position (the variable you stored previously) and calculate the players looking direction there. The general idea is to handle the mouse-events as quickly as possible (do not perform costly operations in the event-handler). And most importantly: Don't alter the game-state in your mouse-handler, since all this is redundant until the next frame gets rendered. So you better update the game state once, just before rendering the next frame (in your game-update loop). Update: Keeping the current mouse-position as a variable is the most basic way to solve this. This might be good enough for something like the mouse-position but bad for keyboard-events (where you might get more than one in-between a single update). The solution to this would be input-buffers where you keep a list of the events that occurred and process the list in your next update. 

The Sutherland-Hodgman polygon clipping algorithm should work just fine for triangle vs. rectangle clipping. You'll find some more information about clipping algorithms here. Or just search for "Sutherland Hodgman clipping". 

This should give you the proper movement ratio to plug into your code (or the one proposed by Andrew Russell in his answer). 

I think it entirely depends on the amount of data (and memory-resources available) you'll have to load for each level. If your level-data alone is huge, then your level-progress might be just an array (or vector) of files: 

Usually the distance of the midpoint of a polygon to the camera is being used for z-sorting. The painter's algorithm cannot be 100% accurate by it's nature. There will always be cases where sorting will fail, no matter what reference point you use. If you want correct z-sorting with the painter's algorithm, you'll have to slice overlapping polygons into smaller parts (eg. by using a quad-tree) and sort these parts individually. This can become quite heavy on the CPU though.. Found this Powerpoint file that illustrates the issue nicely (PDF Version).