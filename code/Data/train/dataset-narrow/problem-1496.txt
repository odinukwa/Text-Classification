Like it says in the code comments, how do I get rid of this for-loop and vectorize the operation? I feel like I should be using to accomplish this, but I'm not sure how. 

How can I write this better or more efficiently? Is there a state machine library in Python that would stop me from having to rewrite variations of this class all the time? 

I figured out that this assignment could be rephrased as a vectorized multiplication which eliminates the need for a for-loop and costly indexing of individual groups of elements. 

I'm trying to generate a bunch of uniformly distributed unit vectors around the unit circle. Here's my code, which is working, but unfortunately I have a for-loop. How do I get rid of this for-loop? 

I think I can reduce the amount of code I'm using by somehow using more effectively and using a Python iterator, but I can't wrap my head around it. It might also be possible to do this with fewer plotting calls, but I can't figure that out either. Ideally, I would change the line drawing to use a Line3DCollection and the areas to use a Patch3DCollection for plotting speed, but I'm still not comfortable enough with the 3D api. 

so you know the last digit is 0. This condition can then be discarded once you restrict generation to have the last digit as . This basically simplifies the problem to a nine-digit problem. 

(the error mirrors that of indexing lists). In the scheme of things, this code is simpler, faster and contains not too much logical duplication. However, deduplication is nice, so one could merely add a method: 

which is really a bit odd as it means won't print anything, it means we have a meaningless return value from calling it and it means we have to pass a strange second argument. Better would be to extract the recursive component out from the result-giving. Another fancier option is to generate differently. 

Since these get hashed a fair bit and the class should be immutable, it seems sensible to make a tuple and simplify to just . is only called from , which can be merged to create 

In that sense, the creatively defined method name and the parameter names and will not do. The General Naming Conventions states: 

The code is missing the class which I think is also important for the review. The cache items are added with keys and it is important for this method to return the same value for objects having the same credential values, and distinct values for instances with different credential values. Is it? Naming conventions. Class names should be PascalCase and the class violates this rule. Should be To achieve better encapsulation and seperation of concerns, (The creation of an empty credential object should be a concern for the Credentials class, which has control over the internals of itself) instead of having a field in this class, it is better to have a field (or property getter) in Credentials class. 

You should always check if the parameters are passed in as null. Your code would fail with a null refererence exception at if is passed as null. 

since files are iterable. This will prevent the need to hold the whole file in memory. Also, prefer to . is a good variable name if it is uniformly increasing by a fixed amount each iteration and its use it obvious. In this case, that isn't true. Something more descriptive like . Note that that would imply reducing the count by 1 everywhere. However, the count is reset every loop iteration so the check is always True. Remove the variable and check. You repeat this three times: 

You call this once for each sub-tuple of , and there are at least this many of those: $$ 1 + 2 + 3 + ... + (n-1) + n $$ Because there are \$1\$ for length \$n\$, \$2\$ for length \$n-1\$, etc. There's one more for length 0, but that's uninteresting. Each should be multiplied by its cost; if you consider only those that succeed (not those which are caught by ), they cost \$\mathcal{O}(n^2)\$ each due to 

You keep track of class instances and not bare integer values, You can re-use this class in other projects or forms (if designed & implemented correctly), You can extend this class to enrich it's functions etc.. (There are an infinite number of benefits) 

You can wrap your timers in ExecutionPlan class. Using a class for wrapping the timers have many benefits. 

The access is synchronized to the method. OK. For the threads that call at the same time passing the same instance, after the call to , is for only the first invoking thread. OK. All other threads get the existing instance after calling and is . OK is called on one of the first threads that call , most of the time the adding thread, but sometimes on another. OK After the call to , all requesting threads get the same instance out of one by one, as returned by . OK The first thread that gets the instance calls and succeeds. OK. After the instance is removed, other threads continue to get the old instance because they have the removed instance. OK 

Honestly, this looks like it's been passed through your own function. Split it up (and remove that trailing semicolon)! Add spacing. Now, this isn't correct either. Not all tripple quoted strings are doc comments. What about 

But expectedly still takes majority time. Using a set instead of a list speeds up CPython but slows down PyPy. This suggests effort should be solely on a more efficient representation for that. Here's one idea: 

it comes at no extra cost. It also gives more internal flexibility for to, say, lazily produce values. 

you know that every number afterwards is already set in the array since . This means you don't need to set them in the array. You still need to know the number of skipped items, so you look it up from 

in Java can you really call this worthwhile? You end up fighting the language most of the time. A simple 

I'm not suggesting to change to and to of course. The parameters should have descriptive names in the first place. You can consider and or similar. Possible Improvements Being consistent with code formatting is important. Consider using curly brackets, always: 

Yes, it seems thread safe. I run a test to prove it which I give the details at the bottom, but first are some code review comments. 

You should also check the items of the passed in collection for null references. If any of the items of the would be null, your code would fail with a null refererence exception at 

That's why we should first think about the primary concerns of our application, and try to seperate these concerns into classes, which can then also be re-used if designed modularity in mind. Therefore, Assuming what you are trying to achieve is something like this: