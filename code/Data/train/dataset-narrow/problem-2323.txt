covered by "pre-periodic part and initial period, each with length less than $\: C\hspace{-0.04 in}\cdot \hspace{-0.03 in}j \:$". Now, choose a family $H$ of hash functions with short output and domain equal to 

For a subset of $\mathcal{S}$ to be pairwise disjoint, it cannot have sets from opposite literals and 

realized that I have no clue what a formal definition of the security goal would be. Is there a formal definition of security for interlock protocols? 

One could just expand $\: x\hspace{-0.04 in}\cdot \hspace{-0.04 in}2^{\hspace{.02 in}y} \:$, $\:$ but that would use at least $\:\left|\hspace{.03 in}y\right|\:$ bits of space. 

$\big[$the set of strings with length less than $\: C\hspace{-0.04 in}\cdot \hspace{-0.03 in}j \hspace{.02 in}\big]$, $\:$ such that for all distinct equal-length 

games with just 2-buttons and 2-doors in which all doors are initially closed: "Levels" are finite subgraphs of the planar grid. $\:$ Vertices are identified as one of [start,button,empty,door,finish]. $\:$ Each door vertex has a set of opening buttons and a set of closing buttons. $\:$ A k-door is a door that's controlled by at most k buttons, and a a k-button is a button that controls at most k doors. $\:$ Whenever on a button vertex, one can press the button, which opens the doors that the button is an opening button for and closes the doors that the button is a closing button for. $\:$ The goal is to get from the start vertex to the end vertex without going on closed doors. 

I notice that, by rounding to a value of the form $2^\left(2^n\right)\hspace{-0.02 in}$,$\:$ one can assume without 

MA $\subseteq$ PSPACE $\subseteq$ EXP $\subseteq$ NEXP ​ and ​ P/poly has undecidable unary languages, so 

CNF-SAT ​ $\to$ ​ your problem ​ ​ ​ : The subscripts are the variables and the superscripts indicate whether the 

non-negative integer $x$ that satisfies $\;\;\; x^{\hspace{.02 in}2} \equiv y \; \pmod p\;\;\;$ and $\;\; 2\hspace{-0.04 in}\cdot \hspace{-0.04 in}x \: \leq \: p \;\;$, 

and a non-empty list of binary vectors whose lengths are all n+1, Well-Formed Outputs: $\:$ a perfect binary tree of depth d that has each non-leaf node labelled with an element of {0,1,2,3,...,n-2,n-1}, where d is the greatest integer that satisfies 2^d ≤ S Value of a Well-Formed Output: $\:$ the conditional entropy of the last entry of V (which is V[n]) 

Since $H_1$ is involved in the same place in each case, any collision in $H_2$ is also a collision in $H_1$. $\:$ By Merkle-Damgard's security, any collision in $H_1$ can be efficiently transformed 

so by contrapositive, if R is not solvable by ​ FDTIME$\left(\hspace{-0.02 in}2^{S(n)} \hspace{-0.03 in}\cdot \hspace{-0.03 in}\left(\left(\hspace{.05 in}poly\hspace{.02 in}(S(n)) \cdot \ell(n)\right)+ T(n)\right)\hspace{-0.03 in}\right)$ 

Since $\:$2SAT $\in$ P$\:$, $\:$ one has $\:$sPCP(2) $\subseteq$ promise-coRP$\:$ by reasoning similar to the PCP(1) equality. 

(This doesn't fit in a comment.) I think I now see how to show that your the salting doesn't necessarily provide 

Let $G$ be a directed acyclic graph with $V$ vertices and $E$ edges. Choose some subset of $n\leq V$ "special" vertices $\{v_i\}_{i=1}^n$. How efficiently can we preprocess $(G, \{v_i\})$ so that we can get $O(1)$ reachability queries between any two special nodes $v_i$ and $v_j$? For $n = V$, this is just the usual reachability problem. I want to focus on the case where $n \ll V$. Using $n$ depth-first searches starting at the special vertices, it is straightforward to obtain an $O(nE)$-time algorithm. Can this be beaten? What if we relax to $O(\log n)$, $O(n)$, or $O(\log V)$ query time? EDIT (May 3, 2011). One comment points out that bounds like $O(nE/V^\alpha)$, $\alpha > 0$ imply sub-cubic matrix multiplication bounds. On the other hand, a bound like $O(\max(n^2 V, E))$ for the restricted reachability problem would not imply a sub-cubic method, yet would still be quite useful for $n \ll E / V$. 

We have MPostBQP[0] = BQP, MPostBQP[1] = PostBQP, and MPostBQP := MPostBQP[2]. I'm trying to mirror the Arthur-Merlin classes where AM[0] = BPP, AM[1] = MA, and AM[2] = AM. EDIT (3/27/11 5 PM): There seems to be debate about how postselection should be defined in this context. Obviously, I mean for a definition which does not trivialize my question! :) The definition I have assumed is the following: Postselecting on the kth bit means we project the state into the subspace in which the kth bit is $0$, and normalize. It turns out that in a scheme where we postselect before we do measurements, then we can obtain the final statistics by looking at conditional probabilities in a scheme where the postselections are replaced by measurements. However, I claim that this characterization breaks down when measurements and postselections are interspersed. I think the confusion stems from people using this "conditional probability definition" (which works in the special case which I am generalizing out of) as the definition of postselection, rather than the "forced measurement" definition I just gave, which clearly depends on order because of lack of commutativity. I hope this helps! EDIT (3/27/11 9 PM): I defined postselection in the pure-state formalism already. Niel gave an analysis in the density matrix formalism that disagrees with mine for the 3-qubit example. The culprit is, again, the definition of postselection. Define postselection in the density matrix setting as follows. Given a density matrix $M$, rewrite it as a mixture of separable states $M = \sum p_i \left\vert a_i \right> \left< a_i \right\vert$. Let $\left\vert A_i \right>$ be the result of postselection (on some qubit) using the pure-state formalism I defined above. Define the result of the postselection on $M$ to be $\sum p_i \left\vert A_i \right> \left< A_i \right\vert$. This is a more sensible definition, because it doesn't give us results which say that after we post-select, we alter the statistics of events (measurements) we already watched happen. That is, the $p_i$'s are probabilities of coins we've "already flipped". It doesn't make sense to me to say we are going to go back in time and bias a coin flip that already happened because that would make the current postselection more likely. EDIT (3/28/11 1 PM): Niel concedes that with my definitions the problem makes sense and doesn't trivialize -- but with the stipulation that I shouldn't call it postselection. Given the amount of confusion, I have to agree with him. So let's call what I defined to be selection, which performs a "forced measurement". I should probably change the name of the complexity classes I defined as well (to not have "Post" in them) so let's call them QMS[k] (quantum-measure-select). 

cannot have more than one set from any given clause. ​ For a subset of $\mathcal{S}$ to cover $\mathcal{U}$, 

the random bits used by the algorithm that generated the auxiliary input? (Or is that, in fact, how the zero knowledge condition is usually defined?) 

By construction of $A$, that means there are oracle-circuits of size at most j+n$^{\hspace{.03 in}j}$ and a 

for the string $m$ such that $\;\;\;\;\; m \:\: = \:\: x\:||\:111...[b\text{ of them}].\hspace{-0.04 in}.\hspace{-0.04 in}.111\:||\:y\:||\:z \;\;\;\;\;$, 

for succeeding with non-negligible probability in $\:$ given as inputs the index of a group action and the result of 

takes n as input and outputs the lexicographically least oracle-circuit of size at most j+n$^{\hspace{.03 in}j}$ 

"Is anything known about this special case (excluding approximation results)?" I don't think anything is known that's specific to the special case you mentioned. 

large $k$, the probability of $\:\left(P,V_1\right)(x)\:$ succeeding will be more than $\: \frac1{5\cdot p(k)} \:$ greater than 

for all search problems R in ​ FNTIME(T) ​ whose output-lengths are bounded above by $\ell$: If R's circuit-size in bits is at most S then R is solvable by ​ FDTIME$\left(\hspace{-0.02 in}2^{S(n)} \hspace{-0.04 in}\cdot \hspace{-0.04 in}poly\hspace{.02 in}(S(n))\hspace{-0.04 in}\cdot \hspace{-0.04 in}T(n)\hspace{-0.03 in}\right)$ , 

not of the form addressed above then $\;\;\;\;\; H_2(m) \:\: = \:\: x\:||\:\:111...[b\text{ of them}].\hspace{-0.04 in}.\hspace{-0.04 in}.111\:||\:H_{\hspace{-0.02 in}1}(m)\:||\:x \;\;\;\;\;$. and For all strings $m$ that are of neither of those two forms, 

[[i+1 = j ​ and [[there was an edge from u to v] or u=t=v]] or the other way around]. Clearly, any path of length at most k from s to t can be lifted to a path of length at most k from 

Yes, because you made the approximation irrelevant. ​ Reduce from k-SAT: Each variable contributes one element to $\mathcal{U}$ and each clause 

By padding, that means we leave coUSBPcc $\big(\hspace{-0.04 in}$and thus also Pcc$\hspace{-0.03 in}\big)$ ​ as soon 

Those problems are equivalent to: Find [the assignment of one positive integer to each '1' in the matrix] such that with 

For all positive integers c, a similar thing will apply when 2^(2^i) gets replaced with 2^(2^(c*i)). 

$= \; \left(\hspace{-0.02 in}1\hspace{-0.04 in}\big/\hspace{-0.07 in}\left(\hspace{-0.02 in}n^{2+j}\hspace{-0.02 in}\right)\hspace{-0.03 in}\right)\hspace{-0.04 in}-\hspace{-0.04 in}\sqrt{\left(p\hspace{-0.04 in}\cdot \hspace{-0.06 in}\left(\hspace{.02 in}j\hspace{-0.04 in}+\hspace{-0.04 in}n^{\hspace{.04 in}j}\hspace{-0.02 in}\right)\hspace{-0.04 in}\right)\hspace{-0.06 in}\big/\hspace{-0.07 in}\left(2\hspace{-0.06 in}\cdot \hspace{-0.06 in}2\hspace{-0.06 in}\cdot \hspace{-0.04 in}p\hspace{-0.04 in}\cdot \hspace{-0.06 in}\left(\hspace{.02 in}j\hspace{-0.04 in}+\hspace{-0.04 in}n^{\hspace{.04 in}j}\hspace{-0.02 in}\right)\hspace{-0.06 in} \cdot \hspace{-0.06 in}\left(\hspace{-0.02 in}n^{(2+j)\cdot 2}\right)\hspace{-0.04 in}\right)} \; = \; \left(\hspace{-0.02 in}1\hspace{-0.04 in}\big/\hspace{-0.07 in}\left(\hspace{-0.02 in}n^{2+j}\hspace{-0.02 in}\right)\hspace{-0.03 in}\right)\hspace{-0.04 in}-\hspace{-0.04 in}\sqrt{\left(p\hspace{-0.04 in}\cdot \hspace{-0.06 in}\left(\hspace{.02 in}j\hspace{-0.04 in}+\hspace{-0.04 in}n^{\hspace{.04 in}j}\hspace{-0.02 in}\right)\hspace{-0.04 in}\right)\hspace{-0.06 in}\big/\hspace{-0.07 in}\left(2\hspace{-0.06 in}\cdot \hspace{-0.04 in}f\right)}$ 

and will probably ask another similar question.) No to my title, and yes to the body of my post, both because all such fs are in O(1). 

Obviously, M decides at-least-two-1s-in-binary and has runtime exponent 1, and no other Turing machine with a smaller runtime exponent also decides at-least-two-1s-in-binary. 

Two things you might want to look at: Algorithmic Game Theory Ch. 7 : Graphical Games Fluctuations in Evolutionary Games The first goes over how to find equilibria in games or spin systems like you described. Certain meta-strategies for strategy adoption (specifically the one identical to Gibbs Sampling that leads to a correlated equilibria) allow very general, tractable analyses. The second attempts to predict large fluctuations or change in "norms" in an evolutionary game theory model using large deviations theory. The examples tackled are small-scale, but the author attempts to make the mathematical machinery he uses as general and powerful as possible, so it may be applicable to your case. 

Given a population and an evolutionary scheme, can we give a probabilistic regret bound for the long-term population optimality (compared to the best individual produced?). This seems to relate strongly to ensembles of experts and bandit problems. What about in nonstationary settings? Given a set of populations of different species that interact in their environment, playing pretty much any sort of multi-player game, what statements can we make about the eventual stability of their strategies or strategy distributions, given their evolutionary strategies. In any sort of environment with many "niches" (an overbroad way of phrasing it, I understand), either in terms of direct relationship with the environment or in terms of relationships with other species, what statements can we make about how populations will distribute across these niches. Any problem I haven't asked but should - I'm coming at this with little AGT, TCS, Genetic Algorithms, evolutionary game theory or population biology background; I'm asking my questions from an optimization/machine learning/stats point of view, which may be the wrong one or incomplete. 

I use the title term in a very loose sense. There is a significant amount of work on evolutionary game theory, including its mathematical foundations. I was recommended "Evolutionary Games and Population Dynamics" but haven't delved into it yet. There is also a significant amount of work on algorithmic game theory, which is a popular topic on this site. What I'd like to see is work that makes computational complexity or convergence statements about certain evolutionary dynamics. Examples (phrased very loosely): 

Suppose P != NP. We know that we can make easy instances of 3-SAT at any time. We can also generate what we believe to be hard instances (because our algorithms can't solve them quickly). Is there anything preventing the set of hard instances, from being arbitrarily small, so long as for any given instance size (n) there are only Poly(n) (or even constant) instances of size Poly(n) or smaller? For any hard 3-SAT instance, we would have to add the set of all 3-SAT instances it reduces to via looping through the NP-Completeness reduction cycle, but I don't foresee this adding to the number of hard instances very much. In this world, we could construct an algorithm that polynomially solves all NP complete problems, except an exceptional few. Edit: A softer variant of the question: even if we showed P!=NP, how could we know whether a given method to generate size n 3-SAT problems actually generated hard one with some requisite probability? If there's no way to know from P!=NP alone, what is required to show that we can generate a hard NP-complete problem? 

The least common ancestor problem can be used to solve the reachability problem in dynamic rooted trees, so I imagine you will also be interested in the following: Optimal Algorithms for Finding Nearest Common Ancestors in Dynamic Trees, by Alstrup and Thorup. This paper gives a time bound of $O(n + m \log \log n)$ for $n$ links and $m$ nca queries on a pointer machine. 

In Hardness of embedding simplicial complexes in $\mathbb{R}^d$ it is stated that $\mbox{EMBED}_{3\rightarrow3}$ is at least as hard as recognizing a 3-sphere, which is known to be in NP, but not known to be in P. They continue to say that for all we know, the problem may be undecidable. EDIT: Update. Actually, my answer applies to PL embeddings. For linear embeddings the problem is known to be in PSPACE. I don't know if anything else is known. 

Define the computational model MPostBQP to be identical to PostBQP except we allow polynomially many qubit measurements before the post-selection and final measurement. 

This would be philosophically interesting (at least to me) because it would tell us that the "tractable" class of problems for a "postselecting sorcerer" includes (or is) all of PSPACE. EDIT: I've been asked for a formal definition of MPostBQP. (I have updated what follows.) MPostBQP[k] is the class of languages $L \subset \{0,1\}^*$ for which there exists a uniform family of polynomial-size quantum circuits $\{C_n\}_{n \geq 1}$ such that for all inputs $x$, the procedure below yields true with probability at least $2/3$ if $x \in L$, and with probability at most $1/3$ if $x \notin L$. The procedure, which allows for some choices which may depend on $L$ (but not $x$), is defined as follows: 

This is indeed known for $k=1$, which says MA $\subset$ PP. To show it for $k=2$ would mean MPostBQP = PP only if AM $\subset$ PP. Since there is an oracle relative to which AM is not contained in PP, this could give an affirmative answer for my first question. Finally, for the polynomially many rounds case, 

I'm interested in an external memory data structure able to support the following operations on variable length binary sequences: (1) Insert such a sequence. (2) Given a query sequence, find the longest sequence previously inserted which is a prefix of the query sequence, provided one exists. In particular, do we need $O(n)$ I/O's for an operation with a sequence of length $n$? (Say, by directly implementing a radix tree in external memory.) Or is there something nice, where we can get $O(n/B)$ I/O's? 

Define MPostBQP[k] to allow multiple rounds of measuring and postselection before we make the final measurement. Choose indexing so MPostBQP[1] = PostBQP and MPostBQP[2] = MPostBQP and so on. (Update: A formal definition is given below.) Consider Arthur-Merlin games. Perhaps we can simulate them in this model of computation: Postselection can take Merlin's role of producing convincing messages and the intermediate measurements can take the role of Arthur's public coin tosses. This possibility makes me ask: