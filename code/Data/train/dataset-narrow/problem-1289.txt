Also, in , you can skip the generic type specification for the and write just , the compiler will infer the generic types. The code to move the rover should be a part of the , not . Also, it should be defined as a function like this: Drop the surrounding braces in one-line functions, it makes the code look more functional. No exception handling - What to do if the user enters illegal characters? Scala is infamous for its confusing stack traces, it would be good to define code to handle exceptional conditions - a functional (recursive) equivalent of running the entire block in a loop which breaks only on legal input. Also, consider throwing proper exceptions in exceptional cases, an example is in point 6. Imports should be declared closest to their site of use. There is code duplication between and . You could probably use a function accepting a type of turn, be it indicated by a flag, an enum constant (I use this approach in the code below), or a hierarchy. Pattern match on the type of turn to choose the correct rotations to use. 

You could make a subclass of instead of to make it an unchecked exception, in the spirit similar to the unchecked and . However, this depends on the API you are willing to present to your users, and whether you think that this exception must be handled specially over others. 

An implementation may look like: (if Java supported real immutable lists we could have tried to cache the empty String array for hopefully better performance, but we're stuck with what we have...) 

It's not technically \$O(1)\$, it's amortized constant time (\$O(1)\$), as you distribute cost of the calculation over the additions / removals. Not really an issue, but maybe you should make that distinction in your documentation. Use instead of , as it preserves the caller's object identities that way. This would entail changing the type parameterization of to be , though. Considering comments (especially by @EmilyL), you should leave the implementation as-is, but you should put in a comment that you are only interested in the numeric value, not the actual object. Consider marking your formal parameters as , as you do not mutate them. Make 's return type , as the user has no need to get the same number which was passed as an argument returned. Rather, throw an exception, preferably if the relevant could not be found in . An alternative to (4) is to make 's return type , and return on successful removal of from the set, or if the removal was not successful. Instead of throwing an when asked to compute the standard deviation when the set has less than 2 elements, return for such sets, as in the 0- & 1-element sample sizes, the standard deviation is mathematically undefined. That does not warrant an exception, as there is a value which indicates exactly undefined: . Here I assume that the standard deviation is calculated for a sample, not a population, because in that case the standard deviation for 0- & 1-element sets would be 0 (although computation of population statistics is not common in practical usage). 

Try-With-Resources If you're using Java 7+, use the try-with-resources statement. The syntax is similar to C#'s statement: 

Put all your s at the top of your source file. Use variable names that are full words - let the IDE do the repetitive typing via autocompletion. seems kind of weird as a name - why not ? In and other places, , for "traverse", should also be named as , as in the rest of the code. It is standard practice to put the declaration (interface) in a separate header file - however, it seems you're aware of this and you've avoided doing this deliberately for good reason, so I won't dwell on this further. Your indentation is non-standard: 4 spaces to a tab is considered standard by most programmers. You do not follow a consistent bracing style between functions and statement blocks - use the same for both. You sometimes leave a useless line break after the body of the - if this is intentional, be consistent. An explicit is not required at the end of a method of return type , as in . Try not to use or as variable names - it makes your code uncompilable by a C++ compiler as they are C++ keywords which occur in identifier positions in your code, although the rest of the code is undoubtedly valid C++, too. Use the Boolean data type to indicate / conditions - in a C99-compliant (or above) compiler (say, with the option passed to it), the type and the macro literals and are available from the header file . 

Note that @mdfst13's approach below also relies on Java 8, and although his is more efficient, I feel that my approach conveys the idea behind the process a bit better. By all means, please use his version in production code, mine might be too slow for that. Just reproducing his approach below: 

Hard-code as little as possible. Try to use more parameters. All those 5's are for a specific use-case. Try accepting them as parameters in your function. Return a instead of a - it associates each price with a count of stamps of that price and makes the returned value more general with respect to prices. is a bad idea, as explained above. Your code style and formatting is OK as per the PEP8 style guide for Python. 

What are you doing? You haven't bothered to explain your algorithm, either in the question body or in program comments. Bugs. As pointed out by @Abhisek, your code prints 3 instead of 2. When you count the number of camelCase words, you should ignore whitespace, in fact, you should treat any non-alphabetic characters as lower-case, as per my understanding of the problem (although this is an edge case). You haven't bothered to use any of Java's standard libraries. You would find the functions , and extremely useful, instead of doing error-prone and language-limited manual checking. Also, is always a better check than . Non-descriptive naming. Your method does indeed solve a HackerRank problem, but that does not describe it properly. You could name it for what it does, something like , as per some guidelines for Java method naming (Effective Java by Joshua Bloch). You only use once without the emptiness check. In fact, that is not required either, as the general code will handle that too. Just use the emptiness check to set the initial value of the word count to or , depending on whether the input is empty or non-empty. respectively. You do not need to return early to avoid the loop as the loop won't iterate in the first place. For that matter, as s are immutable, repeatedly calling on the same object does not have much overhead, so you do not need even if you are concerned about the loop. Avoid all the business, and use a for-each loop. Kind of like: 

Thus getting the best of both worlds. The parametrization is assuming the declaration and call sites of this method are in 2 different classes, but otherwise it's perfectly fine to lose the parameter and inline the constant - however, the code remains more flexible this way. You'd notice that here we're doing reference copying (shallow copying), but that isn't a problem as s are immutable and interned (there is only one copy of 2 identical constants). Other notes: 1. Naming: is a pretty weird name for what this function does; why not just call it something like or something? Otherwise, the rest of the naming in the code looks OK. 2. Unnecessary code: The check you've got in approach becomes irrelevant using my algorithm. 3. Notes about : Firstly, could be (somewhat) better named as ? I'm not too sure, both are applicable given the context. If you can use Java 8, you can significantly reduce the complicated logic with a simple stream map and collect. It would look like this: 

As @vnp notes in the comments, the fact that triangular numbers are products of coprime numbers allow for very efficient factorization - see this thread for an illustration of the idea in Java, easily carryable over to Python - which I'll illustrate in my code too. The idea here is that since the \$n\$th triangular number is the product of 2 numbers \$n\$ and \$\displaystyle\lfloor\frac{n+1}{2}\rfloor\$, which implies that if \$n\$ is even then \$\displaystyle\frac{n}{2}\$ and \$n+1\$ are 2 relatively prime integers, whereas if \$n\$ is odd then \$\displaystyle\frac{n+1}{2}\$ and \$n\$ are 2 relatively prime integers. This makes factorizing the resultant \$n\$th triangular number take less time as now a divide-and-conquer approach can be employed, making this part of the algorithm \$\mathrm{O}(\log_2n)\$ in time. As I previously posted in my comment to the question, this StackOverflow thread is a good reference for efficient factorization, especially the first answer there. The idea is that there can be no prime factors of a number greater than its square root, and factors are paired in the sense that each factor \$i\$ of a number \$\text{num}\$ has a complementary factor \$\displaystyle\frac{\text{num}}{i}\$. Thus we can use a sublinear time algorithm to factorize integers, which involves enumerating to only \$\lceil\sqrt{\text{num}}\ \ \rceil\ (\mathrm{O}(\text{num}^{\frac{1}{2}}))\$ instead of \$\text{num} - c\ (\mathrm{O}(\text{num}))\$, where \$c\$ is some constant factor. That gives us the major time savings. You adhere to the Python style guide, PEP8, quite well, so I have no stylistic comments for you, except for the fact that could be a bit more descriptive, e.g., (you're using an editor with autocomplete support, aren't you?) Side notes: 

The operation you're looking for is known as a Cartesian product on sets. An implementation of Cartesian product for Java s is somewhat as follows (all s have the same generic type , otherwise we have to violate type safety, see below): 

Your format specifiers totally mess up the output formatting - don't worry, I'll (mostly) fix it in the full program below. Now, you see that we are repeating similar calculations thrice for one number. What this suggests is that we pass around intermediate results ("cache" them) so the process becomes faster. For this, we can combine all my previous suggestions into a whole program as below: 

For all your direction hierarchy, you are basically trying to duplicate an enum, which Scala provides no language-level support for. However, Scala does provide support for enumerations at the API level via the class, which should be extended by new enums. You could try something like this: 

In Python, the accepted style is to use names that start with capital letters as class and type names, hence variables should be: 

More useful and less duplicated code. (Why did you not think of implementing scalar multiplication in the first place? Closure under addition and scalar multiplication (and the presence of a null element) define vector spaces in general, and vector spaces of matrices (real or complex) in particular.) Some might disagree with me, but I think all indexed accesses and size declarations should use parameters of type , as that is the type deemed fit for this purpose by the standard. This means that all those s and s should be of type , instead of . Also, so should and . I would prefer calling them either and or and respectively, as there is less ambiguity about their purpose that way. Matrices are defined on either real or complex, not integer, scalar fields. I guess that the type of an element of a matrix should be , if not, at least . This will come in useful when calculating matrix inverses, as they involve division, and the field of integers is not closed under division. Everything that can be should be . That includes all function parameters, as you do not modify them or their contents. 

About - remember how I suggested it should return a list of the factors, instead of formatting them into a ? In this case, since the factors of a number should be unique, I recommend returning a , whose elements are guaranteed to be unique, and specifically use a , as does not store its elements in a defined order, while stores them (for our use case) according to their natural order. I recommend using a as an intermediate in this case, as the elements of this are only ever iterated in order and the number of factors of the number is not known before the factors are evaluated - thus it will provide performance characteristics better than a on large or highly-composite numbers with where the number of factors is large enough to require reallocations of the underlying array. Note: You'll need to use instead of , as primitive types are not objects and hence cannot be used with generic containers without boxing to its wrapper type first. However, with the advent of autoboxing before Java 7, the process is transparent and thanks to caching will not incur a large performance hit from object allocation for small numbers (less than 127). Try this: 

As I understand it, you'd like to make more elegant. In that case, why not try something like this algorithm: 

Pattern matching in functional languages is a very powerful construct, much more so than the simple in most imperative languages. The clauses in a pattern matching expression (a expression in Scala), match the patterns in the clause against the input argument(s) (and, optionally, also bind values to the results of the match). In Scala, pattern matching clauses are denoted by the starting keyword, which often occludes beginners from the power of pattern matching. Hence, both and denote patterns to matched against the argument, which in this case is the . Now, just matches the empty , as would for an empty , and for s is the exact equivalent of for s. This pattern not only matches the "head" (the first element of a list or sequence) and "tail" (the rest of that list or sequence), it also binds the values and to the results of that matching, in respective order. So, would cause to contain the first element of the , and to contain the rest of that , allowing for easily described recursion over the sequence. Note: The for pattern matching on s in general is only available in Scala 2.10+. I use 2.11, and I guess the OP uses that or higher too. For a lower Scala version, this behaviour can be emulated by converting the to a before the pattern match with , or by making a custom implicit wrapper for containing the appropriate extractor () method. 

Minor suggestion: As you do not mutate the parameter , you can consider marking it to indicate to the user that the parameter is not changed. However, as is of type , which is passed by value, not by reference, you can mutate it within your method without affecting the argument, in which case, you may choose to eliminate the variable. Overall, my suggestion is either: 

Implement multiplication of a matrix by a scalar (i.e., a real number). Then your subtraction routine becomes: 

to ensure that you don't consume the iterator of multiple times - creating the iterator might be expensive or slow, say reading from a file. This'll make the output come out in a different order from what you give us - it'll be a post-order traversal instead of a pre-order one (see below). Since @coderodde has already addressed the main point of iterators and memory-efficiency, this is more educational as you were asking for a recursive solution. Although this particular solution is not recursive, it does utilize the concept of divide-and-conquer with a base case, so it should be helpful to you. About trees: see if you can recognize the tree structure in this program. Hint: it is a balanced \$n\$-level tree where \$n\$ is the number of tuples, with each node having \$\left|T_i\right|\$ children, where \$\left|T_i\right|\$ denotes the number of elements in tuple \$T_i\$. In fact, the \$i^\text{th}\$ level is just the elements of \$T_i\$ repeated as the children of every node of level \$i-1\$. The output of this program is a depth-first search with pre-order traversal of this tree, splitting the output into words at each backtrack (recursion unwind). The output at any given point during the execution is the path traversed in the tree till that point. An exercise - try writing a program which explicitly makes this tree and prints every path from each root to each leaf, splitting the output into words at each backtrack. Here's an example tree for the set of tuples (note how each required word is the pre-order path from the empty root to a leaf): 

Unfortunately, this is more of a code dump, but this is the same thing does in Python, and here's a more succinct Scala version of the core idea: 

You know, this is a financial calculation. s are liable to roundoff errors. You should be using for financial calculations and for formatting numbers. However, in the interest of performance, I'll let this one slide. I don't do this in the code I provide below either. You should really have some sort of Exception handling. You should also consider JDK 7's try-with-resources statement, which I use, to simplify resource cleanup.