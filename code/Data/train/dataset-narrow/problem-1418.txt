Since you are, in essence, building out a class, I would think you should consider implementing your various properties and methods in more "class-like" manner (not necessarily ES6 type classes, but something ES5 compatible like I have shown below). This would allow for higher level of re-use for your Quiz class (i.e. multiple quizzes on same page) and allow for optimized performance of methods (because they exist on prototype rather than on the instance itself). 

Generally speaking, I don't find the naming of the library and classes as "Controller" to be appropriate. In modern programming, "controller" has it's own specific meaning that is unrelated to what this library does. More specifically: - is way too generic to convey meaning for what this class does - read and write files. - Use of or as prepended identifier to your class names to tell whether they are designed to be used in static or concrete context seems superfluous. Shouldn't the exposed class API make this readily apparent? 

This allows you to pass the language requested as a parameter to your script. Also, if the language segment of the URI doesn't match the languages your application supports perhaps the request falls through your rewrite rules and generates a 404 or 301 redirect depending on how you want to handle these requests. By handling localization settings early in the response processing cycle you could also do things like look at the user's browser Accept-language request headers, any user preferences settings (cookies, session settings, use preferences stored in database, etc.), to determine when localization should be rendered and performing appropriate redirects for those users. 

This also allows you to potentially tie different properties/behaviors to different types of favorites. If you don't have the need to customize different favorites and are concerned over creating/managing a large number of favorite classes, you could alternately have just a single concrete class where upon instantiation you check against a valid list of favorite types. In this case, perhaps consider extending this class from SplEnum so you can get enum-like behavior for your favorite types. This would take the responsibility out of the store to enforce favorite types. Also if you are treating this as a cache and your as a model for some record somewhere in a permanent store (i.e. database). Then perhaps this class has methods on it to persist to permanent store or instantiate favorites objects from the permanent store. So perhaps something like: 

It's an Apache config file. It isn't going to look pretty. :) That being said, I don't understand why you have RewriteCond specified for any of these rules. What is that condition preventing? The rewritten URL's are not causing redirect, so it is not clear to me when you would ever run into the condition of having "code" as a query string parameter. These conditions really don't make sense for case when you are adding trailing slashes, and if you truly are getting query strings in these trailing slash use cases, you are effectively stripping the query string out of the redirect as you are not using flag. You should consider using flag instead of just for these trailing slash redirect use cases in order to signal to the client that this is permanent location for the resource that is to be used. I personally find it easier to read through rewrite logic and have that logic to be less error prone if all redirects are handled first in the file, followed by more complex rewrite logic. Finally, if your app keeps growing in complexity to where you have more of these redirect rules being added, you might consider simply moving to more of a front controller model where you evaluate the URI in PHP and route within your application accordingly. 

First, from a styling standpoint, your classes are structured strangely. Typically, one would have all class properties defined as first thing in class, then the constructor as first method, then the other methods (oftentimes with public methods first with protected/private methods following). Don't mix your properties throughout your class. 

Ultimately, if you go with a dependency injection approach, you could actually remove this validation from each method, as you could then assure that valid PDO object was passed in constructor and set on object such that all other methods can reliably utilize it. 3) I think doing away with custom PDO Exception classes is the right approach, but the way you have now split up business and logging logic seems a little strange. You are at the end of the day now utilizing PHP's functionality vs. email as previously done. This seems to be an improvement. I think however that you moved too much of the business logic into these logging methods, as now the logging methods have a dependency on the DBManger object and are very limited in terms of use beyond DBManager use cases. In previous review, I suggested central logging mechanism (of which is certainly one example) vs. having the DBManager class directly email errors out. My stance really hasn't changed in that the DBManager class should know nothing about the specific implementation of the logging mechanism, only what logging mechanism to use. For this reason, I would suggest that these two methods might actually be methods on the DBManager class, because what they are doing is providing the business logic for forming the error message and then handing the logging of the message to the central logging mechanism. They could actually help bring meaning to the existence of that DBManager class if you need to provide some error handling behavior above and beyond what PDO gives you. 4) I don't understand the method at all. If you are relying on a central logging mechanism like , you should not have to deal with creation of new log files, this should be handled by logging mechanism. I also don't understand the return value for this method.What do remote and server address variables have to do with anything? I can see that you are trying to log to individual log files by class and date. I question the strategy of doing the by-class approach in that you might find it more diffivult to debug your application if you can't see a seeing of interconnected errors in a single log file vs. trying to go through a bunch of different files comparing timestamps and such. I would think the by-date functionality would typically be handled by whatever log rotation logic you have on the server, I don't know that I would want to enforce this in some class somewhere. 5) If you take a look at the PhishingController class, you will note a lot of repeated code. It seem like really there are maybe 3-4 lines of code that is truly specific to each method (to generate SQL and parameters). Outside of that the code commonly instantiates the DB, queries the DB, and handles DB errors. This could likely be refactored to a single method that these other method utilize to do the common work. I like that you are trying to catch multiple exception types and trigger different behaviors, but I wonder if this class is where that logic should be. If you take the comments above around possibly moving the error logging logic in DBManager class, then you could similarly have all this logic about when to log query error vs. connect error in DBManager class and not in this class. Think about it for a second, what happens if you get one of your two defined error modes that you are concerned with? Should the DBManager class own reporting and logging these errors or the PhishingController class which is using DBManager? From the PhishingController class perspective, why should it log DB errors? All it should care about is whether the query executed successfully or not, not whether the error get logged successfully. The only question you should ask yourself for the PhishingController class, is what behavior does it need to provide to it's caller in the cases where the underlying query fails. As shown now, the class just eats the underlying exceptions and an returns . This may be totally appropriate behavior, or you may decide that this class should in turn throw its own exception or rethrow the underlying exception if this method call is going to be critical and the caller needs to be aware of problems with underlying dependencies.