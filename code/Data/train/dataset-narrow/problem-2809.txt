UML is not one thing it is a collection of things some of them have value others not so much. the older style Use Cases (at least what we call use cases) that state 

I am working on a game that will be a 3D-shooter (camera trailing player), and want to impose some architecture on the game being that a is composed of where each room can hold (the player, enemies, pickups, projectiles), , walls/floor, and (more on these in a little) my first concern/iteration is to get a single room functional, and then link rooms together in a later iteration(this is so that rooms to render are dynamically chosen to accelerate render times on larger level). my direct question for this iteration is what would be an optimal data structure for holding my for the room? keeping in mind that whatever structure I use needs to be searchable, removable(single/group of items), sortable(this can be given up if needed), growable, and possibly be able to take pointers to the . this structure would probably also be used for my doors. my initial thought was to use linked list though removing items from linked lists can be a chore, and if not done right can just create a memory black-hole. I keep bouncing back, and forth on putting walls/floor into the same structure as the as it would be mostly efficient for collision detection (i think), but I know it can cause a graphics nightmare (more things being rendered means longer it takes), so maybe keeping walls separate, and create a separate list of walls to be rendered vs collisions. the next part would be linking the rooms together by doors(see picture bellow where the joint between each room is a ) where my first though was adjacency list. I understand that the has an adjacency list that it uses though I don't feel that it would work in my situation as just rooms , and / don't work within a so would it be worth while to build a custom adjacency list (might need to see an implementation as I keep getting lost on connecting adjacent things that should be connected) 

I have done a fair amount of play-testing, and those surveys tend to ask general what do you think of the game, and then go into specific details about specific things they are probably concerned about. if your concerned about what people think of the physics in a platformer then don't ask "how would you rate the physics" ask "what did you think of how the character jumped/fell" you can use scale values, but the data needs to be usable. if you just ask about physics, or graphics it is likely that Sallies Mom doesn't know what your talking about, or what it affects, and even if your giving a scale question then put something for "didn't notice" "don't know" some times if some one doesn't notice something as odd they will just think it is normal, and wont even register it. then by asking specific questions like "what do you think about X" if you get a high density of complaints then it is something you might want to take a serious look at. though remember that art is primarily for the artist, and then for the customer. 

When you select a object you should see an Animation Import Settings in your Inspector. There should be an option called , which selects a default animation mode: 

When you're rotating your phone and not moving it then the acceleration returned will lie on a sphere with Earth G radius. For example let's say your phone lies almost flat on the table - your acceleration X and Y values will be small and your method should work, but when you turn your phone 90 deg your acceleration X or Y will get its maximum value and your method will break. In practice, for rotations just around 15-30 deg you should start noticing some strange effects, like non-symmetrical steering in front-back directions. To solve it you could store entire initial rotation, computed from initial acceleration vector and during the game compute actual rotation and a X/Y differences between them. 

I'd consider a grid as a "base" type of tiles in any game. Such grid is simple to imagine and moves over this grid are simple to understand. It's also very simple to implement "under the hood". Those are few reasons why even the Chess game uses it :). Additionally, this grid helps you make "regular" levels, because and are natural directions here. So if you make, let's say a SimCity clone it's very easy to have perpendicular roads. The biggest disadvantage of grids is that they doesn't keep distances very well, because when you move by one tile in directions you basically move by one tile size, but when you move in directions like then you'll move by . It's not so big problem in computer games but it was a big flaw in board games. Because of this problem people tried to find some other way to divide 2D space, so the movements between tiles would be more similar to the real movement. It happens that the only possible way, better than squares is to use . grids are much better for strategy-like games because movements are more natural, but they are much harder to implement. They have also 3 main directions, where one of them may be OR but not both! So try to imagine a city with perpendicular roads built on a such grid... Personally, for a game like I wouldn't think much and used . In fact, I'd use squares in every game that is not a turn-based tactical game. But depending on your taste you need to choose your own. Maybe you'll want to make a one-of-its-kind, clone :) ? 

Why would you do this? I see no value besides having something that you can physically see in the editor, and when it comes time to run the game you wont be doing anything with these cudes as cubes, so why have them in the first place if your just going to take away their collision, and rendering. All you have left is a transform which you could have right away by having empty gameObjects. the easiest way to do nodes in Unity is to create empty gameObjects(mainly for the position), and then give them a script for all the variables you need, and then put all those nodes onto their own layer. EDIT (In response to request for more detail in comment): 

I meant having each agent have to do the same rounding that you do for your mouse clicks which is very value centric, and you end up having to do a lot of the same clean up work of hard coded values, and you get the same end run checks as when doing . but if you do just find the nodes nearest to here (its up to you if you want diagonals), and if you really wanted to you could use the same logic for mouse clicks instead of rounding values just ray-cast to find the nearest node. 

I would appreciate if someone would look over mt deriviation I used $URL$ I would suggest to copy to a text editor that supports side scrolling in my notation I used q^(-1) to mean conjugate, and not inverse, and different identifiers, but I hope that it is follow-able. I think that the majority is right especially where on proving the real portion of the vector would disappear. 

No. from an application standpoint think of an empty gameObject as a modifier that is modifying something, or nothing. I can create an empty gameObject, and then move it around the world/scene, and then I can rotate it, and scale it, but if it doesn't have any children nothing happens, but the changes are recorded. then if I take, and create a sphere, and make it a child of that empty gameObject then that child will take on those modifications, and have its own values stored with respect to its parent, but in essence of physical logic that empty gameObject is nothing (no size, shape, or anything), but it does have a transform, and can receive components. 

I'm not sure it's your exact problem but I had similar issues. It looks like Blender doesn't generate coords by default. Even if you can render your object with texture in Blender - it doesn't mean you'll have in the exported mesh. You need to explicitly add some UV channel - I don't know Blender very well so you need to look for some tutorials for this (But it's very simple, if you know where to click). In 3D MAX, when you create a basic object and select you'll get the out of the box. There's also a simple way to verify if that's the case. When your mesh doesn't have an channel but it's used in the rendering, then your values will be set up to defaults - which means that some corner texel will be used as a texture for entire object. Now, if you move or change your texture, so texels on the corners will have different color - your mesh should also change the color during rendering. 

I think the simplest way is to divide your terrain into grid and manage which grid tiles to load/unload. Let's assume you want to have 3x3 grid all the time, with one center tile under your player, and one additional tile in each direction. Now, during every frame you check if your player has moved to another tile and if so, you load new tiles in the direction of movement and unload the tiles that are too far away. After this load/unload phase you'll still have a 3x3 grid centered over your player. I can't make you a fine picture of it now but here's some sketch: link This way you can manage quite big terrains but there're some problems you should know: Tiles connection You need to make sure that the shape of some tile at its edge is the same as the shape of its neighbor (the second tile that shares this edge) or you'll get holes in your terrain. It's quite easy if you use procedural data, like Perlin noise but it's very hard to model such meshes in 3D modelling application. Grid size and scale You can split your grid into 3x3 or even 10x10 tiles. Every tile can be few meters in size or i.e. 1km - all this depends on your specific needs. If you manage many small tiles your load/unload times will be smaller but you'll do it more often. Additionally, when you make game like a flight simulator you'll need different setup than for FPS. Deferred loading It's not a 'problem' but I've seen some interesting optimisation that I could share. It was in the Terrain Manager for the Ogre engine. It was also grid-based but much more complicated, with Quad-Trees, LOD, tile stitching, etc. The trick was done during load/unload phase, where instead of checking they checked then the Manager loaded only this one tile and returned control to the engine. In the next frame Manager did the same check and loaded 1 another tile. In this simple way you can split your loading into multiple frames, which lowers your FPS variations. 

for without fileIO: it would look about the same, but instead the would be replaced with a method calls that performed the creation of the objects. I have done this conversion in a project where I was paranoid about distributing my level files, but I realized that even though yes someone could go in and modify the files, and cheat in that regard I was not selling the game, and if they broke it trying to cheat that's their dumb fault. Though this process does work, whenever I look back at that program it just feels like overkill paranoia, and possibly even breaking object-orientation 

you could just do a key binding (that is not normally used in your game) that modifies the game state, and then in some section of your screen print out specific information about what is going on. Keep in mind that I have not worked with the debug layer, but I have done this with output. remember that somethings are easier to see what is going on numerically (seeing that valueX is changing/not changing in this way), and other are easier to debug visually (it looks like that model is interpenetrating the wall) the biggest thing is figuring out is what information is really needed for you to know that everything is working or not. When I have done this in the past (was designing debug for keyboard) I mapped AI states/positions to one button, another button showing bounding volumes, another button outputting positions, and bounding data, and a final button that displayed every collision that was not purely Y (at one point I had things falling through the world, and had to just revers the bool check, but that a different story) 

depending on your target (platform/engine/framework) there are full communities of people, and many times there will be a section in these community forums whose sole purpose is "help wanted" (where people either post their skill set requesting a job, or post a job requesting applicants) for Example 

yes, and no. yes its the same in terms of physics, and rendering, but no in terms of the engines book-keeping. every fixedUpdate (especially in non-release mode) the system takes all components that a object has, and the same for its children, and puts them to be calculated, and then if any of those are not active throws it away. so its still trying to do stuff with the inactive components its just not that much. if you multiply this enough times it can amount to maybe an extra half second per frame, but that's probably up there. 

What I think you need is to create a object that will allow you to set up players position and orientation. Next, connect a object as a child of so it moves and rotates with your main object. Then connect a as the child of so it moves with , but can rotate in its own local space, so you can rotate a head. At the end connect a as a child of the and move it backward by some amount. This way a will be always at some distance from the , looking at it, regardless of the orientation. 

In a typical shaders, no mater if it's a vertex or fragment one, you have somewhere a dot product between light direction and surface normal. Then you have a check if the result is less than , which means your surface has light at its 'back'. Now, if you compute instead of just you should get lighting on both sides of your geometry. 

If your objects are not animated I'd make just a transform animation between first and the second. When you want to change the objects you just play the animation and stop at the end. If you want to change back, you just play the same animation backwards, to . When you objects have their own animations it gets more tricky so in such case I'd make separate objects and replace one with another when transition animation ends. This way you wouldn't have to worry about too many animations at the same time, in the same object. According to different types of controls: Implement both in your game, so you can play as the ice cube and as the water (with selection at compile time for now). Then store somewhere your current player mode and in all your input methods like MouseMoved, KeyDown, etc. add a simple and select which of your controlling code to run. 

It's not a full answer, but it's too long for a comment... From your question I presume you want to use a LOD system (geomipmap approach) and you're creating your mesh by cube subdivision, so why not to think about a LOD during both stages - mesh creation and rendering? You start from just a 6 planes, so it's really easy to tell which sides are connected. Then, when you subdivide one of the planes you know which neighbors are at the all 4 edges. You can also store the newly created, internal edges. This way you can create a hierarchical, tree-like data, where you start from 6 quads and every quad have 4 child quads. Having such data you can easily iterate over all LOD levels. You can even store the mesh data precomputed for all LOD levels, or you can create them on the fly, depending on camera move. There are really many possibilities here, but I can't help you more as I don't know what data are you going to need for your algorithm to work.