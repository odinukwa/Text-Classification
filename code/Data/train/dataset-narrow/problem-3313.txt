How do you revert the firmware on a non-booting Raspberry Pi 3? The camera not was working under Ubuntu 16, despite it running the most recent firmware. So I took some advice and tried installing older firmware, but now it won't boot and all I get is the Rainbow Screen Of Death. However, I previously installed Raspbian on a different SD card, and if I swap that in, it boots fine. Is there anything I can do with the Ubuntu SD card to fix it, so it boots? I mounted it on my laptop, and saw there was a folder. I tried copying that over to , but it still won't boot. Is there anything else I can do or is that SD card hosed? 

Is there a guide or list of accel/gyro/compass sensors that have well-documented code that are known to work with the Pi2/3? I've wasted several weeks trying to get various InvenSense chips to work (MPU-6050, MPU-9150, MPU-9250), and while I've found a ton of code for interfacing them with the Arduino or Pi, almost none of them actually work, and those that do only get raw noisy values with no way to calibrate. I was initially drawn to their on-board DMP, but it looks like InvenSense has discontinued these chips and has removed all documentation and source code for enabling the DMP functionality from their website. 

I've found that my Raspberry Pi2's HDMI port only works if there's something attached to it when the RPi initially boots. If it boots with nothing attached, and I later attach a monitor, nothing shows up on the monitor. My application is headless, but occasionally I want to attach a monitor to do debugging, and in those cases having to reboot the RPi risks losing debugging information. How do I configure the RPi to either keep the HDMI port "turned on" even when nothing's connected, or continuously poll the HDMI port and enable the driver when it finds something there? 

The problem turned out to be a bug in my router. When the wireless security was set to "TKIP+AES", it stopped broadcasting the ESSID, although I could still see the network via the MAC address from the Pi. Changing the algorithm to just use "AES" fixed it, so this wasn't a problem with the Pi. 

I'm trying to add a speaker to an RPi project, and from what I've read, the RPi's built-in headphone jack is nearly useless for driving even tiny headphone speakers. What is a good audio amplifier to use to power a fairly small 8ohm 0.5W speaker from the RPi's headphone jack? Can it be something as simple as a mosfet switch, with the gate connected to the headphone jack's signal pin? Or do I need to use something more sophisticated like the circuit outlined here? I don't have a lot of room in my project, so I can't use a generic off-the-shelf powered speaker. I can fabricate simple circuits myself, but I don't have a lot of resources or time to debug complex circuits, so I need something super simple. 

How do you cross compile C code for controlling the Raspberry Pi camera on an x86 platform? I'm trying to create a unittest for compiling and testing the code on a generic x86 continuous integration server (but obviously not connecting to the camera) but I get an error for a missing vcos library: 

How do you run a standard Raspbian image in QEMU? I'm following the instructions in this wiki, but the first step is failing. I downloaded the kernal and the Raspbian Jessie Lite image, but when I run: 

Google finds almost no results for this error, and the few proposed solutions I've found haven't worked. Is there any way I can fix this? Is it possibly caused by low memory? QEMU is limited to only 256MB of ram. Edit: I'm running the most recent Jessie Lite. 

However, I want to view this stream in a web browser (Firefox or Chrome) using the HTML5 video tag. Apparently, both Firefox and Chrome's implementation of this tag support the video format Ogg, WebM, and MP4 H.264. If I'm understanding the raspivid/gstreamer commands correctly, it's streaming and consuming H.264 video? However, when I try to consume this via the tag with: 

A 5-pin header labeled Pi-IIC, which the schematic shows goes directly to the Pi's SDA/SCL pins. A 4-pin header labeled Pi-ID_IIC that the schematic shows goes to some sort of on-board EEPROM. The Arduino Leonardo's SDA/SCL pins. 

Does the Raspberry Pi's USB need the 5V/GND wires in order to work with peripherals that are already connected to the same 5V/GND rails as the Pi? I have an application where a RPi is connected to an Arduino Uno via a USB cable. The Arduino acts as a "power manager" and when signalled, disconnects power to the RPi in order to conserve power (with the RPi disconnected, my power usage drops from 600mA to 100mA). Currently, there are two sets of wires going to my RPi. The main power line going to the RPi's power jack, and the USB cable going to the Arduino. To simplify wiring, I'd like to remove the 5V wire from the USB cable so I only need to use one transistor to "turn off" the main power line. I found that if I leave the USB cable in place, it draws around 200mA of current, which isn't enough to power up the RPi, but still enough to be a huge waste, so I either need to remove the wire entirely or use a second transistor to programmatically disconnect it. Will the RPi still be able to communicate with the Arduino over USB without the 5V/GND wires, since they both have a common ground? 

I've tried re-wiring the sensor to all of them, and I get the same error each time. I read about a bug in the Pi's I2C implementation which doesn't support clock stretching, which the BN005 makes use of. A workaround I've read about is to reduce the Pi's I2C clockspeed down to 50k. However, even though the sensor still works with the hatless Pi, it still doesn't work with the hat. 

This is caused by an incorrectly compiled kernel for the ARM platform. The images I was using weren't properly designed for the Pi. Unfortunately, Canonical doesn't offer any official ARM images, and most of the unofficial ones are poorly built. However, from this site I found this Ubuntu 16.04 image works perfectly with the Pi3. 

Firefox and Chrome say it's in an invalid format. Is there any way to get a low-latency video stream from the RPi that works with the tag? I've seen some examples of using WebRTC or FFMpeg, but these all have 20-30s of latency and don't work with raspivid. Edit: I followed these instructions to install UV4L via a custom repo and I managed to get the uv4l server running with: 

I'm trying to link an Arduino to a Raspberry Pi 3, running ROS, via a serial connection over USB. This is supported by the rosserial library, and it works fairly well for a few minutes, but then the code running on the Pi reports the Serial device returns 0 bytes, and afterwards, all reads from the Arduino fail. I'm able to fix it temporarily by triggering an Arduino reset, but this wipes any local variables and actions being performed on the Arduino. The time between failure seems to vary. Usually, failure happens in about 20 minutes, but sometimes it run for over an hour before failing. At first, since an Arduino reset fixes it, I thought the problem lay in my Arduino code, such as the heap was fragmenting, or there was some code getting hung up, preventing the serial write code from executing. However, I've added logging of my free heap memory and it shows I have plenty of memory, and I've disabled virtually everything in my Arduino loop(), so it's doing nothing other than send out a ping message every few seconds, and the serial failure still happens after an hour. The problem might still somehow lay in the Arduino, but I'm now investigating any causes on the Pi. Googling for "serial issues with raspberry pi" found me a few issues that sounded very similar to what I'm experiencing, such as this post that claims the getty program is sometimes blocking the serial port because it's trying to check to see if a user wants to login through there. I'm running Ubuntu 16, which uses agetty instead of getty, so I'm not sure if this case applies to me. systemctl does show that a getty@.service is running, but I believe this enables logins, so I don't think I want to risk disabling that and locking myself out from the Pi. Are there any other Pi-specific oddities that could explain why a USB serial connection would work flawlessly for short time and then fail? 

I'm assuming this is because the *.so objects in my /opt/vc/lib directory are compiled for ARM whereas my makefile is compiling for the localhost's architecture, which is amd64? How do I specify architecture in a CMakelist? 

Why is the hat preventing the I2C connection? The hat appears to have a total of 3 ways to connect via I2C. 

on Raspbian, it hangs indefinitely. Does Raspbian have some non-standard way of interfacing with services? Edit: Running shows that the process owned by root is consuming 100% CPU. If I kill this, this the service commands return immediately, but with a failed message like: 

How do you safely shutdown or halt the Pi without turning off USB power? I have an application where an Arduino is connected to a Pi via USB. The Arduino manages a battery that powers both it and the Pi. I'm now trying to setup a safe self-shutoff routine where the Pi runs so no files get corrupted by sudden power failure, and then the Arduino uses a transistor to cut power. Unfortunately, it seems that after finishes, the Pi turns off USB power. Since I'm powering my Arduino via USB, I was stuck with this paradox where I need the Arduino to remain powered so it can turn off the battery...but first it needs to wait until the Pi safely halts itself...but by then the Arduino has lost power where it can't turn off the battery, leaving the Pi still powered but halted while the Arduino is disabled. My hacky workaround was to modify the Arduino to track a heartbeat signal from the Pi, and once that's lost, then immediately turn off the battery. That way, when the Pi begins to execute , it kills the process sending this heartbeat, causing the Arduino to cut power. However, this doesn't reliably work because it's preventing full execution of and therefore sometimes resulting in data corruption on the Pi SD card. Ideally, I'd like to keep using the loss of the Pi heartbeat to tell the Arduino to shutoff, but add a 30 second delay to ensure has completed. However, to do that, I need to keep USB power turned on, even after the Pi has halted. How do I do that? 

A QEMU window pops up and seems to show it booting correctly, but then it says "rebooting in 1 second" and closes. My local terminal only outputs: 

I'm using PySerial to communicate with an Arduino Uno from a Pi. A Python script writes a short message to "ping" the Arduino once a second, and the Arduino writes a short message to respond. This seems to work fine for several hours, and then PySerial starts reporting write timeouts. However, I know the Arduino is still running fine because a routine that blinks an LED once a second is still running. What's really odd is that some pings do get responded to, but very infrequently. It's almost like the serial connection degrades or becomes out of sync over the course of a few hours. If I terminate my Python script and re-run, it immediately works again. However, my application needs to eventually control a motor, so that kind of downtime is unacceptable. How can I diagnose this problem? Due to the slow speed of the read and writes, I've ruled out the Arduino's serial buffers getting overloaded. I'm also using a short and properly shielded USB cable, so I've ruled out interference. I'm trying to initialize my Serial instance using different options, to see if it's a configuration issue with PySerial. Here's what I'm currently using: 

What is the maximum safe voltage to supply to the RPi when powering it through the GPIO pins? Due to size restraints in a project, I need to supply power to my RPi through the GPIO pins instead of the micro USB plug. I plan on using a UBEC that provides 5V@3A. However, when I measured it, I found it's actually outputing 5.3V. From this thread I read the RPi's "safe" input voltage range is 5V ±5% for a max safe voltage of 5.25V. Am I pushing it with 5.3V or should that be fine? 

@LiWi's answer will work temporarily, but the permission change will be lost once the device is removed or the server rebooted. A permanent solution is to add your user to the group, which will allow it to access serial devices. 

I was then able to access the web UI at . It also serves a page for streaming mjpeg that works even outside the server: 

How do you diagnose slow computing time issues on the Pi? I have Ubuntu 16.04 installed on a Raspberry Pi 3. All Ubuntu package updates are installed, and I've installed the most recent Pi firmware. However, for simply operations, like extracting small tarballs or installing a package, the Pi can take 30 minutes or more. What's really odd is that if I run or , it shows no CPU activity and very little memory usage during this time, so I'm at a loss for why the operations are taking so long. I've read the SD card can be slow, so I measured it's write speed by running: