If we go by your initial presumption, that anything in one line is faster than something that spans multiple lines, the second method should be loads faster than the first. Even if we look at the number of functions calls, that should be true too. In reality, however, it's the first method that is the fastest one. This is because it's written with the knowledge of how every line of code works in the inner bowels of PHP, and an understanding of how that affects the data which is fed to it. Of course, that also means that it can vary who's fastest depending upon the exact data which you feed them. Which is the only way to properly optimize code, and why it is generally discouraged to attempt for those who are still learning. 

As previously mentioned by @GregBurghardt, just because you can doesn't mean you should. All of his reasoning holds true, and code readability should be your primary concern when writing code. Code shortness is one of the methods you achieve this, but if the code becomes too dense it is actually detrimental to the readability. Which, in turn, will lead to more problems with bugs and inefficient coding(!). I recommend doing it in the following manner. It will keep the repeated code to a minimum, while still ensuring that there are no warning/notices about missing variables or erroneous data. Plus it's very clear what the code does, and easier to understand why. (Comments can/should be added to further clarify why.) 

What you are attempting is called "premature optimization", and is quite discouraged in programming. Not only because it has no benefit for the runtime of the code, or anything else really, but also because the high risk of making the code consume even more resources. In this particular case the IF-construct is faster than the ternary operator. Not by much, granted, but it is still faster. Which makes the change proposed not only more difficult to read, but also contrary to the desired effect. Basically it will be neither faster nor easier, though it will be more "inline/one-liner". Though, I don't think that sacrificing both speed and simplicity is worth it to get it on one line. Example: Which of these two methods do you think is the fastest, and why? 

First off I'd change the line retrieving the DB variables, from your $my_env array(?). I would rather implement a DB connection factory here, or even a singleton if it's a small enough project. (Or to learn singletons.) You've set the timezone using the old date_*() functions, which aren't really recommended any more. I strongly recommend looking into DateTime class family for date-time related needs. Even though you've set the timezone, the code you've posted doesn't actually use it. You've used SQL's NOW() function instead, which uses the DBMS' timezone. This can be an issue if the PHP code and the database server are using different timezones, and you're later on using PHP to manipulate/compare timestamps. You don't need to close the cursor, unset variables or anything like that. PHP normally does a perfectly good job of cleaning up afterwards, and it might even be detrimental to prematurely doing "cleanup". Normally this is only done when you have a specific use-case which requires you to clean up early. You have what is essentially three return values, to communicate whether or not the query succeeded. You only need one, which should be either "0" for not OK, or the ID for OK. Any error messages or such should be added to an error log, by a dedicated function for this. This one ties to the above, as the code should really be made into a function/method. This will allow you to maintain the code a lot easier, and make things quite a bit more flexible. The try-catch block encompasses a lot more code than it needs to, which makes it a bit harder to follow the control-flow than necessary. One should only encompass the functions that actually can throw exceptions, if one doesn't just let them bubble up to a layer which can handle them in the proper location in the code-flow. The connection class you have seems to have nothing to do with neither databases or connections to do, in fact it doesn't seem to following the OOP principles either. A method that simply takes input and returns output, without altering or depending upon the state of the object, isn't OOP. It just normal procedural programming, which is better done with pure functions. ;) 

Make your function parameter . Although C++ is call-by-value, making it explicitly and mutating a local copy of the variable is never a bad idea, and it does make your function contract that much clearer. On the performance side, since on any reasonable computer will have maximally 16 bytes (64 bits of 8 bytes is the case for all common architectures, except for probably some microcontrollers which will have less, even as less as 1 byte) (note that the upcoming RISCV architecture does have a native 16-byte (128-bit) integral data type, but the 64-bit one is the default), you can easily make this function a template, such that the computation of the byte vector can be done at compile time without much overhead and incur no runtime overhead. You can probably even pre-set the capacity of your utilising . Although I'm not sure if this suggestion will work in the constraints of your application. 

I left in the debugging print statements as I feel that they make for reasonable documentation. Side note: Please use functions and proper variable names, like the ones I introduced. Note: This has not been tested with the UVA Online Judge, only on my PC. PowerShell screenshot of timed run: 

The keyword before the method parameter - which I named , because that makes more sense than : it signifies to the method which called that it will not change . Note that this modifier will also prevent any reassignments to , which is OK as you don't reassign it anyway. The spacing, bracing and indentation illustrates my above points. 

You'd retrieve the result with a dictionary lookup similar to . You'd simply do preceded by , where is the name of your dictionary variable. 

Simple, succinct, and to the point. I'm absolutely sure your code is overcomplicated for its intended purpose, and functional programming is not just about pattern matching and recursion, it's about being able to create greater functionality from pre-existing functions. 

And why restrict yourself to arrays of ints? With generics, you could have the following modifications and make this rotation routine work with all types of arrays of objects (note that is not an object, it is a primitive type, you'll need to use , which is the object-oriented wrapper type for , instead of . Same goes for and other primitive types, you'll need to use arrays of their wrapper types, look this up). 

Try using and it's method instead of repeated string concatenations. As an additional point, you could set the capacity of the on instantiation to the maximum expected size of the output, to prevent array reallocations. That is, replace where is a , with where is a . s are mutable and avoid the object allocation overhead of concatenations. 

(similarly for ) Rely on type inference: In Scala, it is unnecessary to declare the types of most values, as they can be inferred by the compiler, and this does not decrease the readability of your code much unless the declaration is extremely complicated or the inferred type is unintuitive/incorrect. This makes your value declarations in look like (incorporating some of my other suggestions: 

Style You have inconsistent indentation and spacing. If you are using some very simple text editor like Notepad for writing your programs, you might one check out editors with auto-formatting of code, or use an IDE. Also, you don't have proper whitespace surrounding binary operators. Finally, your variable names are somewhat nondescriptive, but in this case it would have been OK if you had properly documented your methods. 

for brevity, readability and to not have redundant checks. is not that expensive, still no point in calling it more times than necessary. I'd advice against having HTML in your classes, as you do in . Simplest solution would be to create an array of your database results, return the array and construct the table when it's absolutely necessary - at the script you actually show it. Moving on to , is called every time is called, and that's absolutely unnecessary. Not really an expensive database call, still redundant, you can safely move it into , it's a call that only needs be done once, just after you connect. In general, avoid functions, they are essentially obsolete, kept around only for legacy reasons. Their use is discouraged in the manual: 

Points 1 to 3 are user interface specific concerns. In an MVC approach they belong to the View and not in the Controller. Point 3 can be a user interface concern, if the texts are static, but can also be viewed as a data concern. The same way you get data from the database, you could collect all these static texts in a configuration file and only have to look at one file to change them across every View in your application. That could be considered a Model approach. Having said that, this: 

The first clause, essentially checks if there's an "old_keyword" index in the array (and whether it's or not), that's a pretty typical check for arrays. The second check, that executes if and only if the first one passes, checks whether what's in is not the same as what's in . I'm assuming that the author had some reason for that, but can't imagine what that reason is. Summarizing what happens here, if: 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

at the top of your (external) script, and then use instead. Do it for all your objects, even if you're using them once, it will stay with you as a (good) habit. Avoid inline CSS Consider moving all your style declarations into an external CSS file. Other than a slight performance gain (similar to external JavaScript), you'll have all your style declarations in one, easy to find, place. 

Everything seems to be working as expected (repo, with a simple demo). Since this is my first plugin, I'd be particularly interested in critiques of its structure. That said, as always in reviews, any aspect of the code is fair game for criticism. The plugin code: 

Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject.