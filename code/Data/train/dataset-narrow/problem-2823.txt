I was wondering if there is a design pattern that would easily support such a syntax. My initial thoughts were to create a thread for each script object and have the wait implemented similar to below: 

I am guessing the jittering starts as the Z number goes into the thousands and worsens as it goes into 10,000 e.t.c. The levels of the game won't extend past 10 minutes so my solution doesn't need to work past a certain Z value but the current solution doesn't work past 30 seconds. I cannot change to double precision as I am using the XNA built in structs which all use floats. I also want to avoid scaling everything down as I don't want to rescale all the assets in the game. Is this another solution to this problem? EDIT: The game is fixed time step and I changed the code to make the scrolling every frame a constant amount. I have done some further debugging and I noticed that if I do the following conversion: screen coords -> world coords -> screen coords. All using XNA inbuilt methods. I see that the ranges of the delta between initial screen coords and output screen coords gets larger over time. This means to me that the drawing code is likely correct and it might be something to do with the conversion code or the camera itself. I have fixed the mouse cursor position to the middle of the screen and I have checked that the scrolling logic works correctly. It does a simple addition of z:-1 every frame. The calculation of the viewMatrix: I don't think this is the culprit but the code was as follows: 

I have a simple scrolling camera positioned 2000 units about the 3D 'floor' that moves forward by 1 unit every frame and looks down on the floor at a point that also moves forward by 1 unit every frame in the same direction. I am then drawing a sphere where the mouse coordinate ray (unprojected from near plane to far plane) is intersecting the plane parallel to the floor plane but at height 2000 (the same plane that the camera position is). I am using this technique to acheive this: $URL$ The intended behavior is for the camera to be looking down at a scrolling world and the sphere to exist on the 2000 height plane with its center where the mouse is pointed at. This works fine for about 30 seconds, but then I notice that the sphere starts jittering forwards and backwards after a while, this increases with time. The scroll direction is only in the -z direction (forward) so it seems related to the growth in total scroll amount. I am thinking this might be a precision problem. I debugged the first three sphere location calculations and got these results: 

Which is meaning after frame 60 shoot the player every 30 frames. The frame-count is important as the game is fixed frame-rate and everything is relying on this at the moment. There are many small scripts for enemy behavior like above and I currently iterate through each one calling update(). I have realized it will quickly get unweildy dealing in absolute frames and I want to move towards a pattern where I can specify to do X for 60 frames then do Y e.t.c, something that is easily understandable and easy to write. I want to go for something like below: 

I am assuming you are using some sort of pre-created bullet pool and every time the player shoots you call the above method? I would do the following. 

However I realised this would not be optimal performance wise and would quickly become complicated for more advance actions (such as smooth movement along curved paths e.t.c.). 

The conversion of the screen coords (Mouse) to the world coords. yPlane is set to 1000f (height of the sphere). 

I am designing a new game and I am trying out the entity-component design where entities are comprised of groups of components holding a bunch of attributes. I also have a stack of 'game states' and 'game systems'. On creation, a new state grabs a bunch of (singleton) system s from a provider of systems. The systems are created at the beginning and maintain a list of entities that are relevant to it by inspecting what components are on the entity. At the moment I have the game logic within a bunch of 'systems', the state simply maintains a list of systems to update/draw. I realize that the state should really be holding all information relevant to the state. For instance the state should be holding the information on who's turn it is e.t.c. I have it so the system stores all information on the state at the moment and accesses it via the observer pattern. This is turn leads to all sorts of problems as it pretty much couples the system s to the state + it makes the code pretty messy and inefficient. For instance I have a movement system that is interested in entites with the 'movable' component. The system needs to read from the state who can move at this point. How far they are allowed to move and also controller input to actually do the move. For each of these things I must access the observer methods to modify the state from the system. The game is turn based at the moment and one of the states is a movement state, it has two systems registered to it, a movement system and a camera system which it updates in turn. At the moment the movement system gets from the state an entityId representing the 'selected' entity and checks input to see if the player is moving it. If moved the 'location' component is updated on the entity and the system stores the location onto the state via the observer. The camera system then looks up this location on the state and updates the entity with the 'camera' component with this location. The solution I have at the moment does not seem elegant at all and it is extremely long winded to implement even simple functionality. I am thinking I am doing something fundamentally wrong with the design. I have a few questions that come to mind: 

I solved this problem by making everything relative to the camera position. The camera view and projection matrices don't ever change. The scroll is added to the world transformation instead of the camera position/lookat. This means that since everything on the screen is relatively close to the origin (where the camera is looking). The precision of the float is kept high as the value of the float never goes into the 1000's meaning the precision of the fractional component is never below 3 numbers. 

Create a bullet creation method - Instead of hard coding the logic of setting the velocity and position you can encapsulate this in a method: 

Get the 3D world position at the center of the sphere. Use Camera.WorldToViewportPoint to project the point to the viewport plane. Move a Sphere Collider with the radius of the sphere to that point. Test for collisions using unity colliders. 

I would decouple the particle type from a specific emitter. Have a base emitter and have it work with different particles. For instance you can derive a SprayEmitter class deriving ParticleEmitter and you pass it the particles you want it to work with. The emitter can then call Set position on the particles to move them where you want them e.t.c. Essentially the Emitter takes care of how particles are emitted regardless of their concrete type and the particles are only concerned about updating themselves. I guess the above would be best achieved using a function pointer in the emitter with the signature to return an abstract particle. You can have a class sitting above the emitter that will pass it a function that creates a particular concrete particle so when you call AddParticles you can call this createParticle function and add the return to your array of particles in the emitter.