should be a boolean instead of an integer. Rust has a built-in boolean type, , and the keywords and , which you can use instead of and . 

Don't put a space between an identifier and the colon that precedes a type ( rather than ). Put the and the on the same line. 

You don't need to define the variable as mutable if you move it inside the loop and take advantage of the fact that and are expressions. 

Instead of using the crate, I recommend you use the crate. It's not as low-level as and it has more features. For example, with , we don't need to add a magic value in . 

Unfortunately, the way you've written , that's not true. The following test compiles fine, but invokes undefined behavior (which happens to manifest as the test passing on the Rust Playground): 

Strings in Rust are encoded in UTF-8. Standard library functions operate on Unicode code points, so both the string and the separator can contain fancy characters. 

If you want to combine the result of with the range checking in a single operation, that's possible too. First, let's look at the "lazy" way, where both error situations will produce the same error message: 

If you were to take by mutable reference, rather than by value, then the original variable would indeed need to be declared as mutable. You could not invoke the function with only an immutable reference, because closures can't be invoked from an immutable borrow. If that's a problem, switch to instead. 

Here, we have three cases to handle, so I'm using a expression rather than an expression. I'm taking advantage of the fact that patterns can match "deeply" to match on two levels of enums at the same time. also has an method, and naturally, the closure must return a . I moved the closure out of line to keep the expression being matched on short enough. 

You can use instead of . This requires adding calls where the compiler did a copy when the bound was present. 

The second in ends the function, so we don't need the operator. Instead, we could use to replace the data in the variant while keeping the the same, and then just return the result of . 

From the readability point of view, I'd suggest to keep some maximum line length, like 72 or 80 characters. Beyond that it's difficult to read. Also instead of having , declare your own data type with 3 constructors. Not only it'll be simpler, but the constructor names will also be more descriptive and it'll be easier to understand what's going on. You should also document the function better, it's not clear what the argument is without thoroughly inspecting the code. A small improvement is also replacing nested s with a statement. In general, I'd say that it's not really possible to make a genuine single-pass solution. Obviously we can't avoid checking the last element, if the list is a palindrome, and we need to have the first element to compare it to. So we'll always have to either get to the last element at the beginning, or keep the elements as we traverse the list, to have them for comparison when we get to the end, So we can't get to the situation when we just traverse the list from the beginning to the end, releasing the elements already traversed. In your case, you're also traversing the list twice, although it's somewhat hidden. The first pass is the recursive call to , which gets to the end of the list. And the second traversal is occurring in the line 

Instead of two types, and , which were holding outputs of the different insert operations, let's have just one, parametrized by . 

Update: The signature also isn't correct. The general rule is that the folding function should have one additional argument for each constructor of the data type where recursive types (here ) are replaced by the result of the fold: 

Below is code based on the above ideas, with some more optimizations (to improve sub-list sharing), left as an exercise to analyze: 

(I'm making my comment into an answer.) You can separate everything that is static (not using the state of instances of ) into a companion object (and import the object at the beginning of the class for convenience). This way, it is clear what functions use directly or indirectly (by accessing class variables). This often helps me make my code clearer, and prevents stupid mistakes such as confuse class variables with function arguments etc. 

On the first match, when is a , will contain a reference to the . When we get to the loop, is now a reference too. Generally, when we iterate on a reference to a collection, the iterator emits references too. Indeed, is now a reference to a . Here, I wrote to match the dereferenced value (note that this doesn't necessarily copy or clone the whole ) because we bind values, which are cheap to copy, so we bind them by value, not by reference. Finally, let's simplify these nested matches. Let's look at first: 

Additionally, considering the way you've written the prompt messages, it looks like there shouldn't be a newline after the prompt, so I suggest you change the that prints the prompt to a . Here's the revised code: 

You don't need to do that, since returns a , and is the maximum value. A condition such as would always be false. 

Here, I'm using to convert the to an , because I'm too lazy to define an error type that unifies the parse error and our new out-of-range condition. Then I'm using to perform the range validation only if the parse succeeded. The closure returns if the value is in range, or if the value is out of range. Instead of using , we could also use the method provided by the crate. It takes a closure that returns a , and returns if the closures returned , or the original value otherwise. 

Now, it's up to you to decide whether combining the two validations is worth the additional complexity or not! :) 

Instead of having a mutable variable, I'd factor out the code that decides if a number is prime in a separate function. We can use early returns to avoid defining a mutable variable. 

You use an implicit and an explicit return, but both could be expressed as implicit returns. Alternatively, change the path to use , then you don't need an block and you can reduce indentation: 

If you really need a , then you'd need to define as and write instead of . However, I would do this differently. I'd write a function to turn a into a slice of bytes (), which would encapsulate the only operation of the program. Then, we can use a simple loop on that slice to print each byte. 

This component built using is very simple. It just sends its input to the output, and keeps the count along the way. Notice that this conduit doesn't need any , it works with any monad. Now it's easy to filter a stream of numbered lines with a pattern: 

For iteration inside you can benefit from and take the -th element of the output. Note that thanks to laziness, you don't have to care that further elements in the list are not defined. 

Plus points for including top-level signatures (just missing for ). Some style nits - in Haskell it's uncommon to omit spaces between a function and its argument, rather than it's more common to write . And include spaces after commas in lists. More importantly, as you probably observed, your method is quite inefficient. Just try to compute its value for 4000 or so. First, you sort the sequence every time. Second, you generate the whole sequence again in each step, just a bit longer. For the latter, a solution is to memoize the results, so that you compute each such intermediate list only once. This would look something like: 

What you are experiencing is a common problem that occurs with threads and lazy evaluation. What happens is that the thread creates only an unevaluated thunk, which is passed through to the main thread, and evaluated only then, and the exception is thrown there. This is also a very good example why using exceptions in pure values is a bad idea (but of course if you're making a library like this you have to take this possibility into account). The solution is to fully evaluate a value inside the block, so that any exception that might occur is thrown there. For this we need a combination of two functions: and . The former creates an action that forces the evaluation, the latter one performs deep evaluation (to a normal form, not just to a weak head normal form). Also you might also want to separate the return value from the thread action. If you're not going to operate on thread actions, you can even omit them from the data type, as once you start an action, all you need is the channel. An updated solution could look like this: 

In general, using for the error type is not a good idea, because taking a decision based on the contents of a string is not very robust. It's preferable to define a struct or a enum that implements the trait. The trait also makes it easy to compose errors in a complex program. Normally, iterator adapters take ownership of the original iterator. This is true of the iterators in the standard library; for example, takes by value, and the struct doesn't have any lifetime parameters. The reason is that an iterator adapter often consumes the original iterator to perform its own iteration (assuming it is driven to completion). On the other hand, yours takes the original iterator by reference. This is less flexible, because it means that I can't write a function that returns a unless I received an iterator of bytes as a parameter (I can't return a that refers to a local byte iterator, because the byte iterator would be dropped when the function returns.) There are cases where it's useful to use an iterator adapter without giving away ownership of the original iterator. For these occasions, we can use to give a reference to an iterator to an iterator adapter. Mutable references to iterators are iterators themselves, thanks to a blanket implementation in the standard library (). In your iterator's method, the in the loop in superfluous. I only write when necessary; when I see a , I expect to find some code after it, and when there isn't any code, it makes me wonder whether I missed something. In your iterator's method, you use to refer to the encoded string and to refer to the decoded string. and are similar terms that don't carry any meaning. It might be clearer to name them and , respectively. 

Note that the function plays a very important role that would be lost if it was inlined (by hand): the lifetime of the returned byte slice is tied to the lifetime of the input parameter. It's as if it was written thus: 

The parameter doesn't have to be a , it could be a slice instead (). However, if you had used a non- item type ( is ), then in order to return individual items from the input , you'd either have to the items or move them out of the (using ). You've implemented binary search by hand, but the Rust standard library provides a very flexible implementation via .