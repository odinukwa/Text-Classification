Review Please don't use on the gobal scope. It's considered bad practice. Next, try to keep the scope of your variables smaller. Also indent your code properly to make it easier for you (and others) to see the program flow. Don't include . It's not a standard header. It's somewhat OK in programming challenges, but you should use the proper includes in your real/production code. If you use a smaller scope for your variables, you will also be able to use better names for them, for example instead of and instead of . If we apply these changes (and translate your names into English), we end up with 

A character goes in, a character from the key goes in, we use the function to shift and create the result, and then we continue on our other words and keys. Here's at once: 

Note that you don't need a type signature on those local functions. Indeed, they can be misleading, because the in is not related to the in the outer function. Don't shadow library function names is a name that's already imported via . Since we now import our containers as qualified, we can simply provide our own function to get rid of : 

However, as you've noted, it does not yield the same result as your variant. Here's the exercise, though: write an iterator that provides your behavior. 

That way we will always have a current value. The initial empty memory is the same as yours, except for the pivot value 

A mixture of both is more appropriate. may exit even before the amount of seconds is over, so if you want to make sure that you don't exit to soon, you have to check the current time: 

We can stop as soon as our needle is a prefix of our haystack. However, we're basically checking all tails of here. And there is again a function in that yields those for us: 

There's a great saying in carpentry: measure twice, cut once. It concerns cutting wood or other material, where you have to throw away your resources if you accidentally cut at the wrong place. A similar saying is there for software engineers: you can't optimize what you can't measure. There are several ways to measure your code, e.g. benchmarking, profiling, or looking at the generated assembler to see how many instructions a certain part of your code will take. Here, we will take the latter route, start with the assembler, take considerations step by step and see where we end up. A study in assembly Lets have a look at your code. Well, not yours, but the assembler the compiler generates. You can use . On my platform, this results in the following "hot" section in : 

The function didn't really get shorter, but it's now easier to reason about its behaviour. Now it's time to talk about . You had about a screen page to think about it, which isn't really much time, sorry. But what's the current problem? Why is it a bad idea to use it in ? Because you have to traverse the whole list for every insertion. This would change your current from \$\mathcal O(n)\$ to \$\mathcal O(n^2)\$. So how could you fix this? It's somewhat easy: You have to remember not only the first, but also the last element of the list. A . Note that this will make all functions that remove elements more awkward. Your current implementation works, but if you want to have an \$\mathcal O(1)\$ , you really need another pointer in your . Further remarks Your implementation is fine, but it is. Hm. Not very helpful. You can only insert things into your list, and you can check whether something is in there (and remove it). The following functions would at least help to access some elements: 

Hm. just cycles through and skips spaces. We can implement it without and if we hand it two lists: our secret, and our d key: 

Alternative variants Truth be told, that looks somewhat silly. We can just use instead of , or even : 

There's not much to say, to be honest. The type signatures are all there, which is a plus. Communicate possible errors and make functions total However, has two possible runtime error sources: (which is partial) and , since the latter can return a . Therefore is partial too. In Haskell, we try to keep the partial functions to a minimum. can fail, but it's type does not communicate that to us. Instead, should return as . We can use to communicate another possible error, namely an empty : 

all your s need to allocate, even if they never get used one cannot use with types that don't support default construction 

The random number is part of the game, so it's a little bit strange to generate it in . Your function already suggests a name for a another function that takes care of that step: 

That's a convenient small function and makes it possible to change our later without changing too many functions. For our we want to get the next player as well as queue them to the back of the line. A list isn't the perfect data structure here, by the way, but we keep it for simplicity: 

Before I post the result, let us verify that this really does the same as yours: for a single \$p\$, you created a list of all non-divisible numbers that were also in . Therefore, you ended up with: $$ \{x \in xs \} \cap \{n \in \mathbb N : n \neq 0 \mod p \}$$ Which is almost literally in the code above. Now for the result: 

We will revisit Caesar later. Vigen√®re First of all, let us apply the point-free to non-pointfree conversion and use pattern-matching in : 

We could also use since we're using , but that's not important. It would fail if we used , though. Now that we've reused , let us have a look at : 

The code can be written cleaner if one removes the from . has access to all bindings in its context, including the ones in . A first step to declutter is therefore to get rid of duplication and get rid of unnecessary parentheses: 

Both should return , but on the first list returns and on the latter . Make sure to your list, or state in the (currently missing) documentation that your list has to be sorted. Also, using twice is rather slow. Instead, the first elements up to and then take the : 

Whether that's easier to understand than your original variant is left to you. However, we can also get rid of the intermediate : 

This is an exaggeration, but you can be as verbose as you like. This kind of commenting has a big draw back, though: it's easy to accidentally enter a comma or period by mistake and end up with broken code. Conclusion All in all, well done. The if-else-logic is a nice brain teaser, to be honest, which makes an proper comments a lot more important. 

Exercise: Try to rewrite with or even (the latter only needs an additional constraint). Bottom line Other than that your mutable code looks fine. I would change slightly so that there is only one temporary element, though: 

That's it. We now have several functions that can be used independently but act on the same state. By the way, the single hints that the amount of s isn't really part of the , but could be used as the return value of instead. For completeness, we can provide 

That's a good question. The answer is: yes, is a right type, but it's not the right type. Most of the time, you want to use the result of in some operation that wants an , not a , just like you want to use . Note that I said that is a correct type. You can of course use . 

*ahem* is an overkill for this program. It needs the package. Also, if a number is divisible by \$k\$ of your \$K\$ divisors, your algorithm is \$\mathcal O(K + k \log K)\$ (*), so worst case (\$K = k \$) you will have \$\mathcal O(K \log K) \$. This is due to the definition of . Compare your with the following variant: 

Why is the necessary? First of all, will make sure that we don't accidentially change your string in our function. And will get rid of additional copies that would happen throughout the execution. Note that we can get rid of : 

In this case, 's type would be too general. So keep that in mind. Other than that, I would prefer to use the simple cases (without ) first, so that the function doesn't get fenced by itself. But that's personal preference. However, there is already a function called in . You should try not to use names from , as it can lead to very interesting results if you change your code, e.g. 

Note that makes it easier to change the other types, as there is less repetition. It's completely up to you to write like this, though. Encapsulate possible errors in the type (if possible) In consider or instead of : 

We can use or to see that it's possible to convert between vectors arbitrarily. This means that we can, by a small unfortunate accident, create a function that will happily compile: 

Unfortunately, you cannot expand , since content in parentheses (like this) does not lead to a new sentence. Note that and aren't valid in some languages, though, they require and , so it's not clear what you try to achieve there (see comment above documentation above). So all in all, well written, but without additional explanation or documentation there is no way to check whether the function actually does what you want. I also suggest you to add some tests. 

Here's a mnemonic: if one of your functions is a dual to another, and one of these uses , the other one should likely use . is the dual of . The first uses , but the latter is missing . Is the queue empty? Let's use a : 

Next, try to initialize the variables instead of just declaring them. While we're at it, try to come up with better names, e.g. instead of 

It would get rather tedious to do that in your current program. We would need , you get the pattern. So instead, we should try to handle all the items the same way in a single block of code, if possible. Which brings us to the next topic. Reuse information At the begin of your program, you have . However, you don't use that information to your advantage when you ask the customer whether they want to buy a bagel: 

Turn your world upside down However, we can also turn the triangle upside down and start with the longer lines: 

"I would have only space for three digits, but in my assignment I use !" But we're not done yet. Keeping the example with negative numbers from above in mind, what goes wrong in your actual counting? 

that rotates a string at once, so that you can transform a whole line instead of a single character. 

Unit tests should be put in the file they're testing It's recommended to put the unit tests into the same file as the functions you're testing. This prevents your code from getting out of sync with your tests more easily. Also, you don't want one single large for all your unit tests. Use proper types in traits At the moment, as soon as we use any function from , we end up with a :