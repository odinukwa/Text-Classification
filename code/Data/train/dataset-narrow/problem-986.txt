Reason is to avoid accidentally breaking the if-else construct, by introducing new solutions.Consider this: 

You can write e.g.: "The implementation of {@link #save() save()} function is optional." Same holds for the JavaDoc of the method itself. 

First of all, in my opinion, both the algorithm is nice and interesting, and the code is really well-written, broken down into easily understandable functions! Well done! The only addition that I can make are corner-cases (and their possible fixes) for some of the helper functions. However, please note, that from the main entry point, I did not find any way to trigger these corner cases, so, from a user perspective, the program works well even without the changes below. Corner case # 1 

Out of scope The quality of the hash-functions used for testing is out of scope of this review. (I know there are much better ones, but for now I focused on the data-structure itself.) However, if you know a way to e.g. better organize them, and avoid repetition (but without making that global!), that would be very appreciated. The code 

(Of course, you can make it atomic as well, if it should be thread-safe.) Another possible solution would be to have a , which takes care of creating 's. (In this case, I recommend somehow hiding the constructor of , e.g. make it package private, and put the in the same package as the factory. Or have the factory return only an interface which the internal implements.) 

As it seems my intention on what should do and how it works weren't very clear. So here is what the example will do as instructions: 

The new function might seem a little bit difficult in the beginning. All it does is to calculate the next step equal or greater than the current in the direction of : 

You could and should read the user inputs into variables of types that represent what you are doing with them best. E.g. whether the user wants to invert or should be a boolean. For the operation I would recommend declaring an enum. I would also print messages about input errors directly where they happen. If a user already enters a wrong operation (e.g. "XOR") in the first question, why should you let him enter two additional values before you tell him. Additionally your messages can be more specific. Checking/Comparing user input that is not required to be case sensitive is easiest done by making the user input upper case (or lower case) and compare against the wanted/required values in the same case. This method is also less frustrating if you don't need to retype as you accidentially typed . If the user enters something invalid you can also force him to enter a valid value by using a loop that doesn't quit until something valid was entered. And last but not least you output. You can completely stream line the way you do it by "calculating" the values depending on the user input beforehand and output everything later. E.g. this line: 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

Background Linked lists are a well-known data structure, so I won't waste too much detail on them. Suffice to say that a linked list consists of "cells". Each cell contains some kind of value and a reference to the next cell (except the last one, which contains an empty reference). I implemented a linked list in Clojure as an exercise. The code 

N.B.: is borrowed from a task of codewars.com, all the rest is my code. While any remark, and suggestion is welcome, I would be interested most particularly in the following questions: 

Why is this last point advantageous? Because you can easily add more situations, without the need to copy-paste the gui elements (wrapping divs). Besides that, it is also possible to quickly change the gui implementation. (E.g., if you decide to have divs instead of buttons, you do not have to change every one of them.) I created a fiddle, where you can try the concept. (Unluckily, the built-in fiddle of SO is not available from tablets...) 

is used to get the unsigned equivalent of as the function makes use of the modulo operator. Modulo operations on signed types is UB. Next is to get the difference between an and store it in the unsigned type. This is perfectly fine since will only return positive values. Also we are getting the absolute value of step. It doesn't matter if we are going from to in steps of or from to in steps of ... all we need is if we exactly hit when iterating. will give us this value. e.g. when using the last value we hit is which is short of . will give us this . What we need now is the value being signed again in the direction of step. will return if is negative and if step is positve. If there is no underflow we can just return the last we were provided with. Otherwise we need to calculate the next last that can be "hit" with . So we use to find the difference we need and add it to . Example: 

Comparing the new code to a normal for loop with the same range actually shows us no difference in compiler instructions: 

For the second part, I suggest factoring out the mapping logic from inputting the date (or at least, the date should also be read in the function itself -- but receiving it as a parameter, and then reading it again is very messy IMHO). So this would look something like the following: 

Although lines (1) and (2) do look right on first sight, due to indentation, they are breaking the if-else statement. This kind of issue can be avoided by always adding braces. 

I think the logic for getting the minimal distance between the points would work even without the explicit check against MAX_INT: 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

In this way, the result of the above example will be: . Of course, it might be worth considering to rename the parameter, e.g. to or something similar. P.S.: I setup a github repo for the above mentioned changes, and their corresponding test cases (along other tests): 

So I came up with a solution that should be as fast a "normal" loop. As already discussed your main problem is the function that is called on every iteration. I removed the check (see comments) and instead added a function to calculate a range that is compatible with the size of (see comments). This function is now used instead of just using (see comments). Also: To prevent someone from messing around with the iterator I made the constructor private and added as friend class (see comments). 

The same way you can "prepare" the values of and . If the user wants to be inverted you use otherwise you use for both calculation and output. 

I was just playing around with some code and had the idea about writing some kind of manipulator to delay the output of characters in a typewriter like style. The focus was mostly on how to use it and was inspired by or . Overall it works pretty well. I just want to make sure that I didn't miss anything that may backfire any time. The code is just for playing around and doesn't have a real use case (yet). 

In this case, he would probably get meaningless results. I therefore suggest introducing a check at the beginning of the implementation of the method (if you need it at all, see below), and e.g. throw an exception if no search was performed yet. Constructors In this particular case, I would suggest initialising only in the body of the constructor, after checking the validity of the parameter. In other words, I would first validate, and only then initialise, instead of initialising with a (possibly invalid) parameter and then cleaning up. Also, it is not clear to me what the purpose of the default constructor is. Would an object constructed through that constructor work correctly? If not, then you can probably remove it, and keep only the parametrised one. Destructors I recommend adding a destructor to this class, where the file stream opened in the constructor is closed again. Idempotency Note, that currently it is possible to call only once. After the first call, we will be at the end of the input stream, and thus it is not possible to read from it anymore. I therefore recommend to either reset the stream (or close/open it again), or introduce a similar check as mentioned above for the state of the object (i.e., throw an exception if is called twice). Responsibility of the class Instead of the method , I would rather introduce a method , which would return the actual count, and then leave it up to the client how/if he wants to print this count (of course this would also need the above mentioned check, whether the object is in the right state). Maybe it would be even better to have return the count directly (and throw an exception if the word we are looking for is empty, instead of communicating this fact through the return value). Naming I recommend changing the name of the variable to something which better reflects what it is, e.g. . ( makes me think of a string holding the name of the file, not a stream through which the contents can be read). Code blocks I suggest always adding braces around code blocks, e.g. for the code above: