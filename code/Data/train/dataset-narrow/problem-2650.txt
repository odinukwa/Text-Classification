Having a list of textures in an array is not a great idea. What if you decide to put them into a texture atlas later (which is generally more efficient than loading a bunch of files)? What if you change the order of a file in the middle? You'll have to re-order a bunch of your data. A more flexible approach would be to keep not just a flat file name or index, but a combination of the two; perhaps in a simple class, or a hash: 

You can do something similar for the y coordinate; essentially, you're creating a wrapper object and setting coordinates manually to some offset (so the circle is always positioned correctly relative to the rectangle). 

I've started down a line of art asset development that will allow me to (hopefully) reuse and improve assets for several games. But how do I go about storing and finding them? Let's say for example I decide to focus on RPGs for ~2 years. I would create items, monsters, etc. and store them somewhere. How would I categorize them and make them easier to search later on? Is the best solution "use directories with broad categories like landscape/items/monsters/etc.?" 

It depends how you want to do it. libGDX "recently" moved to Gradle, which, among other things, manages dependencies for you. Your options: Do it the Gradle Way 

You can get the latest version from Maven for your maven/gradle builds. Also, note: Greenlight is not some magic marketing machine. You have to market your game really, really well to get it greenlit. 

With only 30 objects max, you shouldn't need much optimization at all other than to not check the same two pairs against each other more than once per frame. Which the code sample below will cover. But if you're interesting in different optimizations that a physics engine would use then continue reading through the rest of this post. What you will need is a spatial partitioning implementation, such as an Octree (for 3D games) or Quadtree (for 2D games). These partition the world into sub-sections, and then each sub-section is partitioned further in the same manor, until they have subdivided to a minimum size. This allows you to very quickly check which other objects are in the same region of the world as another, which limits the amount of collisions you must check against. In addition to spatial partitioning I would recommend creating an AABB (Axis-aligned bounding box) for each of your physics objects. This allows you to check the AABB of one object against another, which is much faster than a detailed per-poly check between objects. This can be taken another step further for complicated or large physics objects, where you can sub-divide the physics mesh itself, giving each sub-shape its own AABB that you can check against only if two object's AABBs are overlapping. Most physics engines will deactivate active physics simulation on physics bodies once they come to a rest. When a physics body is deactivated, it need only check for collision each frame, and if anything collides with it then it will reactivate. This keeps simulation times down. Also, many physics engines use 'simulation islands', which is where a group of physics bodies that are close together are grouped together. If everything in the simulation island is at rest then the simulation island itself deactives. The benefit of the simulation island is that all of the bodies inside of it can stop checking for collisions once the island is inactive, and the only check each frame is to see if something entered the AABB of the island. Only once something enters the AABB of the island will each of the bodies within the island need to check for collisions. The simulation island also reactivates if any body inside of it starts to move again on its own. If a body moves far enough from the center of the group, it is removed from the island. In the end you're left with something like this (in pseudo-code): 

I just moved away from MVC towards something more component-architecture-like. I have no concept of messages yet (it's rough prototype code), objects just get internal properties and values of other classes for now. That issue aside, it seems like this is turning into an aspect-oriented-programming challenge. I've noticed that all entities with, for example, a component will have similar properties (get/set X/Y/Z, rotation, velocity). Is it a common practice, and/or good idea, to push these behind an interface and use dependency injection to inject a generic class (eg. PositionComponent) which already has all the boiler-plate code? (I'm sure the answer will affect the model I use for message/passing) Edit: The DI model I'm proposing is as follows. 

It seems like the problem with cases #5 and #6 stem from a single root: you're only performing one pass of movement checks. You should keep moving things down (lets call it a "gravity pass") until you know nothing moved. For example, in case 6, this is what would happen if you used multiple passes: 

The answer to #1 is "yes." Steam hosts other Java games (like Spiral Knights). For #2, I suggest you package your game using launch4j. This will provide you with native (Windows, Linux) wrappers around your application. Other benefits include (from their home page): 

I'm interested in dabbling in Nintendo DS, 3DS, or GBA development. I would like to know what my (legal) options for development tools and IDEs are. In particular, I would not consider moving in this direction unless I can find: 

I'm designing a game that depends heavily on audio; I will have some 300+ speech files (most of them just a word or two long). This can very quickly escalate the size of my final game. What's the optimal way to encode/compress speech files to keep the size minimal without getting audio artifacts? Please address both per-file compression/encoding, and also zipping/compressing the set of all speech files together in your answer. Because I'm not sure which (or combination of both) factors will give me the best results. Edit: I need this to run in Silverlight and Android, so I'm presumably stuck with only MP3 as my option (other than uncompressed wave files). 

When a player collides with a wall while jumping (or, if you like, falling), turn on a flag for the next 100 milliseconds or so that causes an attempt to jump to successfully initiate a jump (ignoring any surface contact checks) with a fair amount of speed on the X axis in the direction away from the wall. Remember to turn the flag off early if a jump is in fact initiated. 

The way you have it described, somebody hacking a save file would just need to construct an MD5 hash of the save file values in order to bypass this measure. You need to add one thing in order for this to even really be worthwhile: a secret block of arbitrary data that's added to what you're hashing (both when creating the save and when validating it on restore). The mechanism won't be uncrackable or anything at that point, but it'll be resistant to medium-casual tampering. If you can avoid having the data block be easily extractable from your runtime files using a hex editor, that'll add another notch. If you want people to actually not be able to hack your saves, you cannot perform local saves at all. You cannot trust the client because the client is in the hands of the enemy. 

I would imagine it's because, since you won't get any useful generalization of policy out of anything but toy problems, and the reward function is going to look suspiciously like an A* heuristic, the prospect of using RL tends to look like a really overbuilt, inefficient way of getting results that are identical with A*'s at best, but probably aren't going to be nearly that good. This may be unfair to RL, and if so I'd be interested in hearing why, but I'm not really seeing anything to indicate that. Many of us also remember what pathfinding was like in games before widespread adoption of A*, and aren't eager to inflict anything resembling those days on players, or suffer the market consequences of doing so. 

I'm looking for a vector art tool for gameart, similar to Flash, but preferably free. It just needs the following capabilities: 

Sounds like you want A-star path-finding, which is pretty much the defacto for path-finding. I used this in my XNA game: $URL$ (I repackaged the library into a slightly more usable stand-alone DLL). 

After googling for some time and reading the articles, I'm not sure I understand exactly how this effect works -- that is, how I would implement this. It seems like you need your original image, plus a grey-scale "normal map", where the colour represents depth -- the "farthest away" pixels are black, and the "closest to the viewers" are white. But even if I have this, how does this information combine with lighting to create that 3D effect? Also, how would I use this information to create casted shadows (see bottom-left barrels in the picture below)? 

I added some code using to execute my function every 100ms. It worked, until I tried instantiating images in it -- since it doesn't run on the libGDX core thread, there's no OpenGL context, so it can't do stuff with images. I figured using the libGDX class, which the javadocs say , would solve this problem; but unfortunately, the timer code just doesn't execute. I tried: 

The comments say it all, but ... no, there probably hasn't been much research on it. But, one thing is for sure: in-game, interactive tutorials work better than "read this" tutorials. This is easy to see in Flash games; you can see the evolution of static screenshots/images linked from the main menu ("Tutorial" button) into in-game tutorials (or tutorial-like levels). The benefit, obviously, would be seeing things happen and how actions play out, while the game progresses, instead of reading a bunch of instructions before you even have a good idea about how the game will go. 

As stephelton said in the comments to your question, vector math is extremely important for pretty much any 2D or 3D game. However, physics knowledge isn't necessary for a lot of simple games. There are physics-like concepts you should understand a bit about, like collision, but you won't need calculus or physics classes for that as long as you keep it simple. A lot of things you may want to do can be simulated simply enough that players won't care much, like friction, or sliding, or gravity. A decent grasp of physics will likely help in many situations though. 

Each pixel doesn't have to be its own node in your navigation mesh/graph. You should be able to subdivide areas by sections, and each section becomes a node in the graph for the A* algorithm. This leaves you with far fewer nodes and much faster searches, however you do have to calculate how to move through these nodes naturally with AI, as you won't just want to walk from node center point to node center point. Here's a decent paper explaining how navmeshes can help solve issues like you're talking about: $URL$ 

Anytime you applied a positional change (translation) to the camera, you would flatten that vector out. Let's say in a non-restricted situation, where the camera could move along the Y-axis, that you have a movement vector like this: 

This gives you a line segment with which to check boxes against, and it should work with any XNA-based game. And if you planned things well then your boxes are exactly 1x1x1, which makes it very easy to know which block areas the line goes through. You would write an algorithm to check each of those areas, in order from nearest to the camera, to furthest, and as soon as a block is found then you're done. One optimization you should make would be to shorten the line segment to only be as long as you want players to be able to click on blocks. 

Wow. This actually seems like a situation where old-school AI semantic webs, like Richard Bartle thought were going to be important to the future of games when he wrote Artificial Intelligence and Computer Games, would be useful. You basically have a couple of data lists (database tables, whatever), the first of which specifies rules about how things can relate to each other, like: 

Well, it's not how I would do it. Since the velocity of the character is a property of the character, I would attach that information to the character. In fact, I would have the character know both its position and velocity, Heisenberg be damned. If that means the character needs to "know about" the level, at least insofar as being able to ask what the coefficient of friction is at its position so as to be able to update its velocity, then so be it. Radical decoupling is a virtue only toward a particular purpose, not in and of itself. I think you were on the right track to some extent with your mediator pattern, though. Pushing the control input directly to the character object and making it solely responsible for animation makes it awkward to, for example, have an action interrupted by external interference. I would make the character object responsible for modeling what it's attempting to do, while being open to being told that something else is actually happening by the mediator, and for providing animation information to a view which would do the actual management of the animation (rather than the character model doing so itself). This isn't to say that I think all logic should live in the mediator. As implied above, I would make the character model responsible for logic that's about it. The mediator should be responsible for resolving things in a broader scope.