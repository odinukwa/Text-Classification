this code will run for a very long time even though I can tell you without running any code that the output should be 

General comments This is a monolithic block of code. Even some newlines to break it up would help readability, and really I think it would benefit from being split into several methods. 

I would use a Taylor expansion to three or four terms to get a starting point and then Newton-Raphson should home in very fast. 

Postscript: t3chb0t's suggestion of a method which can then be combined with is compatible with a rewrite of your method, and in fact this is what I have kicking around in my library of utility methods (although I call it ). As a modification of your code: 

The algorithm is doing an inclusion-exclusion, so that really is a unary minus. Both and should be using signed types, not unsigned. 

This is correct and simple, but it generates a tonne of garbage to be collected. Have you considered using a single accumulator? 

Anything more complicated than that should have a comment explaining why the complication has been added. 

The minimiser should take care of unescaping the Unicode escapes. It might be slightly easier for me to find which characters they are, because I can look up the hex values in a Unicode character table. 

Another much more minor optimisation is to ditch and use instead . Also, as a style improvement rather than a speed one, pull the reused value out into a local variable. That's a long enough expression that it would probably be worth pulling out if only used once: it's definitely worth pulling out when used three times. 

Why call ? I can think of very few situations in which an exe should take its own name as a command-line argument. 

That's not very descriptive. I can tell that has something to do with primes, but something like would be a lot more informative. 

The way you're using indicates that you've got the type wrong. In almost all accesses you're iterating through it checking the elements to see whether their matches a value. That suggests that it should be an , or that you should pass the around rather than the . You might also need to synchronise access to it - I haven't nailed down whether it's possible for it to be accessed by more than one thread. 

Negative-index Fibonacci numbers are perfectly well defined, so this error message is misleading. You could change the error message to something like , but you might as well change the code to support them. It's just a case of negating and using initial matrix . 

Why ? The code looks single-threaded. Is this planning ahead for multi-threading? Also, code to the interface rather than the type. At the very least, the fields should be rather than . 

Good to see that you've thought about corner cases. It's debatable whether is better here or (since you're in ). 

Separation of responsibilities: it would be cleaner to return a vector rather than to "return" with . 

I agree with Nikita's observation about thread safety. It might be instructive to see how to do this with , although I'm not convinced that it's necessarily a better solution than . It's certainly fragile - I had to correct some mistakes in my first version of this answer. The potential threading problems are: 

Have you profiled? Bottlenecks are often surprising. I would have thought it worthwhile to accumulate the values of first, so you know exactly how many primes you need, and then to add an early exit to the sieve when you've found enough. 

Beyond that, you need to look at different algorithms. The binary quadratic form doesn't seem to be a common one in prime sieving. You could see how it compares with Sundaram's sieve (BQF ) or failing that, if you're working with large enough ranges, Atkin-Bernstein (e.g. a combination of , , , , and for different totients of 60). 

This is not dynamic programming. A dynamic programming approach to this problem must work on the following basis: 

Now we can look more closely at that inner loop. Suppose we want to extract an upper bound such that we can rewrite it as 

The function is very long: it's probably worth at least pulling out the solution search routine. But beyond that I'm not going to comment much on style, because I'm not a Pythonista and others can do it better than me. 

We're still in , so this looks like more copy-paste which either means that it's unnecessary code in both methods or that there's a bug. as a name implies to me that the variable is being used in a swap, or maybe as a factored out part of a complex expression. For a loop variable, why not ? (Or , since that's what the base class is called?) 

The exception approach can certainly be clearer, and I wouldn't discard it just because it's "using exceptions for control flow". Exceptions are always control flow: the question is whether they're the appropriate one for a given case. However, I would make one change: I prefer the name (stolen unashamedly from Microsoft's .Net API) to . 

Firstly, the purpose of is to split work between multiple threads; the purpose of / is to avoid the need for multiple threads when handling things such as I/O. So combining with / is a code smell. Secondly, what's ? A field of the class? In my opinion it should be an argument to the method rather than a hidden parameter. Thirdly, that lambda is far more complicated than it needs to be. The code I've quoted above could be 

No. Just no. ISO 8601 is the only date format that should be used unless a locale parameter is supported. 

It's not needed in this scope, and in the scope where it is used the first thing that happens is that it's reinitialised, so this line is completely pointless. 

Also, this very much needs either a comment or some Hungarian notation to indicate the endianness of the coefficient array. 

What's going on here? My best guess would be that you're mixing tabs and spaces with a tabstop of 8. Be consistent: tabs or spaces. Changing the tabstop shouldn't break the formatting. Names 

Finally, you could consider normalising each cyclic word. Given the possible rotations, choose the lexicographically smallest and insert only that one into the set. Whether this gives an efficiency improvement will depend on the statistics of the strings, but if they're random and of a length comparable to the size of the alphabet then a na√Øve algorithm for finding the smallest will be essentially linear, and you gain two things: firstly, the set becomes smaller (less memory usage, faster lookups); and secondly, you can drop because the number of cyclic words will be just the size of the set. 

Using a colour space which is designed to be closer to the way we perceive colours you can avoid the loss of vibrancy. E.g. with HSL, interpolating between the same endpoints: 

This doesn't do much, so if it's the bottleneck it must be because you're calling it a lot. The first thing to do is to look at the calling pattern. If there are lots of calls with the same value of then you may be able to calculate and once rather than each time; you may even be able to cache and share it between lots of calls with the same and . On the level of microoptimisation, is mathematically equal to and is mathematically equal to ; I don't see a numerical reason that pulling that out would hurt, and it might shave a couple of cycles off. Then is which is another common subexpression. There's potentially another algebraic tweak: could be refactored by including that extra product in the method: 

There you go. The main loop runs up to \$5 \times 10^{11}\$ times. As a rule of thumb, when brute-forcing a problem I work on the basis that \$10^9\$ is about as high as I want to go. Solution: change your algorithm. This will require learning some mathematics, and I'm not going to write a detailed tutorial, but there are two things you need: 

Why are the three auxiliary functions in the top-level scope? I admit that I don't know F#, but the languages that it's heavily inspired by would allow them to be defined in a clause inside the definition of , keeping the top-level namespace clean. 

Note that sympy.permutation has some methods to generate the symmetric group over a base set, so constructing can be delegated to them. 

The documentation for Android's says that it uses exactly the same path syntax as SVG. That means that it supports and for circular arcs. Have you actually tested that they don't work? 

Here you could have an early-abort if the partial digit sum of prime factors already exceeds the digit sum of the original number. That same idea carries over into the suggested rewrites of the method. 

There's a lot of code which has special cases for nulls. I wonder whether you could get a simpler implementation by using sentinels. It would be good at least to see a comment mentioning that not using them is an intentional implementation decision rather than an oversight. 

I've not seen this before. Nice trick, but it can be done in pure bash. The catch is that bash case modification is part of parameter expansion, so you have to store each word in a variable, and you'll need a loop. If you're not completely committed to having a one-liner then this is something which could be pulled out as an auxiliary function, and you might even find it useful elsewhere. 

You've missed an error case called the "triangle inequality": the longest edge can't be longer than the sum of the other two. (If it's the same length then you probably want to consider that an error too because it reduces to a line segment). To test this robustly requires taking into account overflow. It's a bit odd that you throw an Exception for some errors but return an error value for others. Since you're writing Java rather than C, favour throwing exceptions for exceptional cases. 

That's confusing. Using when the comment delimiter is just also makes me wonder whether there's something odd going on, and that's not the kind of question you want a maintenance programmer to be asking. Spelling 200_success already pointed out in comments that igonre is incorrect, but so is peformed. If you don't have backward compatibility constraints which prevent fixing it, I suggest fixing it. Capitalisation Most of the SQL keywords and MySQL built-ins are capitalised, but not all. In particular, why rather than ? 

To get more speedup, it's probably worth looking at parallelisation. Lifting over is completely parallelisable; mapping to a suitable sublist of is also completely parallelisable, although possibly a bit fiddly. I don't know anything about parallelisation in Python, but there seem to be options. 

I think we've found the reason for the slowness. If you find yourself reaching for permutations in a coding challenge you've probably missed an opportunity to decompose the problem. It's often useful to think about small values of the parameters first. 

Why does the return type use the implementation rather than the interface ? Why hard-code the type? You don't do anything with it other than equality checking, so it could be (and then could potentially be an extension method of ). followed by a get is a minor inefficiency. Since will give (i.e. 0) if the key isn't, found, this can be fixed: 

was initialised as . , so there's no point initialising to 256. (And the class name isn't actually correct). 

Wait, that was just to rotate the list? Why? At this point I'm seriously in need of some comments to explain what you're trying to do. 

For my taste the code could use a lot more whitespace, but I'm going to try to stick to your style in the proposed changes. 

Your solution takes linear time and linear space. Can you modify it to take linear time and constant space? Can you modify it further to take logarithmic time and constant space? 

This is Java, not C. You don't have to declare all the variables at the start of the method. There are 20 lines between the declaration of and the first use. Keeping variables to the smallest scope possible aids readability. Also, it's not obligatory to declare variables to be equal to the "default" value. Observe: 

Leave it as is. Replace with a class which takes scaled reciprocals of a general sequence, but keep the static for the name alias convenience. Factor that general class out of and make the latter a subclass whose only declared member is a constructor. As 2 but replace the static method with . (There's also a 4b option of having both static utility methods). As 4 but make the return type of all the static creator methods be . 

This isn't really production code, is it? There's an obvious test method which is testing a private method. What should be the API? The chunks of five are returned as 

Note: there is potential for integer overflow both in your original code and in all of the suggested changes so far: the intermediate values in Collatz chains can get very large. Ideally the code should check for that. 

The indentation is inconsistent: the test class has its indented the same as the class declaration, but the main class has them indented one level more. 

The fastest memory-efficient approach is probably going to be an iterable using a Gray code to create a non-recursive solution which adds or removes a single element to the set between each . 

Thread-safety. This has no thread-safety whatsoever. Typing. If you're going to emulate C#'s events then don't just emulate the ungenericised . At the very least, emulate . Because Java's generics aren't reified this requires a bit of boilerplate: 

Rather than using and and making assumptions about the exact size of one of them, you're using a language which has . I would guess that your s could be and your s could be respectively, although it might be even more complicated than that. ing each logical type would not only provide clarity on the meaning of variables but also help you see where you can use types vs types vs exact types.