Yes, that's right — you've managed to write a recursive string concatenation routine! calls itself! This means that if there's no room in the buffer to concatenate the input strings, we'll produce an error message and attempt to concatenate it onto the log buffer... and if there's no room in the log buffer, we'll produce an error message and — well, thankfully, the recursive call passes instead of a log buffer, so we won't recurse infinitely. That's a small blessing. Your parameter is essentially an attempt to allow the user to customize your library's error-reporting mechanism. If you're really interested in going down that route, I recommend that you learn about function pointers, which would allow you to write a library function like this: 

And because I was using STL containers, I'd have the entire algorithms library at my disposal if I needed it — you know, and and whatnot. 

(Notice the mix of pre-parenthesis-spacing styles as well.) Pick one style for a given program and stick with it. 

The easiest solution is to drop the lock, call , and then reacquire the lock to move the result into the queue. Of course, the move-constructor of might take the lock... Also, notice that if throws anything other than , your program will die in . That's not so good. 

Consider providing "weak references", which the standard library provides as . Weak references () and strong references () work tightly together, using the same infrastructure. Consider providing the ability to pass in a custom deleter: 

The first statement here smells to high heaven; and the mix of and is dubious as well. I think what you want is 

However, this still has a major flaw: You're accidentally requiring that be default-constructible! That's no good (especially if it does happen to be default-constructible but the default constructor is expensive). You can fix this issue, but it requires metaprogramming. 

In which case, sure, factor out a base class. But if you don't need that kind of thing to work, then you probably shouldn't worry about adding code to make it work. Instead, just focus on making the two codepaths as understandable as possible. For example, right now you've got parameters named and that both seem to be doing the same thing. Consider renaming them both to , so that a human reader who has already learned what the English word "pin" means will immediately know what's going on in your code, instead of first having to learn what means (namely, "pin") and then later have to learn again what means (namely, "pin") and then wondering why there are two different words for what seems like exactly the same concept. You've got member variables named and . Consider renaming them both to the same thing. And so on. Once the two codepaths start looking more similar, so that the human reader can look at one of them and then look at the other and say, "Okay, I see what's going on in CapSwitch by analogy with SimpleSwitch"... well, at that point, it might make sense to look at whether CapSwitch can reuse any of the actual code inside of SimpleSwitch — via a non-abstract base class, or CRTP, or any other design pattern of that general nature. But it's still very premature to worry about that, I'd say. 

(Notice that you could use instead, since in this particular case you know there can't be any overflow — and you are concerned about raw speed. But my assumption is that you aren't very good at profiling to find hotspots, and are looking for style tips in general, so the general advice "Always use over " wins out over the very case-specific and chainsawish "Omit bounds checks when you're sure they're unnecessary.") 

You say that, but then when I look at the code I find that nothing inherits from . So it's not a base class. Also, you should get rid of all the destructors except those that are actually necessary. Classes that aren't used polymorphically shouldn't have any polymorphic methods. (This applies to and , obviously; but it also applies to and as well, because you never use polymorphically.) In general, the code is just way too complicated for what it does. You shouldn't need so many different classes, or probably any virtual methods at all. 

and if you give that method a more descriptive name, like , then you could also implement several different kinds of views, e.g. a class template that provides . 

Notice that I've also changed your , to , , on the principle that adding and subtracting 1 all the time is less efficient than not adding and subtracting 1 all the time; and on the principle that everybody knows what "string length" means (it's ), whereas "string size" is a bit ambiguous (does it include the null terminator or not?). 

I haven't even really dug into the lock-free parts of this code, except to point out that all your spinlocks are broken. I suspect that the lock-free parts have approximately the same density of bugs as the main code, which is to say, they don't work at all. One way you could help people review this code — including help yourself review it! — would be to split the code clearly into "deep magic" and "boilerplate" parts. Right now, you've got deep-magic code like living right next to boilerplate code like , deep-magic living right next to boilerplate , and so on. It's really hard to figure out what exactly is the "core" of primitive deep-magic operations that needs attention, and what is the higher-level boilerplate. Of course another way to make the code more reviewable (and more correct) would be to rip out much of the boilerplate. For example, you have five different overloads of and one of ; I contend that for your purposes you only need . That'd save you about 40 lines of code, and save you at least the one bug I pointed out in already. 

Even better: remove the argument entirely! Just use the predicate for the whole thing, and the condition becomes . 

Notice that the in isn't strictly needed, as written, because the destructor of was going to drop that lock anyway. But you could put more code after if you had more things to do that didn't affect . 

Notice that by using we prevent anyone from entering an infinite regress via ; although a ()-level regress is just as bad, honestly, and compilers will catch both in practice after a few levels, so whatever. I also recommend passing / by value instead of by const-reference, since it's an empty type. Again since it'll all get inlined I don't think it really matters either way. 

In the above code, is basically a definition of what means in the code. You could go replace every instance of in the program with , and the program would still work fine. This is a nice property for a program to have; it's known as referential transparency. A perfect program won't have any places where you say "Hey, you know that variable from earlier? Well, now it means something totally different." If the variable means something different, you should give it a different name. Next, decompose your program into functions. For example, take that messy expression you're trying to get rid of, and stick it in a function: 

I suggest rewriting just that portion of the code as follows, and then profiling to see if the bottleneck is gone. However, writing that just reminded me: Have you tried profiling your code? (Random Google link. Someone in the comments may have better advice about how to profile Java code.) 

Notice that I'm adhering to the Rule of Zero: the compiler-generated destructor is good enough for me, so I don't need to write it out explicitly. Similarly, I don't need to write out the body of the default constructor; I can just it. And I don't need to write a member-initializer for ; I can rely on the compiler to default-initialize that vector to the empty state. I do, however, provide a default constructor, because without a default constructor you can't do some really useful things such as call . 

Well, one coding-style improvement: You need those casts to shut up compiler warnings about unused parameters... in C. But in C++ you don't need those casts; what you do instead is, if you're not going to use a parameter, just don't give it a name. 

and you should also modify your metafunction to return when is not an element of at all. That is to say, should inherit from , not . When I made those two modifications to your code, the error message above reduced itself to this: 

(There is also a type trait, at least for now, but I don't see what POD has to do with your constraints here. It might even be correct to test only for , or maybe you don't need the constraint at all, I'm too lazy to find out... well, okay, I see you're using . So you need trivially relocatable at least. would be insufficient; is correct but overkill.) 

The last thing I'd consider doing is eliminating mutation from the code. You've got these variables and that aren't initialized, and then you use to mutate their values. It might be more straightforward to write an "int-getting function" and use it consistently. Plus, this gives us a place to hang the missing : 

But this is missing three pieces: (1) there should be a newline after each line; (2) there should be a to print whenever we don't print or ; and (3) we need to avoid printing whenever we did print or . (1) is easy to fix; we just add to the "carriage return" code along the bottom of the loop. (3) is awkward. I made an abortive attempt to squeeze a recomputation of something like (read left-to-right) into the "carriage return" line before realizing that computing logical AND ("i mod 3 AND i mod 5") is awkward in Befunge, and I would have to add a fifth line if I wanted to branch again here with . So it makes sense to do what you did and keep track of whether we've printed or as we print them. This lengthens the loop body by a few characters (most of which are ). With (3) out of the way, (2) is easy to squeeze into the blank rectangle in the upper right. As a bonus, if we just printed then we know we don't need to test for !