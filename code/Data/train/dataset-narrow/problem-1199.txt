Finally, to conduct an experiment we absolutely 100% entirely need a control. You cannot justify a scientific result without a control. Our control will be a base . Nothing more. So I built a basic benchmark: five methods. One does , one does , one does , and the last does . I'm going to post the x64 result first: 

And so on. You could also use a trick with the absolute value (as mentioned in comments on the question), but that takes a lot of the meaning away. This version allows you to easily define upper and lower bounds: 

A works here, and it's functional, but it does come with some drawbacks in this case. If you and I both submit the request at the same time, one of them will be delayed even though there wasn't actually a reason. Now you've introduced a potentially hazardous situation, what happens if a lot of distinct persons submit requests at once? The best option here, is to block only those who violated the key sanity. The easiest way to do this is actually to the appropriate exception. There's a nice question about this on Stack Overflow, which I would like to borrow some information from: Duplicate key exception from Entity Framework? 

I would take some of these strings and make them constants/variables/configuration settings. This will allow you to change them easier and in one location. 

This script is designed to locate and download the first repository in your sidebar on the GitHub repository page. It downloads the .zip file for that repo and saves it to the default location. I built this script as a test to determine what it would take to perform this type of operation since I needed to use it on something else, but this script itself is the actual script I use (very) infrequently. Basically, any/all PowerShell idioms would be awesome to have feedback on. The comments are there for the person I was writing the script as an example for, but again this is the script I'm worried about. I want to continually improve it. 

One of the more recent functions I've needed for personal and work purposes is to split a string on a delimiter, but while ignoring the delimiter when inside a quote. Just as well, if within a quote then two adjacent double-quotes () should be treated as a double-quote escape, and as such should be output directly into the resultant string. 

You're relying on the fall through case to perform the work. You'll see in a moment (as I now have some time to write for tail-call recursion) that the arrangement of a function should be: 

I'm going to go over a few things in this answer, hopefully it makes them simple enough. Then, at the end, I'm going to go way overboard and significantly over-engineer this programme while still making it shorter. 

One of the suggestions I would make is to improve your input handling. You don't handle invalid integers well at all. 

Same number of LoC, but it's a little more clear what's happening. As far as performance, I don't see any obvious bottlenecks. I think the biggest bottleneck you'll end up having is in the LINQ (this is all speculation, but we're talking microseconds, not even nanoseconds). You shouldn't be concerned of your performance until there's a measurable performance issue. 

That's a lot of stuff, not to mention, you have three major categories of calculations as well. So let's break that down. We first need to create a main 'pump' loop. 

As part of a project I'm working on, I need to measure FPS. In the past, I would do this within the actual project itself, but recently I've been trying to implement more abstract (and reusable) manners of doing such simple things. So, I built an class that handles all this for me! 

Is it a pain in the rear to use? Yes. Is it in the Brainfuck spirit? Yes. It's still not true brainfuck syntax, but you won't get there with C#. 

Of course that's huge and does a lot of stuff. We obviously want to break it down. So we'll extract our to use some methods, function composition, etc. It's still long, but it's slightly more maintainable. 

Now, we've extracted the entire game result to a new class to eliminate the need for string processing. (This is far better for multi-lingual setups, or setups where you just want to dump this result to a DB, etc.) Notice that I left out, that's irrelevant to the result of the game playing method. It doesn't care about the game number, only about it's result. Next, we'll use this in our method: 

The first defaults and then checks for the parameter, the second checks if it's set then defaults. Take your pick. But those still don't handle invalid (non-numeric) input, so we can do that as well: 

We eliminated multiple excessive methods, and return the same thing you did initially. (Or should have.) 

This is another pretty basic class I wrote for a library as I hate the way the default in .NET works. Essentially, I wanted to have the operator, as well as implicit conversions to strings. (Rather than needing all the time.) It's pretty small and simple, so there may not be a lot to critique. Also, before you say "just inherit and extend it", it's . 

So what did we do? We replaced all the strongly-typed calls with some generic ones. We also added a parameter that allows us to specify a certain to build our result. We could extract that out, but I'll leave that up to you to decide. Next, we rewrite the other as: 

Another concern: if there is a substantial delay between messages, it may occur that the log is never written to before the application is closed (or messages are left in the buffer), this can be alleviated by scheduling a to save the log at periodic intervals as well, so that if there is a substantial delay the log is saved anyway. 

While this is technically true, prepared statements will not protect you against people entering blatantly invalid data. You should still do some filtering. (Though you need worry less about filtering against SQL injection, and more about filtering against data tampering.) 

Please, please, please always explicitly include access modifiers. Right now, you may not realize it, but and are both . This means they cannot be accessed from outside the assembly they are written in, which isn't very useful if you have to share your implementations with another person/developer. If you want to keep them , then mark them as such so you don't forget the scope of them when you go to debug the issue of why you cannot access them from other stuff. (Trust me, I've been there and done that, and it's not fun.) 

Lots of very cool stuff in there. But, there's also some bad stuff. You are significantly arrow-coded in some places. One of the changes you should make is your guard clauses. Most explicitly, in this method: 

Both should have the same effect on the cases you provided. However, if, for whatever reason, one of the cases ends up as , then the second method will only make it . Choose that method with great caution. As the OP pointed out in an edit that should have been a comment, this code can all be done as LINQ: