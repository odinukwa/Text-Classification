When it comes to design, I wouldn't put the functionality of translation into an enum, even if it's inherited. And to have a default implementation in an interface still bothers me, it feels like an oxymoron to me. The functionality of translation itself is a 'concern', and should be separated (See what I did there?). Also, let's assume the enum value can be saved in a backend, you then also pass translation functionality to the persistency layer. Not a big fan of that. And considering testing: Here's the usual 'having an abstract class'-problem. How do I test abstraction? You could use either a implementation, and call it good, or write an implementation for your test case only. It's not too bad, but it's not sexy either. My main problem with abstraction is, if you mix abstraction with implementation, in your case: your abstract method calls a method from the implementation, so the method you want to test is not tested cohesive. 

setting portrayals up shouldn't reset the display main() method Usually, the main method is at the bottom of a type. 

I have some "readability-issues". It usually helps to name your methods with a verb and a noun, so, would be , for instance. and are not named correctly, in my opinion. If I call , I do not know what this method will do with the two parameters, it feels like, the method adds the listener to the consumer. I also have no idea, that the is used for unsubscribing later. If I call , it feels like I pause the listener, and can activate it later. and would have been more clear. Also, since we're talking about publishers and subscribers, I'd recommend to use the terminology of this pattern. , (well, is given by the jdk), , and . Well, it's a bit smart-arse-y, but, since I'm here,... By definition, or at least by the definition I know/remember, one thing the publish/subscribe pattern wants to achieve is, that the subscribers have the ability to subscribe to specific messages types, e.g. : You subscribe to a news feed, but only the sports part. So, I recommend to rework the terminology, because a user of your API can have different expectations of the API. (Yes, I'm one of them :P) 

If you got that, you start to add the 'fight mechanic', you maybe add in the GameSetup a new step 'choose your weapon' (so, a new type ), the player chooses it and the sets it to the object... And please note, many newcomers have that assumption, that you can only represent real things from the real world as objects, like House and Door. But you can also have things like and ... it's about splitting problems into smaller problems. Also I'd suggest to read about test driven development, or at least testing in general. It's a more advanced technique and maybe new starter shouldn't be bothered, but in my opinion, very very, like really very important - to be honest, as important as the production code. Test driven development actually helps to make your code more clear, improves the design of your application and also helps to think more or better in objects. And it tests your code. Hope that helps... 

Flashback time, again :-) Looks quite good. The code looks like you really wanted to make code good looking - which maybe is more important than people would think. Naming 

Commented out code Get a code repository. And never ever check in commented code. If there's commented code, no one will ever know if it's important. If you need the history, you got it in your scm. setup() method The king of the worst gets a new contender: 

So, you're checking if the email attribute is not in the session, then get the cookie, and then set it to the session. Maybe wrap it in a -Method or something? Same goes for the token. And I'm pretty sure you can write one method which works for the email and for the token. This if is also confusing 

The only Reason for the is to have it as key object, right? Now, why is that confusing for me: You call that thing . What is it listening for? And what's the difference between listening and consuming? In your sample code, you actually do use this as key and use a lambda expression as parameter. So what if I would actually would overwrite the method in the type, change the method signature in from 

Why didn't you just made a simple class with a static method, which takes a prefix and an enum value? If you chose to save the message key as 'class.name' + "." + enumValue, for instance 'pack.age.PreferedContactForm.MOBILE=Mobile', you wouldn't even use the messageKeyPrefix! And you can get rid of MessageFormat. Why not something like this: 

The keyword is usually a sign of bad inheritance (Liskov's substitution principle) and I do not recommend to use that. Beside that, I do not understand that data structure of your stock information. Why not something like this? 

Use a (Http)ConnectionPool - which you do. Web Servers usually have different configurations about their http pool (or "Connectors"): The amount of threads, which will process requests, the amount of open connections (which will wait until the thread pool has a thread free) and often the amount of http connections open per client ip. This certainly has to match the configuration of your pool. If your app opens too many http connections, they will just wait, memory consumption will rise, memory management will take cpu time, you kill the backend server (yay). I see, your connection pool has a maximum of 1000 connections. That's a lot. Our company website has about 1000 in total, for several different servers, the max connections for our productive server are usually around 100 or 150. 

Double-clicking on a ListCell would call .edit() on the domain object. Same thing. The presentation code calls the domain object, then, the domain objects calls someone and says "someone wants to edit me". If I understood it correctly. 

In general, the Decorator pattern is a nice thing, if you don't overuse it. And with overuse I mean endless wrapping of instances and super-calls. To answer your question in the last paragraph: Yes, you should in my opinion hide as much as you can and provide concrete cars with a factory. Just think about debugging the method in your last example. That's a lot of jumping around until you exactly know what is happening, and it's only sample code. Also: You're mentioning that this is a demo and you want to use that pattern in production code. Without knowing what the concrete use case would be, we certainly can't tell you, that the pattern will solve your problems. I somehow have the feeling, it's the wrong choice. I think the decorator's strength is, that you can add behavior, but more important: you can add/change behavior at runtime - and I don't see that in your example code. Hope that helps... 

I don't understand, why you are providing separate methods to get the values, enum's already provide those methods. I wouldn't suggest to do that, because that's your own convention. If it doesn't do what the default method for an enum does, give it a proper name. Hope that helps... 

First: WTF? (You know, the best measurement of code goodness is WTF's/minute.) Second: Those files shouldn't be in src/data. It's not source code. 

Usually the logged in user and it's common used information is stored in the session. And the session is usually wrapped in a class (like itself). This is done because you can decouple your code from the session or from the servlet api (or whatever api you're using). It also makes it easier to test. Most of web pages do show your user information when you're logged in, e.g. your avatar on this page on the top. So for every request you do not have to look up the user's information. I'd introduce a class which provides a and method. Beside that: 

I did some refactoring... I disassembled everything into smaller pieces. Maybe the naming of the methods and vars could be better (I'm sure it can), but I wanted to show you, how to split 'stuff' into smaller pieces of code to make the main method (not meaning the main method in your code explicitly) tell the summary and move the details to separate methods. 

JavaDoc WITH single line comments. Develop against interfaces Don't declare your variables with the implementation of the datastructure, use instead of . It shouldn't concern you what type of Map it is. The decision what map to use is taken once. <> / Diamond operator instead of 

: The method name is not clear, I had to read the method to be sure, what's going on: It deals the first two cards. Maybe . Even though, many are familiar with the Black Jack rules, not all are. 

You should have seen the look on my face. Why must what be included to have what to allow something which somehow has nothing to do with the method name? Why does it return Object? Why is there an explicit comment about non-volatile? Everything.. is just.. so scary start() 

Where to start ... I'd say, in general, I can follow the code and understand it. The naming of your variables are quite decent, that really helped a lot. But there's a lot of painful stuff around. I focus on those which hurt the most - many things should also be obsolete after few changes I recommend, too. static variables vs instance variables You mix a lot static and instance variables - I was actually really surprised, the code worked! I don't think you have understood that concept, because in the class, for example in the method, you mix everything up. You also access static variables directly and at the same time, you use the static getter method. If you declare a variable static, it is "bound" to the class, but not to the instance - the instance can access those of the class, but not the other way around. But: Those statics in shouldn't be there in the first place (explained later). In general, static variables are rarely used, if a "variable" is declared static, it's usually a constant. Static methods are used more often, but those are usually 'utility' methods of a class, which work independently of the state of a class. separation of concerns One of the main object oriented principles: A class should do "only one thing". The more it does, the more complicated it gets, the harder it is to find bugs or change it. The does on one hand hold its state (the name, the candy consumed), but on the other hand, does also the game logic (I'm just gonna call it like that now)! The game logic must be moved to a separate type. And then, you can also get rid of all this static variables. At the same time, the class loads and starts the game, but also takes user-input. That should be refactored to a separate type, too. Maybe do a class with a method like , which returns a . I think, if you get rid of the missuse of static/instance variables and separate the concerns, you will get the most improvement. Formatting / Naming There's some bad formatting - indentions, empty lines. Get used to format your code before you save (or use a 'save action' in your IDE), it helps a lot. Another problem is fixing the formatting and commit it to the code repository - understanding changes between commits gets more difficult. Also check out the java naming conventions, how variables should / must be named. Code Style Now the small, but important details. constructor : Setup what? A method should be as self explanatory as possible. It shouldn't be too long - if that's the case, it's usually a hint, that a method does too many things ("do only one thing") and should be split up. 

Yeaaah, that's why people tend to use existing ormappers ;) - you might want to introduce some static methods in your base dao, e.g. all() and join(String table, String condition), so the writing is more fluent and it's better to read... you might want to check the Criterion API/impl of hibernate, it's quite nice to write and read, but that's quite the work, if you really want to implement your own ormapper with a certain amount of sql features. And: Most important: It's your job to make a class or a method readable. In test cases, I even write a static tomorrow() method, which creates a new Date and adds a day. Of course, you have to write a lot in java, but that must not be the excuse, to make your code not readable. 

($URL$ The first one doesn't match, so that's an argument against decorator. You say, you decied not to modify your existing service, because it's "hard to unit test", with all the dependencies. In my opinion, the usage of the decorator pattern makes it more complex. In your case, you only have two actual implementations (original / extension), that wouldn't be too complicated, but if you have just one more implementation, it will be horrible, because A can composite B, B can composite C, and so on. So it's very hard, just to understand how a specific composition works, especially in your case, when states of an object will be changed. If you're argument will be, "well, it's only two implementations", that will be an argument against decorator, too. What I find amusing: You decided to use decorator, because it's hard to test. Well, if something is hard to test, it's usually a sign of a design problem. Or bad test code. At first glance, it doesn't really seem very complicated - if we're talking about unit tests, and not component tests. I mean, most of the methods just call other services. When I look at , the things that have to be tested, in my opinion: