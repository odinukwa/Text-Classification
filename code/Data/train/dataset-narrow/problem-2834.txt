Complete vs. incomplete information What you are looking to do is path finding without complete information. The conceptually sound way to do this would require you to keep track of all of your non-playing character's information state (i.e., the parts of the map they already have discovered). Local information A more workable solution in your case might be to have complete information path finding (as you do now) for human-like enemies, and use local information (a type of incomplete information) to perform path finding for creatures of lower intelligence. You could do this, for example, by only considering obstacles within 5 tiles of the creature and assuming all other tiles are passable. Your example above would like this to the path finding algorithm: 

If there are more than just 2 colliders this will get a little more complex, as you'd want to do collision detection for the second, reflected, part of v as well. 

Side note: The transformation matrix should be separate from your sprite's pixels. Updating it with a 2D-translation can be as cheap as 2 additions. If this doesn't make sense read up a little more or even ask a new question about it. 

If you are looking for an academic solution have a look at cluster analysis, possibly combined with this other Wikipedia page: Determining the number of clusters in a data set. Keep in mind these algorithms are typically designed for processing highly-dimensional data, not unit positions in 2D/3D, so be sure not over-engineer your solution based on this. 

The algorithm starts with a wide funnel and proceeds by iteratively moving the funnel sides forward along the portal side points (the end points of the line segments) as long as this tightens the funnel (A-D). 

The other case that needs to be handled is when the funnel degenerates to a line segment. To account for this the algorithm checks if one of the sides is on the "wrong" side by using the cross product again, this time of the vectors made by the funnel apex and the right and left side end points respectively (R × S in the image below). 

Because every NPC has to re-path anyway when it finds it is executing an invalid path this should result in the behavior you are looking for. So when the zombie realizes at the top right corner there's a wall in its path you'll feed this new bit of local information to the algorithm: 

You could also define your areas using a Voronoi diagram, where multiple same coloured sites define an area. A map file will at the minimum contain a list of "sites", with their x,y coordinates and the area id they belong to (one of 1 through 5 in the image below). 

Option 1 is a very bad idea, you might aswell be coding in BASIC. Option 2 sounds good enough for a Snake remake. Now start coding! :-) If you were making something bigger than Snake, or are just using Snake as a toy project to get to know more advanced software engineering practices for games, go for option 3: component-basedentity-system. 

Some players won't spend the money, but the ones that will, will probably play more and consequently spend more. 

You'll save yourself a lot of time if you keep each scene graph "holder" object like this at the world coordinate system origin. 

Choosing the shortest splitting edge should result in a more natural terrain with a relatively small amount of work. Bonus: With a lot more work you can do even better by taking into account your height map's global features like peaks, ridges, valleys and drainage flow paths. For an introduction have a look at Section 3.2 and 3.5 of this article: Digital Elevation Models: overview and selected TIN algorithms. 

I suggest you use Steering Behaviors to simulate these types of behaviour. See this page for an example of evasive behaviour implemented in this way. The basic idea is you only consider simple properties like the position and velocity vectors of your prey and predators to compute the desired change in these properties in linear time. This results in responsive yet realistic behaviour. However, this comes at the cost of not taking other factors in consideration, like more high-level goals (the position of power-ups for example) or the position of static obstacles, as you would in pathfinding. These can be taken into account by combining the Steering Behaviors approach with, for example, potential fields (see Using Potential Fields in a Real-time Strategy Game Scenario (Tutorial)) or pathfinding (e.g. Corridor Map Method). In the case of the latter you want to decrease the update frequency (and trust the Steering Behaviors to compensate for any errors that might occur because of this) or do partial replanning, possibly combined with a more hierarchical approach (e.g. Near-Optimal Hierarchical Pathfinding (HPA*). If you want a more specific answer, improve your question with more details about your problem. For example, consider describing what your game is about and the number of NPCs we're talking about. 

In this picture, your unit's position is , can be found by adding its facing vector to its position, and is the position of the mouse cursor. The point of intersection gives you the endpoint for the movement. 

Your arrive behaviour keeps on triggering unless the moving entity has exactly hit the target. This is fine if your time delta and/or your velocity are so small that the position delta in won't overshoot your target, unfortunately, this is not the case at first. This results in the oscillation you see before the moving entity finally stops moving. To fix this, add an arrival threshold parameter, and change like this: 

Your question is quite broad and underspecified, so in this answer I'll focus on finding river flows. Within the field of computational geometry there is quite a bit of research on the topic of drainage networks on a terrain. An overview can be found in section 3.5 of this article: Digital Elevation Models: overview and selected algorithms. A useful starting point about drainage networks on triangulated irregular networks (TINs) - which sound like your existing vertex structure - is Yu et al., Drainage queries in TINs: from local to global and back again. I should note that the methods used in that article only provide you with realistic drainage or waterflow networks. Subsequent effects of erosion of the terrain is not covered. 

Only talking about the lower part of your image, since that seems to be what your question is about. You should separate your model from its view. One suggestion for the model would see each have an inventory-X,Y-coordinate. In that case you only need to check if there are collisions when you add an to the inventory (creating an which references the ), or when you move an around. An -object representing your inventory would contain a list of s, and could expose an interface similar to this: 

Collision response Depending on the gameplay you would either perform more fine-grained collision detection (maybe the AABB's contain meshes), or move forward to the next phase: collision response. When there is a collision the line-AABB-intersection algorithm will return either 1 or 2 intersection points depending on whether A ends its movement inside B or passes through it, respectively. (This is discounting the degenerate cases where A grazes B along their sides or along one of their respective corners.) Either way, the first intersection point along the line segment is the collision point, you'd translate this back to the correct position in the world coordinate system (the first light-blue circle in the second picture along the original v, call it p) and then decide (e.g., for elastic collisions by reflecting v along the collision normal at p) what the actual position for A at the end of the frame will be (At+1). 

Lots of variables going into that force, which is probably the cause of "the power is too great". You're also not linearly increasing or decreasing the actual angle but its sine, this means (if I'm not mistaking) that the way you're using "" in your code contributes superlinearly to the actual angle. Try this: 

The view can be anything you want, but like MarkR I'd suggest you use the canvas if you're using that anyway. It's arguably more "pure JavaScript" than using HTML (s) with JS (a.k.a. DHTML). 

You will probably need to create a specialized tool for map-creation, but your map will always be well defined (you won't have pseudo-degenerate pixels making your life hard, like the intersection of areas 6, 7 and 9 in your picture) and detecting collision/selection will be as easy as checking the nearest site. To make the borders more natural you could opt to add more sites in the map file and/or use a specialized drawing method in your engine. 

You could create and serialize the trie offline, then push/pull the resulting string to/from the client for unserialization. There is probably no need to roll your own code for (un)serialization. I don't have a lot of experience with modern Flash and ActionScript, but this seems to be a way to do it: $URL$ 

This means each move forward should move the funnel edges inward, this can be checked with the cross product of the vectors representing the old side and the potential new side (P × Q in the image below; also see in Mikko's code). If a move forward for a side would not tighten the funnel, we don't update that side for the current iteration of the portals (E). 

(As a side-note: I'm guessing this might make A/B testing problematic, as some (all) people will be used to playing for naught (some of the time), it will become hard to stomach when they find out have to pay to play all of the time when beta testing is over.) On the other hand, people are essentially gambling on themselves. Gambling is fun. Gambling is addictive. Gambling made me lose one my most prized marbles when I was in lower school. :-( I wish I could cite one of my favourite blogs on psychology and video games as an appropriate source for all of the above, but I could only find this piece: Sunk Costs, Pre-Orders, and Game Over. Which basically suggests that having players pay to play might not be so bad after all in the long run. 

(source) In short: most games are not accurate simulations of real-life. And if a feature costs money (and they all do) and does not add value (except to a handful of star gazers/gun nuts/medical professionals) it won't make the cut. This is why you won't see a lot of realistic nightskies/weapon reloading/gunshot wound treatment in games. 

You're forcing your players to make a purchase decision. The expected profit changes from guaranteed positive (getting to partake in a match) to a possible negative (the effect of which is exacerbated by people's tendency to be loss averse). 

This happens when an "earlier" bullet has killed one or more of your enemies, and they are removed with in such a way that now (e.g. when it was the last enemy or enemies in the ArrayList). A "later" bullet will now be checked against an enemy index that no longer exists, and throws an . It is generally a bad idea to thoughtlessly iterate over and remove from the same collection: you'll never know where your references end up (in this case doesn't point anymore where you think it does). One way around this is to have a separate clean-up loop when you know your "dead" objects can no longer be referenced. To know which objects to clean-up, either: 

Your condition system seems to have two orthogonal axes: temperature and poison. Represent them as such. When thinking about this you should separate transitions from states. and are transitions in the way you mention them, not states. 

Multiple moving AABBs To make this work for two AABBs that move in a linear fashion during a specific period of time you would subtract B's velocity vector from A's velocity vector and use that as the line segment for the line-AABB intersection. Pseudo code 

Assuming the players will attribute some value to in-game currency (for example, because they invested time in acquiring it), then yes, I'm pretty sure even a small amount will discourage players from partaking. The jump from free (gratis) to 1 credit is bigger than, say, the jump from 1 credit to 2 credits. In the first jump's case: 

Your terrain reminds me of the practicle example (Height Interpolation) used in the Delaunay Triangulations chapter (PDF) of Computational Geometry: Algorithms and Applications. Although they generate an irregular triangle mesh from a height map, the part on illegal edges might still apply to your regular triangle mesh. The idea is there are two ways you might flip the edge for every four neighbouring grid vertices (I'll refer to these as a quad later on). They define an edge as illegal if we can locally increase the smallest angle by flipping that edge. The chapter then leads up to using a Delaunay triangulation to get an illegal edge free mesh, but since you have a regular grid you can suffice by running through all quads and decide the splitting edge based on the length, like so: 

It is not possible to get the names of the PlayerPrefs keys at runtime. Instead you could opt for serializing your highscore table, and adding it as a string value to a fixed key in PlayerPrefs. This is untested C#, but you'll figure it out: 

It's not entirely clear, but I understand the unit will only be able to move in the direction it is facing. In that case you will need to factor that vector into the equation as well (next to the unit and mouse positions). Have a look at the equations in Minimum Distance between a Point and a Line by Paul Bourke. 

The code at the bottom of Mikko's blog post constructs the portals array, which is a list of line segments representing the line segments between the path's polygons. These are the "portals" the smoothed path has to go through (or the polygon edges from "let's trace the polygon edge midpoints"). Note that the portals list starts and ends with degenerate line segments at the start and goal points. This portals list is shown as the yellow dotted line segments in his pictures.