That would have been a delightfully short answer, but "body must be at least 30 characters; you entered 1". :) The X server is really usually called and you can just start it. You can set the DISPLAY number as an argument along with some other things. You might want to have some sort of session, though, and still go through xinit or such and start X with startx. You can use or such as a script and simply not start a wm there. You will need a "magic client" as the last command that stays running so X doesn't terminate immediately. In a traditional "failsafe" session, that was an xterm. If you know what to launch and launch once only, it could be that mplayer. Or any UI/wrapper that does the launching for you. When the last ("magic") client in the init script terminates, X terminates. If all you want to do is play video, you might see if rpi can run mplayer with directfb instead and skip using X11 entirely. 

Everyone of the 3 git repos you linked is for a specific component. The tests one constains a full program. You can infer that the Kernel needs patching, as well as some other components, from the first paragraph of the link you pasted: 

I love the Pi, but I have to tell you it doesn't hold the fastest IO in the market. According to this article on the USB performance there is a empiric limit of 30MB/s transfer rate on the USB port. And all the USB ports use the same IO interface. As that, the limit of all combined USB should be capped on that 30MB/s limit. If you take a look at some HD throughput charts you will see that the average HDD can pull much more than those 30MB/s, so, seems obvious that the limit on the port will keep transfer speeds much below the empiric maximum of most HD Drives. Given that the limitation is the port itself, connecting 2 HD will only make them share the available throughput, and not add to any speed. 

I think the problem is that type reads happen instantly and blocks. So the program spends its time in the sleep statements and after one branch is finished, it reads the buttons in a flash and goes into a branch where it sleeps some more. Unless you're holding down a button at the moment the read happens, there won't be a count. While the program sleeps, the buttons are ignored. You could try holding a button down long enough for the next loop for a start. You may need a slightly different approach than this loop for a real-time problem. 

You will probably need to figure out the pairing and connecting process. I haven't looked if there's a handy ui available for rpi for this, but you can script it or do it by command line. See $URL$ for some instructions. 

The answer is: it depends. If you are dealing with 1-wire bus sensors, which are digital and can understand individual addressing, it is perfectly possible. Just stack up to 10 of them in the 1-wire GPIO pin (check adafruit's tutorial on how to connect one and repeat for up to 10 in the same pin). This works, I have a configuration with 2 DS18B20 working perfectly. The i2c protocol is also addressed, and should support connecting more than one device likewise. I haven't personally tested the implementation used on the Pi to be sure. Other sensors/protocols might not understand addressing and just might not work. 

The names of the packages for programs and libraries in Debian (and Raspbian) are standardized, and sometimes differ from the names the libraries give themselves or the tag or symbol names for them. You should search for "curl" on the package system, and you will find the curl-related libraries, which might be what you want. Packages ending with a "-dev" are the ones you usually need when you want to have something compiled, they will install the includes and other files needed for that. Try a: 

It should be possible, in theory. Practically, you will probably need a breakout board or an adapter of some kind to match the connector and interface of the camera module. You will also need to find out how that particular module (or family) is interfaced with. If a datasheet can be found, that should contain useful information for both projects. For starting points, you might try looking for (microcontroller) projects using the same kind of camera module and if there are any kernel drivers for the module on other systems. In any case, it will most likely be a great deal of work with somewhat special skills and usually very weak and hard to attain information and political issues. In other words, a magnificient learning experience. I urge you to publicly document all efforts. :) 

I would suggest you check the DS18B20 1-wire sensors, which are digital, and have working kernel drivers. Adafruit has a tutorial on how to get them working. You can use up to 10 sensors on the same pin at this time (this is a hardcoded kernel driver limit, as is using the pin it uses. This tutorial has it right, just follow it). As for reading the results, it is as easy as finding a file with a predefined name pattern and then opening the file for read and parsing 2 lines of content. Using 2 sensors is as easy as duplicating the procedure for reading one. Each sensor will be made available in a different file in the file system. There is no need for any Java-specific libraries, procedures or tricks altogether. Just open a file with a particular name pattern for reading. If you use the same sensor, the filename will be the same between readings, so you only need to find the filename that the kernel driver creates once for each of the sensors throughout the sensor's lifespan. As for an expansion board any that makes pin GPIO 4 (which is P1-7) available is okay. That is the fixed pin number used by the 1-wire kernel driver. The Pi Cobbler from Adafruit is one of the many that will do that. 

Possible to connect some pins? With suitable wiring (maybe buffered), yes. Will it do anything useful? Probably not. Maybe you could step the head or something, but transfering data would require a pretty complex controller. It would indeed be better to go with a USB fdd if you need to read/write floppies. Pretty much all floppy drives are also (mostly) Shugart cabled, not PATA (IDE). 

Changing the user login name should work. It's just a piece of text for people to use. UID is the thing that actually identifies a user to the system. Some config files can indeed be using the name and of course the user has a home dir etc. You shouldn't edit passwd file by hand, but by tools like vipw or usermod. Remember that there's probably a shadow system as well, so you need to make sure they're both updated properly. I wouldn't try to rename a user but create a new one and either disable or remove the default account. Removing it risks a new user with the same uid (getting same file access etc) or login name (e.g. sudo rights) getting added later. 

It has torrent and donkey protocols in a light daemonized server, that you can access via a HTTP connection using a browser, even from remote machines. 

This is a known problem with libv4l2 and the Raspberry Pi. The thing is it tries to allocate 256MB os RAM to make that conversion, which is all the memory of Model A and half of Model B. If you are using model A your only hope is to create a Swap file/drive big enough for accomodating that conversion. 256MB should be the minimum. If you are using model B, free up some memory closing programs or just do like model A and create some swap space. 

Short answers: 1-No. 2-There is a 1.1A polyfuse after the microUSB power connector, so anything trying to pull more power than this (includung the 700mA for the Pi itself) will cause the board to stop functioning. 3-The return pin should be GND. The long version: First things first: there are at least 2 electrical motors in a floppy drive. And if I am not mistaken, they are 12V motors. So, I don't think you will go far using only the 5V power pins as for powering up a floppy drive. The Raspberry Pi, unlike other electronic hobby-targeting platform, has no protection whatsoever in the GPIO or power lines. That alone should drive every project thought to make use of these signals to think about some sort of protection, at least a transistor. You are talking power, motors. You should always use some sort of protection and never connect it directly to the Raspberry Pi. You can use the Pi as a controller, but shouldn't use it as Power Source. Use it to control some power circuit that will source the power you need. That said, according to the the Raspberry Pi Hardware guide: 

If you have the package, it will also do a timestamp saving trick to prevent the clock from being reset. That won't advance time while the device is off, so it will lag behind. The internal clock will also drift a tiny bit while on. If you have an Internet connection (or lan with a server) and run ntp (ntpd/ntpdate), you can get the time over network, as other answers point out. When synchronized, it is really quite accurate. Online servers will also give you the consensus "world time". 

I believe "TTL serial" means async serial you'd find in a common UART. A natural way to attach this printer to a PI would be to find a UART on the board (GPIO 14/15?) or attach one to another bus. There are a few good (FTDI, CP2102) and worse (Prolific) chips available for USB and loads for I2C and SPI. If the device demands handshaking, you'll have to worry about that as well. The Adafruit page doesn't seem to use any (Tx/Rx only if I read it right). If you do want to do this over actual GPIO (logically fine, but see others for warnings about electical compatibilty), you could search for "software uart". 

Deeper information can be found at the Polyfuses article on that wiki. The I/O pins also have maximum source/sink currents, and these are very low, signal-only. 

I know of two great sites for supplies and also for information on how to use external hardware with the Raspberry Pi. They are Adafruit and Sparkfun. You should definitely check Adafruit's Raspberry Pi Tutorials, where they teach you how to connect a number of different hardware to the Pi. Spark fun also has a number of tutorials, but they don't seem to be as specific to the Raspberry Pi as Adafruit's. But you should give them a look also. 

This is more of a convention than a REAL necessity for every case. 0x8000 was far enough from the start to be "clean" of interrupt addresses and null pointer addresses, so, convention started to use it as the beginning of the kernel address. According to the ARM booting procedures: 

If you're on the console (attached keyboard and screen) you should be able to use the Linux virtual console system to switch between multiple terminals using (ctrl-)alt-F1 through F12 and more with shift. The number of terminals configured and the number of them having getty processes (that ask you for login and password) depends on configuration. 

You will need some of the boot magic and a kernel that work on the board. These don't come with mainline Debian. You might be able to install these on a fresh card from some source (anyone have instructions?) or you might use a ready SD card image, but wipe the root partition to leave just the booting bits. Then you might be able to use that kernel and a Debian install initrd (maybe netboot versatile?) to boot into the installer. I did this while installing debian on an NSA310 and it works if the kernel is adequate and you can manage the boot process. You might also look at the Raspbian installer kit. Alternatively, you could use a second machine with a card reader and use debootstrap. If that ends up being cross install (e.g. amd64 installing for armel), you might need a few tricks. There should be several documents around describing debootstrap for arm boards. This I've only tried on i386, but will probably try for arm in the future.