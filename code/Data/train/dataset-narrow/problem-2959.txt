Racket is also Free Software, so I would go with that. (Sorry I said that I would not recommend one.) 

In like languages (C, C++, Java, C#, …), always use in the form (there may be some exceptions, but rare). So you are using to construct a foreach, as the language does not have the higher level structure. (C# has ; C++ has library implementations; Java has foreach, but uses keyword ) 

Do it in code, so that pupils can play with it. This code will throw an exception if the invariant is not met. Show how this can be useful in finding bugs in the program. The book a touch of class by Bertrand Meyer, is very good for teaching Object Oriented Programming and has examples (can't remember how many, but it is where I leant it). 

Warning: Wikipedia says that this was removed from the language in C++11, but may be back in C++20. It is interesting as this is the only place I have seen this type of checking, most other languages insist, incorrectly that the operators and return type of a multiply are all the same type. I would like to see it in other languages, but with much less complexity (though all of the complexity can be abstracted into a library, using a feature that has no other use). 

I'm not sure the following will work for all students, but I remember this being a transformative "aha" moment in my own education: 

Preferably contrasted against a functioning but god-awful student submission from the previous term. Show them how its an order of magnitude simpler than their shotgun-formatted needlessly complex mess. Show them what compactness and elegance look like. In freshman?sophmore? CS prof assigned us to write a CLI memory card game. I like many of my peers did this big elaborate class hierarchy and/or held the "cards" in nested data structures with nested loops. The prof's code was IIRC < 20 LoC: he used a flat array of structs with the modulus operator to determine the "row". I learned that day what Torvald's meant by "taste", namely the ability to know when to use "industry best practices" and when to just write simple code even if it's less flexible. I realize that's almost the opposite point than the one you're driving at (i.e. getting them to use the more advanced constructs) but show in your code that they exist for a reason. If you can replace 50 lines of tedious, error-prone buffer manipulation with a built-in collection and an iterator/forEach that takes less than 10, believe me the smarter ones will notice. And when they collaborate with their peers on group projects peer pressure will help with the slower ones. 

Art Pixel Art I have recently seen some binary picture change t-shirts. See $URL$ Pupils could make these in Art or textile classes. Each pixel is made with a thread through two sequins. If the sequins differ in colour then, when you rub your hand over them, that pixel will change colour. (Alternatively you could use sequins that are two colour.) You can link this to how computers display images. Also explore how pixels are no longer noticed, if viewed from far away. 

Note I say part of. I have done this for a commercial product. I kept asking how much of this needs to me assembler. I kept being told this dose, I would push back and say no just this line of this routine, so call out to another routine that is implemented in assembler (the compiler will do call optimisation: in-lining). We got an operating system down to 10 to 20 lines of assembler (not including what was in compiler). 

Ensure that you have experience first The worse thing you can do is tell them that they are doing agile, but then do something that does not work. (This seems to be the normal approach in industry.) It will lead them to think that agile does not work. So first ensure that you have a good grasp of the concepts. Select some useful agile practices «Test first», and «one thing at a time», are very useful tools in teaching (but without automation, until later). Having students just do one thing at a time, can help to rid the feeling of being over whelmed. Planing a test before writing code, helps students to think about what it is that they are trying to do. Another similar technique is «re-write the assignment in your own words». «Pair programming» from XP, is also useful. Groups and pairs have been shown to help learning. «You are not going to need it»: is there anything that you are producing, that you don't need yet. Don't produce it until you need it. «Automate it»: So you got to the end and did not need a flow chart, so did not make one. But the examiner insists that you need one in your design. Therefore use a tool to generate one from you code (they will never know). «Do the simplest thing that will work»: Why complicate things. This could mean using techniques that you already know; using a library; Use a «revision control system»: This allows you to exhibit «courage», as you will not loose all of your hard work. Accept «feedback», try things, make mistakes, learn from them. In writing this, I have just selected agile/lean practices will enhance my teaching and students learning. The others can wait for another day. Tell the pupils that you are doing this: tell them that you have selected a sub-set of practices, and why. 

Enjoying the process is a double-edged sword. You think my job is to write code? My job is to solve problems. Code is often the worst way to solve problems. I enjoy the process, and I constantly have to remind myself that the means are not the end. In my experience, most techno-religious "debates" are perpetrated by people who enjoy the process. Most "bikeshedding" arguments too. Now, maybe your son just isn't that in to it. Maybe this isn't for him. But maybe he's juuust into it enough to be a good engineer, without being too into it. 

You start by explaining how CS is different. One thing that is not going to be immediately apparent to high school or even university students is how young CS is as a discipline compared to other subjects. Or rather the ramifications: they probably won't realize how different that is from the other subjects they get in the core curriculum even as they're memorizing important dates. Every subject has a forefront of changing knowledge (one that high school and undergraduates basically never see) but for the most part that's all CS has. For every quicksort or lambda calculus there's a hundred things that have become common place in the lifetime of your students. So unlike math, science, literature, etc. which have centuries if not millenia in their bodies of knowledge CS has decades at best. So you explain that, you explain that over the course of their careers as computer scientists or software engineers they will almost certainly constantly have to learn new concepts/tools/techniques, and that you are doing that right now. And that's actually quite exciting even if it makes for some conundrums like yours: how many fields can you be in where you, Joe Blow/Jane Doe programmer, can possibly make or at least contribute to a meaningful advancement? 

I worked on a professional project. We chose C++, as we could see that there were a lot of C++ programmers out there. By a short way in, we realised that we were wrong. There are a lot of programmers that say they are C++ programmers, but most are incompetent. Not because of them selves, but because of the language. It took a lot of training to get them and ourselves up to speed. Many to many relationship of features. 

As a step toward learning binary or hexadecimal. Show that we use many number bases everyday: base 24 and 60 in a clock; base 7 and base 30ish in a calender; base 16 and 14 in weights (in US); base 12 and 3 in distance (US); etc. Then introduce octal. Octal has an advantage that it is not too different to Denary (Decimal), and that it dose not introduce new symbols (like hexadecimal). After octal, head toward binary, maybe brefly explore the idea of other bases, and ask how low can we go? Binary is the limit. Then binary to octal, but look at how this does not fit will in to 8 bit bytes. What can we do about this. Base 4 or base 16. Base 4 does not help us much, but is used by DNA. Base 16 helps us reduce number of digits, but we need 6 more symbols (a-f). 

TL;DR Those two aren't your only options. The main concern is cognitive load: learning to program is difficult enough without adding incidental complexity. We've seen an explosion of hybrids in the last few years with good cross-platform support: sublime, atom, etc. And while you couldn't pry vim out of my cold dead hands, learning it is easy if you already know programming but would be a nightmare if you had to learn it and programming at the same time. Ditto for emacs. And that also applies to IDEs like Eclipse and Visual Studio. They have their own way of doing things. They take forever to open. They are user configurable but not easily. I'll never forget the first time I opened XCode and basically said "what the hell is all of this?" Have your students download atom which works reasonably well out of the box with a healthy plug-in community for growth. It's scriptable in JavaScript and themeable with CSS. Unlike notepad it gives you features you actually need to program, unlike nano it uses standard keyboard shortcuts they'll already know from e.g. MS Word (Ctrl-C, Ctrl-V, Ctrl-S, etc). And unlike VS/Xcode/Eclipse it doesn't obscure what you're doing: editing text files. Edit Can't believe I forgot to mention this but... They more or less made us use Komodo Edit (free version of the Komodo 'IDE') in my first programming class, which is exactly the kind of thing I'm talking about and I think it really helped. Simple, no configuration necessary, things that should be easy were easy, etc. Don't know if they still offer it or not but I'd Atom is better along just about every conceivable metric. 

Reason 1 : Because without printing it out you can not weigh it. When I was an university, there was a myth that some lazy teachers (I don't know the technical terms for the roles), would weigh your reports, and give a grade base on that. I heard of one student that handed in some work with a load of blank paper attached, and got a good grade. Reason 2 : To see how complex it is. I remember a story by Michael Jackson, about judging how brilliant some one is. I will include the last 3 paragraphs here. 

There is “A touch of class” by Bertrand Myers. It is a very good book, at least a semester worth of learning in it. I did not get OO, until I read it. I had previously done C++, java, C#, and some python. But when I read this book, I started to program OO properly. The book uses a language called Eiffel. It is a good teaching language, and also used in large systems, safety and mission critical systems. It is probably quicker to learn Eiffel then another language (or two), than try to learn other OO languages from scratch. (This is the authors clame, and my experience as a learner) 

Hate to add yet another answer, but this needs to be said: there are three things that matter: how to communicate with people, how to communicate with people, and How to communicate with people. Frameworks change. Testing practices change. Version control systems change. Languages change. Algorithms change (simpler but slower as the hardware gets faster). Hardware changes. At some point hopefully in my lifetime hardware architecture will change (away from Von Neumann to cellular automata et. al.). Even a person can change. But people don't change. Peopleware, Mythical Man Month, etc. are every bit as relevant today as they were decades ago. You will have to deal with bosses and coworkers. You may also have to deal with vendors, clients, customers, direct reports, and employees. You will have to go on job interviews, pitch ideas, give presentations, write documentation, send email, and even write policy. Software is a second career for me, I was already an adult when I went into the field. Before doing so I interviewed a bunch of people through my network who were in industry and I asked them what they wish they'd known going in. To a man/woman they said some variant of "people skills". If you are sending your graduates out into the workforce without a solid grounding in this area then all the technical prowess in the world won't help them. They will be rated "hire, but not for my team" in interviews.