I'm going to return and exchange this Raspberry Pi 2, but wanted to know if anyone has seen these errors before: I have one RPi2 (out of 13 I use for my after-school program) which acts up during boot, often giving this output (looks like a kernel panic): 

What you are likely seeing is the result of your SENSOR->LED->GPIO6 line being in a "floating" state - it is not part of an active circuit and hence the voltage on the line is fluctuating. You will need to enable the pull-down resistor on GPIO6 by replacing with 

You should expand the filesystem after your first boot into Raspbian. You can do this by running from the command line (terminal). In Jessie there is also a menu option under Preferences that allows you to get into a graphical interface for the Raspi-config command, which also allows you to expand the filesystem to use the full card. The filesystem is deliberately small so that the image you use to create the disk is not unnecessarily large, and to make sure the image works on any size SD card (as long as it is bigger than the original image size). 

You seem to have some misconceptions about what a Raspberry Pi is. A Raspberry Pi is a proper computer (as in: it has a processor and a GPU, memory, input and output connectors) which, just like your Windows and Ubuntu machines, needs an Operating System to do anything at all. That OS can be simple or complex, but most OSes available have a default GUI for you to work with (but can be configured to give you a text-based login as well). Then, once you have an OS up and running, the RPi allows you to connect to external hardware using the GPIO, for which it has a range of tools available (RPI.GPIO is just one example for when you'd like to program using Python). This is where the RPi differs from a normal computer - the availability of GPIO pins (combined with 5V, 3V3 and GND) to interact with external devices. If you want a device to which you just upload some code and it interacts with external hardware, you might want to look at Arduino (and its clones), this type of device has a microcontroller (not a microprocessor, though the difference is sort of theoretical) on it which does not need an operating system to function. You write your code on another device (e.g. your computer), connect the Arduino, flash your code to it, and voila! it runs. 

The rPi (typically powered via USB) The opto-coupler on the board using the 4pin header's VCC - typically powered using the 5V (or 3V3 volt) pins on the GPIO header The relays (either powered from the same 5V supply as the opto-coupler when you put the jumper across the 3-pin header's VCC and JD-VCC, or separately powered by removing that jumper and supplying 5V to JD-VCC, the latter would fully isolate the GPIO pin from the relay) The pump itself - my answer above shows how you can do this with a separate or joint 5V power supply, but you could just as well use a 12V supply or 9V supply if you have those handy. This power supply gets its positive wire attached to the middle screw terminal of the relay, and either the left or the right terminal (but not both) go to your pump. 

I thought about suggesting to replace the 433Mhz receiver module with a 2.4Ghz transceiver. From the looks of it, the 433Mhz receiver module used in that relay is exactly this one. You could desolder this module and replace it with a 2.4Ghz WiFi receiver/transceiver - BUT this would likely not work, as the relay has firmware that knows how to communicate with the 433Mhz receiver, but not with the 2.4Ghz WiFi receiver. So it is extremely unlikely that option would work. 

Install one of the many many database packages in a terminal window using (e.g. ). This site has an overview of all the Database packages you can look at. Use the Pi-Store on the Raspbian desktop. It contains many applications - however, I've noticed some that require payment even though via the first method they are free. Instead of getting a dedicated database, have you looked at LibreOffice? You could use LibreOffice Calc (an Excel clone) as a simple database. 

I'm about to throw in the towel on this one: On my RPi2B (Jessie) I am using HDMI out (HDMI->DVI cable to monitor) but want to use Headphone out for Audio. I've done the typical trouble shooting steps of using to force audio via Headphone out, and tried changing the audio config files to force audio as well, but so far only OMXPlayer uses the Headphone port; any other audio (such as in Scratch or in Audacity) goes via HDMI. keeps showing HDMI as default device as well. I'm looking for any tips on what I can still look at to force ALSA and/or PulseAudio to use the headphone out. I assume the conflict is somewhere between these two audio layers. Who can help me out? 

Of course all those IP addresses and masks need to be modified to your specific scenario - the modmypi article explains how to do this. EDIT: From the comments it is clear that you are trying to connect the Pi via your Mac to your Internet connection. This requires you to set up Internet Connection Sharing on the Mac, the procedure for this is detailed in this article.. The basic steps are: 

Not a direct answer to your question, but have you looked at using a USB PoE adapter? It even comes with a female USB cable for power, to which you could plug a USB-micro-USB cable and power the rPi the safe, factory-supported way. According to the questions on Amazon, many customers use this device with an rPi. If you already have 48V PoE running, this TP-Link adapter might be a cheaper option. If you want to replace the jack itself, you will have to measure the pin setup on your rPi (distance between pins etc.) and then compare with what is available online - digikey.com has at least 45 different PoE MagJack's available - one is here: $URL$ The MagJack is likely bigger than the one current on the rPi, so you'll have to accommodate for that. Look at the datasheet and compare it with your metrics and you know when you have a good candidate. 

This should help you locate the # sign and any other keys you'd need. Note that the key with the ~ and the # sign is often located next to the [ and ] keys on the row above its pictured location. 

Set0 and Set1 are switches on the ITEAD PN532 card - physical switches indicated on the card itself with the words "SET0" and "SET1". To enable SPI mode, make sure SET0 is set to L (Low) and SET1 is set to H (High) by sliding the white switch to the correct position (marked with L and H respectively). 

As far as I know, Ubuntu Snappy only works on a Raspberry Pi 2, not on a Raspberry Pi B+. See here: $URL$ 

Sometimes it does not give this kernel panic, but instead gives garbled display output, like in the below image (note - the image looks like it is out of focus, but that's actually the video output from the RPi - it seems to superimpose text output with a slight horizontal offset). Note the green lines on the right side: 

I updated an older Raspbian Jessie image (imaged around April/May of 2016) using , followed by an straight after. This is on an RPi 2 B. A reboot resulted in a quickly flashing boot screen with 4 Raspberries, followed by a reboot, ad infinitum. Is there any way I can get this image back to working order, without starting over? I've looked in `/boot' but cannot see older kernel images or anything I can switch to. Any other tips on where I should look to find the fault in the boot sequence (e.g. a log file or something) would be much appreciated as well. 

It all depends on which Minecraft he is using (the title of your post says "Minecraft Pi Edition" but just making sure). Is he playing Minecraft (Linux edition, currently 1.8.8) on it, or Minecraft Pi edition (version 0.1.something)? Big difference between the two. For the first - I'm not sure it will ever run smoothly, even on an rPi2. You typically need a multicore laptop/desktop PC to run Minecraft. The latter (Minecraft Pi Edition (aka mcpi)) is made specifically for the rPi but is a REALLY old version, no mobs etc., more intended for programming purposes. It should run fine (but of course much "finer" on rPi2's 4 cores than the rPi's single core) on either version, provided you make sure it uses the VideoCoreIV GPU (which it should use by default). 

From what I can see you made a .o file (), not actually the arduPi program. This file is a library that you need to link into the compilation of whatever program you are building with that library. If you are trying to compile the test file , you would need to do this like so: 

This is likely caused by an undersupply of current. As per the conversation in the comments - you are seeing a rainbow-colored square in the top right corner of your screen (not on your picture) which is the rPi telling you that it doesn't have enough power supplied to it. Switch to a more powerful supply such as this 5V 2.2A supply and it will likely boot all the way. Or alternatively remove some of your USB peripherals (disk, wifi, mouse) to reduce the power consumption of your setup. EDIT: And if you are indeed already using a 5V 2.4A supply, you have a faulty supply, because 2.4A should be enough to boot an rPi with keyboard, mouse and WiFi attached. I use a cheap USB volt/amp meter (like this one) in combination with a microUSB-to-USB adapter to check how much amps my power supplies provide - sometimes what they claim they deliver is far from what they actually deliver, the Amp rating might be maximum "burst" or "peak" Amps, not the continuous supply capability. 

From that definition, the manufacturer of your HDMI-VGA adapter probably used definition #1 as the "passive" description. However, given the fact that HDMI is a digital standard, and VGA is analog, there is no way the adapter could also be "passive" from the perspective of definition #2. Now to your question's answer: I use a "passive"(definition #1) HDMI-VGA adapter regularly with my rPi's (both B, B+ and 2B) and it works, IF AND ONLY IF I plug in the adapter before the rPi turns on AND the monitor I connect to is already turned on as well. If I try to add my HDMI-VGA adapter while the rPi is running, I get no signal. Can you try this? If that fails, make sure you have looked at all the HDMI configuration options in /boot/config.txt - perhaps you need to force something there to make the dongle work. I would NOT start with trying to modify the dongle - it should be properly powered from the rPi's HDMI port ("passive" as per your manufacturer) - the cause is most likely in the two things I mentioned above. 

According to the documentation, the device you link can be used as an SPI device. Unfortunately, with the default pins for SPI, as far as I know, you only get 2 Chip Select pins, so you can drive maximum 2 cards this way when using standard available libraries. If you want to drive all 4, you cannot rely on those libraries and will need to do some bit-banging (unless my quick google search skipped something of course), but it only requires 2 extra GPIO pins (Easily available) or can even be done with the original 2 pins if you use a demultiplexer IC (0,0 = card 1; 0,1 = card 2; 1,0 = card 3 and 1,1 = card 4). Now for some alternatives: 

That sounds like the longest and most complex route to get the Pi to display via SCART. There is a much easier route: get a composite cable (if you have a Pi A/B) or a 3.5mm to Composite cable (if you have a Pi A+/B+/2B) and a composite to SCART adapter. Here is a post that shows how to use this (it's about installing Rasplex but ignore that part). An example 3.5mm plug to composite cable is this one: $URL$ and an example composite-to-SCART adapter is this one: $URL$ 

You can then turn these circuits into PCB designs, and even order your PCB printed right from Fritzing itself. Outputs generated are compatible with what most PCB service need as inputs. 

UPDATE: As discussed in chat - the RF24 library included in the github link for pyRF24 ($URL$ does not have the BCM2835_PERI_BASE setting which is what helped you get the C++ version working. You'd need to see if you can compile the pyRF24 module by replacing the RF24 version included with the version stored here: $URL$ Actually, that github library (edoardoo) ALSO contains a pyRF24 wrapper with a setup.py script. Can you try making your BCM2835_PERI_BASE change there, change the architecture flag for the rPi2 and then build the librf24 and the pyRF24 wrapper from that source? Here are the steps you need to do (Actually, you confirmed in Chat that these steps worked for you - so kudos to yourself) - this gets the wrapper to work in Python2.7, not Python3: 

should work. Similarly, if you want to do something with the relay, use the pfr_relay variable. By the way, these are very basic programming constructs (variables and object references) so make sure you get comfortable with programming in general and programming in Python in specific before attempting more complicated code. UPDATE: I've done a quick check in the PiFaceRelayPlus docs, and found the following example code (executed in the Python Shell): 

On other occasions (typically the first boot after being switched off for a while) it seemingly boots into X, but never renders graphical output - my monitor suddenly says "No Input" and only the red light on the RPi is on. Anyone seen this before, or have an idea of what is happening here? My best bet is that the VideoCore IV GPU has an error. PS: I'm booting Raspbian Wheezy, but get the same issue when booting a fresh Raspbian Jessie. I have tried several different SD cards, all of which boot fine on my other RPis. UPDATE: Ran the faulty RPi using Jessie in a different setup and managed to get into the desktop. Then ran it back in my original setup (still with Jessie) and also got into desktop, repeatedly. Booting into my trusted Wheezy image (tried and true for hundreds of boots on all my other RPi's): ERROR. Put Jessie back in, boots. Only difference I can notice is that this RPi has a small label "Made in P.R.C." on it, whereas most of my other RPi's (haven't checked all of them yet) are "Made in U.K.". Is there perhaps a firmware difference?