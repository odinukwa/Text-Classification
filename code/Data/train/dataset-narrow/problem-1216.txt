For the most part, I don't believe in catching exceptions unless you're going to do something about them. But re-throwing with more specific info is a perfectly valid thing to do. Also, I don't like to have functions other than printing to the console. I'd prefer to re-throw with a new message, catch the exception in , and print the message. Related to this, I see the following code in : 

I ran your code and messed around a little with it, and it works pretty good. You also have a pretty cool idea here, that I might have to steal next time I do a TKinter GUI. As far as high-level design, I agree with your decision to have each entry line be its own objectâ€”it's much easier to think about than the other approach you described, with the class directly managing the TKinter objects. You've added enough behavior that these things aren't really the same as their constituent objects anymore, so it makes sense to make a new class that deals with that. I don't really like your list approach, though. It looks to me like you're doing parallel arrays, something that gets used in C a lot since it doesn't have a real dictionary type. You rely on the keys and values (entries) being at the same position in two different lists. Normally, I would prefer dictionaries. If order is important, you can use the class, assuming you're using Python 2.7 or above. (It looks from your TKinter code like you're using Python 3.) To me, an ordered dictionary feels cleaner and more Pythonic, and there's no danger (however remote) of your keys and values getting out of sync. (I say this as someone who spent a year coding all my dictionaries as parallel lists because of the habits I developed after taking C++ at university.) As I mentioned in my comment, I have some issues with the way you've named things. Per PEP-8, the standard is to use CamelCase for class names and snake_case for functions and methods. I realize that is horrible, though; in Java they would write , but PEP-8 prefers that you keep fully capitalized acronyms fully capitalized. To get around this, I'd recommend just changing the name. If I'm reading the code right, is a container for instances, so you could call it something like . I'd also recommend changing . It's a pet peeve of mine, but I hate it when people name things with "my". It seems to be a Perlism; in that language, you declare variables with the way Javascript and Scala declare them with . I dislike "my" because it makes names longer without really adding more info. Really, what does have that doesn't? As far as I can tell, two extra letters. Finally, I'd recommend a cleaner way to manage conversion functions inside . What you have now is basically a giant switch statement, which somewhat defies extensibility. Functions in Python are first-class, so you could instead store your conversion functions in a dictionary. I tried it out, and it looks like functions are even hashable, so you can use them as dictionary keys if that's what you need. Your dictionary values could be tuples or dictionaries which give the settings of variables in each case. Let me know if you need to see an example, and I'll edit to add. This approach would also strip out a lot of code in your function working with . This is good, because it's usually considered better style to keep your function lean. If you need to do something complicated, you can write helpers (which would be private in Java) and call them from . It could use a little cleaning up, but you've got some pretty well-designed code here, and a good idea for a helper class to speed along GUI development. 

Regarding the code inside the block in , rather than trying to minimize that code, I would think about what other exceptions you might be able to catch and handle at that point. Try doing some of the other calls from that block of code in the interactive prompt, with invalid data, and see what they toss at you. I don't think it's too much code anyway. I wouldn't put it in a separate function; while it may be several lines of code, it feels "mainy". As you say, it's the meat, or maybe more like the backbone: it provides the structure that binds together all the other code. I think it's fine where it is. I see some issues with your use of exceptions. Regarding the code inside : 

Rather than print a message from inside this function, I would probably re-raise with a new message: 

At the very least, I would have my methods return . Then you can chain calls like in Ruby or JQuery; your main can be: 

Now is longer and a bit uglier. But this way, all the logic for is in . You expected to return a vector of vectors, but as it was before, relied on processing each line into a vector, so the logic of one function was spread across multiple functions. Notice how the whole thing is now separated into a general portion, the function, which could be useful again later on when you need to read some lines from a file, process them in some way, and return them in a sequence; and a specific portion, , that contains all that bits which are only relevant to the problem you have right now. Pursuant to that, I don't really like that is private. It seems like a perfectly good, general, widely useful function. For example, suppose we have a CSV file with columns , , and , separated by spaces. Then we could write: 

But consider cutting down on the amount of context your class stores, passing more things in as arguments, and returning results, e.g. make take a directory and a list of allowed formats as arguments, and return a tuple containing the list of found movies and the list of skipped movies. Then you could write something like: 

Your capitalization convention strikes me as odd, not just for Python, but for any language I've ever used. Not only is it hard to read, but things cased LIKE_THIS are usually constants in Python, so this usage will confuse Python programmers. Many other things about your code formatting are also confusing or unconventional. Please do check out PEP-8. Your function is quite long. I'd recommend trying to split everything under into its own function. Also note that the comment marker in Python is . The syntax is for strings. Python allows you to put one of those as the first thing in a function or class, as a documentation string. You can then read documentation interactively on the command line. If the triple quoted string isn't the first thing in a function or class, it's just a string literal that never gets assigned to anything and disappears. As a personal request from me, please don't document your code like this. The performance hit is probably negligible, but it's just weird and wrong. Stick to a doc string at the start of a function or class, and regular comments for things that aren't going to be part of the code. It's more common when you have a script you want to run from the command line to write it like this: 

In your main program, you can catch the rethrown exception and print its message. This is better than a version without a / clause because we can add information to the exception about what went wrong to make it easier to debug. This is better than the version with a print statement because callers of the method can decide how they want to deal with this, instead of being forced to have a print. It's also usually considered bad style to use a bald clause. For debugging, just let the exception stop your program. Printing is not very informative, and doing so can also mask the real cause of bugs. Look at the following highly exaggerated code: 

I recommend against having print statements inside classes. One of the benefits of classes is code reuse. Having print statements inside class methods makes the class less reusable. Some of these can just go away, or they can become logging statements if you want. The ones inside your clauses should probably become rethrows. They can also be logging statements if you want. I would probably write it like this: 

Now does not ever update the game state directly; it just returns a map of things which have changed between the previous version of the state and the current one. merges the new state and the old state, replacing the values which have changed and leaving alone the ones which haven't. This kind of refactoring could also really clean up Your use of a bunch of chained definitions in a is something I've seen in lots of other Clojure code, and it is purely functional, so I wouldn't worry about it. When you calculate from , you're not doing IO, you're not destructively updating a variable, and you're not breaking referential transparency. Another thing Hague suggests is keeping around only the minimum amount of state. He advises figuring out which pieces of data depend on other things, and calculating them as needed, rather than storing them. In your code, you could do this with ; instead of an atom that contains the current power, you could make another function, . The Enterprise state could contain a base power level that you pass to , and then the function can calculate the actual current output, returning a lower number if damage has occurred, and maybe a higher number if you've got some kind of secret Romulan power generator installed. This would also clean up a bit. Here's a slightly cleaner version of as an example of all the suggestions I've made (except that it still has the global game state):