Visibility modifiers and names types are by default . You can choose to remove them. is a very broad name for your , so you can consider just calling it . and Instead of assigning the result to , you should directly from each , i.e.: 

... or overloaded output building methods Alternatively, you can use overloaded methods that take in a specific implementation (one of the rare cases where you'll actually want the method parameter to use the implementation), and a helper method to do the appropriate casting. It's all about managing the resolution outside of the stream-based processing. :) 

Also, your bracing style is quite inconsistent... sometimes you use the Java convention, sometimes you don't, and sometimes you omit them completely. I will suggest sticking to the convention throughout to improve code readability. 

You can consider implementing the interface so that you can potentially open up its usage as an implementation of the Collections classes. Your field seems to be underused here, as I can sort of see a method using it too... BTW, regardless whether you use the interface, your method should be written as , to follow Java methods' naming convention as 'is...' for return values. Back to talking about Collections classes, they throw when no element can be returned, e.g. when empty, so perhaps you can throw that too instead of . Since you are relying on your inner implementation, you can consider having your field declaration as too instead of , this being one of those cases where using the implementation (class) rather than the interface makes more sense. With a , you can replace with the neater method . In your method, if you are on Java 8, you can consider : 

If you are going with the (i.e. approach "2.2") way, you will need to call . This reuses the instance throughout the method: 

Instead of parsing output carefully to feed into , I started from the output of and then replacing each entry with its output. is used to fix the number of 'columns' we want to pick up afterwards, which is in turn used to print the appropriate newlines. Finally, I feed the output to as a final attempt at pretty-printing. is used as the delimiter throughout. It still doesn't look as nice as the default non-piped output, but at least it's something I suppose... edit 2: Bonus question, round 3... I hope this is what's required... :) 

I must admit, this is taking things a little to the extreme, and I'm conveniently relying on the assumption that passing extra arguments into will be silently ignored (tested). Otherwise, I'm actually pretty OK with what you have in your question. :) 

If this process has an associated Activity, set it to the VisualProcessStep instance Currently, you are looping through to see if there is a matching activity. I will suggest creating a new method that also accepts the activity ID to look for (assuming it has its own type, e.g. ): 

Sure, readability is sacrificed, but hey, just one statement! By taking advantage of and its return type, I can optionally store the output of the current iteration's breakdown (when the quotient is not zero), and determine what should be the next value to recuse with (the original , or the modulus). edit I suppose I can improve the readability somewhat by this... 

Looping once, aggregating multiple values Inside , now renamed as , you are streaming twice on the argument. While this shouldn't be an issue for most cases, there is still an option to just loop once should it be one of the remaining places to optimize (hopefully with some runtime analysis/micro-benchmarking to prove it). This is achieved by creating the instance yourself (instead of relying on ). To avoid similar calls, you can also get a reference to it once. Putting it altogether: 

We then just need to 'recursively' call this with the five arguments, and a or as a 'starter' with : 

This is a personal preferences thing, but I'm not a fan of prefix in variable names, since this is not exactly a recommended Java naming convention. I understand your usage here is to let you conveniently name your values as numbers, so it's really up to you whether to stick with it, or go with , , , etc. You also don't really need a field for it, since you can always return (or , shorter due to the implicit casting of ) from . One more thing, types' names are usually singular, but since you have consistently used the plural form, I think this is fine too. Generally, consistency over convention, over chaos. 

Testing a number of inputs and expected results is relatively easy with TestNG's parameterized testing feature. You need a , and link it up with the method on the method now: 

is just a simple wrapper for a that checks for the incoming length first before calling the methods on the instance. Like I said earlier, I'm not sure at the moment whether there is a more concise way of doing this or not. I also had to rely on a boolean value to ensure we have at least the first word as the output. The test for it: 

A : Possibly simpler to understand, at the slight expense of not being 'resource-efficient'. This is a stateless operation. A : Appends the conversion result to a supplied to minimize object instantiation. This is a stateful operation on the . 

The usage of on the instance is recommended to manage its underlying I/O resource cleanly. Potential bug The screenshot you currently have does not agree with your code, since it looks like Mark managed to remove 8 from 7 in pile 'C'. The same prompts confused me here... Maybe use a prompt that indicates an invalid input was encountered will be a bit better. 

is used here just so that can be used as a special placeholder to effectively ignore further computations when a is encountered without a matching . It doesn't look as streamlined as I hoped it would be though, and I think for most intent and purposes the non-stream-based way works and reads just a little better. 

For what it's worth, the method signature to over-ride should really be (with the necessary check for the correct type), and you are also recommended to over-ride the method. 

It's also recommended to use on your instance for safe and efficient handling of the underlying I/O resource. 

It's usually recommended to prefer the primitive type over its wrapper class, unless you have a clear intention to return values for indicating the absence of a value. Interfaces over implementations 

You don't really need both and methods, with the latter performing input validation. What you can consider is to take two integer inputs and pass them into a static factory method that will do the validation for you, and throwing an if necessary. 

Instead of looping one more time through your array, consider expanding the iterations on your first loop and then exiting from there once you reach the desired result: