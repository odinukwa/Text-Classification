Diagrams are a great way to communicate, document and aid your design, and design is the most significant part of software development. UML has a lot of features but you are not meant to use them all at the same time, only the ones that are useful. When navigating in a new city, do you actually stop and look at a map, rather than just continue and follow signs? That's what design vs coding is about. When things are unfamiliar, when the problem is complex, when you feel lost, that's when thinking about design is most helpful, and it's better to do it earlier than later. It's much easier to change your design before you've implemented anything. Diagrams are a great way to visualise the problem and help your design, especially for visual thinkers (which is most of us on gamedev I'd imagine). A lot of problems become trivial, defects become obvious, when it's clearly mapped on a diagram. Some issues you may find in a diagram: 

Whatever's most convenient, but you'll find that more atomic commands are better simply because of code reuse - surely isn't the only command capable of inflicting damage? 

It would be easiest to keep around the dead units and flip an flag to revive them. But you raise an interesting question: how to maintain references over the network? Most network-ready game engines should have this solved for you and offer some kind of "universal entity reference", but if you are rolling your own, my suggestion is to use a portable, container-agnostic unique identifier. Yes, if you assume your clients are running the same binary then you can get away with more specific references like memory offsets or indices, but using unique identifiers will save you trouble down the road, when switching containers or dealing with non-determinism. For most people, all it takes is one hours-long debugging session over invalid references for this investment to pay off. 

You can either promote the impossible cliff to a 1 (noting that this could set off a recursive process due to the promoted 1 creating new impossible cliffs): 

Now that the equations are in reduced row echelon form, you can start plugging in values to see which ones work. Note that your matrix isn't completely reduced, which tells you there are many possible solutions. Let's start with row 2: it is basically saying: . Obviously keep in mind that you can't have negative numbers of anything, which implies that you can't have more than 8 of anything. With that in mind, we can plug in 8 for the number of bars, which means 0 pizzas and 0 cakes: 

When dealing with different frames of reference interacting with each other instantaneously, you have to compromise somewhere, you cannot have everything consistent everywhere; that's a fact of life. The scenario you have outlined is basically this: the shooter thinks she has hit her target, but the target thinks she has successfully hidden behind an obstacle. Who is right? That's for you to decide, but I'd argue that games that emphasise shooting - with fast projectiles - should favour the shooter, whereas games that emphasise moving and evading - with slow projectiles - should favour the target. (You could of course do both in one game depending on factors such as the speed of projectiles.) 

That depends entirely on which cheap gaming console it is and what system it runs. There are a few popular choices and people have made plenty of homebrew games for such platforms, so it is a possible, albeit difficult task. No matter what option you go with though, you will need to rewrite the game. This is because I'm guessing you're using a Windows version of RPG Maker. There are versions of RPG Maker that are for other systems like SNES or DS but they are very different products. These days cheap Chinese gaming consoles fall under the following categories: 

There's no reason you can't have both, using the Facade pattern to translate from one interface to the other underlying representation. For example, using Sean's SOA/AOS terms: SOA facade 

You also mentioned that you run into problems when there are >50 events, or there are delays of up to seconds. This is much smaller in scale than the scenario described in 1500 archers, so see if you can profile your game and find out where the slowdown is. 

There is a C implementation of the easing functions here: $URL$ You can use it as-is, or if you want to make your own custom function (such as a bounce that bounces less, or quicker), take a look at the code - it's fairly easy to understand. 

There's no way a single Perlin noise generator, no matter how well tweaked, will recreate these features. Hence my suggestion to use a multi-phase generator, with something to create those ranges, and Perlin noise to add the fine detail like peaks. Have a look at libnoise, an open source terrain generation library. It uses a composite generator, which includes one that generates ridges. Here's a sneak peek of what it's capable of: 

What happens on your client? Do you momentarily die and revive? Do you ignore the peer's input altogether (then what's the point of having p2p)? I'm sure you can come up with many more edge cases like this. Finally consider the limited benefit of such a scheme. It might be a boon if you and your friends are all geographically close (say, you're all in Nauru) but the nearest hosting server mandated by Modern FPS 2015 is in US West. You will have a horrible time playing each other, so p2p will make things a lot better and the server turns into a glorified command validator. In practice, such a situation is rare, as most peers will not be significantly closer to you than the server. 

When you move your mouse, the event loop will execute many times per frame. But when you check which keys are pressed with , they stay pressed until you let go, some time later. So as your event loop is churning through the mouse move events, it will re-apply the player moves repeatedly. The solution is simple: move the player outside the event loop. 

tl;dr don't mix your event loop with your game loop. When you move your mouse, the game receives a load of events. You don't actually use these events to update your mouse position though, you are getting the current state of the mouse using . That's inefficient, but it's not the problem. The problem is you are updating the player position inside the event loop! This is what's supposed to happen: 

When you're dealing with small numbers, sometimes the brute-force approach is best. In this case, you can simply try all combinations of items and return the ones where the point sum is right. The trick is to work out all the combinations (a.k.a. multiset), and in your case, repeat the whole process but with a multiple of your divisor, until the number of things is too high, because even if you only choose your smallest-point item only, the points will exceed your target. To make this more concrete, consider your second example; first we try picking 8 items that total 24 points. Try again for 16 items, and for 24 items. Stop after this, because after 24 even if you pick only the smallest point items (Foo or Nacho), you would exceed your point target. Here's some sample code; you can find ways to generate multisets ("combinations with repetitions") on rosettacode. 

LOD on individual meshes is still your best bet, IMHO. It's very well studied and works well for crowds, especially if they are animated individually. At the extreme, you have a single quad (or triangle) with a pre-rendered sprite that's appropriate for the camera angle. This is called impostors in the field. Since we're talking about extreme levels of simplification, you can get away with very few sprites to minimise on the texture memory required. For somewhere to start, here's a paper on 3D impostors which uses an interesting technique to address popping artifacts when changing camera angle: $URL$ 

There is no reason why you can't link a door to more than one other door. You can have corridors merge at some point. But oldskool roguelikes didn't even do this; they simply connected random pairs of rooms with corridors, and if they happen to cross into a room, boom, open a door here. This is the reverse process of what you're thinking. You can easily see how, since each corridor creates exactly two doors, this never produces a third door, so the problem never appears. But why limit yourself to these methods? There is a wealth of possibilities on the PCG wiki. Maze generation alone is a well-studied field and has numerous algorithms. 

One more approach (and this is the hardest but probably has the best effect) is to make the hints very very subtle. In the developer commentary for Escape from Butcher Bay, the lead developer mentioned small level changes that prevented their testers from getting lost: making certain doorways larger, adding lights etc. These had a psychological effect on the players that made them feel as if that was the right way to proceed, without being told explicitly so. In the same vein (but in a less subtle way), the opening stage of Half-Life contained color-coded corridors. The player could choose to follow them, or maybe be subconsciously reminded by them: 

This is a very simple (and naive) method, so there's no guarantee that you'll get puzzles of a certain difficulty - aside from the number of missing numbers that is - or if you can even remove the amount of numbers you want. Hope this helps anyway. 

What you are asking for is completely doable, as you initially wanted: 3d on 2d. You just got the camera angle wrong. For CG cameras, the perspective is almost always linear (as opposed to say, fish-eye) so all you need to do is have the camera looking straight down. The best example I can think of is the early GTA games, which had simple 3D models for the buildings on top of sprites/tiles for everything else: 

Logically, you can represent these commands as a flow chart, that is run from the top each time, and what you do depends on whether you answer yes/no at each step. Whether you implement this in code or in an external file like XML is up to you. 

No. SDL2 is a C library, and since C has no keyword, it wouldn't make sense here. C allocates memory using and friends, but usually C libraries take the approach of managing the memory for you, so if there are functions like , you can assume that they also free the allocated memory. 

The differences between JS object and JSON file are moot as you can go from one to the other using . 

You make a tile map, probably in a map editor like Tiled, and export to a format that Phaser can support, like JSON. Load the tile map in Phaser. You can now draw entire layers of the map in one go - you don't have to worry about individual tiles. You can now figure out how big the tile map is by using methods like . You can scale individual layers in the tilemap using . The scaling works just like sprites and groups - you can scale x and y individually, as a decimal, with 1.0 being normal scale. To figure out the right scaling factor, divide the canvas size by the tilemap size. For example, to fit 800 pixels inside a 900 pixel canvas, scale by . 

Something that generates a potential spawn point, let's call it Something that checks whether a spawn point is valid, let's call it Make sure that you eventually make a correct guess, or handle things if you cannot make one 

Only dismiss that text if the player has pressed A and jumped. Another approach is to let the player revisit the text at will. For example, in Binding of Isaac the starting room tells you the controls. You can freely come back to this room in case you need a reminder: 

Historically, many PC games used modifier keys (Ctrl, Alt, Shift) as part of their controls because these keys were wired to handle being pressed together with other keys, to avoid ghosting. This practice sort of fell out of favour during the 90s because the modifier keys were being used more and more by the OS, which would interfere with the game. Later, certain genres of games had their controls coalesce around key clusters, most notably the FPS genre around WASD + mouse, but another example would be Japanese indie games around ZXC + arrows. In a self-fulfilling manner, since most games used these clusters, keyboard manufacturers also made sure that ghosting was minimised around this area, so if you stick to the same controls that other popular games use, you will also avoid ghosting. Looking at your example, W and D are fine but K is not; are you by any chance using K as a directional control? If so, consider using the arrow keys instead. 

This sounds like a more complex version of the classic "animal legs" problem. Except in that case, you only have two animals to deal with, so you could work it out using elementary maths ("every time I swap a cow for a chicken, I get two more legs..."). But in this case you have more variables, so you'll need to resort to the algorithmic way. Recall that in the animal legs problem, you get something like this: 

As for tunneling, I won't cover too much because it can be a huge topic, with solutions ranging from small hacks (such as small increments, or slowing things down) to complex robust algorithms (search for swept volume). Without seeing your game in action it's hard to say what you can get away with. 

I would have suggested an iteration or two of cellular automata, certainly if your requirements change, but as it is your requirement is very simple, so only a simple algorithm is required. 

Pathfinding algorithms like A* can deal with inertia (or any other dimension you can throw at it) just fine. The key is to treat them as an additional dimension, and create a higher-dimensional search graph to search in. To keep things simple, let's suppose we have only two speeds: slow and fast, and this path: 

Here are some examples of how games (runner or otherwise) have handled this situation. There is no "best" and you still have to decide which one is right for your game. The physically "correct" way (vertical impulse) To jump, you add a vertical impulse (red) to your movement velocity (green). The resulting velocity (blue) will always take you above the slope, so as long as your slope doesn't get too much steeper soon, your character will always jump above the slope. 

The advantage of this approach is that it can be easily fed into an easing function so you can choose a style that suits. To use this pattern, you detect whenever the player has moved from one tile to another. The start value will be the position of the previous tile, the end value will be that of the current tile, but to figure out time you need to record when the player began moving, and compare that against the current game time. That's not the only method though; a simpler method would be to track the player's position in the "rendering" side, and constantly move this position towards the "game logic"'s position. But finally, don't be so concerned about having the perfect design, especially when making games; if it's easier to hold some "rendering" data in the "game logic", just do it - you can clean it up later if it's hampering things. 

I'm thinking about making games for tablets. Coming from a PC/console background, I'm keenly aware of the huge differences in the user interfaces, and that I need to design it with the target platform in mind. One aspect I'm worried about is player fatigue. The input devices used on PCs and consoles - keyboards and game controllers - are optimized for extended play and have mature, ergonomic designs. Most seasoned players can easily use them for an hour, clocking in thousands of key/button presses, without suffering from fatigue. Designers can depend on this when designing the user experience, with consequences ranging from size/length of levels, steps required to execute commands, pace of the game and many more. What about touch-screen tablets? Do players become fatigued faster, or are unable to execute as many taps/swipes per unit of time? If so, are there any resources or guidelines about this matter?