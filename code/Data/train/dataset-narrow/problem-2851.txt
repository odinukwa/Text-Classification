This is not morse code. You don't need a library to do this. You could achieve the same effect by having a sound file that has different lengths of beeps interleaved with silences. The sound file must be loopable. When the text starts to be written to the screen, you start the looping sound. And when the text is done being 'typed' to the screen, you stop the sound. I would suggest you find a web site that offers free to use sound effects, load it in your favourite audio editor (Audacity could do the trick) and modify it until it fits your needs. 

For that kind of behaviour you generally Rotate about the origin, then Translate, then Scale. Since you want to rotate from the center bottom of your quad, from the origin you'd: 1. Translate the image to have its center at the origin () 2. Rotate 3. Translate to the desired location I'm not familiar with the inner works of OpenGL (I work with a rendering engine), but your first translate ( does nothing, it does not translate anything because of the values are zero. I think your intention was to "set the origin at (0, 0, 0)"; to achieve that, I think you need to set the current matrix to identity instead (). So in the end it would look like: 

Since the parent class does not have a default constructor, your children class cannot use a default compiler-generated constructor as it will not be able to call the default constructor of the parent (because it does not have any). To fix this issue, you have to explicitly add a constructor to your class and call the constructor for the parent class (the ). 

The tool pipeline is the set of tools that an asset has to go through from the original creation to the moment it's used in the game. For example: 

You have to use the frame time, and make your score based on time instead of on frames: Here is the pseudo-code: 

I have not tested the code, but it's been done with nearly the best of my knowledge. When computing the final position of a node, you really have to keep a wall between the node's data, and what's being applied to the scene graph: when computing the position in the scene graph, it must not change the node's original settings (of course, it's the position w.r.t. the parent, but this does not need to be modified during the update and the calculation of the final location). My coding standards have been applied, please disregard as I'm becoming an old monkey. 

To determine what is the difference in the input, you need to constrain the delta to the same range you use: This is the excel formula I used (row 8, with the "old" value in column A and the "new" value in colum B): 

I don't think you have the proper approach to your issue. Typically, if a game starts to go slower and slower, it's because you add stuff to it over time and it's not able to process everything in a timely fashion. If there is too much stuff from the beginning, the frame rate will be low but constant from the beginning. Even if "pausing" a game to "let the frame rate catch up" or to "restore the FPS" seems to work to solve your current issue, it will not fix the underlying problem. It is not a good solution and your players will really not like that. I suggest you use a JavaScript profiler (I did not test this one myself, but it could be useful to you) to inspect the behaviour of your code, and from there determine what's causing the issue. 

as well. These functions are called each frame instead of only the first frame there is a contact. In fact, you should probably only implement these as otherwise on the first frame you'd get 2 life reductions instead of only one. 

In this case, even if the copyright has expired, since it's a Nintendo DS exclusive, I would guess that you still can't use the data, because it would imply that you use the software or the hardware in a way not authorized by the EULA. 

The point you draw is really a spot of the size you put on the screen. It has no volume. From opengl wiki: 

move direction is the heading. You have to distinguish speed from velocity; when you multiply speed (a scalar) with the move direction (a unit vector), you get the velocity, which is a vector. 

Now, please note that this might not be the best way to achieve it, but at least it seems to solve your current issue. You could probably improve the execution by making member of the class to avoid having to re-create it/resize it each frame. And XXX could look like this: 

The synchronization with the VSync, like what you set with , is tied to the display of your game. So it will be synchronized to the monitor refresh rate. If you solely rely on this to throttle your frame rate, you could run into this kind of issues: 

Typically, developers that are on a budget and don't have a lot of money for advertisement will invest more time. Here are some techniques used: 

They solved this problem quite easily in the latest iterations of the Far Cry series: If you can one-shot an enemy with a silent weapon, you succeeded at a stealth-kill (head-shot with a silenced gun, bow), and no one will know where you are. If you aim badly (e.g. the chest or lower body), or the enemy has too much defense (aim for the head with a silenced small gun on a heavily armoured guy) and you're not able to one-shot him, he'll know for sure where you are and come hunt you (with his friends). Not knowing what is exactly right for you and your game, I suggest to list all the options available, architect your game code around the fact that you'll have to try all those different things, and then test the many things that could make the game fun. 

Instead of having long segments, you could try to alleviate the issue by using circle shapes. You'd have to reduce the angle of freedom for your joints, but since you'll have more, you'll end up with the same result. The third option I see is instead of using rectangle sprites, try and make 'capsule' sprites: a rectangle with half circle on each end. This would still have "angle-ish" joints, but at least, you won't see the rectangle separations. 

You've already got most of the setup. What you could do is just control the Campfire from the other collider inside the Collision method [untested code] : 

I found it a little bit difficult to follow the entire thread of your question. However at the most basic level, in a simple FSM you could either just query the current state of your StateMachine (i.e. assuming its a singleton manager class etc : StateMachine.Instance.GetState ) and then do the necessary long-winded if or switch statement logic depending on which state is returned. Alternatively, for something a bit more loosely coupled and dynamic you could just have each relevant Class subscribe to a OnStateChanged event equivalent and react to specific states with callbacks. There isn't a right way to implement a FSM, however you can take a steer from one of the many online resources eg: $URL$ $URL$ ------ EDIT UPDATE ------ The idea is that if you're going to roll your own GameStateManager in the Unity engine, then each state would essentially have it's own methods such as Update etc. These methods would execute sequentially as per the norm. You could manage your state transitions with a State stack container. This way multiple states could be queued up and pushed into the stack, and then executed in order i.e. GameState-->MenuState-->ControlsMenuSubState etc. At the end of each frame you could then do some bookkeeping and check if it's OK to roll onto the next state i.e. pop the current state and then execute the next state object on the GameState stack. It does sound like you're overcomplicating things by coupling each class to each State of the game. The classes generally shouldn't know or care which state they're in as it's the State's job to call into other classes, not the other way around. Unity's normal Scene methodology is also suitable. You could just use Scenes to transition between major games states, and then use the Unity GUI for Overlay states such as Inventory or Menu states which need to run in the current state. All you would need is at least 1 object to maintain your meta game state between scene transitions. 

Once thats set up you can then interrogate a tile in your move path to see if its walkable based on the terrain type, or if it's blocked by an child obstacle etc. 

$URL$ If you're using Aron Granberg's pathfinder, then are you perhaps using one of the smoothing modifiers? This would result in the unit trying to optimize the path which would probably prevent the unit from hitting each node as it steps through the path. Or is the problem that you have a consistent offset when the unit paths from node to node? 

in each Update() call. targetPos can just be a gameObject in your scene indicating a position to the left, just outside of the visible screen space (at which point you can kill/recycle your pillar). If you need objects which have their own speed then alter or add to the 'speed' variable for each required gameObject. For example a projectile being shot by a trap towards the player from right to left might be moving at playerSpeed + bulletSpeed etc. On the topic of recycling objects : instead of instantiating a new gameObject for each obstacle such as pillars, especially in a tight loop or Update() function, instead investigate object pooling in Unity where you can just keep recycling from a pre-allocated list of gameObjects. --- EDIT forgot you're using rigidBody ---- After you instantiate each pillar with an initial velocity (moving towards the player from right to left) then it sounds like you could then use an InvokeRepeating or something similar to fire off an increase in speed of each subsequent pillar by just adding force to the current velocity : 

When I implemented something similar I used a messaging system exclusively to handle the necessary communication between different entities in various systems. That way the messenger can perform the relevant required component checks while marshalling the your messages between the entities. You can think of the Events as mini SubSystems if you like. It also cleans up your systems quite a bit as well as providing a great deal of de-coupled logic, and hence less dependency chains overall etc. (contrived and untested psuedo-code disclaimer) example : 

I know some people frown on link dumping, however I found this to be a very enlightening paper, and it obviously conveys way more than I could elaborate on : $URL$ 

When importing the animation there is a 'mirror animation' checkbox under the Animations Tab in the Inspector for that asset. If you check that box and rename the animation to "myanimation_mirror" or whatever then you should have 2 mirrored animations. 

Wouldn't it be simpler to just use some integer state logic to drive the match comparisons? For example you could just keep track of each Tile's state and colour and do numerical comparisons instead of interrogating the actual texture of each gameObject? This has the added value of using a single Texture Atlas to store your tile textures and then just map to that Atlas as per the norm if a tile needs to change via a user mouse click. A quick comparison example for you to Ctrl-F5 (if you run it a few times you'll get a match) : 

A quick test, just grab the logo image from the SFML site and paste it into the working directory of your project (or just somewhere simple and explicitly state that in code i.e. "C:\test\img.png") 

From my experience recently in doing a few 3D animations, I found it very simple to just split up the animation into 3 separate clips. That way I felt that it was quite intuitive and easy when creating transitions between each animation clip in each stage of the overall animation. You also have a great deal more control over the animation transitions using this method. If you split the animation up then just ensure that when you import the animations that you check the Loop animation check box in the Animations tab for the middle climbing animation clip and you should be good to go. You can then also use State Machine Behaviours to drive any additional actions like playing sounds or effects etc during each clip. I'm sure you could also perform some complex looping logic as you allude to, however that seems unnecessarily complicated and error prone in my opinion. 

Additionally, I've noticed that you're loading a new texture for each block. This kind of defeats the object of using a texture. With a texture you want to load it once into video memory and then point all of your sprites to that once instance to reduce draw calls and memory requirements etc (aka batching your draws). In 2D games using the concept of one large texture atlas is very common because it's so efficient. You could have a variety of block textures all tightly packed into one 'blockTypes' texture and then just use 'sprite.setTextureRect' to refer to different sections of that texture as mentioned above. I'd just throw a few texture atlases into a map so that you have a single texture dictionary to refer to in all of your block objects.