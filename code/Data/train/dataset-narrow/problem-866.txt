I suggested the list as an example but as a personal preference If i am using a custom interfaced type i try not to use lists. instead i just have a single IModifier Modifier{ get; set; } The reason being the modifier is just like the above attribute. I could easily just pass it a 

not make more sense? could the method not even be a method on a interface of some kind defining the rules for deciding relevancy? would that not separate your concerns, make testing easier and over all make it clearer what each piece of your code is doing? 

Of course if any of those properties are required then the constructor is the way to go, but the lack of null validation makes me think they are not Also there is a lot of magic strings going on. At minimum, you should make those constants. I would personally just do an enum but that is a design choice: 

so basically, if the pooledObjects doesn't exist, create it, then...return it. If it already exists...just return it. this is just me being a bit picky, (as i am a linq fan) but you can simplify the GetPooledObject to: 

Don't forget, code you wrote 6 months ago is indistinguishable from strangers code. If you saw this code and had never seen it before you would think it is clear and makes sense? to be polite that method is mostly gibberish. You are trying to define relevance in your story entities, I get it, but a hard coded nest of grouping ids is scary to read and very easy to mess up. you are basically talking about a rule engine, Given a name and a gamestate, find the right StoryEntities. A level down from that is, if the current gamestate and name match a certain condition, filter the returned Entities. then you are, based on conditions grouping those entities by relevance. you method is doing a search, a filtering and a conditional grouping, these are different tasks and need to at least be method separate, certainly not be all on one or two lines. what if you decide to swap return order? 

then by being a serializable, unity will make all the fields available in the inspector, now you can set up a more modular system. 

This same separation of concerns can now be applied directly to the modifiers. Picture adding a conditional modifier, that only applies if the player has certain buffs or attributes, such as 

Given @CantGenEnough 's comments that my previous suggestion didn't fit his needs I thought I'd try an alternate approach I was playing with. Instead of the above you could try a similar approach with a sort of a weighted calculator instead of the actual skill approach. So If you had a generic 

Well I would personally want to cut down on all of that exception handling code. The easiest way in my mind is to create your own exceptions. Now, I understand you seem to need a message and enum associated with each chunk there so why not make that as a base transactionException and overload each case. 

having a public set exposed the possibility of the View completely changing the Observable collection or setting it null. should that ever happen? Also using ICommand instead of calling methods directly is the MVVM way, you can then bind it directly to things like buttons 

Firstly, should not be in this code, in-fact calling the Create function on the QuestRepository should compose a quest and hand it the timestamp. it should not be the job of the quest to decide when he is created, what if you are trying to test that? how can you hand it a testable time? Even worse is which is a magic function that goes somewhere using a utility and does something. Your entity should be an entity. a data transfer object, if you have commands to perform on it, then leave that job to classes that use the quest, like say, the handler. Singletons used in this way will only cause you problems. Lastly we come full circle: More Separation of Concerns! 

So you would have a chain of possible solutions, each one if checks to see if the type is one it can handle, ...then handle it. that way you have support of unlimited quest types, default quest handlers and you never have to go and update a bunch of case statements. 

then in this script you basically say , no searching, no problem, everything that needs pooling can access it. Rapid fire seems fine, although unnecessary comments are....unnecessary. code should speak for itself, if it doesn't..rename it. Comments are reserved to complex things that cannot be distilled further or domain specific logic like explaining maths functions in code etc, RapidFire....rapidFires? huh, who knew :P as for unity specific, you never put a constraint or a check to ensure that the gameObjects in the Bullets pool have a bullet script. yet in fireBullet you make that assumption...code could break. ESPECIALLY if you are loading from a resource and not managing the scripts additions personally.... 

Okay...so later on you have some more to do, swap em again? not only does this litter the code but it is something easy to forget to change it. Next, you have to make the task asyncronous...oops. no joy, people keep switching the flag on you! Any properties like this should be constructor based. In fact my personal favourite solution is to package such things either in an entirely different class or to at least pass in a parameterCollection so in short something like: 

and with all that in place you should be able to throw a number of custom exceptions and wrap the whole thing in one catch block that will log the associated message and return the associated enum. 

infact i would suggest not only does it not. but if you require it does, your individual components are designed wrong. you have no reason to test Ninject. that is like sending yourself a letter to check the formatting and quizzing the postman. if you want to test an abstract class, try not to. why did you MAKE the abstract class? to be used in an implementation. test the implementation 

if A fires when called correctly ...good. if B activates (regardless of who called it) ... good; if B returns an expected IC ...good. does it MATTER if A->b->c evaluates properly? 

Hmmm, Well I think the way you are going about it, while functionally correct won't scale well. Ideally you want to try more of an aggregation. Off the top of my head I would approach this like: 

which could allow you to swap the application ordering on the fly. resolving an issue brought up by someone else. also allowing a sort of tree nesting with a RandomModifier housing a composite Modifier which has a .... and so forth. 

ok, silly example but effectively you have a single IAttribute, consumable by anything expecting a IAttribute only it is not simple, it is a crazy amalgamation of sub attributes, which in fact could each have their own modifiers! In that example your base T in the Abstract class is not being used. it is redundant. or another example, 

The simplest example is, the creation of a thing has nothing to do with the using of a thing. a.k.a you don't need to know how the sausage was made. In your code, the sausage is the database. I know exactly how your data is stored, what format each field is and more dangerously, embedded in your code, how to delete things. embedded sql is always a red flag. Imagine a 

just like the above separation of concern, Your quest handler is extremely aware of the session object. also the general web naming you have is rather confusing and unnecessary. client packets? notification composers? all of this could be easily wrapped in a 

and have compile time addition of the notifyProperties. Although if you do want more manual control that is fine too. Also, Xaml grows fast. Try to remove any extraneous properties. Do you NEED names for each row/column? P.s Also a pet peeve of mine, HUGE METHODS, especially switch case. I try to avoid them as much as possible. If i have to use them as a golden rule I only ever have one line after the actual Case so: 

Sure, it may not be that relevant in this case but it is good practice to take anything that can change...out, such as your prefabs. Next up. magic strings are scary. again, knowing unity and what you are doing means its not a big deal but again...it is better practice to avoid doing it all together. finally Repetition leads to more places to change and is messy in general remove the little bits of code repetition where you can, the component decoration and composition unity does can look a little bit hard on the eyes when stacked. so move some of that into helper methods where appropriate as for unity SPECIFIC things, the way to avoid the distasteful pattern of publicly allowing access to fields is: 

Is that not a little easier to understand? Hopefully as an added bonus seeing how little the differences are in creating multiple pools, you might want to even go so far as to make a pool manager that takes in a custom struct of the data and manage tonnes of pools e.g: 

Well, The GridView is an implementation, Down the line if you decide to swap the GridView for a listview or something it should have no bearing on the data. Exactly how to go about sharing the information is subjective. there is no right way. My personal preference is a super contracted approach via interfaces. e.g: 

I like it, especially the enums. Although the Tuple evaluator is super hard to parse. Definitely think it would be better to wrap that in a interface or something which contains the relevant enum flag. besides if memory serves you can perform flag concatenation for a cleaner compare. 

Darn, at first glance this looked like a simple solution but you ruled out constructor injection. The only suggestion I can come up with is to have a class that inherits from the same interface, DOES have the constructor injection is built up and added to the main object as a composite object fed in through a set only Property, maybe some kind of flagged function call like 

whereby the Modify Accessor is a composite instance of the class, it adds instances to an internal enumeration and orders by weight. the Skill classes calls its composite Modify.Calculate(_baseValue) or something and still returns the combined result and all is safely encapsulated. 

so now, in the actual editor you just set "Bullets,False" - "Asteroids,True" and you can add new pool as easy as that. Nothing hardcoded. ...so yeah that's a small bit of homework if you want to make it more modular. 

Personally I am less inclined towards this, more overhead in terms of building a fluent interface for your equation aggregation and a bit harder for newer people to grasp using but then again it reads better than any other solution at first glance regardless of ability. So if you were to package this as a modifier API for yourself it might be the way to go (but for api additions I tend to follow the rule of 3 uses so may be premature to do so); but as a problem solve for a particular project I would choose the more straightforward above method. 

And you can do that across the board. Any where a method overload is super hard to read, encapsulate it in an object that makes sense. 

If you had that in your constructor you could perform all the quest handling without any implementation detail knowledge, allowing you to (amongst other things) test the handler without relying on a database. 

Although that doesn't really solve your problem. I usually like to answer a persons question first in case they choose not to do a large refactor but I would take a closer look at what you are trying to do. You have a number of larger design problems: 

may not be as all powerful but creating them when you need them is preferable to a god system that is hard to understand and edit, while not adding a lot more in terms of readability and take far longer to design and implement. 

Also have a think about your viemodels goals. It is effectively providing data to the view and allowing a select, right? In the interest of only exposing the abilities I want i prefer to make an interface for my ViewModel 

As for getting the prior state that is simply a matter of having a prior state variable and at the end of your update cycle set . P.s I robbed @ChrisWue 's very clean snippet for my example. 

which will clean up your constructor call and allow a much easier one-stop-shop functionality change. So now your constructor goes: 

which has some nice features like auto deactivating the button when the CanExecute fails. and having the ability to have a canexecute is nice. Good separation of concerns. Also if you decide down the line to maybe go fill ViewModelLocator using the interface as a binding in your view allows some hot swapping of views/models. So what i mean by that is 

I love me a good interface but...what's it for? you are not using that in any logically path i see. Hell your "Projectile class doesn't even implement ""! Maybe rethink the interface name if it refers to a fire type..... 

Well Firstly that constructor is a bit of a worry. Anything more than 3 (at most!) arguments is normally a bad idea. Now that you have so many it would be a good idea to make yourself a : 

As for the other main question: re: lots of constructor arguments. you are right, this is a code smell. a clear indicator of complexity and shows too much of the guts of the internals. ..unfortunately it is the smell of cooking with IOC. which is somewhat unavoidable. that being said, it is an example of precisely why constructional design patterns are needed. you have a complex object with a number of components. but you only need a single entity, preconfigured. the solution is a combination of constructional patterns and configuration. Take all of those constructor parameters, figure out which are instance-specific vs domain specific. then make a factory to create those objects. e.g: