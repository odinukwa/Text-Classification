Make sure that dies. The header redirect you do use doesn't, and if the one of doesn't either, an attacker could easily bypass this check, as a client does not have to follow a header redirect if they do not want to. Possibly SQL Injection You mostly use prepared statements, which is good. It's a bit surprising that you do not always use them though: 

But this still doesn't make very much sense. Your function returns a PDO statement, which still has to be processed, so you didn't really gain anything by introducing this method (well, you save one line for every query you write). You should either get rid of it and use PDO directly (or some alternative such as an ORM), or you should handle all PDO related code inside of this method (make sure that the method actually improves on using just PDO though). Misc 

Yes, it only saves one line, but you really do have it in a lot of places, so it's worth it. Indentation Proper indentation is important for readability. For example this code: 

Right now, you take two times the memory of the original array (your boolean array plus the original array), and in the worst case, you are running through the array-size twice (once to fill the boolean array, once over the original array). You actually don't need at all, because the default value will be false. So if you remove it, you will at least save on time. If space instead of time is the issue, you could also sort the array, and then find the two equal values that way without needing any extra memory. Misc 

The reason this works seems to be the way works. But this really seems to be more of a side-effect, and it is never a good idea to use those for security related things. Conclusion Regarding performance, security, and readability, a simple replace for , , and with their HTML representation seems to be preferable to your method. 

@Elias Van Ootegem already covered quite a lot, so just a couple of points from me: Security: Login as any user Right now, an attacker does not need to know the password of a user to login, just the username. This is because of the precedence of over . Your query is executed as: 

Yes, you really should use prepared statements, your current code looks extremely vulnerable. Right now, is the only value that you actually validate in some way before putting into a query, all other variables - if user supplied - will lead to an SQL injection (they could have been cleaned by , but I really would not rely on that, and input validation is at best a nice addition to proper escaping or prepared statements). SQL injection is possible in and statements, not only statements.. Also note that is - as it's documentation says - deprecated since 2013, you really should not be using it anymore. Use either or , and use prepared statements. Naming You should handle your variable names uniformly. Either use camelCase, or snake_case, but don't mix them, as that will make it harder to remember names. Also, don't start variable or function names with an uppercase character. And don't abbreviate variable names. What is ? And does stand for ? Maybe, but why is it written out in ? should be , etc. It's also not really clear that stands for . I would just get rid of it, it doesn't really add any benefit anyways. Early Return If you turn this if around: , then you would save one level of nesting: 

What you should do is check the file extension as well as the actual file type. The functions that are generally recommended for this are and respectively. Ideally, you should use whitelists, not blacklists. Misc 

Database Structure Your database will contain a lot of duplication. The whole point of a mapping table such as is that you can have m:n relations without having to duplicate any of the other data (so you save storage space, and avoid the problem of updating in multiple locations). But as you include that data inside the table as well, that benefit is gone. What you want to do is just have the ids in the mapping table. Security You sometimes use prepared statements, but not always. This isn't good, as it leads to SQL injection. Whenever you have something like 

This leaves the false impression, that you are adding up the value of . If you just return the value, your code will also be shorter: 

Structure I don't really like returning a magic array. The caller has to guess or read up on the keys, which is annoying. I know that this is often done in PHP, but I think a better approach would be to move the retrieving of information to the constructor, store the result in class fields, and then access those fields with explicit getter (or if you don't want to completely rewrite your class, store the array as field, and add getters for each key of the array). This could be used like this: 

Thus we found our SQL injection. Note that all the other parameters you specified as user input are also vulnerable. It is likely that other parameters are vulnerable as well. For example in (although it's not clear where that comes from). Another example would be , which is also a global, and is inserted into a query here: . Note also that depending on what the global is, and what you do with , you are likely open to XSS. From a security standpoint, I would rewrite the code from scratch. It will be extremely difficult to fix it in its current form, because it's so confusing. Ideally, you could extract parts of the query generation to their own functions to increase readability. Here, it is also extremely important to know where what variables actually come from (which is one reason against ). In each function you create, you want to be extra careful with the arguments that are passed to it. So you might eg build a function. Now, inside that function, you know that is dangerous and should not be put into the query, but only used to calculate the amount of you need. 

A naive approach to the actual refactoring would be to find all elements that differ in the methods. These are: 

Note that I also changed your formatting (curly brackets for one-line statements and statement on its own line). Now you can also notice that you have a pattern, which would look a lot nicer as : 

I put the in there for strict checking (), just in case someone adds a to the whitelist. Alternatively, you can just hardcode it: 

SQL Injection You are completely open to SQL injection in all your queries. This means that an attacker can read any data they want from the database, and possibly read files, create new files, or execute commands. You should never put any user input (this may be from GET, POST, the database itself, anywhere really) into a query. You need to use prepared statements instead. XSS You are also vulnerable to XSS. One example is , but really all echoes that contain user input are vulnerable. This means that an attacker can inject JavaScript into the context of a victim, making it for example possible to steal cookies, change the websites content (eg for phishing attacks), bypass CSRF protection, etc. You need to HTML encode all user input before echoing it. CSRF You are also vulnerable to CSRF. This means that an attacker can perform any action for an already authenticated user, if that user visits an attacker controlled webpage. Formatting Your indentation is off, making your code hard to read. For example, I have no idea where ends. You should also store functions in their own file to increase reusability. If you include a file containing one or multiple functions, you don't want any side effects. But even if you need to store the function in this file, don't put it inside an else case in the middle of your code, put it either at the beginning or at the end. And you should use camelCase or snake_case for your variable names. Something like is hard to read. Structure Your HTML code contains quite a bit of duplication. You could create functions such as , or you could use a proper templating engine. Your code is also too long. Your function for example does too much: It prints stuff, it checks the existence of stuff, it inserts the author info, and it inserts a bunch of other stuff. I would create separate functions for each of these to increase readability. Misc 

Security: SQl Injection You use prepared statements, which is great. But you still put variables directly into SQL queries, which makes you vulnerable to SQL injection via : 

Return Value I don't think it's a good idea to return in . What would it even be used for? The code would look like this, which doesn't make much sense: 

Nice Code, just a couple of points: Constructor and Default Values If you use the default values in the constructor like this: 

Structure I'm not quite sure why you chose to write your program the way you did. It seems to add complexity to the naive approach of using a normal function, without adding any benefits: 

then the second function will return a different result than the other two. Here are two more examples for different results between the functions: 

That's already a bit nicer, but really not that much simpler than the original query (and harder to use, as it's not really clear what the passed values need to be), so I'm not sure if it's worth it. I would probably stick to the well-known and simple PDO interface. If you want to simplify it, or don't like to write plain SQL queries, something like a query builder or an orm might be worth looking into. Security Your approach completely disguises which values are safe and which are not, which will lead to security issues. Basically, only may contain user input. For some of the other values, a user may not expect it to be secure (such as ), but just to be safe, I would still validate it. For some values, this is devestating. Having such an interface as yours, I would completely expect eg to be secure. Misc 

No, it's almost always a sign of bad design (and not just because of the static variables, but also the static functions; only utility functions should be static). Another bad sign is that you import in your logic class. You classes also do too many things, which makes them very static, hard to read, and hard to write automated tests for. I would at least create: 

And you use it like this: Player1 plays paper, Player2 plays rock. Look in the paper row for the value under rock. it is 1 and player1 wins. -1 would mean they lose, and 0 means tie. For just rock, paper, scissors this is overkill, but for a lot more options this might work well. Comments on current code