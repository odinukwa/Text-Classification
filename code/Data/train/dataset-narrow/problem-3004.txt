The care put into a variable name should be proportional to its lifetime. I consider a single letter appropriate for an integer loop variable1 or a short-lived temporary variable, while classes and members2 should be named carefully. Footnotes 

It is useful to create a macro to compute the maximum operation. The advantages of a macro over a function are: 

I'd like to create a college-level AI course based on the famous AI MOOC created by Peter Norvig and Sebastian Thrun. My reasoning is that I wouldn't be able to create lectures as good as theirs, especially because I'm not particularly knowledgeable about AI. (The last AI course I took was in the early 90s.) I would teach a "flipped" course in which the students watched lectures on their own, and we used class time to: 

The main attraction of block-based programming languages is that they expose users to the fun aspects of programming (creativity and design) without requiring them to deal with the less fun aspects (such as syntax and obscure errors). This enables students who might have dropped out of an introductory C++ course to get a taste of programming, both to expand their understanding of the world around them (since they use programs every day) and to motivate some of them to learn text-based languages when they hit the limits of block-based languages. Some disadvantages of block-based languages: 

Don't assume that students who have seen other programming languages will be bored. Creating phone apps is hard, so the ability to do that may be of interest to them. If they are extremely advanced, you can encourage them to contribute to App Inventor, which is open source. Disclaimer: I was part of the App Inventor team and am co-author of a book about App Inventor. I have taught App Inventor at the college-level (to non-majors). 

Problem solving and computational thinking is a hugely transferable skill in itself. Almost any science / engineering route through academia into the workplace is greatly benefited by the ability to write / modify some code that will process data efficiently and generate exactly the sort of analysis / evidence that you require. For example, a substantive part of a Psychology degree involves collecting and processing statistical data. Even without the logical and analytical benefits of CS, the ability to write code to automate the analysis of that data immediately gives you huge advantage over peers without any CS skills. 

I don't think that student learn that much from just running someone else's code without going through it. Copy & pasting can be really useful for sharing code that has been deliberately 'broken': you can demonstrate / explain code that is working and then introduce deliberate mistakes for students to find and fix when they copy / paste. That way they get the speed advantages of copy / paste but they also have to engage their brains whilst getting experience debugging. Alternatively, you can give students code to copy that they then have to comment / adapt / extend. 

You can get a fast-paced, fun lesson where there's enough challenge to get the brightest students being competitive with enough support for those who take more time to understand and complete the work. 

The easiest way to set the conditions so that they can all be reached continuously in every class period is to make the conditions so easy that all can achieve them with very little effort. However, this is not at all motivational and sells the students short of being stretched, inspired and challenged. Dumbing-down the curriculum so that all succeed can get great results on paper but is counter-productive in the long term. A good lesson almost should contain some objectives that can be reasonably achieved by all students whilst also featuring others that create scope for curiosity and intrigue for the fastest/brightest learners. Any teacher knows this isn't easy: 

Now we've discussed what the problem is, and what most people would do to solve it, you should be able to see why lessons don't actually reach every student, despite no-one actively aiming not to reach everyone. The Solution I can't really promise a straightforward solution that works now, and reaches more students without a lot more effort. pddring's ideas are excellent, and you should strongly consider providing different 'routes' of challenge so that all students can take something away from your instruction. At the very least, you probably need to ensure that students understand enough to build on the concept you've taught (e.g. understanding syntax to a reasonable level before moving on to constructing more complex algorithms). The holy grail is the 'Digital Aristotle' that CGP Grey talks about, but I don't think it's entirely here yet. Some Internet resources like Khan Academy provide excellent self-paced resources and self-test questions which might be helpful to use if students need to work on things at home, so that they do have the prerequisite knowledge. In essence, there are two options to reach more students: provide different teaching for different abilities of students, or try to make sure everyone is on the same page before they get to your lesson. I feel that I've written a lot without actually proposing a real solution, but it's extremely difficult to solve this problem. If you're willing to put in the time, you can provide different levels of difficulty in each lesson, which would at least ensure that the vast majority of abilities are taught well, but I think that the future lies in computers adapting a curriculum just to your students. If you find a platform where you can put tasks that adapt to a student's ability, it may be worth considering so that you can challenge every student to reach their potential. 

Write some code that is unfinished with some deliberate mistakes and share it with your students on GitHub Get your students to clone / download your code, find and fix the bugs then talk about the problems with having so many different versions of the same code in the classroom. Get your students to fork your code into their own repositories and commit their own changes. Discuss code and commenting conventions and why they're necessary (e.g. PEP8) Get your students to go back and recommit their code in line with the conventions discussed Ask your students to issue a pull request on your code so that their changes can be contributed to the original resource. 

Ask them to switch their screens off. They don't like it if you do it too often or for too long but it's surprisingly effective, saves you having to repeat yourself unnecessarily and forces you to try to make your instructions clear and concise. If you can't see their screens you can always tell by the glare from their screens on their faces who hasn't followed instructions. 

Once they've been through that process in a safe and controlled environment they'll be much more confident joining in with an open source project. It can be intimidating jumping in for the first time, no matter how friendly and supportive the contributors are. You might also want to look at GitHub Classroom which automates the process of creating, sharing and collecting programming assignments from students. 

Ultimately, I don't think it's a question of choosing a particular type of student to pitch the level of difficulty to. As teachers we have to be deliberate in our planning and delivery so that there's something even the least confident student can leave having achieved but also some bait dangled tantalisingly just out of reach for those who want to discover for themselves. All that, whilst not neglecting the majority of students who find themselves in the middle of the two extremes. Realistically, my answer to your question is that we can't guarantee every condition will be reached continuously in every class period for every student. I can't anyway. But it's worth giving it a try - it makes teaching more fun as well as more productive. 

I would mention it in any class in which it is relevant, such as User Experience or where A/B testing might be used to show different users different versions of a website and measure their behavior. Because such research is ubiquitous (consider Google's testing different shades of blue), Facebook was unprepared for the backlash against their emotional manipulation study. 

CS students are taught to use version control software. I teach at a small liberal arts college, and we've taught its use in our capstone course (and sometimes others) for as far back as I can remember, at least since 2005. A graduate's not knowing something does not necessarily imply it was not taught. Students tell me they've never seen material that I know was in the prerequisite class. I'm sure this is not unique to CS. (Students are taught proper writing in the required English 1, but they don't all use it.) Teaching something does not guarantee that students understand it. They could have copied-and-pasted commands or relied on their teammates (or Stack Overflow.) I don't include questions about VCS on tests, just like I don't include questions on how to use IDEs and debuggers, but that doesn't mean it isn't taught. 

This provides a simple demonstration of the benefits of pointers and will help them understand why primitives (not counting pointers) are passed by value, while everything else appears to be passed by reference. 

I teach the "standard" conventions for the language, where they exist. For Java, I use the original Sun naming conventions and Google Java Style Guide. More important that standard capitalization (which I require) are: 

I would be keen to avoid punishing someone who might not have done anything wrong, but some others might not give the benefit of the doubt. It's certainly not easy to tell what exactly has gone on when two very similar works are handed in, but if you can rule out any copying without the author's awareness with certainty, then you must assume that the author facilitated cheating. If you haven't made clear what the difference is between helping and cheating, then you can't really punish anyone fairly—if you don't clearly lay out your expectations, then you can't enforce strict rules. 

(and that's just from the script that generates everything!) I would imagine that Rails would feel a little bit overwhelming for a beginner to web development. It brings a lot of baggage with it, like the MVC pattern and a lot of handy generators that are useful to experienced developers, but hide the logic to a learner. It seems logical to me to teach using Sinatra first, and then let your students realise what the problems are. They'll be more inclined to go through the process of learning Rails, with all the extra boilerplate involved, if they see why using an opinionated MVC framework is useful. For trivial backend applications, like you'll probably be developing at first, RoR is overkill, and there are too many concepts that you'd have to teach before actually getting to make anything. I'm a fan of teaching from the basics in this case—showing why each additional layer of libraries and frameworks is needed is far more valuable thank saving some time by skipping Sinatra. And, of course, the motivation to make something can be more easily satisfied by starting with Sinatra, and you can later introduce the 'batteries included' framework of Rails. 

One way is to have an industry advisory committee consisting of alumni or friends of your institution. (I was on such a committee for a community college when I worked in industry.) Once a year, the committee meets with faculty to learn about the current curriculum and suggest changes based on their active professional knowledge of the field. Another way is for faculty members to spend sabbatical years in industry. I learned more about software engineering from a year at Google than from my entire formal education. 

On open source projects and industry teams, there are often detailed style guides about how many spaces should be used for indents, line continuation, etc., and whether braces should go on their own line. While I have my preferences (such as spaces around binary operators), I acknowledge they are somewhat arbitrary. Should I require students to follow a standard for assignments and team projects (perhaps conventions of their own choosing), or should I ignore these as trivialities? Of course, I would enforce more important conventions, such as proper indentation, appropriate naming, etc. 

How do you encourage students to benefit from code reviews you give them, rather than being discouraged or responding defensively? 

As you know, the local variables and do not get changed, because C uses call by value. At that point, I show and discuss this cartoon: 

The difference is that, in the first piece of code, each array element is retrieved from memory once and placed in either a register or the cache, from which it is operated on a million times. Ignoring spatial locality (which would apply equally to both versions), the total number of reads from memory would be 1,000,000, and the total number of writes would be 1,000,000. With the second version of code, each array element is fetched from memory once for each value of . The total number of reads from memory would be 1,000,000 x 1,000,000 (10^12); the total number of writes would be the same. Per Latency Numbers Every Programmer Should Know, a main memory access takes about 100 ns; an L1-cache reference takes .5 ns. Accessing a register adds no time to instruction execution. Ignoring the times for the writes (which may not be in the critical path) and spatial locality (which applies the same to both versions) and assuming that is stored in a register, the data memory access time for the first is 10^6 * 100 ns = .1 s. The data memory access time for the second is 10^12 * 100 ns = 10^5 s. 

Before contributing to an open source project it can be useful to become familiar with the tools and concepts involved in version control systems. 

The Russell Group of Universities has published a useful list of recommended A level subjects for different degree options which suggests that other than a CS degree, CS A level is recommended for: 

I tend to avoid multiple students working on the same code simultaneously (Google Docs style) because it's really difficult to assess what has been done by each student or to stop one student dominating whilst the other doesn't understand what's happening. Either that or students tend to get distracted by what the other is writing. Having said that, you could try: 

How about IP addresses being countries and ports being sea ports? In the UK it works well because there are so many different sea ports that students recognise from looking at an online map of the British Isles. You can extend the metaphor by talking about firewalls blocking off access to ports (e.g. sea blockades during WWII) or increasing security by removing external access (landlocked countries don't need to worry about sea invasion). The main advantage over an address / flat number analogy is that you can extend it by talking about different types of ports (e.g. airports) for different protocols (e.g. UDP / TCP) with various implications for speed / reliability. No analogy is perfect though - students who want to understand it fully should have experience using or hosting different services on the same server. 

If your students are mathematically inclined, you could simply think of the variable type as a constraint on the value contained inside of it. For example: 

Given a large amount of time, actually rediscovering some solutions to common problems would help your students to think critically and understand why certain design choices have been made in CS. But you could spend years rediscovering things that are already known, and sometimes just telling allows you to move on more quickly. Removing 'the content' completely from the course would essentially render it pointless—if there's no goal ("in this course, we will learn X"), the course wouldn't really seem to help anyone. As a summary of my views: delivering the content is practically a requirement given the time constraints of most courses, rather than letting students investigate things for themselves. Perhaps changing this would provide some benefits, but the current system has emerged because it's pretty efficient as passing on knowledge, even though some students don't benefit as much as they could. 

How did you begin to teach Java to your students? I bet you didn't start by showing them the Backus-Naur form that the Java parser follows. Instead, you probably introduced a simple "Hello, world" program, and slowly built on that with assignments and projects for the students to work on. I'm sure you can see the parallel here—teaching XML as a prerequisite for HTML is not, in my opinion, a productive or helpful exercise. XML is a rather boring language; it doesn't do anything, so you don't get that instant feedback when you write some code, unlike in HTML, where you can see the webpage unfold as you add elements. HTML is also simple enough that you can generally pick it up as you go along; explaining that you start an element with and end with should be simple enough, and any mistakes in the markup will be visible when you load the page. As a general rule, if you want to teach [insert language here], you probably don't need to teach a different language first; teaching XML to make HTML easier probably won't give you the benefits you're expecting. I'm rather partial to the typical "Hello, world" for HTML. Almost certainly, your students will spot that the title is "My First Webpage", and I imagine that they'll be able to guess with some guidance.