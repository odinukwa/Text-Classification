This is good code, but I will still add a couple of pointers. Some of them may be subjective, but if it adds any value, its probably worth it. 

Please add null check for 'keys' I am assuming you are getting a NPE, if key==null. If key == null, then hashcode is 0. In the while loop in 'get' method, I am struggling to understand, where you are advancing to next entry in the same bucket ? Your Entry class can contain 'next' pointer, such that it behaves like a linkedlist. this can be made since its not changed in scope of method. Similarly can be added. In your method you are catching and throwing the same exception. You would typically catch an exception only if you want to pad it with additional message or cast it into a more generic exception. You always call and there is a logic inside that tells you wether to proceed with or not. Now, if you could either rename it to or do the check before calling it would be more meaningful. 

N.B.: I am not familiar with Processing in detail, but since from the question I understand that 'drawDigit' is an own method (i.e. not built in to Processing), I assume, that it is possible to introduce other own methods in a similar way as in Java. Functionality I do not understand, how the seconds will be rendered correctly. As far as I see, this is the only part that depends on the seconds: 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

should be private and nested. is valid field inside Entity.java, you are using generics. is a more standard name than can be marked as final. You dont need a private , a constructor can call another constructor, called constructor overloading. method does not check for can be renamed to In , is BUGGY. You need to rehash and recalculate index. In you are advancing temp. Its giving you no benefit. Infact it appears buggy. Try looking up for stack using linkedlist. In , your if statement is redundant. code works perfectly fine without if block 

I assume both lists contain object of the same type/class, ie MyClass1 and MyClass2 are not two different classes. In such a case MyClass can override equals method. Once equals is implemented as stated & you have ensured not to have violated the equals and hashcode contract, you can the use a HashMap. This can reduce your time complexity. 

I felt, the two formats and confusing. I understand the whole concept of DRY and stuff, but take it with punch of salt. Make it use the same format. As correctly pointed out by @mdfs13, can and should be replaced. Professionally, a heap could be extensible, not restricted to fixed size. Each time you throw , you pass it empty, ie without any string message. Your child classes have , this can be dangerous since is supposed to be and needs to be . Your should return immutable . Given your implementation you should not encounter this condition in . Good to have a check, but you could avoid such checks in private methods, since they are in your control. In this check should be enof. No need to check ; You can declare this too. 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

Leave it as it is: all output is shown, some of it might be on the wrong place. Overwrite the the end of the first string with the second one (i.e. ). Overwrite the beginning of the second string with the first one (in this case: ). Throw an exception. 

So, I am asking if there is a better way, to compare two sets, providing a custom function for equality checking (in this particular case, this custom function would be ). I am thinking of something like this (pseudo-code only): 

(Of course, you can make it atomic as well, if it should be thread-safe.) Another possible solution would be to have a , which takes care of creating 's. (In this case, I recommend somehow hiding the constructor of , e.g. make it package private, and put the in the same package as the factory. Or have the factory return only an interface which the internal implements.) 

You should add properties to contain the ID, names, etc. To ensure they are safe from being modified in an unacceptable way, make them as private and create methods that allow them to be modifier in controlled ways, if they need to be modifiable at all. Second, the getter methods don't need to take a parameter to determine which User to query. Instead, they should return the value for the property contained within the object itself. 

I've seen a number of questions on Stack Overflow of the kind of "How do I sort on fields X AND Y?" The most common answers to those questions consists of "Write a custom Comparator." But what if you have 3 fields you can sort on? Or 13? or 300? My solution is this utility class, so that rather than writing a billion different Comparators for every possible combination you might want, you write just 3 (or 13, etc.) simple ones and essentially composite them to get the desired behavior. This method is designed to be used as essentially an expanded version of Collections.sort(List list, Comparator c) so I want to adhere to the same contract as much as possible. I am also interested in ways to improve the documentation/API and finding possibly troublesome corner cases. 

One more remark regarding the API This API might seem verbose, but it is the best I could come up with so far. I had previously tried more concise ones, but they were more error prone, and also more difficult to manage for a large (4-5+) number of states/observations. For reference, here are the previous attempts at the API: 

First of all, in my opinion, both the algorithm is nice and interesting, and the code is really well-written, broken down into easily understandable functions! Well done! The only addition that I can make are corner-cases (and their possible fixes) for some of the helper functions. However, please note, that from the main entry point, I did not find any way to trigger these corner cases, so, from a user perspective, the program works well even without the changes below. Corner case # 1 

In this way, the result of the above example will be: . Of course, it might be worth considering to rename the parameter, e.g. to or something similar. P.S.: I setup a github repo for the above mentioned changes, and their corresponding test cases (along other tests): 

You should create a single MongoClient that your DAO uses to access the database, as suggested in the documentation. The client internally manages connections to the underlying database so all the opening and closing you perform is unnecessary and inefficient. To go even further, you should have Spring manage it and inject it to whatever needs it. is a typo, the correct spelling is . is not a very descriptive name. We already know it's a , the type is right there. Better something like that conveys meaning and even that's not a great one. That said, transforming the documents into raw lists of values and extracting the values via index is rather opaque and fragile. The indices used look like magic numbers, without meaning attached, while a is already a Map. Thus you could, for example, call on it instead of juggling indices. This will lets the reader know that the value is meant to be an integer and that it is the id of the object. I would assume by the name and parameter that the method will return a instance with that ID. Instead, it queries the database, the resulting instance is pulled out and added to some sort of local cache and the entire cache is returned. Note that this is identical to the method; the only difference between these two methods is the hidden side effects they're doing behind the scenes. currently doesn't actually do anything except provide lots of pitfalls to stumble into. It looks like some sort of cache yet every method bypasses it to always hit the database. Every method manipulates and returns it so every action has the danger of stepping on each others toes. It's also possible for classes outside the DAO to manipulate it because the mutable list is returned directly. You honestly should just get rid of it. The method doesn't update anything; it is exactly the same as the method with a different name. So we now have 3 methods with different names and the same obvious effect but subtly different hidden side effects. There is no method that suggests to me that it is meant to be used to save new values. I would replace the method with a that is used to both add new values or update existing ones to the database like Spring uses. 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

For the refactoring, I suggest that you should wrap the logic of the for-loop into a do-while loop. Something like this: 

I especially like the point of @Mike, namely that you should generalize your code. I would suggest taking this idea one step further, by having the situations and the choices in some data structure (e.g. JSON) and having only a single div, where to render the text and the corresponding choices (as opposed to one div per situation). To be more concrete, I am thinking about something like this: HTML: 

N.B.: is borrowed from a task of codewars.com, all the rest is my code. While any remark, and suggestion is welcome, I would be interested most particularly in the following questions: