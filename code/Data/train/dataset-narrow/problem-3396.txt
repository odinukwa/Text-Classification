If no one is actually using the desktop, you're not going to notice a direct performance hit, since it is not contending for the CPU -- it's idle. However, it will occupy a chunk of memory. This may or may not be significant depending on what else is going on. To have a look at how much RAM you are actually using, check ; the important number is the second one on the second line ( -> ). If that's at least half of the on the first line, don't worry. If you are using most of your available RAM, performance will suffer because the system uses whatever is left over for page/file caching; this is why output from can be a bit confusing (if you don't take caching into account, it may appear that you are always using almost all of what's available). The page cache is a good thing, which is why leaving 100 MB or so for it on the pi is beneficial. Personally, I don't care about graphical boots or logins; if I want to use the GUI, I just log in on a console and use . If you generally aren't using the desktop, you might as well disable the display manager service. On raspbian wheezy, presuming you haven't changed the default runlevel (2): 

The recommended maximum is 5.25V, and yes anything in excess of could be catastrophic for the device (although as per joan's comment below, you may actually get away with somewhat more). The problem is that current is a product of voltage and resistance (Ohm's law). The resistance is engineered in the device's design to deal with a specific, narrow range of voltage (in the Pi's case, 4.75 - 5.25V). If you supply less than that, there is too little current and the device will not work. If you supply more than that, the amount of current will increase correspondingly. Excess current will cause components to heat up, and at a certain point, that heat will physically damage them. Polyfuses excepted, such damage cannot be undone. I believe the polyfuse is less likely to protect against overvoltage because more delicate components in line after the fuse will heat up to a critical point first. However, the big picture is not necessarily that simple (see Ghanima and Milliway's comments below regarding the presence of a TVS diode in the 5V power regulation circuit; above a certain threshold, this will mean voltage will flow to ground with little resistance, causing a surge in current which hopefully trips the fuse), and it does not hurt to cross your fingers. 

If you are using a USB SD card adapter (e.g., because you do not have a microSD card), this cannot be used to boot the pi. You have one choice of boot device, the built-in SD card slot. Once an operating system has booted you will be able to use the USB adapter. 

It does not have to be run . You can now log out and that should stay going. Every 15 minutes it will print something like this to : 

1. Init, being the first process run (the only one ever started by the kernel), has a limited set of hard coded environment variables (such as a basic ) and that's all it passes on to the scripts it starts. 2. Another confusing distinction -- this means they're not really environment variables, they're just variables belonging to a POSIX shell instance. Such a shell will put them into the environment with . 

This is incorrect syntax, which in latter editions of (Debian/Raspbian tends to lag substantially behind current upstream versions) seems to have been made more clear, where the output would probably have a third debug line: 

The first form quotes the argument, making it a single string. The second uses a character escape sequence (backslash + space) to indicate the space is part of a contiguous string. Most people will find the first form more intuitive, but the second can be useful in more convoluted circumstances. Do double check the name to make sure that is a space and not an underscore (). 

There maybe a bit of a complication if you are using systemd with jessie (it does by default), although I believe it still supports the older methodology. Or you could just stick with what you have, which should work. You should be able to check post boot w/ . 

Presumably NOOBS runs a linux kernel just like all of the options it appears to present, so this is a little strange and understandably frustrating. Note that although even some of the people responsible have taken to referring to various linux distributions as if they were separate OS's, this is a misnomer: they are all packaged variations on the same operating system (linux). With regard to hardware compatibility, what works on one linux distribution should (or could be made to) work on another, and what can't work on one can't work on another either. So on the positive side obviously your keypad can work, but for some reason on raspbian it doesn't. That's a little bizarre because USB keyboards are standardized -- unless you have a very unusual keypad (you don't actually say what it is). NOOBS does not look very user friendly to me WRT to accessing the system log, but in raspbian it's -- you could have a look at what appears in there when you plug and unplug the keypad. 

If you want to use that permanently, add the same line to . For example, I use JDK 8 on the pi that I have installed to /usr/local, so I have a line: 

[Source: Adafruit] It's what is referred to in the description as the "driver board". In this pic, the cable you thought was covering a Pi's GPIO's is connected to the screen itself, and the eight wire adapter on the right goes to the other little PCB with buttons for controlling brightness and contrast, etc. Notice the HDMI jack on the bottom, which in one of the other pictures (with the actual screen in it), you can see this board in the background with an HDMI cable attached. That's what would be connected to the pi. So technically, you could use this screen with any device with an HDMI jack and a 5V output. It will not impede your use of the GPIOs in any way, but it does mention it needs 500 mA, which I think is about half of what you could reasonably expect the pi's 5V outputs to supply. 

That link is outdated. To disable the serial console and login on current versions of Raspbian, all you have to do is edit and remove: 

Probably not beyond observing that most likely you accidentally did a lot more than you think you did. 

Where are you running that script from? It looks to me like you do this from within the X GUI. In that case there is probably already a window manager running. Even if there is not and/or this is an xinit script, you should not background the wm and go from there. The proper way to do this is to create a separate script with your loop in it and put the rest of the stuff in or where ever is appropriate for arch (try there first): 

Writing to the SD card is much slower than to a USB drive, and in fact in copying from SD to USB the bottleneck will be in reading from the SD card: 

This should produce some output and perhaps ask you questions about repairing the filesystem. Say yes to all of them. You can also use the switch to to automate that. Put the card back in and try again. 

First, address size (such as 32 or 64 bit) is not the only defining characteristic of processor architecture. Commonplace desktops and laptops are x86(-64) based. The Raspberry Pi's SoC is not. It is ARM based, like most mobile devices. While it is not explicit on the download page, the fact that Android Studio is distributed in binary form with only two options (32 or 64 bit) implies with certainty these are x86 binaries. So you are out of luck. Note that various tools such as are available as packages on Raspbian (and the SDK appears to be...), as I think is Eclipse(??), but I do not know how far you can go with that development wise. I doubt very much there is any possibility of running an emulator on the Pi and if there were, it would be horrific performance wise. I also doubt running Eclipse on the Pi 3 is going to be much fun. This is probably not something worth pursuing. 

You may want to go through other things in that directory () but that's the best place to start. It's the same path as in a kernel source tarball, if you have one of those. I've used the native userland interface via C and C++ quite a bit with a bunch of devices. The only caveat I have is that some of them respond better to plain and than to the functions; if at first you don't succeed try the same thing only different. 

Hopefully not, but that's not all that's going on. You're also making a comparison each time to evaluate the for loop conditional. No more than 1 assembly instruction can be processed per cycle, and I believe it may often be less than that, e.g., if the instruction requires fetching or storing stuff from/to RAM. I'm not at all an assembly level guy, but I can show you some clues about what's involved. It's easier if we break that loop down a bit, although the assembly generated won't be quite the same: 

1. A few good reasons for that: 1) It will probably be cheaper as this is a less common need than you may think, 2) It's more flexible, 3) The DC booster hardware should outlast the batteries, so you don't want them all together in a "power bank" style package. 

This is possible although it would make more sense to connect the pi to the router, then everything else to the pi -- I mention this because the "along with everything else" in your question is a little ambiguous. Perhaps that is what you meant. Anyway, this would obviously require a bit more hardware -- a switch or hub and/or an appropriate wifi adapter. There are advantages and disadvantages to this. The major advantage would be you could set up a much more fine tuned firewall than you can with the stock software on most home routers. But the disadvantage is... 

You're not screwed. That is not to say my solution will work, but one way or another this can be worked out. The easiest way might be to start by using the image that was the original source of the card you want to copy (presuming it is not also 3.69G). Put that on the new card. Next, use or whatever to size the data partition (for raspbian, that's the second one) on the card up. Then mount both data partitions, and update the new one from the old one with rsync: 

Or whatever the new UUID is for the HDD partition. Don't accidentally add a newline into this file or anything. If all this doesn't work, all you have to do is change that back to what it was (). The reason you need to use the UUID instead of the device node is unless you add a rule to set it, the device node of the HDD partition is unpredictable (although it may often be the same). Finally, before you try this, edit the on the HDD partition. Change this: 

They claim elsewhere the firewall is iptables and the system is debian based, so if you can't find Settings or it doesn't work, look thru the list returned by for "iptables". If it's there, to stop it: 

Getting the logging script to run on boot without any potential foreground UI. Get the same (background) script to respond to commands -- this means a client/server architecture, which is how most of the background things started at boot work. Get the background logging service to start a foreground GUI process (in response to a client request) which will report from the log/control the logger. 

Somewhere after . If that's not there, the problem is your configuration wasn't read (but there's no reason it shouldn't be on a stock system, see again). If it is, keep reading down the log -- Xorg should report your typos/errors. 

Realistically you can't, VirtualBox is for x86(-64) ISAs only, whereas Pi oriented images are ARM based. You would have to take the source code for everything in the base image and recompile it -- which is not realistic. You could take stock Debian and tweak it in the same ways as Raspbian does. There are probably a few things in Rasbpian that are unique to it, but they could be compiled from source. This would be much less work than the last option, but still considerable -- possibly hundreds of person hours.