I was reading Andrej Bauer's paper First Steps in Synthetic Computability Theory. In the conclusion he notes that 

Is it true that for all $n$ there are $n$ pairwise nonhomomorphic graphs with $poly(n)$ vertices? Is there a polynomial time algorithm for constructing such families of graphs? 

Stephen Smale claims in Mathematical Problems for the Next Century that $$NP \not\subseteq BPP \implies NP_{\mathbb{C}} \not\subseteq P_{\mathbb{C}}.$$ Can someone sketch the argument or provide a reference? Is there any similar result in the reverse direction? $NP_{\mathbb{C}}$ (definition) and $P_{\mathbb{C}}$ (definition) are NP and P over complex numbers $\mathbb{C}$ using the Blum–Shub–Smale machine model. 

Razborov proved that the monotone function matching is not in mP. But can we compute matching using a polynomial size circuit with a few negations? Is there a P/poly circuit with $O(n^\epsilon)$ negations that computes matching? What is the trade-off between the number of negations and the size for matching? 

I am trying to understand the bitcoin protocol in the context of computational cryptographic security. The question is a reference request to foundations of cryptography articles on bitcoin. My first question is what abstract cryptographic protocol bitcoin is trying to implement? Do we have a definition of electronic money/digital currency in cryptography that captures bitcoin? What are the security requirements for a secure electronic money? If the answer is yes, companies like eBay provide a centralized mean of electronic money transfer. Does considering a decentralized electronic money changes the definition of abstract cryptographic protocol for electronic money? Or is it just the same concept but in a model where there is no trusted third party? Can the adversary break the protocol if it has more computational power than the combined computational power of other (honest) parties? Assume that we have $n$ parties $P_i$ for $1 \leq i \leq n$ plus an adversary $A$ networked and the adversary wants to break the bitcoin protocol. For simplicity let's assume that the network graph is $K_{n+1}$ and adversary does not control the network and simply is a party like others. What would be the exact mathematical claim about the security of the protocol in this simple case? 

This made me wonder about non-relativizing results in computability. All results I know from computability theory do relativize to computation with oracles. Are there results in computability theory that do not relativize? I.e. results which hold for computability but do not hold for computability relative to some oracle? By result I mean a known theorem in computability theory, not some cooked up statement. If the notion of relativization doesn't make sense for the result then it is not what I am looking for. It is also interesting to know if the result can be stated in the language of Synthetic Computability Theory or not. 

Place all non-split vertices (under the ordering) into $A$ and $B$ by putting the vertices with 3 successors into $A$ and the vertices with 3 predecessors into $B$. Tentatively add all split vertices (under the ordering) into $A$. Repeat steps 4 and 5 until step 4 fails: Identify a split vertex $v$ that has more neighbors in its current set ($A$ or $B$) than in the other Move $v$ to the other set 

I have for a while been curious about Turing Machines with exactly one tape and exactly 3 states (namely the start state $q_0$, the accept state $q_{accept}$, and the reject state $q_{reject}$). Note that I allow arbitrary (finite) tape alphabets (i.e., the tape alphabet is not restricted to equal the input alphabet). For convenience, call the class of languages recognizable by such TMs $C_3$. I have several questions about this class: 

Since you specifically ask later about the version of the problem in which the given path is restricted in how many times it visits each vertex/edge, I assume that the original version of the problem has no such restriction. In other words, in the original version of the problem the "path" is actually a trail (i.e., any sequence of vertices such that each contiguous pair has an edge between them). Thus I will refer to the original version of the problem as the trail max-weight travel problem. The other version, in which the number of uses of each edge/vertex is limited, includes the case in which each edge/vertex can be used at most once (i.e., the trail used must be a simple path); I will call that subproblem the simple path max-weight travel problem. Below, I prove that trail max-weight travel is weakly NP-hard and that simple path max-weight travel is strongly NP-hard. trail max-weight travel is weakly NP-hard We reduce from the Unbounded Knapsack problem: we are given a list of pairs of positive integers $(c_1, s_1), \ldots, (c_k, s_k)$ where pair $i$ represents a type of item with cost $c_i$ and size $s_i$, a maximum size $S$, and a minimum cost $C$, and we are asked to decide whether it is possible to choose some quantity of each item so that the total size is at most $S$ and the total cost is at least $C$. Suppose we are given an input $(c_1, s_1), \ldots, (c_k, s_k), S, C$ to the knapsack problem. Let $H > S$ be any big ("huge") number. Then we build an instance of trail max-weight travel as follows: 

Recently I have seen several articles on arxiv that refer to a proof system called sum-of-squares. Can someone explain what is a sum-of-squares proof and why such proofs are important/interesting? How are they related to other algebraic proof systems? Are they some kind of dual to Lassere? 

How hard is this problem? If we choose $a,b,p,m$ randomly but "wisely" will $f$ be a pseudorandom number generator secure against TC0 or AC0 circuits? What is the smallest value of $k$ where $Q$ can be solved? What is the fastest known algorithm for $Q$? 

Lynch's Distributed Algorithms book is a classic but it is from 1996 and rather out of date. Are there any recent distributed computing books that can be used as textbooks for a graduate distributed computing and algorithms course? 

How to compute the inversion of $2^n-1$ bits using $n$ negations Let the bits $x_0, \ldots, x_{2^n-1}$ be sorted in the decreasing order, i.e. $i<j$ implies $x_i \ge x_j$. This can be achieved by a monotone sorting network like the Ajtai–Komlós–Szemerédi sorting network. We define the inversion circuit for $2^n-1$ bits $I^n(\vec{x})$ inductively: For the base case we have $n=1$ and $I^1_0(\vec{x}) := \lnot x_0$. Let $m=2^{n-1}$. We reduce $I^n$ (for $2m+1$) bits to one $I^{n-1}$ gate (for $m$ bits) and one negation gate using $\land$ and $\lor$ gates. We use negation to compute $\lnot x_m$. For $i<m$ let $y_i := (x_i \land \lnot x_m) \lor x_{m+i}$. We use $I^{n-1}$ to invert $\vec{y}$. Now we can define $I^n$ as follows: $$I^n_i := \begin{cases} I^{n-1}_i(\vec{y}) \land \lnot x_m & i<m \\ \lnot x_m & i=m \\ I^{n-1}_i(\vec{y}) \lor \lnot x_m & i<m \\ \end{cases}$$ It is easy to verify this inverts $\vec{x}$ by considering the possible values of $x_n$ and using the fact that $\vec{x}$ is decreasing. From Michael J. Fischer, The complexity of negation-limited networks - a brief survey, 1975. 

Manuel Blum is a well-known theoretical computer scientist and a Turing award winner. But more interestingly, he has the highest number of students who have gone on to win a Turing award (Leonard Adleman, Shafi Goldwasser, Silvio Micali) in the whole computer science. The list of his students is amazing and even more so if we include the students of his students. Can anyone comment on Manuel's supervisory style? What makes him so successful in training exceptional researchers? Anything that can help other supervisors be more successful in training exceptional researchers? 

You can prove your idea via the usual recursion theorem proof of Rice's theorem. proof: Suppose that $M_{yes}$ is a machine with both property $P_1$ and $P_2$ and that $M_{no}$ is a machine with property $P_1$ but without property $P_2$. Such machines must exist by the nontrivial assumption. Then suppose there exists a decider $D$ which accepts any input $<X>$ such that machine $X$ satisfies both property $P_1$ and $P_2$, rejects any input $<X>$ such that machine $X$ satisfies property $P_1$ but not $P_2$, and has any behavior on all other inputs. Consider the following machine: $M =$ on input $w$: 

Consider your problem restricted to 3-regular graphs. Consider some ordering of the vertices. Define a split vertex to be a vertex $v$ such that both $succ(v)$ and $pred(v)$ are non-empty and define a non-split vertex to be any other vertex. Notice that in a 3-regular graph, the value of $|succ(v)| \times |pred(v)|$ is $0$ if $v$ is a non-split vertex and is $2$ otherwise. Thus, $\sum\limits_{v\in V}|succ(v)|\times|pred(v)| = 2n_{\text{split}}$ where $n_{\text{split}}$ is the number of split vertices. Therefore, in 3-regular graphs, solving your problem (minimizing the summation) is equivalent to choosing an ordering so as to minimize the number of split vertices. The following theorem tells us that solving your problem in 3-regular graph $G$ is equivalent to solving Max Cut in $G$. Therefore, since Max Cut in 3-regular graphs is NP-hard, so is your problem. Theorem If $G = (V, E)$ is a 3-regular graph with $n$ vertices then there exists an ordering of the vertices such that the number of split vertices is at most $k$ if and only if $G$ has a cut of size at least $\frac{3}{2}n - k$. First direction First, suppose there exists on ordering of the vertices such that the number of split vertices is at most $k$. Then we partition $V$ into two sets $A$ and $B$ as follows: 

Not necessarily. For example, consider the case where $L_1$ is the empty language and $L_2$ is any NP-complete language. Then certainly $L_1 \in NP$ and $L_2 = L_1 \cup L_2 \in NP\text{-}complete$, but $L_1$ is not itself NP-complete. 

One of my papers was just posted to arXiv and addresses this question: optimally solving the Rubik's Cube is NP-complete. 

Every variant of your problem is NP-complete. First some definitions in order to make the ideas in my proofs more concise: I'm going to use the term length for a trail/path/walk to mean the number of edges in it. This is just to resolve ambiguity (i.e. I'm not talking about the length of the list of vertices comprising the trail/path/walk). Define an $n$-trail, $n$-path, and an $n$-walk to be a trail, path, or walk respectively, of length $n$. Define a vertex cover of $X$s in some directed graph $G$ to be a set of vertices such that every $X$ in $G$ contains at least one vertex in the set. For example, a vertex cover of 1-trails in $G$ is just a vertex cover of the undirected version of $G$. The decision version of your problem, which I will refer to as the vertex cover of $X$s problem (for various $X$) takes as input a directed graph $G$ and a value $k$ and asks whether there exists a vertex cover of $X$s in $G$ of size at most $k$.