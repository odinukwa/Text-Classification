But you do need 100 of them so you can store all intermediate values: You don't need to loop over an array to initialize it: 

In both read and write you should leave the loop after an error (unless you have explicitly tested and fixed the error). 

Declaring variables using the comma is lazy and considered bad practice, but you should also use more descriptive variable names. i/j/k do not explain what they are being used for. Also if you function is longer and you need to change it looking for all instances of a variable 'i' may take a while longer because of all the false positives on a search so maintenance wise it is also a bad idea. There are a couple of edge cases where the declaration can go wrong. So in general it is just best to stay clear. 

It looks like the just a call to the constructor. Why not just call that constructor. If you modify the constructor of to pass the next pointer then you can really simplify the push. I would write it like this: 

The call converts a string in IP format into an address. But this is not really that useful. I needed a function that converts a hostname or IP address string into an address. The constructor allowed you to specific a non blocking connection (and it was the default). In reality that will not work for a connect call (as you are establishing the connection). So I removed the option to making it nonblocking and it always passes true down to the base class. 

This is where your class is horrible. It is basically the most unfriendly container class I have seen and can not be used with any of the standard algorithms, which makes it practically unusable. 

They provide absolutely no benefit. In fact they are considered worse than useless because they give you a false sense of security. The better way to get the compiler to tell you when there is an issue. Get your compiler to treat warnings as errors (because warnings are actually logical errors in your thinking). Then you compiler will never let you use the assignment operator in a test. Doesn't “if (0 == value) …” do more harm than good? In C and C++, what methods can prevent accidental use of the assignment(=) where equivalence(==) is needed? 

You should probably mark it as const. This allows you to pass the stack by and still check the state of the object. DRY you code. The following code is repeated in two places 

Validate input. Your code looks good but you have no error checking. If anything but a number is typed in then the whole program crashes with undefined behavior. 

But usually when you have an input stream reader you also have an output stream writer that mirrors the reader. So when you persist to a stream the class can also read the value in. In ATM: Interesting. You have a action and action applied for every transaction. Does this mean that a transaction can perform both operations? 

Good practice to initialize all members so they have defined values. In the next one will have an indeterminate value. 

In Again more white space needed. Again tabs/space problem. In your printing functions. Rather than serialize to std::cout. You should probably pass a reference to a stream onto which you want to serialize the tree. The method custom print should probably be re-named . 

You have taken the stance that your ranges are inclusive of end. As you will notice this actually makes your code harder when you have empty ranges. But also it makes your split inaccurate. 

That's an awfully slow machine. 90 seconds for 300,000 calls or 3,333 calls a second. Even unoptimized this code runs (300,000) in less then 1/100 of a second on my machine when fully optimized it is closer to 1/1000 of a second. So it is not this code that is causing you to slow down. But the result of this code may be affecting the call path inside your application and causing other more costly code to be executed. Since this code takes 1/1000 of a second of the 90 second total. It is contributing to 0.0001% of the execution time. This is so insignificant that you should not even be trying to optimize this part of the code. My test code: 

Can be ? Who owns the object? You need to think about your ownership semantics of the interface. You are using a very C style of just passing pointers around. This is not how things are done in C++ (or at least modern C++). Yep this is an old trick. 

That loop can be written in several better ways. Copy and Swap Idiom Here you destroy the old data before you know that a copy will work. Thus potentially leaving your object in an invalid state. Look up the copy and swap idiom. It is a safe affective way to perform an assignment. 

The easy way to do it (in steps) The std::istream_iterator<X> reads from a stream using . If is then it reads one white space separated word from the stream. 

Use the for assignment operators. This is suseptable to failure if one of the operations fails and throws an exception (you will be left in a non consistent state and thus have not provided the ) 

For the above code to work must work with and which by default call and on the container. The values returned are considered iterators and tested against each other using . So the above code can be considered short hand for: 

You can use global read only variables to define constants but that's the only good use of a global. You should wrap your variables inside one ore more classes so you can control access to them. An array of 1 character strings!! 

Also your variable names are a bit on the short side. This makes it hard to understand what you are trying to do. A bit of verbose ness will help in self documenting the code. Again does not look like you need a dynamic object. 

Yank that stuff out of the loop it will probably make it fast. If you must have branches in a loop then make the true branch the one that happens most frequently. 

But having this just means your code is tied to this one board. You can make your code much neater and thus much more re-usable by encapsulating this information into a class with methods to manipulate the state of the board. Also by using encapsulation you will prevent accidently modification of the board by other parts of the code becuase you can protect the state of the object by making it private. 

Looks like these should be static const. They are valid for all members. You don't want to initialize them more than once and you don't look like you are going to modify them. 

Holding these as separate fields makes the rest of the code more complex. I personally would hold this a single value (seconds since start of day). Then all your comparisons become trivial. Your get functions become slightly more complex but not not very much: 

Your interface does not make that clear. Which is why you should not use pointers. I think I covered all this in the previous paragraph. 

If the user wants a copy. Then all they have to do is assign it to a local variable and you will get a copy. But if they want to manipulate the object in the garage without a copy then you can also do that (so best of both worlds). 

To be blunt that is the compilers job. If you are worrying about the low level architecture you are using the wrong language. You should be worrying about the algorithm efficiency not the register usage efficiency. The most common thing done wrong by java devlopers is allocating code dynamically when a normal local object would do. In your algorithm I would worry about space usage. You are using way too much for the current algorithm. For integers you don't have to worry about the cost of moving objects as a copy and a move have the same cost. But in the general case you should prefer to move rather than copy when you can (a move can be a lot cheaper than a copy). Also your code may be generalized in the future and if you have already done the work then your function can be templatized with no extra work than adding to the front of your function. 

Not sure I believe that will hold. Middle is a good estimate. But you need to find the start of the word. So seek forward for the next word. 

I hope that inspires you to simplify the rest of the code. The next section is a classic example of when to use an array: 

In C++11 exception specifications have been deprecated. The curl library is a C library. It only knows about C calling conventions. Thus you can NOT pass it C++ functions. If it works it is pure luck and definately non portable. 

When you override virtual functions add that will get the compiler to check that you have written the correct override. You inherit privately from std::exception This means nobody else sees it as an exception class. You should inherit publicly from it. 

People can have big religious wars about the two. Personally I prefer the first one in my code but its not a big deal if a coding standard says use the second one (I don't care enough to argue about it). BUT everybody agrees that consistency is important so pick one and stick to it. Also note the second style of putting the '{' is usually only used for non function scope blocks and that most people use the '{' on the next line for functions (but this is a style thing so not a big deal). Just want to emphasis that consistency is the key. If you are going to claim that it is (then make sure you have spell checking turned on) 

But there is an O(n) solution. What you need to do is convert the search of the second string into a single comparison. Since char is a limited range (0-255) we can swap space for time. Allocate an array that represents every character possible character. Then we can use this as a way to look-up the existence of a character. So rather than doing this: 

Your large number of if statements could be reduced (without reducing readability). I would not go to the extreme of putting it all in one if statement but you can definately combine a few. 

Move Operators: Much easier to write in terms of swap. Then you only need to write it once (in the swap method). Also Best to mark move constructor and move assignment as (assuming they are). If you place them in containers it allows them to be moved otherwise containers will attempt to use copy semantics so that they get strong exception guarantees. 

Recursive Converting a loop into recursion requires an extra function to cope with the extra variable used for last. So the main recursion looks like this (it just calls the actually recursive function setting up the last parameter). You should have this wrapper function to help users of the code from calling the recursive part of the function incorrectly. 

Fortunately all your global members are const so its not a real problem. Don't passs by value (unless it is a small POD object). Pass by const reference to achieve the same result. If you need to mutate internally then you can make a copy at that point. SO 

Nope. You are not making a copy. You just moved the pointers. Comments that are out of sync with the code are WORSE then useless comments. Do you want me to believe the comment (you are making a copy) are do I believe the code (you are moving the pointers). Did you believe you were making a copy and that assumption cause the code below to break? I don't know. As a maintainer I would hate you as now I would need to debug your code to make sure you did it correctly then fix your code or your comment. Insert Helper My first though about this. Is that if the key already exists then its not inserting the data (we are overwriting the existing data). Now this could be OK but it would be nice to know. If we look at the standard containers an insert into std::map returns a boolean indicating if an insert happened (true data was inserted, false data was not inserted but the data is in the map). The rest goes back to standard recursion. You can remove half the rest of the code. By not checking if the left/right are null but just re-calling and retuning the new value. If the value is null on entrance you create the value and return it. 

But that seems awfully deeply nested. Which usually means that there are are top level includes that include these files indirectly. A comment with a link to the documentation would be nice especially since a maintainer is not likely to know about these. Hmmm 

I think you are testing here to make sure that you don't fall off the front of the string. But you are checking the content of the characters not the position of the pointers. A better test is 

So in this code if we get to the default action; the debug version will assert (and stop the application) while production code will return . In my opinion if you get to a point where your code should not then throw an exception that should not be caught. That will cause the application to exit (in a controlled way). But in this case I think the expected behavior is not to throw but to return -1. So I would make the default action a no-op. seekpos which The which in your has basically three settings. You only check for two of the three.