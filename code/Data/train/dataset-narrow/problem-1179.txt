Do not use , it can lead to hard-to-spot name hiding errors. Read Why is “using namespace std” considered bad practice? for more information. Be more generous with horizontal white space. Lines like are hard to read and do not gain you any advantage over . Do not try to fit more than one statement into one line. Things like are usually discouraged because they are ugly and hard to read. Putting onto its own line is not going to hurt your code. All caps variable names are unusual to say the least; most of the time all caps style is only used with macros. Thus, should probably be . Do not use for everything. One reason for this is that can overflow and cause undefined behavior, the other is that your code should also express the intent it was written with. Since is a signed type, you imply that a user could also enter or any other negative number for , and also that some prime numbers could be negative (Why else would be of type ?). If you are only dealing with positive integers, use (but be aware to not decrement past 0). 

Conceptual Framework for Domain Model In your application, there's a rule imposed (via your Drools XML) that there is a fixed set of values to a 's move. My opinion here is that your domain model should reflect that requirement, and seeing as you have generics in your code, your application should also be able to support Java enum. I think it's better to capture this restriction on valid moves by creating an enum called like the following: 

I'm not really sure, but somehow I feel like this can be an instance of a refused bequest, or some sort of breach of contract. I think you have few options here: 

Ideally, class should be itself the , but since Drools seem to rely on POJOs and, the constructor for can't be made private, I think this is an acceptable compromise. With this, there probably won't be a need to have separate rule for validating unless there are expected, more complex checking. Also, since the application is checking an external file for values, there isn't a need to recompile or rebuild the code when a new Move like Jedi is introduced into the system. As for the rules on game proper, I'd say they should have been applied to a and not to separate players. The system doesn't even seem to be interested enough in Players to give them names like "Player 1", or "Player 2"; they merely carry a Move in them. A contains 2 objects, each from 2 opponents. The fact that there is a class seems to suggest there should have been a class to begin with. 

[Note: Java makes no guarantees about the time and space complexity of methods. Thus, could, in theory, also have a much worse time and space complexity if not implemented well. I assumed that it runs in O(n) (which is the best case) when matching on a single char only. This fact, of course, makes the second approach even worse.] 

I'm not convinced that it is still appropriate to define as a macro in our modern times. You likely know about all the drawbacks macros have (no type safety, proneness to bad behavior because of missing parentheses etc.), and you don't have any significant drawbacks if you defined it as a function (except for the issue of type rigidity, which does not apply in your case, however, since you only use once and could define it for the appropriate type). In my opinion, and are rather obfuscating the underlying code. Since both of these functions consist of a simple check, and their names do not actually convey what is checked, you are actually losing clarity here. Encountering calls to these functions in the code inevitably makes you go back and read their definitions, because the name just suggests that a check is carried out, not what check. My suggestion would be an -like method to which you pass a condition and which calls if that condition is not met. That way, you abstract a part of the functionality away (the fail-on-error), but retain the self-explaining property of those checks. You can omit the parentheses around the argument of if it is not a type argument. For example, can be written as . The advantage of removing the parentheses here is to make it clear when the argument is a variable and when it is a type name. I don't know how much you care about such things, but ideally, you should check the return value of functions that could fail. This includes , and if your program fails, it is a matter of grace and correctness whether you let it just crash or fail gracefully (correctness in a sense that failing gracefully implies that you accounted for a certain edge condition, such as out-of-memory). Consider factoring "run once"-code out of loops. For example, 

This way, you have more control over the internal state of a given class within the context of a given method, while limiting the method's behavior to something that's more specific. It also makes the code a little more traceable in that if there is no requirement that says a completed can go back to being non-completed, you don't have to enable such state transition. I think it's also somehow more "poetic" to have an invocation like compared to . 

To me, this is a very simple construct that captures the essence of what a Player is: an object that returns a when it s. With interface like this, you can define many different types of Players, like, for instance, one that plays randomly. For example: 

If we're speaking of actual efficiency (as in performance) though, I don't know how much more efficient pattern matching is compared to iteration of characters. However, this is much more readable. In any case, notice that the actual translation logic is wrapped inside the condition that the input string does not contain a number. This way, you return from the method as soon as you determine the input is unacceptable. To check whether the input string starts with a vowel, you can also use pattern matching like: 

Just don't. Don't do this. This is not the C++ way to do things, and can lead to all sorts of trouble down the road. For example, what about this: 

You queue is nearly useless Harsh words. Why do I say something like this? The answer is: You only offer two methods to access elements. While this is conforming to the most basic definition of a queue, it's not very useful in everyday programming. At the very least, you should add an iterator interface, which would also allow your queue to interact with most standard algorithms and increase usability by a huge margin. Also, you should add some type definitions to conform to the standard's container library requirements. Some other things 

This helps eliminate redundant layers of indentation and makes the code more readable. Since you don't write anything to the argument string, you should use to iterate it (in addition to making the parameter , see point 1). Please, don't use . It's horrible. Why? Because it does not do what its name advises and is pretty much redundant. does write an end-of-line character, but it also flushes the underlying buffer, which is seldom what you want (and if you really need that functionality, you should use ). 

As for the restriction about what their names can be, since it's not very convenient to use enum, then I'd suggest using a plain text file of comma separated values, added in the classpath. For example a file in the directory could look like: 

This has a single move strategy, which is what you set to it upon construction. Structuring the the way you did is, to me, a little weak because the class doesn't seem to be in charge of its own state; it seems to rely on some external component in deciding what to do next. In some way, it can be considered an anemic data model whose only purpose is to carry data instead of representing an abstraction or a concept. Going back to my point about the class representing some playing strategy, we know that, conceptually, there many ways a player can play. What I suggest here is that instead of making a Java class, declare it to be an interface instead, like the following: 

Putting all of this (and some bits of supporting code) together, a reworked version of your program could look something like this: 

is not valid C++. In fact, when first reading your code, I was really taken aback because I thought that this shouldn't ever compile. However, it turns out (after researching) that this is actually a MSVC extension, albeit a really useless and horrible one, in my opinion. Please, please, please use the standard syntax, lest you want a mob of C++ programmers with pitchforks and and burning torches show up at your door. Don't use . It's bad, because a) does the job just fine, and b) actually also calls on your output stream, which is something you very rarely want. Just stick with and call directly when you mean to. Order your includes. Why? Because ordering includes makes it easier to verify whether all necessary includes are actually there, in two different ways: One, it makes it easier to manually verify that all necessary headers are there and two, the compiler will complain if you are missing an include in a header file if that header file is included before its missing header is included (For example, imagine depends on including . However, the author of forgot the include, and now you're using the header in your project file , which also requires . If you first include and then , your compiler will complain that it can't resolve in . If you include first, however, this error does not surface because now the include is there. This is known as include shadowing.) So how should you be ordering those includes? First of all, nearly all people agree on alphabetic ordering. Secondly, it makes sense to group headers into categories such as "files from the current project", "library headers", "STL headers" etc. If you do this, it is recommended to write, from top to bottom, first the header the current file is implementing (if any), then headers from the current project (i.e. local/internal headers), then headers from different projects and libraries (i.e. external headers) and finally standard headers. This is most likely to prevent include shadowing bugs due to each header being checked in its implementation file (given that such a file exists). Always use over ; the existence of in the global namespace is not guaranteed by the standard, but in the namespace it is. Avoid including everywhere. The reason for this is that usually injects static instances for , and which can lead to binary bloat. More importantly, however, is a code smell, because using and family is constraining your users and yourself. Imagine, for example, a bot, which wants to run some 1000 or 10000 games of Keno and log the results to a file, or a websocket, or any other I/O device. Currently, the only way for that bot to achieve this is by redirecting standard output, but that might not always be possible. Also, what if the bot actually only wants to log the output of to its destination, but doesn't care for the rest you write? Currently, it would need to parse the standard output for that, which, again, might be constraining or unfeasible. But if is bad, how do you implement output functions? The answer is by refactoring your output functions to take an as parameter and write to that instead. Syntax-wise, there is no change at all; the offered degree of flexibility, however, is much, much higher. (Don't forget to change to , though). has two issues: 

My personal view in methods like this is that instead of making them setters/mutators, you turn them into actions/features. So instead of having a that takes a from a client component, I think it would be a bit more sensible to have something like: 

Hopefully the class illustrates my point about classes being in charge of their own state, actions, etc. Lastly, about , I will also say that this class is weak, and overly transparent. My idea is that once a object is created, it will never change. Because of this, I think that should be defined this way: 

Hopefully there's a way to make this work both ways. Anyway, I don't expect to get everything correctly here, but I hope somehow I raised interesting points regarding your code structure, and domain design 

I don't know what field represents, but I kept it. However, due to the fact that it's not readily understandable, you should reconsider why it's there in the first place. In any case, notice that there are only getters for this class, and no setters. This is because, like I said, objects most likely won't need to change, there's no point enabling the state transitions in them. Rules Integration I missed a critical aspect of the problem you're trying to solve with your code, which is the rules engine primarily geared towards not-so-technical people. However, I still think that having those rules in the system does not mean we should completely forget about good OO design. I believe that rules should augment your design, not hijack it. Since having a enum is quite restrictive, my idea is to define it instead as a value object: 

The bug I've found is somewhat unfortunate, but easy to fix. Apart from that, there are a lot of little things that you could do to improve your code, but apart from point 1 I didn't spot anything that would require immediate changes. However, it would be nice if you'd strive to make this code portable, i.e. remove . Also, there are some irregularities in how you name things; you should decide on a coherent style for the sake of readability. Regarding STL usage, I didn't actually find much that could be improved. Apart from replacing legacy C functionality (i.e. and ), there is not much to do in regards to making your code more C++-y. Overall, I enjoyed reading your code. Keep up the good work! 

The same problem I mentioned at also occurs here: You have a lot of unncessary allocations. Again, the approach to solving the problem is similar: 

corresponds somewhat to and takes the underlying character type as a template argument. Your former classes and are now only aliases for certain template specializations, just as and are. (In my code, is kind of hidden away inside an namespace. If it serves your need, however, you could also make it part of the public interface of your program library, allowing further specifications such as )