Your code uses streams quite neatly and well. The algorithm employed is not necessarily the best, but the logic is reasonably clear. It's common with streams to use vertical white-space to make the steps in code more readable. For example, the line: 

There are a number of concurrency issues in this code,. I can point out what I see, but correcting them will require some significant rethinking... and determining what the rewrite will need will take more than there's time for in this answer. Concurrency issues: 

You should also have a 'NoStyle' class that takes a raw String input, and returns a null getSource(); using this system you can easily add Styles, and you can have styles that join phrases, etc..... Also, you can add the styles together in a way that makes decomposing the value easier at a later point, and you only need to add/wrap the styles that you want. 

Having made that recommendation, though, I also recommend having an index on the column which will make the scan a whole lot faster too. The query is still really ugly â„¢ but that's a problem in your application and data storage. Additionally, your final query is horrible, horrible, and horrible. A group-by query with many columns, but only grouping by the policy_id is very messy, and is MySQL specific. The values returned in the other columns are unspecified in terms of behaviour. I hope all your values in all the columns are the same or otherwise your output values are unspecified. It is a problem with your database structure too, that the data is not normalized. Why do you record the same values for the same policies in multiple records? Your database may be a data warehouse, but even then it is a bit of a mess. You should audit your tables, and reconsider the design and normalization of your tables. Still, if you apply the changes I suggest (add the year index, and have a single temp table for the year values), then I imagine your query will execute in about 5 seconds instead of 30. 

Your algorithm is fast (vnp has an interesting solution too), but your implementation is a bit messy. First, some nit-picks: 

Your code is odd in the sense that it is going to a lot of effort to calculate that 103 is 1000. I understand why you are doing it, but I took the liberty of changing the terminating function and replacing it with: 

If you think of that in binary terms, notice how if the bit is set in the first value, we get the respective two-power of the right-value and add it. As we shift the left value, we determine whether it's low bit is set, and we multiply it by the doubling right-value... until one of the values is zero. 

That's a LeftFolder that has a folding function, and an initial seed. Using that LeftFold, you can create your actual NQueen solver with: 

Your server sets up a cluster, then listens for requests. It parses a parameter from the request URL, and writes it to file. For performance reasons, that write to file should be asyncrhonous. Currently your client has to wait for your log to write before the client continues.... but, here's the real flaw in your code.... ... you do not send a response at all to the client! You need to actually process the response by sending a status code, and ending the communication: 

it is called many, many times the while loop iterates many many times there's something else you're not showing. 

Note how, in this class, I use a trick for the , where it is advanced in the finally block of the call. This is a pattern I like because it makes the method very light-weight, and it is always a step-ahead of the data. So, that is a single-purpose class, it converts a to a line-at-a-time . Now, you need a unique ... which can look something like: 

Your Monster class should have very few, even no static fields. All static fields, if any, should be constants only ( ). What you want to do is separate the definition of a monster from it's implementation. Also, the implementation of the monster should be based on a template that sets it's characteristics. The Definition can be that template too. So, consider a class that is something like: 

and your read-side becomes (note you had a bug before because if you had multiple listeners you would poll different values for each of them): 

There can be a lot of permutations, and the numbers get large fast. The actual formula is a factorial, as in \$n!\$ where \$n\$ is the number of values in the set. If there is one member, there is only one permutation. If there are two, then there are two permutations. Now, the way to visualize it, is that, we know there are two ways to arrange two members.... with three members, we start building permutations... take the first member from the set, and there are 2 ways to arrange the remaining 2 members. Then take the second member from the set, and there are two ways to arrange the remaining 2. Finally, take the last member from the set, and there are two ways to arrange the remaining 2. In other words, there are \$3 \times 2\$ permutations. If we reduce the logic down to just one member in the set, then the actual sequence is \$3 \times 2 \times 1\$. Then, if we add a fourth member, it becomes \$4 \times 3 \times 2 \times 1\$ Factorial numbers get large, fast. So, the following factorials are 'realistic' (for an arbitrary definition of realistic): 

Concept The basic concept of having a channel that you hand out to all receivers, and then close that channel as a signal, is a good one. The way you use that concept in your example usage, is a bit contrived, and I don't think it represents a real use-case, but it's good enough for an idea of how it could be used. Communication In Go, the best practice is to use "communication" over "locks". This is documented in the package as: 

This should always be safe.... but, your code throws if the list is empty. Also, why call it , it should match other standard conventions, like for removing items, and I would suggest the name , with an offset and a length, like everything else that does these things. Bug 2 The original title of the question was: "Delete N Nodes after M in a linked list" Apparently I got fixated on the after part of the title, when the actual description makes more sense and means 'from', not 'after'. The method name is still 'After', so, that, in a sense is all that's left of my Bug2: 

For chained, cascading conditions like you have, there's really nothing wrong with what you are doing (conceptually). A sequence of if-statements identifying invalid conditions, and returning false if invalid, is just fine. A good idea is to always organize the most common reason to be invalid first, so that you reject values with the least amount of effort overall. Finally, it makes little sense, other than for debugging purposes, to have temporary variables to hold state. So, for example, the following: 

There are a few improvements I can see, but not really related to performance (though it may run a bit faster anyway). If the files are small (less than 10Megabytes or so), then the relative performance of different approaches are slight (obviously, you can bork your code, but the IO part will remain about the same). So, it comes down to readability. For readability, I would recommend using the 'cool' toys in Java7. Consider the following: 

With he above, and corresponding changes to the deq methods, the code resolves itself to a simpler problem. 

Looking at just the JDOM portion, there are a couple of tricks you can play. Unfortunately, XML and streams will always be an uncomfortable mix... The following factors in JDOM make better performance possible: 

The reason it will fail is because the method trims the line terminators off of each line, so, the input to the regex will be just , etc. Since there's no whitespace after the , the match will fail, and the method will return null. You should consider an alternative approach of doing a limited split, and returning the first value: 

Learning to use, and using the debugger are fantastic ideas. It is a valuable skill that will serve you well. Understanding how your code works (and breaks) is very valuable, and the debugger helps you through there. The remainder of your specific questions are somewhat linked to your actual implementation, and I am going to suggest that your implementation would be simpler with a String split operation. The specification says: 

Performance Your concepts of 'large' and 'very large', are unconventional. I would consider 'large' to be in the > 100MiB ballpark, and very large to be > 4GiB (more than 32-bit size). This has impacted the features you consider to be performance-enhancing. All file-systems I know of use at least a 512-byte extent, with the extends merged in to at least 4KiB blocks. If you are buffering data, I would recommend at least a 4KiB buffer. I have done similar things in the past, and I now typically use a 1MiB buffer to get queued reads happening. I would thus have a buffer like: 

Note how the explicit declaration has been removed. Note also how there's now no need to call the 'accept' methods directly on the BiConsumer, and the multi-stage process on the is now very obvious. It's all a bunch clearer. You were creating lambda's, and then using them in a back-ported way by calling the 'accept' method. Now it's just plain non-lambda calls, for non-lambda methods. XPath Your xpath method: 

Generics What you have right now is fine with respect to the Generics. If you want to be a bit more correct, you can use a Class-type initializer, and use that to create correctly typed arrays, and avoud the generic casting later.... but that is a pain, and requires passing in as the constructor. 

We can count from 0 to 15 and use the bits in each value to mask out the letters and replace them with the asterisks. In code, this would look like: 

But, this is hard work, and, to match the DB performance, you will need a decent machine (lots of memory), and be willing to process the data in parallel, etc. You suggested this before, using Java. The basic algorithm I would use in Java (Java7) is as follows: 

This code of yours is not working, despite your assurances that it is. It replaces just the first occurrence of 'ins', and that should be obvious since you call the method. The example sentence you use in the code is not the same as the sentence in your description. The one in the description will fail your code: 

This has a much better performance characteristic than checking every combination. You can also add some tricks / optimizations to the loops to quit when impossible combinations present themselves, like: 

scan the matrix cell-by-cell if you encounter a 1, use recursion to follow all it's adjacent 1 values mark all visited cells as 'seen' consider that process a 'hit' for an island scan the remaining unseen cells for the next unseen island. (go to 1). 

SQLite is notorious for doing calculations based on the wrong affinity of the data values. I immediately suspected that the SQL was doing integer division on the values even though you are casting them to decimal. I put some examples together as an SQLFiddle here, and I cast the values to float instead, then used the SQLite function to get things decent. Doing floating-point division is what solves the zero-value division before. This is the SQL I ended up with: 

"Rewrite my code" is not what code review is about. We review the code you have, and, occasionally, if it helps, we show what we are talking about by writing additional code too. Demands to "Rewrite my code" are not ... polite? Still