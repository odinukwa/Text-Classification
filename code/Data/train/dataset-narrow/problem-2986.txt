The second phase is actually getting feedback on the code you wrote. This can be tricky to do as a self-learner, since you have no direct way of getting feedback, but there are a few things you can try. One resource to try is CodeReview.SE, though it's probably best to submit relatively small programs for review. Another idea is to contribute to an open-source project. The more popular projects tend to be relatively picky about following best practices and idioms and will code review your submissions before accepting them. As before, start small: try and find a small and easy bug in their issue tracker, and start with that. It can also be valuable to try googling "open source for beginners" -- that reveals plenty of resources and websites that attempt to connect projects looking for help with beginners. 

The Map abstract data type (ADT): in particular, understanding the difference between the ADT and this particular implementation. The key: understand what it means for a key to be hashable (both in general and within Java). The hashmap internals: understanding what we do with hashed keys, resizing strategies, etc. The chain: Understand that the chain can again be abstracted (we can use any map other then a hashmap for the chain). 

High level: Just like any language that exists in the world today, it has it's own alphabet, syntax and grammar that is for communication. Technical: First off I just want to note that some languages are interpreted while some are compiled, as for their differences I believe it's off-topic. The idea is that your "code" is tokenized based on the language's alphabet and syntax and formatted into a parsing tree. The parsing tree is then translated into some intermediate code. Lastly the compiler translates the intermediate code into source code or machine code that can be executed by the CPU. 

Since programming languages are made for humans to easily learn and write in, it is like writing a book. We choose alphabets of the language and write meaningful segments that perform tasks whether it is to loop over an array or read some files. 

That depends entirely on the context of your CS1 course. Are you teaching unit testing suite to your students? If you haven't learned something then how can you use it? If unittest is part of the curriculum, then definitely students should use it. At my University, students are formally introduced to the suite during 2nd year, and thus for all their Java projects they are required to have their own testing suite. As for their C projects, we do not require unittesting because is already enough hair pulling. So to answer your question, no we are not using unit testing in CS1 because it has not been formally taught yet. 

The idea of the game is: you have a group of pictures of persons with different facial features. One gamer selects one of them and the other gamer has to make questions to try to eliminate the ones that are not relevant and try to guess which one the other gamer has chosen. It is kind of like what you do in the WHERE part of the SELECT... 

Since you mentioned that ideally you were looking for a video, a few years ago I used to show a video to my students: The Good Warriors of the Net - IP for Peace . It is a bit old, but the main concepts are there. Another that I used to show my students was: How the Internet Works in 5 Minutes Grab the popcorns! :) 

For research reasons, in the last few days, I’ve been looking at several statistics on computer science programs in Portugal (but also in Europe and the US). One of the most interesting findings is that approx. 20% of the students will drop the program at the end of the first year. But the most problematic finding is that after four years, only approx 22%-32% of the students were able to graduate in a 3-year program. It is important to stress that in Portugal the admission to higher education is determined only by the grades that the students obtained in High School (50%) and the results of the exams in some particular subjects (Math and Physics) for CS programs, for instance (50%). In the end, only the n students with higher scores will be admitted. Given the demand for IT personnel and the high unemployment rates of several other areas, several students will end up attempting CS. I am aware, that some companies rely on the Berger Aptitude for Programming Test to select their candidates. From what I understood, this test is used mostly to evaluate the candidate’s ability to program and could not be used to select candidates for the CS programs. Given this context, shouldn’t the students be performing some aptitude test before enrolling in these programs? Is anyone aware of the usage of such tests? Obviously, I understand that one shouldn’t simply say to someone: “Hey choose something else!”. However, we are talking about several hundreds of students that are basically losing one or more years of their lives. Although this happens in Portugal, I guess the same thing occurs in other countries. Shouldn’t we be doing something about it? I am aware of some other questions concerning programming aptitude. However, I think mine is different. 

In SCRUM, during the end of each sprint, there is a Sprint Retrospective and Spring Review. Important artifacts from the two should be extracted into this report, as it reflects the "developed work". I'm not sure the scope of what you require from your students for documenting the work, is it for the whole internship, or just one cycle? In any case, because Agile is done incrementally, they can just write one template per sprint they've completed. 

I've found a lot of success giving real world (often times very silly) examples of boolean algebra to give them a more intuitive understanding in addition to the pure algebraic laws. An example would be "If it rains tomorrow, I will bring an umbrella so I will stay dry". This is a simple A -> B: If it rains tomorrow then I will bring an umbrella, I will stay dry (T -> T = T) If it rains tomorrow then I will not bring an umbrella, I will not stay dry (T -> F = F) If it does not rain tomorrow then I will bring an umbrella, I will stay dry (F -> T = T) If it does not rain tomorrow then I will not bring an umbrella, I will stay dry (F -> F = T) Using DeMorgan's we know A -> B = !A V B. We can say A = it will rain tomorrow, B = bringing an umbrella and whether you stay dry or not is the equivalent of the resulting truth table value. You can incorporate students in coming up with these silly examples, and having them figure out how the narrative would look like to reflect the truth table values. In addition, pairs can come up with scenarios and test each other's knowledge. (This was during 2nd year University too! So it's never too old to get silly) Lastly as a remark, I did not see you mention some Laws of Boolean Algebra such as Associative, Commutative, Idempotent, Identity, and Distributive. I think it's worth while to introduce these laws during lesson 1 or 2 because solving boolean algebra down the road is built off of these fundamentals. 

I think there are two phases here: the first is just being aware of what the correct idioms and best practices are, and second is attempting to apply what you learned and getting feedback. For the first phase, you can get a lot of mileage by doing research and casting a wide net. In particular, I personally find the following Google queries to be pretty useful at giving me an overview of the best practices and general "feel" of a language: 

During your very first labs section of the year/semester/whatever, set the tone by explicitly telling students lab periods are times for them to ask questions and have (brief?) one-on-one interactions with you in addition to working on their labs. This probably will help only in a limited sense, but your students may be more willing to ask questions if you straight-up tell them that questions are not only encouraged, but expected. Shift to doing more group-work. If everybody is working individually, being the only person to speak up and hold a conversation feels awkward. If there's some ambient background chatter, asking a question will feel less "awkward"/more "private", which might encourage your students who are shy or embarrassed to speak up. Make your labs harder. The idea is that now everybody is going to struggle and therefore ask questions. And if your more confident/talented students are asking questions, the students who are falling behind might feel encouraged to do the same. This pairs well with the previous suggestion: if your students are now working in groups, they should theoretically be capable of working through more material. You should probably do this by making the problems trickier and twisty, not by adding more work. If you do the above, and notice that everybody's struggling with the same problem, consider interrupting and going over some core points as a class/working through the problem together. This gives you more opportunities to engage with your students, albeit as a group, not one-on-one. Switch your question from "do you need any help?" to something more like "any questions?". (See @nocomprende's answer for reasoning). 

I've always admired the Swiss' education system of teaching kids where they rarely have examinations, but rather through constructive assignments and homeworks to teach students. At a conference I've attended, I heard a quick introduction on gamification of education and I am trying this out with some students. Here is what I proposed: Assesments (excluding exams and final project, due to curriculum and school board constraints) have unlimited re-tests, limited to once a week. 0.5 credit is awarded for 50%+ and 1.0 credit is awarded for 80%+ At the end of the term, their number of credit earned is divded by total number of credits for a "term work" grade worth x% of their final mark The goal here is for students to not worry about a 50, 60, 70, 80, 90 or 100, but rather track their progress through completion of content. I believe the unlimited retries gives incentive for students who are falling behind to realize early and catch up immediately, rather than later. This is to avoid the mentality of giving up because it is "too late" or "wait for next test". To some degree, I believe in the innate competitive nature of CS students transferred from love for gaming I believe this method (with modification to suit your needs) meets what you are looking for. Accurate enough to give a % mark because you track progression. Although I foresee multiple 100% with this method Does not disturb students because they are well aware of their progress, and know they can make improvements rather than blankly stare at an unfortunate poor test 1 Quick and low effort - I just use an excel macro and export to show my class after each week their progress 

Something I wasn't sure about when I was reading your post was if the problem is whether the issue is if students lack motivation or if they lack the ability to succeed in your course. If 30% of your students are consistently failing your course, then I genuinely do have to wonder if the latter is the case. If so, I'm not sure this is a problem you can easily fix within just within the context of your course. For example, I'm assuming the students are expected to complete a few pre-reqs before they can take your course. Why aren't those pre-reqs adequately preparing your students? Etc. If the students are genuinely under-prepared and have "given up" and are just going through the motions so they can graduate, then the best fix is probably to try and systematically repair your entire department. Perhaps that might mean finding more ways to add in support (especially in the intro courses), making sure students know where to find support, raising the bar on core classes... It could also be the case that the pre-reqs listed for your course aren't actually enough, and that you need to add another pre-req class or two to make sure your students are prepared. 

I can tell you are very intelligent as this is something only someone who truly understands algorithms and proof of correctness can say. It is actually very difficult for younger students to see this as they are tunnel-visioned by the actual loops in the code instead of the bigger picture. Instead, I think what you are trying to convey is to look for "what part of the code is doing what the algorithm is meant to do" 

A set of instructions written in human readable language (at least to developers) that is executed to perform a task or goal. 

Let's start with the term "Loop Invariance". It is a property of a loop that is true before and after each iteration, thus in-variant, non-changing. So then, what is the purpose of the loop invariance in proving algorithm correctness? That is, it is a predicate about what the loop is supposed to do. Thus with proof by induction on this predicate shows the correctness of this algorithm. I know this is still very theory heavy so let's break this down even more. A simple insertion sort. The purpose of insertion sort is to sort an array. Therefore the loop invariance would be that after each i-th iteration, the array is sorted up to the i-th element. The magic here is that instead of looking at the nested for i, j, loops of the algorithm you are choosing the loop invariance that contributes to the goal of the algorithm. To answer (1). There is no sure guarenteed way to choose the correct loop invariance unless you are very experienced in algorithm correctness through countless examples. The best approach is to choose the segment of code that is actually doing what the algorithm is trying to do. Such as the example above, sorted up to the i-th element. (2). I believe this has to do with the proof itself, rather than understanding the loop invariance. Structurally, to prove that the algorithm is correct, you would have to use proof by induction (either simple, or complete) to pove the loop-invariance and the fact that the algorithm actually terminates. Usually proof of termination is a 1 liner, such as when i > array.length, loop will terminate. 

As probably we all experience, plagiarism is very common in CS. I know that there are several types of plagiarism ranging from simply submitting a copy of the colleagues’ code to other highly sophisticated mechanisms. In my experience, the most common is indeed the simplest one. The student just grabs the code from another colleague and eventually change the names of the variable, and submits the solution (some students don’t even do that!). While there are several systems that are easily capable of detecting this type of plagiarism, they do it mainly when the student submits the final version of the code. Some other tools, are capable of detect plagiarism and notify the student about that (as if they didn’t already know that!). In most cases the use of an anti-plagiarism tool will act mainly to support punitive measures. Although it is not the main focus, as part of my PhD work, I am working in a tool that analyses the source code as it is being written and is able to detect plagiarism in “real-time”. This way, the teacher can be notified about students that are performing plagiarism even before their final solution is submitted, giving the teacher time to act and avoid the punitive measures. My biggest question is: What should the teacher do with that information? Will this be efficient? 

These ones you can probably skip -- these sorts of situations don't really come up (unless you're doing something like push-to-deploy). 

Implement a very basic programming language. Write the parser for them, but have them manipulate the AST (eval expressions, perform constant folding, etc). (So hey, trees are a thing...) And of course, all programming languages have variables. How do we store variables? Hey, wouldn't having dictionaries be useful...? Use dictionaries to implement a "sparse vector" class. Use the sparse vector class to implement TF-IDF and cosine similarity. Then, use TF-IDF/cosine similarity to implement a search engine. If the students are unfamiliar with linear algebra, you can skip the "sparse vector" bit and have them implement TF-IDF directly. Bonus! Have the students also implement page rank, which ties in to graphs. (Want to integrate even more concepts? Have them write their own sorting algorithms to sort the final results. Go even further? Rather then using a sorting algorithm, have them implement top-k-sort on top of a heap so they efficiently select just the top k results in worst-case O(nlog(k)) time.) Have them implement literally anything related to graphs. After all, you can pretty much always get away with implementing an adjacency list as just a dictionary of keys to some collection (a list or a set). This means that any problem where you manipulate an adjacency list can also be a dictionary assignment in disguise. And there's a huge wealth of interesting graph problems out there -- have them implement pathfinding on a map of your local city using Dijkstra's, have them generate interesting and randomized mazes by adapting some MST algorithm, have them analyze a DAG, etc... If you also want to integrate a bit of systems, you could maybe have the students implement a simplified version of Git. After all, git is just a DAG and all graph problems can be turned into dictionary problems. (It's also an interesting application of hashing!) You'll probably need to give them code to do file IO for them, and maybe handwave or simplify the whole merge business, depending on how complicated it ends up being. (Or maybe not? I don't know much about the merge algorithms git uses, but it's entirely possible they could end up being interesting applications of dictionaries in their own right.) A simpler assignment (more for CS 2 students): have the students read in simplified grammars in BNF format. Then, recursively (and randomly) traverse that grammar and generate some output. Have the students invent their own grammar -- there's room for creativity here. You could generate randomized poetry, randomized programs, etc... Have the students do something with n-grams and Markov chains. As before, this is really just a graphs assignment in disguise -- each node is an n-gram; you store a weighted edge from one n-gram to the next. If you want to stick with the whole "secretly a graphs" thing but keep the math part light, have the students use Markov chains to generate text. You can have a lot of fun with this -- feed in Shakespeare to generate vaguely Shakespeare-ish text, feed in your Facebook data to generate text that sounds like you... You can also experiment with doing this on a character level and try feeding in corpuses from different languages. As it turns out, auto-generated English is pretty distinct from auto-generated French. The algorithm to do this ends up being pretty similar to how you do the BNF thing since it's just randomized graph traversal. If you wanted to make a point about the importance of abstracting and refactoring code/adapting to sudden changes in the project spec, you could perhaps tie it in here (though tbh it feels a little contrived/might be more trouble then it's worth though). Alternatively, if you want to avoid graphs but don't mind bringing in some stats, have them do basic basic classification instead, and give them a taste of machine learning. (E.g. can you classify spam emails vs non-spam emails? Can you classify which human language some text likely came from based on letter frequencies, character n-grams, and so forth?). My memory is a little hazy here, but I think you don't really need a graph (explicit or implicit) and just need a way of storing a discrete probability distribution. (And a dictionary is great way of doing that -- map n-grams to the probability that n-gram occurs.)