OpenGL is needed on Mobile phones, OSX and every console other than the X-Box (well the other console use their own thing thats a stripped down OpenGL similar to OpenGL ES since ES 2.0 wasn't out back then). So you will definitely need it in the games industry. You will probably also need DirectX. Having said that I think most game devs now program using premade off the shelf engines and don't worry about the graphics API (other than possibly things like shaders). I don't know much DirectX (being a Linux user myself) but I can't see learning 1 really causing you problems learning the other. They should bother share similar underlying concepts. The main thing would be the coordinate system. For an indie game developer it can depend. Indie games are niche products. Having support for other platforms such as OSX can give you a large number of extra sales as the number of game available on the platform is fairly limited and there more likely wanting to boost support for their platforms. You can also throw in Linux support for little extra and get some good PR (the main hassle is building for a whole bunch of different targets). Mobile phones are also something to look at as they all use OpenGL ES. Porting to WebGL is also another possibility with things like Google's Nativeclient and emscripten (Compiles code to JavaScript) or just redoing it in JavaScript (or even using JavaScript across the board the desktop, web and mobile). 

It is absolutly possible. Here's a simple class that, when called, will save a screenshot of the main graphical context: 

Tip - Always use the true position of your object You were assigning an intermediary variable that stocked the position of your player. The problem with this is the following: if you move your player, the checkVec variable will not be updated, so the next collision check will most likely fail. Always use the true position of the player, or at least update the checkVec when you move it. Warning - Don't use += in tests! When you use += in your ifs, it WILL modify the value! Use only + instead! This is probably the reason why your collisions won't work. EDIT: Fixed-step vs variable-time As Shiro pointed out in the comments, this method is not 100% applicable in the case the user modifies the default tiem step method for the variable time step. In this case, we should take into account the time elapsed between two Update(). More details in the link Shiro provided in the comments, and on this site. 

The short answer is it depends, or use a bit of both. Now days I don't think you even really do textures on objects, instead you do 'materials' or 'effects' on objects. A material can have multiple textures (1 or more basic image textures possibly with transparency, another for normals/bump mapping, another for specular reflections (The shiny part of metal will reflect light more than the scratched dirty bits) another texture for parts that should 'glow'. Another for ambient light (although that will often be the glow texture). They will have inputs (so you can swap between multiple different textures for the 1 material, modify the colour (maybe depending on the team the model is on), change animation speeds. You're likely to use bother depending on what kind of object you are dealing with. And you can also do hybrids between 1 texture over the whole object and individual textures and so on. If you are talking about limited hardware (mobile/web). Or a game with simpler graphics (although in that case optimizing is less important then anyway), I think it really depends. Firstly, how close are you going to get to the object. Something like a house will need multiple textures if you are going to be walking up close to the walls, standing on the ceiling etc... but if it's a top down game where the house never gets closer than a specific distance then it's fine to use 1 texture. Maybe you use both methods depending on which LOD model is loaded. It will depend on the kinds of objects you are going to be using. Some more 'organic' things can only really be done with 1 big texture (think of a tree trunk). Of course something like a face will It will also depend on how many objects you are going to be seeing on the screen at once. If you have a RTS with armies of people vs a smaller number. For the point of view of which is easiest to implement programmer wise, there about the same. In fact if you implement the multiple texture system, that will implement the single texture option. It should also be possible for you to use multiple different materials/textures on one continuous mesh via extra vertex attributes. One of those can be a texture id. This is much easier on modern OpenGL where you can share uniform variables between shaders (I don't know about DirectX but I assume it's possible there too). Of course if you have different properties for your shaders then this will be harder. It also takes more memory. And you have to make the meshes have that metadata (although that can be done automatically). It's also about the content creation pipeline rather than the programming side of things. Are you (or your artist) happier making a model, unwrapping the mesh then paining on it. This will mean each model is individually textured and unique, kind of hand crafted. A Blizzard game might do something like this, it allows fast creation of simple content, that's low performance, just knock together single mesh models then paint on them with a tablet. They use a simple cartoonish painting style. Or are you likely to share textures between various models. A game that uses tiles might want the stone brick texture on 90% of them but mix in a few extra bits on most of them. And unwrapping tile objects is going to be harder in may ways due to the geometry. 

No, your way of doing it is exactly how AABB collisions work, being the most basic rectangle to rectangle collision: $URL$ You basically check if any of the sides of a given rectangle are too far from those of a second one. 

"that slowly keeps ticking downwards" - this is your bottleneck. When doing a game engine with a standard update and render loop, you have to be careful that the update does not take too much performance, or else you will enter in a bottleneck. From what I can understand, your update loop looks a bit like this one: 

You load the texture into the graphics card's memory. You bind the texture to the current texture unit with glBind / using SpriteBatch.Begin(). You render a quad on the back buffer and the graphics card fills the quad's pixels with the texture in the texture unit. When all rendering is done, you swap the back and front buffer. This is done automatically in most high level engines, but you still need to do it in SDL and XNA (Using GraphicsDevice.Present()). 

Raw pointers should be avoided when possible. I'm not sure exactly what you mean by 'makes a copy'. Containers themselves can't store raw references. Possibly you are making a function accepting a ref but then putting them into a container with a non-ref. In C++11 (which I recommend using unless you have compiler restraints) you can also store references in a container with a std::ref or std::cref. You will need to make sure your compiler is compiling in C++11 mode. 

It's a good idea to make a very minimal login server that runs on a separate server from your other components. Since this is where all the security is if your main game server/website is hacked in your login database won't be compromised. Make sure you log everything. If you don't want your own host, you can look at Google App Engine and similar solutions. It's even free for small usage cases. It might be worth looking at how XMPP handles authentication. Of course the whole standard is somewhat over engineered for a whole game. But it does do chat as well. XMPP itself could serve as a authentication system but it would be kind of a hacky use of it. I'm not sure if Google would allow that kind of use with GTalk since they probably don't like 3rd party programs asking for password. You could operate your own XMPP server and get chat, authentication and encryption, but you would need a XMPP client built into your game. OAuth isn't too bad, it only would require the user to use the webinterface one time to authorize the program to be linked and it works with Google/Facebook and probably quite a few others and it does mean you no longer have to bother with running your own server. BrowserID is another new alternative. But it's also a browser based system.