When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

I am essentially listing things from that article It seems like something that was written years ago, but I assume, it should be a good starting point for you. Further, the city I live in does have a national institute on speech and hearing, which includes folks who are sight challenged. If this is something serious, I can drive up there and talk to someone and hook you up with a professor or something. 

I have already looked at this and this, but it does not help me at all. I am teaching a guy who is something of a Java expert. Unfortunately, due to the mandatory-ness of the university curriculum, he is forced to downgrade himself to learning C. ( I use the word downgrade in a strictly technical sense, no offence meant to people who are fans of C ). The thing is, I am able to get him through the whole C syllabus except for pointers. More importantly, we want to use pointers inside structs, which are actually declared in a header file. I am teaching him to build sharable c libraries/header files. If you need more details, let me know in the comments, and I can share the code I am using in a repo and so on. Update 1 - I am also looking at this, but its not very clear to me. I haven't used C in a decade, so all this is a little blurry for me. Update 2 - getting even more specific, what is really happening in these two lines, that I am putting in the header file. I am defining the samplestruct in the corresponding .c file. 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely. 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

To sum up, the curriculum given by you sounds quite good to me. Except for the adjustments proposed above, I don't see much that needs to be changed. 

First up, the logistics. I had a detailed discussion with the HOD and also with the students, and convinced all of them to come for additional classes (I called them Bootcamps) The Bootcamp was a 2 day affair ( 6 hours each ) and was held on a holiday. No attendance or anything like that. Students who are serious can come (and 80 % of the class showed up) Taught the basics of OOPS. I essentially summarised the entire semester worth of contents into 12 hours. 

About a month ago (before they took off for their vacation) some of my technology club members asked me if I could conduct some workshops on cloud. Being a lifelong Microsoft man, and something of an Azure expert, I told them that I could conduct series of short workshops (2 to 5 hours) for them and their friends. Now, they are back from their semester break, and I have to begin in 2 weeks. This will appeal to a number of students as the cloud works with dot net, droid, web and iOS. I am expecting a decent audience (the workshop are has a capacity of 8, and I think it will fill up). These are folks who have never seen any cloud dashboard, AWS or Google or Azure. Further, these are folks who are interested, but have probably never even built a simple app and connected to a database. We are looking at a blank slate folks. Curious but currently without knowledge. So, here is what I am planning. 

I was used to mathematics, and a calculator which used fixed point arithmetic - an environment in which the answers were always "right" (to a given number of decimal places)! The way most programming languages handled decimal numbers felt broken and almost certainly useless for storing monetary values or for use in scientific code. I didn't appreciate the trade-off being made in terms of speed and space by taking the approach IEEE 754 did until much later on when I looked at the specification in detail and the analogy with standard scientific form was brought up. At what stage should students be introduced to how floating point numbers are stored, and (more importantly) how can the motivations for this approach be properly conveyed? 

Computer Science lends itself to a variety of different assessment methods - from the more practical assignment based programming problems, to the more formal final exams that cover the theoretical content. More formative assessments give students and educators the ability to improve learning and teaching whilst it is ongoing, but there is usually some concept of a "high-stakes" summative exam in most courses. I'm sure we can all agree that portions of one module (e.g. on data structures) will be exceptionally useful in later modules, and so it makes sense to do as much as possible to help students master these concepts. Often (from my own experience as a student), the "feedback" from the summative exam is a simple number or grade, which isn't broken down by assessment component. Further, there is usually no way to see the exam script or any form of mark scheme or question breakdown, which makes it difficult to improve in the general context of the university degree. The summative exam does nothing other than provide a coarse measure of the candidate's performance during the exam. Is this sort of status quo widespread throughout undergraduate level CS, and what can be done to give students the opportunity to learn from and reflect on these sort of assessments? Should a more formative approach be taken for the majority of each module? 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

1 After reading through your question another time, I guess I've misunderstood the question and you only asked for a solution for the first item in my list. I think I will nevertheless share my thoughts on both - maybe they can be helpful for you or any future visitor. 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

I think whether and when the test cases should be released depends on a few factors. Not releasing the test cases You say that the assignments were only partially assessed by the unit tests, so in my understanding this means that there is somebody having a look at the source code. If (and only if) the assessment was fully automated and there were no human beings looking at the source code, you should not release the test cases before the assignment as otherwise it would be possible that somebody just created a program that has the required outputs for the test cases hard-coded and chooses the right one (using some kind of map or dictionary) depending on the input. If you plan to put the same (auto-graded) assignment again on students in e.g. multiple courses, you might also want to avoid releasing the test cases after the assignment - otherwise students that have completed the assignment could be able to hand the required test cases through to the students that haven't yet completed the assignment. If you however change the unit tests for an auto-graded system after releasing them (i.e. each course has it's own set of unit tests for the same task), then you could release them after the assignment. Releasing the test cases before the assignment I can imagine a situation where it's neccessary to release the test cases and to do this before the assignment: If you're doing test-driven development. In this case having all the unit tests available to everybody would be essential as otherwise the whole strategy wouldn't work. Furthermore, the test cases could help students as they are examples of the program's in- and output if they have trouble understanding the specification (as specifications can benefit from examples). I would even go further and would recommend you to release the test cases before the assignment in almost any case unless you have specific reasons against it. Releasing it after the assignment This could be an option if you want the students to figure out the algorithm without having examples (not sure when this is required, but maybe there are some sort of tasks that require that) but you want them to give a chance to review their mistakes after the assignment is done. I would always try to release them at the latest when the assignment is done. 

Then, rinse and repeat the above so many times. It took me a while (a year or so) but eventually, I was ready to work in the industry. Now, years later, I switch between working as a developer and trainer, no problem. Since we are talking about transitions, I have found that while I still make a decent amount of money from training, development actually pays more. 

I train full stack development and that includes user interfaces (which falls under if not cover the entire gamut of interaction design). When it comes to examples, I talk about the infamous case of how Microsoft screwed up Windows 8. I use Windows 8 because a lot of people are familiar with it and may have actually used it. Or at least read about it. Or at least read about the many, many jokes made at windows 8's expense. You could use Windows 8 as an example how badly even a big company like Microsoft can screw things up, and the kind of impact it is going to have on users. Then, you can follow and reveal how Microsoft learnt from their own mistakes and fixed things with Windows 8. I always use this in my UI classes, and it elicits a lot of interest, familiarity and some fun stuff.It also seems to drive the point home.