I see 2 little issues with method. First, you check for an invalid negative value but I think that a 0 value is equally invalid. So I would suggest this change: 

That takes 8 seconds by itself. Anything else I do will only add to that time. Problem 1: Randomly List 100 Primes Offhand I would create a dictionary with 100 entries. The key would hold the index number, and the value would hold the prime that is found at the index. Inside the loop you would have to see if the dictionary contains the current prime. I already know this will take a minimum of 8 seconds. Unless I do this: 

is never actually changed or used. is functionally equivalent to the loop that you wrote. This is a fairly common pattern, and there are a few ways to go about organizing it. Yours is handy because the variable communicates that this loop will continue until something is 'done'. The best place to explain to the reader how a loop is supposed to terminate is right there in the condition. One more descriptive (but also less clean) way to write that condition would be 

This is often tolerated as a static variable, since we're very unlikely to change the fact that we're reading from System.in in the middle of our calculations. On the other hand, doesn't need to be static, and since it's a resource that should be closed when we're done with it, the best practice is to make it a local variable or manage it carefully as needed. The object-oriented approach is to use a loosely-coupled function like for your input, and then let all of the calculation happen in a different function. You might also want to be consistent with your arguments in 

This can be cleaned up by making the parameter optional in the signature, and also by using when using it. Example: Definition: 

On one hand, this is proper to be a method in that it must take a wee-bit of time for . On the other hand, if was to be small enough, you may consider making it property. Note that "Count" in the beginning is a verb and "Count" on the end is a noun. Color: A verb or a noun? Speaking of nouns vs verbs, for the method, I take issue with the name since whenever I see I tend to think of a the Color structure. Perhaps or are suitable as action verbs. Granted “color” can be a verb or a noun, but again most developers may think noun. That said, I don’t see where you do anything useful with . Looking at it further, there is no need that should return a value. That would shorten up code in the (or ) method. 

This assigns the operator to and performs the comparison without the need for a statement. You can use a do-while loop to handle the first number and print "Operator: " to the console before reading , if you like. 

is a primitive type, while is a class. That distinction won't cause a logical error here, but consistency always helps when a program grows larger and more complex. Order of Operations: Your program handles each step of the calculation correctly, but it doesn't understand Order of Operations. That's a more complex concept that you'll have to look at a whole expression for instead of being able to handle each operation piece by piece. The fully object-oriented solution is to treat the expression and the individual operations as their own objects and apply logic to those objects piece by piece. You could, for instance, create a list of numbers and operations, and scan through that list, applying the highest-priority (multiplication and division in this case) operations first. The fully functional solution is to scan the expression and use recursion to decide which numbers need to into first, returning the results of each step up until the base function returns the final answer. There are many ways to do it, and you can think about how you'd like to implement it in your calculator 

Heslacher's answer had a closing remark about not using in my method. I got a basic implementation working and performance went from 5 seconds down to 0.7. Great suggestion. I then tried to add the new code to Heslacher's answer but an unnamed editor (okay, I'll name the editor: Heslacher) said I should post it as my own answer. Basic Implemention: Requires: 

Enums should be treated as enums and not numerically. @TopInFrassi touched on this too briefly when he said not to use byte. That doesn't mean you should use for the enum either. Rather just use the enum as is, particularly with well chosen phrases as it makes your code more readable or less cryptic based on magic numbers. Example 

Rather than saving the answer in a static or object-level variable, you can return it from your functions. This lets you keep more careful track of what makes changes to it. Imagine if you had a lot of different functions like that incrementally update the answer every time they execute. If you started seeing the wrong answer due to a bug in the code, it could be difficult to trace it to the broken function. To handle the object-oriented way, rename to whatever you like, change both of your functions from to type, and return the partial answer and the end answer from each of them, handling them locally. You can make a new that calls your renamed function and handle the printing of the answer in instead of the function that does the work. 

Nice effort and nice to see someone willing to be critiqued. Prefer This is a matter of taste but where type is clearly discernible from the right hand side, use . So instead of: 

For several reasons. Note I added spacing around - it's okay to let it breathe. I ditched the jumbled one-liners. And I even corrected the comment to be NESW instead of NSEW. Or you could use named constants (as I did) named North, East, South, and West to make it more understandable. 

One thing I haven't seen mentioned yet is the DateTimeKind. You may want to preserve it with your methods. Here is but one example: 

Can you use and to read in all of your numbers and operators at once, from a line like or ? matches a regular expression, and is the pattern for any single character. Error Handling: What happens if the user types in a bad operator? If someone tries to ask for , the operation is ignored in this case. Instead of getting the result of = 12, they could get a result of 21 without realizing there was a mistake. A good way to protect against that is to use a statement in your switch block. A way to handle these errors and let the program or the user know there was a mistake is by writing 

Though I would think it should be a property rather than a method. But you may also consider caching the exists state, which would alter my examples somewhat. Extending these thoughts to other methods, becomes: 

This answer would work across midnight across different dates and for DST transitions. Plus it shortens up the code. Shorter and simpler is easier to follow and maintain. 

How many points are we talking about that makes performance slow? If its a crazy amount, you could use a Range Partitioner and a Parallel.For. But I would suggest outputting as a rather than an array so that each parallel thread can merge the subset of points. I'd rather not get into details about in this answer though. One alternative is to check X or Y against the tolerance once: 

Nice solution. This code is pretty legible, which is great if you have to debug anything. There are a few simple ways you can make your program more user-friendly and resistant to user error. Input: For the user, it can be tedious to type in their values on every line, always being asked for 

Object Oriented Programming: Generally, static variables should be reserved for variables that are shared between multiple instances of a class, and any other variables should be made local or non-static. The static variables you've defined here work properly, but reorganizing the methods and changing the variables into local ones will make it easier to add functionality to this calculator later.