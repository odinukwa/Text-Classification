Part of the goal for using the Repository pattern is to separate the storage from the domain. By passing the IDataReader in to a Foo object, I feel like the domain gains too much knowledge of the underlying storage mechanism. So, between the options listed, I prefer setting the object's properties in the Repository. That being said, if the object doesn't make sense without a certain property, it should still demand it during its creation. However, even in this case, the Repository would still be responsible for setting all the properties requested. 

Regarding documentation, I have found Eclipse and other tools to utilize the following style of doc-blocks. The @return is especially useful for code-completion of methods available on the returning object in my IDE. Documentation tools tend to have built-in support for other tags like @author as well. 

Coming from a language without the ?? operator, I find this even easier to quickly read and understand the intent of however I recognize that is probably just because I'm not used to reading ??. 

Also, I would add that some very notable programmers have emphasized the rule of a single assertion per unit test. As such, give some thought to this as well. Lastly, I would recommend being a bit more descriptive than object0, filename1, etc. Try to give more meaning to the variables. It'll help immensely in 6 months when you look back at your code and sit there wondering what the purpose of this or that was. 

The organization of your code seems strange to me: should be class or instance method of the String class or maybe neither? The method lies outside of the String class bracket, yet references private hash and . My throws a runtime error while trying to execute it. Then the code doesn’t properly handle invalid (non-roman) characters, it stops recursion because for the first invalid character the mapping will fail, in this case not the result of the canversion up to that point but the array of the ’s values will be returned, which is supposedly not what you want to achieve. After putting within the class frame and adding public before it for the code to execute: 

meaning "find all groups consisting of one or more apostrophes and replace each of them a with starting apostrophe followed by the found group and an ending apostrophe". Now try to do this without a regular expression - it would require much more complicated code. All this will reduce the very act of processing the to a mere one liner if you exclude checking for null: 

to spare on the call. At the end I’d suggest reverting the keys and values of the mapping hash (because you start from roman characters), using symbols instead of strings as keys and replacing recursion with a loop: like this: 

Modify Caching Strategy It seems every image that is subject to caching is ending up both in memory and on disk. Depending on the number of images and caching aggressiveness, this could be more expensive (in terms of resource usage) than the network request used to retrieve the image. From my perspective, using both and the Cache directory together doesn’t add any value. They are both volatile and unpredictable (to different extents). The system could reclaim space from either when it deems it necessary. From Apples File System Programming Guide: 

You are also tightly coupled to the . What happens if you want to replace Parse in the future? You will likely have to throw away the implementation and create something new. Protocols Your protocol provides an abstraction for what the concept of chat means to your application. It conveys this concept without dictating its implementation. It doesn't give you working implementation, but it does score you a point for the future maintenance of your app. It gives you flexibility. With now a defined concept, other types can adopt it, filling in the details of what means to the conforming type (in this case ). Combining this with delegation (as you have), puts you on the path to a decoupled, flexible type that doesn't expose the public interface of and doesn't require your consumer to know implementation details about how Parse is being used to facilitate "chatting". "Less code is better" You don't say why this is or how you prioritize this design principle against things like readability. Is it better because its less to maintain? Less to look at? Personally I would add a couple of caveats to this statement: 

Now this means "find all groups of single or double apostrophes and replace each of them a with starting apostrophe followed by the found group and an ending apostrophe". This works only for single or double apostrophes - so does probably the right thing for your use case. To enclose any number of input apostrophes in a pair of the same, you'd use: 

I admit it is longer, but behaves better raising error on erroneous input and is faster – on my machine benchmarked against your code was regularely almost 3 times faster. UPDATE @200_success Thanks for asking - besides the performance gain there are two more reasons for using symbols instead of strings as keys. Never use mutable objects as keys in hash tables This is reason enough - mutable objects as keys are evil, if they change unpredictable things can happen, since values are placed in buckets of a hash table based on hashcode of the keys, now you can imagine that changing the keys of pair after it has been placed into a hash map is never a good idea. And strings in Ruby are mutable! I admit though, that this will rather not happen in our case, yet it would be a bad practice anyway and should be avoided just to keep the code clean. And it seems that in fact Ruby copies and freezes the strings if used as keys in hash maps in case we forget about this rule :-). Nevertheless we have our performance gain by using symbols. roman_mapping is in fact an immutable constant Neither keys nor values would ever change. So it is logical to use an immutable class for the keys - like symbols. Now numbers are immutable, too, but the hash maps are not. So while we are talking this, we should make also immutable using , and while doing this we can also replace the method with a frozen constant. To make immutable all these steps are necessary - simple freezing the hash map wouldn't be enough. If a reference to its keys leaks into the outside word it still could be changed. I've just updated the code above. A new benchmark on my machine shows now even more performance gain: the new code is more than 10 times faster than the original: 

For example, could this variable be renamed to make it self-descriptive? Perhaps . Perhaps something else that would eliminate the need for the comment. One File Per Class Generally speaking, you want one file per class. I also believe it is common practice for C/C++ programs to have one file for the header and one for the code for that header. Maybe something like and , as well as your . Scope Why are your Tpacket_list variables protected? Is there a reason they aren't private? Also, list_head is declared in main, then freely accessed as a global variable within the Tpacket_list class. Rather than do this, it is considered better practice to use Dependency Injection. Pass this variable in to the class that requires access to it. It will make your code far easier to maintain later. It will also open up the possibility of unit testing your class. Random Thoughts 

First off, as a disclaimer, I don't code in C/C++, so I may critique some common practices that are considered acceptable as it's the norm. Nevertheless, a few things stand out. Comments Comments should be used to describe why something is being done. The code itself should be self-descriptive as to what it is doing. 

Why would I ever choose the Protocol + Delegate method (design 2), at least in this case? In this case... Ultimately it comes down to you design goals and the expected lifetime of your app (how long will you or someone else have to support it?). In my opinion, based on what you described, using protocols provides a more flexible design that is better prepared to handle changes down the road. 

Someone consuming your class will get the entire public interface of . This is a lot of mental baggage that doesn't seem to be related to using class. and the concept of chat don't seem to be related at all. I would think of family of chat objects as: 

What is a large number? How much is too many? You will have to test and measure. Test & Measure (and then measure again) I would definitely recommend testing and measuring your caching strategy to see how much of an impact it has. Xcode instruments provides tools to accomplish this. One way to go about this is: 

Test with no cache (this will be your baseline) Test with a simple caching strategy (maybe just using or the Cache directory) Compare the results of step 2 to your baseline obtained from step 1 Not satisfied, then apply a different caching strategy. Repeat step 3. Otherwise, if you are satisfied with the resource usage and responsiveness of the app then you can stop here until there are significant changes to either your codebase, data or the iOS frameworks. 

I assume you get the arguments as a array - given the above you should first transform it into a - the most efficient would be an , but I would suggest using a which will preserve the order of the arguments. This will also validate the input and only accept valid arguments, thus preventing the program to crash because of an invalid input. Now what you actually do to the is basically enclosing a single or double apostrophe within a pair of apostrophes. There is a way to do it without iterating over the string variable character by character - use a regular expression, all you need is: 

Next you have a hash map but do not use it as such, just iterating over values. Even then you could use: 

The code above is less efficient performance-wise since it does more - yet it is safer and much more readable (and IMO elegant :-)). Simplicity and readability reduces errors and thus testing and maintenance costs. If you refactor processing of the input parameters (validation, conversion into a map) and creating the String array out of the method it gets very short, very straightforward and more efficient. Since the input validation should be done anyway its cost shouldn't actually be taken into account. Now the command line processing is pretty ad-hoc, there are better ways to do it - for example using . 

Therefore its either a choice between caching in memory and caching on disk or an emphasis of one over the other. This inevitably leads to additional questions about how your app will be used and the what kind of images you are working with. Some basic guidelines: 

The Details Let me expand on my answer by first saying that Inheritance vs. Composition type discussions are subjective and are debated amongst developers of various languages. There are many blogs, articles and posts on StackExchange sites that cover the debate. Also, since we are talking Swift, I would highly recommend taking a look at this WWDC session: Protocol-Oriented Programming in Swift $URL$ I highlight this session because instead of Inheritance vs. Composition, we should be discussing Inheritance vs. Protocols. Why? Because not only do protocols allow you to do composition, they also provide other features that let you model things in interesting and flexible ways. I would also like to point out that this question is challenging to answer (though I think it is a good question), because you have two seemingly working implementations in the present, but your design choices may not reveal their true cost until some unknown time in the future. This is where the advice based on the experiences of others will inevitably reveal itself but at the same time seem subjective if you cannot relate to their experiences. Inheritance Is really a ? According to Parse documentation: