Rather than this, consider - it'll save you the indexing. Check out this question: Converting 'ArrayList to 'String[]' in Java 

The contents of the outer loop - i.e. the inner loop and the check - could be broken out into a separate function, , which could instead of . I.e. in the loop, and if you finish the loop without returning, . 

See the above note - we probably don't want to force the user to deposit money before every withdrawal. 

You definitely don't want to loop from 0 to , when is changing. This loop doesn't really capture your stopping condition, which is . How about: and in the loop you add the number to your Array(List), without needing to use the break condition. 

Why is slower than ? Is there any way to optimize the regex in so the performance is comparable to the first two? Is there any other way to speed up this code? 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

Note that this code is optimized for arrays with at least 1 element; if the majority of its uses are on 0-length arrays, you'd see a performance boost if you added a short return. Alternatively you can use Array.prototype.reduce. I highly recommend that you not use this method - while it is more "unique", it is also much harder to understand and much less efficient. And good code strives to be readable and efficient (and robust), not unique. 

My biggest suggestions for improvement are: always submit the cleanest code possible, try to follow broad, important, rules for how the language should look, so it looks clean to the reviewer, and work on writing short, helpful comments around tricky or interesting spots in the code. 

This method is a little busy - it would be nice if the functionality to get input from the user was somewhere else (in a separate function), especially because you need to use it for multiple commands. Also, it really seems like (, if we use Camel Case ;p) should be an object variable. 

I encourage you to consider writing unit tests (I recommend ). It'll make your tests easier to write and read. The above tests are ok, but I would definitely add tests to check that you get when you expect to. Overall: Your code is overall quite clean and easy to follow. It's not quite production-level, but it is good for a Java course. Nice job! Regarding returning : There is a large discussion around this issue. I think most people believe something along these lines: 1.) should not be used in place of an error. This is because in general, methods should enforce their contracts loudly, i.e. if a method's job is to take a number greater than zero and return it times two, and it gets a number less than zero, it should complain. By returning , you force programmers who use your code (if they're responsible) to write in code to handle the possible null case, because otherwise there's no guarantee that they will be aware of the error that made your method return . And 2.) can be used as "no results", but it might be better to return an or an empty data structure instead. For more, check out this question Is it better to return NULL or empty values from functions/methods where the return value is not present? For a class assignment, though, it may well be the case that using is "ok" because its fast - and it doesn't require you to shift focus from whatever the point of this assignment is to spend time writing exception throwing code. Avoiding using as an error, and instead throwing an exception, is a best practice, though, and as you grow as a programmer you may want to do so even if it's not required. Be careful though - if your code is auto-graded and it is expected that it will return for a given input, an exception will probably cause it to be marked wrong. In this case I suggest writing code to your assignment's specification, and being content with knowing that were you writing code in the "real world", you'd do it differently 

is, actually, the worst variable name there is. It is impossible to create a less specific name. I would suggest renaming it. 

I am writing a script to count the number of rows in a textarea, and as it will be called on every keypress I want to make sure it runs as fast as possible. I'm not aiming for a general solution: we can assume that the textarea has a monospace font and enough horizontal space for exactly 80 characters. I've probably solved this problem in 20 different ways, and this is by far the fastest solution I've come up with: 

Here's a second solution, which is slightly faster in Firefox, but otherwise between a little and 5x slower: 

In general, you shouldn't leave auto-generated s in submitted code. For an interview, I would be fine with leaving s explaining functionality I wish I could implement but didn't have time for. 

Style: classes should usually be nouns - e.g. Account or maybe AccountCreator, because you use them as Objects - so it makes more sense to have "an Account" than "a CreateAccount" 

I don't understand this comment - is it justification for calling ? If so, it's not quite right. You could add a counter variable that gets incremented in your clause above. That doesn't mean that you necessarily should, though - see below 

While the above solution works, it is somewhat inefficient and messy. This stems from the fact that you're trying to get javascript to work the way you want, when what you should be doing is trying to understand how javascript wants to work. Each language has a style, even a personality, and if you're flexible enough to go with it then your code will be shorter, faster, and cleaner. Here's how I would abstract away my JSONification. 

The switch statement might be more legibly written as a series of if else-if statements (with nesting), but that's mostly a stylistic choice. 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

Using an array and incrementing the size is a little ugly, and it's inefficient. Consider using an ArrayList, which allows for index-based insertion in constant time, and hides all of the size changes (as well as doing them more efficiently). 

For the parameter, may I suggest ? Alternatively, anything that communicates what exactly it means should be alright, given that it's at a pretty contained location - even wouldn't be terrible, especially since and are also parameters. The method is harder, mainly because the thing you're calculating doesn't have a great name. "Return the nth occurrence of a weekday in a given month of a given year" doesn't lend itself to brevity. I would take one of two routes: Does the assignment / class / professor have a term for this functionality? "Weekday oracle" or something equally obscure works perfectly if it's the way that everyone else who will see this code knows to refer to this thing. If not, I would name it what it is; something like - this would pair well with naming that first parameter . In this case, I think information (what exactly can I expect this to do) trumps brevity, because what it does is not very common / intuitive. 

The performance doesn't make any sense to me - does the same thing as , except it doesn't create any unnecessary strings or arrays. Is with a start position just really slow, or is there some optimization only the first method is picking up on? Finally, here's one more method, which is much slower in every browser I've tested, but beautifully concise: 

ps: I can't just do something like , because I need it to shrink as text is deleted. Also, I don't want to remember the previous count and just calculate the difference, because some changes will inevitably be missed and a differential script will never right itself. 

Overall: aside from the "first item in array is 0" which is either a mistake or a misunderstanding on my part, your code is clean and well-organized. I urge you to 1.) try to use less often, and rely instead on iterator-based loops and -based loops as much as possible, and 2.) read up on ArrayList - it's a very common and useful data structure, and I think it's what you're going for by trying to implement a self-adjusting array. 

This is a configuration constant - it should go at the top of the class, before methods. If all users should have the same withdrawal limit, it should be declared , too.