The word would be clearer if you spelled it , and likewise should be . The use of syntax is much much harder to read than a simple would have been. In the case that is 0, no CAS is necessary. Instead of repeating the assignment to twice, refactor your loop. The expression is a verbose synonym for . Put it all together: 

Anyway, these signatures are both getting into crazy metaprogramming, but the point is that I want to be able to construct a engine from e.g. or or whatever; I don't want to have to copy my key into a in order to build a . 

Naming: Surely the parameter you've called ought to be named ! The word "limit" implies an upper bound, as in "speed limit". In this case, the "limit" on object size is . The parameter you've currently called is the thing you're supposed to be comparing to the size limit. What it actually represents is just a size. Separately, are you at all worried that repeatedly ging (only) huge objects will be a bad debugging experience? Or do good browsers already handle huge objects just fine? 

Orthogonal to the first idea, here's another one. Right now you have knowing about and vice versa, which is pretty ugly if your attitude is that is the "real" object and is just an auxiliary. (Think versus , for example.) (It might be different if you're coming from a Model-View-Controller world, and you think of and as co-equals.) Anyway, if you think of as a second-class citizen, it's annoying that has to include , isn't it? Well, you could get around that (and turn into a header-only class) by turning into a class template: 

This is a solution to Advent of Code 2016, Day 8. The tricky part of this problem is that you have to be able to rotate both the rows and columns of a two-dimensional array. Rotating a row is easy using , but rotating a column seems much harder. My basic approach was to write a "getter function" such that returns the th element of the (row/column) currently being rotated; and then I wrote a very straightforward "rotate by 1 in a loop" function in terms of . That implementation is marked below. (Although, given this particular problem's range of input, "it's not dumb if it works.") But I'd really like to use if possible, both for speed ("rotate by 1 in a loop" is O(x), when it should be just O()) and for elegance. So I wrote a wrapper that takes the "getter" function and turns it into an iterator. This is marked below. 

EDIT: To help focus the discussion on the algorithm instead of the formatting, I've run auto-format on it. I'm not going to change the formatting in my version, but if you find it easier to read this way, here you go. I'm looking for feedback on how to simplify or improve the actual code, not opinions on what style/spacing different people prefer. 

However, if you're trying to follow what's actually going on with and , though, I highly recommend the column view in the original code, since modifications to each variable are shown in a column. Each column of code in the test is aligned so each of the 24 cases is on a single line and laid out sort of like it would be on a spreadsheet or table. This helps in spotting patterns and understanding the differences between each of the 24 cases (each of the 24 cases is extremely similar). 

Multiple upstream servers are sending notifications to a load-balanced django app. If all the upstream servers are working correctly, the app will always receive duplicates of these notifications (since all the upstream notifiers should send the same notifications; it's just for redundancy). I want to be able to filter out these duplicates. However, since the python app is load-balanced, the only place we can check for these duplicates is in the database (unless we did distributed locking, etc, which sounds like more of a pain). To do this, I'm hashing the messages, then invoking a stored procedure in the database that checks if a message received in the last 10 seconds had the same hash (I know about hash collisions; it's a risk). I want to be 99% sure the store procedure is safe against race conditions. Here's the SQL code that seems to work: 

I'm much more worried about correctness than performance since notifications will only come on the order of every few seconds. In particular, I'm worried that the commit won't happen until after the lock is released. Will this work as intended? 

I'm looking less for code style/spacing/braces suggestions (I happen to like the way I've lined stuff up since it helps with debugging and spotting patterns), and more for algorithmic suggestions. I'm mostly worried because I'm considering adding diagonal walls. That will suddenly bloom the left/right logic from 24 cases (2 wall arrays * 3 directions the paint can go * 2 for front and back * 2 for left and right) to 112 cases (4 wall arrays * 7 directions the paint can go * 2 for front and back * 2 for left and right), at which point it might be simpler to generate the code with a text template or something. 

In general it's not that useful to separate the and abstractions. If you want a list just pass around the first node of the list. It makes many algorithms much simpler to read and write. I'd start with 

Problem Given a square matrix of size , calculate the absolute difference between the sums of its diagonals. Input Format The first line contains a single integer, . The next lines denote the matrix's rows, with each line containing space-separated integers describing the columns. Output Format Print the absolute difference between the two sums of the matrix's diagonals as a single integer. Sample Input 

This becomes much easier if you realize that those two cases are identical, all you are doing is freeing something and changing what a pointer points to. To change what a pointer points to, you can simply keep a pointer to the pointer that needs changing. The pointer to pointer starts off as the input and becomes a pointer to the pointer of the previous while iterating down the list. That way when you find the element you just save its pointer, free the element, and use your pointer to pointer to update the previous element OR to point to the new . 

Task Write a program that, given the amount to make change for and a list of coins prints out how many different ways you can make change from the coins to STDOUT. My approach The number to make change for is . Take one coin and sum the number of ways to make with the other coins. Add the number of ways to make with the other coins, etc, for all where is the number of coins used. Do that recursively. Memoize it so it's effectively dynamic programming. Code 

You don't need to track the end of the list. You can just check that you've reached it if an element's next is . doesn't do anything. Every time you use it you set instantly after, so should be a parameter. Setting to isn't that useful because if you don't change it you can simply check and get the same thing, while using less memory. Try