Your overall code is good, I do agree with Wenqin that a more class-oriented approach to the shapes could prove beneficial to the structure of the program. Anyways, onto the review. You are right about the use of your statements in the beginning. This can be handled in a much easier way if you just make a to store this and call it from a single statement. That way if you make changes later, it's easier to maintain and it's definitely easier to reuse. 

You never do anything to modify , yet at the end of the method you return ? Some comments would go a good way in explaining that a bit. 

Any other feedback is greatly appreciated, I am new to bash scripting and trying to find the best way to get this to be as optimal as possible! 

Another copy constructor that just takes up space without providing any added functionality or benefit to your program. I would remove it if you don't use it (unless it is required) Finally, the reason that your professor added the extra methods was to force you to protect your data. This is a normal practice in Java, but you really don't see accessors/mutators as much in a language like C++, for instance. 

Room_Dimension Class Overall, I think that this class is laid out pretty well. There are a couple small things that I would question though; 

You have accessors (the and methods). These methods allow us to retrieve data from our private members of the class instances safely, without revealing how they are implemented. This is known as encapsulation, a very important topic on programming to understand. This is where having a properly implemented copy constructor can show its' worth, due to the fact that you can now create copies easily without exposing references/implementations of the member variables. Typically, accessors are paired with mutators, which conversely, allow us to alter the members of a class instance in a predictable and controlled way. As pointed out by cbjobar in the comments, the use of mutators changes a class instance from immutable to mutable; the data values can now be modified after instantiation. 

The functions can either be s or external functions that are short and easy-to-read as values. Usually this is better with only one or a few consistent arguments. The functions are so long that putting them in an chain makes it hard to keep track of the flow. Again, usually this is better with only one or a few consistent arguments. There are a huge number of possible inputs, which makes for an overly long test chain, but where there are again only one or a few consistent arguments. 

Assuming your nesting is only one level deep, the concatenation can be done very easily using . This will treat the inner lists as vectors, then concatenate them end-to-end as a 1D numpy array. You can then take the mean of the resulting array. So this will do what you want: 

So here is how I would write it (ignoring the functions part). I am putting intermediate values inside one file, and then saving the final result to a file at the very end: 

Without knowing what your file is structured, it is hard to give too much concrete. I do have some suggestions, however. 

They key point to these two approaches is that they only ever keep one line in memory at a time, which saves on memory enormously. Or, if you want to do some other manipulation on the lines before saving, you could do something like this: 

will return even if someone wins on the last move. You should do the empty check after you check for any wins. Your comments in has twice. The second should be 

Follow the pep8 style guide The initialization should be moved into its own function. Many parts can be greatly simplified by optimized by using with vectorized operations. In (which shouldn't be called that, btw), you can use rather than keeping track of the vertex number manually. You can do . You should probably use single leading , since your code doesn't benefit from name mangling. You can reverse and use a to reduce the nesting by one level. You can use string replacement, for example . In , at the end define the string outside the loop with and then on each cycle of the loop replace it with . In , in the final loop you can use to avoid having to index into . In , you can do instead of using a set comprehension. You can do to make list of tuples. Do not do , though. You should use or instead of or . You don't need to wrap single tests in . You should make a function and put all the code in in there. Then just call that function in . 

The biggest problem in your code is that you have literally everything in one method. This is a BIG maintainability concern and makes your code really difficult to reuse and debug if something ends up going wrong. Break your code up into many small methods, this way if something breaks, or you find a bug, you know exactly where to look for the fix. 

I have been working on a script that automatically checks on the state of 2 services that I require to be running 24/7 on a server that I manage. The script works as I need, but I would really like to optimize it if possible. Specifically, I find that I want a way to reduce the need to type the command: 

This is a simple boolean comparison, so you can literally just return the result of the comparison and not have to make a bulky if-statement. I think that Janos did a good job touching on making your class a simple static method. I agree with him about your use of tests also. You put in a lot of code (more than your actual list and program) to do some really basic tests. I would honestly just keep it to one method. 

As a side note, look at how much easier it is to read! Think about what it would be like to read your code from someone else's perspective; would you think it's cluttered? Confusing? In your , this can be broken up into methods based on shape (unless you decide to create a class for each shape). This helps in maintainability also and builds on what I stated above. 

So what would happen if a user input a negative number? This would definitely give you output, but is it valid or even usable? Overall, your code is alright. But try to avoid uneccessary spaces or excessive blank lines, it results in code that is tedious to scroll through as the program becomes longer. Try to implement the DRY Principle as often as you can, it will result in elegant code that maximizes re-usability. Putting my suggestions together and leaving some work for yourself, is the code below: 

The second approach would be to roll your own generator-based solution, using the statement. This can then be converted to a tuple in the same way. You need an inner function to handle the generator, and an outer function to convert it to a tuple: 

You strip out spaces, then on the next line check if each character is a space. The second part is redundant. The only possible values for are and , so can be simplified as If is , then there must be an even number of elements. If is , then there must be an odd number of elements. So really all you care about is if there is more than 1 odd count. You can return the results of expressions directly. So something like is simpler than using an test and manually returning or depending on the outcome. I would put the first since that reduces the number of characters that has to operate over (although this is probably a silly negligible micro optimization). 

You can use to avoid having to manually append the newline. If you are going to be working with lines individually, or are going to save the file, it is better to use a generator and not join at all. 

You are doing a LOT of unnecessary type conversions in Python that you aren't doing in MATLAB. Type conversions are always slow, so this is going to hurt your performance a lot. You shouldn't do , always iterate over the sequence directly. You can use unpacking to get the values without needing to index in this case. You are iterating over , then subtracting one to put it back into Python 0-based indexing. This is an unnecessary mathematical operation, better to do , or in your case . Better yet, pre-compute your values, then enumerate over those. is the equivalent of and will be much faster. Python has in-place operations, which will be faster. So instead of . Numpy sums work of flattened arrays by default. Further, summing is a method of numpy arrays, which is simpler and probably faster. Numpy arrays are floats by default if created using or , but there is a argument that can set it to whatever you want. Numpy has a and to create an array of the same shape as another. By default it also creates one with the same dtype, but you can override that. PEP8 is the recommended style for python code. 

For readability I would recommend create a instead of working with . Typos are sometimes difficult to track. 

Don't do a lot of work in the constructor This is a bad programming practice in general. Because just creating instances can already take a lot of time. I would prefer an method instead. Or put the work you are doing in the constructor, in the method. Which can call a or something. Prune entire BFS iterations If you hold a maximum radius for each node while visiting. You can determine at start that a certain node will not decrease the radius. When it is already visited with a higher or equal radius. 

Which is too big for int/bigint. When the exception is not caught well and your error pages expose information. Worst case this may expose information about the underlying directory structure. Which can be used by hackers while doing other attacks. And even when this is not the case, passing through exceptions are not a best practice. I would rather use a built-in php method for that like intval. As an addition to this, you can also use prepared statements which is another very good way to protect against sql injections. 

All that is left to is checking if all bits in the mask are set to true by the current player. This is very easy using the bitwise -operator. Example: 

Consider using an field instead of . You are using a lot of hashing, which causes overhead on a String. 

You are looping over all intervals. This means you have to check all intervals with each other. Hence complexity: This is a well known problem, you could find a lot of reading about this online if you want. 

Depends on what you want. Typically programming challenges are not validated on clean code. But on correctness and efficiency. 

=> All bits in mask are set to true REMARK: Instead of looping, you could hardcode all row and column masks. Which are still only 8 masks. If you understand this, you should also be able to understand how to 

You have this copy constructor in your class, which is confusing because your class is mutable. Typically, we only need a copy constructor if an object is immutable. If you wish to keep the copy constructor, remove the setter and getter and change the copy constructor to this: 

This can be placed into it's own method so that you don't have to repetitively type it throughout the code:': 

Input validation You do this for your statement, but not really anywhere else. While this doesn't make a huge impact on this particular program, it could on another one you write and you need to get into the habit of checking anything that you receive as input from the end-user. Here is a simple example of what I mean: 

Otherwise, I would remove the copy constructor; it really has no purpose if your class is mutable. On the topic of mutability, you have one private member and one public member? It's a bit odd that you would expose the next node, but keep the values private. I would change the to be private: and then I would create getters and setters for it. Only do this if you are required for some reason to have mutable Linked List. 

Here is my updated code per the suggestions given in Joe Wallis' answer. I have changed the main loop in the method, eliminating the if/else statements. I have also added additional methods to aid in easily retrieving data later form a separate module that is used. 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

Alternatively, you can use it as an index a . This is shorter, and avoids the issue, but I think it is less idiomatic personally: 

I make like in the previous example. In cases where is perfect and is good, I can just write to at the point where ends. In the cases where is bad and is food, I can just write from the start of . In the remaining cases, I have to calculate where starts, and then write . 3. 

The only thing I can see is that you don't need to have the on a separate line. works fine. It works on both python 2 and python 3 from what I can see. Also, you could use in this situation: , although I am not sure that is any real improvement. On python 3 this approach is a bit simpler: 

Follow the pep8 style guide. In , you should slice initially, rather than popping. So . In , you should convert to float in the initial list comprehension. In , you should convert to a single numpy array, then slice that to get X and Y. In , you don't need to wrap the in In , don't put multiple operations on a single line like that. In , you should do the splitting once, then get the items from that. In , you should use string replacement. So, for example, . Or better yet you can define a string at the beginning, then apply the format to it in each case, so and . Use to automatically open and close files when you are done with them. When looping over a file object, you don't need . Just do, for example, . That will automatically loop over all the lines in the file. In , you should test for a slice of a string. So In the loop of , it would be better to define a string in the block, and then after the block write that string. Never, ever, under any circumstances call . If you need to exit, either allow the program to exit normally or throw an exception. In your case, raise an exception. You should put the argument parsing in a function. In , you should at the end of the block, which will allow you to avoid the case. Or better yet, do , since will work in both cases. In , you should do (which is miss-spelled, by the way). In , the list comprehension should be a generator expression. This will allow you to avoid having to store all the filenames.