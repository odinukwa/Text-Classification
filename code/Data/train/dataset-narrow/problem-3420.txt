I am come across this nice looking affordable touch screen lcd panel $URL$ and was wondering if it would be compatible with the RPi. It seems as if though the module does come with an embedded driver that supports an 8 bit serial interface so I think I should be able to use the $URL$ generic driver to interface with it sort of like they do with for example the Adafruit 1.8, am I correct in saying so? If so could someone please just confirm what connections should be made and that I will not have to add some adapter circuit or something. I would also like to use the touch interface of this module and it does seem as if though the above drivers support touch but there is not to much detail as to how that works so I have completely no idea if this module's touch will be compatible. If someone could please just explain how touch implementation works that would also be greatly appreciated. UPDATE: I have just noticed one of the displays that the github driver is compatible is a Watterott MI0283QT-9A which appears to have exactly the same driver as the screen that I want to use, an ILI9341. I will just have to use the 9 bit interface but that should not be a problem. I would still just like some confirmation that it will probably work and I still need a lot of info on getting touch to work. 

I want to use an RPi running Arch Linux to power an embedded device and I therefore need the RPi to launch a (Mono C#) application the moment after it has finished booting without the user having to do anything. I have seen tutorials of how to do this on Raspbian but not for Arch. Can anyone help please? 

My RPi is working fine and automatically connecting to wifi when powered from USB but when I try to power it from a regulated 5V supply on the extension headers I can see that it goes on but then short after a while the wifi dongle's light goes off and I never get a chance to even ssh in. When I powered it from usb again it works completely fine. Any idea what could be causing it and what I can do about it? PS. The 5V is regulated from a 12V open frame power supply and seems to be a very solid supply. 

The Raspberry-Pi 2 can run programs without being connected to another computer. It normally runs it's own programs, and talks to other computers for similar reasons to any other PC or laptop. Add a monitor+keyboard+mouse, and it can be used to write programs, to run on itself, or other compuers (like MCUs). So again, it doesn't need another computer. It normally runs a version of the Linux operating system, and much of the information on the web uses the Raspberry-Pi/Pi 2 that way. I strongly recommend you go to the Raspberry-Pi web site and start searching around there instead of youtube. The YouTube videos don't seem to be communicating effectively. You do not need to do 'bare metal' programming if all you want to do is light an LED when you push a button. There is much less information about using it this way (maybe 1%?). Programs that run on Raspberry-Pi/Pi 2 can be developed in many different programming languages. Python is popular because it is easy to learn, but you could use C/C++, or many other programming languages. The only instructions which come with a Raspberry-Pi are about going to the Raspberry-Pi web site, and learning from there. If you want to drive an LED display 'wall' I recommend you look at Paul Stoffregren's work. He has several projects, including playing real-time video. He uses a small Cortex-M MCU to drive 1000 LEDs, and a BeagleBone Black for controlling many of the Cortex-M boards. See $URL$ $URL$ Edit: I think trying to drive 64x64 (4096) RGB LEDs directly from a Raspberry-Pi/Pi 2, is not the way I'd go. Each of the 4096 LEDs will need 24 data bits to update the picture = 98,304 data bits The refresh rate of the WS2812 LEDs is about 800kbits/second, and it is very time sensitive, so 98,304/800,000 = 0.123 seconds That is about 8 frames/second, so unusable for live video. They would be better driven as 4 independent displays. I think it will be hard to drive 4 displays unless you did use the R-Pi bare metal, where everything will become much harder. I like Paul Stoffrgren's approach because, not only it works, and he has proved it, but also because the hard real-time task of driving the LEDs (which would be hard to debug, or more precisely harder to fix if it doesn't work) is handled with a piece of hardware which is capable of the job, and easier to debug and fix. A BeagleBone Black has two 'real time' processors called PRU's, which could be used to drive the LEDs. However, they might be quite complex to use, with very little help available. Given your original question, which I interpret as an indication that you are not very experienced, I would suggest you investigate Paul Stoffregren's approach first. That works for 2048 LEDs, has the potential to drive more, and can be experimented with at a low initial cost. Doing some actual experiments that are likely to work is very helpful for discovering facts and building experience. Edit 2: I would tend to avoid anything which says Technical Details "We don't have a spec or datasheet at this time. However, these are the specifications from the factory", even from Adafruit, unless I really knew exactly how to use them. Further, comments like "in theory you can chain these together", suggests they haven't tried, though it is exactly what you say you want to do, would not make me feel confident. The only examples they have are for Arduino UNO and Mega. So use an Arduino MEGA. It has 8KiBytes RAM, which is enough for 12 bit colour for 2048 LEDs. I would probably search the net for working code for more powerful processors, and base my choices on the that. Otherwise I'd probably use different LED technology. 

My Pi is set up as a PHP MySQL (Percona) server and I think that I have managed to make it quite resilient against online attacks but it is still very vulnerable against someone just taking out the SD card and reading all my data. I guess I could encrypt the important stuff in MySql but the encryption keys would still be in plain text PHP files and I guess that I could encrypt the PHP and/or MySQL folders but that would all just get complex and there would still be cache and logs etc. to worry about. Someone could probably also see the hashed password and use a rainbow table to crack them. Correct me if I am wrong but as I see it the simplest to manage and most secure solution would be to just encrypt the entire drive (excluding boot and kernel obviously). Now the only problem is that I cannot really figure out how to do that. The best link I could find was this one $URL$ but as far as I can determine this only explains what you should do for a fresh installation but unfortunately I have already installed a lot of packages and have made a lot of configurations which I would like to keep. Could someone please explain to me (or provide a link I guess) in simple terms what exactly I should do to fully encrypt my existing Arch Linux installation. PS. I can understand that for full encryption a key needs to be entered at boot but I could not determine if that requires a physical terminal (screen + keyboard) on the device (which I don't really have but I can get if needed) or if I will be able to do it over the network? EDIT: Ok, I have found this link $URL$ and my drive is now properly encrypted, all problem is that using ssh to enter the unlock password doesn't work because my key is not accepted when I try to connect from Putty, any ideas? Just a thought but could it be that the root_key file is actually encrypted when Dropbear tries to read it? 

I want to use a Rpi to interface with 3 atmega ics in an embedded system but the pi seems to only have one uart port. I know arduino can emulate a serial connection over two io pins, will this be possible on a pi? I plan on using a headless raspbian setup with a mono c# terminal application.