I have written a Java application that opens a dialog () which runs fine on Windows but when I try and run it on the Pi, the dialog fails to appear. What may be wrong? 

When using servos that rotate through 180o, one sets the desired position of the servo arm and the servo will try and "get there" as quickly as possible. There is no explicit control of rotational speed on a servo. If one wants to attempt to reduce the speed, one can ask the servo to move to a target position by repeatedly moving to sub fractions of that position and delaying between moves ... however this is unlikely to deliver a desirable result. For servos that were designed for continuous rotation, some of these use the PWM signal as an indication of their rotational speed. If we assume that a PWM signal is between 1000 and 2000usecs then 1500 means stationery, 1000 means maximum speed in one direction and 2000 means maximum speed in the other direction. Other values between 1000 and 2000 will rotate in the corresponding direction but at less than maximum speeds. 

With the Raspberry Pi being a Linux based computer, you can most certainly use its sensors to accumulate data and then transmit that data to a remote computer. You have many choices available to you in achieving the network connection. Some of these include: 

Given the popularity of the Arduino IDE and the wealth of existing Arduino sketches, can I use the Arduino IDE to write or compile sketches that will run on the Raspberry Pi? 

The PI3 is a very different architecture for the Pi 1 Model B+. I would recommend that you obtain a second micro SD card and install a fresh Raspbian upon it. 

For starting programs at boot time, another solution is to use . This has the advantage of starting and stopping the program as well as just start on boot. A sample video tutorial illustrating how to use systemd is available here: $URL$ There are also many other resources available by searching on "systemd". 

The encoding protocol can be found by googling "nunchuck protocol". A sample application for reading the nunchuck is shown next: 

At a high level you have two applications here. One which displays a clock and the other which retrieves the time from GPS data and writes it to the console. Your goal is to successfully "merge the two". You are going to want to write a completely new application which might use these two apps as a degree of a template. You should study both apps in detail until you fully understand how they work. At that point, you can start to design a whole new app which, at a high level will begin by initializing the UI environment and the GPS environment. Then in a loop, you will want to retrieve the time from GPS and use that as the input to the UI function which, today, uses the PI system time as the clock value. 

As for data formats, the content can be anything you desire. I'd probably suggest staying away from binary data unless the volume is extremely high. If you are using Node.JS, then JavaScript objects are probably in your future and JSON becomes a good data content potential. REST requests are probably going to be easiest, Web Sockets probably the least network overhead and MQTT if the network was unreliable and you needed to buffer the data. Your choice of technology will probably be influenced by your choice of implementation language at the Pi end. From what you have said, I'd be tempted to suggest running Node.JS on both the Pi and the PC. 

I have been writing some pigpio apps and all of a sudden, they all start to fail. The error I get is: 

The Wii nunchuck is an I2C accessible device and can be wired to the I2C pins of a Pi. How do I read the data from a Wii nunchuck in C using the WiringPi library? 

As I understand it, the mode of a GPIO pin can be INPUT or OUTPUT (and I think there may be other modes such as PWM and I2C). I believe that the mode of a pin is a global and that if two applications attempt to set the mode, the last one called will be the actual final value. My goal is to determine a pin's mode before attempting to set it or use it. This will allow me to detect potential conflicts. Is there a way to determine the mode for a given pin? My programming library of choice is wiringPi but I am interested in any solution in this area just now. 

This is actually a Linux general question as opposed to Pi specific ... but the answer is to use the command. Read about it here: $URL$ Basically run: 

The WiringPi library has APIs called and for writing and reading 16 bits of data from a given I2C device at a specific register. Since the resulting 16 bit value is made up from the read of two 8 bit bytes, is the value Low Byte / High Byte or High Byte / Low Byte? 

It would probably be useful to see the whole Arduino sketch but from the screen shot, the logic appears to be: 

I perform Java development on my PC and execution on the Pi. Since Java generates classes and classes are machine/architecture independent, I use the PC to compile to classes. What I also do is use NFS running on the Pi to mount an NFS exported file system from my PC (If you are using Windows for your PC, Samba should also work). This way I can compile on the PC and then immediately execute on the Pi. This alleviates the need to copy from the PC to the PI which introduces an error step caused by "forgetting to copy". It also speeds up the workflow. I took the time to write up notes on this on the free book available here: $URL$ 

If one googles this phrase "raspberry pi gpio web interface" and switches to images mode, we can see that there appear to be quite a number of pre-existing solutions and samples. For example: $URL$ $URL$ $URL$ and quite a few others. 

I purged the original Node.js that comes pre-installed with the Pi and installed Node.js myself. The purge did indeed remove Node-RED and other Node based tools. After I installed the latest Node.js I then manually installed the packages I needed (such as Node-RED). I suffered no ill effects and ended up with exactly the set of installed packages at the correct levels that I wanted. My recommendation is to note the packages that are removed by a Node.js purge and decide which of them you want to have again. I use Node.js extensively on the Pi and there has been no ill effects on me following this procedure. 

If this is indeed the case, then if we look carefully at the logic, as soon as you set the servo to be we end the loop at start immediately back at the start of the loop which then sets the servo to be . What that means is that the servo would be asked to turn to position and then almost instantly asked to turn back to with the result that you wouldn't perceive any actual motion. 

I'd like to suggest that a study of the environment is also a great candidate. This is the environment that is already present in Raspbian and is responsible for starting the majority of system demons at boot time. It takes a little study and work to get going but the results can be pretty good ... plus it gives the you the ability to start, stop, refresh and see status using the command. A google search on will provide a good start on reference materials. A video tutorial on this technique is available here: $URL$ And a write-up in a FREE Raspberry Pi book is available here: $URL$ 

For DC motors such as fans, you can use a power transistor to switch power to the motor. An H bridge is probably over-kill since you only need the motor to spin in one direction. A circuit like this will probably suffice: 

When you have the source of an application (for example a program written in C) when it is compiled, the source is transformed into executable statements that the central processing unit (CPU) of the computer understands. Windows machines typically understand Intel/AMD processor instructions while the Raspberry Pi is based on the ARM processor and runs ARM instructions. The simplest analogy I can give is to think of a C program as being a book written in Latin. For the program to be useful on your desktop PC (Intel/AMD), the book is translated into German (the native language of the PC) while for the Raspberry PI, the book is translated into French (the native language of the PI). If you take a book translated to German, it can't be read by a French only speaker nor can a book translated to French be read by a German only speaker. 

Linux is a multi-user, multi-tasking operating system. This means that it can run multiple processes simultaneously. However, this is an illusion. What is really happening is that only one program runs at a time (assuming we have only 1 CPU ...). The apparent execution of multiple programs at the same time occurs because we perform what is known as a context switch between programs very quickly. If we were to take a photo snapshot at any moment in time, only one program would ever be running in that picture but if we switch between programs quite quickly, we get the illusion that they are all running. So ... what allows us to switch between one program and another. Typically, a program will "relinquish" its use of the CPU when it performs some kind of long term asynchronous I/O operation such as writing to disk, making a network call or waiting for user input. However, if a program performs lots and lots of pure CPU operations, it may never voluntarily give up its CPU time. This is where pre-emption comes into play. The OS tracks how long a given application has the CPU and if it has held that CPU for "too long", the CPU is taken from it and given to another waiting application. There are sophisticated algorithms for choosing which application gets the CPU when a slice of time is used up and this is, in part, governed by an attribute of a process called its priority. At a high level, processes which want the CPU and have a higher priority level than other processes will be given it. What this means is that if a program runs with high priority, it may be given an "unequal" share of the CPU relative to other processes. This can result in the notion of "starvation" of other applications which would like the CPU but have lower priorities. There are also other reasons that starvation can occur. There are certain tasks that are "non-interruptable" and if called, may not be preempted. An application that registers to use these services may also claim an unequal share of resources. The starvation of CPU time to some applications does not indicate an error or flaw ... it merely reflects the reality of what the system may actually be doing. When an application is run as root, that application has the highest level of privileges which includes the ability to change its own priority (upwards) as well as register with the hardware timers for interrupt level processing at very short duration intervals. I did a very quick examination of the code in the projects you referenced and found indications that both of these may be happening in the Adafruit libraries. It may simply be the case that when you are running those Adafruit programs, they actually need dedicated resources to achieve the timliness of the tasks that they are performing and that there is nothing left over to give CPU cycles to the other applications you want to run in parallel. 

This sounds like an excellent application for RFID cards. RFID scanners are very cheap. When an RFID card or key fob is brought into proximity of the scanner, the scanner will record/register its arrival. Each RFID card can have its own unique ID and can also be programmed to contain a small amount of additional information. The most popular RFID scanner is the MFRC522 which can be bought for a few dollars. There are also many excellent tutorials and samples for working with this sensor. Many are also specific to the Pi. Some staring links might include: How to use RFID-RC522 There is also an instructables that sounds very much like what you want to achieve. See: Attendance system using Raspberry Pi and NFC Tag reader 

It is likely that you are running a DHCP client. This attempts to get an IP address for your network interface, gateway address and nameservers for your DHCP server. This is over-riding what you have configured in your definition. The solution is to edit the file and add static definitions for your named interface in there. See the man page for dhcpcd.conf for details and/or google for further examples of folks having configured Raspbian and DHCP client. For example: $URL$ 

An excellent blog post tutorial has been posted here: $URL$ Please review that detailed posting for a complete answer to connecting your SD card reader to the Pi. There is a companion You Tube video available here: $URL$ 

I don't believe that there is an "absolute" answer to this question. What I'd suggest you do is go to ebay and search on the phrase "project box" and have a skim of the results. What you will find is a rich assortment of the types of boxes and cases which can be used to house a finished project (circuit, solution). In order to firmly attach the "internals" of your project to the housing, some folks bolt the solutions in place. These can be metal or plastic bolts of an appropriate diameter. The pre-drilled holes in the PCBs of modules and circuits provides a recommended and easy attach point for these bolts. Alternatives to bolts include glues (eg. hot glue), firm padding, zip ties and other ad-hoc techniques. Your solution may have specific requirements. For example, heat conduction, air flow (for heat dissipation or sensors), line of sight (IR LEDs) etc etc. 

JavaFX on the Pi runs on a single primary JavaFX . The implementation on Pi does not allow additional stages. As such, you can't create secondary windows or dialogs that open in their own windows. This is simply a restriction in the current release. The release at which this restriction is present is at least: 

My personal choice is to use a USB->UART connector. When a virgin Raspbian image is installed, there is an instance of "getty" running against the default serial of the Pi. This means that if we attach a serial terminal to the RX/TX of the Pi UART, we can get a login prompt. Using a USB->UART, I plugin the USB end into my PC and then connect the PC RX to the PI TX and the PC TX to the PI RX and then add a common ground. Now if I run a serial terminal emulator such as Putty, I can login to the Pi. From there, if I need, I can setup any and all network options I may need to get further bootstrapped. 

Do we have any sample apps using native socket APIs either in C or Java? Later ... Have started to reverse engineer code and it appears to be TCP sockets (AF_INET) ...