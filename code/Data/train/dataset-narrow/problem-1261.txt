Another recommendation I have is to move the checks for and into the respective functions as pre-conditions. This will allow you to simplify. 

you dont need to maintain x. Also, why do you have only 4 here? from the above, if the level is 5 you add a new cell. 

Does position have a constructor? If not, it would be nice to create one for it. If yes, it would be better to use it. 

We can depend upon tar to not create empty archives. So if the filelist is empty no tar files are created. 

As you can see, the reason you can't use rndStr directly is that rndStr uses IO. So it cannot be directly used as a function. You can think of it this way. rndStr returns some thing that is wrapped in a box. You need special constructs to unbox it, and the special construct is either <- . You might also notice that main has the same kind of signature. That isn't a really good analogy, and I am not the best teacher :). So if you really want to understand what happens, it might be better to read any simple monad tutorial. 

It is rubyish (and smalltalkish) to use select, inject, collect etc rather than explicit loops where possible. 

Another advice is to avoid magic numbers in your code. If there are any, they should be declared in a highly visible area along with their purpose rather than buried deep in the code. 

Readfile shouldn't really say that a file if it does not exist will be created. It should just read the given file and return the value. The check and warning should be done elsewhere. 

Edit: Why is this better? Because unlike other approaches it never modifies a variable that is assigned once. Thus it preserves the referential integrity. That is this is a functional programming approach in comparison with others which (as of now) follow an imperative model. The succinctness that results from it is just a bonus. 

There is something seriously wrong with the markdown, I cann't get the code quotes to work right anymore. It was working until yesterday. 

I suppose you feel that foreach is a kind of a map, and that inhibits you from exiting in the middle. In most code that I have seen, the first form is preferred except in the cases where we need to get the index where the break happened. i.e This is ugly. 

Finally, if your class takes decisions based on a flag in another class, you might want to rewrite it to reduce coupling. And perhaps use a pattern like Strategy. 

Some observations. The space between #! and the path to binary is not needed. (It used to be for some arcane versions of Unix but not anymore AFAIK) Secondly, I prefer to let env find ruby for portability. 

Any particular reason you handled the first one using exception and the second one using an if condition? Also consider returning an error code, If program can be used in non-interactive way, printing any errors to stderr also helps. I would also modify it as 

Avoid extra indent when one of the cases is simpler and can be dealt with easily. Also, about your ranges. They should really be named constants. 

Also note that it is better to take out numbers such as and declare them to be a constant with a good variable name that denotes their purpose. It helps you to understand your code at a later time. -- 

The classes in are often very useful. These are just your functions that have been modified a little bit. This may seem like overkill to you, but as a beginner, you would profit tremendously if you internalize the functions in the space. At the very least, understand the functions used here. (I would certainly recommend your definition of the diff over this, but the point here is one of demonstration.) 

The given problem can be attempted in a slightly different manner. You can see that the pairing corresponds to binary digits with { standing for 1s and } standing for 0s. For e.g the pairing with the maximum value for say 4 {}'s is 11110000. So all we have to do is to generate every number from 1 to 11110000 and strike out all numbers that do not conform to our requirement - that is, at no point while counting the digits from left in a number, can the number of 1s be lesser than the number of 0s, and also that the total count of 1s and 0s must be equal. A few optimizations can be done, For e.g, all odd numbers can be eliminated. And the total number of digits have to be even, etc. If the number of braces are , then the algorithm is of complexity. So it is not an efficient algorithm. I wonder what the complexity of your algorithm is, and how you can show that your algorithm is indeed correct. For additional ideas ref: catalan numbers. 

It actually gets or sets a value... There's also the tag that you should add. I use the GhostDoc extension to help generate code documentation - that might help you out too. 

I don't want to start a holy war about it but you should know that your bracing style isn't generally the expected style for C#. It is more common for the opening brace to appear on a newline: 

You are mixing query and fluent syntax for your LINQ queries which is resulting a in a lot of code bloat. Let's refactor it one step at a time. 

Now you only acquire the lock once and do everything while holding that lock instead of having to keep acquiring and releasing between items. 

Do you see the problem? For every item you're doing a which will iterate over all of the items you've already processed. First iterating 0, then 1, then 2, then 3, then 4... all the way up to N-1 items on the last call. So we know that is going to get more expensive on each iteration of the list even when we schedule everything on the same resource. In the worst case, you need a new resource for every item. You're now doing one call to for every resource id that you've already created. However, you never search the last one as it is created on the last iteration. So just on your last iteration, you'll be doing (N-1)*(N-1) operations. Ouch! I'm sure the average case is creating quite few 'resources' but it is worth considering the absolute worst it could be. Just while I'm at it - you're also calling loads and loads of times. You already have one answer that improves this for you, I'll just throw another one at you. All you need to do is keep track of your 'resource id' and the date/time the current item ends. That fits nicely into a list: 

You already have an enum - make sure you have implemented equality correctly and let people create their own mug cup. 

The problem is that Entity Framework's is really a unit of work. By newing them up inside each method you lose the ability to do several interesting things in the same transaction/unit of work in an easy way. You should be able to have multiple repositories (Dao in your parlance) using the same context/unit of work. Your code is also incredibly coupled to EF and you're violating the dependency inversion principle. This is the best write up of DbContext lifetime that I've ever read: Managing DbContext the right way with Entity Framework 6: an in-depth guide. Although you're not actually using any of the 3 main patterns discussed. If that is Automapper, that's also the wrong place to be configuring it and is a conflation of concerns. 

Edit With the caveat that I don't know ninject and that this isn't very performant here's a reflection based approach for registration as a complete console app: 

I'll answer your primary question first - Why is it producing 1 char and then immediately consuming that char? Look at the producing code carefully: 

So, based on the name and return type I'm going to "Spend" something(?) and get a list of items. To me, I find it had to believe this method is going to have a single responsibility straight away. The parameters only confirm the suspicion: 

I just use a dictionary to keep a tally of the number of edges in each column and keep the current winner in a variable. My original code was simpler (only using the dictionary) but it failed the performance requirements on leetcode so I had to manually keep track of the maximum as well. 

You have another problem - a captive dependency. You have a Singleton (as it's static) that holds a reference to a unit of work (through the settings service) which shouldn't be kept alive for the lifetime of the application IMO. 

specifies that the only valid captures are explicitly named or numbered groups of the form (?â€¦) See documentation String interpolation - see documentation which is implicit typing 

Your code looks good: you have consistent spacing and good, descriptive names. should be as all methods are in C#. I would remove the optional parameters from as we've now made it much more specific to the case of 1-20. You can calculate this directly without needing to brute force see this blog for a good explanation of that approach. 

stopWords is clearly a constant. So take its construction out. Also see that a set is used. It makes the member operation cheaper. 

Using auxiliary definitions can make your code read much better. Prefer sequence to do notation when values are not used in intermediate computations. Try to move out of the imperative mindset when using do notation. (the do notation makes it easy to write 'c' in haskell :) ), using auxiliary functions can help you there. (I used case instead of if/then because that is what I prefer, there is no particular reason for that except that it makes it easy to use destructuring easier if I need to.) 

One suggestion is to make the roles two classes, initialize them based on the role and call the save function. 

A few observations, Avoid comments that do not tell the reader any thing that they can not understand by reading the code. They just add to the visual noice. Instead add comments as to how the function fits in with the rest of the program, or how the function is to be used. 

Should you check this here? It is more of an assert than a problem with user input, and the user input is validated elsewhere. 

As you suggested, there is a difference, however, it seems that the difference is actually in favour of case statement rather than if. I am not sure what to make of it, especially since you seem to have a different result. However, the time difference does remain if I increase the number of loops. 

Also remove all the magic numbers like 600. They should be named with some meaningful names, and those variables/constants should be used instead. You can reduce some thing such as this 

Do you really want to go recursive on this? Binary trees in the worst case may be a linear list. A better idea is to do some thing like this: 

Regarding the whole organization, it might be better organized as a small command interpreter with specific commands for hint, level etc 

It is nicer to separate out self contained functions even if they are of type IO a (You already have some, but take out as much as you can.) 

Note the use of , I feel that it is better to do this than to distribute the cleanup code every where else in the function. Now, observe the functions below. Another way to do them is populate them into a table rather than defining function wrappers as below. An advantage of that approach is that, you could avoid defining too many helper_x functions. 

I think this is better than repeating the state@ again and again. I think the below might also be nice since it is avoiding the repetition of foldexpression 

I added the unit test import here, and the set. It is rather adviced in haskell to look out for opportunities to take out general definitions when possible from a more complicated expression. The idea is to build the language to describe your problem and then use it to solve the problem by describing it. So lots of tiny general purpose functions are very good. 

Avoid incorporating io statements with your logic. Refactor so that logic is separated to another method. Regarding your assertion that code changes have to be made if you change price, I do not see why. You can read the information to construct a country from a file and thus avoid hard coding it in the main file. However, this does not change the design as a whole. 

Avoid excessively long variable names. I know that various books advocate longer variable names, but often they take away from your screen real-estate, Also, try to restrict the width of your statements to about 100 characters. It is a little more easier on the eye of the reader. 

You don't need to test if dir exists if you are going to use mkdir -p More over, your message in that case is a bit redundant. mkdir's error message says exactly the same thing. 

The same program with a few changes. first, try to refactor your functions so that they are small, second, Often, using a case statement is more clearer to using cascading ifs. third, 'using namespace std' is a bad habit. It is probably ok to use in a small one off program like this, but avoid polluting your global namespace in larger projects. And avoid magic numbers when possible