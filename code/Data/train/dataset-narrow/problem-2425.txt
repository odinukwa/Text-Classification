DES is a Feistel-based cipher. In such ciphers, the function $\rm F$ need not be invertible. Here's the reason: In each round, the following operation is applied: For $i =0,1,\dots,n$ $L_{i+1} = R_i$ $R_{i+1}= L_i \oplus {\rm F}(R_i, K_i)$ Decryption is performed as follows: $R_{i} = L_{i+1}$ $L_{i} = R_{i+1} \oplus {\rm F}(L_{i+1}, K_{i})$ As you can see, the decryption does not need $\rm F$ to be invertible. (Since the decryption does not need to compute $\rm F^{-1}$.) 

"Complex" problems are normally defined as problems which cannot be solved by (probabilistic) polynomial-time Turing machines. When there are extra information available for solving the problem, the model changes to machines which take advice. That is, instead of $\rm{BPP}$ machines, we consider $\rm{P/poly}$ circuits; i.e. polynomial-size circuits (equivalently, polynomial-time Turing machines which take polynomial advice). In some cases, we may consider even stronger solvers: Instead of poly-sized circuits, we may use circuits whose size is sub-exponential. (e.g. circuits whose size is $n^{\log n}$). One might note that, an exponential-size family of circuits can decide any language (even undecidable ones) by merely incorporating the look-up table in its code. (In particular, the size of the look-up table is $O(n2^n)$.) Let's consider the Decisional Diffie-Hellman (DDH) assumption. I don't go into details. Just assume that $p$ is a large prime, all computations are over $\mathbb{Z}^*_p$, and $g$ is its generator. 

Edit: These are not lower-bound results, but they might be useful anyway: $\rm{NP} \subset \rm{P/poly} \quad \Rightarrow \quad \rm{PH}=\rm{\Sigma_2^p}=\rm{\Pi_2^p}$ $\rm{NP} \subset \rm{P/poly} \quad \Rightarrow \quad \rm{AM}=\rm{MA}$ $\rm{coNP} \subset \rm{NP/poly} \quad \Rightarrow \quad \rm{PH}=\rm{\Sigma_3^p}=\rm{\Pi_3^p}$ 

cited by several references as having influence on the relativized ZPP = EXP result (see for instance "Comparing Notions of Full Derandomization" by Lance Fortnow). Specially, while the paper you cited only proves the existence of an oracle $B$ such that ${(\Sigma _1^p)^B} \subset {(\Sigma _2^p)^B} = (\Pi _2^B)$, The paper #1 above continues by proving: ${(\Sigma _2^p)^B} = (\Pi _2^B) = \mathbf{EXP}^B = \mathbf{NEXP}^B$ and paper #2 above completes it by showing the relations between relatizied EXP and (if I'm not mistaken) RP. Joining forces, the relativized BPP = NEXP is deduced. PS: Please provide me with an email address of yours. I want to send you some docs. 

[This is not a direct answer to your question, yet it might be suggestive and/or informative for some people.] William Gasarch's P vs. NP Poll gives some statistics on "how P vs. NP will be resolved": 

The idea is that $P$ shows to $V$ that he can decrypt by committing to the decryption. However, he does not reveal the decryption until $V$ shows that he actually knows the plaintext. Contrary to its simplicity, this protocol has lots of caveats. For instance, one can show that if $Com$ and $E$ are related in a bizarre way, the protocol is not zero-knowledge. Another caveat is that if $E$ is in fact probabilistic, showing that the protocol is a proof of ability is very hard (if not impossible). However, if it is deterministic (say, merely a trapdoor one-way permutation), then the proof is rather easy. In any case, one can show that the protocol can be used for identification (in the smart-card model of Feige, Fiat, and Shamir). 

Here, "straight-line" is contrasted with "rewinding". A simulator is "straight-line" if it does not "rewind" the party it is doing the simulation for. For instance, in a zero-knowledge protocol, the simulator usually rewinds the "verifier". In the "straight-line" sense, this rewinding does not happen. I first saw the term "straight-line simulator" in Rafael Pass's paper (On Deniabililty in the Common Reference String and Random Oracle Models. (CRYPTO'03)) and M.Sc. thesis (Alternative Variants of Zero-Knowledge Proofs). Edit: I found an earlier paper: Concurrent Zero-Knowledge: Reducing the Need for Timing Constraints by Cynthia Dwork and Amit Sahai, which dates back to 1998. For more pointers, see Alon Rosen's comment below. 

PlanetMath lists over 150 books which are available online. The list is updated regularly (the most recent addition being 2011-01-09, as of this writing). Books are math-related, but some of them are useful in TCS, too. 

The length of the proof of a theorem, assuming it is decidable in the logical system, depends totally on the sets of axioms and rules of inference. For instance, consider the propositional logic, for which there exist several characterizations: Frege (1879), Nicod (1917), and Mendelson (1979). (See this short survey for more info.) The latter system (Mendelson) has three axioms and one rule of inference (modus ponens). Given this short characterization, it is really hard to prove even the most trivial theorems, say $\varphi \to \varphi$. Here, by hard, I mean the minimum length of the proof is high. This problem is termed proof complexity. To quote Beame & Pitassi: 

shows that, for some oracle $B$, we have $IP[poly]^B \not\subset PH^B$. (Therefore, $IP[poly]^B \neq IP[O(1)]^B$ since as stated above, the latter is a subclass of $\Pi_2^{P,B}$.) 

The book also includes a nice take on time- and space-hierarchy theorems; see Chapter 7. EDIT: I also recommend Complexity Zoo's Active Inclusion Diagram (requires Firefox 1.5 or later, or Opera 9 or later). If you don't have that, you may try Zoo's Static Inclusion Diagram. 

First, I think the CCA-security is not enough, and the encryption scheme must be at least IND-CCA2-secure. Second, I believe the protocol is not zero-knowledge, at least in the auxiliary-input model. The reasoning is as follows: Let z be the auxiliary input to the malicious verifier V*. It's safe to assume that $z = Enc_{p_k}(m)$, where m is unknown to V*. Then, V* can deviate from the original protocol: Instead of choosing a random m and computing c (as prescribed in the protocol), she lets c = z, and sends c to the prover. This way, V* exploits P as a "decryption oracle," and obtains knowledge beyond what she could possibly compute. One piece of advice: Read the paper Towards Practical Public Key Systems Secure Against Chosen Ciphertext Attacks, specially section 4. It suggests a protocol similar to yours; one which has never been realized. It also proposes the now-famous "knowledge-of-exponent" assumption (KEA), one which was later used to construct a non-black-box ZK protocol. (The reason why you can't find a simulator, beyond the line of reasoning above, is that you try to imagine a black-box simulator. That's impossible by the result of Goldreich and Krawczyk). For more info on the use of the KEA in constructing non-black-box ZK, see [Hada and Tanaka] and the more recent [Bellare and Palacio]. --Edit-- @cyker: I'm working on a similar issue as (presumably) you're doing: The (right) definition of simulators. A partial result of mine, closely related to the protocol you offered, can be found at $URL$ The latest results are submitted but not published online yet. 

I used the this scholar search, and the only result which seems somehow relevant is this: Lance Fortnow, Adam Klivans, Linear Advice for Randomized Logarithmic Space, ECCC TR05-042, 2005. Unfortunately, I think it is not exactly what you need. In particular, the main result of the paper is $\mathbf{RL} \subseteq \mathbf{L}/O(n)$. Yet I believe the techniques used there might be helpful in the case of your question. 

A message authentication code (MAC) is defined by a triple of efficient algorithms $(\mathsf{Gen}, \mathsf{MAC}, \mathsf{Verif})$, which satisfy the following (the definition is taken from section 4.3 of the Katz-Lindell book): 

My question is about a special class of permutations, called one-way permutations. Informally speaking, these are permutations which are easy to compute, but hard to invert (for a $\rm{BPP}$ machine). The mere existence of one-way permutations is a long-standing open problem in cryptography and complexity theory, yet in the remainder, we will assume that they exist. As an example of a conjectured one-way permutation, one can consider the RSA: Let $n = pq$ be a Blum integer, and let $e = 65537$. The one-way permutation is defined by: $\pi_n(x) = x^e \bmod n$. Note that RSA is defined over the finite domain $\mathbb{Z}_n$. In fact, to obtain an infinite domain permutation, one has to consider a family of RSA permutations $\{\pi_n\}_{n\in D}$, where $D$ is an infinite set of Blum integers. Note that $D$ is the description of the family, and by definition, it is infinite. My question is (assuming the existence of one-way permutations): 

Example 1: Let T1 and T2 are the two trees illustrated at the beginning of this post. To convert the right tree to the left tree, one can build a tree of cost 3 on top of ×, and change 4 to 1 (the total cost is 4). Example 2: Let T1=$x^4$ be represented by the following tree. To convert T1 to T2=$x^4+4x^3+6x^2+4x+1$, it suffices to add 1 to each of the $x$ nodes, to optain $(x+1)^4$=T2. This can be done by adding a cost-1 expression tree on top of each $x$ node. This example shows that the term-by-term conversion (which I called the greedy approach at the beginning of this post) is not an optimal approach. That is, if one wants to produce terms in T2 which are not present in T1 (i.e. $4x^3$, $6x^2$, $4x$, and 1), the cost will be much higher. $URL$ 

Unfortunately, there is a result that theoretically forbids "oblivious code execution": Boaz Barak, Oded Goldreich, Russell Impagliazzo, Steven Rudich, Amit Sahai, Salil Vadhan, and Ke Yang. On the (Im)possibility of Obfuscating Programs, ADVANCES IN CRYPTOLOGY — CRYPTO 2001. Here are the links: 

First of all, I wanted to point out that surjectivity is not well-defined without first defining the codomain of the function. So, in my description below, I'll explicitly refer to the codomain over which the function is surjective. Both the discrete logarithm or RSA functions are permutations which are conjectured to be hard to invert. Below, I'll describe the discrete-logarithm function. Let $p_n$ be an $n$-bit prime, and $g$ be a generator of the multiplicative group $\mathbb{Z}_{p_n}^*$. Define $f_n \colon \mathbb{Z}_{p_n} \to \mathbb{Z}_{p_n}$ as $f_n(x) = g^x \pmod{p_n}$. Then, $f_n$ is a function whose properties are as stated in your question: It is both injective and surjective (over codomain $\mathbb{Z}_{p_n}$), it is computable in polynomial time, yet it is conjectured that no efficient algorithm can invert $f_n$ on average. 

@mikero mentioned Bellare & Rogaway's paper, which gives a full proof. It's a rather advanced one, which is hard to digest. I suggest reading section 5.1 of Victor Shoup's Sequences of Games: A Tool for Taming Complexity in Security Proofs, which, IMHO, is a much easier read. The basic idea is a to show a sequence of 3 games: