The problem with the Command Pattern is indeed the explosion of classes and the verbose boilerplate around each little function. That is better done today with lambda functions: the closure syntax automatically packs up the values in a struct and makes a callable with the code body. To use that at run-time (rather than templates), the code takes and manipulates . Sending a struct to match a is rather circumlocutory, which is probably what you are complaining about. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. Some people criticize the leading underscore of identifiers as a style. I point out that it is easy to clash with compiler-supplied identifiers and you must remember to never use a capital letter after the score, so it is a hazard. 

The && is a short-circuit operation, so the code has to jump. Jumps are slow. Testing that both bits are set is the same speed as testing one! 

Don’t use the weird . Using a vector of bytes will be faster, and using a bitset will give you the compactness if that was your intent. Writing is silly. Use uniform initialization: 

My explorations on GCD and performance Aside: you might find My blog post interesting, where I found bottlenecks in GCD including branch prediction, lack of instruction parallelism, and the DIV instruction. Even things like Modulo is significantly slower for signed types compared to unsigned types of the same size! Since the values being used are all positive, that is another speedup. For some operations, the opcode is faster for 32-bit than 64-bit; so switching to a smaller version once the numbers get small enough will speed it up. I found that an algorithm written for computers in 1961 that does no division runs slower than the modern expression when coded naively, but once the bottlenecks in that are found and eliminated, it runs much faster. The CPU can burn through lots of primitive instructions so the increased length is not significant; it’s the traffic jams inside the CPU that kill the performance. 

The might be a throw-away example, but I’d rather initialize the object in one go, not assign to each prop individually. 

The left and right shift can be simply written using an algorithm that copies everything, with the destination shifted one over from the source. 

Likewise, your and functions are nearly identical. I suggest moving the file opening/closing out to a higher level, and combine the encrypt/decript logic into one function that parameterizes the only slight difference between them. 

that’s it! A higher function does the file reading and writing, and a lower function does the rotate logic. As for the file reading, you are doing the exception thing again: throwing 299 and catching it again in the same function, where there was no need for non-local flow control in the first place. For the rotate, we want to add the shift but wrap around. If you start with zero, that is a simple modulo operation. So, subtract the starting letter to get a number from 0 through 25 inclusive. 

You set quiz_avg to 0.0, but the other words you used have no effect! See the comma operator for what you actually did. 

whould be what you use. The body of has almost identical blocks for choice 1 and choice 2. The only difference is the call to Encrypt vs Decrypt. In the updated code above, this would be a difference of calling the same function with a 3 or a −3. In any case, write the block once, and use an statement or the like only for the part that is different. 

Don’t write explicit tests against . Don’t have naked /. Your list doesn’t do anything except . It should have some general purpose means of accessing the values, traversing the list. And then can be written using that public API. 

The algorithm will stop with the iterator pointing at the found character, or at . Either way is good for us! No special testing needed. Note that ranges are delimited as half-open: including the begin, excluding the end. That is, an end iterator points one past the last char to keep. That means everything works naturally without any adjustments or fiddling: 

Likewise for the function, called repeatedly for every output value. For the inner dimension, just use iterator increment to advance to the next value. Here is the way we did raster graphics in the old days: Don’t make a vector of vectors. Make a single vector, and an access function that multiplies the row by the row size and adds the column to produce a single index. Now, given a pointer to any cell, you can efficiently move to the next in any direction. Going right, increment by one. Going down, increment by the row size. So trace through the source matrices this way, one going right, one going down. If the compiler grasps this and auto-vectorizes the code, you are golden! So you might find out what coding idioms are understood by the compiler. Having the loop structured to traverse both inputs with constant (though different) strides is probably key, though. Getting the compiler to see you are doing a dot-product (on each row) is the most significant speed-up you can do. Of course, you can invest in something like Intel IPP library or find some free code that uses the AVX2 instructions. A dot-product with two inputs and an output taking different strides is a very general function you can find to reuse. Oh, if you’re not compiling in 64-bit, do so: you get more vector registers. 

The usual: don’t use an “out” parameter. I assume the is due to this being data kept by the GUI framework? Making this nicer is more advanced than you need right now. But use in the next line; you are naming the type twice. I’m guessing the use of a pointer rather than the or somesuch is another artefact of the GUI framework. It would be good if functions that need such “bad C++ due to API” are clearly labeled as such. 

We really want to get rid of legacy loops, but there is no simple way to do that given the way you wrote the algorithm. Repeating the call to each time through the loop could be avoided by assigning it to a named variable first, but if becomes as indicated in the first item, it won’t matter. However, I point out that you should get used to writing rather than in these things. For it doesn’t matter; but you will use iterators most often and you don’t want this one to look funny and make the reader wonder "why is it postfix? Oh, it’s OK for this time.) Sticking to idiomatic code makes it easier to read and maintain later. 

You do not have to write that loop at all, if you use std algorithms. sums the values, but generating the list of primes might be a bit tricky. But you do want to keep a list of all the primes! See below. Performance 

Yes. Your return type will be the base class, not the class the user was actually incrementing. That is, the requirements specify e.g. that have a return type of . Given some specific then will give a compiler error. Your base class needs to use the CRTP to make those reusable functions. 

But, you could use a simple means of forcing the result of the test to a 0 or 1 instead of the ternary operation. But, if the bytearray constructor initializes everything to zero, then you only need to set the 1’s anyway. Shift the parameter down, rather than shifting the mask up. This way you can quit early when you have nothing but zeros left in the high order bits, and it has the advantage of the always giving you 0 or exactly 1. 

and you are protected against memory leaks when the Link constructor (and its payload’s constructor contained within) throws, and for any exceptions that occur up to when you discharge responsibility for keeping it. 

The various members you have in the section taking a parameter should just be normal members instead. 

Design review or code review? Well, in real-world projects we communicate the design in its own way first, not just say “here’s code that implements my design.” I would like to see a paragraph explaining how it works in very simple overview, and a sketch showing the different types and their relationships (UML pseudo-code). Expressions.h You might put the whole thing into your own namespace. I always wonder why people use when it’s not for some huge matrix or something. is the native floating point type. Unless you are using SIMD, they are just as fast. For the enums, you might want to always put at the top, so default initialization is the most useful or natural meaning. main I see you did not cram everything into , but simply use this to drive other functions. That is more realistic for code that goes into a large project. Memory.h It is generally good to order your lines: standard library first, low-level utilities next, specialized libraries, and then the project’s own specific code. ModelData.h Double-spacing your members means I have to scroll the window to read the class. What is the point of that? I see you use default initializers and don’t write a constructor. Rule Of Zero. But, is a pointer to another member in the same object. I think that will not work properly with the automatically supplied copy constructor and assignment operator. ModelData.cpp A lot of the functions I see at the top could simply be inline in the header. takes up a lot of space for such a trivial accessor! 

Advanced From my generic above, you can see that each one is exactly the same except for the name of its own class. This suggests that you make it Generic for real. You only need one template function. The only reason I say this is advanced is because of how you’re dispatching on the type to registered functions. You might scratch your head for a moment to figure out how to take the address of a specific instantiation. Then, you wonder why you need all those lines to populate the map when they are all the same except for the type name… 

You have which can’t change with your fixed names, so why do you need that? All your code is referring directly to one or the other so you don’t loop over n players anyway. You did not make it constant. The current player is stored internally as the index. When you want a pointer to the player object, call the accessor which looks it up using the index — don’t store the pointer separately too! Follow me? Deck.cpp 

You can write this in a way to prevent defining outside the loop. More importantly, deal with errors from . It would be cleaner if it only skipped whitespace and did not also read (and return) the next char beyond that! (Hint: see the next function in your file) 

But really, look at the comment on the header's declaration! You should be passing an enum for this, not making the user figure out the mapping just so you can reverse it. 

render Same lessons explained already. Now how do you make a return value that can be a or nothing? . This function is too long. The body of “visibility state changes to visible” can go into a helper function. The body of the next statement is huge; it can probably go into its own function which can then be split up into others. Every time you have a comment header explaining what the next block of code does, you are “naming” that block of code and indicating it has a purpose distinct/different from other such blocks. A block of code with a cohesive single purpose and a name— what’s that normally called? Closing remarks Your code is a lot better than most of the code posted here. There are a lot of things about how-to that you already know. Your fluency in the language indicates that you are new to it, but you are learning from more up-to-date material compared with a lot of newcomers’ code, so good show there! Is there a book or online resource you recommend for this? 

Destructor: By making the pointer a , this now goes away completely. Don’t declare or write it! The auto-generated one is better.