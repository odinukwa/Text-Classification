Example To use the logger I first need to create a factory. Optionally I can specify automatic-properties. 

Here I find the too general. It looks like it should be called e.g. . Alternative? ;-) You could use regex to clean-up the string. 

Most databases are case insensitive so you wouldn't need this formatting adjustment if you used server side filtering. On the client it's better to use the where the is either the or then because on the one hand it better communicates the intention that you are performing a case-insensitive comparison (which is not that obvious if you use - you might be just fixing the case for whatever reason) and on the other hand you don't have to change the case twice which might introduce a new bug if you call for the first string and for the other one or forget it altogether. If you use EF or any other ORM you should filter the data on the server and not after downloading everything. With large databases this would be such a waste of resources. If is backed by Entity Framework then you could return an and still take the advantange of a server query. Why don't you use english variables names? Everything is in english but the parameters. This is not consistant... and it's difficult to get help with local names. 

Why or ? Would you know it it two months? Use constnats like or etc. or create a helper class to store the offsets: 

This time without examples because I think the usage is strightforward. You create and instance of the activator, specify the type you want to create and pass an array of dependency caditates. Do you think this DI is smart enough or does it need any improvements? 

The most important thing is to always put everything in a dedicated classes. First you need to get the currency rates from the url so the will do this job: 

In order to make your switch testable and extendable you should split it into multiple classes. One class for each operation that could look like this interface: 

It splits a string by (space, equal-sign, colon) into tokens (unless escaped) and removes quotes from quoted parts. 

An updated finbonacci-sequence (as well as the other ones) now only contain the core logic for creating the sequence: 

The last part of my HTML genrator requries a few styles. Because all styles are inline and the styling is for emails there won't be any fancy selectors, just by element, id or class. The most complex css might look like this: 

Implementing Nkosi's suggestions was a great step forward. This way the client can also recieve the response. However, there was one more thing that could be greatly improved. While reading about Queued background tasks I realized that this is exactly what I need to speed up my middleware becasue sending emails made it hang for a short time. Queueing the task in a background service allows the middleware to return immediately and take its time for emails. I adjusted the example code for my needs by not using a logger here. Instead I placed the inside the clause (and changed a couple of names). 

Let's make it more generic and declarative with attributes. This should upgrade your current solution. 

In my tests it was slightly faster then then original implementation although I'm not sure where the performance improvement actually comes from. 

@RollanIllig already said what is wrong with . I'd like to add that even if it was ok to do it then there is no need for it to use either or . It would more linq-ish if you just used and let the user execute it when he needs to instead of doing it for him. This method also shouldn't be part of this class forcing the user to use your random numbers. 

This might be very inefficient because when I see that a method returns an I assume its execution is deferred so I automatically do to execute it but what it actually does, is to iterate the list twice. First time to create the first list and then to create the second list. You should either create a real deferred method or return the so there is no doubt about the result. 

As it's already been said, using as a parameter does not have any advantages here but... it can be used as the new C# 7 feature with return values and local variables which I find allows us to greatly improve the readability of the algorithm. By using it this way we can now return a reference to an array item and also use local variables that we can overwrite. We no longer have to work with indexes everywhere. Setting the variables will set array items. 

ImageFileType property You set the file name via and then the extension... this is a little be weird. The class should be able to recognize the extension which means that the property should be read-only and return the type of the image: 

What if other exceptions are thrown like when Entity Framework could not save the data? If you want to make this bullet-proof then catching the generic might be better unless you know what you are doing and the app should really fail when something else happened. 

Finally the clones the because it's not a good practice to overwrite the parameter. It performs the calculation on a copy. Here both loops start at the bottom right corner and the prevents the second loop from unnecessarily going over the zeros. 

This is an ugly old pattern. Why don't just try the newer ? You already use in your tests anyway. In order to implement it the awaitable way you just need to use a different API, in this case and build everything on top of it. With the you can now better control the server. 

I like the idea of the class and I use similar solutions myself a lot (now improved) because they are often better then ordinary s: 

Bug There is a bug. The license constructor expects purchaseId + serial and you create a license with a serial + purchase id Constructor signature: 

The last tests verifies that is called with a fallback type which in this case is the because is not supported and must be converted first. 

I managed to rewrite most parts of it and I think it's much better now. It shouldn't be anything fancy, just a simple data validation helper that I guess most of the time will just check if something is not . Thus no stuff etc. because it should not contain any business-logic. 

Dependency Inversion Priciple The smell is that your code violates the Dependency Inversion Priciple which reads 

In order to make the exception creation really simple, I use a few helper extensions for tuples that I use to specify some or all of the three parameters: 

The can actually be simplified too by deriving it from a dictionary. By adding the search method to it you can easily use it on any node. I named it . Another adjustment you can make is to use instead of the so you can use one of the construtor overloads of the dictionary and make it case insensitive. This way you won't need the . 

Ok, it's shorter now but still, it's a lot for a filter that just uses a single property. You shouldn't use big objects as parameters if you only need a single value. Consider this: 

Sorting needs to be fast, right? So how about using a dictionary for the oder lookup and not the O(n) ? 

If you don't need to preserve the order of the elements a simple LINQ query like this one would give you the same results: 

Anyways, I think creating a few queries that can perform the few different searches you requires would be easier to maintain then a all those filters an parameter objects. 

but if the the is optional anyway why don't you simply include it in the array? It doesn't make any difference for the result and the method becomes really simple: 

I'm not entirely sure because even though you use a generic return type you use the same table for all of them: 

This repository can create default connections from the default constructor thus the constraint, or you can pass it a custom one: 

It would also be a good idea to add a message to saying something that the second action wasn't actually slower it it fails. Otherwise you'll just see a generic information. 

The extension works with enumerators. If it could not then it gets a new enumerator and tries again. If the second try failed then the collection is empty, otherwise it starts from the beginning. It uses a local function that handles the enumerator by resetting it if necessary. 

Using the in this way is usually a bad idea. It should be disposed as soon as possible. Besides this code cannot work. You pass it a but later in code you use the property which doesnt't belong to this object but to the . 

You can do it much easier because what you actually need is a way to navigate through the list back and forth. This can be solved with a simple : 

and it would implement this interface by storing the observables in a dictionary so that you can unsubscribe again: 

This might look trivial but it's a part of a bigger parser where types can by dynamically specified by a user so the lookup is also dynamic and the user is allowed to extend the type creator collection with his own implementetion. The example is just about an but I have implemented it for all the basic types and a few custom ones. There is also a that takes care of serializing various types: 

Performance & Components It's been claimed (by many sources) that this solution would waist resources by doing unnecessary comparisons or struct allocations but... the biggest waist of resources is of course LINQ and its state machine. Tunring all three methods into ones that return a makes them nearly equal. The difference between the original solution and mine averages merely to ~30ms for 10.000.000 calls. It's been also claimed (by many sources) that for an algorithm of this complexity (or simplicity) it wouldn't be necessary to use other .net components like the ... and it turnes out that original solution does not work for a grid of size 3x3 and a coordinate anywhere outside the bounds. It returns always three points whereas none should be returned. The lesson is the same as always: 

But I prefer to avoid such circular dependencies without a layer of abstraction between them because it makes testing much more difficult. On the other hand if a already knows the it's a little bit strange that the methods still requires a as a parameter. There could be a property on the interface for accessing or you could already pass to the new instance of and remove it from its methods. 

I like the ternary operator but in this case I wouldn't use it because a single expression that makes sure both variables are valid and then searching for the strings is easier to understand I think. The isn't very pretty, especially the part which actually should be . You could get rid of it by filtering the array and skipping the empty and null elements. 

this way you wouldn't have to copy/paste the repeated logic. And if it doesn't have a link or an URL then it's easier to add an to check it then duplicating the code. 

Creating query (alternative) Creating SQL like that is vulnerable to SQL Injection. You should use parameters instead. Here's an example: 

What would happen in this case? A property can construct it's value from several backing fields or even call methods. But you already know it as one of ther requirements is: 

I'm also not sure about its name. You are not filtering there so the prefix is misleading. One could there are other assesments and the private filed is even called recent assesments. Try to be consistent. Don't change the meaning without a good reason. Why don't simply name it or like the field ? 

I don't like the properties. They look like a bad design. But it's hard to say more from the snippet you've showed. 

I'd like to make the usage of my configuration framework easier so I created a few extensions that after getting a value from a source automatically assign it to a property or field. They should make retrieving and assigning setting values as convenient as possible. I'm not concerned about the performance as most of the assignments are one time operations when the application starts. 

T4 The database reflection code is compiled into a separate assembly that I reference in the template. Finally I use it to generate the actual config with a T4 template which is the first time I wrote something like this (and because of this I set the beginner tag). 

Since we don't know anything about the process before parsing JSON, it's not possible to give you any other advice. However, I'm pretty sure you don't have to read it twice, especially that you are working with streams and they can usually be connected in such a way that allows you do things only once. 

This would create a package called with rebuilding the solution but not uploading it to the server yet 

Not that I'm aware of. Once again. Where you put the builder doesn't matter. As long as you don't set anything private of the constructed object it can be anywere and it will still work. As a matter of fact you don't need the builder at all. You can create the object without it but we use a builder to make the creation of an object easier or by providing a fluent API and guiding the user step by step how to create an object but it's not necessary. Whether you do: 

You can improve the method by changing the order of operations. It is requried that the file doesn't have the extension so you should check this first before opening any streams. This will allow you to remove some indentation and put the s next to eeach other and make your code more readable. By using the you can make it still shorter. 

You shouldn't bind the implementation to any particular type in this case the . I think it would be better to drop this class and instead add a new property to the interface. You could check if the validation fails and is set to true then you stop processing other rules. If you want to get rid of the generic argument but at same time you want to keep it for other implementations then add another abstraction layer. Make the interface non-generic and add an that is derived from the non-generic interface: 

Your application is a nice candidate for the command pattern. With a few changes you can make it easily extendable and maintainable. Here's how it goes: First you need an interface for such a command. Each command needs at least a descritpiton and it must be able to do something: