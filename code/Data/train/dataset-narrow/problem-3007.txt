Bottom line I strongly believe that public presentation is only warranted when the amount of work to be presented is so vast that a synopsis is indeed helpful. Subsequently, I don't believe in immediate feedback, and especially not one produced under peer pressure. Ideally, I'd have a seminar, where students present the results of their research / lab study, followed by an assignment of groups of students to study the results being presented, followed by another seminar where the "study groups" critique the works they were assigned to. 

I'm adding my answer to already huge list of answers, but I believe I'll add something novel, not listed above: C language semantics is a mess. It is not your students' problem. C is mostly an imperative language, but because the authors didn't care to stick to one paradigm, they introduced a cross-breed of incompatible paradigms (mixing in some declarative style). In a proper imperative languages like Forth the problem simply doesn't exist. Even remarkably poorly designed Basic and Matlab had solved this problem better: they use the same imperative style, and assign values to some variables. So that you are never tempted to write something like . You want to solve this problem? Use a better, more consistent language. I understand the need to learn C, as it is an industry standard today, but it would be also wise to invest into the future by educating the students about why this language shouldn't be the industry standard. 

Some background info I've studied CS and was briefly a TA. I had to submit exercises in Java written in pen on paper. I also saw the exercises submitted by other students. None had even a correct number of opening and closing brackets, let alone other typos. My other background is in printing and typography. Having worked for a while in a publishing house, I assure you that the number of mistakes in mathematical and programming-related books is astronomical when compared to regular prose. It is not humanly possible to verify handwritten formulas in reasonable time. Every single textbook I had on subjects like math and CS had dozens of mistakes that I was able to discover, and the denser the material, the more mistakes there were. There are prominent mathematicians like Vladimir Voevodsky who try to change this situation by developing better foundations for automating proofs. I believe that this is the way to go. 

Science classes would be my immediate thought, where data can be collected to support experimentation. The most obvious metrics being weather, sunlight, etc. for biology type things (not my subject, so I'm a bit weak on examples). In physics, accurate timing and acceleration are easy to sample, so that can also be linked to experiments. In design, you might collect and analyse strain data or measure force distribution. 

The big disadvantage seems to be that you're re-enforcing their (or maybe your own) preconceptions about barriers to entry, and taking them further from the 'normal' programming environment. Yes, you can twist a spreadsheet to demonstrate some topics, but the biggest misconception you will teach by starting like this is 'everything executes in parallel'. Having moved from coding software to verilog (hardware) I can vouch for this being a major mindset change. You're also teaching a non-flat code layout, have zero scope for sensible comments, and an unusual syntax. A better approach is probably to find an online simulator (i.e. a web browser, which everyone has or can access in many countries). These will handle the code storage (in the browser or in the cloud) and avoids any assumptions about how familiar they are with specific types of software. I really think you're better identifying this as a new journey, and not expecting your cohort to have anything installed on their machines. Having supported a public drop-in class, I'd also opt for an environment which allows both 'block' coding or text based views like the micro:bit javascript blocks editor. This removes the barrier of needing to remember syntax and seems just as relevant with older introductory level students as very young ones. Once you have introduced the fundamentals (keeping the first contact easy and low stress), you can move to using text based entry. Returning to the micro:bit example, I think having a physical device is less important with an older cohort (particularly if they are in your class by choice). It gives you scope to use a demo, and show some context about how close to invisible/trivial computers are (something else that your spreadsheet doesn't expose). To summarise my objections to the proposed approach: 

It may be a hassle (is this an argument for better editors), but the time spent in keeping the code tidy usually pays off by both avoiding and finding bugs faster. Its a different (but related) question to 'would you prefer your code to be really fancy and efficient, or to work properly'? I think this latter problem is maybe easier to explain because it's more tangible. 

The take away is: We use physical formatting to help the reader understand the structure of a document at a subconscious level --- you don't have to read it, and you can identify the components and key relationships almost instantly. Then you can use your intellectual effort to understand what's there rather than "Is this one of the items that goes with that thing?" Publishers have figured these things out and honed their skills for centuries. Alas, self publishing and the web means there are a lot of poorly designed documents around. For programming, you don't want anyone to use their conscious thought to answer easy things like "Is this statement controlled by a test in a conditional? In a loop? Is this a function call or a special syntactic thing? How many arguments are there for this function?" There are enough things you'll have to think hard about, and it's inconsiderate to make your reader spend their valuable time and energy on mundane items like this. That reader might be you in 4 or 5 days even, when you've found a bug and can't quite remember what's going on in this part of the code. Exercise 2: Print out some code and then put it some distance away. E. g., stand it up on the marker tray of a white board and back up until the text is too blurry to read. I used to say 10 feet, but my eyes are bad enough now I can just take my glasses off. Just ask the students when they can't really read most of the words. If the code is formatted in a way that is considerate of a human reader, we can tell how many functions there are, which functions have loops, which have nested conditionals, all without reading any text at all. We can even pick out the more complicated functions and sometimes even spot opportunities for refactoring based on common shapes! Side note: I had a blind student once who was a fantastic programmer. I hired him as a TA, and he was superb at that, too. He was once hanging out around my office when I was talking to a student about these things, and he blurted out "I don't know why you people need that stuff! It's just 'space, space, space, space,...' and it's annoying." It's true: he takes in programs in a necessarily linear way, and he makes structures in his head that I cannot fathom. I program, and teach my seeing students to program, by drawing lots of pictures. I have no idea what he has in his mind, but it sure works! I wish I knew how he did it. 

If you want to look at hardware which might also be suitable for programming in C/C++, the BBC micro:bit might be a good alternative to an arduino. It has a more self-contained set of peripherals, and is programmed in ARM assembler. It uses drag-drop style programming (you need an ASCII format hex file) over USB. Of course, you need to set up a tool chain to compile the code, unless you want to write raw hex by hand (or analyse compiled code from the online tool chains). Halting debug (single step and modifying registers) is supported, so it's a capable platform to work on if you want hardware. In terms of a compiler for Cortex-M0 (as in the micro:bit), the educational toolchains support an in-browser compiler which demonstrates that it's not actually too complicated. Of course, there is a fair amount of initialisation required if you want to actually turn the LEDs on or look at the push buttons (let alone the SPI accelerometer on board). You might include some assembler within an online compiler C++ project - that ought to work (if you use the ARM mbed toolchain rather than the school specific toolchains). An alternative is to look at something more low-level, using a verilog simulator (but there is non-trivial cost involved in the simulator which might put this out of reach to schools - it's more targeted at universities who are teaching embedded hardware, and start-ups). The whole Cortex-M3 processor and a supporting system can be downloaded from ARM for free. This runs code (and has a model which prints out disassembly as it runs). - disclaimer - I developed this product. 

In practice, the hash function is expensive to calculate (and will have far fewer collisions meaning many iterations will be required to search for a suitable padding section). Although a single block could be modified, once the modified block has been wrapped into a subsequent block, a couple of times, the compute cost of re-writing an older message grows significantly. What this generates is a publicly readable message, which can't be re-written in the future (and everyone can verify the accuracy or an old message). 

I've heard that making the introduction to computers as more hands-on and practical is better for engaging girls than simply sitting at a keyboard and coding. One relevant entry point might be the cheap modern 3D printers (made possible by a $5 control board), which have all sorts of non-software applications - and maybe generate less bias than robots. In this sense, working with microcontrollers and focusing on embedded applications should be beneficial. There is also scope to pull in a wider range of applications in this way (health, environmental monitoring, other sciences, education) which makes the final employment benefit of taking a Computer Science course easier to grasp. I believe girls are more conscious of making longer-term career plans, so showing them the diversity of roles where Computer Science is applicable will also help. The chain from remote data collection through to data analytics (and the underlying stack) is massive. I'm not sure if there is much evidence to support the value of an mcu approach yet (some, for sure, but I think it's early).