One is clear to understand, the other could mean anything. Yet it can even make sense after we give it a comment... 

Your TargetCodeGenerator's generateAST has multiple abstraction levels embedded into one method. And it's a long method. It has all of these details that are pretty complex - when I see functionality like 

It's a shame one is a double and the other is an integer, or you'd been able to merge both into some sort of function, keeping as a function which calls with a lengthy string. 

Failing that, at the very least remove it from the else case - you KNOW it is true, there is no reason to set it to true again. 

What's happening here is that if each request takes 0.3 seconds (pretty fast), the whole page takes 14 * 0.3 = 4.2 seconds to load (slow-ish). In cases like this, there's two things you could do. 

When you hash the key, you do so via for-loop over and . These are two function calls, and String.charAt continuously checks the length. Consider declaring a char array of length , then setting it with . I'm assuming you have keys of a decent length here, and not very short. Do several performance tests for this, at different times and with different sets of data. 

In drawRoute, you first declare , and then after the for loop, you assign values. I think it'd be better if you moved the creation of so that it's created and used in one place: 

This code is just as functional as your original code. But it's both way shorter and doesn't muck about with an abstract class that you don't need. It also makes use of the interface for a variable - showing off that you can call functions on objects if you only have an interface. As for making your code actually show off the use of inheritance and polymorphism, that's up to you to figure out. 

If the cursor is null, you don't need to do anything in this function. So turn it into a guard clause: 

It's still not nice, because you have an empty if statement block. Invert the if conditional and swap the blocks. 

But you can reduce the need of comments by having self-explanatory code. It doesn't solve all the problems, but it certainly alleviates them. Except you often use single-character or dual-character variable names. Have a look at this: 

We could remove the first check with the for loop, since I explicitly check at the end if . Making the end product something like this: 

And is false. Next, the external thread calls . Because there is no other thread busy with start or stop, it can go into the method. It goes through the checks, is true, is also true, and starts a new thread (because the old one is "dead"). is set to true again... and... oh snap. Application threads: 

I think this line sums up your code pretty well. You have a strange and different way of programming. Where I'd write , You'd involve some utils class of some sort. It's not wrong, it's just different. And there's plenty more of those. Things like putting variables at the bottom of a class, rather than at the top. Or making asserts. Or putting everything into one file because that's easier to work with. Or having some tool that generates various functions at compile time based on annotations... It's not my kind of style, and I'm not used to it. I read the code in great detail, the only thing I have actual complaints on is how you handled the main class. and aren't the strongest variable names, and certainly not for code at the highest level of your program. 

Another suggestion from a linked question is that all primes are expressible as "6x+1" or "6x-1", so you could use that to perhaps iterate over every 2nd number, or over every 6th number -+1. 

There's no need to count the amount of times each item differs from the previous item, like you do here: 

then you'd be able to get rid of part of this duplication. To get rid of the numbers, you'll probably want to use a List. 

This doesn't make things a lot clearer, though. You have a variable that doesn't even get used, and a variable which indicates the maximum amount of columns. If we use better variable names... 

Just doesn't inspire great confidence. The part worries me that you'd have a lying around somewhere (which would be unheard of). The ... that's just redundant. But to call this would be wrong as well, as this contains much more than just a single . Really, this is either the class or the . 

According to your comments, "Triggers" must start with the character. However, due to the way the code will look after you implement , this is nothing more than an assertion. Personally, I feel you should remove it. 

Seems all you do here is getting a string... from either or . I'd recommend putting this in a separate function... 

You have to break it up into multiple lines because you don't want to pull the vector out of the list. This makes for a lengthy line... 

You can initialize the Collection once with Arrays.asList, using a array. Then declare it as a static final class variable and you're pretty much set. An alternative is the HashSet you described - via you'd have a filled , which is one of the constructors for a with contents: . You'll pay for the double conversion, but it should be faster than directly using a . 

It's not much clearer though. Also, in case you DO have side-effects from , then this can be worked back in too: 

You should fix your indentation. I want to review the code, but a lack of indentation makes it really hard to read it. You use Eclipse, so use this to format your code: 

Hmm... Here's a batshit crazy idea. Put a for loop inside the current for loop to repeat the bits you need. 

This removes the old value. The comments here didn't help my understanding at first; I understand that you mean to say "don't clean up empty value sets for keys here". I don't see how it will get cleaned up in time. 

Let's talk about this bit of code. First, I personally prefer 4 spaces of indentation, so I made it 4 spaces of indentation. You'll have to bear with it. (It's also a common standard, so you may have to bear with it in other places as well). I also indented the case, because it seems you forgot to indent those lines of code. 

And this is what it looks like after applying the second rule. You get much shorter code. Though, I don't think it's that good yet... I don't like the negation here: 

You should get in the habit of doing the following: If an if statement has a body of setting something to a boolean, and an else body of setting to the negated value of that boolean (e.g. ) then don't bother with the if statement and directly assign the value. If an else statement only contains an if or an if-else(if-else) chain, pull the inner chain up a level in scope. Specifically: 

Your indentation is a bit off here, with the true case of the if being indented one extra level. The else case is missing its brackets, which is probably the cause of confusion. 

But, if we change the max or min, then we also already found 1 instance, so we should just start counting at 1. We also put the counting in an else statement so that we don't count them double: 

You have these "magic numbers", where apparently, as values 76 or 83, is some character limit. Maybe you should define this as "toastSingleLineLimit", and check against that? How did you even get to this symbol count? Do you use a monospace font? What if my text is "mmmmmmmmmm", or "iiiiiiiiii"? Then a non-monospace font may end up multilining too soon or too late. Consider finding another way to deal with the issue, if possible. 

Java 7 comes with multi-catch: You can catch multiple exceptions with the same code block. By using it, you can change 

Notice the problem? (I'm not sure if using compared to prevents this from becoming a bug, but...) short-circuit evaluates. Basically, if is true, then the whole if statement is true. Whoops. 

Naturally this assumes that either of them is IN the token list in the first place. Else it will say . You could simplify your code a lot like that: 

These are your only reads from . They're ALL using . So, we can get rid of the entire array. It's a useless array. Let's get rid of it. 

Semantic type cast error - sounds like something that will either give you "true", because the element exists, or "false", because the element does not exist. Instead, it returns integer. You should rename the method to "findIndexOf" 

Unused imports - Warnings You're using Eclipse. Eclipse and NetBeans are IDE's that will probably (aside from turning them off) give you warnings about your code. An unused import is such a thing. In , you don't use . So you should remove it. Your IDE will give you other warnings from time to time. If you look at the warnings it gives you, it will help in both debugging ("hey, you're calling a function on a null variable here!") and in cleaning up your code ("Use instead of " - I know NetBeans even just allows you to click a button and it will fix it for you). Duplicate Code - Refactoring Whenever you can, try to not state things multiple times. Take this function. 

I removed some of your comments, because splitting up if-elseif branches with comments makes it VERY hard to understand. You'd think that if you see a statement like this 

Additionally, is not yet required for your first if. So leaving that one out until it's needed speeds things up a bit. And since a return statement exits the function, we can use an implicit else: 

Then the rest of your code can be indented one level less. Heck, you might even be able to move this guard clause up, thus saving a bit on performance for that case. Performance isn't the main reason to do this though; Identifying guard clauses allows you to move them away from the code doing the actual work. 

Next, you can combine your for loops to make the code faster. First, here's the three for loops we want to combine. 

And column 2 we stop because 11 beats 3. The only problem with this approach is that you need to be able to have a sparse array, otherwise you run into memory issues. This solution is \$O(n)\$. 

This is not what I had in mind. I had in mind an object. Something like an "Associative array", perhaps (array with string keys). What you have right now is condensed arguments to , . That's even less readable than , even if it condenses the argument list.