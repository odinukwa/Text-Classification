There's been similar stuff in various games, where you character becomes harder to control when you're drunk or on drugs (GTA3 et. al.), where aim stability is affected by experience/etc and also where the screen display is severely affected by different things (many RPG-FPS:es has this). I suggest you research that and see if it makes for a good gameplay component. It will make users be frustrated if done improperly, so careful tuning is required. Usually challenging, but overcome-able (...) gameplay mechanics are good. So a dim view, or laggy/overshooting (but predictable) mouse pointer may work well, but be careful with randomness. Game outcome based too much on chance aren't that fun (for most of us at least, some people enjoy bingo... but these rarely buy videogames). Personally, I enjoy "bad control" or "random jittery targets" as an occasional change to the regular gameplay, but I don't think I'd enjoy having it as a core gameplay feature. 

Good luck EDIT: I have missed the part where you wanted to make an "Animation", so if you want to move your character around you should use the physic vector3 functions that I mentioned before. In case you meant playing back a pre-made animation from some external 3d graphic program you should take the animation from the project view drag and drop it on the item that is supposed to be animated. The function is called Animation.Play 

There is. I hope you know that through the advanced analytic options inside of the google adsense you can get a lot data. You could add a blank field across the onGUI funcion. For every touch, in the spot where the ad shows up send packet to your server. Just with location. Your server will know that someone clicked, while you will not have to worry about trolls that love changing their phone time. 

I could make it a long answer but it would be a waste of time to write it, taking into consideration the fact that unity has made a great tutorial covering every step. 

Render a large quad (with your texture) to a smaller render target, performing whatever blur/downsampling algorithm is appropriate. I.e. for each target pixel, sample the number of texels from the source you'd want to combine. The simplest (and thus fastest, but ugliest) is the box filter, which usually uses 4 samples from the large texture and put their average into a single texel/pixel in the target. Repeat this step until destination is 2x2 to get all mip-map levels for a texture. There are two-pass techniques that are more efficient if you don't need the intermediate textures, and just a result, see this gamasutra article. 

For reading, it clearly depends on your platform, and what kind of input you want to read. Note that it's easy to convert one thing to another in your input layer. (I.e. poll and emit events to the engine, or listen to events and emit state to the engine.) For processing, there are a few different options: 

You can use the variable of the function. This variable is a float value of the time elapsed since last render call (Something like time from frame to frame, not exactly, but this is the idea). Simply add the delta time value to a variable and then execute the code you want when the variable gets to a specific (or random number). Generic example: 

First of all. C is not the same as C++. (They are different programming languages) Now, (trying to explain without making it too complicated), arrays are lists of variables. 

(The image has Numbers with capital letters, my fail, ignore that, shouldn´t have the starting letter in capitals) For example, is an array that contains space for 10 ints (numbers). You can access values from the array ("list"): 

Prison Architect uses "pieces" of cables, it is not all one long cable, it is a sum of lots of "pieces" (or squares, not sure how to define it): Image here (The bright green conected pieces are cables) I don´t know how they do it, and I bet they are not going to tell us, but I can tell you how I would do it. 

I used the textures from this file used in the GLUT Caustics Example for a game I did ten years ago. Might work for you too. It's an animation as a set of textures. Load them as a 3d texture for smooth interpolation when rendering, then use projective texturing to compute texture coordinates. The technique explained in the article (albeit with a pretty old OpenGL version, today you'd use a shader instead). 

You could consider running a simple PID controller in your game. It's simple to implement in a function like the one you have already. By tweaking the parameters (or computing them, there are many techniques) you should be able to get a pretty neat behaviour. Be sure to run your physics loop with a fixed time step though, as this is necessary to achieve stable regulation when implemented with discrete/digital logic (as oppossed to analog circuits....) However, some non-linear daming that Lunin suggests might be an option. That would allow the chopper to "soft-snap" to the target height. It depends on how "physics-y" you want your game to behave. :) 

There is a some difference, you will need a very good artist to make it look better from the 8k/8k. It is better to use smaller textures merged using UV mapping. If you are not a proffesional I'd stick with the smaller resolution. Epic games tries to create a product for the masses, and unless you know how to make a good lightmap it makes no sense to make shorten the game audience, not everyone bothers playing on ultra detail. As for the use of such high resolution maps, yesterday I played the game Tomb Raider 2013. I used my development pc which has the GTX Titan installed and in one scene Lara Croft picked up a photo of her and it has looked real. Like a normal photo taken by a real life camera. And you don't need an ultra res. Photo to achieve that. You can merge more smaller photos using UV mapping. Should I stick with Cry Engine or Unreal: Stay with UDK, better doc's and it is more user friendly, with over more than a milion downloads you can get more help around the game dev. If you are a team of gamers making games without good 3d modelling experience, it wont make a difference. Unreal4 engine has some features that the Cry Engine lacks. Furthermore, with Cry Engine without paying a large sum you will not have access to the engine source code, which is always easing the development.