Now, assuming you are okay with the above method of organization, you just have to manage and back up a folder! You can use any of many cloud storage solutions to do this. You could have a server somewhere and FTP everything to/from it (don't use a web server; webhosts don't like being used as backup solutions and have no reservations in deleting files if they see you using it as pure backup). One solution I highly recommend you check out is Amazon S3; this would truly be unlimited storage, as you ask for, at a cost. But the price is very low. Or, you can simulate unlimited storage by buying a large hard drive(s) and just keeping everything on it (back it up somehow of course!!). Then you have the benefit of always having fast access to your data, whereas S3 would require a (fast) internet connection. 

Due to the comment that you're looking for online content which can be read: This IS an online tutorial! It can indeed be read online! When you go to the above link, look on the right side, the third section is "Contents"; in that box, look for the links under "3D Series 1: Terrain". For example, here is one very relevant section: "Terrain from file" 

Hopefully, then, the first part of my answer might at least help lead you to better alternates to the Game Doctor. 

I only see a button to download to my Xbox 360. When I clicked it, it said it was added to my "queue", and I guess it will magically show up on my Xbox? But there is nothing I saw to download... Here is a screenshot of the page I see: (notice the "Download to Xbox 360" button in the bottom right) 

Here's a real-world example: RuneScape "ticks" once every ~0.6 seconds. You can read about it here. I imagine it simplifies things from their perspective, as in their scripts they probably specify timings and delays in ticks instead of milliseconds. And of course, with such a large/slow tick rate, users with slow connections are not at a huge disadvantage compared to other players. 

AMD Fusion is the next logical step in onboard graphics; the first step was of course "why don't we take the video card, and stamp it onto the motherboard instead!" - of course, greatly reducing the power in the process. Now they're thinking "why don't we take that onboard graphics chip, and built it into the processor". It will be low-powered, just like onboard graphics. But at the same time, integrated graphics chips have come a long way; today's integrated graphics chips can play World of Warcraft smoothly at a decent resolution, for example. I get the feeling that discrete (video card) graphics chips will remain faster than these integrated solutions (whether motherboard integrated or CPU integrated), mainly since they can be separately cooled so there isn't as strict of a constraint on the power. From a programming standpoint, the libraries and methods will not change. DirectX and OpenGL will still be the two standard low-level libraries. Regardless of how the architecture is, you still need to take some 3D data and draw it to the screen. OpenGL doesn't have a "copy some data into graphics memory" operation, it has "draw this buffer" or "draw this array". The copying is all implied and handled by the library. So in your case, if the whole system memory is GDDR and no copying is necessary, then the OpenGL driver for the chip will not copy and just draw the buffer; that's perfectly fine, and it doesn't change our programming methods at all. For a long time now there has been an abstraction layer between CPU and graphics. Long gone are the days when we, as programmers, literally copied memory from one area to another in order to see it on the screen. So now as GPU and CPU merge, we won't have to change a thing. The hardware guys can worry about the merge, and we programmers can keep on moving forward with development. 

Interesting question; having taken Physics classes, I take this sort of thing for granted, when really it is an intriguing idea. The key point is that X and Y movements are distinct from each other. An object in motion will sustain its X motion, and its Y motion will be affected by gravity at a rate which you set. You should track the sprite's X and Y velocities. When standing still, the sprite has an X velocity of 0; when moving, it has a constant velocity. When touching the ground, the sprite has a Y velocity of 0. When the jump button is pressed, give the sprite a Y velocity. Now every frame, reduce the Y velocity by some amount; this is your gravity magnitude. But if the sprite is touching ground, set the Y velocity to 0 so that the sprite doesn't move into the ground. And then modify the sprite's position by (velocity*time). Here is a decent-looking Physics lesson which demonstrates these separated velocity components: $URL$ 

From reading your question and comments, I get the sense that you don't quite understand relational databases. So I guess my biggest recommendation to you, is for you to make sure you understand their strengths; the concepts of a primary key and a foreign key are especially important. It is also difficult to discern exactly the question here - I think you're not even sure exactly what you are asking. Your actual question is "how should it happen?" and from the description you seem to be weighing the use of a database against hardcoding these dreams. And somewhere in there you seem to have a notion that a database won't be able to handle a large amount of data - which, I mean, isn't that sort of the point of a database? So if you think a database somehow can't handle some magnitude of data, you must not have much experience in the corporate world. Let me tell you, databases handle ungodly amounts of data and they retrieve it faster than you would think possible. They're made for that kind of thing. Anyway, all of the above is subjective, and if you're dead set on storing these dreams in files, by all means do so. Just make sure you know your reasons, and that they are true, measured reasons. To guess that a database is slower is simply unfounded (or I'd like to know where you got that idea). So go read about relational databases, know what a primary key and a foreign key are, and then look at this simple schema that I think is basically what you need: 

Here is a great, high-quality blog post about the reason for Wolfire's switch from ODE to Bullet: $URL$ The biggest paragraph is most likely this one: 

There is a forum thread in which some people are trying to get the OpenGL ES branch to compile for iPhone; there are some instructions there, so you might have success with it in Objective-C. Here is another thread which covers some Objective-C Irrlicht problems. At this point it's probably blatantly obvious I'm just searching around to try and help you. If these didn't help I'll just delete my answer, since I am obviously not (yet) a Mac guy. :( 

MMOs often have much more content than traditional games. If you think about it, your traditional one-player game has a mostly linear storyline, so the levels are very straightforward, linear, small and restricted. They can be scrutinized and made to a high level of detail. A MMO, however, has an entire world's worth of content, so a lot more art and content is required to match that same level of detail. It is also the case that MMOs often have many things on the screen at once; this can differ based on the game, but some games allow many people to be standing in one area (for example if there is an important event or party). That is a lot of polygons; so each character must be low detailed in order to be able to draw them all on the screen at once. Similarly, even in the fighting areas there can be a generous number of NPCs/mobs on the screen at once. Level-of-detail algorithms can be used to tune the detail levels based on how much is on screen, but then you are introducing even more content that needs to be made (each thing would then need to be made several times -- or an algorithm can try to do it automatically). 

When debugging, it's great to throw an exception. When the user has the program and encounters something that you missed, it's not; you might want to silently log the error, or ignore the call and just return from the function, but you probably don't want to throw an exception and stop everything just because there's a bug in your code unless it's a showstopper. C and C++ support assertions via assert.h; I like to use those, and this would be a good place for one. For example, at the top of the GetKey method, do an assert that the key is found. However this is also a good place for using an enum rather than a char or whatever you're currently using. That way, the programmer must use a value from the enum and there's not really a possible way to feed it anything else. 

Regarding implementing the ability to curve the ball: First of all, you'd need to know the paddle's velocity at the time the ball hits; which means you'd need to keep track of the paddle's history, so that you can know one or more of the paddle's past positions so that you can compare them to its current position to see if it moved. (change in position / change in time = velocity; so you need 2 or more positions, and the times of those positions) You now also need to track an angular velocity of the ball, which practically represents the curve along which it is traveling, but is equivalent to the real-world spin of the ball. Similar to how you would interpolate the bounce angle from the relative position of the ball on collision with the paddle, you would also need to interpolate this angular velocity (or spin) from the velocity of the paddle on collision. Rather than simply setting the spin like you do with the bounce angle, you might want to add or subtract to the ball's existing spin, because that tends to work well in games (the player can notice the ball is spinning, and cause it to spin even more wildly, or counter the spin in an attempt to make it travel straight). Note, however, that while this is the most common sense and probably easiest way to implement it, the actual physics of a bounce doesn't rely solely on the velocity of the object it hits; an object with no angular velocity (no spin) which hits a surface at an angle, will have a spin imparted upon it. This might lead to a better game mechanic, so you may want to look into this, but I'm not certain of the physics behind it so I'm not going to try to explain it. 

According to your first requirement, you are looking for a framework rather than a library. jMonkeyEngine is a framework for 3D games (i.e. it provides the main loop as you ask for, similar to XNA) but it wouldn't be a good choice for 2D. However, a game loop isn't a hard thing to write, and existing Java libraries handle your 2nd and 3rd requirements, so I highly suggest looking into a scene graph 3D library/engine or any 2D library, depending on if you're making a 2D or a 3D game. Aviatrix3D, Ardor3D, Java3D and jMonkeyEngine are my recommendations for scene graph 3D engines. For 2D libraries, you have JGame, or you can choose to use OpenGL for max speed and use LWJGL or JOGL. You could also just go with Java's built-in Graphics2D library, which would be an especially good option if you plan to deploy your game as an applet. 

Well, seeing as you use the += operator to add a button, perhaps you use the -= operator to remove one? So something like the following pseudocode: 

I believe you are feeling the effects of Gimbal lock. 3D camera implementations typically do not allow for looking directly up or down because of this (because then the forward and up vectors would be parallel). I know from experience that OpenGL can do strange things, and my simple implementation of a camera doesn't allow for less than a 0.1-degree angle up or down. If you can modify the camera's "up" vector to be something other than (0,0,1), then you should do so when you want to set its forward vector to (0,0,1) (i.e. when you want to look up). The forward and up vectors cannot be the same, though. Other alternatives include making sure the 'up' vector is orthogonal to the 'forward' vector at all times, or using quaternions. I don't know how these options apply to the Ogre3D engine, sorry. 

As a fellow Mac user, I'd like to offer an additional factor: the CPU scheduler in OS X is more "fair" than in Windows. This is sort of a complicated computer science topic, so here's a simple way to think of your CPU scheduler: your processor has to juggle many tasks at once (all your open programs, plus background system processes). It can only actually do a couple things at once (the number of cores times the number of threads per core; a dual-core i7 can do 4 tasks at once, for example). So it splits all the work into pieces, and alternates between them so that it looks like it's actually doing a lot of things at once. When you run two programs, the processor is actually just alternating back and forth between processing those two programs, really fast (like, a few microseconds here, and then a few microseconds there). The pattern for which things are executed in what order and for how long is decided by a "scheduling algorithm". For example, the round robin scheduler just arranges the tasks in a circle and processes each one in order. Another scheduler might arrange the tasks from least-to-most time remaining - small tasks would be done quickly, and big tasks might have to wait a while before being done. Windows and OS X are very different, and their scheduling algorithms are a bit different as well. Windows is a little "smarter" about prioritizing things, so it gives extra priority to visible programs in order to make the computer appear faster. OS X, however, is more fair to background processes. The overall algorithms are much the same between the two OSes (they are both multilevel feedback queues), but this little detail results in a different user experience. Both sides have their advantages. Like I said, visible programs in Windows will appear faster because they get more priority; but if one visible program decides to take a lot of power, the whole computer suffers a bit more. OS X's more fair scheduler results in more predictable and stable speeds, which is good for audio and video operations. For example if you're playing a song in the background, it's less likely to stutter when you do other things at the same time than in Windows. So, the takeaway point is this: a full-screen game in Windows is going to get high priority on the CPU and anything running in the background will just have to wait. In OS X, this is less the case. Some technical info about the schedulers is given here; the rest of this answer is from my computer science education and my usage of OS X over the past 10 months, after having used Windows for over 10 years (and Linux occasionally). I am sometimes frustrated by the more fair scheduler, but other times I appreciate its advantages. Linux, by the way, has an even more fair scheduler implementation; this is what makes it a great server, but in my opinion the user experience is degraded. For example, when your computer is bogged down with tasks, your cursor will stop responding smoothly because it's given the same priority as everything else. This basically never happens in Windows or OS X.