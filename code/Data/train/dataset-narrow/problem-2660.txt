Where takes the simulation's current position and rotation and calculates the new position and rotation based on the velocity and delta time. You likely have a function for this already, so use that here to update the simulation values. 

Don't use a random pattern, people would like to use their muscle memory to play a song the same every time. I suggest you define the pattern for the entire song, and give each position a difficulty rating. The most difficult version of the song would include all the difficulties, say 1-5. Where as the medium version of the song would contain all the positions rated 3 or below. While the easiest version of the song would only contain rank 1 positions. It would likely be easiest and most logical to build up these layers of difficulty from the easiest to hardest. On the first pass of analyzing the song, just get the most radical changes and the strongest beats. Then progress from there, filling in the richness of the song with more positions to be played. But remember that each level should also contain those before it. This will help the players progress from one difficulty level to the next. 

Really the solution here is playtesting with follow up questionnaires. From each tester, ensure you collect: 

Then you can simply calculate the force of friction with the following: friction = µ • normalForce When you're summing up your forces you include this force. If you have no other accelerations, then your friction is going to be the only force, and will slow your object down. 

You're unlikely to find a standard algorithm for doing that. Also, I'm not sure you'd get the structural aspects you want from using pure noise. I'd look into how procedural cities or building are generated, then apply those to making your own algorithm. There's a Survey of Procedural City Generation (pdf). Then over at the Procedural Content Generation Wiki, there's a good list of links related to dungeon generation. Hopefully this is enough to get you started. 

I think ClassicThunder is heading in the right direction, but he/she may be at the wrong level. Keeping an adjacency list at the Chunk level is fine, but it's not really the solution you're looking for to manage the loaded chunks at the World level. If you're keeping the actual data for your chunks in the dictionary structure, all you really need is an array of keys, in your case chunk positions. This is actually fairly simple after I've thought about it more. For knowing which chunks should be loaded, all you really need is the root position of the chunk the camera is currently over. Now, you know what size each chunk is and you can figure out how many chunks you need to be visible at a time. So once you have the root position, it's really just a few loops to give you the positions of all the other chunks needed. So for example, say you decide that having 9 chunks loaded at a time works well enough. This means the chunk the camera is currently over, plus all chunks that touch it horizontally and diagonally. That would mean the view area is no larger than a single chunk. 

Those positions define the positions and size of the shapes you have attached. For example, the top cuboid would defined as such: 

If the dart were truly random, you'd expect it to hit blue 50% of the time and red 50% of the time. So we want something to happen 50% of the time, this is what we would use. So what if we wanted it to happen .2% of the time? I means our image needs to look at bit less equal. 

Though you haven't told us what the problem is. I can see that you never initialize your velocity variable. 

Granted, if there are duplicates, this likely won't find the one you're seeing on screen. Since you're drawing tiles by iterating through the list, this means in the case of duplicates, the last instance of a tile will be drawn over the others. The code above will find the first instance of a tile at a specific position. All in all, I suggest you try again with this code. Rewrite it with the requirement of accessing an arbitrary position in mind. Think about how a two dimensional array might help in that situation. Also consider how you're placing tiles and if they're actually ending up where you want them to. 

I'm not a lawyer, so this is just my interpretation of the law. Before you release anything, talk to a lawyer. Your legal decisions are your own. Names of cities are not protected trade marks (yet?), you can use them how you like. You may also look into giving the city name as the default and allowing the player to change the name of the team if they desire. As far as other games that may employ similar methods, I don't know, and it's not really on topic for the site. 

There's some tweaking you can do with this one, altering the grid size to make for finer details, and using some kind of marker on the map to ensure the grid is aligned properly. Another option: 

That sounds pretty complex to me :/ As an alternative, perhaps you can make a scripted tutorial that the user can step through. If all the events are pre-determined you won't need any AI at all. Otherwise you'll need to break down each component (as DampeS8N suggests). Identify the actions you'll need your AI to take. Finding a path, targeting a "thingy" and hitting it away are all things you'll need to do. As you delve deeper into this, you'll find a dozen more little things you'll need to detect/react to. 

You should swap the last two with each other OR the first two with each other, if you want clockwise order. Ensure that you also look at the tutorial I linked. It will describe the proper way to draw the quads. 

Picks a random number between and , the divides by . This gives you a random number between 0 and 100. If that random number is less than or equal to your chance (), then the statement is true and whatever is inside the if statement is executed. If you want to get a .2% chance, that means that for every .2% of the times you run this code it will be true. So how do we do that? Pick a random number between 0 and 100, if it's less than .2 it's true. Throw a random dart at this image: 

Same deal, cars should be damaged based on the severity of the crash. For example a head on collision would be devastating, but a side swipe would be barely anything. 

Any kind of art work that allows you to see what's happening is great. Whatever you need to be able to: 

Just Google , there are plenty of useful results, including one that has a code example It's just like a open bezier curve, but for the "next" point on your last point, you use the first point. 

The shader will compile and run, but will only render lines (or whatever the last primitive defined is). So how do I define a single geometry shader that will handle multiple types of primitives? Or is that not possible and I need to create multiple shader programs and change shader programs before drawing each type? 

Think about what you need to do, open the door over time. It's not going to happen all in one call in the function. You'll need to add a little more rotation each frame to rotate the object smoothly. Something like the following will rotate the object from 0 to 90 degrees over time: 

Notice anything about all those options? They're all rigidbody types! You need to add a component to your cat!. It's up to you if you want the non-kinematic or kinematic. 

I don't play a lot of racing games, but the ones I'm familiar with will cause a slow down + damage. Unless the accident is really bad, then the car will be destroyed on impact. 

Where your plane is the center of the white circle. You can see a live example of a similar behavior here. Also giving a enemy jet the flee behavior when they're targeted will make it a little more challenging to hit. (Have them flee from the firing cylinder that represents the kill zone in front of your plane) 

You can use integers for the inputs to your physics system. Although you're likely going to have to use non-standard units of measure. Typically we see meters per second, kilograms, etc. Using smaller units just so we can more easily round the values to whole numbers isn't hard, it's just kind of silly. However, as soon as you want to perform any calculations, you're going to want to use floats, not integers. Any formula that has a division involved is going to want to use floating point values. The reason we use floating point values is because it's closer to what we use in mathematics and real world physics. There's no reason to constrain ourselves to integers. Floating point calculations are very fast on modern CPUs. 

Yes, it's typical to convert into triangles. When reading the mesh in, it's simple to convert a quad into a triangle. It will depend on the format you're exporting to. For example, the format I use, Blender will export all the vertices, then it will export index information for triangles and quads. So it's a simple matter of arranging the indices to take a quad and create two triangles. 

You either have a compile error in this script, or you have one in a different script. If this is the first time you're trying to use this script, the entire solution needs to compile before Unity knows about this new class you're introducing. Locate your error and correct it before trying to add this script. It could be a compile error or something like a name mismatch like SanSolo suggests. 

Using the names of other games should be OK under fair use, specifically nominative fair use. Where the qualifications for nominative fair use are one of the following situations: 

The benefit is pretty obvious. It saves you a lot of work. That's the purpose of the engine. Android will come with the basics, but a game engine will have already implemented a good deal of the tedious work required to create a game. Perhaps you haven't looked into it much, but there's still a lot that a 2D game requires that's not part of the base Android SDK. As you'll hear from lots of experienced developers, make a game not an engine. Obviously you know the requirements of you game best, so it's up to you if you want to use an engine or not. You may want to just pick and choose among the various libraries available instead of going with a full blown engine. 

Just use the Vector object. Even if you feel this is/has been used incorrectly in the past, it's what people expect. Plus, it's not necessarily incorrect to use a vector as a point. And would difficult to do outside of discussion since both data structures require the same primitive types. The only differences will be the member functions, and it's easy enough to put those in the same class, since there's not much in the way of conflicting methods between the two. Since you're learning, it's good to learn that doing what people expect is often the best way to do things (for trivial choices like the one being presented). 

Have you looked into flocking algorithms? When I look at your description that's what comes to mind for me. There's lots of articles around for this, here's one I like. Likely you won't be using all the aspects of flocking, like cohesion. Most of the aspects would be useful for what you're trying to do, like alignment and separation, both of which would help in avoiding collisions. You'd end up with something a bit different than flocking, but it should help you get started. Good luck! 

Finally I don't think you should worry so much about optimizing right now. You can optimize forever. You'll never finish your game like that! You can worry about making it neat and clean, but not necessarily optimal. If something is really bugging you, just add a little comment for later defining how important you think the optimization is: 

You have lots of options here. You can also assign the object manually by dragging and dropping the health GameObject onto the new script's field in the inspector (if you do that remove the code in the method). Or you could use the event system, or lots of other options. I've also noticed you're using the old method of creating your GUI. I'd suggest moving to the new GUI system recently released from Unity. It's much easier to use and provides a lot of functionality for you automatically. Additionally, for someone who's new to Unity, it allows a lot more work to be done solely in the Unity editor, which means less scripting and more game making.