I am working on a problem in which polygons are decomposed in a way similar to triangulation. Before actually decomposing the input, we have to classify the polygon in one of two categories: 

Even when $\delta$ is a total function, it doesn't seem to be an easy count (for me, at least). The graph might not be connected, and the states in the connected component containing the initial state might all be accepting, so, for example, there are many graphs of size $n$ accepting $\Sigma^*$. Same with other trivial combinations for the empty language and other languages whose minimal DFA has fewer than $n$ states. (A na√Øve) recursion doesn't seem to work either. If we take a DFA of size $k$ and add a new state, then, if we want to keep determinism and make the new graph connected (to try to avoid trivial cases), we have to remove a transition to connect the new state, but in that case we may lose the original language. Any thoughts? Note. I updated the question again, with a formal statement and without the previous distracting elements. 

I think it's undecidable, but I don't have a proof. Intuitively, if $s\neq qr+p$ for all $p,q\in\mathbb{Q}$ (i.e. if the answer is "NO"), then you will be always looking for a "next" pair $(q,p)$ such that $|s-(qr+p)|$ is smaller than before. You don't really have an argument to decide when to stop and return "NO" because, for all you know, there is a better approximation to $s$ of the form $qr+p$ than the one you already have. 

However, in I5, the subpath 3-4 (in red) does cross the subpath 6-1 (in black), and we don't want this. 

Why D1 is not the same as I5 If you follow the path given by the ordered edges, you have that, in D1, the subpath 3-4 (in red) does not cross the subpath 6-1 (in black). 

How to define this? We're trying to find a definition for these cases. As I said before, "simple" is not enough, but what's more important to us is that the definition should be (if possible) algorithmic, in the sense that an (efficient) algorithm, not a human, should decide whether a given polygon is decent or not. Also, we are willing to relax a case or two if there is a definition that works for almost all cases, but provides an efficient algorithm to verify it. I don't know whether this has been studied before. Feel free to point me to the appropriate literature if you think it would help, but I have checked a few references and all I've found ranges from "we will assume all polygons are simple" to "non-simple/degenerate cases are left as an exercise". 

The question is simple and direct: For a fixed $n$, how many (different) languages are accepted by a DFA of size $n$ (i.e. $n$ states)? I will formally state this: 

That depends on how you define the computation process. If you consider that the TM executes all possible computations at the same time ("in parallel", if you want) and then decides if accepts by looking at the states in which it finished, then obviously it will always halt after the same number of steps for a given input, or never halt at all. On the other hand, if you define a run of the TM as one possible execution, and define that the TM accepts a word if there exists a run that ends in an accepting state, then the answer is "no", and it should be pretty simple to define a TM which halts after different number of steps for the same input on different runs (for example, one that accepts in a run, but ends in an infinite loop in other run). 

Why D2 is not the same as I3 In our application, D2 is different from I3. There is no overlap in D2 and its interior can be seen as a shaded area in the following figure. 

Consider a minimal DFA $\mathcal{A}=(Q,\Sigma,\delta,q_0,F)$ and its accepted language $L$. Assume that $Q=\{q_0,\ldots,q_{n-1}\}$, and consider the automaton $\mathcal{A}_{\times}=(Q^n,\Sigma,\delta_{\times},q_{\times},F^n)$, with $q_{\times}=(q_0,\ldots,q_{n-1})$ and $\delta_{\times}$ given by $$\delta_{\times}\left((q_{i_1},\ldots,q_{i_n}),a\right)=\left(\delta(q_{i_1},a),\ldots,\delta(q_{i_n},a)\right).$$ On input $w$, $\mathcal{A}_{\times}$ simulates $\mathcal{A}$ processing $w$ starting from all possible states, so, in particular, $$\hat\delta_{\times}\left(q_{\times},w\right)=\left(\hat\delta(q_0,w),\ldots,\hat\delta(q_{n-1},w)\right).$$ We define now a relation on $\Sigma^*$ by $x\star y$ if $\hat\delta_{\times}(q_{\times},x)=\hat\delta_{\times}(q_{\times},y)$. It is easy to see that $\star$ is an equivalence relation. Moreover, for $x,y\in\Sigma^*$, $$x\star y$$ if and only if $$\hat\delta_{\times}(q_{\times},x)=\hat\delta_{\times}(q_{\times},y)$$ if and only if $$\hat\delta(q_i,x)=\hat\delta(q_i,y)\text{ for all }i=0,\ldots,n-1$$ if and only if $$x\sim_L y,$$ so $\Sigma^*/\sim_L=\Sigma^*/\star$. In particular, since $\mathcal{A}_{\times}$ has $n^n$ states, we can choose a representative for each element of $\Sigma^*/\star$ (and therefore of $\Sigma^*/\sim_L$) whose length is at most $n^n$ (a representative for the class $[w]_{\star}=[w]_{\sim_L}$ is a shortest word that takes $q_{\times}$ to $\hat\delta_{\times}(q_{\times},w)$, and the length of that word is at most the number of states). Thus, any algorithm that processes all strings of length at most $n^n$ will cover all equivalence classes of $\sim_L$ by means of at least one representative per class, which is what I wanted. In other words, $n^n$ is an upper bound for the length of the smallest representative of an arbitrary class in $\Sigma^*/\sim_L$. 

since, in $\lambda$-calculus, you define objects (terms, which you may call numbers) and operations within those objects. 

There is no such thing as a calculus, but there is a well-defined mathematical object called algebra, though the word has many uses. However, my guess is that the name was given in the sense of 

I was wondering whether there is a ``better'' (I will explain in what sense) algorithm to start from a DFA $\mathcal{A}$ and construct a regular expression $r$ such that $L(\mathcal{A})=L(r)$, than the one in the book by Hopcroft and Ullman (1979). In there, the sets $R_{ij}^k$ are used to represent sets of strings that take the DFA from state $q_i$ to $q_j$ without going through any state numbered higher than $k$. This construction, although obviously correct and very useful, is rather technical. I'm writing a monograph about algebraic automata theory and I don't want to distract my audience with too many technical details (at least not with details that are irrelevant for the results I want to show), but I do want to include a proof of the equivalence between DFA and regular expressions for the sake of completeness. For the record, I'm using Glushkov automata to go from a regular expression to a DFA. It seemed more intuitive than $\varepsilon$-transitions, which I didn't define at all (again, because I don't need them). What other algorithms are known to go from a DFA to a regular expression? I value simplicity over efficiency (that's ``better'' for me in this case), but that is not a requirement. Thanks in advance for your help! 

This is useful because $\equiv_L$ is an equivalence relation for every language $L$, and a language is regular if and only if the index of $\equiv_L$ (that is, the number of equivalence classes) is finite, as per Myhill-Nerode. Now, I would like to define a binary operation $\cdot$ on $\Sigma^*_{/\equiv_L}$ as: $[x]\cdot[y]=[xy]$, where $[x]$ is the $\equiv_L$-equivalence class of $x$. This $\cdot$ will be operation that will give $\Sigma^*_{/\equiv_L}$ the structure of a monoid. My question is: Is $\cdot$ well defined for an arbitrary language? How do I prove it? So far, my approach has been trying to prove that the definition above is equivalent to: