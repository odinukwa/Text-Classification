There's an additional complication, in that each can contain a new repetition of the entire structure, beginning again from . This nested content, however, is essentially spurious and should be ignored for all practical purposes. Anyhow, to apply the numbering to the inner sections (and simultaneously ignore content in the aforementioned nested sections), I'm currently using the following code: 

Globals; I would prefer using ids on the input fields (or even better, a jQuery selector) to retrieve them rather than going through . Like: 

I have a list of elements (well, nested lists of elements, really) that the user can reorder (using jQuery ). A simplified view of the structure is something like: 

This works, but as the notes I found that filtering using is incredibly slow. If I don't filter on , then what happens is that nested instances affect the count, and the numbering is incorrect (numbers jump like 1, 8, 17, 32, etc.). Can anyone suggest an alternate approach that will produce the same results without the performance hit? 

Note that this allows you to easily pass the field itself to , instead of just an arbitrary key. Functions; I'd recommend the following style when writing functions: 

That will do the same thing as your code. Also, please consider using variable names that are not just single-letters. 

Each inside of is sortable, and each inside of is also sortable (independently of the other sections). Each element within these sections is numbered according to its position in its own list. So to continue with the example above, the correct numbering is: 

Globals; Even more than above, I'd prefer not having these globals at all. Instead you could retrieve them as needed in your functions (and/or pass them in as parameters). Event Handlers; If you're just going to use the and attributes, there's no need to bind them programmatically. You can set them up in your markup instead, like: 

Is there anything that I can do to improve my function? I'm especially interested in the use of storage types other than and what the advantages of doing so would be. It should also be noted that I do have an intention of doing something like this in a however, as this was quickly thrown together for the solution that's parked for the time being. I'm less interested in my method of solving Problem 16, however any comments on that would also be appreciated. 

As part of a first year university course in computer architecture some time ago we were tasked with learning 8086 ASM. The final course work required creating a small animation of shapes moving around the screen changing colours and the like. As I would not expect anyone to review 720 lines of assembler I'm just going to provide my implementation of Bresenham's Line Algorithm. Note that this is not the entire program but a single macro from the working program. Also note that at the time of writing I had little to no experience with 8086 ASM (I still don't in fact), but I'm very interested in knowing how I did and how it could have been improved upon. If anyone is interested in reviewing the rest of the project as well (it can be done in small parts) then let me know. 

I'm writing a very simple engine which I hope to use to create a game at some point and felt that I needed buttons to allow the user to select options in a menu, so I wrote up a rudimentary button class. Think of this as similar to Windows forms if you like. Whilst what I've produced works and I can detect the button presses I feel like this is not the simplest way to do it (although note that I would like to do it myself as a learning exercise rather than using an existing library to produce the buttons). One of my biggest problems is that the buttons are done using rather than and so have a top left anchor and working based on window width and height in pixels rather than a center anchor ranging from -1 to 1, needless to say this makes rendering buttons a chore. Any advice on how to improve that alongside general scrutiny would be much obliged. display.h 

There is no need to create a new string at each iteration. You can directly append the subslice to the array like this: 

As returns an array, we get directly the result in proper format, so we can avoid js mapping and filtering. so the final script is: 

Some results on my machine (ubuntu16.04) , with a similar dataset ( 100 000 000 docs in data, 20000 in datagroup) New script runs in less than 5s : 

I prefer joining errors with a line return () instead of a comma, but it's just my personal taste. Multiple errors would be printed like this: 

1. Readability It's always a good idea to run and on your code to detect common style mistakes, here mainly comment/error message formatting. The name might not be clear enough. Maybe is enough? The function is not a good way to initialize a . Instead of 

It's easier and nicer to read 2. Use range loop instead of switch Instead of specifiying behavior for 3 cases ( 0, 1, default), we can use a simple range loop So this 

An other easy optimisation would be to create an array with the correct capacity to save an allocation at each iteration, as we know that will have the same length as : 

All errors (type error, required flag missing ect...) are handle directly by the library Now the complexity of the function is 3 

2. Make sure that arguments are valid if is <= 0, the program will panic. A little check after could prevent this: 

Possible improvements: Currently, if an error is thrown somewhere in the code, the program does not stop but just write the error to . It may be better to return this error and then call 

Recently I've been doing some experimenting with RPN and the shunting-yard algorithm, in order to test these systems more appropriately I planned on writing a tokenizer and then using these tokens to check validity and eventually get some output. I also think that I could use this to work with some primitive programming language, such as making a CHIP-8 assembler. Function The intention is for my tokenizer to separate the input string into a list of the following: 

Will not come out as the numbers they represent but can be reconstructed later on. But sequences such as will come out as making it easier to account for multiplication of variables. Questions For the most part I'm quite happy with this code, a couple things that I'm interested in (alongside general review) are: 

The reasons for these questions specifically is that I like concise code, writing it on few lines without having any too long. Code 

I'm working through some Project Euler problems using C++ and some of the numbers in question are starting to get quite large (21000 for Problem 16) and I need to add some of these large numbers together, so I quickly threw together a string represented (positive) integer adder: 

Note that this would require a few changes to make it work but would result in there not being any recursion hidden away. 

From this code review I'm most interested in comments w.r.t the genSamples function, the program as a whole seems to work well for frequencies between 20Hz and 18000Hz although there are some strange distortions after that as my sin wave becomes distorted (normally I wouldn't be able to hear 18kHz+ but as the the distortions are clearly audible). Any suggestions on how to improve the wave generation functionality would be greatly appreciated. Note I am aware of PEP8 and I am less interested in the styling of the code as this was just a quick write up to test what I'd been reading and to try out a couple of things, the code will be tidied when I more fully understand what I'm doing and how I want to continue. Until then I'd appreciate it if just the functionality of the code were to be critiqued. Also note that the current setup of the code takes some time to run and any performance gains that are possible would also be appreciated. 

I don't see anything in your code that should cause any performance issues. You're not doing anything iterative, or performing any complex operations; your code just executes linearly and changes some CSS properties. That shouldn't kill performance. Have you seen anything to indicate that this code does kill performance? If so then the only thing I could suggest is changing the events that you listen for (or maybe, adding some logic to ensure that you don't start a new transition while the current one is still running), as perhaps the page is triggering more and events than you expect. Premature optimization is the root of all evil, and all that. Also, you should be able to do: 

No, I wouldn't say you're using too many variables (except for , which doesn't appear to be used anywhere). Not enough functions, though. And perhaps too many spurious assignments. Specifically, I'd suggest something like: 

To provide some background context, I'm implementing a web-based solution (Java, Spring, Hibernate) that allows the creation/authoring of task-centric workflow documents. Basically a workflow provides an ordered collection of tasks (and related content) for a user to step through. One of the available task types is a "risk assessment" matrix, in which the user selects a "risk" level (i.e. "how likely is it that this thing will break?") and a "consequence" level (i.e. "how bad is it if the thing does break?"). Based upon their input, some text provided by the workflow author will be displayed. Essentially these tasks are backed by a 5x5 matrix of strings, and by selecting a "risk" and "consequence" level, the user is indicating a position in the matrix. There's one further complication, in that all text provided by the document author must support internationalization. To deal with this I've implemented an entity, which simply refers to a collection of entities, each one of which specifies a language, and a string of text in that language. That all works fine. What I'm wondering about is, what's the best way to store the matrix itself in the data model? I can't just serialize an array of Strings, as each position in the matrix is actually occupied by an instance and not a . I suppose maybe I could serialize an array of ids, but that seems fairly hacky, doesn't it? Under my current approach, I've explicitly declared a field dedicated to each position in the matrix. That makes for 25 getters and 25 setters. To avoid having to deal with that nonsense, I added some helper methods that take advantage of reflection in order to get and set fields based upon their matrix position, in standard notation (I use a two-dimensional to transport the matrix data to/from the rest of the application). What I'm really after is the cleanest, most convenient way of managing the matrix content. I think what I have is fairly reasonable, but can anyone think of a better approach? Here's the code: 

I've recently started learning OpenGL and thought that a great way to start using it in its simplest form would be to create a Chip8 emulator using the keyboard callbacks and graphics that GLFW and OpenGL provide. As this question would be too large to request a review on my classes used with OpenGL and my Chip8 emulator, I'll keep it to just the Chip8. 

Following the review of my old merge sort implementation here, it appears that the biggest improvement to make was to use iterators instead of copying the s. Having never used iterators before, I'd like a review of the new code following that review: 

Edit: Thanks to @ratchetfreak for pointing out a bug whereby I was overwriting elements of without storing the overwritten element elsewhere beforehand (essentially losing it). 

This indicates that a few of your opcodes may be functioning incorrectly (although it could be a deeper issue), it might be worth running your emulator alongside another to see how they compare. 

I'm dereferencing a lot of iterators in order to swap and assign values, is there a better way to be doing this? Is this implementation better than my last implementation? I'm looking for answers that think about stability, efficiency in terms of speed/memory, etc. (Possibly an obvious question) Also, I know nothing about templates, is there anything more to it than adding the line then line before the function and then using within it? I can't figure out how to get rid of . Obviously this goes against the templating, how should I store the results while I'm doing the merge? (Edit: since looking back at the previous accepted answer, I figure I should create a new vector outside the original call to (inside ) and pass the of that array as the destination, rather than defining a new array inside each call and using . Is this correct?) 

Don't panic The code shouldn't panic on every error. For example, if the user running the program don't have the permission to read a file in , the program should not crash but rather log the error so avoid method like this: 

The function should not exists either. Intead, as @Josiah already said, intantiate the generator with a seed: 

Then, the datagroup collection is filtered using and . On really big array, this can be really expensive as javascript is quite slow. Instead, we can let mongodb do this operation with a simple query using : 

Before addressing your concern, a few things on coding style: Coding style This can easily be detected with tools like golint and go vet 

Your program works fine and you are correctly using goroutines, but the code isn't very idiomatic. Producer/Consumer architecture What we have here is a typical producer/consumer scenario. The producer is wich returns a list of files, and the consumers are goroutines executing on file content. So instead of the method, we could just have a : the producer sends file names to the channel, and the consumers loop over it and parse the file content. This have two main advantages: 

Work on []byte rather than on string This is a general advice regarding performances: always prefer working on instead of working on to avoid extra allocations. The regex package has methods to work on string or on byte slice, so instead of 

from now, we can check that we don't break anything when modifying the code. We can also accurately measure the performance gain... 3. Results We can see a clear performance improvement with the new code: old code: 

Your implementation is really nice, however you could get way better performance with an array of bool! generateSieve with a : 

As a small suggestion, I noticed that your s have an odd line at the right hand side due to drawing them with the outline of an oval (as you noticed and commented in the function). You can fix that by instead using two filled ovals, a big one which is filled using and a smaller one filled using (Although this does require adjusting the to compensate for the missing width): 

The following is a .wav file generator that I wrote briefly while (re)learning about audio sampling: 

I'm aware that not all op-codes have been implemented as I have only implemented the ones needed to get the 15 Chip8 games that I have copies of running. The code that I am most interested in having reviewed are the chip8.h and chip8.cpp files however I have included (the majority of) main.cpp for completeness. An update that I would like to work on would be to switch from using a statement to using function pointers but would like a hard review of the current working code before I begin with that. Thanks to this tutorial which I used to get started and for opcode . chip8.h 

The tick rate of the CHIP-8 doesn't directly affect framerate, indeed frames act slightly differently than normal in that not all games will necessarily clear and redraw the entire screen. Perhaps a better name for this would be or and it may be worth increasing it to get a more playable experience. 

Something I'm less sure about as I haven't implemented a CHIP-8 emulator in some time is that it doesn't appear to be functioning 100% correctly, although some games are certainly playable. As far as it running is concerned, I picked of a few games to see how they ran, I had no problems with: