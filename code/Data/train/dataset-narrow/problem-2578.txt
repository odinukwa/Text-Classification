Currently i'm working on a sprite system which will have frames which make animations. Usually a sprite contains current position, current frame number to be displayed in the running animation, etc... This is what I mean is STATE. Let's say there are 100 NPC characters in a game which will have different animations running at any time.If we are maintaining the state in Sprite class, we usually create 100 sprites and draw it as each sprite has its own state. But I feel the same thing can be done like this, Imagine, position and animation state is separated from the Sprite class.When ever we want to draw we will just set it and draw the frame at certain position.With this approach there is no need to have 100 sprite instances.We can make the exact above situation with one single sprite instance. For me I feel separating the "state" kills encapsulation.But at the same time it will have a benefit in terms of huge memory! Please give your Pros/Cons on this kind of approach? 

I haven't used Corona.It needs a license if you need to publish.Cocos2d on the other hand is really flexible and stable 'graphics' engine right now. I would suggest Cocos2d-x (C++ version) as objective-c version has some performance issues when your update cycle is Overloaded.This performance issues is ONLY because of the message passing System in Objective-C. As others said,You need to depend on the support of 'third party Engine' if any thing NEW comes up!But cocos2d is flexible at that moment! If you are targeting multiple platforms,Cocos2d-X is ready for that as well! Check this link - $URL$ 

Many games have certainly taken this approach. The most recent example I can think of is Bastion. If you hang out in the Bastion for 2-3 minutes, you'll eventually hear the background track fade down then fade up again as the background loop restarts. This is kind of lame. It's possible to make your background loop more dynamic. To make you background loop more dyamic, think about decomposing the loop into its elements. For a given basic outdoor background loop, you can probably put in these: 

There's also the original Cocos 2D, as well as Panda 3D. Haven't done a lot of game programming in Python. I just know that if you want to try anything more than the absolute basics with audio in Python that you should avoid pygame like the plague, or at least find an alternate sound module. 

I haven't used Box2D itself (only ports and things based off of it), but the name "Box2DDebugRenderer" suggests that you should not render anything that should be in the final product whatsoever based on it. Use it to draw collision bounds and collision contact points. This is very useful visual information to see while you're developing your game. The game itself should have its own renderer. Isn't that part of what LibGDX is supposed to provide? 

Consider manipulating your layers at runtime. Enabling/disabling collisions for certain objects with entire layers Physics.IgnoreCollision and Physics.IgnoreLayerCollision allow you to disable collisions between two colliders, and between two layers, respectively. If you want to exclude a specific collider from collisions, there's no built in way to do that. If you are using non-kinematic rigidbodies with non-trigger colliders, there will always be a response even if you try to filter out the responses by tag. The way we accomplished this on our project was to create a layer named "Void". Void does not collide with anything at all. Now you can temporarily disable a collider's collision by setting its layer to "Void", and re-enable it by restoring its old layer. Here's the gist: 

it's performance hungry, especially for the memory ( RAM and CPU/memory controller ), this also means that to run a simple game you need at least a computer with medium range specs the JVM it's not standardize, especially on Mac, the first official Java version on Mac is the actual version ( Java 7, first and only one ), the previous versions are provided by Apple and are not standard, especially for the part related to the window system and the graphical appearance, also in many GNU/Linux installations the default JVM is OpenJDK and not Java from Oracle Java generates bytecode and not compiled code, even if you obfuscates the code it's really really easy to crack, sometimes it's also easy to do reverse engineer If you distribute java code you are implicitly asking the user for installing the JVM, most of the users do not have this abilities and most of the times they just expect that your program will run/install right after the download without additional software for what i know Machinarium is in Flash ( probably even worst than Java ), the original one on PC/MAC/Linux, the others are porting. if you are interested in Java and you want to code games, do yourself a favor and just use C# 

Yes, also this is a common scenario for both desktop and mobile users, with OpenGL the fixed pipeline approach is just deprecated and when using old code on modern devices you are just guessing, because any GPU maker that wants to stick with a modern OpenGL approach is not forced to support old functions and the old approach for the pipeline. These days you get OpenGL ES 2 capable devices from the low end market up to the high end, and the OpenGL ES 3 will come soon, adopting OpenGL ES 1.x is just an old and deprecated approach for the market of today. OpenGL ES 2 introduces the programmable pipeline on mobile devices discarding the old fixed-pipeline approach; probably for this reason you find it more difficult to use, but just a change of mindset and some hours passed on coding will make you change your idea about this. 

So now we've got a TeleportTriggerProperty class, and this is where the teleportation actually happens. When OnNewParent() is called, it adds a listener () to the OnObjectEnter signal. That way, whenever an object enters the tile that this TileProperty is attached to, it can teleport that object. 

Usually, no. This sounds like an unnecessary layer of indirection. If there will only ever be a single type of PositionalComponent (which is useful to enforce, since an entity's transform data is so foundational to a game, it should be reliable and predictable without much effort). Even if you could dynamically add these getX and setX functions (which you seem to be suggesting is a feature of haXe?) those property names are ambiguous. Why not just set via ? And there doesn't really need to be a DI setup to instantiate a new PositionComponent for a shipEntity that needs it. If an entity doesn't have a position component, either don't dynamically add that attribute, or do some null checks. I say "usually" because for specific instances of specialized implementations of abstract types, DI could have some use. 

LÃ–VE isn't as a library that you import into Lua. What it does is embed the Lua interpreter and expose its game functionality to that interpreter. If you'd like to interactive play with the API, there's a couple of libraries built for debugging and live coding: 

You know the length going from the red line to the top of the blue line, right? Then you can apply some basic trigonometry. The blue line and the red line are the legs of a right triangle. Your desired line from the camera to the red line in the direction of the raycast is the triangle's hypotenuse (origin at the camera): Given an angle, between the hypotenuse and some leg of a right triangle: