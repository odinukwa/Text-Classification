How did you install phpmyadmin? This problem indicates that php scripts are not configured to execute in that virtual server. If you installed using apt-get, it would definitely not be expected to work in a Virtualmin default configuration (though you'd get a 501 error instead of downloading the file), because Virtualmin sets up suexec for all virtual servers. Suexec is a security feature that causes scripts to be executed as the owner of the virtual server account rather than the Apache user. The phpmyadmin package from Debian/Ubuntu apt repositories runs from within the default document root, and would need to run as the apache user. So, you'll need to either disable suexec for the virtual server you want to run it under, setup a virtual server specifically for this install of phpmyadmin that has suexec disabled, or install phpmyadmin in the public_html directory of the virtual server you want it to run under and owned by that user. Suexec will not run applications not owned by the owner of the domain or outside of the suexec docroot (and your phpmyadmin is presumably owned by the apache user and outside of the suexec docroot). But, your specific problem is that php scripts are not being executed in the location where phpmyadmin is installed. As for security, there are three things that are the most common sources of exploited servers in the wild, and they aren't related to any of your questions: 

classicmanpro did a great job covering most of the differences, but I'll try to clear up the confusion here about resource usage. Virtualmin is a module of Webmin. You can't have Virtualmin without Webmin. Resource usage of Virtualmin, by default, is a bit higher than Webmin by itself, but it does not have to be. Virtualmin enables caching and pre-loading of a number of libraries, making the default memory usage somewhere around 110MB, while a normal Webmin install on a 32 bit system will be only about 10-12MB. You can easily disable the caching and such that Virtualmin does to make it use exactly the same amount of memory as Webmin alone. There is documentation about this here: $URL$ Usermin is a webmail client, with some extras. If you need to manage your server, then you need Webmin, or Webmin+Virtualmin. Usermin may or may not be a useful addition. I like having it on servers that have mail, because I can check mail with my phone (there is a mobile theme that provides a pretty nice UI on WebKit enabled phones like iPhone and Android phones). Resource usage of Usermin is similar to, but separate from Webmin (Usermin is not a module of Webmin; it is a separate server, and it drops privileges and performs actions as the logged in user, making it safer for some use cases). i.e. Usermin on a 32 bit system takes about 10-12MB of memory. In short: 

I don't see any reason this would be a bad idea. Staging implies a non-production service, so you can have all your staging happen on one server without concern for redundancy, performance, etc. One other reason for separating applications and instances of applications is for security, but once again for a non-production service this is less of a concern, unless you host a copy of your production data on your staging server (which is another type of separation to think about). If there are security concerns, and you can't use subdomains, you could still use proxying in nginx to divide the instances up across multiple VMs. But, in the simplest form, you'd just run them all on the same instance, and use 'location' directives to determine what app each path runs. nginx doesn't care how you divide up your applications, though you'll need to configure a different proxy configuration (either different ports or different locations for configuration files, depending on the app server) to each application server based on the directory. How you do this will depend somewhat on what your app server is, which you have not specified. For example, with Ruby using the Passenger application server, you would follow these instructions: $URL$ Notice that Passenger hides some of the implementation details from you, so you don't need to think about ports, only directories. Whereas in the following example, you'd specify the port for proxying and it would need to be different for each application instance. With Perl Mojolicious, you could follow this example: $URL$ Note that the section in either example can be replicated for as many paths as you need independent instances of your app. It's the same as running multiple apps; you just give each one its own directory and configuration files. I suspect the reason you haven't gotten any answers thus far is that you haven't provided any concrete information about your deployment. I'm finding it hard to offer advice when you've specified you'll be using "Ansible, Chef, Puppet, etc." and "Redis/MongoDB"...are you using all of these things, despite the fact that they do very similar jobs? Most people choose one deployment tool (from Ansible, Chef, Puppet, etc.) and one key/value store (Redis/MongoDB). Configuration examples for all of these, and the caveats for things to look out for will be different for each. Anyway, the short answer to your question is: Yes, you can do that, and there's no technical reason you shouldn't. 

Yes, you would enable SuExec. $URL$ Specifically, the section that begins Using suEXEC. Quoted here for convenience: 

It is likely a local sender using the sendmail command; postfix doesn't need to be running for a local sender to add things to the mail queue. If you're running any web apps, I'd assume one has been compromised and is trying to send spam. References: $URL$ $URL$ It is possible to limit which users can send via sendmail/postdrop. It may be worth enforcing use of the SMTP server along with SASL authentication, instead of allowing local users to drop directly into the queue. 

It looks like you're confusing which software you're interacting with here. So, let me see if I can clear up some things for you, and I think once you understand how these pieces fit together you'll be able to get your settings right and the behavior you want. Usermin is a completely separate program, running on a different port. A Webmin user is, in no way, effected by what you do with the Usermin configuration. Webmin users are not Usermin users (though either could be a system user, and one user could have both Webmin and Usermin access). So, to be clear: If you are wanting to limit a Webmin user, you do not do it in the Usermin Configuration module (that's for Usermin users). You do it in the Webmin Users module. So, at this point, you may be asking, "Well how do I configure permissions for a Webmin user?" Browse to Webmin->Webmin Users and then click on the username of the user you want to edit. Then, open up the Available Webmin Modules section. Click on "File Manager" in the Others category (or Filemin File Manager, if you've installed the third party version on github, though I think we can't recommend that one at the moment, as it has gone in a weird direction lately, and seems to not interact very nicely with Webmin current versions). Now you can choose how to restrict this user's use of this module. The options are quite fine-grained, and most are pretty intuitive, I think. To limit the user to a specific directory, you can fill in the "Allow access to directories" field with the directories you want available. To have Webmin perform the file actions as the user, rather than as root, you can edit the "Access files as Unix user" option and set it to "Save as Webmin login". In short: Forget about Usermin. It isn't related to what you're trying to do. Also, it doesn't sound like Virtualmin is in the picture at all (though for web hosting related tasks, you probably should be using Virtualmin rather than just Webmin by itself, and it does create website owner user accounts with the kind of permissions you're talking about, by default and without any extra hoop jumping required). On this question: