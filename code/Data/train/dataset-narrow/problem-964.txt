In our high school there we must be taught something called . Honestly I didn't took it seriously. But later I found this ugly frightening figure has its own beauty and is very useful solving problems that are very complicated in first sight, like this problem. 

Of course we can use the modulo for each number below 1000 to determine which are divisible by 3 and 5. But isn't it a brute attack on these numbers? Why don't think it in a different way? 

You can see there are two circles A and B and they are overlapping with each other. In our problem we have two sets of numbers- those are divisible by 3 and those are divisible by 5. See these two sets have a common or intersecting set- those are divisible by both 3 and 5 (or 15 to be precise). Now the questing arises how would we get all those unique numbers from set A and B? Thats pretty simple as you might already understand. That is , pretty simple, right? This expression takes care of all repetitive elements in those sets and produces a set with unique elements form both sets. Now how do we get ? The formula is- = + - That means we need to subtract the set of numbers those are divisible by both 3 and 5. Lets find out which numbers belong to these sets- , and We have set our limit to 1000. Lets get the numbers those are divisible by 3 in the first place. 

Having so many operations -- seems like you'd want to use some kind of a factory, injected in the constructor, or the instances themselves injected in the constructor, instead of constructing the classes inside the constructor. 

From the algorithmic perspective, I'd like to suggest another solution (regardless to Python as a language). Here goes: let's assume that all items in the given array are different. the other case has a similar solution, so let's focus on the algorithm itself. 

The math behind this function is not that simple, but it's not that complex, too: You should calculate the shell's index, according to , , and . Then you should calculate on which side of the shell are and ("North", "South", "East" or "West"), and calculate the "distance" (in steps) of the current item from the shell's start position. All this is pretty much mod calculations. Once this method is done, you could simply write a nested loop (N by N) with and , and print the function's value, without having to populate a matrix before that. The calculations in the should not take more than O(1) (in space and time), so eventually you could have a solution of Θ(N) in time, and O(1) in space. Just an idea, though. 

We need to take their summations- this is the formula for getting the some of a linear arithmetic progression, n is total number of elements in the series. 

If you anything with a then the result will always be . Here and . So the expression will be Using this algorithm you are not actually checking the numbers which are divisible by both 3 and 5. Still it gets you the correct answer. The reason behind is you are just traversing throw the numbers and moving forward. There is no chance of any repetition here. The accepted answer is all good :) 

At first I apologize for bringing this off topic matter here. I heard of this website about one and a half year ago and I immediately fell in love with it. At first I tried to dive in with my programming knowledge and soon it drove me crazy as I failed in solving almost every problem except the simple arithmetic ones like the one mentioned here. The I finally figured out that these problems can't be solved with just developing algorithm without sufficient mathematical knowledge and of course without seeing the problem in a different angle. Let me explain. 

We need to get all the numbers below 1000 those are divisible by 3 We need to get all the numbers below 1000 those are divisible by 5 There will be repetition of numbers as there are a lot of numbers which are divisible by both 3 and 5. 

first element is 19, since abs(20-19) = 1 is the nearest distance to 20. let's find 19 in the sorted array: 

and the rest is obvious. Again, this has nothing to do with Python in particular. It's purely an algorithm to be implemented in any language. This algorithm takes O(n log(n)) in time, while the one suggested by the original poster takes O(n^2) in time. 

What if the script renames file "a.zip" to "b.zip", and both files "a.zip" and "b.zip" exist in the same directory? 

It's not clear to me what are and ? If these represent the radius values (like C1-P1 line for ), then perhaps (and ) would be a better name here. I'd create and use a data class for each point-radius pair. Say, class with and or something similar. I'd separate constructor and results. The results are calculations that should not be part of the constructor. Take, for example, the class named in .NET: you can construct it, change the inputs, and only when you call the property named - you get the calculated uri. The same should apply here, too. Constructing a class gives us an instance with a valid state. Calculations - in their own methods or property-getters (that are practically methods, by the way). So should be the returned type of a method (or maybe if this pattern apply here), and not part of the class' state. 

This would be the finishing of the discussing. But WAIT as I mentioned earlier I have solved this problem and that solution is not matched with this one!! WHY !! Finally I figured I out, this is the result of not reading the question properly. They asked for the number below , but what I have done here? for and it was okay, but for ? 1000 is divisible by 5! We can't include it in the set!! So the actual summation would be , less than what we got here. People might argue why I have posted the whole solution here. But thing is that, anyone with a little knowledge of programming and the basic understanding of modulo can solve this problem like the questioner. Is this the right way of solving these problems? Was it the intention behind developing this problem bank? Of course not, at least I believe. They certainly want us to look at problems in a different angle. Look things those are hidden in the plain sight. Sketch the idea before painting actually. This post is for future reference only, intended to them those are interested solving the problems in this website. But also for others to show there could be some other perspective to any problem. Thanks for reading. EDIT As per suggestion by @200_success I am rewording here. As per the original question I agree with @Simon André Forsberg there is certainly nothing wrong with the modulo operation. And also it can be broke down to a simpler version as he already mentioned. I want to add with it that the condition writing is very easy with the basic understanding of . I am just breaking down the idea. In digital logic design is represented as and is as (and there are some more). So the condition becomes . Now you can have as many times as you like as its just an operation, so we can rewrite 

Naming Consistent: might look better if it becomes Accurate: perhaps could be used instead of , since init means some kind of a setup, while the method actually changes the array's values. In addition, perhaps the class' name could be changed from to , which, at least in the aesthetic aspect (to my own eyes), looks better. 

I believe should return something. The returned value of might have a special value of in case that one of the s calls failed (this scenario should be covered by the code). In the implementation of extend - consider using instead of and manual copy. If you insist on perhaps using might be more elegant than a manual copy. I'd move magic numbers to s: Initial Capacity (hard-coded to 10) and Growth Factor (2). Alternatively, they could be parameters to the function How would you free this struct? Perhaps you should add a "destructor" to be called before calling with the struct pointer as a parameter. In terms of functionality, other than printing this "array", how would the consuming programmer could get (or set) a specific item in this "array"? 

Without reviewing other aspects, I think you should separate the code so that there's the server itself in its class (or, maybe even better, its own project), and there's the UI. For instance, you should not show a MessageBox inside a server's code. There are so many reasons for that so I'll just leave this statement as is. In other words, the server should behave as a black box, returning error codes, or throwing exceptions, or anything else, according to its own API. Mixing the server's code with UI is not a good practice.