Then i would create a custom user control wich will display such tree using this interface and specidied s (after i will fail to make wpf TreeView work as i want it too yet again -_-). This is a tricky task with plenty of pitfalls, but i think its possible. At least that would be an approach I'd try first. 

I think you forgot to unsubscribe from . Better safe than sorry. You should also consider renaming the handler, so it does not look so out of place in otherwise conventional code. is a better name. 

You should probably remove empty braces inside attributes. => . This loop is very hard to read due to how you use offsets. 

You shouldn't really create a inside your workers. Instead you should create single instance inside your queue and pass the same token to all workers. Then you can use inside method to send a cancellation signal to every worker. Also, instead of using , you should use flag. It is the other way around with worker threads. Those should probably be created by workers themselves, so you do not have to store them separately. Good job on actually ing the threads you create, that's a good thing to do. But the timeout smells. Are you sure that you are not hiding an error? If threads successfully join every time, then you should call regular without timeout, if they do not - that is something you should investigate and fix. Finally, you should pay attention to classes that implement . Nothing horrible will probably happen if you forget to dispose them, but still it is a good idea to clean things up yourself when you are done using your s or your s. 

For multi-threading scenarios you can segment your array using constructor or class. Both are cheap. 

As for those values, they should probably be exposed as a property of , as Bruno suggested. If you do it, I don't see any reason for to exist at its current state. You might as well just inject array of rules directly into your evaluator. 

I am looking for general review, but memory leaks are my main concern. I think I was careful enough with dependency properties and weak events to not leave a running timer hanging in memory for no reason, but I am not sure. If you see any issues with my code, let me know! 

To begin with... what's the point? I mean what is so bad about having a dependency on standard .Net assembly? It is already installed on the machine as part of .Net installation, so this dependency does not affect the size of your app. Am I missing something? This design works under fairly naive assumption, that the app will not change in any way as the time goes on. And it might be the case for your particular app, but it is not the case in general. Imagine I am using your library, and I want to subscribe to event. What should I do? Should I call you at 3AM and ask you to also override this event with keyword? Will you do the same thing for every single event (or property) found on ? Will you then test every single interaction, to make sure you did not break standard behavior? If you are not willing to take this all the way - don't do it at all. I don't even want to begin imagining all the potential pitfalls. What will happen if someone sets for your new event? Will your base event keep going? What will happen, if I have a style for regular button that uses and I want to override this setter for your button's style? How is it going to work, will I have two event handlers as a result or just one? Etc, etc. 

Yes, you are correct, in some cases can leak memory too! Usually it does not happen, because most implementations of either utilize (which uses weak references) or do not care about state and therefore use empty event, which does not hold any references at all. But if you implement as strong event, will cause memory leak. In your case the simplest solution would probably be to additionally when control is unloaded, and to when it is loaded. Alternatively, you can use weak events pattern as Zache suggested. 

You should only use bindings when binding to classes which do not implement interface, otherwise those bindings will leak memory. If you need a binding to your , then you should wrap it into . Same goes for collections and . Using plain ol' as will leak memory too. Singletons... just don't. Simply pass the service into constructors manually or using some container. You should avoid re-creating . Call and repopulate it instead, when you need to reload it. I think the simplest way to address your concerns is to share single of your games between the viewmodels that need it. This way you won't have to bother with synchronization. There are multiple ways to achieve this. For example, you could create a child view model to represent the list of games, and inject it everywhere its needed. Or you could re-organize your UI in a way, that there is only one place where list of games is displayed. Or you could even return from your service class, and expose it from your viewmodels (keep in mind the point #1 about bindings though). I think it is generally a bad idea to settings in property setter. Writing to disk can be expensive and it can lag. You should perform I/O operations either in background or when user closes the window. 

Personally, I really hate statements, because more often than not they are used to make an excuse for a bad code and/or laziness. In a project I am currently working on I recently found the following comment left by one of my coworkers: 

won't work as you want it to. So eventually you might want to implement some sort of reference counting. 

This method should probably be refactored into static extension method, so it is easier to re-use if needed. 

This way you can guarantee that all equality methods always return the same result. And fixing a bug in your equality logic becomes as easy as fixing as single method. At the moment passing to method will , while using will work just fine, for example. You have a mutable hash code, which is a bad idea in general. You have mutable static feilds ( and ), which is also a bad idea. Consider this code: 

I may be missing something, but how is this different from ? And why would you want to pay your worker to sleep? Looks extremely inefficient in most cases. And surely there are other names you can use apart from ? So you can both avoid using and give a variable a much more meaningful name. "Event" does not tell much. 

you can get rid of , if you add property to your elements, and you can further improve it by adding meaningful exceptions when input has incorrect fromat. 

This is because when you write to dictionary it can,for example, increase the size of underlying collections or reorganize internal "buckets" where items are stored. Those operation will move items around which can break a concurrent read operation in unpredictable way. Enumerations on the other hand will throw straight away, if you modify the collection during enumeration process. The bottom line is: your (read) and (enumeration) are not thread safe. You must synchronize them with your method if you want to read and write concurrently.