To sum up, the curriculum given by you sounds quite good to me. Except for the adjustments proposed above, I don't see much that needs to be changed. 

As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

I am not sure if this is really what you are looking for, but there is also Blocky from Google which is kind of similar to Scratch, and lets you see the source code produced by the block in different programming languages (JavScript, Python, PHP, Dart, Lua). Blocky is used in several projects like code.org. If Java is OK for you, than you can consider the BlueJ IDE which is: 

There is this research paper "Learning edge momentum: A new account of outcomes in CS1" by Anthony Robins that is much focused on that subject... From the abstract: 

As probably we all experience, plagiarism is very common in CS. I know that there are several types of plagiarism ranging from simply submitting a copy of the colleagues’ code to other highly sophisticated mechanisms. In my experience, the most common is indeed the simplest one. The student just grabs the code from another colleague and eventually change the names of the variable, and submits the solution (some students don’t even do that!). While there are several systems that are easily capable of detecting this type of plagiarism, they do it mainly when the student submits the final version of the code. Some other tools, are capable of detect plagiarism and notify the student about that (as if they didn’t already know that!). In most cases the use of an anti-plagiarism tool will act mainly to support punitive measures. Although it is not the main focus, as part of my PhD work, I am working in a tool that analyses the source code as it is being written and is able to detect plagiarism in “real-time”. This way, the teacher can be notified about students that are performing plagiarism even before their final solution is submitted, giving the teacher time to act and avoid the punitive measures. My biggest question is: What should the teacher do with that information? Will this be efficient? 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody. 

I suppose that a traffic light is a very good example and easy to understand by your target audience. 

The question kind of says it all. Imagine that for an assignment you receive two or more similar submissions (e.g. programs). What will you do? Annul all the works? What if you know for certain who was the original author? Probably this is already in your schools’ code of conduct. In my school it is not and I sometimes don’t really now what to do. 

I think that to understand the SELECT queries, the Who is Who? / Guess Who? game could serve as a nice metaphor. 

For research reasons, in the last few days, I’ve been looking at several statistics on computer science programs in Portugal (but also in Europe and the US). One of the most interesting findings is that approx. 20% of the students will drop the program at the end of the first year. But the most problematic finding is that after four years, only approx 22%-32% of the students were able to graduate in a 3-year program. It is important to stress that in Portugal the admission to higher education is determined only by the grades that the students obtained in High School (50%) and the results of the exams in some particular subjects (Math and Physics) for CS programs, for instance (50%). In the end, only the n students with higher scores will be admitted. Given the demand for IT personnel and the high unemployment rates of several other areas, several students will end up attempting CS. I am aware, that some companies rely on the Berger Aptitude for Programming Test to select their candidates. From what I understood, this test is used mostly to evaluate the candidate’s ability to program and could not be used to select candidates for the CS programs. Given this context, shouldn’t the students be performing some aptitude test before enrolling in these programs? Is anyone aware of the usage of such tests? Obviously, I understand that one shouldn’t simply say to someone: “Hey choose something else!”. However, we are talking about several hundreds of students that are basically losing one or more years of their lives. Although this happens in Portugal, I guess the same thing occurs in other countries. Shouldn’t we be doing something about it? I am aware of some other questions concerning programming aptitude. However, I think mine is different. 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely. 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

In the final report of their internship, the students of our school must have one chapter where they "document" the developed work. When using the “waterfall” methodology, they usually have one sub-section for each stage: 

It is not clear for me what "computer science" means for you. Is it at High School level? If that is the case, you could try to introduce some of the mechanics behind "digital music". How it is processed from analog to digital. How it is compressed, how it is reproduced, ... What does it mean to be 8bit or 16bit, the bit-rate, the sampling frequency... If the students are more into drawing/painting, you could do the same with image formats. 

The idea of the game is: you have a group of pictures of persons with different facial features. One gamer selects one of them and the other gamer has to make questions to try to eliminate the ones that are not relevant and try to guess which one the other gamer has chosen. It is kind of like what you do in the WHERE part of the SELECT... 

I think whether and when the test cases should be released depends on a few factors. Not releasing the test cases You say that the assignments were only partially assessed by the unit tests, so in my understanding this means that there is somebody having a look at the source code. If (and only if) the assessment was fully automated and there were no human beings looking at the source code, you should not release the test cases before the assignment as otherwise it would be possible that somebody just created a program that has the required outputs for the test cases hard-coded and chooses the right one (using some kind of map or dictionary) depending on the input. If you plan to put the same (auto-graded) assignment again on students in e.g. multiple courses, you might also want to avoid releasing the test cases after the assignment - otherwise students that have completed the assignment could be able to hand the required test cases through to the students that haven't yet completed the assignment. If you however change the unit tests for an auto-graded system after releasing them (i.e. each course has it's own set of unit tests for the same task), then you could release them after the assignment. Releasing the test cases before the assignment I can imagine a situation where it's neccessary to release the test cases and to do this before the assignment: If you're doing test-driven development. In this case having all the unit tests available to everybody would be essential as otherwise the whole strategy wouldn't work. Furthermore, the test cases could help students as they are examples of the program's in- and output if they have trouble understanding the specification (as specifications can benefit from examples). I would even go further and would recommend you to release the test cases before the assignment in almost any case unless you have specific reasons against it. Releasing it after the assignment This could be an option if you want the students to figure out the algorithm without having examples (not sure when this is required, but maybe there are some sort of tasks that require that) but you want them to give a chance to review their mistakes after the assignment is done. I would always try to release them at the latest when the assignment is done.