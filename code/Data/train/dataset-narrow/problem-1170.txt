Generally i would strongly recommend to split keys and values. One possibility would be to create a std::pair 

You are missing the third point, which complicates the code more than it should. So lets start with a data structure that fits the problem 

Also generally you should really check whether the memory allocation succeeded. Have a look here $URL$ 

So here would be my take for the code using two std::vectors. The idea is that the first vector simply stores the individual profits, whereas the second vector starts with all the profits of the 2 segment chains, aka [i, i+1]. We determine the minimum of that vector. Now in the next step we increase vector2 by element i+2. So now it holds all the segments of length 3 (obviously in every step the last element gets ignored). We continue until we reach the full segment. 

Your bst_create_helper is buggy, as it doesnt do anything if root is not the nullptr. Maybe you just misplaced the curly brace? 

So i think there are quite a lot of things to improve: Use more function. Your code does a lot of stuff within a single function. Separate it into specialized functions, that do only one thing. For example how to generate the alphabet. In your code you have this 

Do not use namespace::std; Google it or just drop it. Add all the necessary headers. You are missing string If you have to implement getter functions declare them const. 

Try to think what your class need to be fully defined and put that in the constructor. As a rule of thumb, whenever you need to do something outside of a class object before you can safely use it, something is wrong. 

For the provided sample file this takes 2.6s on my machine. However, there is a much better solution Solution2 The underlying problem is, that we have to traverse the edges on after of the vertices. This is highly suboptimal, as there are generally many more edges than vertices. The solution is to store the pointer to the vertexIndex in the map rather then the vertexIndex itself 

So i think there are some possible improvements. The general idea should be to utilize a sieve like approach. In principle i like your code, but similar to the other questions your naming is really bad. Noone knows what n, k or v is. so use descriptive names as you yourself will make tiny mistakes and spend some time searching for that "k" instead of an "n". 

As a side note, you pass the element by copy not by const reference. This might also have some real preformance effects. SO rather do 

The obligatory "Do not use "It is bad practice and will hurt you in the long run. So start typing when you need it. Whenever you pass data that should not be modified, pass it as , so that you actually cannot modify it. Also you are passing the data via a copy here, a reference would make more sense. So for example your function should look like this 

EDIT: this is no longer relevant but i dont know how to cross it out. However, i would suggest, that you keep track of your jump length via the queue. So rather than haveing a have a New: I would now suggest to store the first visited field in the struct itself, which simplifies the code a lot 

Also you might want to check whether the provided values are actually reasonable if (width < 0) { throw std::runtime_error("Invalid width provided!"); } if (height < 0) { throw std::runtime_error("Invalid height provided!"); } is the same as Declare variables, where you need them. For example is not needed outside the loop. You already know the size of the matrix so reserve the memory to avoid reallocations 

With the added benefit, that you can now declare k as const. However, it would be arguable whether you should throw a warning in case k > min. 

Now that you have the two histograms you can walk through them and count the difference in the frequency of the characters. 

Do not use . It is a bad practice even in coding challenges. Use the std containers e.g. That way you do not have to deal with memory. So this 

Try to add a space between control flow instructions like , and friends. Therewith you can readily differentiate them from functions. 

I would strongly suggest, that you create convenience classes for that use case, which act similar to functions. The reason is, that the random number generators generally increment their state and more importantly that initialization is costly. Therefore, create a class that holds the generator and the distribution and create an 

Do not use It is bad practice Use descriptive names. For example your variable should be named or something in that direction. That applies for every other variable. Why are you allocating an large array if you know the size of the array. Also you should use a or . Your input routine then becomes. 

So what you actually need to do is simply counting the occurrences of every letter without any sorting necessary. That is best served by a , where you insert the characters and increase their count. 

Why is xnew defined outside the loop it is used in although you never use it anymore? The next thing to notice, is that is actually more of a copy of . One could be tempted to just write rather than , however that prevents a possible optimization by the compiler if is passed in a move constructible way to the function. Therfore it is better to let the compiler do the copy 

I think you overcomplicated your problem. The easy solution that comes to mind (the third attempt I had right now) is to define a struct with a mutable element (The member we want to modify is marked mutable, as elements of a std::set are const qualified): 

Your names should be more descriptive. The fact that the actual game is in the function loop is a bad wording. Same for logic. Generally a function does something which should be reflected in the name. 

So the first think to define is the state of Muttal on the route, which is a pair of the current token and machine, which incidentally are two unsigned numbers 

There is an incredible amount of boilerplate here. I would like to remind you that with C++17 you can use fold expressions, which do basically the same but way simpler: 

That way in the interval [first, second) there would always be the numbers and you would not have to replace the final character or other stuff Again encapsulation. There is no reason why the this block of code is not inside its own function: 

I think your friends vector is wrong. You should have rather than . Otherwise you get problems with ownership. I would suggest to use auto &elem for range based loops. In any case you should at least use rather than passing by copy 

That is a copy of all neighbors everytime you access a node during your search. If you really need the temporary, which you dont then at least make this a reference. 

You could also go for sorted insertion into the vector, however i felt that it complicates the matter of finding and in my experience just inserting and sorting at the end is more performant. Now for the optimal schedule we have to start with the last element and then go from there. If currentTime is not less than nextPossibleTime of the final instruction we can schedule it. Otherwise due to the ordering we know that there is no possible instruction and we have to go idle (I choose "1" for that). After an instruction has been scheduled, we check whether there are remaining uses and either remove it or reschedule. 

Now we have some problems here. The nodes themself are more or less loose, as we only store the pointer to the nodes. You can walk around this, by using smart pointer in this case . Second, we made the nodes private members, so we have to add a member function to the nodes too, that handles insertion, removal or search. There are different possibilities. The cleanest would be to add the appropriate member functions to the node class. The second would be to declare the tree a friend of the node. The third would be to turn the class into a struct and just make them public. Your choice. 

Not that its pretty but if you really like STL... More interesting are other STL functions for example . It does what it says, by adding the elementwise products of two ranges to an initial value. So this piece of code: 

The real beauty about this approach is that it is not only more efficient if you do it once, as you can ommit the second search over the array. It gets even better once you have to repeatedly search, as you can allocate the dataPtr array once and save the allocation/copy of the temporary array during consecutive searches. If I borrow from @Emily L. 

Don't use QT objects when you are not working with QT constructs. There is no benefit to it. Your node::_id is unsigned shirt, which for MSVS has a range of 0 to 65,535. Be aware of that when you graph grows. Do not use a map. A is way faster/bettter for traversing than a . You do a lot of copying data around: 

You should consider using descriptive names rather than textual comments. For example this line here 

Just a one liner. The field and its counterparts define a section. So everything after is public until / come up. So there is no need to put it before every function. 

At a first glance it is hard to discriminate what is the condition and what is the following code Also separate controll flow instructions with a whitespace so one can easily discriminate them from functions 

That way you get all the nice things about the container for free. Also note that the container is passed as a const reference, as you do not want to modify it. However, there is still the problem, hat the types of the iterable and the vector might not match. 

Every container has a method. I would consider it bad practice to use rather than , as it can have really performance implictations for lists and maps. Please post complete code. You are missing any headers and also the dubious That one you should really ommit in your code and start using proper namespaces. 

If you know its bad dont do it. --> looking at namespace std; For gods sake use braces. You are in your 5th level of nesting without a single brace. That is simply a bug in waiting. As a rule of thumb, whenever you nest something use braces. It is not like the additional line is hurting you. Similar to the above declare each variable on its own line. That way it is much easier to read. Use separate files for each class you have. That makes it much easier to follow your code. Your main function is loaded with stuff that should be part of the class initialization. 

EDIT: You should obviously follow the suggestion of LokiAstari and optimize the while loop. Also printf is C rather than C++ so use std::cout Put together this reads: 

The same obviously goes for indexes Given that you emplace in sequential order here you might want to switch to If you do not care about memory you can reserve the memory for your graphics vector with a guess during initialization and then call afterwards. That way you avoid possibly costly reallocations. However depending on the size of your guess this might significantly increase the memory burden. 

You should realize, that your stack implementation leaks memory, if a non empty stack goes out of scope. In that case you have to recursively call delete on your nodes. To remedy this you should look into that handles the memory management for you. Why does your stack doesnt have a function to retrieve the top node? Is there any reason you defined int rather than making a template library? dumpStack is a bad name, as dumping semantically involves throwing away. Maybe printStack? Use correct constructors and initializer lists 

And have a stack based on a std::vector The second most frequent topic next to namespace std. Use descriptive names! What is g,v,n? In this limited example this might be easy, but does it hurt to write 

I believe your code doesnt work. If you swap N elements pairwise you end up with the identical vector right? You should only loop until n/2. Do not use It is a bad practice that you should stop sooner than later. Use descriptive names. n, k, np are not understandable by themselves. Finally, c++ now knows std::iter_swap, which directly the values of 2 iterators. so you might wanna use that. 

This is one of the questions, that is directly related to the underlying data structure. So you can actually be quite sure, that this problem is best solved with a stack. The trick here is, that a stack ha$URL$ a well defined order in which the elements are retrieved. In that particular problem, lets say you know the current maximum of the stack. If the new element is smaller than that, you can push the maximum value instead of the actual one, as you are only interested in the maximum value of the whole stack. This is only true, as a stack guaranties, that the new element is removed before the previous maximum element. Only if it is greater you push the new element. This has the distinct disadvantage, that you do not preserve the original data. So there are two solutions, one for tracking the maximum element and one for also preserving the data.