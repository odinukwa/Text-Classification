I'm looking for feedback on anything relating to structure of my tree, or how I programmed it. If you have any tips, or see some place where I've taken a longer route than necessary, I'd like to know. I'm not looking for criticism on how my if-else chains look, or how I only include brackets when necessary instead of all the time to maintain consistency. I am more interested in functionality feedback. One thing I can point out right now, which I believe is inefficient is that when a block is being created, it is looped over just to be collected and passed into another block constructor. This means if you have a block nested 10 blocks deep that block is iterated over 10 times, and only processed the last time. I could remedy this by creating new properties and blocks as I go, the deeper I go. Using a recursive approach, and that might work faster. However as far as I've seen blocks are never nested 10 deep, they may get as deep as 5. Anyway here is the code. IVNode 

Edited additional points In this line you'll notice that you are printing the address of not the value of as denoted by the , remove this if you want your program to run properly. 

Separate your main-loop logic from your main menu rendering logic. You should have a main-loop, which calls recalculate, and draw, then in your draw you should draw the appropriate menu, based on the games current state, the logic should stay in its own class away from the main-loop. 

you aren't actually using the program arguments, so there isn't any reason to include them in your main signature. 

TimeSpan objects have properties like Days, Hours. the calculation done, does take into consideration leap years. Printing to the console can be made easier by sending parameters to be inserted into your string. 

Structure Instead of making a final class, like you have there, make it a class responsible for loading one image, then maintain a dictionary of all the resources you've loaded, this way your game will be much more scalable, and values wont be hardcoded. You could even have a class called to directly point to some of these commonly needed images, who's names wont change. You would still load the images with ImageProvder, but would simply maintain a direct pointer to your desired images. 

Yes... there is a simpler way. You have two choices, but each about the same. Use an Array, or a Map. The more advanced way of doing this would certainly be with a Map. Think about a map as a type of array where instead of using an integer to index the array you can use anything. In our case here we'll use char as the index. Because chars are ints you could just use a simple array in this case, and just mentally think of 'a' as 0, but we're going to take the larger step today. 

Information You can do constructor chaining in C#. However what you are doing here does not require such techniques. Here in your case you have 3 constructors taking all different types of data, and mostly doing separate things. You will be best off grouping repeated code into a method and calling that method from each constructor that needs it. However, for future reference if you do want to do real constructor chaining, you can do it as such... 

I see that at the bottom of your code you are checking to see if all the values in Numbers are 0, and then printing a message, and returning. Why? You did this earlier, and had an early return, so if that was the case the code should never have made it here. 

I wrote this function to use in my applications where I need to easily color-code output. Example syntax would be: 

Your program is a bit flawed. Technically just 0 is a subset of {0,1,2,3,4} however you appear to only care of subsets of 2 or more numbers. 

I'm working on some precompilation operations for a world compiler. Currently to identify flags placed by the level designer I need recognize when a specific entity exists at specific coordinates from the flag's origin. I need to generate a list of offset coordinates from the origin(and include the origin) in string form. That is 7 coordinates. this operation is done for every flag in the world, so it is preferred to be efficient. It is not an operation that takes place during gameplay, so I don't have to worry too much. My current implementation works correctly, and quickly, however I still would like to get a review on what I have written, and hear any advice to better this operation. 

If it wasn't for the I would suggest you actually go forward with the whole OOP thing, and have the workbook load when you construct it, and take advantage of OO design by actually having internal data besides just the path. I do think its is fine that you give them the option to specify , that could be very handy. 

For future reference, instead of making the class you could take advantage of the class. Not to say that you shouldn't have made this class, but can generally replace these simple data structure like classes. 

Now your CardNo cannot be changed outside the scope of this class. This should be done any time you don't want something to be changed from an outside source. This doesn't work well with objects, because.. while the reference cannot be changed, the object its self can be, so you'll have to be careful there. 

Next we can simplify some of your code with , which you should use any time you want to repeatedly do something to a list. Below, using , I query the list of numbers and I ask if all of them equal 0. 

Edit: This is of-course personal taste, but I dislike (what I consider to be unnessary brackets taking up newlines). 

serves no purpose, if your number is indeed lessthan or equal -.2 then it will also hit the next check if it is lessthan or equal to 0. 

As soon as I see a I get nostalgia, and know that you haven't taken a step back from this program and considered a world without (java). There is always a way to avoid using a , and this is a rather simple one with multiple alternatives which don't kill your program flow. I think the best one for your situation though is to only increment up when the is successful. 

You didn't include a on your condition, this isn't wrong, I just want to point out that some people like to see it for consistency's sake. 

Your math was wrong, but don't worry it was a simple fix. And I have provided an easier way to do it on top of that. The key to this review is that we're going to take advantage of the .Net libraries, which you should remember can practically do anything you want them to. That is IF you know how to use them. in C#.Net 

Make sure you are disposing(closing) your database object. I presume by the way you have your class setup that when your database object is disposed it will close, in which case I would recommend using the keyword. Which would make your above code look more like this in practice. 

Example: MVVM OnProperty Changed, notifies the UI when something in the backend has changed and updates accordingly 

If you want to actually run this program, here is the very simple code that it takes to load up a vmf and write it back. Main 

I like to say instead of , it just makes it more clear to me what is going on. Your code would look more like this. 

Lets kill that giant nest of code. When an Exception is thrown, it interrupts the flow of the program. The code does not continue to execute beyond that point, it is like an early return in that regard. This means we do not need to nest our next statement in the Else block, because if an exception was thrown the program has returned. You should not be throwing Exception, not to say you should throw exceptions, but just not throw the base Exception class. Instead make your own exception class that inherits from Exception. An incredibly simple way of doing this is just... 

In adition to everything else being said, I would like to point out that your tabbing is done incorrectly, and would look much sexier like this 

Ensure that in your you aren't actually doing the logical calculations every time. I assume you are doing your calculations based on a delta based system, where your calculations used the elapsed time since your last .update() to determine how much (lets say) something has moved. So be sure you've implemented a system, where the calls update on all the items in the list of items, and each one of them determine if the time since they last updated their stuff, was long enough ago to warrant recalculating their position. (Each item class maintaining how often they need calculations) If you want to see an example of this, check out the Source Engine's implementation. $URL$ Here you will see after events happen in game, the programmer manually sets the next time the think() method will be ran, which is called update() for you 

Also note that I removed you setting , because you were not using that since your were returning right away. 

I just wrote this short little program to increment up the build number for my projects every time I build them. After compiling this exe, I just call it in the pre-build command line. I did take out the filename string because I used it thrice, and I figured I'd get some flack if I didn't. 

Point of affirmation, this is indeed a good binary search. finding halfway between your highest and lowest values will get you to the answer on average the quickest. 

The code I posted in is the most efficient because it only does as many comparisons as is needed, and cuts out when it finds the correct value. One advantage 4.1 has over the code you posted is that it doesn't do a string assignment before it does the comparison. Your code could have been re-written to avoid that as-well. The code in is sleek, however it does require you to create an array, which is not expensive at all. I am only mentioning this, because it is something to consider when choosing the right code for you. While the differences here may not even be noticeable by the computer its self in terms of run-time speed, efficiency is something to keep in mind at all times when coding. 

You can do this same thing for your class, that is.. making these functions instead of methods on a class. You don't have to, but again, you aren't taking much advantage of the OO, so there is need for you to make it OO. 

Other than that... this code seems pretty solid, except for the crazy lack of immediate readability :D and like mentioned in the comments the fact that you are using delegates at all here. 

Your worst case scenario for the chain is that you have to hit every single one of those IFs. If you structured those in binary search design, ie. start from the middle and eliminate half of the spectrum at a time and work your way out, worst case scenario is that you have to hit half of your IFs. The code for this may look ugly, but it would help. 

I know you said you liked using delegates, and you wanted to see what you could do with them. But I think its good to recognize when you don't need to make your own. Here is a simpler refactored version of your code. It does not use your delegate. Also, technically what you were doing before was recursion still. 

Your If-chain should be an if-else chain, because if one of those is true, then there is no reason to check the next condition. This behavior is easily emulated also in a switch statement 

Naming convention: All of your method level variables should start with a lowercase letter, be , ie. vs 

Edit: Expanding on Exceptions Instead of throwing an , adopt the model used in TryParse. Return success or failure of the method as a boolean, and sent out the data you want. This way you don't have to throw an exception at all. 

I like my variables to only be in the scope they are needed. For your case this would be guess not being in the loop. 

Review I don't know if this is something you should implement, because I don't know how you intend to use this class. In C# you can place access modifiers on the individual parts of the getters and setters. A way you can use this (again, not sure if you need to, but this is isncase you do): 

will replace the condition for checking null-ness and emptyness, I would recommend you look at as well, this is good if you may be getting some blank spaces newlines or tabs with your data. (Optional) Instead of comparing your Enumeration to 0, implement a value, this way in-case someone ever changes the default values of enum this code will still work. Or if you don't want to change the enum, you could just check to see if the value given is a valid value in your enumeration. 

In your specific example you will use getters and setters simply when something is public instead of private. You can however have private properties with getters and setters. Getter and Setters are methods which are used in the setting and getting of data. They are very useful when you need to do some calculation when getting or setting data. Example: getting calculation 

As I said above, C# convention is to make anything that is publicly accessible to be a property. So this is your chance to look at your class members and decide what really needs to be seen and/or modified by outside sources. What if you decided to allow addons to your game, and lets say its a multiplayer game, so you don't want people cheating. But now anyone who can get the memory address of your asteroid object could easily change its position, visibility, or its texture. Even if this is some small project for yourself, data should only be exposed as much as absolutely necessary, and only those who need to change that data should be able to. Also, anything that is public needs to be , not ie. start with a capital letter. From a quick look... this is how I would do it.