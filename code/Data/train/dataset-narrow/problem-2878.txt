Obviously there are a lot of constants to be fiddled with here (I would start with WOBBLE_FACTOR around .2 or so and NUM_COEFFICIENTS about 20), and you can look at producing bigger wobble (e.g., replacing the divide by (idx*idx) with a divide by just idx so that the higher-frequency terms aren't as damped), but for the resolutions of pools you're talking about most of that will just vanish. Note that this will (basically) produce the outline of a lake by drawing 'around' it; if you wanted to 'scanline' your lakes you could do it by just deciding whether the center of each cell in your grid is within the lake's outline - that is, whether its radius is less than the frequency sum at that point: 

etc. When doing larger figures where each vertex will be part of several triangles, this saves both memory and time. 

One small note: you say 'looks like a real life map with countries of different shapes but equal sizes), but 'real' countries are vastly different in size even within certain regions — even the 'large' countries of Europe can vary hugely, with e.g. France being more than twice as large as Italy. With that said, there are obviously gameplay regions to try and keep sizes roughly the same - just be aware that a little variation here is probably a good thing! My initial approach to the problem would be to 'evolve' (rather than 'grow') your regions: 

I think you've got the right idea, but the execution is going to be immensely challenging. I'm presuming when you say 'in an SVG file' you mean that the shape is defined by one (or more — your sample figure has an internal hole!) stroke paths. Unfortunately, SVG paths can be remarkably complicated, with both quadratic and cubic Bezier curves and elliptical arc segments. The intersection of a line with any of these is a solved problem, but a highly non-trivial one, and even the matter of re-parametrizing Bezier curves to split them in two at the point of intersection is a little tricky — basically, what you're looking for is complex enough to take a small book to answer, not a forum post! That said, there are several excellent references out there; the short short version of the answer is that you want to use recursive subdivision along with the so-called 'variation diminishing' property of the Bezier curve (essentially, the property that a Bezier curve is contained within the convex hull of its control points) to narrow down the possible locations of an intersection (and note that a line can have multiple intersection points, and that's another special-case that you may have to take into account). And once you solve the intersection problem, you've still got a long road ahead — you're going to have a ton of bookkeeping to do to keep track of curve and line segments and partition them correctly into pieces. This isn't to discourage you at all; just be aware of the magnitude of what you're trying to do! Fortunately, your other question — 'can I change the line of intersection of figures to give them curvature?' — has an easier answer: absolutely. Since you're already in SVG-land, I'd use Bezier curves here too: first, choose five points p1..p5 along the line segment you want to 'curve out', probably somewhat at random in roughly equally-spaced intervals; then displace them a small random distance off the line, and use them as the control points of two separate Bezier curves, one using points p0, p1, p2, p3 and the other using points p3, p4, p5, and p6 (where p0 and p6 here are the two endpoints of the original line segment). You can take advantage of the convex-hull property of the Bezier curve here too, making sure that your displaced points don't displace too far so that the two regions to either side of the curve(s) are still simple regions. This should give you the sort of curved boundary that you're after. 

(Stock caveat: I Am Not A Lawyer and this should not be construed as specific legal advice.) If all you're concerned about is that your work is copyrighted to you, then you're in luck - that happens automatically upon creation of the work, and no explicit copyright mark is needed. On the other hand, if you're concerned about the prospect of people infringing on your game's copyrights (and you're in the US - other agencies will be appropriate for different countries, of course), then probably the simplest route to take is registering your copyright via the US federal government's Electronic Copyright Office; this provides all the benefits of classic 'paper' registration for a relatively nominal fee (it looks like $35). This allows several benefits over the implicit copyright that's automatically granted to your work; for instance, you must register a copyright on your work before you can file a suit for infringement (though note that you don't have to register before learning of the infringement!), and having registered in advance of any suit both provides prima facie evidence of your copyright's validity and allows you to recover attorney's fees and statutory damages for the infringement. (For more details on this, I recommend ask.com's page on copyrights or the SFWA page on the benefits of copyright registration) If you're very concerned about people infringing on your IP rights, or you want protections beyond just basic registered copyright protection (e.g. trademarks on certain expression elements or on a logo, etc), then the answer starts with 'Find An Intellectual Property Lawyer' — they'll be much more competent to advise you than anyone else here. Separate from both of these matters, of course, is the issue of how much you should be concerned with copyright protection right now. I won't tell you not to be worried; that's an issue you can only resolve for yourself. But I will say that my gut instinct is that you should be much more worried with making your game first; having to be actively worried about people stealing your code falls into the Nice Problem To Have category. That's not to say that you won't have it eventually — just that IMHO it should be quite a ways down your list of concerns. 

Finally, one detail to clean up: I mentioned doing a point-in-shape test up above. The most straightforward way of doing that is casting a (2d) ray from your point off to 'infinity' in any direction - or at least to a point beyond the overall bounding box of your shape - and count the number of intersections that you hit along the way; if this number is odd then your point is inside the shape, otherwise it's outside. There are a few subtle details to be careful of here - for instance, if your ray runs tangent to some curve segment - but the basic approach works quite well. 

Octrees aren't the only way of handling spatial partitioning. If your objects are static - which it sounds like they might be - then you may be better off not using an octree but instead using a hierarchy of bounding volumes. And even if they're dynamic, you don't necessarily need a full octree; you can go down to a quadtree, the two-dimensional version, and treat all boxes (for purposes of the spatial partitioning) as having the same height. As for whether it's worth it, a lot of that depends on just what you're intending to do; 512 objects is few enough that individual frustum culling is probably fine, but you may find yourself wanting the spatial partition for other reasons (for instance, for object interaction). 

(Answering from my comments to get this off the unanswered list) My strong preference would be for a 'world-space' solution over a 'screen-space' one; that is, rather than trying to do the work of outlining in a shader, instead do it in your engine: for each edge in your figure, determine whether the edge should be highlighted on-screen. You can use whatever criteria you like for whether an edge should be highlighted; for instance, a simple one would be to highlight each edge where the faces on the two sides of the edge point in different directions with respect to the camera (that is, one pointing towards the camera and one pointing away). It would be nearly as easy to highlight each 'reflex' edge - that is, a concave edge of your figure, one where the two faces on either side are pointing towards (rather than away from) each other; etc. Your criteria don't have to be specifically graphical, either - for instance, it's easy to 'reject' any edges on your figure adjacent to the ground. Keeping track of the edges is a little bit tricky, but not too bad - there are a few special cases (for instance, if you can have a 'figure-eight' edge where two diagonally-adjacent cubes share the edge but no two facially-adjacent cubes do), but in general building an edge list is relatively straightforward. Once you have the (sub)list of visible edges, there are a couple of different ways to handle displaying them; probably the most straightforward is also a world-space approach, where for each edge you render another rectangular box, ; for instance, if the edge runs from (x, y, z) to (x+1, y, z) then you might render a box that goes from (x-.05, y-.05, z-.05) to (x+1.05, y+.05, z+.05). If you do this, make sure to take care in how you construct the 'end caps'; the particular version that I note there has the advantages that boxes from adjacent edges will align correctly at their endcaps, but non-uniform coordinate deltas might not. 

Unfortunately, 'without advanced math' is a fairly high bar to set for this particular tutorial, because the topic is inherently fairly advanced; metaballs are just a more colloquial way of talking about a particular type of isosurface visualization. The simplest way to conceptualize it may be to imagine taking everything down a dimension; imagine that you're working on a plane (or technically the surface of a sphere) rather than in space, and consider a classic heightmap; then the coastline of the terrain represents one isosurface: it's the set of all the points on the map where the height (the elevation above sea level) is zero. Now, suppose that you had a bunch of elevation data and you were asked to draw coastlines. One approach would be to (somehow) find one spot along a coast and then 'follow that coastline' until you get back to your original point — but that requires you to find that first point, and when you complete your loop you can't be sure whether you've missed anything (imagine tracing the coast of England and entirely missing Ireland in the process). Instead, you might try an approach where you scan over your map pixel by pixel, looking for spots where you have two adjacent points, one above water and one below, and then carefully drawing a line that cuts between the two, somehow making it match up from pixel to pixel. The generalization of this idea from two to three dimensions is commonly known as the marching cubes method, and it's the most common algorithm for rendering isosurfaces; things are somewhat more complicated in the 3d case than in 2d (since you effectively have 256 cases, one for each of the 28 possible assignments of 'above surface' and 'below surface' to the vertices of a voxel), but the core ideas are the same. Note that even pretty low resolutions on your grid can give good results for this; the demo you linked to is probably running the Marching Cubes algorithm on a 32x32x32 (or likely even 16x16x16) grid and it looks perfectly reasonable doing so. This leaves open the question of just what your heightfield is, of course — I don't have time to go into that side of things right now (although some searching should find you a handful of different potential functions), but I'll try and flesh this answer out a bit later to give some of the details on that front too. Of course, because you're essentially dealing with n3 pieces of data (the values on an n x n x n grid) then even fairly low grid resolutions can get expensive pretty fast. With the right potential function, though, you can use interval arithmetic to bound the values of your potential function on larger chunks of space and cut down on the number of actual calculations you have to do; essentially, this is applying octree-style spatial partitioning to the metaball problem.