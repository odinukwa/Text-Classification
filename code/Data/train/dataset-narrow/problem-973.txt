One cause for the observed delays might be your method which loops over random tiles until a free tile has been found. When the number of available free tiles is small compared to the total amount, this method might loop for a long time (e.g. on average 20000 times on 200 x 200 tiles with only one free tile). Apart from above issue, the overall performance is already pretty good. However, you might want to organize your code in modules or classes and thereby encapsulate functionality as well as remove references to global variables. Also, try to keep your code decoupled. The observer design pattern helps a lot with that. If applied to the tile set or board, this pattern allows clear separation of your logic from the representation. The following code exhibits above improvements, but there is no 'gold standard'. You might want to pick some ideas you deem useful and add them to your own implementation: 

In this case however, as you are striving for optimal performance, even generator functions are slow compared to directly processing the raw input. Robustness Your code is not very robust. Your handling of invalid queries is inconsistent. For invalid queries you return . For invalid queries you throw a . I recommend to simply ignore the request of deleting the top element of an empty stack. This would be consistent with . I also recommend to define the maximum of an empty stack as . This would be consistent with . Correctness Your code is not correct. For example, for queries you throw a . This is because you process the first line as any other line and ignore the fact that it contains the number of operations. Runtime Complexity The worst-case runtime complexity of your code is quadratic. Let's assume you are only given push and print queries in alternating order. You loop over all N queries. For each of the N/2 print queries, you inspect all stack elements to find the maximum. Since the number of stack elements corresponds to the number of push queries N/2, the average number of elements in the stack is N/4. Unfortunately, the resulting N/2 × N/4 = N²/8 is quadratic. A linear worst-case runtime complexity is possible. Instead of pushing the incoming element onto the stack, you simply push the current maximum on the stack. So you can reply to a print query by simply inspecting the top of the stack. Applying the aforementioned changes to your code, we get the following implementation with linear runtime complexity: 

to act as a module holding your methods and constructor functions to act as a block scope and thus prevent you from polluting the global scope 

Rigid body physics: Simulating the kinematics of rigid bodies over time requires integrating over their velocities to find their positions. As you don't have any additional forces such as gravity or springs acting on those bodies, this step could be as simple as where denotes the time passed between two frames which you might want to supply via . However, when collisions occur, the velocities have discontinuities. Therefore, you might want to update object positions as above only until a collision occurs. Then you compute the new velocities and continue with the integration. Even though your bodies are just balls and therefore pretty simple, this can easily become tedious and problematic when the time between collisions becomes very small. An alternative and more generalizable approach is to update object positions without regard for collisions and then resolve collisions in a dedicated step. Contrary to @MarcRohloff's suggestion, I'd recommend updating the ball movements by a dedicated physics "engine" which can be part of the as knowledge about the complete board state is necessary in order to update a ball's position. Graphics: I also recommend keeping your drawing routines separate from your models. A dedicated graphics "engine" can perform optimizations such as minimizing the number of context state changes or apply global effects such as z-sorting which requires knowledge about the complete board state. Apart from that, I recommend following the advice given by @MarcRohloff. 

Compute any sum of range by subtracting from . Each lookup now performs just two array lookups and a subtraction in constant time. 

So I suggest renaming , and to fit the more well known terminology of a map insertion and add a comment describing the specifics: 

Suggested Implementation Write a general purpose helper function or use a library which already includes one. Such a function would group array elements by their label or name. The user supplies a callback which returns the label or name for each array element: 

I would like to hear your recommendations on when to use JavaScript's over , especially when applied to mutable objects as demonstrated in the following comparative code samples: Strict preference of : 

the 'manual' zero-padding of the timezone offset and its many if-else branches the many hardcoded numbers and strings the long illegible string concatenation 

Algorithm Your algorithm is simple and easy to understand, but comes with a linear runtime complexity of . An algorithm with constant runtime complexity exists. Here are some pointers in case you are stuck: 

I used the _underscore naming convention to mark private properties. See Managing the private data of ES6 classes for alternatives. PS: Be aware that some platforms such as leetcode measure execution time on possibly older JavaScript engines and sometimes report timeouts when using newer language features. In such cases, use e.g. a traditional -loop instead of . Also, it has been reported that measured execution time on leetcode is unreliable and easily varies by more than 50 percentage points per measurement. 

Implementation Your implementation is clean, robust and easy to understand. I suggest only small changes: 

3. Simplify the condition: Your condition can be expressed in terms of both loop iterators and thereby simplified to : 

In addition to that, we don't know which parts of your interface or method signature are given and which parts are subject to review. You write that we "can ignore the Test-object-wrapper". But what about the method signature with its unorthodox choice of arguments, which seems to be required by the given specification? For all these reasons, it is hard to provide a meaningful review. Some notes: 

First of all, when presenting a piece of code to fellow developers, you help them the most by letting them know what your code does and what the inputs and expected outputs are. You immediately start by describing how your code does something, which is a bit confusing. Regarding your code, I suggest the following: 

Options and defaults: I'd like to suggest 1. an improvement and 2. an alternative to how you construct a object from user supplied options and defaults: 

2. Remove the redundant condition: The final condition is redundant as it is always when the first if-condition is . Remove it: 

Performance Test on V8 6.2 Below are average runtimes (in ms) measured after warmup (1000 preliminary calls). Best case - input queries repeated 

Each row represents the schedule for a single team. We note that for each round teams are partitioned into pairs playing against each other - i.e. . However, there is a flaw: According to above schedule, there is a round for each team where it has to play against itself (the red squares) - i.e. . That's because a correct schedule for 10 teams can only have 9 rounds, not 10. To fix this, we first slice the main diagonal of - all matches against team - and end up with: 

I think that by closely following the above recipe, you can avoid the more obscure arithmetic and come up with a simpler and more intuitive 'generative' algorithm. The scheduling is encapsulated in the function: 

Declarative vs. Imperative Those two remaining loops actually filter the input arrays and return the remaining unique values. A more descriptive and possibly self-documenting way of writing such an operation is given by the method: 

Better yet, take those complex statements as a hint to better refactor your code. I advise to use available language constructs where appropriate. If you replace a simple for-loop with a while-loop for no apparent reason, a fellow developer will have a harder time to read and understand your code. Also, I really recommend to use curly brackets with if-statements. The lack of those might be more pleasing to the eye by hiding the deep nesting, but makes reading and understanding as well as modifying your code much harder. I suggest to combine if-clauses with identical statements. Instead of writing e.g. 

Performance The inner loops are counting how often elements from the first array appear in the second array and vice versa. However, you are not interested in the exact count, only if . So you could use a labeled as soon as the count increments for the very first time: 

Even better, use the newer and more explicit method. However, this changes the semantics of your code due to the different handling of : 

Give those functions clear, self-documenting names to help the reader along. In your case, those could be e.g. or similar. Your algorithm's runtime complexity is probably linear in the number of available cells. If you find that your application is running slow because of that, you can employ techniques such as spatial partitioning to improve runtime performance. 

For brevity, you could encode your messages in a three dimensional array with the dimensions representing row, column and diagonal (no-win = 0, win = 1). This is shorter but slightly less readable: 

Overall complexity: Instead of introducing a new class for something as simple as a random number array, write simple reusable helper functions which return arrays: 

However, the performance of plain loops is superior. Runtime Complexity If you have to deal with larger arrays and prefer to have an implementation with higher setup costs but linear instead of quadratic runtime complexity, convert the input arrays into sets first and use the much faster instead of . Generalization A generic solution which is not restricted to arrays but handles any iterable input could look as follows: 

It works. But you would then need to return instead of . Also, it is less readable as you re-assign the function's return value to the input parameter, which is confusing. Further suggested improvements: Naming: 

Separating logic and view: Your current implementation returns an array of strings destined for immediate output. This comes with a few drawbacks: 

While the original implementation performs better for very small inputs, the improved implementation performs much better for longer arrays. This confirms our above runtime complexity analysis. Plotting the times against the input length clearly shows the quadratic nature of the original runtime complexity vs. the linear runtime complexity of the improved implementation: 

If is not an array but an object, replace with . Performance If performance is really an issue, look into the runtime complexity of your operations. By introducing an explicit from parent names to children files, the runtime complexity could be reduced to depend linearly on the total number of children only. 

Benchmark Measuring average runtime over 1000 runs for input arrays of different length, we get the following results: 

The above results show that - for the given exemplary scenarios and tested JavaScript engine - the built-in plain object and have superior performance compared to . The differences between object and are either explained by more aggressive optimization regarding objects (complete removal of statements without side-effects) or the function call overhead which is huge compared to simple property lookup on microbenchmarks such as this. This practical measurement can be explained by analyzing the computational complexity of the involved operations: An object or is usually backed by some kind of hash-table with constant time insertions and lookups. Appending values to an array is also a constant time operation. Now, it is impossible to complete an operation in less than constant time. So all you can improve is the constant. Which is a hopeless endeavor, as you are now competing with self-made prefix-tree lookups against highly optimized built-in hash-tables. However: If you have more knowledge about the original problem you want to solve, you can come up with a more specialized and thus faster algorithm. One of your comments says that you actually need to perform "thousands of searches for keywords". In this case - if the list of keywords remains mostly constant over some time - you should have a look at the Aho–Corasick algorithm. 

General considerations: Since you don't rely on an external ad network but a self-hosted solution, you might want to inject your ads into your HTML document on the server side, without the asynchronous client side ajax request. 

If your input strings are of length n, your current implementation has a cubic runtime complexity O(n³). This could become an issue for longer strings. I recommend to split counting character frequencies and comparing those counts into two separate steps with nearly linear complexity O(n): 

See $URL$ The JavaScript specification doesn't mandate a specific implementation for , but I assume that the chosen string searching algorithm comes with higher setup cost but better runtime complexity or simply benefits from its native implementation speedup. 

In my opinion, the semantics in JavaScript are too weak to help static code analysis or to allow for compiler optimizations. Where is (mis-)used to signal immutability, I'd go with e.g. declaring identifiers instead. Is my thinking flawed? When writing robust, maintainable code, which of the above samples would you prefer? Is there a middle ground? 

So how about just returning the paging range as an array of numbers? Later on, within your HTML template, you can then print or - in case you print HTML - simply select a different CSS class for the current page. Handling corner cases: In case you choose a range of 5, but the total number of pages is set to just 4, a call to will return including an undesired at the beginning. A robust implementation should probably reduce the range according to the available total number of pages. Fixing issues: Since we now allow user defined values, we need to fix issues arising from values that are not caused by the hard coded "force start at 1" within your code. Putting it all together: Choosing simpler and more consistent variable names as well as renaming the nondescript to , we get an easier to read and understand implementation. Replacing the loop with yields more descriptive code. Adding a single comment describing the function's behavior instead of many individual inline comments helps the reader to better understand the purpose and usage of the function.