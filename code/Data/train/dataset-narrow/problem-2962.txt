A little Hungarian As @talhaIrfan says, the problem is mostly syntax. This is what I discovered when I was struggling with pointers, while at university. Other students that I introduced the idea to would start to improve shortly after learning this technique. I have also introduced it in professional environments, where the bug rate subsequently reduced. You can do a lot to improve syntax by introducing a little Hungarian notation (I do not advocate too much of this, just enough). You need to be consistent, unambiguous, and clear. It should allow you to read your code more easily. I always use an underscore to separate the Hungarian notation from the rest of the name. I always append type information to the end of the name (this is consistent with what the C libraries do). I chose a set of symbols 

Sorting algorithms — dance, or just moving about. Get pupils to act out sorting algorithms. And identify the loops. Here is how to do it in the form of dance $URL$ 

Making mistakes causes your brain to grow, see $URL$ Also explain that the error messages are there to help you, some one put in effort to get the computer to do that. They can not fix it for you (they do not know what you want it to do), but they can try to help you see what is wrong. Often when a pupil calls me over for help. They will, as I arrive clear the error message. Some times they even close the program (thus loosing all of there work). I think the problem stems from calling error messages “Errors”. Pupils (and often experienced programmers), then try instead of minimising errors, to minimise error messages. This is achieved, by ignoring them, deleting them, choosing techniques and languages that minimise them. We need therefore to embrace error messages. And as my first point says embrace errors. Let you pupils see you make mistakes (don't prepare everything up front), let them see how you deal with them. 

UNIX( a type of Unix ) is the system that we could not afford in the 1980s, so instead we bought Microsoft Dos, and then Microsoft Windows. Gnu/Linux is a newer Unix, as well as being Free Software is also very cheap. 

When programming we need to name things. I have been using turtle graphics in python, and was wondering if the names, chosen, for the command, was making it more difficult for my pupils. Some of the turtle commands are: 

Consider also going the other way. We often think of teaching from small to big. However it is often possible and beneficial to go from big to small. Bertrand Meyer does this in his course “Touch of Class”. Provide the students with a working program, have them read the program, make some predictions on what it does, then run it, determine what some of the key grammar/vocabulary does, make predictions on what changes will do, then make changes and re-run. 

I like these ideas for building logic circuits. Some of them are already covered in other answers, but not all. 

As our view of what a computer is changes, it affects who wants to be involved. However a computer is all of these (and more), and it is non of there. It is a modelling machine. Therefore we need to show what computers can do, “what is in it for me?”. Use grate examples to engage with our students. (The more important question is not “Why did it happen?”, but “how do we fix it?”. Though the first question is an important step to the 2nd.) I have recently been watching some videos by Bret Victor $URL$ making programming more like just using a computer, and making just using a computer more like programming. No need to program, to be able to automate a task. I was thinking that if his views come true, then there will be new different roles, for different people. Some of these may be liked more by women. [Sorry I have struggled to put in to words what is in the Bret Victor videos. As I write this apology, I realise that that is exactly the point he was making.] 

Another approach is test driven development: Ask what next, Write simplest test that will fail, Write simplest code that will make test pass, re-factor if needed, repeat. This works most of the time. However, there are times when it does not. For example, the other day I was making an adding machine out of lego (my own design). Part of the build was tinkering and experimenting, but for part I stopped and wrote a plan. It was easier to plan on paper than as I went along, as mistakes could be fixed more easily (it is hard to fix an error in the middle of a lego model, you have to take it apart). I seem to have an intuitive feel for planning (just enough, and just in time). However this is probably not a good explanation to tell others. When students are doing project work, When is planning and high-level design a good idea? When is it not? How do you tell the difference? And how do you teach this to the students? 

The first solution, is the only one that could be used adhoc, without any set up. I have noticed that very few people use MS-Windows ACLs, probably because they are very complex. However there is a sub-set that is simple and useful. With the correct tools they could be made easy to use. 

I have been giving my class help-sheets, recently. This have lead them to me more independent. They are also filling in a S.N.O.T form, this is a form where they tick off tasks, to show if they did it by there Self, with a Neighbour, with the help of an Other, or the Teacher. I have been using these sheets, to give feedback and improve the help-sheets (If to many ask for teacher help, then improve the help-sheet). A consequence of this is that the help-sheets improve over the week ( I teach this lesson 11 times a week). This results in lesson latter in the week being better than at the start. The problem The improvement over each week, creates a bias. The students that have the lesson at the end of the week receive a much better lesson than those at the beginning. After a few weeks this will settle-down, as I will learn what I am doing wrong, and produce better work-sheets from the start. However there will always be some improvements, and thus some bias. How can a reduce/remove this bias?