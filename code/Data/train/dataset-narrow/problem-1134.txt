And it would be great if you just expose the interface and keep concrete implementation with package access, a good API is a compact one. And for that you can have a to get the right implementation 

The problem with your code is it hard to get right and validate. Is it allowed to send an email with a ? It shouldn't, and hence you need to length of the array. 

should never be , I know a lot of db clients do it, but it is really bad, I need to know if things were saved successfully, wishful programming is bad, you could return the objects after saving them 

What makes your abstraction leaky is the fact that is not abstract enough, that is, Manager and client shouldn't be there. 

Avoid magic numbers like 4,15,52 in your code and extract them into constants and give them some useful names. implement and methods and avoid reference equality. 

Have you considered using an , Hibernate for example? You shouldn't append strings to do build queries, use instead. This is the mistake number 3 in the list of top 25 most dangerous mistakes. You shouldn't hard code database information in you business objects. 

Why this hashCode is implemented this way, I don't really understand it. So now, we can make sure that the function relies on a sensible function 

What are the functionalities expected by the users of this class What are the things that users shouldn't care about What shall I hide so users don't break it. 

The best way to deal with compulsory and optional parameters is using the .The problem with overloaded functions is that they are confusing and user of the class or even you can make mistakes while calling this method. Instead of that you can have builder that allows to construct fluently. 

Or implement Guava suppliers anonymously if you running java 6 or 7. You can add an interface for convertable things that your classes can implement. 

This gives a clearer hint to class users that the value they asking for might not be there. If using then is there, otherwise Guava is your friend 

No, this method cannot be improved because it is completely wrong I am afraid. Fact: Sessions are not thread safe, don't try make them thread safe, because you don't know how to do it and there are reasons why they are not thread safe.You can simply return the Session from the factory like this 

What you trying to do here? Forcing the code to get a connection?You can't do that. If you fail to open a connection first time, I doubt you will get it in 2 nanoseconds time. If you don't want to create too many instances, then you should let your container manage it for you. You don't have an IoC container? Then get a Session object every time you need it and don't forget to close it when you are done 

Because you have decided to declare as a , then you have to make it , because mutable structs are evil, and thats a good read if you want to know why And it's not that hard 

You need to be concerned about thread safety in web applications, HashMap is not thread safe so you can use the version. 

Never write code in your files, it is a horrible idea. Use instead. It's much easier to validate your model in the code and not within scriptlets. Use for client side validation 

Quick question, have you tried testing your code? Trying doing so, and you will find the leaks in your code. 

Making it abstract will reflect the actual abstraction of this entity. One more thing, try to avoid as much as you can, it is just awful. You can use time instead, or the new java date api if you using Java 8. 

To insure backward compatibility, decided to allow you to use Threads in your code. However, I blame your IDE for not displaying any massive warnings when you wrote this code because as you said, you aren't an experienced C# programmer. The reason why I saying that is because use in your code. is hard for people like me and you that aren't experts in .If you wanna do me a favour, go to your editor and do and delete all its occurrences, it's only acceptable to see the term in your code if you doing , otherwise it's wrong. So what we do, we use Tasks. In your code you can easily replace by a 

If you want to Sleep never use , this is quite expensive and unnecessary, use instead. You really need to rewrite your code and use the TPL library instead of . Give it a go, and post your code again to be reviewed but with this time 

Catching Exception in general is usually a bad idea, you should be more specific so you don't end up handling exception that you didn't want to handle. 

you can store these information in a configuration file where you can read these values from. Use a framework instead of and . The application shouldn't terminate if you if the registration fails. 

And so on for different shapes, so there is no need for if-statements. Btw: how come you representing a in a class called ?? Single responsibility principle is being violated as well, where your class represents a Box Object and persists it to a database, these are two different responsibilities. You should rather have Data Access Layer to deal with a very like a database. In regards to SQL generation you can those as well using interfaces, and that is, given a shape get its sql code. 

You don't need to load the driver every time you instantiate the class, you could load it once using a static block 

And overriding equals requires .And your equals have to satisfy the following properties, your equals has to be: 

However, this relies on the function, and you need to make sure you get the right.So you have to override the otherwise you will be calling 

Use English for your variable names, request routes, and Exception messages. Imagine a remote developer joins your company (very common these days), they wouldn't be able to understand the stack traces. validate your parameters before creating unnecessary objects 

I wouldn't instantiate connections that way, use Datasources instead. Database isn't a good name for such a utility class, would be better perhaps. 

Use StringBuilder instead of String when you need to append frequently. Every time you do on a , it creates a new String because strings are immutable in Java, consider using instead. 

As you can see here no static methods anymore, static usually presents a global behavior, and I need to force users to go through the constructor so I make sure weights are computed properly. I suppose that what you using is algorithm (not sure though), where your class name is , that's a bit misleading because is not the only algorithm and it doesn't work with negative weights, and you need something like Bellman-Ford for that.If you don't want to support negative weights for now, it is fine, but you should be able to add this functionality in the future.And this leads for extracting the Route finder to an interface 

The class that represents a node should be called and not , this class could live in the package with no public access the method could be replace by for more flexibility 

Especially in loops where the boundaries are hard to understand, don't assume the code maintainer is a professional chess player. 

It should be clear that the doesn't have the name of the project, so instead of the class you can call this class instead. It's all about separation of concerns, you should have seperate class that does the Chess logic and one that does the and use composition to use its features 

I don't like the idea of using exceptions to handle program's state, it assumes that the user of the class is always aware of them. I would simply use a monadic type like 

Yes , you don't need to iterate through the map to know if it contains a certain value or not, you can just call 

One more thing, is it possible to have duplicated vertices on the same graph? I dont think so, and hence should return a of vertices rather than a 

You will get , but how would you know if its -999.00 indeed or it wasn't a valid conversion. Instead you make your functions return value type instead 

A user of this class shouldn't be able to set the count of elements in the queue to the value they want (-1 for instance), can you imagine a queue that is in debt? and therefore should be . 

You have field that you mutating in a multithreaded code, this field can be cached and might ignore you changing it. You can declare it as to avoid this behavior. 

any language you use, you have to follow its naming conventions. Use Pascal casing for classes in Java 

And because their values are known at initialization, its good practice to declare them . your method is not , use instead. Some validation on the parameter is needed as well.