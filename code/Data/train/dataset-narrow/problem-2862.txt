Source: $URL$ bold mine. Also included there are several work arounds, similar to what you've already outlined though. 

I see no reason that this could not be acomplished in a 2D environment using sprites. In fact, depending on implementation, gameplay, etc it might be easier to do with 2D and sprites. It sounds to me like your problem is art work. You sound like a programmer, and that means that you need and artist. Or, you need to become an artist yourself. With the correct assets (2D sprites, tilemap, etc) in place, making a game look like the screenshot you've attached is going to be a piece of cake (realitivly speaking and all other things being equal). 

I don't know if this will get you what you're looking for, but here's a MSDN document on WPF and Win32 Interoperation. The section "Hosting WPF Content in a Microsoft Win32 Window" may be of the most interest to you. Also, from the first link: Walkthrough: Hosting WPF in Win32. While I've never done this, it may be able to get you the benifits you're looking for without having to do too much wheel re-inventing. 

Just like the particle system solution, you can use 2dtoolkit to create the same effect. Add 3 children game object to the character with only a sprite attached to them. Change the alpha and coloring as needed. Then you can vary the sprite's local positions depending on the speed of the character: 

Solved Thanks to everyone who helped me with the issue. There were a few factors in play. First, there was the scale. What I did to figure this one is create an empty scene and put 2 cubes in there. I varied the size and position of the cubes (from 68x35 to 0.65x0.35 for size and the position by factors or 10 as well) and attached a script to move them, with variation in speed by factors or 10 as well. So all else being equal (same size on the screen and time to cross it), the size of the objects elected a different response to collision: big object got interpenetration, small ones none. I am not familiar enough with Unity to explain the cause of that, but it is reproductible. A possible second factor was the shape of my colliders and how it may be possible that they screwed up the ejecting part. The colliders I had were not overlapping, so I simplified them to 2 boxes in the shape of a cross. Finally I was setting the position of the objects manually in FixedUpdate and that caused some problems with interpenetration at lower scale (at higher scale, it didn't appear to matter). I changed that to work with the body velocity and it helped. 

As @AttackingHobo said, the memory is very fast and expensive. Also, you must take into account that these consoles launched years ago, when memory and hardware prices were higher. Another factor that goes into making consoles very performant on what appears to be very limited resources, is that since every console is identical, we as developers can take advantage of platform specific optimizations. On a PC you can't do that as much, and thus you are required to have a beefer PC so it can brute-force its way through a similar unoptimized task. That isn't to say there is no optimization in PC games, but it is in different areas than consoles, and in general due to the wide range of supported hardware, it is less effective. 

If your game is turn based, a combination of long-polling (read Push) and web services (SOAP or REST) should be more than sufficient for any turn-based game. They are simple to implement on a server and consume on a multitude of clients. The advantage of using web services, are two fold. First, just about every platform worth its salt will have a mechanism to invoke web services natively without much ruckus. Second, is that adding additional platforms, or even letting web (desktop based browser) players play against anyone else, is easy since you're just passing messages back and forth over an HTTP connection. In addition to that, since you're talking about Android and iOS -- where 3G connections are likely to occur, an HTTP web service wont completely die in a "flaky-connection" mode, where as pure TCP sockets would have issues staying connected. 

The object you instanciate, does it have some scripts attached to it? The instanciated object doesn't run its awake()/start() until the next chance it gets and not when you call Instanciate(). In the following code 

If you are not using OpenGL, then most games load sprite sheets with rotation already done (see other image).. You only need a quadrant worth of rotation pre-calculated. It saves memory and you can rotate on the fly to 90/180/270 without loosing quality to cover the other 4 quadrant (going back to the first figure, notice that the grids will align perfectly with rotations of 90/180/270 degrees). 

A user keeps a game on his mobile phone on average 20 days. So for the most part, adding ads is not going to be noticed much after launch. However, it is going to affect your biggest fan the most, which is the segment you don't really want to piss off. There are ways to mitigate the effect however. #1 is to only show ads to people who downloaded the game after version X, so old player won't see any ads. Also, do not show ads to players who purchased something (so no ads in premium games and no ads to a user who dropped $5 on virtual goods). I have retroactively added ads into a popular game. The effect was some bad reviews, but for the most part people expect ads - as long as they are not over the top annoying. The rating didn't really drop when I added the ads. Maybe 0.1 points, but that's it. Also you can let the users know that you need the money to make another game... lots of people are quite understanding of the plea of the indie developer. 

It really depends upon what type (and quantity/size) of data you're talking about. If it is a small bit of data that can be safely kept in memory for the duration of execution, something like a static class would be my recommendation. 

Does the code labeled "Game1" occur in the method? If so, the problem looks as though you draw a different question each frame not that you need to draw slower. If you draw the same thing every frame, there should be no flicker; I would adjust the code like this: 

You could write something akin to a tomagatchi or other virtual pet. The original ones were done on very low resolution screens. Pong is another game that comes to mind for a low resolution display. While it may seem basic, it covers most of the important bits in many games: collisions, physics (albeit simple), game-loop, etc. On such a limited platform, you may be forced to "roll your own" for many of those tasks which may take up more time that you anticipated. 

I can't speak to how the Left 4 Dead implementation works, but I can say how I'd probably do it. I'd go for something like your second option, track each player and only load NPCs when players move past trigger points. The key in a system like this, is to make the trigger points far enough away from the player that they are unable to associate that triggers I would probably have an active NPC collection, which the trigger points either add or remove NPCs from the collection. This allows you to spend CPU/GPU resources on NPCs that players are actually interacting with, but it gives you the flexibility to load NPCs at any time. Think about a boss who can hear sounds, maybe the boss is loaded at the start of the map and if the player going through the map makes lots of noise (grenades, pipe bombs, etc), the boss will seek out the player and attack out of the blue, instead of waiting till the player reaches the boss arena. 

It wasn't specified if you want to do a game professionally or as a hobby. For a professional game, you need professional graphics. Minecraft is a great counter example, but an exception to the rule. As a programmer making games for a living, I get the graphics from a paid artist and from online websites that sells 3d models, images and sound. For a hobby, there are free online resources as well as doing your own art. However, if you are anything like me, my art sucks, takes too long to do and I don't like the end result of the game. That means I lose my mojo doing stuff I don't like vs stuff I do like and I am not motivated by my results... which means: I get it from good sources. Get at least decent looking placeholder for your graphics. Then figure out how to get a better version, if you reach the point when you are ready to release, etc.. Don't force yourself to do stuff that will demotivate you - whatever it is. Motivation is the only thing that will make you finish your game and finishing the game will be the most important thing for you to accomplish. Do not squander motivation on graphics if it is not your thing, but realize that a nice looking UI will motivate you. 

What I'm wondering is how complete your design documents typically are before beginning the implementation of a project? I'm talking about medium to very small projects with a very small team here where even fully fleshed out the entire document may only be a few dozen pages. Do you start with a rough framework and start fleshing out the details at the same time implementation is starting? Do you completely flesh out every section completely before any implementation is even started? If so, what percentage change have you seen after implementation starts? If you have experience with one of the two scenarios I outlined, I'd love to hear your opinion on what issues going that particular route caused and what obstacles you feel it helped you avoid. 

One client and server on same computer One client and server on the same SUBNET One client and server on the same SUBNET with additional players from other SUBNETS (Internet, etc) connecting to server via NAT Server on the Internet and multiple additional Internet clients connected 

If you have many states per sprite, I would consider breaking up each state animation into its own file. If you only have a few sprites and a few states, it might be best to simply have it all on a single image file, and use the maping I have above, but include it per sprite. This will keep the amount of memory usage to a minimum, since you're targeting android, memory is a premium resource and should be conserved where possible. 

So as you can see, if you are doing some scaling in ObjectB.Start() and expect that setting the scale right after the instanciation will overwrite the values, that won't work... Of course that's just one possibility, but it did happen to me a few times so that's the first thing that jump to my mind. 

I don't think HTML5 is there yet for cross platform... maybe one day. I have the additional requirements that my games must work on the Blackberry as well... 

What you are trying to do is also fairly similar to what older MUDs did. I am more familiar with the Diku variety and I'll explain it briefly here. If you think that is what you are looking for, you can look up the source code, it is fairly straightforward. First, the different stats and skills are all hardcoded. Strength is a concept known at the code level. Same for hp, armor, stealth, fire resist and so on. All the skills like backstab, spells, hide, etc., also exist in code. All the rest of the data is loaded from a database, even races and classes. So a character structure would be 

XNA Games on 360 use and are required to use -- which as I recall means max users per "game" is 32, and you can not connect to any outside services at all. 

The way that you would do this would be to use the power of C# and create some objects. You would create a Scene object, that would have a Square object, which internally would have a collection of Squares inside it. The method of Scene would know it had to draw its own background, as well as tell the Square object to draw itself and all its children. This is relatively easy with C#, extremely common, and probably the most simple way to do what you just mentioned in your post. A quick sample you might start with: 

You are in the catbird seat. You have a complete and working game. Your options are limited only by how much additional effort you'd like to put into this game. In my mind you have three basic options: 

You'll want to use something like Amazon S3 or Azure Blob storage. Both of these services will charge you for data transfer both IN and OUT; as well as the average storage amount you are using on their servers. They both offer a simple API to read and write data to and from, you can write iOS, Android, BlackBerry, Windows, Mac, Linux, etc versions of your application, which would all consume the same web service API. This gives you the ability to have users interact with data on any platform, and have those changes immediatly available on any other platform. Optionally, you could write a simple web-service which handles your data conversion between platforms, you could use something like Amazon EC2 to host a service like this. Depending on the complexity of the data you are storing this might be over-kill.