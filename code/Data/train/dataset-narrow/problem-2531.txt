I tend to avoid using inheritance as much as possible when it comes to classifying objects based on data used in games as opposed to classifying systems used in games. What I mean is, it may make sense to have a class and then a and inherit the if the behavioral differences will have to be hard-coded discretely in their functions. But if the differences in behavior of a and an are simply going to be determined by the values in a group of stats, things that are best treated as data containers for games, they should just be defined by parameters that all objects share. If you're familiar with the MVC pattern, using multiple inheritance to make similar data containers is like creating a bunch of controllers that only differ in the values in its data members. Obviously it's better to just have one controller and rely on the model to fetch the values that are needed. You didn't go in-depth as to what properties your classes have, but weapon inventory seems to benefit a lot more from a data-driven design. So have just one Weapon class and assign it different properties, and to name them, the name is simply a read-only string member. If you want to have hybrid items (as the mentioned before), perhaps then define a Weapon class that can take properties of multiple Weapon objects, ie. in a Vector or List containing one or more sets of properties. 

If you're not a huge C++ fan, then the question I have is, are you already competent at C#? Any way you slice it, DirectX and its related APIs are fairly complex and you will get stuck in some places if this is your first time using a 3D graphics API. Because they are merely wrappers, they involve low-level stuff that you have to deal with on your own. If you decide you want something a bit higher-level than SlimDX or SharpDX, XNA may be another option for you, but at the trade-off that it's limited to Direct3D 9-level graphics. The best thing, in my opinion, about using a managed D3D wrapper is that you don't have to really worry about memory leaks! The only major performance profiling you'll have to do is GPU efficiency (obviously) and garbage collection rate. 

How you should create the textures depends a lot on the visual style of the game. A lot of texture assets I see from more photorealistic games, (or fantastical games with realistic structures) are indeed retouched photographs. It is mostly just with the diffuse colors that photographs are used. Usually, entire textures for props and smaller details are used, but for entire walls and facades it's not uncommon to combine elements from different photographs of buildings to create an entirely new one for fictional settings. Sky textures are likely going to be taken as photographs too. Games that have more of a stylized look tend to use more hand-drawn textures from scratch, especially if you're going for a cartoon-like look. In this case you'll need some decent drawing skills to pull off good depth and lighting effects. In last-gen games where normal mapping was much less common, such features had to be drawn in by the artist. It is still useful, though, to use real photographs as a reference. If you're not very artistically inclined, use existing photos as a base. CG Textures has a large collection of photographs of realistic materials. The best way to start out is picking a texture and in a program like Photoshop, start adding in additional layers or adjustment layers to enhance the colors or shading of the photo. Gamasutra also has a great article on how to use the high pass filter in Photoshop to improve the look of tiled textures. This filter gives you a finer control over the details of a photograph. 

Don't shuffle vertices around. Shuffle pointers to vertices. You say that you have a vector in which to store raw vertex data and memory, so go along with that, and keep a second vector that contains pointers to elements in your vector of vertices (your memory buffer). Incidentally, this is the same way I figured out how to cull hardware-instanced meshes individually in the same draw call. In short: 

The best ones I know of are Mappy and TIDE. Both export in open formats, and TIDE while not as well-known also exports in its own XML format and supports Mappy FMP, and Flixel's file format, so you can move back to Mappy or easily port to Flash. 

In both views, map the keys according to the view vector and movement of the camera. In 2D view the world may be "flat", but still thinking in terms of looking at it from a Z depth in 3D space. For me it's easier to compare it to a traditional 2D fighter where you can only walk left or right, but 3D fighters allow sidestepping and circle-strafing. Think of how the joysticks are mapped according to these views. It is indeed harder to map WASD keys when the "clear" path to walk along is at an angle offset from what the camera sees, it's why analog joysticks are much preferred for the granularity. Initially, WASD keys should be moving the player along the camera's local coordinates at the moment when the key(s) were pressed. This is the most intuitive way to map the keys when you cannot know for certain where the camera is in relation to the player. That blue vector that points up can just as well be the "away" vector (imagine it going down the camera's local Z axis). Contrast this to "tank" controls where W and S move the player along the vector to what the character sees. Since your camera moves along a spline, its local coordinates change, because the tangent might change. If the player is currently moving and the camera changes direction, do not update the controls to its new local coordinates until the keys are released. This way, the player can keep running along a straight path without frantically switching controls as the camera moves. I pretty much learned this making a Marble Blast-type game, such a game would have more slippery movement and require twitch reactions. If I wanted to U-turn on a dime, I would initially press Down to move towards the camera, but as it quickly swivels around, I would be again going away from the camera, but still holding Down and moving in the other direction. Upon releasing Down, the controls "shift" to match the camera's new orientation. 

Treat projectiles as particles and use a kind of particle system to manage them. In essence you know you want to control where the projectiles spawn, and how long/where they are deleted, but moving the projectiles should be automated. Instead of the Fireball class extending the Sprite class (which to me already sounds like a bad design), have the ProjectileHandler class with a list of Fireball objects, each including a Sprite. Fireball objects define a direction, which the ProjectileHandler uses to update the position. This way you can spawn a new Fireball with any sprite you want like: and the FireballManager adds it to the list. You may notice that the Sprite could be just about anything here, so Fireball can be just as well be given a more generic name to suit all kinds of projectiles. The ProjectileHandler is unaware of what texture each projectile uses for the sprite. The dragon may use different, bigger fireball sprites, or you may want the wizard to upgrade his attacks and have the new fireballs look the part. Byte56 did mention that texture switching should be kept to a minimum, so this implementation has that drawback of not doing so automatically as different sprites can be added in any order. I suppose a sorted List of would solve this, but don't try to optimize yet unless it becomes real necessary. The reason I said it's bad to have Fireball to extend from Sprite is that Fireball is treated as a projectile, not a Sprite. It should instead contain a Sprite object to represent that Fireball visually. 

Keep in mind that I am describing a brute-force culling method with linear time. If you are using quad-tree or other spatial culling algorithm, you would need to give a unique number identifier to each particle and use that to in place of i when assigning pointers. Now, visibleParticles is at least partially updated with different pointers, but when it's time to render, you'll only be using the ones from the start of the vector to visibleCount. Still, you'll be able to copy the entire thing into the buffer. Lock the vertex buffer, memcpy the visibleParticles vector into the buffer, and unlock. You now have all the updated vertices updated with one memcpy call. memcpy should be okay here, since you're guaranteed not to change the number of maximum particle elements in the vector. Finally, draw the particles by using the value of visibleCount for the numVertices parameter in DrawIndexedPrimitive. 

Gas13 has some guides to drawing classic pixel art written down. These are really general theory stuff- he's not going to hold you by the hand in step-by-step tutorials, but instead explain the principles on what makes a good game sprite. I would start with this following page: $URL$ Even something as mundane as creating a grass tile can be improved in detail, and then you can learn how to move on draw more complex objects with depth and definition, using a limited color palette. 

The simplest State Manager system I can think of doesn't use a stack or multi-object structure whatsoever, or even a "StateManager" type of object. You just need a GameState class with an Update function that returns a GameState pointer. When its main function begins to run, assign a pointer, say, called "currentState", to a new GameState you want to run on startup. In the game's main loop declare another GameState pointer called "nextState" and assign it to currentState->Update(). Depending on input and other events happening in the Update function, the function can either return the GameState it belongs to (continuing as normal), or a different GameState (something happened in the game requiring to switch modes). After this update, compare nextState to currentState. If they are not equal, delete currentState and then assign it to nextState. This is good enough for basic games which do not care in what order states have entered/left. It's a little tougher for a beginner to wrap their head around, but the code is much lighter. 

Proceeding with levels seems like a good next step, it can teach you how to create data structures to fit your game, and file input/output. Also, I would just have tried to build the engine with a set target game in mind. You don't have to be very specific, but say just make the engine for a specific genre that you like. When you know what to make with your engine, you have a better idea of what actually works in your engine and what doesn't. A good engine would have been "battle-tested" already, and usable in real-world cases. I have been making a game around sample framework code- as I added more features to it that the game would definitely use, it became clearer which parts can be re-used for future games.