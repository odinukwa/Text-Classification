Your variable names could be more clear. is a poor choice, for example. is probably not a great name for a method either - maybe ? You have inconsistent code style. Some one-line blocks are in curlies while others are not. Why ? It's fine if you want to use wherever possible, but that doesn't appear to be the case with the rest of the code, and there's no explicit reason for it be , so what is the strategy here? I'd save the you pass to as an instance member instead of creating a new one each time. Why do you use an explicit in , but nowhere else? I'd choose one or the other. If you've got those tests to ensure everything is happening on the main thread, then why ? Wouldn't to the same thing? 

Your friend is suggesting you have a class that does the common work, and then subclasses to handle specialized work. This is really core OOP. For example, your base class (say, ) might have an method like this: 

Then when you create the subclass, you'd set somehow (either directly through a setter, or with Intent arguments, or most likely have that class be and define in the subclass). Then in each subclass, you'd call , as well as any other specific functionality, in the subclass's definition of . That's just an example, and could be handled differently. Generally speaking, if you see the same block of code in multiple places, you could probably optimize that away. Single Responsibility Principle is not relevant in any way here. Basic inheritance ($URL$ and DRY ($URL$ are much more appropriate to what you're describing. 

Your variable convention is inscrutable. Why is private? Why are the next three package-private? Why does look like a constant but is neither static nor final? Why are some member level and the rest static level? Variables names like , , are not clear and should be reconsidered. Your static variables are A) created whenever the class is first referenced, and B) may outlive the Activity. I don't see any reason in the existing code for these to be static. You should probably coordinate your thread with your activity lifecycle. For example, check if the Activity is still running in your download while loop, and exit out if not. In your , see if you still have a UI to modify. You might want to cancel the during or . Your code style is inconsistent. The whitespace convention changes throughout and is hard to follow. You have some single-line blocks without braces, and some with braces. You have some blocks with a brace on each line and some with 2 braces and a statement on one line. You don't test for null in when examining the String returned from - it's very likely that http connection could fail (server down, interrupted connection, etc), and you'll end up throwing an NPE if that happens, rather than managing it. is probably better as is not clear. I also don't see it referenced anywhere. Add javadocs. 

There is a much, much, much easier way to do this. You can use real values for order, so when you want to move the row from position 16 to position 7 you give it an order value which is the average between the order values of rows 6 and 7. The precision of real numbers is huge, and I presume that the re-orderings of images in your database will be happening at human reaction speeds, so you probably won't run into precision problems during the remainder of the expected lifetime of the universe. But if you are really insecure about the possibility of precision problems, you can rectify your table every once in a while, by reading the rows sorted by their order, and writing them into a new table, re-assigning the order values by copying them from an integer identity field. Then you delete the old table and rename the new table to the old name. 

This class has a well defined role and by keeping it intact you are satisfying the Single Responsibility Principle. So, I would leave it like that. Perhaps you might want to look into how you could refactor some common code out of each method and into a separate utility class, but that's all. 

Another solution would be to properly filter your input. It is easier, and it is also more dangerous, because it is easy to miss something. For the example at hand, you need to parse the user input into a number, and then convert that number back to string in order to append it to your SQL string, as follows: 

I think you should add a numeric field indicating the order of a card relative to the other cards. You do not need to use it for anything other than sorting. Also, instead of taking the identifier of the enum value and doing uppercase and lowercase tricks with it in order to turn it into something presentable to the user, you should just store the name, too, as a separate string in the enum. So, it would look like this: (where 0 indicates lowest order for sorting.) Furthermore you can also add one more number, the 'weight' of a card, to use in calculations which determine whether a card beats another. In general, enums in java are very powerful, so powerful that you pretty much end up not having to use the switch statement with enums anymore, because you can include a big part of an enum's functionality within the enum itself. 

The main difference here is that you have deferred the creation of the random value to the callers end. The calling code will also be required to either use generics too: 

For reference you can also check this excellent article from Smashing Magazine (check the author) and related GitHub repository. 

Caveat: I've never written a line of C#, nor do I know anything about its compiler. I think that the approach taken in your code could be considered the more modern approach. It is definitely more suitable for human consumption, and it makes it more easy to test individual parts of the algorithm. With luck it will compile down to very similar byte code too. But, your code is inelegant in that you loop twice skipping alternate elements. You also have a bit of smell where you have the code . I'm not sure what the accepted usage of Tuples is in C# but for internal use I'd have thought a single function that returns you an (insides, outsides) would be acceptable - if not a little helper class with two elements. This would modify you code to begin (pseudo-ish): 

So, if you're clever about getting an index in there you could write the algorithm (without validation) in just 3 lines and you'd have done a bit of functional programming which sets you up nicely for playing with a new language. 

Modify this to render just the first three links, then your ellipses (...) separator and then the final page number. EDIT to add pseudo code This is messy but hopefully gives you the idea, create your function, make it work and then post a new question asking how to make it prettier (for example tidy up the ifs, add logic to only render a single set of ellipses, don't repeat any rendering code). 

Your iterations would need to evolve to use the SortedSet#tailSet or SortedSet#subSet methods. Both of these are just new views on the same data so they are cheap operations. A pseudo approach: 

Finally, you say you have read about the factory pattern, that is ultimately what you are playing with here. Note. I think Enum naming should use the singular (Type) rather than the plural (Types), you are not selecting an Object of type Types as your Object (Types.DOUBLE) represents just one type. 

Firstly, underneath everything Javascript is an event driven language so I do not think that there is anything wrong with using an event driven design pattern if you are comfortable with it. Events are a great way to be able to interlink different components of your system without exposing the inner workings of them (loose coupling) and they add queuing by default. However they are more complex, they make it hard to trace behavior which in turn can make them hard to debug. I think that you would get a cleaner interface by developing using something called the revealing module pattern, there is an excellent resource on various design patterns by a guy called Addy Osmani at adyosmanio.com and the revealing module pattern specifically here. This (or a flavor of it) is commonly used in jQuery plugin development which you can see on the jQuery advanced plugin development page (see Keep private functions private). By following these principles you can keep the private stuff private and only expose the functions that you want the calling code to have access to. You mentioned specifically , and so a quick example of how that might look.