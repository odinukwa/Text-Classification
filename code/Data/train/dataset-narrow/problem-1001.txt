While this may seem "decently normalized", it's not. As you said yourself, there will be a lot of (redundant) NULL values, but also, relationships will not be enforced correctly, as this schema allows for duplicate records for any combination of Post/Group/Link and Tag. For instance, you could have two tagmap records with the same and . Now, while you could add a compound key consisting of PostID, GroupID, LinkID, and TagID, then you have another problem: a single record can contain more than one (non-tag) Post/Group/Link relation. e.g. a tagmap record with = 1, = 1, AND = 1. This can lead to update anomalies. See Second normal form. A normalized solution would be to have three separate tag-relation tables as abuzittin gillifirca suggested: , , and . Doing so will eliminate all the redundant NULL values and allow you to enforce relations correctly. Having said that, I'm guessing you came up with this design, because you want to use a single query to fetch all entities assigned to one or more tags. You can still do this with multiple tag-relation tables like so: 

People do this sort of thing all the time in the JavaScript (this.arguments) and Python world (*args); however, by removing type constraints from the parameter list, you have to be wary that you're always providing the types of parameters your function is expecting. If one of your parameters is supposed to be a string, and someone passes in an object, bad things may happen. Conversely, some very respectable projects use multi-line parameter lists. It's fine to have a lot of parameters, as long as they're all necessary, but it's always good to be skeptical. Long parameter lists is a good code smell – if you see them, the code may need refactoring, but not always. As far as the attributes of Box's, forget about programming for a second. Conceptually, what are the properties of a box? Can a box still be a box without a color, tileW, tileH, walkable, speedY, and speedX? Can a box still be a box if it doesn't know how to draw itself? If your answer is no to all of these, then your code is fine, and requiring parameters as a single collection/object vs. individual parameters is (arguably) a matter of preference. That being said, I would move the three lines to a separate method . It's best to only do construction in the constructor, and leave the rest – like rendering – to other methods. 

If you can't guess, try it; it's a good way to learn =) Anyway, you don't want that to happen. So you can do this several ways. Before I'm going into two idiomatic options, let's talk about your interface definitions: 

(That said, I'm not convinced it matters — the compiler should probably optimize this anyway.) I tried it and was very surprised to see that the benchmarks were still very poor. Turns out, you called the wrong function in your benchmark :-) calls insead of . Retrying it with this fixed leads to the expected result: 

You're saying something similar here: "give me a and I give you a ". It's better if you want to have a concept of a variable that you'll later pass around or reuse. 

It doesn't seem that the library has a query builder or a specific type. So building a query in an idiomatic and readable way should be done as you would do for a normal string, and that is using the package. This will allow you to get rid of many code smells: 

And, no, there's no easy way to have something more dynamic that , unless you have a specific use case in mind (and then, you would use an interface, but this is out of scope for this question). See this for a detailed discussion on why Go doesn't have generics for now. 

I ended up using the decorator pattern. The report view and each graph object now implement a method. When the report view's is called, it iterates over each graph, calling the graph's . The latter method receives the report view as a parameter, and this provides access to convenience methods for creating/retrieving DOM elements for the graph to attach itself to. New report view: 

$this->get('feed_parser') is just a fancy way of getting a SimplePie object from the PIMPLE container - you could just instantiate a SimplePie object yourself (if you want code you can't test). After running this code, $item would be a PHP array (or some collection class) containing the details of one image. In my case, I then exposed this as JSON and a REST API endpoint for use by JavaScript, but you could just as easily have PHP output the appropriate HTML. 

I think this is fine for something as simple as a volume control; however, there are some limitations to at least be aware of: 

As far as I know, Meteor's reactivity is one-way: changes in data are reflected in the DOM. To go the other way (DOM to data) there's two common methods: 1) grabbing data directly from the DOM when it's needed (i.e. to save it) as you've done above and 2) binding DOM elements to data models, and using the data models for CRUD operations. 1 is simpler to implement, but 2 gives you more control over data-flow, subscriptions, and life-cycles. 2 has plenty of great libraries you can use, so you don't have to reinvent the wheel just to leverage these benefits. Backbone.js is probably the most well known plain-JavaScript library for this sort of thing (also check out Lo-Dash and Exoskeleton if you haven't), but the Meteor ecosystem may have a preferred library for this. 

Minor: don't panic. This is encapsulated in a function (that, indeed, does too many things) so the function should return an error if something bad is likely to happen; and you should let the caller deal with the error. Furthermore, is almost always what you want rather than . Major: don't use a regexp to parse HTML. Seriously, don't. Consider using the html Go library instead. 

It's very simple; what you're saying here is "give me a , I can give you n random values from it". Option 2: 

Naming conventions aside (short names in camelCase are typically used in Go), this is the right way of doing what you want. The authors of Go have a different view of what is more readable & maintainable than the authors of Python :-) 

In short: your method should be two lines long, your method should be three lines long, you shouldn't have more than 2 global variables, and all errors should be caught on . 

and not implement any other functions. will "implement" , calling will do what you expect, and trying to call on it will panic (nil pointer dereference). 

In , you're needlessly allocating strings by modifying the variable. It would be a fairer benchmark to write it in the following way: 

you could also write but it's not that important. Now, the rune/string/byte question is the interesting one. deals with only; and converting strings to bytes and back is expensive (new memory allocations each time). So I'd change your code to use instead of , and instead of . The function becomes faster: 

Definitely separate your PHP from HTML as Alex suggested. You probably don't need to go the full MVC route for something so simple, but simply generating your PHP variables then outputing your HTML would make your code a lot more readable/manageable. I like your idea of generating a random string and checking it, but Flambino's right, it will never be reliable (by design) - also, imgur probably hates you ;) A simpler approach would be to consume imgur's RSS feed: $URL$ I was bored one morning, so I added something similar to the login page of one of my projects. It pulls one random image from lolcats' RSS feed and inserts it into the page. Here's the code that pulls the image: 

This will make sure that sure only one $db is ever created. Here's the source code from Pimple's method for demonstration purposes: 

This looks pretty good, not much room for improvement I think. LinkedIn's JavaScript is calling linkedInApplySuccess, correct? All you have to do is specify data-success-callback, or something similar, in your HTML? The only minor thing I would do is instead of sending just the job ID, send the entire JSON object. As long as resources aren't an issue, it's always best to capture all data and disregard the stuff you don't use rather than only collect the stuff you're currently using; this is because requirements change, and in the future you may want to do something with the data you've been ignoring. For instance, you may want to calculate how many people are applying for jobs with the position "Chief Weasel Wrangler". You can alter your code to something like this: 

You client code is incompatible with the argument type of (I guess you meant to write instead of ?). But this is strange to have for an expiration time, most probably should just be renamed to and be an . The code could be more idiomatic. Your variables/functions have long names that aren't really useful. You could replace by , by , by , by , etc. Your function does many things (type conversions everywhere!) so that's confusing. You should probably refactor away a function like: 

why not: log.Println("fetching from hacker news", fmt.Sprintf(newsUrl, i)) Using everywhere makes your code not very resilient. Maybe it's worth looking at "what can fail for transient reasons" (typically, database transactions…), and re-try the thing that failed a few times with exponential backoff. There's lots of whitespace in the "what stores the data" part, which isn't very idiomatic. Empty lines in functions aren't really frequent. 

Yes, this is the way to do error handling in Go. By design, you can't let exceptions propagate to the callers "silently", you have to consider what makes sense at each step. I found that on large-scale projects, it makes it significantly easier to predict and test the error handling behavior of your code. It also forces you to put the error handling first, which (imho) results in more readable, less nested code. Truly global variables don't exist in Go — if a package exports a variable , other packages will have to call to access it. That being said, it pretty much never makes sense to do that. In the example you gave, cmd.go and project.go are in the same package, and all package-level variables are shared, so identifiers conflict. If you want this variable to be shared, it's more readable to put all functions that use it in the same file. When you want to mock some of your functions, it's the sign that there should probably be an associated interface. You can then "mock" an interface easily, by re-implementing your interface in your tests and making it do whatever you want. I find this more readable and idiomatic than using complex frameworks. 

Ah, the age old pragmatism vs. purism. While it sounds like you have a healthy amount of skepticism, I think this is actually one of the few instances where it's OK to use a global variable. The core of your problem is you need to share data (state) between two routes. A global variable is the simplest way of doing this if all you're doing is appending the number 4 each time. Here's some things to consider: 

Likely, just has a single default state, but if you ever want to construct this object yourself, you should consider return-/exporting the definition from your module, rather than returning an instance of it. A simple solution here is to simply return the result of . Use a template. In the future, you can use additional templates to support other platforms. e.g. start with a desktop template, later on create a mobile template, and choose the template dynamically at runtime based on the environment. 

The advantage here is can be anything as long as it shares the same API. OK, so now let's talk about ensuring only one DB connection exists at any given time. Since the DI dependencies are just anonymous functions, you can just use the static keyword inside of the dependency definition; however, Pimple makes this even easier by providing a method that does this for you. As per the documentation: 

and then, check directly whether the result is within your interval (without your auxiliary function, which just hinders readability). Now, the bad news: computing the number of days between two times, even assuming that they are in the same timezone, is hard. Your function only works if you are in UTC. To truncate to day for any timezone, use the solution in the accepted answer of this StackOverflow question instead. Once you have you correctly-truncated times, getting the difference in days between them is not as easy as you think: if you simply divide by (like you currently do, in a somewhat weird way), this will fail if the times are not on the same timezones. You say "that's not a problem", but you're probably wrong: most places in the world change timezones twice a year, for daylight saving time. So you have to take this into account… You have two options: 

→ , same for . is more readable. You can also convert everything that represents a time into a or a , rather than deal with Unix timestamps. There are functions in the package that do what you want to do (, , etc.). About that, why does need to do complicated things with times, checking when was the last time it was called, etc.? Shouldn't the caller take care of this with a simple instead? It feels like this complexity shouldn't be there. is a weird name for an implementation. maybe? Your package isn't very idiomatic, which makes the callers do weird things to use it. For example, why do you have a struct that doesn't contain anything? Why not simply have as a package-level function? Same for the other empty structs of this package (…). It's more idiomatic to test for rather than . I'm not exactly sure what you're doing with (this is pretty complex). Maybe add a comment for the line or refactor this part? Talking about refactor, is way too long. Split it in sub-functions. No need for an after . Rather than: 

I'm not following. Which file/object? You appear to pass the JSON object from to your constructor, and this is just a plain JavaScript object. 

After a cursory glance at the character codes for these, it looks like the lowercase is 32 (decimal) higher than uppercase. e.g. 'é'.ord - 32 == 'É'.ord You could try something like this: 

Since this is all the code you posted, I'm going to assume you're only using these functions in the place they're defined, so the later code would be best. It's more readable and doesn't include unnecessary identifiers. Your question is really about anonymous functions, not closures. To answer this question, you should ask yourself, "do I plan on using these functions elsewhere"? Since anonymous functions, by definition, are not bound to an identifier, they will be inaccessible everywhere except where they are defined. This is the version that I would recommend: 

Since RequireJS invokes the module, it would be problematic to construct dynamically. There's no good way of creating more than one instance of your view – probably not a problem. The View is tightly bound to a specific DOM structure. This means it will require extra code to make your View responsive. e.g. a small volume control for mouses (desktop) and a big one for fingers (mobile). 

You could simplify this even further by using a single CSS class for all elements that need animating. e.g. Also, if there are any animations that are triggered by mousehover, you could do all the animation in CSS with the pseudo-selector. Finally, make sure the CSS transitions you use are compatible with all the browsers you're supporting.