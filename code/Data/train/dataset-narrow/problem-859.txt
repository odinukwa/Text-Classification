Note that i split the calculation of prod as there might be rounding errors otherwise. So that should give you an idea about what to write. Generally you code is terrible to look at. 

There was a similar question recently. The one main gist is that you should not add the random device as a member C++ Random Number Generation In the end you also do not really need it once you initialized your Engine. Consequently you should only put the engine in you class. 

So I think the first thing to note, is that if you want to merge N vectors you should start with the longest one and then procedually increment from it. Also i think you do not need to develop a function for an arbitrary number of vectors, but a good one for inserting one into another. Because then you can just iterate over vectors U2...UN inserting them into U1 (Given that U1 is the longest). Also it is unclear what you actually need. Is it just the number of elements? Because your code doesnt merge the vectors but just counts elements that would be in the merged one. If you really need the actual vector you might want to consider C++ std::vector for this task. 

Is bad, especially if you consider switching to a stack that is by default based on a deque. Instead use the right function 

So now to the problem at hand. I think your data structure is indeed badly choosen. The first thing to note is what is important. 

Do not include headers Do no use namespace std; Encapsulate your data Lines are cheap so use it. Stuff like is a bad practice. Characters are cheap so use them. Names like are terrible because noone that read some code knows what it is. If you name the variable rather than it is not necessary to write a comment about it and the user sees the purpose whenever the variable is in the code. Have a look at the standard constructs like operators. 

Now you could optimize your set further, by checking for multiples etc. Use a std::array for your leafs, as its size is static. You could obviously also use a bitset. 

The only way that you can change the last movement is via DepositMoney and WithdrawMoney, so the function SetLastMoneyMovement should not be public, but only be called via those other methods. You seriously lack any form of error checking. What if the user inputs wrong data, are there bounds etc. While your code works, it does not show a valid concept of the problem at hand. The ATM only knows persons and a person has multiple accounts. Therefore, your ATM class should only have a list of available persons and you should create a person class that in turn has the information about that persons accounts. At the same time account balance last transactions are relative to an account and not the person that own that account. So as a stub i would suggest the following design (I ran out of time too :( ): 

There are 3 dereferences and one multiplication here and the braces are just hard to read. What makes it really bad is that it is completely unnecessary. 

You can declare const in the constructor and add explicit so that there is no other possible constructor. I personally dislike using int for variables that are strict non negative, but this is purely opinion based. You can use range based loops in your implementation 

Declare variables where you need them. This is not ancient c where you declare everything at the beginning of the function. Stick with a given code style stuff like this is just terrible 

You can paramterize a circle via a radius and the angle. Therefore, for the cycle with radius r around (h,w) you can calculate the x and y coordinates with the following equations 

This only takes 0.018s on my machine, which is considerable faster than the other approach. The only caveat is, that you have to dereference the values of the edges. 

The first thing to note, is that this is highly inefficient, as you only want unique elements of your string. This kind of asks for a Most importantly if you look in your favorite book you will find the following constructor: 

While you might just want to use the default move constructor and move assignment, you should mark them Otherwise the compiler needs to wrap those with exception handling code. 

I encountered a very similar problem and believe i found an efficient solution, that is even better when done repeatedly. In my case we wanted to know the k largest values of an array without changing the array. The approach you took was that you copied the data then sorted that and searched agaion in the original data. What is better is to sort references to the data 

You are always using . This involves a copy of . If you do not alter then you should use As far as i know it is more idiomatic to check for existense of an element in a set via count. So rather than you can check or the in my opinion way better Your code assumes every node is unique. You might want to adopt to a more robust approach utilizing a that holds the data and then wr on pointers to that node 

So the obvious hack for digits is to actually read the number into a string and then walk over the characters of that string. You can write your own lambda functions that do the correct thing for a given char and use std::accumulate with them. 

Do not use It is a bad practice that you should stop as soon as possible. Do not trust magic macros like . For such small code fragments that are repeated only few time it is often way better to write it out. use std::size_t instead of unsigned long long int You already know the maximum number of chewing gums, So reserve space for your vector early to avoid reallocations. You can always later call to free the unneded memory. Use descriptive names even in challenges that only call them N or K. N is the number of gums so call it or whatever you want. This improves readability quite a bit. This also goes for example hardness, which is a vector so it should be plural e.g. hardnesses. Declare variables when you need them. This creates more or less independent code paths that might late be put into functions more easily. In your loop you use . This requires a copy of it before the increment. Especially for iterators and friends is more efficient as it does not involve the copy. Try to separate command flow with a whitespace, e.g. . This helps to discriminate it from normal functions. EDIT C++11 knows the language construct , use it rather than 

Depending on the C++ version you are using you want to consider using range based loops for C++11 and higher. Then a loop like this one: 

However, this function does something really terrible, as it overwrites the parent member of node and all its parents, which is most certainly not what the user expects of a function called "find". So you should rather add a temporary for that 

denies construction by reference or move semantics. Although as you deal with basic types this will most likely not be a bottleneck 

Do not use namespace std It is considered bad practice and doesnt save you anything A class with only public members is not really usefull, you might use a struct for that. Also you have open coded the constructor of the node: 

Use C++ features like std::string. There is no reason for you to put into the mix. Rethink your data structures. You want to build a trie. That trie consists of nodes. So I would generally expect one object that is a node and one that is a trie responsible for creating and storing the nodes as well as traversing the trie. Your choice of a map is a rather bad one. You want to compare simple characters one at a time, for which the (unordered_)map is an overkill. Simply create a std::vector of the trieNodes that represent the respective characters and you are fine. It is correct, that you only insert, if the first char is not found, but make this more explicit.