I've been in groups before, and multiple people were supposed to code. It was a system where you had to be on the same computer for it to work. It fairly well approximated pair programming - we were discussing out loud, and one person was watching the other giving suggestions, and the other was coding. The people in the group that I was mostly working with weren't annoying, and a couple were semi-friends. It was terrible. I'd programmed before the class and the other student hadn't, so I was a bit better. That made it even harder, because the other student was less likely to, say, use a function, or make some aspect simpler, or whatever - so I felt like I was taking over too much to fix something, or suggest a better solution, and I ended up doing more of the coding. There was a time limit, obviously, so since I was faster at coding (and I also could keyboard, whereas the other student couldn't), the other student often was like, "hey, we need to get this done, you obviously know how to do it - just do it". The teacher stepped in and put the other student at the keyboard, but since a. the other student couldn't keyboard, (just pecked) and b. both of us now felt even more rushed, because the rest of the group had finished some of the mechanical aspects (we were in an engineering course creating a "elevator" type thing), the whole thing just got worse. 

This answer's based on "A History of Capacity Challenges in Computer Science" (2016). As we can see in the plot, there's a rapid rise in Computer Science majors until the mid 1980's. It seems generally agreeable that this followed from computers being an interesting field of study. 

outnumbering men by at least 3-to-1 in all of those fields. Each woman who spends all of her time studying to become a doctor is a woman who isn't studying to be a computer scientist. The clear common ground between those four fields is that they're highly social and focused on helping others. By contrast, men dominate the fields that are perceived to be the least social, i.e. Computer Science and Engineering. There's also some variation based on how math-heavy a field is; for example, women are relatively more likely to do Biology than Physics. But, that effect doesn't appear to dominate. For example, women are fairly well-represented in Math and Physics. Also, women may choose Biology more often because it's a popular major for students planning to go to med school. Asking students directly If you're an instructor in high school or college, then you have direct access to students around the time that they're making their study choices. So, asking them what they want to do and why seems like a good path toward personal understanding. You're probably going to hear stuff like "I want to help others" more from the women and "I like computers" more from the men. Ultimately, their major will be their choice, so it's all about understanding what they want. Two big peaks for CS degree obtainment, regardless of gender Looks like CS degree granting has gone through two big peaks during this time: 

Building off Bennett Brown's answer about creating an "alphabet" with DNA... It is being researched how to efficiently store data in DNA. Here's some thoughts you can cover: 

I'm going to be honest - I'd question them first. Maybe suggest tutoring to see if they like it, and really trying to get at what they want to do. If they want to teach at a university and also do research, that's one thing. If they want to teach at a highschool or middle school, that's quite another. An example: I've emailed a professor at a university near me. He does extensive research, especially in molecular computing and so forth, and he emailed me apologizing for not responding sooner because he had been working with a colleague in Spain on a research project. (::jaw drops in awe::) He also teaches a few classes at the university. This is at a pretty good public university. In contrast, I've taken a class under a teacher in my middle school in engineering/robotics/programming. It was a pretty good course, I must say, but I should point out: he taught three engineering/robotics/programming classes a day, three math classes, and then had a prep period. He also supervised the mock trial club and the robotics club, and I think he might coach a sport too. He as far as I know does not do research. This is at a really good public school. Quite different. If your student wants to do the latter or the former, fair enough! Both are good pursuits. Just make sure they know what they're getting into. Things might be better or worse depending on whether the school is public, private, what area it's in, etc. Also, maybe they really just want to do research, or maybe lead a team in industry. On the other hand, it's perfectly okay to change careers - I know multiple people who have done it - so maybe they want to do one thing and then another. That's all fine, but just make sure they know that they want to do, and that they've tried doing it. Also, point out that they might want to take some education focused classes along with their main classes. 

This can make sense in the capacity explanation, because interested students would've been less able to achieve a CS degree due to rising entrance requirements. However, it's still strange that student interest drops back below obtainment after that. If it really was a capacity issue, then maybe students reasoned "CS is too hard" or "I don't have the grades/background to get into the CS department"? 

Focus on the well-agreed-upon concepts. You don't need to understand them or even be able to use them just yet, but have them in the back of your mind as you progress in your more foundational studies. Take note of the skills and tools that seem to be most useful in the current community. For example, if the field seems to be best-attacked through a particular branch of mathematics or using particular computational tools, then you might want to put acquiring those skills on your to-do list. 

They help you trace through your notes to find something that you recall but need to reread. Especially in research, understandings constantly change. 

The first peak, around 1985, is before my time. However it's my impression that there was a major loss of momentum around those years. The term "AI winter" was coined in 1984, suggesting that pessimism was prevalent enough to assign it a name in discussion. Presumably this pessimism dissuaded incoming college students from selecting CS, causing the drop a few years later when they graduated. That second peak looks like it's centered around 2004/2005, suggesting that students were really optimistic about Computer Science around 2000/2001. And those years were the peak of the dot-com bubble, which started its clear burst in late-2000. It seems probable that the dot-com bubble bursting dissuaded incoming students from going into CS then, too. Females in specific also followed this trend, and had the same peaks: 

Tell them about role models - people who have experienced it, but pushed through. Think the movie/book Hidden Figures, or colleagues of yours, or even you yourself. Give them people to contact (like yourself, or other students) that are role models or who have gone through it. Encourage them to not care what other people think. They chose to go into computer science for a reason - because they enjoy it, probably. Don't let other people stop you from doing what you love. Of course, this doesn't mean that words or actions aren't painful - it's to encourage them to push through that and just do what they've trained to do. Give them ways to respond, i.e., going to HR/management/something within the company, documenting it, things to say, etc. Tell them that they are part of the group that's working toward stopping it. Get them angry, and ready to do something about it if they encounter it, not just blow it off Seek a good environment. With so many companies needing programmers, they can pick the good ones. 

I was at this camp one summer, and it was a programming camp for building models of different systems. I was super excited - I'd already been programming on Khan Academy and Codecademy. So I walk in, and they say that we'll be using this language called StarLogo Nova. We open our chromebooks, go to the site - and I begin questioning things, because I figure out pretty quickly that it's a drag and drop language. I had (have?) a dislike for drag and drop languages - I had tried Scratch after doing what I considered "real" programming, and I didn't like it. However, that class changed my mind. We created a model of an epidemic, a model of an ecosystem - and I was hooked. I literally still occasionally take a look at those programs when I'm in the mood and add new features. The about-face was because, I think, it felt useful. I felt more able to create something cool in StarLogo Nova than Scratch. So I guess, I'd say to first, pick a good, fun DnD language, and second, build something cool in it and show it to them. You might also go into the idea of higher vs lower level programming languages, with DnD languages just another step higher than something like Python. Assembly is no more "real" a coding language than Python is. (If anything, it's the other way round =P) All this being said, don't stuff beans up your nose - your students may not even be thinking any less of DnD languages and may have quite a bit of fun without you saying anything at all. 

Seems like a developing field is a discussion that a community of researchers engages in. To participate, you'd need to: 

Once you have some basis for understanding the discussion, then you focus on getting your own ideas straight. In the end, it's really all about you; sharing research results really isn't a goal so much as a duty to be performed when/if you become the foremost authority on some particular understanding. If you're a younger student, you've probably got a lot to learn and develop before you can really enter that arena. But, if you're interested in it anyway, it seems like you could do two things: 

From a systems approach, capacity issues do make some sense for explaining a peak like the one here. The rapid inflow of students could be allowed since they were filling available capacity; then, once that capacity was taxed and admissions was allowing too many students into the classroom, they'd have had to cut back on allowing new students in. Helps explain the difference in interest-vs.-achievement The mid-1980's peak is the basically one place where Freshman interest is higher than degree completion. 

Sites like hack this site are completely legal and allow users to experiment and learn about vulnerabilities (in this case, using them to solve levels and challenges, but it will teach them how to avoid them in their own code). You do need to create an account to access any of the challenges, but it's a great site. I'm pretty terrible at it, but it's fun to try to figure out. Multiple challenges in the basic level involve SQL injection. Let them try it on their own programs or on a dummy website or two that you set up. 

It appears that the student(s) in question don't really want to do what they are doing, but feel like they have to; this answer addresses that. Be sure to consider that maybe your student(s) just really want to learn the extra stuff, and don't block them from doing that. Emphasize the power of summary. In a world with the internet, no one needs to memorize every concept, but just understand the basics, or what to google when you need something. I can't tell you how many times I've looked up details on Stack Overflow, and then using that finished my program. Tell them that the important thing is to understand the big ideas, and be able to implement them. If they don't respond to that, try to spend a couple of days teaching completely without the book, and asking your students to not use it. Summarize up front, hand out notes with the points you want, and then let them go on the lab work. Tell them that the notes you have handed out are all they should need, along with occasionally googling something. If they are taking notes beyond that, tell them there's a problem. Hopefully that gives them an idea of what they need to do. Also - a textbook with every sentence highlighted doesn't point out the more important things - it's just annoying to read. Perhaps you can show a quick example - plain page, overhighlighted page, judiciously highlighted page - in a one-on-one with those students. 

is legal because both 's are in different scopes. This scoping issue is why we have the statement above wrapped in extra 's, since the belongs in that scope. loops can omit parts Might seem weird at first glance, but 

Lots of profiling. For all anyone knows, that random gibberish full of typos and conspiracy theories on Reddit is the deepest, most correct theory of physics ever. But, since it's probably not and there's only so much time in the day, your bets are better hedged by focusing on content that appears to be of higher quality. To that end, you should develop a bunch of prejudices over what's likely to be better content, then selectively focus on it. Sure, if you're truly out of stuff to read, then maybe you'll end up going through that weird Reddit post; or, if you've got too much good stuff to read, you might not even be able to make time for Einstein's words. It's all relative. Examples of common prejudices: 

Absorb non-electronic notes If you do have non-electronic note materials; e.g., hand-written notes, images, lab book notes, or handouts from a class; if they're potentially important, try to get them on the computer. Scanning them or snapping a picture with your phone can be better-than-nothing. Optical character recognition (OCR) can help make some hand-written notes into electronic copies. It's not particularly reliable or stress-free just yet, but as long as you have something for future OCR to work on, it remains an increasingly useful tool. 

Well, I'm not an educator, but a student, and I'm in the United States (early highschool, so 14-16 ish). I find several advantages from coding. 

I am learning various topics on my own, and so is another person that I know. We were planning on studying together around four days a week, a half an hour at a time (perhaps to be increased if all goes well) to help motivate each other. However, we're studying entirely different topics. Like, not even machine learning and complexity classes different. More like accounting and computer science different. What are some ways to motivate each other and improve each others learning even though we're not learning the same things and we don't have a ton of interest in each other's topic? I suggested occasionally sharing a "big idea" the other learned, but I was wondering if there were some other things we could do. 

Do they understand any prerequisites necessary? Do they know how to learn? Do they remember what they've learned in the past? Do they understand what they've learned in the past? Do they know how to build up on what they've learned in the past? 

As shown, women chose CS relatively more often until the peaks, then relatively chose other majors after the peaks. Not a bad thing So women like being medical professionals more than programmers - awesome! As long as people are freely choosing what they want to do, then that's exactly what we should be striving for. 

Try to keep the formatting future-proof You want your notes to endure, so avoid systems that might break in a few years as best you can. Sometimes document formats like PDF make sense despite being proprietary, though it's best to avoid relying on them as much as possible. Tips: 

The peaks look more pronounced for women; presumably if we had a graph of just men, we'd see their enrollment had a milder response. I'd speculate that this implies that women cared more about the optimism/pessimism about Computer Science happening at the time than men did. This is, optimism had a stronger pull to get women in, then pessimism also pushed them out harder. This push/pull effect can be seen in the relative CS degree obtainment plot: 

Follow the rabbit hole down as far as you can go without losing sight of the light of day. Understand where you've ended up, and build a solid foundation there. Build back up 'til you're out of the rabbit hole, standing on more solid ground. Rinse and repeat, iteratively falling down further and building back up more. The more you do this, the greater your understanding grows. 

There's basically a single sentence to explain the problem here: shows you, the user, what's going on, but shows the computer what's going on. So how can you illustrate this? First, I'd begin by having students write about and and the difference between the two. At least try to get them to be able to say what the difference is. Next, have students write a simple program without and with that works - maybe something like (I'm going to use python 3): 

Neither. Biology has some physics and chemistry, but it also has some stuff all its own. Ditto for computer science - there's science and there's math. (Plus, if you're being really nitpicky, scientific theories are based on math, but, whatever.) There's also a dash of something different. Yeah, teach mathematics, just like you teach a scientist mathematics, or a biologist physics, and also teach science, just like you teach a biologist chemistry, but also teach how it all comes together - computer science! 

As for when this all should be pointed out - the uses for these concepts are so fundamental, this really is almost day 1 (maybe day 2) of class - install/open the IDE/whatever, learn how to print, then start with variables. This is one of the most important things to learn in a language like python - how to use variables and manipulate them to your advantage.