Not necessarily. The big "but" is that the drivers have to be compiled for ARMv6, which isn't always the case. Less likely to be an issue, but still possible, is the power draw from the adapter - it's possible that if it's too much, the Pi won't supply enough current and therefore it won't work. 

It doesn't support WoL. Considering the device draws so little power, the benefits of shutting it of and waking it with WoL are few and far between. Just leave it on! 

Not really for fully featured dev work, unless you really do love command line based IDEs and editors rather than graphical ones. Simple messing around with text editors / compilation will be fine though. The major problem is the speed of the interface. At present, with X not having GPU acceleration, even relatively simple applications such as the web browser run pretty slowly for me. Fully featured graphical IDEs would be unusable, even if they did run (which I'm unsure about due to memory requirements.) Some of these issues may be mitigated when X gets GPU acceleration. Speed of compilation can also be an issue for some languages such as C++, though is less of an issue with others (C / Java.) To all practical intents and purposes, the stuff you compile on the Pi will only run on the Pi (well technically other ARMv6 platforms.) You technically could cross compile, but I'd argue whether that's really worth it! In short, if you want to play around with a bit of development work with standard editors then it will do, but you'll probably find yourself getting frustrated quite quickly if you move onto anything more serious. 

I'm going to be bold and just say no! While it's true some big capacitors can retain their charge and shock you, there's none nearly big enough on the Pi for this to happen, and I don't believe there's anything on the Pi that runs much above 5V anyway. Definitely not at a voltage that could shock you! 

I'm tempted to use the Pi for controlling an autonomous robot that could be subjected to harsh conditions - mud, water, the lot. (It's theoretical at this point, but the concept remains the same!) Because of this I'd either like to build or buy (relatively cheaply) a completely waterproof case, preferably one rated for submersion up to 1m to be safe. What would be the best way of obtaining such a case, and how could I safely route cables through it whilst still maintaining its waterproofing? 

It's technically possible that if a future "model C" were to be released (I'm just speculating) the hardware requirements may be good enough, alleviating some of the above issues - but from a practical perspective I don't think running Windows is ever going to be hugely feasible. 

The script is called by cron. Use crontab -e to set it up. Add your version of the line below to your crontab file. 

Save the above code to a file (e.g. get_mp3.py). Edit it to change paths to match your needed path. Make the file executable (e.g. chmod +x get_mp3.py). Then you can call it directly from a cron job. To install pysftp do the following: You might have to install ftp first: 

You will probably want to put the sleep command in the execute_on_boot.py script, and add one at the end of the script as well since the terminal window will disappear as soon as the script completes. I tried putting the sleep command after the "-e" and before python, but couldn't figure out how to make it work. If you do figure it out, please post it here. If you need to delay it until the windowing system starts up, then use cron. To add the cron command type: 

I echo @joan's comments that the three sensors should be run from the same script to avoid conflicts. That said, if you are using completely different pins for each sensor then you should not have an issue. If you are using the same pins for trigger, well then that might be your issue. You could hack a solution to the symptom. Write a watchdog type script that checks to see the last time the .csv file was updated. If too long, just reboot. It's ugly, but it will get it to run continuously. Debug the old fashioned way. Use logging.debug. Ugly but effective. Add debug statements at key points in your script. That way, if used in conjunction with #2, you could see exactly where it is hanging. Later it is easy to change the logging level so you only see the failures. Once you identify what line is causing the hang it should be easy to fix. 

Choose standalone for the purposes of this answer. Edit the file /etc/proftpd/proftpd.conf Search for umask parameter. Edit to your liking. Hope that helps. 

Easily feasible based on what you listed above. "My worry is that I need to get the PI on bootup to automatically start the timed sequence" .. One clarification, it won't "boot" then shut off. You would leave it on all the time, and have a script start your lights up at the times you want. Easiest way is to use cron. Look here for an easy explanation of how to set up a cron job. To edit the cron file if you are not using a GUI interface (i.e. you are running headless), go to the command line and type . I'll probably get flamed for this comment, but if you are going to program it and are not a programmer then python is probably your best bet. For the web interface, you can set up any number of web servers on your pi. If you google web server for RaspberryPi you'll be drawn into a religious argument about which is best. They all work fine. I use flask. Another alternative for interacting with your device is to use text messages. Also requires a web server and a service like plivo or twilio. I prefer this for away from home uses for security reasons vs exposing a web page. Hope this helps. Let me know if you have any questions. 

(*) I say a limited lifespan, but as per discussion in the comments this is unlikely to be a problem with a decent SD card in practice unless very heavy usage is going on, in which case an external hard drive may be a better alternative. All in all I'd say that with the proper testing and stable software the Pi is suited to 24/7 operation for certain tasks, as long as those tasks don't make heavy usage of the SD card. I wouldn't however use it as a device that needed to be up 24/7 for some form of critical operation. 

There may be minor differences between different boards - different batch runs could use slightly different components in appearance, though I'd expect them to be functionally identical (at least to within some reasonable margin of error.) It's not unusual at all on these sorts of devices. As to whether they're all unique though, the answer is no - I have two that look identical, and I can imagine in the vast majority of cases ones from the same batch will be practically identical. 

Another possibility I came across is that I didn't get any display unless the HDMI cable was plugged in before the Pi was switched on. Should be a relatively quick one to fault-find, but worth documenting here nonetheless. 

Don't run it on a conductive surface, that's a sure way of damaging the Pi, or at least making it unstable. You'll probably end up shorting random points on the board. Any non conductive surface should be ok - plastic, wood, etc. if you're thinking of building a case should all be fine. In the short term I'm running mine on the anti-static bag it came in which works a treat (I've run whole PCs this way with no issues.) 

The easiest thing to do would be to try another SD card, and then perhaps potentially another Pi if you can get your hands on one. Until that, it's quite difficult to say which one of those issues it likely is. 

The video codecs actually fall into three categories - those supported and enabled by the GPU, those supported by the GPU but not enabled due to licensing restrictions, and those not supported at all. As for details of what goes where, this blog post gives the info: 

Nope, because Windows isn't compiled for ARM (and not being open source, you can't do it yourself.) Yes, Windows 8 is apparently going to have an ARM version, though I seriously doubt it will work for a few main reasons: 

Is this a problem that can be fixed with a later firmware update, or will it likely require the purchase of a new device? 

Oracle have now released (as of Java 7u6) a JDK with JIT that works on the Pi with full AWT / Swing support. It also supports JVMTI (cacao only has partial support.) Press release here. I've verified it works with Greenfoot, and provides a huge speedup compared to the likes of a plain (non-JIT) OpenJDK build. At the time of writing it doesn't support hard floating point, and so won't work with distributions like Raspbian that only use hard float - this is however planned for a future release. UPDATE: As Darren pointed out, a hard float version has now been released for ARM in the form of a JDK8 preview release, you can find it here. UPDATE 2: Hard float is now supported in JDK7. 

I'm guessing that the reason that you cannot ssh into your pi is that you are hanging on boot. The boot process is hanging before it starts SSH. My guess based on the info you provided is that you may have a power issue. To test that theory, take all the usb devices away, including the wifi and the logitech stuff. If the boot works, then add them back one by one. Keep the monitor connected and look for a rainbow icon in the upper right. If you see that, you have a power issue. If you are still hanging on boot then it's possible that your SD card is corrupted, or at the very least there is something in your boot sequence that is causing an issue. This can happen if you have power issues. It looks like you are at least running a wifi usb dongle and a wireless keyboard or mouse, so if you have a poor power supply you could get intermittent failures. Either way, the path of least resistance would be to re-image the SD card. Then boot up the newly imaged SD card with all USB stuff connected + the monitor and look for the rainbow icon in the upper right which tells you there is a power issue. If none of this works then just ignore this answer, I'm out of ideas based just on the info your provided. Hope this helps. 

Directions on how to mount the SD card via usb are here. I'm not recommending this product, but here is what the SD -> USB adapter looks like. You should be able to get one anywhere you can buy an SD card. If you get a cheap SD card, you can always do the reverse and overwrite the card you have pidora on once you have raspbian installed. Just make sure you get a card big enough to hold raspbian + image file. Hope that helps. 

As @joan said, Jessie would be a much easier alternative. However, if you are going to install 3.4.3, the first comment is not to remove the other versions. They can all live together peacefully (I have 3.4.3 installed on mine). And as @goldilocks said, I'm surprised that it let you uninstall 2.7. Some of the issues you had with the install may have been the result of removing it, but I'm not sure. First question on your instructions, are you sure you used ? If not, then that is your install problem. It will make, but not install without root privileges. Setting up 3.4.3 on wheezy is possible (I've done it), but it's a PITA to have it work naturally like you would want it to for students. That's because python is used in other places, and you shouldn't just remove 2.7 nor change the default binary nor default path so it finds python 3.4.3 instead of 2.7. I would suggest using Jessie although you can also have the students use virtualenv - that's another great solution. Hope that helps.