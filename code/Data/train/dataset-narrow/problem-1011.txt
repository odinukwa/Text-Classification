This is true in most cases, but if the expression is a complicated on that would stretch the if statment past 80 chars then it would be best to use the variable. 

The cost of libraries The easiest way to get a performance boost is to drop the libraries. Without jQuery the code looks like. 

Which returns a promise or not depending on the settings. If the time since last idle context is greater than a promise is returned and execution context is set to (allowing events). If the time is less than then is returned and execution continues without interrupt. The following is a general purpose interrupt to allow for pending events to be processed. Ill call it for want of a better name. 

Some benchmarks I am guessing a function like this is written, apart from an exercise, to search for power numbers. Thus execution time is important. String manipulation and type conversion is not something that javascript likes to do, so running the two given answers in a profiler I measured the time to run the following loop. 

The first without the curlys was introduced some time way back and is the dumbest thing to have ever been allowed in any language. We can not remove it from the languages that allow it, too much source already written. But you risk your coding sanity if you feel you do not need { } for single lines. Because if you make a change adding another line and forget the curls, you have a bug that is so hard to find, hours and days will be burnt for no good reason but lazy fingers. Just use the rule, all blocks are delimited with {} even if you don't have to. 

I will assume that the argument (which would be better named ) is always a string as that is what your code implies. Also assuming that undefined names are to be set to (empty string) and that all middle names are to be concatenated to a single string separated with spaces. Rename properties removing the "name" part as that is implied by what the object is holding. You don't need to store the result object, just return it directly. The resulting function 

Thus if you want to change you do so where you define the const and if you need to change the code you can us refactor tools to locate the unique types in your code base. Using data given. Better yet is to avoid the constants all together and use the data in the array items. You can compare strings with is . Javascript uses the strings char codes to evaluate the condition, that means that is as lowercase characters have a higher character code than capitals. So assuming that event types are all lowercase you can sort the events with a standard sort function. Thus the steps would be 

You have it almost perfect in your question. With a little improvement you can reduce memory and CPU load. 

The promise is to do the JOB and report back when done. Promises are not for timeouts to communicate, they do that already via the call back, and a timeout's callback is as good as a promise, with a lot less overhead. I have not looked at the code for BlueBird so I can not determine its quality and thus your code. But I see two promises where there should only be one, so there is room for improvement. Why do you need a promise? You have to consider why you want to have a promise. Creating a promise just so you can start another is adding an extra layer of unneeded complexity. You want a promise so that you can have some code execute when the job is complete, or if there is a chance the job may not complete, you have a promise to have code executed for that situation. Whenever you write any sort of code, always ask yourself, is this step really needed, if you can do without then it should not be there. One promise The following will do what you want with only one promise needing to be created. The timeouts handle the timing, and all you want to know is that you get a promise to know when the job is done. 

All the above (and there are more) require considerable memory resources. They also prefer these resources to be readily available to the GPU so if possible will occupy GPU RAM (shadowed from RAM) Running out of free GPU RAM is a the biggest performance killer for the browser's rendering engines as it begins to swap resources in and out of GPU RAM to complete the render (GPU bus thrashing, or GPU RAM thrashing). Do your best to keep usage as low as possible by always releasing unneeded resources. I would make some changes 

The best way to use a hash to scramble a list is to use the hash as a seed for a pseudo random number generator. The seed ensures that the sequence of random numbers will be the same for the same seed. Unfortunately javascript does not provide a seed value that we can access for it's function so we have to create our own. The most basic pseudo random number generator is seed = (A * seed + B) % M where A,B,M are large integers. Each time the function is called a new seed is generated and return as a random value. The seed is also used as the seed for the next value. Once you have a good sequence of random values you can use them to create a better shuffle. Putting it all together. Thus a rewrite of your code with a random number generator to do the shuffling and an improved string to hash function. 

However there are only 23 valid answers so the best way is via lookup rather than the dangerous and slow recursive solution. 

Indirect recursion. An alternative to direct recursion is indirect recursion. This is done by calling the recuse function using a time event. The code is similar but you will need to provide the result as a function call. This method gives unlimited recursion and frees up all incidental memory by releasing each recursive call's context from the heap before doing the next iteration. Also exiting to context idle makes GC more efficient. Using your jumper function as an example. 

The results of the test indicate that the function shuffle string is only 9% of the ideal situation. But if you look at the numbers you will see that there is a high rate of hash clashes. Finding a better hash function will improve the score, also I used words from 7 -10 characters long, which puts the function at a slight disadvantage. If you are wondering how I got the ideal score, I did it with the following test that simulated the ideal shuffle. 

As Object.prototype As you are after a fundamental function you can chose to add it to the Object prototype thus making it available to all object. Many here will throw their hands up and say "NO WAY", I expect this answer to get more downvotes than up simply because of this. But it is a valid way of using the language, and is better understood than hidden behind gasps of "No" and "Run for the hills the end is now". If you do it the following way you make it easier to use in your code. But there are warnings. Warning when adding to the prototype of basic objects If you do however you must take some precautions. Do not use the function if it already exists as the source may be unknown thus unsafe. Ensure that the function can not be overwritten as the object prototype is global and could be hijacked. Ensure that it works, the last thing you want to do is add a prototype to a basic object that requires some form of vetting before use. It should be bulletproof or it should not end up on the object's prototype. The object prototype form 

Alternative ? Not to sure what you mean by alternative solution. A merge sort is a merge sort and you need to create arrays, via slice, manually, or even creating a buffer and managing virtual arrays will all incur some overhead. Your code. If you want to improve performance then there is plenty of room for an improved alternative to your code. Your recursive function is inherently a poor performer but it outperforms the iterative function because the iterative function does not use a stack to optimize data processing. Your merge function is somewhat sloppy and can be improved, it is the core of the functionality of the sort. You gain the greatest benefit via improvements in the merge function. Even greater improvement if you can side step the need to call it as often. 

Spaghetti When I see this type of code I instantly cringe, not because the code is bad, apart from too much noise the code is good. I cringe because I have done this type of thing a zillion times and have learnt that if you are reliant on a outside uncontrolled data source (namely the section string and row numbering) that source will change, have exceptions, be buggy and generally just be a SOB. You will hear about the need to change your code when the client sees buggy software, not good software bad input and you need to fix it now! Your code is a complicated mix of if statements that will not easily accept change. Change requires time to write, test, and deploy. Complicated code like this is hard to change as the data format will not have considered your careful design. So the changes adds more if statements inside your heavily statement laced code, making the next change even more complicated. So a better design is a modular approch. RegExp If you have never used the RegExp Object before it is well worth learning. There are many sites that provide a live testing interface. Regex 101 is but one. Modular Going through your code I saw that all the various section formats could be tested for via a RegExp, the only parts that needed custom code were the extraction of the seat colour from that section row data. I thus create an array of objects that store the regular expression, and the conversion function. 

Not a performance thing, just a style note. You have left out the after the and the locals declaration . Better yet You could also flatten the bitmap array and use an index rather than a coordinate. You change the y step to a modulo size. This reduces the number of tests and eliminates the need to index into a 2D array. 

Reorder in place But you do lose the object reference that may not be the best option. You can reorder the object properties and still keep the object reference by using to remove properties. A little more complex as you need to delete all the properties you want to move the new property position in-front of 

Are you up to date? There is really not much to the problem and there are a variety of solutions. It is also hard to know what the interviews are looking for. For some it is knowledge of latest language features, for others it may be judged on efficiency. These very simple tests are generally just to see if you can actually write code. You would be amazed at how many people apply for jobs they are not able to do. Assessing the code. Looking at your code as a conservative HR interested in your code writing style, and up to date language knowledge. It is a pass, you can code, you have the job but will have you in supervision for a while..You also need to catch up on the language as you are not using ES6 to the full. General points 

Create a map. Now if you have a regular grid of cells that is defined as an array with a modulo. defines the number of cells across and down. defines the size of each cell. are the cells as an array where a cell's position is related to the array index 

Using for variables that do not change and a ternary operator for the class selection. The most important part of coding is good and consistent style. Having messy code makes it harder to read and near impossible sometimes to spot subtle syntax bugs. Many IDE's can format the code for you, learn to use them they will save you many hours of bug hunting frustration. 

So I submitted that as an answer and it bombed big time being only ahead of 52% of submissions. NOTE Your (OP) code runs 33% faster than the above. I used my own benchmarker to test the different functions and the code I first gave (Solution B) running much faster than the updated solutions. Inconsistencies I have zero trust in the leetCode results, they are completely inconsistent with proven benchmarking results and even for their own results. I would guess there is a bug in there timing solution (JS is notoriously hard to benchmark) so be happy for a pass, and give no credence to the performance as that is based on luck. Best JS solution I could come up with. So the updated best performance as tested on a independent benchmarker is the following snippet run in strict mode. Out performing all the above by an order of magnitude. BenchMarked 0.1 compared to the next best at 2.0 for (Solution B) and OP's 4.6 33 times faster than OP's original.