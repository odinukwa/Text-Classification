An event system will do for a lot of cases, but that is more suited for propagating information that changes or is generated 'rarely' (like the death of the player). For something like entity health and position — which need to be known every frame — an event system isn't well suited. 

I need some advice on how to design the Entity module in my game, how to apply the MVC pattern and generally how the Entity should interact with its controller and its representation. First some details about the game: it's a 2D action-platformer, it's data-driven (or rather, I'd like it to be data-driven — it isn't yet) and the Entities should be scriptable (I'll be using Python). I'm still at the very beginning of the development and I have some general ideas about how the Entity module should work, but I get stuck on the details. Here's roughly what I have up until now: 

I'd like to know if someone has found a way to build a component-based entity system in their game(s) without using IDs. I find that IDs tend to do away with one of the major (possible) advantages of OOP: not having to be aware of the type of a certain object. 

I'm making a racing game with cars in Unity. The car has a boost/nitro powerup. While boosting, I wouldn't want to be deviated when colliding with zombies, but I do want to be deviated when colliding with walls. On the other hand, I don't want to ignore collision with zombies, because I still want to hit them on impact. How should I handle this? Basically, what I want is for the car to not rotate when colliding with certain objects. 

I am trying to create a 2D platformer (Mario-type) game and I am some having some issues with handling collisions properly. I am writing this game in C++, using SDL for input, image loading, font loading, etcetera. I am also using OpenGL via the FreeGLUT library in conjunction with SDL to display graphics. My method of collision detection is AABB (Axis-Aligned Bounding Box), which is really all I need to start with. What I need is an easy way to both detect which side the collision occurred on and handle the collisions properly. So, basically, if the player collides with the top of the platform, reposition him to the top; if there is a collision to the sides, reposition the player back to the side of the object; if there is a collision to the bottom, reposition the player under the platform. I have tried many different ways of doing this, such as trying to find the penetration depth and repositioning the player backwards by the penetration depth. Sadly, nothing I've tried seems to work correctly. Player movement ends up being very glitchy and repositions the player when I don't want it to. Part of the reason is probably because I feel like this is something so simple but I'm over-thinking it. If anyone thinks they can help, please take a look at the code below and help me try to improve on this if you can. I would like to refrain from using a library to handle this (as I want to learn on my own) or the something like the SAT (Separating Axis Theorem) if at all possible. Thank you in advance for your help! 

I assume that when your network data arrives, its processing diverts enough CPU power to slow down your rendering process. Are you enforcing a constant framerate or are you just rendering frames as fast as you can? Assuming you have a constant framerate, you may chose when your network packets are processed. I mean by that that your websocket event should do nothing except adding incoming messages into a waiting list, and somewhere in your game's main loop you process them. It could go like that (very rough algorithm) : 

If the players cannot modify the world, you may be able to just save your seed, and rebuild the world later. If they can modify the world, it will be very tricky to rebuild the world (especially if their modifications depends of the RNG at the moment they take the action). If your world is highly procedural (you generate a lot of data) and modifiable you may try to save both the seed and a "delta" of the differences between the generated world and the "actual" world. One way to do that (not the most efficient but it should work) would be: 

Of course, you may also save a few extra data just to make the player game easier (total time played when the save was performed, thumbnail image of current screen, etc...). (and you probably don't need to save the actual tileset images (unless you change them dynamically but I didn't seen any game doing this yet)). Bottom line: It will not be the most "optimized" way, but it will be the most flexible and easy to maintain way (this means less bug, and the kind of bugs players hate the most is the one that lost their progress after saving/reloading a game). EDIT: The Bonus question: 

My question: Can I configure PhysicsEditor so that it saves shapes in this format automatically? If not, is there some software that allows that kind of configuration? 

I have a very general question: In games, what use does the programming concept of a window have? Or, in other words, why do some game dev libraries offer interfaces through which to create multiple windows? — Why would you need more than one windows in a game? Are multiple windows used as different views/states of the game? (I.e. in-game, main menu, pause menu, etc.) 

Imagine I have a skeleton — that is a set of bodies held together through various constraints and joints — and I want to flip it. Bodies cannot be flipped in Box2D, so how can I fake that? Here's an example: I have a humanoid skeleton, made out of different Box2D bodies: the head, torso, upper arm, lower leg, etc. These Box2D bodies are held together by joints. Some of the joints have angle constraints, like the ones between the upper and lower arm, which do not allow the 'elbow' to twist unnaturally. When I turn my character the other way around, I should flip the skeleton and its joints should be flipped as well. How can I achieve that in Box2D? 

You mentioned you want the game to be flexible. Do you mean that as only adding new features (better lighting, physics, etc), or also flexibility in terms of game-design? If you also want the game-design part of the development to be flexible, component-based entity systems would be pretty useful. Unfortunately, I can't give you a competent answer to your second question. If you choose to implement a CBS, there's two important things you need to ensure: 

It looks pretty close (it's hard to tell without the base image) but you can tweak the parameters. You may see it in action there: $URL$ Some remarks: 

Now, if you want just a couple of hard passages in your games, you can do that by hand but if you want an almost impossible to play game from start to end you may want to automatize the process: You may do that by writing a modified replay engine that will not kill the player when he hit a trap but instead delete the trap from the level 

Extra thought: you may even make the game procedural with a few changes: - Just create all your levels without any trap. Whenever the user starts a level, your game engine would have to: - add a bunch of traps (you may have various difficulty level with more or less traps) - run in the background an AI run of the level which delete the traps in the way - display the level and let the player trying to pass the level Or you could script the game entirely, like in "I wanna be the guy" but then it's closer from "movie making" than "video game design". [*] this is for level design only but you may consider leaving it in the final game since players which successfully finish the level will be very happy to brag about it by sharing the video :o) 

This approach also allows you to prioritize your messages; if instead of having only one waiting messages list you have many, you can dispatch message depending of their priority. That will allow you to process most important messages first, even if some less-important message has been received before them (i.e. if you have a lot of mobs attacking your player, you may delay for a second or two the chat related messages, or information stuffs like "xyzz has join the game" or "dfghf is now level 41"). If you don't enforce a constant framerate... well, I really think you should; the framerate perception will look better at a constant reasonable value (i.e. 30 fps) than if it varies depending of where you are or how many players are around you. Another pointer to optimize may be to reduce the number of messages sent to clients. i.e. for non-critical events (like chat or informative messages), instead of sending a message every time someone says something you may consider limiting those to 1 message/second/player. The idea is when you have a message of such to send, you just wait for one second before sending it, and if another message of the same kind arrives during this second, you just add its contain to the first message payload. Same thing for server issued world updates: Instead of sending one message with new coordinates for each player/actor, you may consider packing many of them (all if possible) in the same message. That shouldn't have any perceptible effect if you have a fixed framerate; you just have to send your world update message at the same rate (i.e. every 33ms if you have a 30 fps framerate on the client). If possible, and assuming you use TCP (so no packet should be lost) you may keep on the server the last "world state" send for each client. That will allow you to only send what have changed since the last update. This will also reduce network bandwidth you use which is always a good thing. Bottom line: It's all about prioritization. You just cannot do everything at once, so you have to compromise and to process first what you think is the more important. 

What good free and widely used tools are there for editing 2D skeletal animations? Preferably, one that allows me to write custom animation exporters. One pretty good indie tool that I know of Demina, but it's not ideal. It doesn't allow you to export the data as you want (although, it is open source, so you can change that) and I find it clunky in how you edit individual joints. What other tools would you recommend? 

How do you usually solve collisions between entities and the ground? Sending collision events hardly seems appropriate since almost everything touches the ground at almost all points in time. Calling collision handling functions doesn't sound any better. How is this normally achieved? Is handling of slopes significantly harder? 

Definitely not. is just a tool and you should use it when it fits your desired result. If your widgets are supposed to be laid out in a tabular way, then use . Otherwise, it's perfectly okay to position your widgets manually if that's what you need. Two alternatives to 

When positioning manually One piece advice, though, if you decide to position your widgets manually: don't use absolute pixel coordinates. If you your screen is 400px wide and you want a widget's X coordinate to be 200px, set it to , instead. This will allow your widgets to be position correctly, even if the screen size changes and it takes no extra effort on your part. 

If you have only a basic knowledge of C++, I don't think that's going to be enough to (easily) develop something like a platformer. Python is an easy to learn language so it's not a bad choice at all. If you pick C++ I recommend you use SFML for graphics and sound, and either Box2D or Chipmunk for physics, if you want such a thing. If you do pick Python have a look at Pygame (graphics) and Pymunk (physics). But developing a platformer isn't exactly easy; you might want to start with something easier, like an adventure game (where you only click around the screen and you don't have to worry about complex character interactions). 

I don't think displaying an outline of your character will be CPU intensive (unless you have thousands of players to display). You just need to have 2 sets of images for your characters: 1 with only the outline (O sprite) and one with the rest of the character (C sprite). If you're having high tiles, you probably already draw them in the correct order (using z-order, the tiles in the background first, and the ones in the foreground last). You just have to draw the C sprite in the correct z-order (which means it may be hidden by a high tile in front of it), and the O sprite after you have drawn all the tiles (which means it will always be visible). You mention doing this in PHP; I take it that you're working in a turn based game, and you're generating an image on the server every time something changes. While it's not critical, you may consider rendering the scene in Javascript on the client side; that will greatly reduce the bandwidth used by your game (each tile is only sent once) and displaying an isometric world in Javascript is not that difficult. 

TMX Files are basically a XML file describing your map/level; You usually read it to initialize your world and forget about it. Now, if the lib you use to manipulate/display them (or your own code if you did it by hand) is able to regenerate the TMX from your world after the player interactions modified it I'd say the way to go is to just serialize the new TMX, either in a file or in a DB's TEXT field. It can seem a little overkill, but it has a few advantages: 

To explain what some of this code means: The blocks variable is basically an integer that is storing the amount of blocks, or platforms. I am checking all of the blocks using a for loop, and the number that the loop is currently on is represented by integer i. The coordinate system might seem a little weird, so that's worth explaining. coords[0] represents the x position (left) of the object (where it starts on the x axis). coords[1] represents the y position (top) of the object (where it starts on the y axis). coords[2] represents the width of the object plus coords[0] (right). coords[3] represents the height of the object plus coords[1] (bottom). de2dCheckCollision performs an AABB collision detection. Up is negative y and down is positive y, as it is in most games. Hopefully I have provided enough information for someone to help me successfully. If there is something I left out that might be crucial, let me know and I'll provide the necessary information. Finally, for anyone who can help, providing code would be very helpful and much appreciated. Thank you again for your help! Edit: I have updated my code with a new algorithm that checks where the ball was previously before collision. Corner cases work on that single platform correctly now, but when I have a wall of objects, I keep can really slide against it, but if I move towards the wall while sliding, I pass through it and an essentially now standing on top of a block inside the wall. Also, there is a jittering effect that happens when I am on the ground, where the ball is constantly going up and down. 

A simple web search bring this shader up $URL$ which looks like what you're looking for. I'm not an expert on WebGL, but according to this page, it looks like it uses the regular GLSL language (this is the C-Like language used by graphic cards to program shaders). This means you will probably have little to no changes to do to make it work. You may however try to start with a more basic shader to understand how it works. This blog page lists all the steps to implement a shader in WebGL. That seems a good place to start. Another good place to find wonderful shader examples is $URL$ 

Here is a way to do that on a platformer; this is probably possible on other kind of games, but I won't develop here. 

Depending of the specific details of your game, you can probably optimize this further. Just a bit of warning: If your procedural process is using floating numbers AND you want the saved games to be useable on another computer than the one which saved it, it will likely not work the way you're expecting it unless you take extra precautions (see this article about the issue if you plan to do it: $URL$ 

Well, developing a very crude level editor from scratch would take you at least a couple of weeks, and the result would be a lot less productive than using Tiled. If you really want to get rid of TMX files (that's something I do most of the time), you can write a script which convert a TMX file into whatever format you'll be using (in your case, the script could output a list of SQL's INSERT statements that will add the new level to your DB). This way, you can have the better of the two worlds (Great tilemap editor to design your levels (Tiled) and the data structure you want for your game). If you're using some kind of Makefile, you can even treat your TMX files as source files (this way, whenever you want to change a level, you just have to save the file and rebuild your game (or at least the DB in your case; you may use a specific build target for the DB so the game itself won't have to be recompiled everytime you edit a level)).