You can also optimize this by drawing any circles that doesnt have any other nearby (within double max radius) and removing them from the list before begining. Or ignore all big distances right away. You could also use priority queue instead of calculating distance/distance array - sort once and then only pop. obviously, this will not work for extreme numbers of circles, because it requires n^2 space and the whole algorithm is n^3. To illustrate the algorithm first steps (for ilustration purposes, the longes edges are not drawn at all): 

however if the mask is drawn too big, its edges appear blurry, because smoothstep afflicts too many fragments. This could be solved by multiplying the mask by some value, however it would stop smoothing if is the mask was drawn too small. For illustration, on left is the mask(100px), in the middle is its zoomed edge and on right there is zoomed edge of mask if drawn big(600px). How to smooth the edge to appear correct regardless of the size? (=zoomed edges should always look the same, like the middle image) 

I have a texture intended as a mask. The texture type is (32 bit float) and the data inside is a signed distance field (= value of each texel is distance to nearest mask edge). For test purposes, the mask is just a circle part and is directly drawn in greyscale. The fragment shader handling this texture has following code: 

EDIT: if you insist on the path you drawn, just compare the two extreme possibilities in which way path can leave a straight part (=point at one or the other end of the edge), and choose whatever produces shorter line segment (pythagoras theorem). 

edit: adding C++ code example what I had in mind. I would maintain two integers forward and backward depth, first one being used to detect maximal depth found and as tile index in path, while the second is used to to detect backtracking from furthest path: 

I would like to render game UI, and for that I need rectangles. However, since a button could be textured just as well as solid color or (multistop)gradient a problem arises. I would also like all types of rectangles(buttons) somehow at least partially uniform at handling. I have been puzzled by this issue for quite a time and idea came across my mind - what if I stored colors to a 1D texture array and treat all rectangles as textured. Could you give me some example how to do this? Or event better a reason not-to solve it this way and point to better solution? 

Lets start with the easiest, the segment from p0 to p1. First of all you need the perpendicular direction to this segment. To do this get the "normal" direction first simply subtract one point from the other, then use the well-known trick to get perpendicular vector (swap coords and negate one): 

The most efficient way is probably not calculating anything. You can "precalculate" collision simply by drawing the wall "a bit smaller". Just subtract half of player r from the wall, the wall is still "physically" on whole tile but its image just don't reach its edges. Floor the float value of your player position, query grid matrix...and done! 

Lets put together some greedy algorithm. If we had two circles(circle centers), the solution is trivial, right? Just calculate the distance(pythagoras) between them and divide it by two. But what if we had more? As you might agree, at least good solution, if not optimal, is always draw the smallest possible circles such as its radius is maximal possible. 

There is hardly any practical relation between soft and hard realtimes in industry(what the wiki page is about) and gaming. It is usually hardware or OS designed to meet deadlines where it is absolutely a must e.g. navigation systems in airplanes. Unless you ship (own) RT OS with your game you don't have to worry about anything like this simply because the OS you are running the game on was not designed to do such thing. Also there is no slow motion in hard realtimes it is not designed to ever not meet deadline(actually, when designing one you have to prove first there is no possibility at all of not-meeting deadline) - not meeting deadline in hard RT would usually means death, or billion dollar assembly line blowing up. For soft RT it is more relaxed - it can be simplified as "if you did not managed to finish computing physics, I don't care about (this frame's) physics anymore". You should probably understand the first sentence by now. 

The problem is objects movement in digital world is discrete. In real world, it seems natural if a bar extends, it does is over time - computers cannot "move" objects, so they simulate this behaviour by setting their position by small steps dS. However, if the movement of an object is too fast, it can produce weird resulst like shown on video - bars actually trapped balls below if extended too quickly. There are generally three solutions: 

ofcourse, it will probably need to be more complicated than simple OR or AND(to simulate families, which should be probably aligned blocks of persons), but you will get a level of binary tree, PLUS you should be also able to compute next and previous levels if needed as you can tree it as array-stored binary tree(with computable index shift). Edit: Well, I do connect family here. That thing is a tree! You can query their parents - their "parents" are at virtual array index , siblings are at or (depending one whether it is left or right sibling), as well as you know children of current generation will be at and . By virtual indices I mean indices for not-generated tree parts, and the is actually at virtual index of . I am sure you wont have any problems to exapand this binary tree example to 2-3 or n-ary tree. You can get the requested previous generation persons by querying siblings and determining whether their (grand) parents still live. As if there is a person, their parents must have existed at some point. 

As for hero width, if you look closely - where is the path closest to edge? In the connection of last "tile" and the one before. Check path distance to the edge in that point(you will have to do math now, switch wont suffice), if it is less then hero width/2, add new point to the path at hero width/2 distance from edge. 

or in other words: 1) move onto inner-most shape 2) move on vertex with index +1 on +1 bigger shape. This has the upside you can make gradually bigger absolute size difference if you put relative scaling (e.g. ) in the inner loop. Translating the path to the desired location is now trivial. 

Alternatively, if you have only few and known in advance possible rotations, you could use lookup table coupled with enum and modulus: 

Also make sure the speed is incorrect: it can perceived incorrect while in-fact correct - for example physical dimension or the object is moving in dimension that is shorter that . 

This is very nice example of problem suited for A* algorithm. I will not go into details how to implement A* here as it has been done better before and this very easy to find, however this is how I would apply A* for your problem: As you can see, there is only a limited number of states that you can "move" to using single swap (14 for this case if I am not mistaken), you can think of them as a nodes in the (pathfinding)graph searched by A*. Naturally, you can only move to adjacent nodes and the distance from start node is the number of swaps made to reach "current" node. What you also need for A* is function estimating the distance to goal state. Choosing good one is the key to speed of the algorithm, however pretty much any decent one will lead to the solution. I suggest using the sum of distances to goal postion, e.g. "1" is 1 swap away from its place, similarly "3" is two swaps away, all summing up to for the state in your example.