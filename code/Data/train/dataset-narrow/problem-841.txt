Note that each item has a name and a price/value. In case of armor, it also has an armor value. Armor items are a special, more specific type of item. We could sort them into classes like this: 

Phone numbers have a normal form, which is NNN-NNNN, with N being a digit. This makes phone numbers contain 7 digits worth of information. That fits in an . → Less memory usage, better cache usage. You don't need to retain the original form. → We can use destructive methods. Your incoming alphabet is limited: uppercase letters, decimal digits, and the hyphen. → and/or table parsing are viable. You need to output only the duplicates. → We don't need to store everything, but we might end up having to. You need to output the duplicates in lexicographical order. → We don't need to keep everything sorted; only the duplicates. 

Find a public static method matching a specific signature, e.g. a factory method. , , and so on, are good candidates. Document what you accept, and in what order you search. Find all public constructors, and try to invoke them with 'default' values. What constitutes default values depends a bit on context. We may need to ask our users to provide values for us. Again, document what is supported, and how you will try instantiating. 

That's for the abstract part; let's get to concrete suggestions. Pull singletons up to the factory level The concern of the DAO implementations is data storage and retrieval. The concern of the factory is how to supply instances. Lifting the singletons from the individual implementations leaves the factory in control of instantiation and life cycle. Here's a straightforward example of such an approach: 

As you noticed, searching for your entries is adding to your time complexity, because you have to run down your queue. Priority queues are very good at polling the top element, but not optimized for searching for specific entries. You can optimize for searching by using a for counting frequency, and then use a for maintaining order (1). Adding an entry will look like this: 

This is more of a code maintenance problem: each time we add a medicine, treatment, or ailment, we also need to modify the Patient class. That's because they are tightly coupled in behavior—they depend on each other. For a small enough project, like this one, this is fine. (Larger projects, where there may be many, many more combinations of treatments, medicines, and ailments, will benefit from a rule-based approach, but that feels out of scope here.) 

There are solutions that take fewer steps. One could attempt to improve the current solution by shrinking the possible ranges. Given: \$c^2 = a^2 + b^2 ; sum = a + b + c\$ Neither a nor b can be larger than c. This also means that neither a nor b can be larger than half the sum. For c: it can't be smaller than any other term, and it must be at least one-third of the sum. 

does not give any ordering guarantees. This gives JVM implementations the greatest freedom and opportunity for optimisation and throughput, but makes access order unpredictible. If you don't want to use any of the prebuilt (and tuned and optimised and tested) solutions in , you'll have to manage a FIFO queue of your own. (1) (1) Caution: Concurrency is hard, and not like long division hard; more like managing a fastfood restaurant with a troupe of gremlins hard. I mean, just peek at the source code of classes in j.u.c. I'm usually all for re-inventing the wheel as an exercise, but this is some serious chow to chew. vs is a tricky thing to use and almost always leaves room for a potential deadlock. It's tempting to use it instead of the safer because, come on, only one thread is going to get access anyway, but it's not safe. The trouble is that all waiting threads are not equal: there is only one that should be woken, and that's the one at the head of the queue. Every other thread needs to pass on the notification, but the woken thread is chosen at random, with no guarantee that eventually the head of the queue will be chosen. So thread A could be waiting forever while C, D, and E poke each other at random. Note: would be safe if you did not have a FIFO requirement! Efficiency This is really hard to judge, partly because different JVMs and versions have different implementations, partly because is missing. The current code doesn't have any obvious or glaring inefficiencies, least of all that are likely to be consistent across implementations. Miscellaneous Your class doesn't use generics for its elements. It's not important for the concurrency, but just sayin'. 

(1) 20 000 lines, 100 chars per line, 8 chars per pattern. To limit disk churning, I kept the file open in Notepad++, which should help keep the data in OS cache. 

(I've elided the constructors for brevity.) The same can be done with enemies and the player. They have current health, armor value, damage potential, and so on: 

More general comments Self-typing through generics only works for subclasses one level in. I've tried serious wizardry with generics, and never found a good, reliable way to assure the compiler it would get an instance of the current type without having to override those methods manually. instead of ? These methods have different names, but they appear to do the same thing: append something. Is there a reason you chose different names for them? is too liberal in what it accepts. It feels a bit odd that I could write: 

Euclid's formula doesn't generate all triples, but it does generate at least all primitive triples. An important property of Pythagorean triples is that, if \$(a,b,c)\$ is a triple, then so is \$(k*a, k*b, k*c)\$, for any integer k. Such a k is necessarily a divisor of the sum of a, b, c. 

Quarantine Any time you use a map to link information with an object, consider adding the field directly to the object. If it doesn't belong in the object, or you don't have the ability to make changes, consider a wrapper object, such as a new class . The statics need to go. Passing the Quarantine object to your Treatments will solve this. This try-catch seems to be a fail-safe because you're not confident your code is correct: 

While personally I cringe at the sight of using a decimal type to represent length, it seems the least-effort approach here. The alternative is checking in whether length has overflown, and then set a flag to raise ArithmeticExceptions as required by the specs. 

Method #1 feels like the better approach, because it doesn't require your view to expose its buttons, but the four-times ActionListener method seems odd. Both methods have some trouble with magic numbers. Introduce an enum for directions. It may feel like overkill at the moment, but it'll take care of your direction-to-action mapping. It will also help shape some of your options. Then consider supplying instead of . This will also make it easier to enable/disable the movement buttons in case something blocks your way (like going off-field), without your view having to expose its buttons. When you combine these two, you get something like the following: 

is rarely a good idea. Consider reusing existing exceptions (IllegalStateException?) or defining exceptions specific to your domain (NoPathToTargetException?). Otherwise, callers of your methods will be forced to handle the top-level throwable type, which invariably leads to the next paragraph... An empty usually causes more problems than it solves, especially when catching the base type. If this is a debugging construct, consider printing the stack trace to the error stream. You'd be surprised how many can't-happens logging catches. ;) Use braces even for single-statement blocks. One day, you'll be sorry you didn't; I know I was. I can see exceptions being made for condensed one-liners, but if you put the following statement on a new line anyway, there's no reason not to add the braces. is only used immediately following assignment, so you can pull its declaration down to the block where you need it. You may want to factor it out and make a method. (Your comment stresses that calling is important, but I don't see why.) Since you check for low power in your loop anyway, you may want to throw the exception (BatteryLowException?) there and then. Another option is to make a specific return type: 

1 (Note that I opt for interfaces here; I tend to go with interfaces when I'm designing/freewheeling, and later on decide which ones will become classes. seems to be duct tape holding related values together, so it's a good candidate for being a class.) Now, if we later decide to add functionality--say, we add a flat addition bonus--we won't need to rewrite our Hero interface and add three or more methods. But if we want to add another attribute? We'd still need to change the Hero interface. Hrmph. This is where enums will come in handy: 

But now has multiple responsibilities. It parses input, determines a reply, and sends that reply. We can filter some things out: 

No fuss about encodings, file paths, IOExceptions, invalid patterns... Just the bare needs to function. Any other constructors or static factory methods you desire are then for convenience, and should delegate to this one. Specifics breaks with the other methods in that it tries to fix an erroneous input parameter. This leads to the oddness of succeeding but failing. Consistency is king in library usage: should fail, or should succeed.[3] [!] changes the contents of the incoming array. You don't really need to sort this array, anyway: I'd consider it a feature if the columns returned are in the same order that I requested them. is not a very descriptive name. ;-) Consider names such as or . 

To verify this, I tried my hand on some quick-and-dirty number parsing (worthy of ThereIFixedIt.com), and wow, the speed difference: 

If inventing/implementing your own protocol seems a bit much (and it usually is), you could consider using an HTTP library or a general I/O framework like Apache MINA. But we wouldn't do the tag "reinventing the wheel" justice if we didn't go all the way, eh? 

Since you're working with the product of single digits, you have a very bounded input for factorisation (see bottom). It's cheap to keep track of the prime factor powers when a digit changes. You can take it a step further: you don't even need to store the actual prime powers, just whether they are odd or even. 4 bits will do: a bit each for 2, 3, 5, and 7, the only single-digit primes. Here is an outline of how the code would work: 

(I think this should also work for IPv6.) Other remarks Consider using try-with-resources (see example above) for your database connections and file streams; it really cleans up I/O code. You don't seem to specify the character encodings of your input and output. Considering the domain, I doubt you'll run into serious trouble, but it may be useful to decide on an encoding like, say, UTF-8. I doubt String.intern() will help you much. Interning helps to reduce the number of copies in memory, true, but since you use them as hash keys, you'll discard duplicates anyway.