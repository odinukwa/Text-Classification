While is constant complexity for random access iterators, it is calculated in linear time for bidirectional iterators. Rather than checking the full range, check the non-existence of the first value. 

C++ has special rules regarding evaluation order. In this case, the of the argument list is not a sequence point because the argument list itself is not an expression. Since the arguments are indeterminately sequenced, modifying the variable and trying to access the variable is undefined behavior. 

For input parameters, pass types that cheap to copy by value and everything else by reference to . We don't know which the user plans to use, could be an , could be . Does the callee need to own the inserted node? The standard library returns a pair that tells the caller if it already existed and an iterator pointing to where it exists or was inserted. If you want to hand out a strong reference, consider using s aliasing constructor (see #8) to return the instead of the entire . 

For functions prefixed with , are these meant to be apart of the public interface? If not, hide them through a named namespace (, ) to indicate they shouldn't be called. 

If you wish for you algorithm to make a copy and you are not using the original string, pass by value. Your function also is not a plain reverse, so give it an appropriate name. Prefer C++-style declarations () References/pointers relate more to the type than the expressions/grammar. Ensure all dependencies are included 

Naming is important. When users of your library encounter your code, can they tell what it does? There are many tree types. doesn't provide the type of tree it is unless its qualified by its namespace. That could be declared away by others. Instead, doesn't it make more sense to name the class ? Make working with your library code easier for readers and writers. 

is being deprecated in C++17 as it does not provide code clarity and does not operate with internal name lookup. You should just provide the 5 typedefs of yourself. 

A linear search for the first positive value returns an index of 3. Converting back to a one-based index results in \$solution(A) = 3 + 1 = 4\$ 

Now you can write the short and simple functions that are easy to read, test, and maintain. Get familiar with the standard algorithms found in and . Do you really need to sort the entire data set? Would partial sorting () suffice? For even-sized data sets, you could pair up with to find the two values. As Vnp mentioned, is a candidate for summing up a range. 

Insertions at the back of the list are expensive. Consider a constant time approach by bookkeeping and inserting directly at the tail. 

We gain reusable functions, avoid magic numbers (), and can -qualify our immutable objects. Prefer to treat warnings as errors For these small learning programs and new code bases, turn up your warning level and treat warnings as errors. Older code bases should continue to use the same rules that are already being used. You have mismatched sign comparisons for each comparison. Use the C++ Style Declarator Layout 

The use of an external buffer to store modal candidates is a violation of your first requirement. Consider a sequence such that the mode can be found at the end of the sequence and every other element in the sequence is distinct not a mode. $$S = [1, 1, 2, 2, 3, 3, ..., n - 1, n - 1, n , n, n] $$ What happens with the capacity of the buffer as we approach \$n\$? edit - This could potentially be a lot of appending and reallocating. If you actually pass that sequence into your function, you also discover a nice bug from exiting early. - edit 

By only partitioning the elements that match your comparator, your partitioning algorithm is likely to exhibit worse-case performance as more elements are repeated in a sequence. Know your 's. See . 

Naming can be hard, but it is important to get right. If I were to call , I would expect the result length to be at-most the length of the input string. "" doesn't really describe what is happening within the function. So what exactly is your function doing? From your description: 

What is a ? My definition of a is different than your implementation of a . A tracks the amount of time that has elapsed while the stopwatch is in an active state. The basic functionality is broken down into the following parts: 

Motivation I have found on occasion that I have needed to safely increment/decrement iterators by ensuring they are within some bounded range. After reading through some implementations (SO, Boost Summer code) and a proposal, I found that most of these "safe" functions did not handle the case where a negative difference type was used. From the C++ standard (C++14 Draft N4140 24.4.4): 

Before coding, did you go over the requirements with the interviewer? Are strings limited to just words? What about sentences/phrases? Any adjustments for capital letters, punctuation, word dividers? Consider that the phrases *A man, a plan, a canal, Panama!", "Was it a car or a cat I saw?", or "No 'x' in Nixon" are considered palindromic phrases. Also, why do you ignore strings of length 1 and 2? Document the reasoning. 

Make interfaces easy to use correctly and hard to use incorrectly. The function name is confusing as it would lead me to believe that if I called , I would expect a returned value of . From your problem statement: 

If you are fine with this behaviour, document it. If you want to ensure you always use the behavior of a specific locale by default, consider imbuing before reading. 

Why not both? Having a function that takes a predicate would be useful. takes a predicate and is just a negated version of their . See boost/algorithm/cxx11/copy_if.hpp. 

For potentially expensive to copy parameters like , prefer to pass them by reference (to if immutable). Be consistent with your spacing, i.e. vs . 

RAII containers are designed to call the destructor at the end of scope. In this use-case, that destruction call cascades down the list adding each call to the stack. If the list is deep enough, you will overflow the stack and the result is a segmentation fault. You'll need a destructor that iteratively destructs the list, which will also require that you satisfy the rule of five. 

Keep code simple. C++14 adds a fringe case in which parentheses around a return value is evaluated as an expression. In this case, the expression evaluates just fine. In the world of -deduction, things could explode. 

Does it meet your needs? At the very least, I would expect C++11 and beyond containers to support move operations (move construct, move assign, data emplacement, swap by move), comparisons, and perhaps even allocators. I would start by looking at . 

Consider the overlapping occurrence case of searching for the substring . Using your count operator, a count of \$2\$ is returned. If I were to use this operator to erase all occurrences, only one occurrence would be erased.