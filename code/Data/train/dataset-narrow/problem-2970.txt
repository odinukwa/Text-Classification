Picking out the current micro:bit ideas on twitter: Robot Football NeoPixel Clock An optical indicator for a S/W project (I think, was a bit unclear) Arcade game on a 5x5 display If I'm interviewing, I can ask about one of these projects, what was hard, what was interesting, what comes next. That tells me something about a candidate that no 20 minute coding test will. All of these projects would take any of us here some time to complete too. If I gave you an arduino and a kit of hardware, I'd say 'do the blink LED exercise first', to make sure you know how things behave when they work. Then a few more simple follow on activities. Jumping straight in at the deep end is too big a step - we set up commercial products just the same too, with easy step-by-step instructions (plus videos). People still come back with questions - our first question is always 'does binky work?' 

Describing the low level architecture at the level of what the machine is able to do can greatly help some students to identify with the task of coding. If you do this, I think you also need to consider how to describe the link between this internal machine architecture, and the external (analogue) world. I don't think it's necessary to go into great detail, just describe the basic load/store/add as a very simple process which is powerful because it can be performed extremely rapidly. I'm dubious about the value of going down to the level of logic gates or transistors. These are not the elements that processors are designed with (not for maybe 20 years), and seem like a little bit too much detail to present until you are at a point where manipulating and minimising logical equations makes sense. A simple assembly code expresses the right sort of low level unit, and there are plenty of examples of mechanical programmable machines that you can draw on (via you-tube) to demonstrate that the magic is realisable. 

The micro:bit foundation present some research findings which look quite encouraging when it comes to using physical computing as an introduction to Computer Science here: 

The problem appears to be that algebraic substitution comes naturally to your students, since they have been introduced to it much earlier in their education - and I think the idea of a 'number in a box' is much simpler than the idea of a string in a computing context. Strings are far more complex concepts than a number - there is the character set mapping, a list of unicode (since they expect accented characters) and a delimiter. For me, the absence of any detail of the implementation was a challenge when it came to learning about string variables - so I can easily imagine that string variables are the ones which stand out as being confusing. It seems that you need to refresh the idea of variables being just a label for something, and also that the thing which is labelled is maybe just a representation, rather than an accurate copy. I can't give any good culturally relevant examples, but maybe one way of relating to the quotation marks is to talk about picture frames. Obviously the variable names can be written on the back of the pictures... With a number it's usually quite clear where the boundary of a picture is. If you had a photo of a window and stuck it on the wall, it might seem to be an actual window - but the picture frame would be a clear recognisable sign that what is inside is a 'representation'. Pictures with addresses, street maps, phone numbers could also be used to play with some ideas about indirection and references. I'd re-iterate that it seems to me that numeric variables are probably working for your students by chance, and you can maybe explain the basics what they have inferred in this aspect, and expand on it to include the other data types you need to cover. 

It's necessary to know about octal because some compilers and tools will interpret multi-digit numbers with leading zeros differently to how many people will read them. Tracking down this sort of bug is very hard (as in spoken language where two people interpret words differently - maybe a useful analogue to work into a conversation). I found two other relevant questions on SE: $URL$ $URL$ The first identifies quite a lot of genuine legacy applications, which seem to be driven in the main by resource constraints which are not likely to be so relevant any more. The second question doesn't add anything more that I can see. About the only time where Octal could be useful is in packing more separate items into a 32 bit register, and I'm struggling to decide if this is just obvious or actually a useful concept. It's closely related to ideas like video encoding, where RGB can be packed as 5,5,6 bits - but I'm not aware of this leading to the use of octal in the representations. Video is of course one of the areas today where resource constraints are very real (8.3 Mp per frame@60 Hz). 

An important and fairly contained topic is to introduce the impact of technology changing. As software designers, we will make assumptions which have a critical impact on security. Bunnie interposed a break-out connector on his Xbox ROM, and now we have OpenCV to read ROMs directly. Assumptions about how much crypto $100 of compute will buy you change (sometimes in big steps - 10 years ago, you couldn't buy fast cycles without buying the hardware yourself). BGA reflow used to be an expert operation (with X-ray analysis), now people go it in their toaster... These changes over time mean that the attack surface will also tend to expand - complex indirect hacks can become trivial. The impact of this is that any secuity system which can't be updated will become insecure - fairly certainly. 

I think the ancient history is less relevant to a general curriculum, the context that many of us learnt to program with is not likely to help students understand the environment they will be working in in the future. Similarly, Mores law does not predict the future (and is expected to only continue with step changes in tech beyond 5nm). What probably is relevant is to look back 10 years, and see how phones have changed, how battery tech has improved, how everyone carries broadband with them, sat-phones cover the whole planet, and many houses have well over 20 Mb Internet. So not only are computers near enough free (outside of supercomputer) but they are far better connected. This is fairly new, and things are still changing, but you ought to be able to demonstrate some comparisons which are accessible and help students imagine how things might change. Domestic drones are my current best example of tech which has only recently been accessible at a sensible price.