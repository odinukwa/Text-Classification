You have a bit of code duplication that could be extracted and consolidated. But first with some error fixes (at least the code did not compile on my TASM). Compilation issues 

Buffered input I don't know why you chose buffered input as your method of entering the hint, but in case of this command the data has a specific format. 

Other things that might be good to fix You have the same loop for scanning the characters. Why not enclose it as another proc and just use in those two places? You can make assumption that for example will point to the buffer that has to be filled. Also in this scanning you could handle for example backspace character and delete the characters. 

You have a bit of code duplication that could and should be removed to avoid mistakes. FASM supports macros that you can use to remove duplicated parts. One can define a macro: 

I think it reads a lot easier this way, where each line contains a test and the output value if the test is passed. If the test fails, we move onto the next line. And at the end, the last line contains the value if all tests have failed. I also like this layout because it looks a lot like how you would nest Perl's ternary operator: 

I hope you will agree that it is easier to read when the code is broken out this way, with each statement using a very few functions, and where the names of the variables holding intermediate results help understand the process. This should already be faster than your version, thanks to the replacement of . If speed is a real concern, you could make significant improvement by replacing with the following regular expression trick: 

the use of rather than looping over an unused argument the use of 's and arguments rather than the trick you used making an optional argument 

The actual string starts on index 2 and before that you have max string length, and bytes read. Also there's no at the end. You have to put it there. 

which is just . So let's call it like that and make sure a requirement that when calling it we have dx 

Compare Your compare method is kinda strange. You do not iterate at all and you don't use any opcodes that would do that for you. It works only when you have one-char secret. Not so cool :) I would write it like this 

What we do here is just divide the number in by 10 and print the values stored in (result - only if >0) and the - reminder. Printing the hints On fourth attempt you are putting the character to be printed in . It should be in . You don't also have to use different registers so just: 

Rather than carry the weird assumptions about your data column names into the second part of your code, I took care of making uniform names in the data reading/cleaning section. For that, I converted all names to lowercase using . I added a to check that each sheet contains the four columns you need. Always try to gather in your head the assumptions that your code is relying on, then add code to check these assumptions and die if they are not met. Everywhere I needed a column from the data, I referred to it using its name (e.g. ) rather than its position (e.g. ). Doing so will always make your code more readable and more robust to data changes. I replaced with a base solution. It helps remove a dependency to a 3rd party package but if you prefer to keep dplyr, it's ok too. I replaced the calls with simpler (easier to read) calls. I note that your calls were probably returning the expected results but you are doing something weird. To use , your regex pattern should really use a set of parenthesis to catch something that will be stored inside . It would have made more sense to not use regex captures and just use the empty string as the replacement instead of . 

You compute twice - this is a waste. You return instead of the improved guess, i.e., you return a worse approximation than you could. 

You do 17 iterations when only iterations are necessary. Recalculations Now compile to turn recursion into a loop and see: 

The seems to be no reason to use lists as opposed to arrays here. I would use multidimensional arrays instead: 

Stack overflow is tail-recursive, so if you compile it, it should become a simple loop and there should be no stack issues. However, do not rush with it yet. Algorithm Number of iterations Let us use to see the problems: 

Trivial Use instead of . Avoid very long lines (Emacs will indent for you). Do not use when a single without would do. Memory Use instead of when possible to avoid unnecessary consing (in your case, allocates a fresh list, so its result can be passed to ). Catastrophic Whenever you use , you are using the wrong algorithm. Optimal search is linearithmic: . Insert search is quadratic: . Your implementation is : 

as in the will be the number of characters not the ascii representation of that number. If we could restrict ourselves to maximum 9 characters that would be easy. Just add 48(dec) to the and you get the value. Since your secret is limited to 21 characters we could go with a simple method for printing. 

You could also add a new line to those strings so that, they are a bit separated from each other when printing like this: 

and similarly in the second place. Also some checks for input length might be good to do. You should also comment more your code. I strongly believe the code should be self documented but not on such low level as asm :) So comment more. GIST 

A bit of explanation. This macro will do all the work that is required to check if a specific flag is set (specified as operand op1) and if so print the message specified by operand op2. We need to specify also our label as local so that there is no label duplication when macro is placed in code multiple times. We also keep the flags to be restored after printing. Having this we can simplify the code a bit to basically this: 

However, no such allocation happens with so there is no reason to avoid nested reduces. Note that the proverbial "sufficiently smart compiler" should be able to handle these problems (but not necessarily the quadraticity above!), so you should only worry about this if you discover it to be the performance bottleneck. Remember (SICP): 

Algorithm Your algorith is quadratic for no good reason because and are linear in list length. I suggest that you add new elements to the beginning instead of the end of the return value in and 

note the use or instead of . Another interesting optimization is changing the iteration in from descending to ascending. This should speedup it up considerably as it would terminate early more often: 

The way quick sort is defined (requiring random access) it cannot be efficient for linked lists (especially immutable ones). I recommend a recursive implementation of merge sort. It will be clear and concise. It should also be relatively efficient. 

You can improve your code by using vectorization to speed up the computation of Euclidean distances in the inner loop. The code would be: 

I think you will know how to take it from here. Note that if your data is so large that you cannot handle all stations at the same time (i.e can't even compute ), you could loop on the main stations by bunches, e.g. 1000 main stations at a time. One remark: your earlier solution and the one I suggested here both use basic euclidean distance to compute distances. This will probably be fine if your data is restricted to a small region and far from where longitude jumps. Otherwise, you might want to look in a more appropriate function for computing the distance matrix. 

There are certainly more things that can be done. One thing that comes to mind is to use the package instead of data.frames since you have such a large data. But please let us know first how much faster this code is. Maybe it won't be worth the extra effort. 

You are checking the primality of the same numbers several times! Extra optimization can find a divisor, not just check primality. Optimized algorithm 

Lisp is a multiparadigm language. is just as lispy as recursion, and, in a way, much more so (think in HOFs)! Style 

Performance is probably quadratic in your implementation, so you might want to consider another approach for larger values of 1000 :-) 

is unreadable. is better. is far too high precision. With such an epsilon, you might as well use instead of - the "oscillation between two adjacent floats" problem will be the same. Read up on machine epsilon. This number should actually be an argument to . Adding a line break would make the function more readable. 

is C/Java style. Lispers use or . is clearer than . Lispers use indentation, not paren counting, to read code. Your code is thus virtually unreadable. Please use Emacs if you are unsure how to format lisp properly.