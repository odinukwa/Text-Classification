All a multi-pass shader really is is more than one separate set of shaders that operate on the same input data. For example, toon rendering is a common application of multi-pass shading, with two distinct passes: 

You propose running each separate "system" in parallel. The problem with this is that you will have to lock every single piece of shared state. CLARITY EDIT: When you have two parallel operations using all of the same data, lock contention and synchronization is going to slow things down so that you're not gaining many benefits from the parallelization. The key to multithreading a game engine is to realize that many systems perform SIMD-like operations, where a single operation is performed over a large number of game objects. One example is adding each object's acceleration to its velocity, and then adding its velocity to its position. When something like this is happening, you can spread the workload over multiple threads. You'll see huge performance increases when parallelizing CPU-intensive operations like pathfinding or collision checking. This is better because it doesn't require locking the game state and does not introduce any problems relating to synchronization or racing. In fact, your main loop does not really need to change at all! 

A million images are obviously not going to fit in RAM at the same time, so you need some sort of caching and streaming mechanism to constantly load in the images you need. An easily-implemented but slow solution is to load in the image as soon as it is needed and unload the image as soon as it is unneeded, i.e. when the face of the card becomes visible/invisible. This will involve a lot of file I/O and will be extremely slow. An alternative and better solution is to have some sort of cache. The basic function of the cache is to retrieve a card image given an ID, be it a string, integer, or something else entirely. Internally, the cache will store a to map a loaded image to this ID. When the cache's function is invoked, it will first check to see if the image has been loaded, i.e. check if the dictionary has the key . If so, that card image will be returned. If not, the card image will be loaded and then returned. Of course, the cache doesn't have unlimited memory. You need to have some system in place to discard unneeded card images. The simplest way to do this is to sort the images by when they were last used. The most "stale" card image is then discarded to make room for a new one. You could also implement a more complex system that determines which image to discard based on the number of cards in play, how often the card is used, etc. A side benefit of having a cache is that you can easily "prefetch" card images before they are needed so that the game doesn't appear to pause and load the image when the card comes into view. For example, if your game has decks, you can prefetch the images of the top few cards. Make sure that you have your images loading on a background thread so that the game doesn't stall if many images need to be loaded at once. Simply play an animation to delay the card being shown if its image is still pending. The great thing about a cache like this is that it can be used for any kind of resource, like shaders, models, sounds, and even game object prototypes or blueprints. Just make sure you have a robust prefetching system for more real-time and demanding games, especially open-world games that shouldn't have loading screens :) EDIT: Here's a simple, single-threaded implementation that only implements a time-based discard system. Card images can be prefetched simply by calling without worrying about the return value. Card images come in the form , where is the value passed into . 

Point your index finger in the direction of the left-hand operand Point your middle finger in the direction of the right-hand operand Your thumb is now pointing in the direction of the vector obtained with the cross product 

Hopefully this is pretty self-explanatory in places where I didn't go into detail. If something doesn't make sense, just comment and I will add detail where needed. Disclaimer: this code is completely untested but, to the best of my knowledge, should work. 

I'm creating a 2D platformer and I'd like to implement an auto-tiling system. Normally, this wouldn't be particularly difficult. However, I'd like to have tiles like in Yoshi's Island, where the graphics extend past the actual collidable tile's boundaries. Consider this image: 

Make each system loop through all entities each frame, skipping those that do not satisfy the system's component requirements. Each frame, check the entities which have been modified and loop through all the systems, registering the entity with each system that is able to use it. 

If you want a lot of fancy effects and sprites on the screen at once, use OpenGL because it supports shaders and is hardware accelerated. If your game is simple and doesn't need a lot of effects or sprites, stick with SDL, especially if it's your first game. SDL isn't hardware accelerated, but it's much easier to use. Note that if you are going to use OpenGL, you can actually use SDL for everything but graphics at the same time. Other cross-platform windowing libraries that support OpenGL include: 

First of all, you must define the input geometry in patches, which are made up of control points. This can be seen as a generalization of primitives and vertices. The important thing to note is that control points do not necessarily have to coincide with points on the resulting curve or surface. I will define a cubic Bezier curve as a 4-point patch: 

I would always go with the first. Let's see why we should eliminate the other two: Having a pointer directly to the resource object is not great. In terms of performance, it's really about the same as an index lookup (assuming an array or hash table of resources). However, it's not flexible. It's meaningless to have it stored in an external file, and requires an extra field for any magic number (to prevent temporal issues). Storing the library handle directly is borderline useless. My biggest gripe is that it prevents you from associating various levels of detail as the same resource. The resource header that you look up with the ID should have an array or list that contains the library handles associated with detail levels. This also suffers from the same problems as the pointer on top of that. 

Apologies for the C syntax, I don't use LWJGL but from what I've seen it's pretty much directly transferrable. 

The simplest way to enforce a relationship without strong coupling is to use a Mediator. There could be an system that keeps track of the player's keys and listens to collision messages between the player and doors. By moving this dependent logic upwards, you keep the player, the key, and the door decoupled. Here's some C# code to illustrate. If you need clarification just leave a comment. 

I've never used the UDK before, but I'd solve this problem using pseudo-forcefields. Each object has a convex (most likely spherical or elliptical) forcefield that encompasses the whole object plus a few in-game meters or so of room. These forcefields may combine or affect each other depending on closeness, so that actors won't walk into a V-shaped dead end and get stuck. Now, when an actor begins to enter a forcefield, it is steered away from the center, faster if closer to the object, and won't collide. PS: Make sure to disable or shrink the forcefield if it contains the goal point. 

The way I do it is build one general-purpose shader program with optional parts sectioned off using preprocessor conditionals. For example, a simple fragment shader with optional texture mapping: 

The quad-tree should encapsulate the whole world, not just the visible area. Aside from that, it's overkill to represent ground tiles as entities. It's rare that you'll need to have modular functionality for the ground. 

I'm writing a cel-shading effect in HLSL and Direct3D 11, and I need to be able to flip the culling mode on the outline pass of the effect. I know you do this in XNA by setting CullMode to CW or CCW inside the pass definition, but is that how you do it in D3D11/SlimDX? 

These flags such as or are defined in the game code when the shader is compiled. In my system, the flags are mapped to a bitfield which is used to look up the desired shader progam object. Therefore, your material is essentially a bitfield + a program identifier + uniform data. The bitfield governs which uniform data must be present. 

Marching cubes is a pretty efficient algorithm. It's just a couple of lookups per cube and it works in O(n) time. You can also run it in parallel very easily using a thread pool, so even if it's constrained to the CPU it's pretty fast. 

If you accelerate for half the journey and then decelerate at the same rate for the remaining half you will come to a stop at your destination. Did you mean for the velocity to be exponential? That implies a variable acceleration, which is not very realistic. If this is what you intend then just apply the same logic to jerk (which is the derivative of acceleration with respect to time). That would simply involve negating . Since you will end up at extremely high speeds if the distance is long it might be worthwhile to lock "warp drive" to an analytical model to prevent floating-point error from building up in a numerical integrator.