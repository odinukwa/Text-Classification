Looks like you you have duplicated the background position twice in the else part. I've inserted the 2 below 

Added: After the else statement you have background.position = .... in twice. The first one needs to be background2.position 

Chrome is likely to use hardware acceleration. Create a canvas 240x240 and run your experiment in Chrome then create a canvas 300x300 and do it again. The larger canvas I expect to be faster due to the fact hardware acceleration kicks in after 256x256 and chrome uses software when the sizes are less. Also it worth pointing out that -webkit-transform:translateZ(0) turns off hardware acceleration. I haven't tested any of the above; I only know this due to the fact one of the chrome engineers commented on a bug I reported in chrome when you cross the hardware and software threshold by dynamically resizing the canvas from larger to smaller than the 256x256 boundary or vice-versa. The solution to this bug was to turn off acceleration using the translateZ as mentioned above. In my case, I simply did not allow users to resize less than 256x256. 

In other words, it means that I want the camera to be rotated so to align to the longest side of the object's bounding box. I tried that. Still, I was unable to properly calculate the correct angles so to rotate the camera in a way that the horizontal axis of the screen becomes parallel to the width of the objects' bounding box. Any help would be much appreciated. 

I give up. After much trying and searching, I have to say I was unable to achieve the following task, for which I must call for your wise advice. In my current Unity 5 application (using C#), there is a procedurally generated object (therefore with variable shape) to which the camera should be aligned when players hit a given key. By aligned, please understand it making the width of the screen parallel to the longest part of the object. The idea is represented in the following picture, where in black one can see the irregular object, in yellow is the bounding box. 

I'm not really sure which is the most appropriate or most natural. Hence my question: What do I do with player-input during movement? 

The "Rectangle" before getEntity() is the type of variable that the function will return. If you want the function to return another type, simply change it. 

Now the function will return a new instance of the Entity Class. But i suspect you want to return a specific Entity. 

Make sure your tiles are stored appropriately. In a multidimensional array, or anywhere where their positional data is stored implicitly. Find the tile each of the corners of your sprite(the red rectangle) is hovering over. In the image these are [10,3], [12,3], [10,6] and [12,6]. Determine the range of your sprite, using the four tiles from step 2. (The yellow area) Check collisions only for the tiles within the sprites range plus an extra tile on all sides. (The green area) 

I have beens struggling with the following. In the game I am developing with Unity 5 in C#, I need to implement basic pathfinding over moving platforms (not with moving platforms). It means, I am not concerned that NPC are able to take moving platforms, I am specifically concerned that the whole pathfinding process should happen on big moving floors. Being that the case, NavMeshes are not an option. Would anyone happen to know of any approach, or have any good tips for that? Thanks in advance for your time. 

Recently I have been implementing the Block A* any-angle path-finding algorithm in a project I have, for which I need extremely efficient results due to the large number of NPCs. However, I still do not know exactly how to handle the problem of local avoidance between the NPCs moving at the same time in the same scene. So, my question is this: what is the best method to implement local avoidance with any-angle path-finding? Just testing for LOS and steering to the tangent of the predicted encounter is a good enough solution or should a specific AI implementation be included within the pathfinding routine? I would highly appreciate references (academical or not) with state-of-the-art implementations of local avoidance for me to explore the most recent developments in that field. Many thanks. 

I'm not sure why you think: As you can see, sooner or later, with many maps I will be dealing with many IDs. And that can possibly get a little confusing and hectic. LeftID will always be -1 of the currentID, the rightID will always be +1 of the currentID. UpID will always be -(total map Width) of the current ID and downID will always be +(total map width) of the current ID with the exception of zero meaning you've hit the edge. A single map can be broken into many maps, and are saved sequentially with mapIDXXXX where XXXX is the id. That way, there isn't anything to be confused about. I've been to your site and it seems, I could be wrong, that the problem is down to your map editor imposing a size limitation which is hindering your automation to break down a large map into multiple small ones on save and this limitation is probably restricting a technical solution. I've written a Javascript map editor which scrolls in all direction, 1000 x 1000 (I wouldn't recommend that size) tiles and it still moves as good as 50 x 50 map and that is with 3 layers including parallax scrolling. It saves and read in json format. I'll send you a copy if you say you don't mind an email approximately 2meg. It is meant to be on github but I haven't got any decent (legal) tileset which is why I haven't bothered to put it on there yet. 

Introduce an anti-camping character Take a look at the Team Fortress 2 Spy (gameplay) for a good example of an anti-camping character. 

You create can create a multidimensional array and place the tiles in the array according to their position. you can now use the information that a tile at tileArray[5,6] will always be next to a tile at tileArray[6,6]. Combining the array and the fact that we know the tile size, finding the tiles becomes a breeze. let's say we have a very small Sprite and we want to find the tiles it can collide with. We can start by calculating the Sprites position on the tileArray (Step 2, simplified because the sprite is small). simply by doing the following: 

The function is now set to return an Entity type, but still returns a Rectangle type. This will give you an error(as you've probably noticed). So the return statement has to be adjusted as well. 

I have been reading quite a bit in order to make the following choice: which path-finding solution should one implement in a game where the world proceduraly generated, of really large dimensions? Here is how I see the main solutions and their pros/cons: 1) grid-based path-finding - this is the only option that would not require any pre-processing, which fits well. However, as the world expands, memory used grows exponentially up to insane levels. This can be handled in terms of processing paths, trough solutions such as the Block A* or Subgoal A* algorithms. However, the memory usage is the problem difficult to circumvent; 2) navmesh - this would be lovely to have, due to its precision, fast path calculation and low memory usage. However, it can take an obscene pre-processing time. 3) visibility graph - this option also needs high pre-processing time, although it can be lessened by the use of fast pre-processing algorithms. Then, path calculation is generally fast too. But memory usage can get even more insane than grid-based depending on the configuration of the procedural world. So, what would be best approach (others not present in this list are also welcome) for such a situation? Are there techniques or tricks that can be used to handle procedural infinite-like worlds? Suggestions, ideas and references are all welcome. EDIT: Just to give more details, one should see the application I am talking about as a very very large office level, where rooms are generated prodecuraly. The algorithm works like the following. First, rooms are placed. Next, walls. Then the doors and later the furniture/obstacles that go in each room. So, the environment can get really huge and with lots of objects, since new rooms are generated once the players approaches the boundary of the already generated area. It means that there will be not large open areas without obstacles. 

This decreases the collision checks per sprite from all tiles to only nine! Again, if anything is unclear, let me know, and I'll try to explain it better. 

The spy balances the game by allowing the enemy team to fight back. It is now dangerous to camp, and becomes more dangerous the longer you stay in one spot. 

I'm hoping to find out how many sprites are on the screen at any given time. In other words, is it possible to find out how many times is called between and ? I'm looking for a build-in function. Although I'm more then happy to write something myself, I'd rather not reinvent the wheel, and maybe I've overlooked something. 

In a concept I'm working on, the player can move from one position in a grid to the next. Once movement starts it can't be changed and takes a predetermined amount of time to finish (about a quarter of a second). Even though their movement can't be altered, the player can still press keys (perhaps in anticipation of their next move). What do I do with this input? Possibilities i've thought of: 

Scaling up any bitmapped image such as png will always look pixelated. To avoid this, if you have the memory, save the non-scaled image twice the size you currently have now and scale down 50% to get it looking like the non-scale image in the above diagram. To get it looking crisp at 2x-scale, you don't scale at all because it is already at that size. Your other option is to use vectors, but this can become expensive in terms of consuming processing time and may lack finer details compared to bitmap, i.e. look cartoony but that could be a positive on your game. You also need to find an appropriate library to do this. The advantage of using vectors is that it will most likely take up less memory and will look good, as long as it isn't too tiny, at any scale compared to using bitmaps. 

Reason for this is that you will not time your interval with the main loop which is clearing the screen which prevents you from seeing the 'sparks' Finally, probably harmless, but to be safe, change the comma to a semi-colon here 

This way you can cut down on most collision checks, especially when your level size is large. If your sprite is smaller than your tiles, you can get away with only determining what tile the center of your sprite is over(instead of all corners), because it can only ever collide with the 9 tiles around its center. Finally, for further improvement, you only have to check the sprites that are moving. If a sprite is not moving, it won't be able to collide with any tiles anyway. EDIT: Step one is important. Store your tiles in a multidimensional Array. When your tiles are stored in a is is impossible to find close tiles without looping over everything (as you probably have noticed). An array makes this much easier, because it implicitly stores the locational information of whatever is in it. Let's say you have a 10 by 10 tilegrid. 

As you said, the problem arises because you're comparing each tile to each sprite. This leads to many unnessesary checks. You can cut down on these checks by only checking the tiles directly around the sprites.