As you are looking for only one resource the reader won't proceed if there is none so you don't have to check whether it has any rows. You can just return the result after the first one. 

I don't entirely agree with the accepted answer. That part that bothers me is the suggesion about using this overload here: 

New event handler Now put everything together and be happy with this pretty nice two-liner event handler: 

Your class works the same way. It implements everything you need so you can either use it inline or to define new types. I find it's perfectly fine. 

The first improvement you can make is to create a class and a method for the formula because in a real application you wan't to write some test before you let anyone use it so how about a ? I don't know if this formula has any special name so I just named it . Apart from putting it in a testable calculator you should work on the names. What is or ? How are those letters related to the formula? If you are splitting it into multiple variables then give them resonable names. Should it happen that the denominator is then the is to be thrown and handeled. 

I cannot explain you the opcodes or registers because I have no idea how the work but I can calculate them as you do so this time I'll just show an alternative linq-ish solution: 

You are executing this query for each record because the list wrapps only the part (which is an array anyway so I don't understand why you convert it into a list in the first place - linq can work with arrays). You need to call the extension after the 

This could simplified with which would stop checking other properties if the result of would be for any of them: 

You are also doing other things that are very unusual for C#. For example you use a plural name for the enum. We do this only if it is also decorated with the that indicates that the values can be combined. Another strange naming convention is the . C# uses a prefix for generic types so the correct names should be: . 

If you made the of type then you woundn't need the cast... but the already has a constructor that accepts a collection... but it uses the extension. This is a vicious circle. You should move the loop into the constructor or use the or even better use the constructor to initilize it from the . The should not depend on the extension. The extension should depend on the . 

Implementing the is now much easier because you no longer have to care about the order of operations and override the method. Just do the validation and whatever else it requires by overriding the other methods. The new implementation also no longer needs a custom constructor because the new method requires a parameter. 

People shouldn't use someone else's code if they don't know how to do it correctly. As a matter of fact the most part of the question is based on this borrowed code and should actually be closed because this is considered off-topic. Let's take for example this API: 

The has two very similar methods: and . I find this duplication is not necessary. could call synchronously. In fact, they are identical. Additionaly I expect to return a so that I can it (if I wanted to) - this is the usual convention for methods. 

HTTP-Request-Headers configuration This new and immutable class allows me to chain http-request-headers configuration for the . 

so I don't think it's necessary to get the connection you've just created with because it gives you exacly the same connection back. I removed it from the constructor: I have also made an adjustment so that you can use either the defautl for unity or you can pass it any other connection (if you have any): 

The core part should be a class that can generate spiral coordinates and return them as like this totaly overengineered one. 

The general issues in your code have already been mentioned in other answers so I'll just post a simpler solution. 

In addition to @AdrianoRepetti's suggestions I find that the only method you have there, the , does not require an instance. It could be just an extension for the collection and it could be implemented purely with LINQ in a lazy fashion: 

Multispace bug There is one flaw in this solution. It assumes a perfectly formatted sentence. This means that if there are multiple spaces between sentences the formatting won't work. For example it turns this into To fix this you either need another extension fixing all multiple spaces with a single one or make this one aware of this problem. 

This is by far the worst line in your code. It took me a while to realize that there is actually an behind the while I was wondering why didn't you indent the three lines below it but wait, these lines are not part of the , it's the . You should always use curly brackets 

String slicing might be in some scenarios a very expensive operation so it's good to know that there is a new feature that can significant improve its performance, when necessary. 

Why can I set an id but cannot read it? If I'm setting it for the current then it should rather be a property although I doubt an id should be settable at all. If this is however for something else then the method name does not clearly communicate this. 

This might cost you a lot of performnace because if is a real deferred enumerable will enumerate it alredy for the first time. Then you'll enumerate it again consuming the result. 

Example The other reviewers already mentioned that it is not very clear what you are going to do so this won't be an exact solution but just a proof of concept and a general idea. There are countless possibilities for the design but for now I picked the following: You start with a interface: 

It's a very bad idea to call the controller a and inform the user that he's going to be working with well, a file system. He should not know how you are storing the data he uploads. You should not reveal this implementation. A Web-API is a resource and should be seen by the client like one (whereever possible), this means your controller should be called . Whether you store the data in a database, a file system directly or in a cloud it's none of the user's business. Knowing the underlying technology he might try to exploit it. 

How? You first need to implement an action-filter-attribute and decorate your controller with it (or just the action). I'm using this implementation: 

where for each point the is executed however its signature isn't easy to understand and actually needs commenting. You can avoid this by creating a custom delegate: 

Example Here's how it could look like and let's with the attribute that will store the query string name of one parameter: 

As all operators are binary and return either or we can pass the acutal assert as an to check the condition and generate the message only in one place: 

This means do just what needs to be done, this is, denominate. Everything else you can do with what's already there so let LINQ do the rest. 

I know the names are ugly but I don't know what the numbers mean, this is why we dislike them. They have no meaning. Next, the logic can be extracted as an easier to maintain dictionary. Now that all values are enums we can easily build such a dictionary that I find by far is better then a nested in a loop. Besides, you can reuse the dictionary to display the options in other places (if you make it a filed or a property of some class). 

where you write Rethrow with a specific message but in fact this isn't rethrowing anything. It throws a new exception with a new stack-trace without an inner one that is completely ignored. It might be logged but at this point you loose the connection between the two. What is by the way a ? An exception should by its name already give a good explanation for what went wrong like: or . But this one tells me that the user was too friendly and that was a reason for throwing it ;-) 

I also wonder what's the purpose of returning a if this is nowhere used. The same with checking the equality of the new and old values: 

It's not a good idea to change state of the class the way you do it here only to return the field as a result: 

With this you don't need the boolean and the conversion method because you can either use on it or in many cases it will be implicitly converted. 

I replaced the dependency by the new class that any observer can receive and call the method on it in order to cancel the retry process. 

Next comes the . Upon creation it receives the and the automatic-properties form a factory. The method renders the and sends it to all listeners via the . 

Should I want to customize the request for a specific call, I would do it just after calling . Here I can chain extensions for adding other headers etc. 

Tests To test it I wrote just six tests and I think this is actually enough. The first test is for the 

Materialize for easier debugging when calling resources As far as your code is concerned you call a web-service there 

If you want to be sure that each workbook is properly closed you can add another for the data files inside the loop. 

The new query is now much easier to understand and does not requrie any comments. It also swaps the with the so it has less items to process. 

Other than these few nitpicks I find this an amazingly clean and useful piece of code that demonstrates how practical expression-trees and dynamic code generation could be and I have to study it more ;-) 

And this is how I've tested it. I created three produces working with different speeds and limited the queue to 3 items. Before leaving the application I'm waiting for items that may still be in the queue. 

@variable This kind of naming can and should really be avoided. I'm sure you can come up with a better name then just a delegate which says pretty nothing about the method. 

At best nothing - they should know only about abstractions. (Further reading: The Dependency Inversion Principle) 

This is really bad. You are hiding the original exception. If you don't want to pass it as an inner exception at least do to be able to see the stack-trace later if necessary. As a matter of fact this could be a separate method that gets the from the xml you could then just return the without the helper variable outside this block. 

Example The usage did not change much because most of the changes were internal ones but for the sake of completnes here's the new use case: 

HTTP-Method configuration The http-method-configuration classes are very simple and contain just a couple of properties: 

This means that the should actually be three classes. On top of all this you cannot test it because the nested factory is a static one and if you try to write a test validating the you couldn't because you cannot verfiy that it'll do to the last id because if any other test executes at the same time the result might actually be or even more. You also cannot verify that it correctly adds the new instance to the list because agian, if any tests execute at the same time you could have more then one object added to the list. 

As each sequence ends with we can add it as a terminator to save some time and not calculating it over and over again. I picked a queue to store the last three s. When you have your numbers... 

You could also add the methods to the class itself but still keep the writing/reading logic in a specialized unit. 

This might look like an overkill now but you'll be glad having this in few weeks. You never want to maintain comments. It's easier to maintain the code. If you format it properly then it's pretty easy to read. This means that in a case like this with lenghty code I'd rather use full-property syntax, add a few line-breaks and indents and here it is. Doesn't it look much better? It documents itself, leave it as it is. Work with formatting now.