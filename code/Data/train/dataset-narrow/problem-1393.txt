Zeroth solution is First solution is which is Second solution is stricly better. Third solution is stricly better. Fourth solution is stricly better. 

A more appropriate algorithm If you want to generate a list of primes (and non-primes) in an efficient way, you should have a look at the Sieve of Eratosthenes. 

Avoiding the additional array A different way to write this without an additional array is to see that the different indices of odd values are substracted, then added, then substracted, etc. Also, you have to perform as many additions as substractions. We could use a simple flag to handle both the alternance of sign and the check that we've performed the same number of additions and substractions. For instance (highly not tested): 

Disclaimer : this is not quite an answer but more than a comment. You've written tests and I'd like to start by thanking your for this. This definitly makes reviewing easier. Good think to know if that you can make easily double the amount of test you have without thinking too much. Indeed, it seems like by inversing the parameters of your function, the return value should be the opposite value. You can write this : 

Now, I can use for performance testing. Computing things once At the moment, you re-compute your sieve multiple times. You might as well juste do it once with the biggest max you can find. 

Bearing in mind that a linter can only look at how the code is written and not at what it's actually doing, statements (or the equivalent as with Ruby) that don't do much are completely fine. A switch that tests many conditions is bound to be long-ish, there's not much you can do there. Every one of the warnings you get is a direct consequence of the fact that you're testing 8 values. I would say this is one prime example of a situation in which you just don't waste your time in an attempt to make the linter happy. Extracting methods is going to clutter things up and look dumb. The only viable option that I can think of right now is sticking those ranges along with their readable description in some kind of hash, and retrieving the value from there. But it's a compromise, really: if this method gets called often, you could be instantiating yet another object at each call. I say you just ignore what the linter says in situations like this, or adjust its default settings to make it less bitchy. Your method is fine, the intent is very clear to me, and it's not doing anything complicated. Don't get all caught up in an attempt to please a tool that doesn't understand your code to begin with. 

Please have a look at PEP 8 giving the Style Guide for Python Code. Now, in (or ), it seems like you assume that A and B have the same size. You could achieve the same result with . 

Your code looks good and is well documented. I have a few suggestions anyway. Naming is a long name for such a function. The prefix is probably not useful and neither is the . The expression is probably explicit enough without additional information. The same kind of comment applies to the other function names. Domain definition (and default value) It seems a bit "un-natural" to handle as a special case for . It may be clearer to explain that is expected to be a strictly positive integer. Then you'd just need to give the default value 1 and everything would work just fine. Function called twice In , you call the same function with the same argument twice. You can easily check this by adding a at the beginning of . A solution to this issue is to rewrite the function: 

This can also be reused in other places but I'll let you deal with the pleasure of doing so. Do not repeat yourself Do not repeat yourself. Do not repeat yourself. Many things look wrong in : 

Controllers I made controllers for logging in, logging out, and registration. These all return a response, which is then used by AngularJS. Basically, it creates an APIKey on succesful login and destroys all APIkeys related to the user on logout. 

These two checks give us the option to filter out StraightFlush, Flush and Straight. If it's neither a straight nor a flush, we need to look at grouping the ranks. Then we match the length of the list of similar ranks to find everything from to . The values are in this case the concatenation of the list of similar cards (e.g. rather than the ranks from high to low (e.g. ), to make sure the relevant values for the ranking (e.g. ) are compared first. A line is parsed by removing the spaces, then splitting (resulting in a tuple , which then mapped over by , and then the first value is compared to the second value, resulting in a boolean that is if player 1 wins the hand. This is then used as a filter to count the length of the list of hands in which player 1 wins. My implementation works perfectly and is very fast (100,000 lines in 10 sec in ghci, actual problem is instant), so I'm not necessarily looking for performance improvements; any kind of feedback is more than welcome. 

Avoid repeated values In your testing code, the values appear in multiple places. You could re-write your code to generate a formatted answer from the list: 

This being done, my unit tests are still passing which gives me some confidence that everything's allright. I can now go back to and improve it : we don't really need to convert the sets to lists : the is faster on sets. 

In , the loop is very unpythonic. The very point of the loop as it is defined in Python is to prevent you from having to deal with indices. 

Style You are lacking consistency in the spacing in assignments. Organisation It might be worth extracting the algorithm in a function. It makes code easier to read and to test. 

In , the class should be responsible for updating its own score. You could define an method taking the same parameter as the one (and calling it). Also, shouldn't be responsible for the conversion to ? I find it a bit awkward to have the and the base their logic on completely different fields. In a : as a general rule, you do not iterate that way over object in Python. The pythonic way to write 

Do things less often (again) I missed it in the first place but you could do the join-and-strip part out of the loop: 

For one thing, the domain being global is not very good: what if two users have email addresses on different domains? Are you going to set it to different values in between user creation? Just let the user have its own email address. Globals in general are frowned upon for many reasons, so when you catch yourself thinking "yes, I'll make this a global", please count to ten and then don't do it. To answer your question in the comments, where you assume you have an internal mail server only: a good rule of thumb is to keep outside of your program everything that can conveniently kept out. In this case, the domain is configuration, and as such it should be kept in a configuration file. Your program does not and should not know what the specific domain is. It just needs to know how to read it from an external configuration file/database/what-have-you. Modifying software is not a lot of fun, so if you can make a program whose behavior you can modify without even touching the source, it's way better. What if your domain changes? As it stands, you have to change your program, and possibly even test it again. What if the domain sits in a config file? You change it in there and you're golden. If you think hard enough, you will find that a lot of configuration can be kept outside of the program, even down to the choice of different algorithms to accomplish the same task. Personally, I try to make everything I make as configurable as possible, because recompiling and testing and deploying is boring. Finally, globals are bad because they're hard to keep track of, and it's difficult to know what parts of the code read from and write to them, which makes the whole thing horribly coupled. Do try to avoid them as much as possible. 

This solution is symetric in terms of and . Its complexity seems to be ~ n^3*log(n) in the worst case (points are a grid) which is not too far from the optimal. The complexity is ~ n*log(n) in cases where no more than 2 points are on the same horizontal or vertical line. Tiny optimisations would be starting the binary search in the smallest possible range : 

Then, I applied a pretty similar trick to other colors by changing the line and I realized that they could be computer with a similar logic but with an additional shifting. Now, the code can be written : 

(I've used as a loop variable to make intent clearer but the usage/convention is to use as a variable name if you do not use its value). Making things more simple You call multiple times which adds whitespace that you are trying to remove later on. It would be easier to build the string you want to print and then print it in one go. Using multiple Python techniques : 

No, there is still a major issue : recursion is slow in python and it will fail eventually when you reach the maximum stack size which is not that big if I remember correctly. In your case, loop can reduce this effect (if not remove it altogether). On top of performance issues, it can make things hard to read/understand to have function calls leading to indirect recursion. First attempt is to remove the obvious recursive call from : 

are you sure this is correct? Concatenating a column name to the other like that? Are you assuming the column name will be passed in followed by a comma? And anyway, isn't it going to blow up with a syntax error when you do the `UPDATE`? Or will the column name get passed as an empty string? Might be a good idea to check what garbage you are receiving through your parameters, assuming said checks aren't already in place at an upper layer. How can you be sure all callers will remember to pass your arguments exactly the way you expect them? Plus, just my two cents, but if my assumptions are correct, this is not a very fun API to work with. 

Code like this is bound to be a bit hairy. However You aren't using parameters This is a big security vulnerability. What's that method doing? Is it doing everything by the book? Does it handle every possible obscure corner case? Let ADO the MySQL connector manipulate your query, especially if there's a chance you're handling values supplied by the user. MySQL can perform the so-called MERGE (also called UPSERT) You can do it via INSERT ... ON DUPLICATE KEY UPDATE statement. In case you are not aware what that is, it's basically a way to either insert or update in case the fails because of a duplicate key error. It's for sure faster than making a separate query to retrieve the records that are currently present. By the way, code like this leaves your code open to race conditions in case another user inserts a record exactly between when you read the current records and the moment you execute your . This is bad, and you're not currently guarding against it. MySQL can do it for you, take advantage of it. EDIT Also 

I defined a data type for the ranking, which is something like high card or flush. A HandValue is the combination of the ranking and the values of the cards related to the ranking + the kickers from high to low. For instance: . Note that even though I have an ace, the values that are relevant (i.e. the two pairs) come first. This allows to compare two HandValues with the same ranking (i.e. ). The instance for HandValue looks at the ranking first, and looks only at the values if the rankings are the same. To actually rate a hand, the suits and the ranks are separated, then: 

I'm making an app with a Flask API backend using a Flask-Peewee ORM and an AngularJS frontend. The Flask-Peewee ORM doesn't support token based authentication, so I decided to try to implement this myself. This is quite a bit beyond what I usually do, and I have in fact no idea whether this is secure or not. It does work, but that's all I know. Any feedback, from pointing out obvious security flaws to advice on good practices, is more than welcome. This is my implementation: Models I made an extra model for the api-key: 

This is the highest consecutive prime sum that results in a prime number that you can get with prime numbers starting from 3. The rest is fairly obvious; it checks for each starting prime the greatest prime below 1,000,000, gets the length and the prime it adds up to, then gets the prime with the maximum length. Any advice is welcome, specifically on: