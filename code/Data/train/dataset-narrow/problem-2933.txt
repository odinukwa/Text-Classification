Flipped learning keeps students more engaged. Teachers provide more personalized attention. Students can work at their own pace. 

A few things jump out from the official Java documentation: As far as an example goes, the idea of a Remote as an interface works really well based on this explanation. 

In short, yes. When introducing students to programming and how a computer works, historical perspective can prove highly valuable in several areas. Consider this one image of Margaret Hamilton next to NASA code: 

There are great resources on exit tickets online. A quick Google search for "exit tickets" will give you some great examples. This page from Brown University has more sample questions. Note on anonymity: None of my surveys is anonymous. I work hard to build an environment where students know I am actively working hard to hone my own craft and that I trust them and am humble enough to reflect on their feedback. I've had many occasions where following up with a student is necessary to make sure I can respond appropriately to their feedback. Students respond positively when are invested in their respective; if you show you are working hard for them, more often that not, they work hard in return. 

I introduce binary on Day 1 (if not Day 0). However, in my class, learning binary is not an end in and of itself: it is a means for understanding the fundamental concept of abstraction. As a teacher of AP CS Principles, I follow the College Board standards for the course. In that sense I have to teach binary, decimal, and hexadecimal, and conversions between and among them. The first "Enduring Understanding" under "Big Idea 2 - Abstraction" focuses on digital representation of data: 

My go-to answer for this topic is Nand2Tetris. There are 2 Coursera courses (Part I and Part II) that match the curriculum of the program. The first course does not require any programming background. Its focus is on computer architecture (logic gates, half-adders, full-adders, ALUs, RAM, ROM). The second focuses on a virtual machine and a compiler for a high-level, Java-like language (and thus does require some programming knowledge). The essence is that you understand every level of a computer from the gate up to a program in a Java-like language. In addition to the Coursera courses, there's a companion textbook and a full suite of software. The list of topics is below: 

For students who wish to study deep learning, a simple introduction to what machine learning even means and how it works at the simplest, most mundane of levels is a great jumping off point. Additionally, CS50 at Harvard changed languages this year to include Python. As a result, they did a whole lecture on machine learning and deep learning in Python. A much more self-contained example, this lecture would certainly be another value starting point for beginning a dive into this discipline. Links to CS50: Week 7 Lecture Video and Week 7 Lecture Notes 

The Snap! Manual, while probably more information than you want or need, does also discuss the logic behind its color and shape choices. In particular, Section I and Section X provide explanation and justification of the design of the Snap! environment. I would think that in any original or modified design of a block-based language, using the development of Scratch and Snap! to inform your own is as research-based as you can get. 

I agree with @Buffy's point entirely: "Mistakes should be corrected, but the how can be finessed." If I can be so vain as to quote myself, I said the following in an earlier question about teachers making mistakes in front of the class: "The classroom should be a safe place to fail, to make mistakes, because of the role said failure can play in the learning process. It's fine to make a mistake; it's not fine to be okay with it." If time allows, you can meet with the group(s) presenting who may need correction following the class. During this debrief, you can point out any facts that need correcting. Then, give them the opportunity to show to their peers what they have learned by giving a short (<5 minute) follow-up from last class's presentation during the ensuing class meeting. This empowers the student to do the learning and the re-teaching, much as you (or any teacher) would do in a similar circumstance. This method would both correct the error in private and allow for a "redemption" of sorts in public. 

Rather than giving them processes to model algorithmically, have them start coming up with algorithms for everyday activities. Here is the formal assignment I have students complete: CS50 AP - Everyday Algorithms. They begin with a simple pseudocode example: 

Quite honestly, I would be upfront with them about the debate. Send them to a couple other SE threads: 

One example that isn't necessarily exciting but would allow for a lot of class design is a interface. From there let's say you have , , and as classes which implement . You could do some really cool things by including as methods formulas for area and perimeter. Additionally, within , you could further subclass into (and further with and and ?), , and . Students will clearly see the relationship of . This will also hammer home the ideas that a subclass IS-A class as in a square IS-A rectangle and that the inverse (a class IS-A subclass) is not true. This can lead to fun, but important design conversations. Do you indeed make a subclass for , or do you have an method on testing for equality of length and width? A second example is this: give the students this challenge. Just as we are coming up with examples of how to categorize objects with IS-A relationships, so too should students come up with their own system of inheritance. I would bet that they would come up with some pretty inventive ideas. Moreover, the power of class design in OOP will "stick" if they come up with the system from the ground up. 

I'm in the midst of a PennX course on edX called Software Development Fundamentals taught using Java, and they gave the analogy of parts of speech. 

I used the above comic in a lecture on P vs. NP. The analogy I gave is eating at The Cheesecake Factory. Their menu boasts something like 250 dishes and 50 kinds of cheesecake. It's a tome to wade through. Now, imagine a scenario like this: You are given a $50 gift card to The Cheesecake Factory. You can order anything you want. Let's say for fun that you will limit your indulgence to 1500 calories. What is the most food you can order while staying under that limit? Good luck. The struggle of ordering food at a restaurant with a menu like this while also obeying constraints of money and calories while maximizing enjoyment and possibly quantity gets at the essence of the knapsack problem (Can a value of at least V be achieved without exceeding the weight W?). While it's an analogy, I think it does help to illustrate the nature of the problem. (Tangent: my wife and I went here to eat shortly after this lecture, and I tried to explain that my taking so long to decide was due to the fact that it was an NP-complete problem.) I also think trying to schedule a meeting with a handful of people can also be a helpful analogy for the Boolean satisfiability problem. I found these lecture slides in my research on examples to use in class. Slide 3 provides a practical example where four people try to find a day on which they can meet. Imagine you have a committee of 10+ people with all sorts of constraints. This is absolutely a real-world example of something that is a) difficult for humans to unpack algorithmically beyond brute force and b) easy to verify once it works for everyone. As the first known NP-complete problem, it's a great place to begin this conversation. 

As a final point on this topic, (passing each test case) is only one of four axes I use to assess their work. I also look at (attempting to implement all aspects of a program), (efficiency of logic/algorithm(s) in a program), and (readability vis-a-vis variable names, indentation, etc.). If you only grade on getting the code right, then I could see not providing test cases for every test case. However, if there is a bigger picture to assess in terms of code style and design, then I see no problem in giving as much information up front in order to aid student learning. 

Those are my big three; I'm sure there are more. Obviously understanding anonymous functions, higher-order functions, first-class functions, and all that comes with them (e.g. currying) is what functional programming entails. However, this content wasn't a "rewiring of old habits" in the same way that the above points were. For what it's worth, I appreciate what C has taught me about what happens on a lower level, but I think studying a functional language qua an approach to programming has made me an overall better programmer. 

One way to approach this might be to have students identify what they all have in common and what they each possess individually. That which is common -- like the school they are attending or the class (and maybe grade level) they are in -- should be . That which is not -- like name or age -- should not be static. You could also go into sufficient and necessary conditions. For example, a necessary condition for something being a bicycle is having two wheels, but it's not sufficient because you could have a two-wheeled motorcycle. To model a class , you could make its necessary conditions into static variables, such as . 

One unit of CS50 AP's curriculum focuses on three main sorting algorithms: bubble sort, selection sort, and insertion sort. There is also discussion of something more efficient like merge sort. One programming assignment has students write the code in C to each of the three "simpler" sorting algorithms. Students get clear pseudocode of how each works, but they are left to work out the code on their own. In contrast I just started working through Princeton's excellent Algorithms course on Coursera (Algorithms, Part I). The first unit there focused on quick find, quick union, and weighted quick union. The algorithms -- both in pseudocode and in Java -- were given by the instructor; the programming assignment (Percolation) involved the correct use of weighted quick union. Rather than implement it, I just had to apply it with the provided class . Similar to the Princeton course, the AP CS A curriculum teaches sorting algorithms but only use thereof, not direct implementation (e.g. students are not expected on the exam to write insertion sort from memory). Instead, students have to understand it and be able to trace through steps in the sorting process. So there seem to be two approaches here (not limited to just sorting algorithms): teaching the challenge of coding an algorithm from scratch (via implementation) vs. giving students the algorithm to apply to a particular problem (via application). Is there a significant benefit in having students attempt to implement an algorithm from scratch? If so, is this the more effective approach for teaching?