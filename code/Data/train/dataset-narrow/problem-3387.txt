To hint some solenoids see here, to name a local vendor that could be useful to you try Pollin I once got some mechanical actuators/solenoids there. 

As stated in the comments to the question the PIR sensors are standard ADAFruit sensors. The description points to a similar product: Parallax PIR sensor. The relevant product detail: 

Usually you keep sending more bytes to transmit the full stream if information one would like to send. I.e. you need to send 1024 bit, so you send 128 bytes. Any odd number of bits can be compensated for using padding bits, i.e. zeros that you fill in at the sender and throw away at the receiver. If you're asking about 9 bit transfer (9 bits transmitted per byte), see here: True 9-bit serial port data? where I take it that the pigpiod library is able to do 9 bit transfer with any port in a software UART mode, with limited baudrate of up to 19.2k though. The hardware UART of the Pi, as Milliways' answer suggests seems to be capable of 8 bit only. 

So other than losing some of the more finegrained controls the underlying provides there is nothing fundamentally wrong with using . Since it uses I will assume that the safety & reliability issues reported for Python 2.x are not an issue here. With Python 2.x however the use of is not recommended. 

On a more general level: First and foremost it is always ok to ask before frying (expensive) components or pieces of equipment. The next step of the learning process is to read and understand the datasheet of component - the sensor in this case. The voltage levels to safely operate the device will always be part of the datasheet as this information really is essential. Typically there will be a "Specifications and Limitations" section, or a list of features that includes the operation voltages. Datasheets also often include an "Absolute Maximum Ratings" section which as the name suggests documents operational conditions (such as voltage, current, temperature) that must not be exceeded. Stresses beyond those limits may cause permanent damage or affect device reliability. Operations outside the documented ranges will also void the warranty. In the case of the mentioned sensor the datasheet (as provided per NULL's answer) lists minimum, typical, maximum operation voltage (4.5 V, 5 V, 5.5 V). So the sensor has to be operated within a range of 4.5 V to 5.5 V. Undervolting at 3.3 V might actually not destroy the sensor but may (and will per joan's answer) significantly reduce the performance. It may fail at the most unforeseen moment or simply read nonsensical values. Simple put, it is not possible to use 3.3 V to operate this sensor. The other answers already made it clear that the number of sensors to be connected is not limited by the number of 5 V pins. They also provided solutions how to overcome this limitation. Note that this only applies to the power rail pins and not to GPIO pins that support only a very limited current. There is however one limit to consider - the current those sensors draw with respect to the power supply used. The sensor in question has a listed maximum working current of 20 mA. Which is not that much - but if ten sensors are used it will sum up to 200 mA which is starting to become significant. So be sure that the power supply can support the Pi, peripherals (like keyboard, wifi dongle, ...) and various sensors attach. To check this estimate and sum all the current demands and compare to the current rating of the supply. Check the RaspberryPi's power consumption for comparison. 

Note that states (i.e. there will be a line break, maybe your text editor just does not treat it right): 

Have a look at the Hifiberry products while the "newer" products use the GPIO pins, the Amp+ (DAC + amplifier) and the DAC+ board share the following pins (see here GPIO usage): 

Setting aside the ill-phrased part of the question (connecting multiple GPIO pins (which to my knowledge are 3 volts), to one ground pin) - which indeed short circuits the GPIO pins if they are set to output and thus most likely damages the Pi, there is nothing wrong with using one GND pin on the GPIO header for multiple GPIO pins. As you notice there are not as many GND pins as GPIO pins. The GND pins are connected to a common ground plane on the printed circuit board of the Raspberry Pi. The current that returns to the Pi is not flowing through the sensitive microelectronics (the processor). It is simply limited by the wiring and the header connector - which are safe to return the current of three GPIO pins (a few 10 mA in total). 

Not a full answer but just some thoughts (as the question is indeed quite broad): Low power WiFi solutions such as nodeMCU or ParticleIO could be used to handle these sensors and send the data to a central control unit (e.g. a Pi) via a local WiFi. Beneficial is the lower power consumption of those nodes compared to a Pi at each sensor. 

Both the two double-port USB jacks and the RJ45 ethernet jack can be desoldered from the board - given careful handling and removing short circuiting solder. I mention the ethernet jack, as it is a big and ugly as the USB and might also show up on the case. If ethernet is needed and the jack needs to remain on board, however I fail to see the benefit of removing USB. I'd rather look for a case that just hides their existance. 

I am not sure about RPi.GPIO but Joan's library also offers callbacks so I will try to explain how this could be achieved with as an example assuming the technique can be transferred to RPi.gpio (after all it's just Python doing the trick). can solve this task: Return a new partial object which when called will behave like func called with the positional arguments args and keyword arguments keywords. Syntax of pigpio's : 

I do not see how this could work out. (Set aside the question whether your employer would like the idea of you using the office network for personal purposes on that scale.) Why would it not work? The VPN would be just a tunnel using said terrible internet connection of yours and therefore suffer equally from packet loss and other issues. Introducing another layer on that bad connection is not going improve it. 

The MagPi, issue 6 (read: back in the olden days), had an article about the Camera Pi. It integrates a Pi in the battery grip of a Canon DSLR. The camera's trigger is done via the shutter release port from a GPIO pin of the Pi. This also allows waking up from sleep modes (which could supposedly not be done via USB and ). Readout of the captured image/video files is done via USB. 

No, the Pi Zero does not support ethernet over HDMI. Unfortunately the schematics for the Pi Zero are not available (edited: an overview schematics is available now, see updated information below). However since it is essentially an minimized Pi 1 I'd bet that the HDMI circuitry is (nearly) the same - though the Pi 1 features a standard sized HDMI connector (Type A) whereas the Pi Zero comes with a mini connector (Type C). Looking at the schematics of Model A and B (Type 1) Revision 2.1 on Github or on webarchive (Raspberrypi.org's schematics are now downgraded to less detail), page 2, we find that the pin 14 at the HDMI connector is not connected. This pin is responsible for the HDMI-Ethernet-Channel (HEC) for HDMI 1.4 and reserved for HDMI 1.0-1.3. So there's no HDMI ethernet connected on the Pi. Pin 14 (reserved for HEC) on the Type A connector corresponds to pin 17 on a Type C connector, see Wikipedia. The overview schematics of the Pi Zero 1.3 shows this pin as not connected (thanks to user Wilf for pointing to this updated information). 

For longer distances I'd vote for a serial communication using RS 485 differential signals. As it is a bus it allows for the connection of multiple clients/slaves that are individually addressable. For wiring simple twisted pair cables could be used - phone lines or CAT-x network cables are a choice. A driver for this could be either attached to the UART of the Pi or to make it even simpler by using a USB-to-RS-485 adaptors. I understand that you're not intending to go for a programmable solution (no microcontroller at the far end). Which I however would recommend to not dismiss from your list of options as it offers a highly flexible way at reasonable effort and quite cost effective (RS485 transceiver + small ÂµC is probably less than $5). But I was hoping to come up with a solution without your own microcontroller. Looking for "RS485 GPIO bridge" I find things as this one from NXP. But it is my understanding that this is not going to be of much use without some SPI/I2C connected logic there (aka microcontroller). So right now I cannot find a "RS485 GPIO expander" that comes integrated and ready-to-run. But maybe we need to think simpler here. So lets combine the electrical characteristics of RS-485 with the desired shift register. Assume SPI for the register which leaves us with SCKL, MOSI, MISO and GND. Skip SS (slave select) if each slave is connected via its own wires. Three signals means three twisted pairs so CAT-x network cables will work out. However this approach requires three RS485 drivers/transceivers at each end of the line (or two if the write and read to the devices are separate). Making it less desirable given the cost and PCB footprint. 

Have a good look at adafruit both the shop (disclaimer: no affiliation) as well the extensive guides section. They (and other vendors of course) offer a wide variety of HATs to interface input/output devices and an huge amount of different sensor to interface to. I think it's best to get a feeling what is available first and what can be done with it to work out the specifics of what you need.