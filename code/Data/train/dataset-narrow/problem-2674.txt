This blog post covers pseudo 3D collisions and discusses an interesting solution to your problem. I'll give an overview of the post but you should check it out as it does a thorough job of explaining the solution (with pictures too!) Their entities are essentially represented by three parts: a box for the body, a box for the footprint and a box representing the attack area. You can think of the body box as representing the width and height of the entity and the footprint as representing the depth. The footprint is used to determine z-order for drawing and whether or not entities are capable of colliding with one another. So, when the player is just moving (not attacking) only the footprint is used to determine whether it's colliding with another entity. In Box2D terms an entity could be represented by a Body with three Fixtures for the body, footprint and attack. Each Fixture would be a sensor so you get begin/end callbacks for collision detection but the Fixtures don't actually physically collide. In other words, just use Box2D for collision detection not physics simulation. 

I'm not sure if there is a game-specific translation framework but I've used gettext system for handling translations in WordPress. Here's the WP page describing their translation process along with a list of tools. The gist is that you create a template file that you in turn use to create translations. The final step is producing a binary, machine optimized file that is used in the actual application. I've used Poedit (runs on Windows, Mac and Linux) to edit translations for WP and found the experience to be fairly nice. It looks like Python supports gettext out of the box so it should be relatively simple to get gettext up and running in your game. 

My understanding is that Flixel has some optimizations that pre-compute values for drawing and it will only recompute them when the "dirty" flag is set. In your case moving the camera is probably marking the tilemap as "dirty", hence it updates when the camera moves. 

What you want it the built in Character Controller. By setting the property on this component you can get a player to move up and down slopes with ease. 

Option 1 doesn't suit me because it's a lazy cop out. Option 2 is much better but then a portion of the screen will be unused for some players. Certainly not the end of the world but not incredibly desirable either. This could be mitigated by rearranging the UI based on the aspect ratio and filling the letter/pillarbox with UI elements instead of simple black bars making better use of available screen real estate. How is this sort of thing handled in games like Quake, CoD, StarCraft and Battlefield? 

I'm currently designing a competitive 2D, side-scrolling multiplayer game and I want support full screen play at any aspect ratio (e.g., 4:3, 5:4, 16:10, 16:9). Doing that is not so much a problem, my concern is that the viewable area of the game for a player with a 4:3 monitor will differ from that of a player with a 16:9 monitor quite a bit. In a competitive multiplayer game where being able to see more of the game world gives a player a significant advantage over players who cannot this is a serious problem. So far I've come up with two possible solutions for this: 

I'm far from an expert but I've been working on an HTML5 version of Pong that uses Websockets for multiplayer so I can share what's been working for me. The general maxim I've been living by is: 

Use the 360 naming conventions exclusively. Use the PS3 naming conventions exclusively. Come up with something in between. 

You might need to mark the buffer as "dirty". Looks like you can do this via setDirty(). These threads touch on "dirty" a bit: 

You're really close to the answer already. What you want to do is implement all collision rectangles the same way and your idea for "corner rectangles" is pretty much that. Here's a high level look at what you need to do. 

I've been looking into this as well and I have yet to find something as clean and simple as XInput on the Mac. A library that's commonly recommended is OIS but it seems like it's not being maintained anymore. You can also take a look at the game pad implementation in SFML. It has game pad support for Windows, Mac and Linux. I haven't gotten a chance to take the SFML game pad stuff for a test drive yet but I've been impressed with SFML in general. 

One approach is to use distance as it will always be a positive number so you don't need to account for sign. When at , compute the distance from to and store this is a float called (or similar). Each tick of compute the distance traveled so far (this is to ), call this (or similar). Then compare to : 

I'm a C++ newbie working on adding gamepad support to Moai as a learning exercise and because I'd like to be able to use a gamepad with it. I'm starting by implementing the Xbox 360 gamepad via XInput and that's going pretty well. Eventually I'd also like to support the PS3 gamepad. This has got me thinking: the 360 and PS3 pads are mostly similar. They have the same number of buttons in more or less the same places that do more or less the same things (e.g., the right trigger on the 360 pad is an analog trigger, so is the R2 trigger on the PS3 pad). From the standpoint of creating an API to support both pads the main difference is the labeling applied to each button. The PS3 square button is in the same place as the 360 X button, triangle matches Y, circle matches B, and X matches A. Some comparison images: 

What I ended up doing was rolling my own API and documenting it well. In naming buttons I tried to make them both descriptive and controller agnostic. For example, on the PS3 pad there is a button called R1 that is on the right shoulder. This corresponds with the 360 pad's Right Bumper button. In my API this button is referred to as "Right Shoulder". Where the PS3 has R2, the 360 has Right Trigger and I have Right Trigger as these buttons are analog triggers in both cases. For the face buttons I started where the X/Square buttons (360/PS3) are and counted moving clockwise ending up with Face 1, Face 2, Face 3, Face 4.