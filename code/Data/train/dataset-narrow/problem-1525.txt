Indentation in the post-loop conditional is inconsistent with the rest of the program, and should be fixed. The same holds for the block (unless that was just screw-up of the code formatter here on Stack Exchange). The return value of is interpreted by the operating system as the return code of the program. On all OSes I know, 0 indicates success, non-zero indicates failure. You should therefore return 0 on successful program termination. Or just omit the altogether, is implied in the function in C++. Or, if you want to be really beyond reproach, and comaptible even with OSes where 0 does not necessarily mean success, you can change it to ; this requires . Error output (such as your message) should be sent to (standard error stream, usually file descriptor 2), not to (standard output stream, usually file descriptor 1). A more helpful error message would be in order as well. Something like 

When printing this message, you should consider returning 1 (or ) from , instead of allowing fallback to the default success. The outer could be removed. If the file is not open, will fail, and you would at least print an error message instead of failing silently. is a very non-portable and extremely cumbersome solution looking for a problem. You're calling an external program just to wait for a key press. You should get rid of it altogether: your program is not interactive at all, it could run just fine as part of a script. Requesting input like this ruins that. Just drop that line altogether. 

One thing I am aware of is that the code does not handle trigraphs; they are somewhere near the end of the to-do list. 

Note: Untested, it may be necessary to have the token concatenation () in a helper macro. Using it as such: 

The benefit is more information - the array size - for you (and the compiler) in some circumstances. A C style array "decays" (is implicitly converted) to a pointer to its first element in most situations. This conversion loses the information about the array size. I doubt that this has any benefit to you in your particular case, though, because you can use ... range based ... even with plain C arrays, too. This saves you from accidentally wrong indexing and other, often hard to find bugs: 

This will be costly ... thus you get yelled at. To avoid such surprises, use the qualified function name when you are sure of the function you want to call: 

IMO this is a huge imbalance. The basically controls and does everything with the small exception that it's not shuffling the cards nor handle the player's bets / funds. As such, it's a violation of the SRP. 

Do you hear the evil laughter? "active" vs the lifetime of an object What happened? When you the vector from its initial size 0 to some larger size in the constructor, then the vector will be filled with default-inserted objects. So directly after construction of your object pool, it is already completely filled with alive objects. These objects stay alive all the time (unless you ). Your notion of an "active" object basically just revolves around whether one can access (through ) that object. "deleting" just moves one object out of the "active" (accessible) region of your pool. "adding" enlarges this "active" region. This is very confusing and not what one does expect from an "object pool"! Further, it puts up some requirements to that type, namely that it must be default-insertable. With the standard allocator (which you use) this means that has to be constructible through value initialization. That's a pretty tough requirement, as it basically means that needs to have a zero argument constructor. Now, if is a bit more than a simple value / data aggregation type, then its objects will probably depend on some objects of other types. To follow the SRP one wouldn't let an construct the other objects then, but rather pass it the requirements upon its own construction (dependency injection). Your object pool design does not allow this, though. In short: You sign yourself up for lots of future trouble. To fix this, use for your vector in the constructor, and actually construct new objects when adding (make of the vector accessible) and destruct (terminology is important!) them when you want to get rid of them. To keep that later operation fast, swap the last element and the one you want to get rid of and then the last. (Of course this only works when order doesn't matter. Moreover, it invalidates possibly obtained references to the last element.) Swapping done right Calling directly is almost always wrong. Bring it into scope with , and then just do an unqualified call: . This allows ADL to kick in and find potentially useful user-defined functions. Provide a complete interface provides , which - like yours - does bounds checking. It also provides which does not. Thus, I'd hope for (expect) your class to provide this feature, too. Furthermore, I'd follow the terminology used by the standard for adding / removing elements here: (or ) and . Expose the allocator allows to use a different allocator than the standard one. You should expose this with your pool, too. That allows for object pools whose objects have automatic storage duration ("are on the stack") when used with such an allocator. 

As far as performance is concerned, there are no problems in this code. It's using C++ streams in the idiomatic way, which is good. If you're experiencing performance issues, you could try detaching from C streams at the start of your program: 

When you do this, you must then not mix C++ I/O (IO streams) with C I/O ( and friends) in your program, but mixing these is bad practice anyway. Here are some other comments to your code: 

You're overdoing it with comments. A lot. And trivial ones at that. Every programmer knows that creates a vector of pointers to , or that you have to use with pointers. Such comments are really just clutter and actually make the code harder to read. Save them for the non-obvious bits. It's unclear what protects. Does it protect ? Or ? Or both? This is one of the places where you should comment, but you didn't ( is absolutely pointless). If possible, rename the mutex to match its purpose. It would also be a good idea to wrap the mutex and the data it protects in a class, to ensure that unsafe access is impossible. requires the reader to parse it (and what's with the double parentheses?) The meaning of , on the other hand, is immediately obvious. And how does it create 4 threads? You could just as well rewrite the entire loop to make it more concise (and perhaps more efficient too): 

Also note that I added a call to into the waiting loop. Your previous code was leaking the threads. You're writing C++. Don't use (type unsafe!) C I/O. Do this instead: 

The same holds for all other uses of C I/O (, ), of course. and would be better declared with type , as they represent the number of some objects. If you have access to C++11, all the above could be simplified even further using range-based loops, lambdas in standard algorithms, or at the very least iterator-based loops. I didn't bother with iterators here (even though they could be used), because their type has to be spelled out explicitly. In such case, it would also make more sense not to allocate the threads dynamically, but create them directly in the vector. No need for manual deallocation, no dynamic allocation overhead. 

gives you a , then. Calculating a winner Instead of winding yourself up in some s I'd suggest a more data-driven approach: 

This constructor rings alarm bells, though. Here you accept a pointer to (probably) an array of s, but you have no idea how many you'll get neither give the caller any chance to tell you how many objects live behind that pointer. Sure we can expect people to be able to infer from the name that there are 16 s required, but it's a dangerous practice / API design nonetheless. You could also provide a constructor accepting a . Or an ( please) constructor accepting a . Don't break encapsulation in your factory functions In your factory () functions you (IMO) break encapsulation by directly accessing the underlying array. Better let the constructor do the work: 

BAAM! Undefined behavior due to signed integer overflow: After assigning the largest representable power of two, you do another which causes said overflow. lambdas ... Perhaps you don't want the "raw, unhidden" lambda there, but instead have names () for everything. Then, instead of writing structure templates ... how about this: 

is absolutely not ok! If your header needs some other (standard or non standard) header, then include it. Same for the implementation files: include all headers from which you reference something. Including the same header multiple times is not an issue if all headers have include guards. Call functions with their qualified name to avoid ADL surprises 

One thing that I think is very important but not yet addressed in the other answers is: naming and abstraction. Albeit your code is short, I have to look at it and think about what these loops are doing to understand what your code is supposed to do. It's much better if that's directly apparent from the identifiers (variable and function names). Speaking of functions, there's at least one functionality that I'd put into a separate function: printing a substring. 

The names and don't say anything about the variables' use. I had to read through most of your code to figure out what means. Always use descriptive names for your variables, at least for those whose value is supposed to persist for extended periods of time. I would be willing to accept the , as it is basically one-shot, but should be renamed at least to or or something more descriptive. Your looping and termination logic seems odd. You are using the correct construct , looping while there's valid input left. But then you have this block: 

This will cause the loop to terminate when a 0 is entered in the input. This behaviour does no match the assignment, and hence it represents a bug. Based on the assignment, you should only terminate when input ends, which will be correctly caught by the loop. The line should therefore be removed. Related, your after-loop test for is incorrect. If the loop is (correctly) terminated by being unable to read more numbers because the file has ended, both and will be set on . The condition will therefore fail. You might want to augment the condition to check for EOF: 

Here's the first functional version of my Python 2 script for processing comments in C++ source files. It's a personal project, I expect to expand it later with more advanced options (mainly about replacing comments with whitespace or marking their original positions in the comment-only output). It's also intended as a learning excercise. I am self-learned in Python, my primary language is C++. So the core of my question is whether the code is "Pythonic" and if not, how to improve on that. I don't want to "write C++ with a different syntax," I want to (learn to) write proper Python. I will of course also welcome any other comments (general style, efficiency, safety). 

I cannot provide an answer for this, as I'm not sure myself, but instead I leave a comment on two regarding your code: Don't break encapsulation 

Live example. Note that this may destructively modify the list argument. The helper function is defined as follows: 

performance related comments still under construction ;) Ok, I got a bit hooked up here, and I think I've got something usable out of it. I'm though not yet posting the code as it's late here and currently really a mess, so I'll tidy up tomorrow and post it then. Teaser (ignore the x-axis label): 

Note that our tests would have revealed this domain knowledge, too. Try the code without the condition and see which tests fail. Finally: Tests pass. Fine. I hope this is of potential use for you. (Ideone link with above code) 

naming isn't really a suitable name for a function that compares the lengths of two strings. comments 

Here's an ideone link to play with the above. Don't throw away useful information What if you add the very same twice? Do you want to be informed about this? Because if its added twice when you didn't intent to, this could help you find bugs. returns useful information, so why throw it away? Better make your return e.g. the returned by . Heavy copies ahead! The "new" syntax has its issues, IMO. Do you know that every time you run that (or any of the other) loop ... 

This is not directly applicable to above example, but ... Hide the initial value ... works nice with this, which should behave as you wanted (minus the default parameters): 

It's a "trick" that's fun to show once, but really don't use it. If you want to avoid the sequence of commands to compile, run and possibly delete, then write a shell function to do that for you. Global variable 

This type of information must go into comments. The next maintainer (which can be you in 6 moths' time) will need knowledge like this to understand the code. You should add specifications to your functions. They affect efficiency of some operations (like storing in a ), and since this is a very generic class, you should not limit its use in any way. An example for the assignment operator would be: 

looks like a rather arbitrary number for the default template argument for (it's actually a magic number). There is even no guarantee that 16 is a valid alignment value. I would probably choose something less arbitrary such as . There is no reason to use for the type of . You don't actually care about alignment of at all (which is emphasised by you passing to its parameter). All you need is a buffer of suitable size, and for this (or a ) would work just as well. As a side note, be aware that was only introduced in C++14. Visual Studio 2013 supports some C++14 bits, but using it makes your code non-C++11-compliant. You might want to swap the order of the data members, it might prevent need for padding between an oddly-sized and aligned . You might consider overloading the pointer operators and for your class as syntactic sugar for , it simplifies usage. Other generic classes which store a single object sometimes do so as well; an example is . 

You don't need to convert an object pointer to , a is sufficient for that. Don't use stronger casts than necessary. You can simplify the assignment to and make it more obvious by assigning the result of the placement-new into it: 

In some code I'm working on there is a (narrowing) conversion from to . The legacy code has some checks in place after the conversion is done to at least warn about values that could not be converted or whose conversion error is larger than some threshold (0.1 for example). Just for comparison: 

First, is not a descriptive name, and it's reused for (though only slightly) different behaviors. But, more "serious", neither of these functions actually does what it says: The first is not creating / making a "remove playlist duplicates" action, and neither is the second creating / making a "playlist path action". They are creating an action that takes (one or two) values from the parser, opens the first as a file, and then runs some given function with the file (and the remaining argument, for the second function). So, they're one the one hand far more general than their names try to tell, and on the other hand IMO they do "too much" by doing two unrelated things: one, feeding values from the parser to a custom function. Two, opening a file. Thus, I'd probably try to make a function that passes all values from the parser on to a custom function, and then either handle the file opening in the custom function(s) (probably not a good idea, DRY) or make a wrapper function that takes care of it. 

All in all there's not much to criticize. Be sure to fix the bugs mentioned in the other answer, though! 

Note that you could do similar tricks in the header file for and , but I'd advise against that as the benefit is minor compared to the issues that may arise if the used macros interfere with code including that header. Better keep ones macros behind closed doors ;) No pointers to arrays without a size or end, please