You can run two instances of sshd with different configurations. In an extreme case: Use one patched version (as this is probably not possible via the config file) which uses a different PAM string than ssh so that you can create different PAM configurations for both instances. Or you start one instance in chroot / lxc so that it sees a different PAM configuration. That might be easier (to maintain). The client selection can be done by iptables (DNAT) then. Just send the respective clients to the port of the second instance (or to the lxc IP). 

Not that I think it is a good idea to do that but for appending to a file a process needs write access to the file not to its directory. But I assume that Postfix is trying to do something different from what you expect... Edit 1: 

It does not matter which system gets this IP. You can give it to your gateway and use NAT internally, and you can give it to the server. In the second case the gateway needs to know where to route this IP to. 

The error message doesn't make much sense to me. SELinux is a possible explanation, though. You may have a closer look at what's happening by starting tcpdump through strace: 

That does not guarantee the exported disk(s) to contain only zeroes in their unwritten areas. Thus the kernel may detect something which isn't really there. You should overwrite the first part of the COW volume (I don't know how much is needed but the first 4 MiB should be enough. Oh, your COW volume isn't even 4 MiB in size: 

Deleting the files is not sufficient for protecting such data. You have to overwrite the files before deletion. For Linux there is a programm called . There is probably a lot of free programs of that kind available for Windows. Get one and tell it to wipe out . 

iptables is the right tool. You can create rules without a target. They just count packets then. And you can reset the counter of this rule (or at least of a chain). You just have to decide whether you want to count new connections or really all packets and place the rule accordingly (usually an ACCEPT rule for packets with status ESTABLISHED is at the beginning of the rule set). You need the switch to see the packet and byte counters: 

I have no idea what may be the problem but a useful next step might be to attach to the listening process (and its forks) with strace and have a look at what's going on when you try to connect. 

I suggest to adapt the script so that it uses one of two names for the same chain (makes sense to use a prefix), depending on how it is called. So instead of a chain dropthis there would be set0_dropthis or set1_dropthis. That way you could create the new set of rules without disturbing the traffic. After that the default chains would be flushed and recreated with the new set as target. Optimal would be to have just a single rule in each default chain which would just direct the traffic to the old or to the new set. Replacing this single rule would be fast (and even safe with ). After that the old set's chains would be flushed and deleted. A wrapper script would detect which set is currently active and call the real script with the respective parameter. 

Your tutorial refers to Grub (legacy Grub). This is Grub2. The line beginning with linux would be the kernel line in Grub. 

if you ensure via SGID bit that a newly created subdirectory belongs to the same group. I do not consider your decision not to create a new group a good idea. 

This can be part of the OpenVPN configuration so that the routing is set up automatically if the interface becomes available. 

You can automate this by using keys without passphrase but interrupted SSH connections are not restarted automatically. Thus it would be useful to make the SSH call from a loop. OpenVPN would be more useful though. Edit 1 If you want to forward other remote addresses than localhost don't forget to both put 

This would fail if there are files with ".matthew05012013" occurring twice in the name, once at the end. This is probably not the case and could be prevented by using another tool like mmv or a simple shell script. 

You could use instead of . Doesn't make a difference if nothing more than 10.45.13.0/27 is behind eth1. Interface names may change. But if later a subnet behind 10.45.13.0/27 is created then wouldn't work any more. On the other hand: In that case the routing on this system would have to be adapted anyway. So make your choice. Most important is that you remember what you have to adapt in case of changes to the network (or system hardware). Your main routing table defines how the system itself (locally generated packets) connects to the Internet. You may need a script that executed the commands every time the network subsystem is restarted. My experience with openSUSE is that a subsystem restart does not affect the settings. So these probably need be done only once after system boot. You can check the current rules by and the tables by . 

You probably want to use the advantages of the newer version (security fixes) Usually during a kernel update the module tree of the old kernel is removed. Thus if you (or some script) unload a module then the system cannot load it again because it finds only the newer one on disk (if at all) and this is compiled for a different kernel and thus cannot be loaded (at least usually). 

vnet* are the virtual interfaces of the VMs. You can configure their names (numbers) otherwise QEMU just counts them up. These virtual interfaces are bridged to either physical or virtual interfaces on the host. You can have a look at what the VM sees on that interface by 

As voretaq7 correctly points out: "something going drastically wrong with the server" includes the loss of the controller. So if you don't go the "official" desaster recovery way he suggests then it would make sense IMHO to copy the contents of the hardware RAID to a software RAID (so that you can easily add a second disk for mirroring while getting a replacement for the hardware). This means that the target disk must be a few sectors bigger than the source disk. And maybe the boot loader configuration cannot be simply copied; depends on your partitioning. But you can reinstall Grub on the backup disk before you need the backup disk. In that case you should ensure that both your controllers module and mdraid are part of your initrd. Just try to boot the backup disk after you're done. 

Usually this is simply done by access rights in the filesystem... (except for the visibility) OK, more detail: 

has all the information you need. You need the command and have to change so that tom is allowed to execute this without having to enter a passwort. is your key word. 

Not throwing all capacity in /dev/root was a goot idea IMHO. You can either extend (, ) the existing LV (and after that the file system in it) or create new ones (preferably). Use or (better) your distro's tool for that. And have a look at your disk partitioning: 

creates an entry (without IP) in . Of course, you could write a script or shell function which sets this value before each ssh call. Or you use a shell variable: