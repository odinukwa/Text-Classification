What you have there is a 4-channel comparator (LM339) circuit with 4 x 10 K resistors on the outputs (pull-ups, it seems), a capacitor, 4 x 10 K trim pots on the inputs and 5 indicator LEDs. The LM339 comparator is quite rugged and can operate within a voltage range of 2-36 volts. The limiting factors are the LEDs that probably require 3v3-5v volts and the Pi GPIOs that only operate at 3v3. 

The fact that you're also seeing "command not found" makes me wonder if it's more than a permission issue. It might refer to a missing linker, program interpreter or similar shared dependency - especially if you compiled the binary on a different system. First of all, I suggest you fix the permissions by typing . If that doesn't solve the issue, try showing the shared library dependencies by typing . If some of the paths printed don't exist, you could either transfer the files from another machine or recompile the binary on your target platform. 

This will run every minute (that's what does) and write to a file called in the user 's home directory. The first column of each entry is the Unix epoch (seconds elapsed since 1970) which will be useful if you want to use the logs in programs, the second column is the date and time in a human-readable format and the third column has the uptime (time since shutdown/reboot, number of logged in users and average system load). All columns are separated by a pipe sign for easy parsing. Contents of after a few minutes: 

The first three bullet points mainly apply to a running Pi (they're software-configurable) but the last two, the voltage level and the pin impedance, are always important since the Pi's GPIOs are not 5v tolerant and since the impedance will determine how much current can flow into the Pi. When the Pi is running, a pin that's configured as an output and set to a high state will attempt to supply all the current it possibly can to whatever you connect. If you're lucky, you've connected it to a high impedance input (or you've added a resistor) and nothing will happen; if you're unlucky, you've connected it to a low impedance/resistance input or a ground connection and it'll fry. The only connections that can be ruled out upfront are the ground to ground connections; providing that the ground potentials of the Pi and the screen are the same, these should be safe. Anyway, since your Pi wasn't powered, it's more likely that it acted as a current sink - allowing the screen to find alternative routes to ground. I don't have a Pi and multimeter at hand right now but if an un-powered Pi pin has a low impedance/resistance, connecting a power source directly to it could easily create a path to ground that would allow hundreds of mAs to go through the pin - add to that the over-voltage and you have two serious issues. The data lines (SCL, SDA, etc.) might also be problematic but I think the 5v screen connection is the most likely candidate. I've highlighted some of these connections below and added brief explanations. 

Lord have mercy! :D No, you can't - or, that is, you shouldn't. Chances are you'll break the solder joints or actually snap the Pi's PCB in the process. Simply get a bunch of male-to-female Dupont wires for less than $1 instead. You'll need them at some point anyway and it's a cheaper option than buying from those Western shops that just resell Shenzen goods at 5 times the original price. 

As Phil B mentioned in the comments, there are two types of relays: normally open and normally closed. Open means "connection broken" and closed means the opposite. Adding to that, there are two "trigger" types: active high and active low. Active high means that writing a logical high activates the thing (akin to NPN/PNP transistors). It seems OP's relay module is normally open and active low. See the picture below for the explanation of why it's active low in this case. 

It essentially tells the system where to send your window in case you're not starting the process manually/from terminal. You can see the number of your display by typing in terminal: 

The absolute maximum current on the output channels of the LM339 is 18 mA. At 3v3, this means that the minimum required resistance to keep the LM339 safe is 183 ohm. Practically speaking, anything in the 680-4.7K is fine. Digital GPIOs are voltage driven, not current driven, so you might find that it still works with something ridiculously high like 100 K. Anyway, when in doubt, start out (too) high and reduce resistance until the thing works. More practical still, just use 4 x 1 K resistors from Pi GPIOs to board input - always a safe bet providing you keep the voltage at 3v3. 

Actual, factual random number generation - none of that pseudo-random mumbo jumbo we have to live with on our laptops* :) Plus all the stuff that's already been mentioned like GPIO, saving power/space, of course. *As mentioned in the comments by @scruss (who happens to be the owner of the blog I'm linking to above), modern intel CPUs also have a hardware random number generator. That being said, the developers of the BSD distros have chosen to not rely on this feature due to concerns about its integrity and a potential compromise. Either way, as alluded to by @edo1 in the comments, distrusting one manufacturer (in this case intel) should not automatically increase one's trust in the competitor (Broadcom). Build your own RNG if you're into that sort of thing and don't forget to thoroughly test your output if you want to use it for cryptography. 

Maybe, maybe not. The fact that it has male pins on the board suggests that you can but it's hard to tell how much thought went into making the thing. I wasn't able to find anything about internal resistors in the LM339 data-sheet so I don't think it has any. On your board, I only see the 10 k pull-up resistors - these won't burn up a large enough share of the current to save the Pi in case of over-current (their purpose is to ensure a clean, active low signal). I'd measure it with a multimeter/ampmeter or check if it burns out an LED that's connected directly without resistors. 

Thus, the python code is working fine, the relay is working, nothing's broken but it just works with a counter-intuitive logic. Beware that there might be safety issues associated with normally closed relays since they will turn on if the controlling circuit is removed; i.e. don't use normally closed relays for your boiler/water heater/nuclear reactor. To invert the logic, one can turn on/off the relay by cutting it's ground connection using a transistor + flyback diode instead. 

Disclaimer: I'm no electrical engineer; just a nerd who's seen plenty of components go up in smoke - including a Pi! 

The Unix/shell/bash way Did you know that there is actually a shell command called that will give you this information? Type in your terminal and you'll see something like this: 

I'm no bash ninja but I just wrote this and it seems to work. Edit the cron entry line and the wget command as needed. Add everything to a shell script and run it. 

The python way Writing the path as will most likely write to the root directory. This normally gives a permission error, so I suspect you're running your script with . Anyway, there's no need for it unless you're doing something "privileged" elsewhere in the script than we don't know about. Change to if is your username or make a folder in for the logs. using actually eliminates the need for closing the file afterwards - it's done automatically. However, you shouldn't nest your sleep routine under the statement. using the option in will append to the file or create it if it doesn't exist. I think these lines do nothing and should be removed: