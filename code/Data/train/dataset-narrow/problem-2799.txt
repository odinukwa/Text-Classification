Genetic Algorithms are usually used to solve a known problem where you can define the environment through rules. Then you can create data sets that represent different properties that affect how things react to the rules. The computer then plays a 'round' with the initial data set, selects the top X number, mixes their values after pairing them together and does another round.. A common example of this is 'breeding a better troll' (doing the breeding to find a set of values where the troll generally does very well in its environment (Is able to hunt and eat, either kill or stay away from villagers, can collect loot and amass all the shiny objects it desires, etc). I am just not sure what you are trying to accomplish is applicable in the realm of terrain generation. The only thing I can come up with would be game content sorts of evaluations where you did not want to plan out a world but wanted to make one that AI pathing can be calculated in nicely or something like that. Even with this however you are looking for a single or at the least limited set of worlds. 

You look to be on the right track to me with your last set of questions. I would suggest first and foremost that you scale the position but not nessecarily the size of the HUD elements. That way when you rotate your device or simply change the resolution the elements look the same but are positioned properly. Next up I would take a look at how many rendering iPhone/iPad games actually support horizontal and vertical rotation modes. I would say hands down they almost all support only one or the other and additionally, rarely rotate to even the alternate (180 degrees) positioning that would keep the same resolution. Lastly, to address the quality issue, this should kind of go away if you only scale positional information. What may come up however is visual clarity. And while this can lead back to quality I am just attempting to focus on the fact that if they scale the resolution very high, the HUD elements may appear so small as to be unreadable. Alternately if they scale the resolution down alot and then you can see nothing but the HUD. My suggestion for solutions to this is to develop a more advanced set of HUD elements since it sounds like you are doing one quad per element. If you could make a button up out of 9 background pieces and a text rendering on top of it it may take care of most of your issues as then you could scale the size of the hud or offer hud sizing options to the end user. You break apart the button's background into the top left corner the top bar the top right corner the left border the central background the right border the bottom left corner the central bottom border and finally the bottom right corner. In this manner you scale the size of the object (and likely the text) but not the texture, you let the corners remain the same size and the borders be the same height for horizontal ones and width for vertical ones so the texture can repeat along the edges. Same for the background section which I would suggest even just making a solid color. Anywho, like I said you look to be in the right direction. Hope this helps. 

Technically, this should be a fairly easy thing to do. Not as easy as the list of steps you had up at the top, but pretty close. This is only because that the underlying hardware compatibility between the different environments (PC and PS3 are the ones in the example) are to be provided via the Unreal 3 engine from Epic. They tout that they have already done a significant amount of the work, knowing where to do the visual effects on the PS3 vs where they are done on the PC and the like. Writing an independent API for playing sound effects that either gracefully downgrades or has parallels for the different effects that can be done. Now, If you are wanting to know how much work and effort it takes for a team to port their engine to another platform, then I refer you to Patrick Hughes' post as that starts to go into more detail there. However, I do believe you will find that one of the selling points of the Unreal 3 engine is multiple platform support. On a side note.. if you go back to the announcement videos for the PS Vita (was that really last summer?) you can see an clip talking to the team behind Dungeon Defenders where they state it took them about a week to tweak their game to get it running on the PS Vita.. Of note, their game happens to run on the Unreal 3 Engine (and has already been released on iOS, Android and PC I believe... I own the iOS and PC versions at the least :)) 

Hey again NotBad, lets see if I can give you a hand again :) 1) EDITED. If you have alot of common components then pre-making a set of them could be very helpful in increasing the speed of creation and deletion. In previous component systems I have used all of the components were tied together with a single ID for example. So to 'allocate' a component to a specific object you would just give it the id of the object it belonged to. To 'deallocate' the object you would remove the id or set it to -1 or some other value to mark it as Unused. This way you only ever allocate memory on startup or when you run out and need to make another handful of a specific type. Deallocating would basically only be done at the end of the game's runtime.. You would eventually want to put in some sort of balancing routine that if you have say 15 unused components in a pool of 30 of that type that it dumps a certain number of them down or the like.. What you DO have to be careful of with this setup though is memory fragmentation.. If you are working within a managed system this should not be a concern, but just in case you are not be aware of that. Hope this helps answer the question a little better :) 2) As eluded to in the first one, you may want to include default values in the templates, this would set up their initial values when they are created (Read in a component, add it to the object in whatever tethering method you are using for your component system and then give it the values supplied by the teamplate). If I recall you are using Lua in here. If the object is represented in Lua after you call the sample CreateEntity() method you may want to return a Lua object that represents the object (even if in C/C++ it is just unified by Id). You could then just set the values directly via the object reference. This may be a bit more work in translation and such between the two systems but I can almost guarantee the payoff will be there in the long run. 3) EDITED. All in all some of the slowest execution speed in what you are doing here is going to be memory allocation. Having a good method as touched upon in the first answer can be key to this. Using a pooling system as described above can be very nice especially in a component system.. if you have a component that moves entities then you can use the same one for a positional sound effect, a particle effect, a player character, etc.. All it does is hold a position and functions for movements. Reuse-ability of component based systems along with their wide instead of tall structure a just a few of the benifits you can get :) For example, the engine I was working in professionally a few years ago was capped to say 100 objects for an entire level, I made a pooling/spawning system to make it 100 objects at a time.. now a PSP can not render that many objects at once, but it freed up the designers to really go wild and make the levels more interactable :) Back on topic, if you can allocate and deallocate all your memory on 'loading' screens (Yes, giving away knowledge that generally the first thing done on Loading screens in games is Unloading data) you will have much smoother game play sessions. So again, hope I have helped as much as I thought I did on your first set of questions and good luck!