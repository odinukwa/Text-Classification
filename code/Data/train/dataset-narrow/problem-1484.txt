Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

This is easily handled with a simple function that checks for a potential error instead of triggering an error. Code first, and then an explanation: 

The only difference between the two is that the second is at least explicit about wanting a variant. The first is implicit. First bit of advice avoid implicit commands as much as possible. The reason for this is quite simple, there is a tendency to think that the computer is magically doing something it shouldnt be, but really you told it to do exactly what it is doing and as a result, you have a bug that can be nearly invisible. Consider for example : 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

If is a for example, you will get a error when trying to assign to (the names here are troubling as well). Let's explicitly raise an error if someone passes a value we don't currently support: 

I am certainly not an expert on naming conventions, so find what works for you. Definitely be mindful of what your names tell your 'reader' though. The other point worth noting here is how you have names that are inconsistent: 

The code below is in two parts. I have pasted code with your old code commented out, and then additional comments for clarity. I have also posted a cleaner version with just comments. Note: From reading the code, it likely wont run properly. I was unable to figure out exactly what your loop is doing, and as a result there are still some bugs. Be sure to fully debug this code before using it. Full Version 

I made some changes to improve your code overall. This wont improve performance, but these changes are worth noting nonetheless: 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

That was the first step I took in making your code make a little bit more sense. By extracting the two loops, and the dimension check, the main routine becomes much cleaner, and gets to rely on a few s to do the work it needs to do. The beauty of this is that your code now explicitly says what it is doing (anyone could read the code, regardless of whether they have been coding for days or years). The next step I took was explicitly checking for the supported types. For example: 

Finally, making these few small changes has a huge impact on the readability/maintainability of the code. Here is the finished product (identical in function): 

And it is now a range reference (the only difference being the keyword). While it is easy to read the code and determine what is happening for us, you will inevitably lose a bug in there that you will have to search for. Option Explicit to the Rescue! is one of the best things in VBA. It is truly simple, but it makes the simplest of bugs super simple to prevent (and even simpler to find). With at the top of a module, the compiler will throw an error when a variable isnt declared. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

Lazy Version It's possible to build a tree in a tail-recursive manner. It's much more difficult to do that with the references to the parent node. So I cheated by making it a lazy data structure instead. The first version was pretty basic. 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

Principle of Least Surprise So far we haven't changed how the method actually works. In the possibilities you mentioned for how to handle a failure to close you missed the most important option: mimic the behavior of the Java try-with-resources block. This is important for two reasons: the first is that it's a pretty sane way of handling this case, the second is that it will be the behavior expected by anyone coming from a Java background. Acting in an intuitive manner is a very powerful thing. Java handles failures to close in this manner: 

This would then be called by creating a new instance of the class, and then usually by calling the 'Add_TableItem' routine. EDIT: As a side note, I am a super noob when it comes to classes. I know the basic ideas about how they work, but when it comes to terms like immutable, or encapsulation, etc I have no clue what I am doing. I have been working on improving my class knowledge, but putting it into practice is the more difficult part. EDIT: Very simple example of the kind of data that would be loaded in and used (the tables usually are about 100-200 columns with 30k-60k rows): 

Initial Notes The first thing that struck me about your code was that you literally have no variable declarations. Lines like : 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

Use existing functions/code where possible. This not only reduces the risk of bugs, but it can, at times, be more efficient. For example, denotes a and can be used instead of introducing an entirely new variable. This also makes your code easy to read. When I, as a reader, see I know what it is, whereas if I see I have to look for its meaning. Indent your code properly. I don't think this point can be over-stressed yet it doesn't always sink in properly. If you ever have code that is touching the window, aside from the Sub/Function declarations and Line Labels, something is wrong. For example: 

It seems weird that in the login would return multiple rows. I would expect only one user to be associated with a particular emails/password login. In your controller you have duplicated this code three times: 

As mentioned by @svick you should seriously consider using which was added in .NET 4.0. You can increase the practical usefulness immediately by doing two simple things 

Maybe it's a result of your simplification for the example but your looks like an over-engineered enum to me. What do you gain from it over using an and a for the current state? In general whenever you need to check for the specific type in order to execute some specific logic then your abstraction is probably flawed from an OO point of view. One design I've chosen in the past for more complicated parser is to have the state execute the transition. Something along these lines (does not compile just showing the idea): 

Also you create on every loop iteration (which is number of iterations). It's possible that either the compiler or the JIT can optimize it but I'd consider extracting it out of the loop and store it in a variable. In the next loop here: 

It has also the advantage that the application code doesn't have to know what menus exist so they could easily come from a database or other configuration file. When adding a new menu no code has to change. Example implementation could be: 

I've been thinking this over for a while now and I'm pretty sure you're not implementing Dijkstra's algorithm (which is the shortest path between two nodes in a graph). It looks like you're computing a minimum spanning tree (set of edges connecting all nodes with minimal cost). Some additional remarks: 

I would move the inner loop which loads the texture into the class as well as moving the texture loading for the single sprite into the class: 

If you have multiple threads adding to it then you need to add some locking in the - but then on the other hand itself is not thread-safe so I assume that's not the case. In .NET 4.0 and later you have which will make the code a little bit shorter. 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

You've got a nice idea, planning for extensibility. There is one issue that I see with the way you've implemented it. 

This sacrifices quite a bit of functionality to pull this off, mainly because of my preference for s. To add the ability to add/remove child nodes, I went with a view instead. This way the data itself stays the same, just our view of it changes. I also added a helper to provide depth-first traversal, to abstract away doing things with the nodes in the tree.