However, neither are particularly large differences. We can refactor further if we extract the following method: 

Given how they were used, I made the (perhaps incorrect) assumption that your ValidationTypes and ValidationFields types are enums. If this is incorrect, feel free to substitute the _.ToString values back in. The validation method could go as follows: 

Given the update... Since you have a stated requirement of showing properties which do not exist in the collection anyways, then why bother adding entries for properties you want to show at all? I would only build a collection of the ignored properties, and then check if the collection contains the property during filtering. As such, that check instead turns into a (if still using an IDictionary) or (for any other collection type). I would also suggest using a simpler collection like or a string array, because the set of ignored properties seems to be really small (only one in your example). The performance of dictionary lookup versus list traversal will be insignificant at that size, and it seems more natural to have a collection of names than name/(unused) pairs. 

Sadly, creating parameters is particularly painful using just IDbCommand, so I continued using the SqlParameterCollection members. Additional questions/considerations: 

If possible, though, an even better way of doing it would be to extract your telemetry names to some numerical ID and use enums or ints. Number comparison will be far quicker than string comparison. However, you state that your input names are superstrings of those appearing in your lists, so I don't know if that is feasible. 

The next thing I see is that you have several discrete properties to store different types of hours, but you are using a dictionary to do the same thing. You could just as easily add directly to the properties, or with some method extraction, you could perform a in your LINQ. Another thing I see is that you are hard-coding the year to be the current year. I would instead pass that as a parameter. Sure, the 99% case is that you are going to ask for the current year, but it is trivial to parameterize that, and you'll be glad you did if you ever have to get the values for not-this-year. The last major thing I see is two-fold: 

That consistently took around 21 seconds to populate the grid. To eliminate the possibility that the largest slowdown factor was loading from the file one line at a time, I produced a similar method which loads the entire file up front, then used a StringReader in place of the StreamReader inside the loop: 

Since you're using nUnit, you could actually break them out into separate tests by utilizing the TestCase attribute more effectively: 

We are then left with handling the actual file, which I split off into a different method. The only notable differences is that I changed the input to be a FileInfo type rather than string, since I already have the FileInfo object from the calling method's loop. Running your method versus the modified version on my folder cut the time consistently between 1/4 to 1/2 the time of the original, though my sample size is far too small to be conclusive. I would advise benchmarking it yourself, though. It is possible that the performance characteristics change wildly based upon the folder structure, depth, and ratio of directories to files. 

Pay Calculation The calculation step is now a simple matter of enumerating your providers and calling : 

One thing I noticed at a glance is that the main window code-behind is doing a lot of work that isn't really UI-focused. For example, the code to handle loading plugins from external DLLs is not something I would expect a Window subclass to do. I would highly recommend restructuring the application to utilize pattern that helps you to break things up into more single-purpose classes. A good example of a pattern that I use often is Model-View-Presenter, or MVP. A more common pattern in WPF projects is Model-View-ViewModel, or MVVM. The separation of view logic from business logic makes the application more modular, allowing you to swap out components more easily. For example, if you decide later that a different UI technology (e.g., HTML/Javascript Metro) is more to your liking, you just need to swap out the view. 

Even better would be a way to map data objects from the database code to XML. Normally, this is where I might suggest System.Runtime.Serialization.DataContractSerializer, but it does not support attributes :( Unused Code I ran across a number of variables which are not used or assigned and then never read. Some examples include and . I cannot ascertain whether they should be removed or if the code meant to use them has yet to be added. Constants Most of the string literals in the code appear to be good candidates for constant values rather than local string variables. Boxing There are a few places where unnecessary boxing occurs. Specifically, the ArrayList used to store report servers and the DataSet used to store the second query result will both box values. The former can be easily replaced with a List, which also eliminates the need to perform the ToArray call. The latter is taken care of by changing the database code to use something other than a SqlDataAdapter (see above). 

It should be pretty clear that is going to be much larger than 16 bytes. One of the reasons this is a concern is that structs are stored on the stack. The default .NET thread stack size is 1MB, so in an extreme case, a struct which is too large could get you a StackOverflowException without any recursion required. 

With those changes, we can refactor our seeded encrypt and decrypt methods to call the above method, changing the class as follows: 

I would first suggest logging the database operation to see what SQL is executed. EF may not be running the SQL you think it is. The red flag I see is that you call ToList before the Skip and Take. Generally in LINQ statements, ToList forces execution immediately. This suggests your EF code is pulling every record from the table up front, building a list, and then applying the Skip/Take to the list. If that's the case, the logged SQL should show a select statement without any filtering. I suspect what you really want to do is run the ToList after the Skip and Take. This should apply the filtering inside the executed SQL, but the logging will show you for sure. 

Since it looks like you are just trying to find the intersection of a known set of keys and those present in the table/column, you could just use LINQ's method. To facilitate this, I would probably pull the list of keys out to a "constant" field. Additionally, unless necessary to return a , as Heslacher suggests, I would return . 

Implement IEquatable<T> Generally speaking, whenever I find myself writing overrides for and , I also make the type implement . It's generally pretty easy to do so by calling the method from the override: 

Without knowing your domain, I just threw in placeholders for illustration purposes. Data Binding If your list of providers is fixed, you can bind any to the grid. However, in the more likely case you want to allow adding new providers, I suggest instantiating and binding to a . I would then add a BindingSource to your form which points to the type, then set the property of the grid to the binding source, and tweak your columns to look how you like. In your code-behind, you will set the property on this BindingSource to your collection of providers. The field required a little extra care. In this case, you want to set up the column as a . Once you do that, you want to supply the possible list of values for to the column so the drop-down works as expected. This can be done easily with : 

Move all the OpenFileDialog setup to the designer file. This will make it a field rather than local variable, preventing unnecessary object creation when a user clicks Add multiple times. Additionally, it will wire-up the proper Dispose call for you. Take the code for opening the files and put it into a separate method. Split off your worker event handlers into class methods rather than anonymous methods, better separating out method responsibilities. 

Since you mentioned in the comments that you want the union of the two lists, you could perform a LINQ . There are a few ways to do it: Use If you go with the simpler overload for , you need to implement and override on . For simplicity, my example will look only at the Value property: 

Since I switched to use DirectoryInfo, I went ahead and made two overloads of the RecursiveSearch method. One takes in the string for the initial search, but sub-directories can call the overload which takes in DirectoryInfo directly. The first allows you to make the change without breaking your interface, while the second is more useful during processing work. For speed, I pushed the try/catch up here and left out exception handling elsewhere, though you may want to add some at the lower level methods, if only to provide more descriptive logging/exception messages. 

Test/implement first. Implement the code you need (which will likely go into ) in your method now, imeplement/test next, and refactor it to use the method later. 

Additionally, instead of using , I always tend towards , as it is much more explicit about intent. could easily be a mistake, but is clear that you really do want an empty string. You can then output your result as follows: 

Since we retrieve the enum values themselves rather than casting to int up front, we can eliminate the Enum.GetName calls. Passing an enum value into a string format will use the name for us (see: Enum.ToString()). In case you are hesitant to assume sorting up-front, it's pretty trivial to toss a call to just before the in our first LINQ statement. However, if you're going to order the list, it would be simpler to sort descending and skip the first (max) value, so we can drop the : 

If you call the method, it returns all directories and files in one call. The upside is that it reduces the calls to the filesystem, which are generally going to be your bottleneck. The downside is that you get a base type back, so some type handling may be necessary.