ARP is a protocol (that's redundant, Address Resolution Protocol is, of course, a protocol) and the result of the protocol is to populate an ARP table in the devices. So, the answer to your question of "How to update arp table" is to use the ARP protocol. Any device that needs to speak IP on an Ethernet needs to participate in ARP. 

First note that all of these technical terms are subject to distortion by Marketing, so sometimes you have to read between the lines. The term switch refers to a layer-2 device, so it is forwarding on layer-2 info. On an Ethernet this would be the 48 bit MAC. With MPLS it would be the Label. The term router officially refers to a layer-3 device, so it is forwarding on layer-3 info (the 32/128 bit IPv[46] address, unless you have a very strange network). That's the primary difference between the terms. How each device actually implements that forwarding is partly controlled by the protocols defined to exchange the relevant data, and the engineering choices made by the device designer, and is mostly opaque to the outside. So, to get more detail on how a particular product does it's thing, you need to get more detail from the manufacturer than the legal department wants them to divulge, so under NDA (Non-Disclosure Agreement). Unless the device you care about is just a general purpose computer running Free or Open Source Software, in which case, you look at the source. 

If you really want to explore the topic for measuring optimizing TCP perfromance I'd recommend to read RFC-6349 

You can attach cisco switch with two PCs behind the router. Dot1q trunking can be used with 1 vlan per PC for traffic generation and second one for SLA probes. The router must be used for inter-vlan routing, traffic shaping also should be configured here. IPERF/JPERF can be used for traffic generation. On both switch ports you can mark the traffic with specific DSCP value, which needs to be used later in the policy. Speed can be easily measured with IPERF: 

I have personally done that ARP timeout set to 60 sec for a single VLAN caused 0.05% ARP usage on cisco 29XX series. It is running like that for over a month. No problems at all. Still I'd not recommend using the network for solving clustering problems. 

More specific match is always going to be selected, so all the traffic will go to 234. You can't control how other ASNs are going to do their routing. If they decide to announce more specific static via redistribution then all the traffic will use it. However in normal situation ISP is not going to use static routes for subnet which is not part of their address space. 

Yes, this is exactly what the routing code in a router is doing when you use an SPF routing protocol. So, for your own network, if you are running an SPF protocol on it, you could run a suitably configured routing daemon on a host that supports it (say Linux). You need to be very careful that it only listens to the protocol and does not advertise any connectivity, lest you break your entire network (by creating what's poetically called a routing black hole). Then you can interrogate the link state database in that daemon to see this. If you are not running an SPF protocol, but rather a DV protocol, then you need a way of extracting the DV data from each and every one of your routers. It would then have to run something like an SPF algorithm over all that to get what you want. I don't know of any OTS technology for this, I rolled my own 30 years ago that used a special protocol that ran on our routers to get that DV data. And, finally, if this is not your network, the owners of the network probably consider that information proprietary and getting access to it can involve (gosh) lawyers. 

3) If you issue the boot command and the result is in a successful bootup, either the default switch> prompt or the hostname> prompt displays 4) If you issue the boot command and the command does not result in a successful bootup, either the switch: prompt displays or you are stuck in a continuous reboot again. The only option to recover the switch is an Xmodem file transfer 

The thing is that you have an MPLS network in the middle of your traceroute. Actually results from traceroute are not really accurate when it comes to MPLS environment. What happens is that all ICMP TTL exceeded messages originated by a P device first have to be tunneled to the other edge using the original label stack before being sent back to the originator of traceroute operation. Therefore, you will always see end-to-end RTT across the provider core in the output. You need to trace from PE router toward a provider-scoped IP address to resolve this "layering" problem and observe proper RTT. NOTE: DNS resolving is correctly configured. 

Just think about it. When the IPv4 protocol was originally documented, it specified a 32 bit field for addresses. As soon as that spec was published (in September of 1981), there were 2^32 (about 4 billion) Internet addresses. The Internet community needed some way to arbitrate their use, so IANA was created (well actually Jon voluntered, and everyone else said "good, I don't want to do that"). How the space is used in a general way is set by the IETF (carving out the blocks for multicast, for example), but otherwise Jon (as the original IANA) started keeping a list and handing out addresses (originally Class A, B, and C later arbitrary prefixes). When the net grew and the job became too big for a single central authority, the regional registries came in as an intermediate level. And later, the job of doing the IANA record keeping was turned over to ICANN. But that original set of addresses from 1981 is all there is or ever will be. That's why we are running out. The Internet was a much bigger success than anyone in 1981 could have imagined. 

Normally the router will periodically send a membership query to destination 224.0.0.1 (all hosts multicast group address). Hosts that receive this message will respond with a IGMP membership report to tell the router that they are still interested in receiving the multicast traffic. When the router receives the membership report, itâ€™s expiry timer will be refreshed. Expiration can happen due to 2 reasons: 

Most probably you have an application issue on the server listening to the traffic and it is not sending IGMP messages correctly. You can solve the problem by adding ip igmp static group to the outgoing interface. 

RSTP protocol which is now widely implemented is sending BPDUs only on designated ports. Those 9 are sent during convergence activity in the past. 

You can add ip flow ingress/ip flow egress under the interface (Ethernet0 in your case). This will enable NETFLOW caching of the traffic passing through that link. No worries no risk involved. After that you can execute show ip cache-flow and you will see all the packets passing through that interface. Most probably the rest of the devices have more specific routing and default gateway is not used at all. 

If your DHCP and DNS servers both implement DDNS (that's Dynamic [updates] to DNS, I know ISC's Open Source servers do this, and I'm sure there are several others), you can have the DHCP server update the DNS each time it gives out a lease. If you do that right, the name each system wants will be registered in the DNS. Notice that there are some complications if more than one device wants the same name. They are usually first come first serve, unless overridden in the server config. 

When TCP/IP first came out and got widespread, there were actually a lot of subnets with non-contiguous masks. But as addresses became scarce, the overhead to the rest of the net to allow global routing of these prefixes rather than forcing everything to be only prefix based; was too much and the global network changed to only supporting prefixes. There may actually still be legacy networks that use non-contiguous masks internally (many IGPs support this, still). But, when such a network connects to The Internet, it has a single prefix that covers all of them, that it advertises into BGP. And, of course, EGP (the predecessor to BGP) only supported Classful addressing. I know several players with original issue Class A networks that used non-contiguous netmasks internally for one reason or another. I just don't know if any of them are still doing it. A lot of them don't even exit any more. The ARPAnet had an internal netmask of 255.0.0.255 (IIRC). 

When the routers on either end of a BGP session first boot, the session between them is in the Idle state. The BGP session remains idle until a start event is detected. Typically, the start event is the configuration of a new BGP session or the resetting of an existing BGP session. At boot time, the start event is generated by the router as the BGP session is initiated. After it detects a start event, the BGP host sends TCP request packets to its configured BGP neighbors. These packets are directed only to neighboring interfaces that have been explicitly configured as BGP neighbors. Upon receipt of the TCP request packet, the neighboring host generates a TCP response to complete the three-way handshake and establish a TCP connection between the peers. While this handshake is taking place, the BGP state for the connection is Connect. If a TCP timeout occurs while the originating host is waiting for a TCP response packet, the BGP state for the connection is Active. The Active state indicates that the router is actively listening for a TCP response and the TCP retry timer has been initiated. Once a TCP connection has been established between both ends of a BGP session, the BGP session state is OpenSent, indicating that the originating router has generated an open message. The open message is an initial BGP handshake that must occur before any route advertisement can take place. Upon receipt of the open message, the neighboring router generates a keepalive message. Receipt of the keepalive message establishes a point-to-point connection, and the BGP session state transitions to Established. While the originating host waits for the keepalive response packet, the BGP session state is OpenConfirm. Source of the information 

The OSI network layers model is just that, a model. Specific instantiations may fit better or worse. Note also that the TCP/IP protocol suite was designed before the OSI model and so the match may often be even more tenuous. But, one of the features of the model is that there are interfaces between the layers, and when you map TCP/IP onto the OSI model part of the interface between the layers 2 through 4 includes communicating the values that go into the MTU/MSS calculations. The upper layers don't have to get this data and can operate without it, but they can operate so much more efficiently if they have it. 

Your firewall is telling you it detected a bogus TCP packet. The reason it reports these is because they might be used by bad guys to try and set up a covert channel. In this specific case the TCP fault is the use of URG (this is seldom used in TCP in practice, but is sent to tell the receiving TCP to urgently skip ahead to some point), but the point it's being told to skip ahead to is not actually in the subject packet.