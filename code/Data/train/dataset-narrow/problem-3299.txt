They are emulated watchdogs, done in software using software timing techniques. Based on the way the library is written, there is little chance of conflict. If two pins experience a level change at the same time, and are detected in the same thread cycle, their callbacks will be executed in some arbitrary order, so if they have side-effects that impact each other, there may be a conflict in this way. There is a chance, if your callback is particularly heavy, that you will experience significant system load if they are regularly triggered. 

The Raspbian Approach is as follows, I would duplicate this approach. provides a resize script that uses (a command line utility) to resize the filesystem on boot. This script is located in 

This looks like a part for a particular application/customer. If you don't need the independent references you may find others devices easier to use. You have a few options to pursue for prototype, but in the professional world you would use a microcontroller or ASIC that support SPI Dual Mode Interleave Channels Use the ADC at twice the sampling rate you were planning to, and use a (switch) to feed either or to the SPI Receiver. You can attach the MUX control to pins. Doing it in such a way, in software you would use for Channel A and for Channel B, sampling is done Shift Register (UART) You can use shift registers attached to and to clock in the sampled data and read out as parallel GPIO (28 bits - 2x14). In this scenario, is connected to Shift register and ADC, connected to shift registers. Your Controller only acts as a clock source and driver This will require making sure that SDO data is stable when you clock the shift register, otherwise you will miss bits. You may need to invert the clock signal to the shift register. This can be done in a way that does not slow down the throughput of the ADC. Independent Sampling Controller You can commandeer a pair of small micro-controllers to sample SPI Data for you, this is a fancier version of the UART Solution. Sampling controllers can do some basic pre-processing and data buffering as well. These sampling controllers could potentially be small 8-bit MCU's like the . If you can find a micro-controller that supports Dual SPI this would be a clean solution 

There is a coding tutorial here which demonstrates a full duplex client for jackd. Full duplex means recording in and playing out at the same time. By using a full duplex client, you can process the input and output as required. There are also links there for suitable cards with inbuilt microphones. The lowest latency you can probably get is around 1ms in and out (say 50 samples at 48 kHz). You will probably want to target around 3ms latency before the performer starts to feel uncomfortable with latency ... but you can probably push that a little. That set of audio programming tutorials also demonstrate how to open, read and write almost any type of audio file. The base library used is SoX which has the capability to load and save many different audio formats. For that reason you can pretty much pick and choose any audio format you like. If you want lossless audio, then something like wav, flac or other will do. To bring your processing needs down, as you are using voice, work out the upper frequency which are in your files and drop the sample rate to double that frequency. For example, if there isn't much audio data above 12 kHz, you can drop your sample rate to 24 kHz and save a huge amount on processing requirements. Consider that the first formant of singing is probably between 2kHz and 200 Hz, which means that the third formant may not be much above 8 kHz. Because you are talking about vocalised sounds, you aren't too concerned with consonants and consequently the high frequencies are not going to be present. It may be different for your recorded instruments. If you can push your sample rate down, then you can probably get better latencies. Do you have enough memory to load an entire set of chords into memory ? If so then extra delays/computation in file loading and waiting can be removed. 

, in C, only allows jumps to labels in the same function. So you will not be able to do that. Even if you could it would be a bad idea, Interrupt Handlers must return from their function to end the interrupt, a GOTO is not a function call You can in principle call the redraw method directly, however this will have the side-effect that you describe - multiple interrupts may "clobber" each other or some other system thrashing. Interrupt handler should be as small as possible, In this case a simple handler would 

Yes, absolutely possible. However, it must be a switching mode DC-DC converter, linear regulators like the hearty have too much loss for this application 

Bit-Masking For an explanation see: $URL$ If we assume that the ZYXDR is then we construct a mask in python by defining a binary literal, then we use the bitwise-and (python wiki) to extract that bit of data. 

What @Dr.Rabbit is referring to is a ressetable fuse that is used to protect from short circuit. This can be seen here as component . The net shows ups at the right of the schematic 

Messing with SPI/I2C extenders for those distances is going to be an unreliable monster. Instead Consider the Following alternatives. Kelvin Sensing Using basic 4-wire (Kelvin) sensing you should be able to reliably measure a 0.01V in a 5V FullScale (1 Part per 500 aka ~9 Bits) with a remote differential ADC. This is likely sufficient for your application. The principle is that there is no current flowing on the wires going to the ADC's, no current = no voltage drop in the cable = no effect from the cable impedance. This is a reasonable assumption for cable impedances and slow signals (~1KHz) with software averaging. 

You can control the audio device using the alsamixer command. If you want complete command line control, you can control the alsa mixer using the amixer command. For example you can control the master volume like so : 

A sound card for the GPIO bus will be coming out soon which supports more then 2 channels input and 2 channels output, see here. Until this happens, you will need to resort to multiple usb sound cards. The problem with multiple USB sound cards is that they will suffer clock drift. With that in mind, you can do the following (taken from the ALSA asoundrc page); Create the file ~/.asoundrc with the following in it (changing the hardware devices for the ones on your system and duplicating this example from 2 to 4 devices) : 

If it is a device selection problem, then ... You can choose which device aplay will use to perform playback. First however you need to work out what the device names/numbers are as far as ALSA is concerned. If you use aplay -l to list the devices, you will see various cards listed, one being your USB device. If your USB device is hw:1, then try to use aplay like so : aplay -Dhw:1 fileName.mp3 

There are some sound cards which have audio input and output on them. If you need to hear what is coming from the audio input and record at the same time, there are a few options, such as ; 

Use a Screw Terminals Bare wires can be robustly attached using screw terminals, there are many HATS and adapters that allow one to use screw terminals for connecting GPIO Pins on Raspberry PI 

Oh Man, what a screw up.Do you have any other access to the device? In all honesty I would mount drive on another computer, copy important files and reinstall. Unfortunately Many things in linux are picky about permissions, SSH is probably among the pickiest. 

In addition to turn-key applications, there are other simplistic ways to get diagnostic information through the web by leveraging the operating system. SOCAT port monitor can be used to listen on a port, and execute/echo a command to that port whenever a connection is made. For example, in two lines 

True, however the downside is not the extra thread, but that you cannot use the same bus at the same time in two places, regardless of how many threads you have. Your multithreaded approach is basically out of laziness. You do not wish to design a robust polling loop so you are asking the kernel, to do its best to schedule your threads and you use locks to resolve resource conflicts when the scheduler screw up. Of course this is less efficient than a serial approach. However, it is simpler (easier), but can cause unintended side effects, the scheduler/kernel is not always doing what you think it is doing. 

That is correct, there is no audio input. The Pis generate analogue audio output using simple pulse width modulation (PWM) which is an efficient way to make output audio, but in the case of the Pi, it lacks great analogue separation. To get audio input, the Pi would have to have a dedicated audio codec, which it doesn't. A lot of people mention USB sound cards which can readily be used with the Pi systems. There are other GPIO based sound cards which can also provide input audio lines ... check here for a non comprehensive list. Some of them also have microphones built in or microphone inputs, or lastly line inputs with which you can use a microphone preamp. USB sound cards tend to have longer latencies (mode delay) as they have to buffer audio to send over USB (using the UAC/UAC2 protocol). Matt 

Alternatively you could get one of the sound cards which have inbuilt input/microphone and output ability, such as the ones listed here. This solves a lot of problems, as the same clock is operating the input (ADC) and output (DAC). I see that was your original situation, and am wondering why you changed to purchase the USB input. Matt 

This command sets the Master volume to 0 dB. You can list the available simple controls using the amixer scontrols command, here is an example : 

If your card is card 0 then make the necessary changes to this code snippet above. If you want to use the USB as the input and the onboard device as the output, you will want to setup an asym default as specified in this answer on stack exchange. Finally it may be better to use a single card with onboard microphone and playback for certain reasons, of which there are some examples on eLinux here. 

This seems to be an HDMI hardware problem so I would approach is as an IT issue, and there are few things to persue. Power supply is red herring (IMO until any further facts are given) Easy Things To Check: 

Current Loop Analog Industrial Controls using control, is reliable for many Kilometers. And is the professional way of solving this control problem in the analog regime. Instead of using voltage you use current sources and sinks, which will compensate for any cabling resistance. The range is an industry standard and you will find many thousands of devices that support this signaling mode. 

Buffered Approach Use Libraries to capture and record audio stream data into a file. You can do this, for example, every second or every 200 milli-seconds, whatever makes sense for you. Use , specifically to extract frequency measurements from the audio stream data. The result of an is an array of frequency bins, that is the relative "power" of that frequency in your audio sample. 

In this particular case, the part you are looking at is an and not a general purpose part like an ADC, or microcontroller. Usually, a device manufacturer will only sell directly to very large customers and distributors. However, Markets and companies are stil small and rather new, so it is more common that they only deal directly. 

The Raspberry PI, and potentially, even the contactor can be mounted in the same location The PLC is mounted in a cabinet, which can double as a junction box (for electrical wiring) or otherwise mounted near the feed in for the room. 

i've changed the metering mode to 'spot' dunno if that make a different but the effect seems more predictable in this mode. i already change it to all of it's available option but the white balance? is still drifted in one or other way. 

i thought it was the 'I/O' bottleneck stuff, so i went to Multiprocessing code which is basically polling the frame whenever it is available without waiting for each time camera capture frame to complete (that is what i'm currently understand). but there were no significant different on FPS counter or i must say, only 2 FPS increase. This is my Multiprocessing code: 

Basically no, you either need a buzzer for simple BEEP stuff hooked to one of the GPIO or using HDMI adaptor that contain an audio jack. for more complex, a bit permanent solution you can build one of pwm based audio like what Bj Black already mention 

Currently, my system is only producing 10 FPS out of 20, which is my target. I'm barely hit 15 FPS in single grab-and-show simple code like this: 

I've been trying to create a program that split few different section of my main OpenCV program to increase fps. The first thing i ever think of is the Pipe() function from my friend. I've tried this 'default' code below in python 2.7 on Windows 10 to learn the basic first of multiprocessing: 

After that i went to Raspberry Python 3 to do the same thing, but nothing happen in Python console when i tried to run it. the console cursor just sit there doing nothing beside blinking, but when i try to run it from terminal by typing and followed by file directory, the text just appear like nothing happen. I don't know why, but i'm definitely missing something here. can i actually run this on Python 3? and why the text are not shown in Console that called from IDLE? 

If you find an audio hat for the pi which has both RCA and headphone outputs, then you can connect both of your speakers (with amps if necessary) to the Pi. There is a nice selection of sound addons for the pi here : $URL$ To control the audio wirelessly, why don't you use some sort of DLNA app on the Pi. For example, if you put a upnp daemon (miniupnpd) on the Pi, it will render audio it gets from the network. You can then have your audio library on the Pi, a separate computer or on your phone acting like a DLNA server. Finally you can control the audio which is being played using a DLNA app (plenty of them to choose from) on your phone. 

If it sounds good when using omxplayer, then you don't need to replace the sound card or anything like that. If you hear distortion, it would be interesting to know whether there are underruns, where you application isn't presenting data fast enough to the ALSA driver. Which sound library are you using in java ? Perhaps you need to understand how to turn the volume up and increase the playback block size ? Matt 

The solution to this problem is to use the softvol plugin. From the Audio Injector forum topic "Output RCA volume control" the solution is like this: To use softvol, add the following to your ~/.asoundrc file :