Razor is a view engine. It's completely abusive to try to use it as a "controller" as you've done here. If you want a code behind, then Aspx & webforms is the correct architecture to use. But that suffers from the same issues as the abuse of razor you've done here. Tightly coupled view/business logic. It's evil. Evil. Don't do this. 

Which is a really good reason to not abuse the statement like you have here. Just explicitly call this on and be done with it. 

But.... what exists? Let me just look a few lines up... OH! A record exists! Why don't we just say so? 

And create a class that manages what Message to return based off of the value of the passed into its constructor. Reducing the above code to 

Neither of these should be Public. Nor should they be variables. They're constants and should be declared as such. Let the compiler warn you if you ever try to assign a new value to these. 

There's dead code here... It happened because you're physically changing the code in order to switch between your two different strategies. It would be better to actually implement the strategy pattern. You could create a like this. 

There's some duplication in the . Instead of creating a new instance of the in each action, create it in the constructor instead. 

Also, may I ask what the in and represent? It's not clear to me. As far as I can tell, these should simply be and . 

Now you could easily create a couple of classes to grab all of the strategies from a database, grab all of the strategy to sku mappings, and create this dictionary to pass off to the every day. Now you're free to create as many pricing strategies as you need. Maybe your store wants to offer a "Buy 5 Get One Free" sale, or a "Buy One Get One" offer. You can do that without modifying any existing classes. Everything is closed to modification at this point. 

Your question has been answered in my opinion, but this is Code Review and if be remiss to not point out that you might as well just be swallowing those exceptions. Sure, logging them off is useful to a point, but your user is going to continue on, blissfully unaware that their data has not been saved. Which means that you will likely be unaware of the issue as well. Oh sure, you've got the log, but do you really ever look at it? I'm betting you don't. Speaking of the exceptions, I don't see a great benefit to catching and , only to turn around and swallow every possible exception that could happen. If you're going to catch , you might as well remove the other two catches. 

Let me point out some things that I know can be improved so that other answers can focus on my problem. 

Also, is a very poor variable name. These are both moot points though, because that variable is entirely superfluous. That part of the function can be rewritten to directly return the value of the expression. 

There is way too much going on insider of . That method is 98 lines of code. This breaks the "Single Screen Principle" by roughly 3 times. What's the Single Screen Principle? It's the idea that any one given method should fit neatly on the screen at once. If you have to scroll to see the rest of the code, there's too much going on and it's very likely that the Single Responsibility Principle is being broken as well. In fact, does exactly five different things. It handles the , , , and actions. All of the code in each of these cases should be extracted into their own methods. should look something like this afterward. 

Yes, it's nice to get a parse error rather than a runtime error, but that's all you're gaining. It seems a little silly to inherit from a class and then have the exact same functionality. 

This is a huge improvement over the last version. I'll try to give you some pointers on how to improve this farther, but I am also going to tell you this. Your database is very poorly designed (if not downright broken) and nothing we do here will fix that. If you were using proper keys on your database, you might be able to develop a sql solution to this. You use as a key, but don't have it defined as such. That column should not allow nulls. Period. I suspect that is the source of your woes and the rest of this is a symptom of that. Now that that's out of the way, let's see what we can do short term to clean this up further... Why are you adding an empty string to the end of ? That doesn't do anything at all. (Note: I just found several more instances of this. I really don't understand it.) 

With just two keystrokes I've re-enabled the update statement. The single line comment on the closing marker prevents it from becoming a syntax error. I know it's nothing to do with your code or cursor, but this little trick has saved me cumulative hours, maybe days, over the years. 

If fails, you could return the original string. If you don't want the original value if it's not a number, you could use and catch the appropriate exceptions. TL;DR I don't think you need to do this at all. Sorry. 

As I alluded to in my comment, you have bigger concerns than performance right now. I don't know who said it first, but I've repeated it here many times. 

The next step would be to break down the steps inside of the new method into smaller methods as well. A good start would be to take the code between the comments and place them inside of a method with a good name. This replaces your comment and breaks the code down into logical chunks. For example: Instead of this: 

First and foremost, use in all of your code modules. It forces you to declare all of your variables. You have about 20 declarations at the top of your module, but haven't declared your recordsets at all. These are never used I didn't check the rest of them: 

You should also remove these comments. You've filled in the code already. They're just noise, not just in the code, but in your IDE's ToDo list as well. 

There's a lot of code here. I'm not even going to pretend I looked at it all, so don't consider this a complete critique. I did see a few things though. In there's a serious case of arrow code. 

This is not error handling. This is swallowing errors and telling your code "It's okay, just run with it. It's cool. Don't worry that we have the wrong worksheet..." A proper error handler looks like this. 

The first one makes it much easier to adapt the external type to a slimmed down version. The second one removes this need entirely, but you lose the ability to use the template views that Visual Studio provides. Pick your poison I suppose. 

Note that in your full code, you will likely need to also pass the appropriate ranges into this method as well. Also, I'm not sure if you need this line of code, so I've left it's equivalent in the above method. 

This is a very naive solution. There's more to consider than just the hours offset. What happens when it's daylight savings time in London, but not in New York? You'll be off by an hour. You can manage all of this by using a , which includes the hours offset from UTC, and a bunch of logic instead of a plain , but it's really better to use a library like NodaTime for this. 

It should be as in "X Range". Don't use underscores in your names. Underscores have a special place in VBA. They represent Event Procedures and Interface Method implementations. Using the underscores elsewhere gets confusing for people. It's better to use for variable names. 

Getting a hook on an open instance of Excel is something I do all the time. I'm now questioning if I'm doing this the best way. I'm particularly concerned with the fact that I rely on the method to throw an error. I'd like to avoid it if possible. I have a Utils module that contains a function that returns a brand new instance of excel and one that tries to get an open instance of excel. When I encounter Err.Number 429 in the function, I call the function. Something I've done routinely for years suddenly feels dirty. There has to be a better way to do this.