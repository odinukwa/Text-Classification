In the example above the center position lies a certain distance (let's say 50 units) behind the player. This could be easily calculated as: 

As the others have said, perlin noise should be a good source of data for deciding where to place different types of tiles. I'd like to complement that idea and link two additional resources that should be helpful with with the third step in your checklist - rounding the corners. This is a process called auto-tiling and it's not all that difficult to implement. There are many different ways to do it, but most of them rely on calculating adjacency information for each tile in order to decide which graphic should be drawn in that location. A very elegant way to solve this problem is to assign a unique flag value to each adjacent tile direction, and lay out your spritehseet such that the value you get by adding together all the adjacent flags of a tile will correspond to the correct position of the tile in the spritesheet. Read this article for a very clear description of the technique. And here's another resource which describes another variation of the technique. 

Disclaimer: There are probably other, and better ways to do this. Either way I'll share and describe the way I approached this problem a while back, which ended up working okay for me. I've implemented a 2D top-down car game a couple of years ago for a university project, and if I remember correctly I used this article as a starting point, although I ended up simplifying it a lot, and dropped all of that "wheel" modeling stuff in favor of a single body for the car. What I did use however was something similar to the method which you can find there, to take care of applying lateral friction. So, here's a little video of what it turned out like. There's a certain amount of sideways friction being applied which also depends on whether I'm using the handbrake button or not, and the car I used for the video also drifts significantly more than the others. This was controllable though. It also had a truck with zero sideways motion and very stiff controls. I was never completely satisfied with the results, but it was enough for my needs. Bear in mind that I didn't base any of my physics on real vehicle movement or anything. I just tweaked and tried things out until It felt right. Sideways Friction So, to give a few details on the implementation, basically, when I adapted that method to my project, I added a variable which allowed me to control exactly how much of the lateral velocity I would kill, as a value between 0 and 1. This allowed me to fine tune the handling of the car and how much it could drift. Here's the method translated to XNA and simplified: 

Short Story A neat alternative to this problem is to store your levels in a bitmap, one pixel per tile. Using RGBA this easily allows four different dimensions (layers, ids, rotation, tint, etc.) to be stored on a single image. Long Story This question reminded me of when Notch livestream'd his Ludum Dare entry a few months back, and I'd like to share in case you don't know what he did. I thought it was really interesting. Basically, he used bitmaps to store his levels. Each pixel in the bitmap corresponded to one "tile" in the world (not really a tile in his case since it was a raycasted game but close enough). An example of one of his levels: 

The main problem with static and global objects in C++ is that they are created before the application's entry point (i.e. ), but their constructors are called in a completely unpredictable order. The same is true for their destructors, at the end of the application. This is clearly a problem because often we will have objects that depend on each other, and require a certain order of initialization and shutdown for the application to work correctly! While you could use a singleton, which usually delays the construction of the object until it is first accessed, the destruction order will still be undefined, unless you make your singleton class more complex to handle that situation too. On the book Game Engine Architecture they discuss a few alternatives to this, but it's the simple solution (in the sense that it uses no patterns, or any special control mechanisms) that they recommend the most. The book even states that this is the approach used in Uncharted for the PS3, so if it was enough for a huge AAA game like that, it will probably be enough for you too. Basically: 

I'm almost sure this is because you're using instead of . Change the value in the sampler state before rendering the primitives. I think it should be something like: 

Keep track of both the current and the previous frame's keyboard state. Detect a key press by checking if the key is down in the current frame but was up on the previous frame. 

Using this Dictionary you can easily find all tiles of any type on the board. For instance, if given one tile, you'd like to find if there's a match you could do: 

I don't think there's anything special about switching from one path to another. You just abort the movement that was taking place, generate a new path from the current position to the destination, and start following the new path from your current position. Your problem seems to be that you're teleporting your character to the center point of the first tile in the path (i.e. the tile your character is already in), but there's no need to do so. Although this problem depends mostly on how you're processing the movement and how you're representing the path (either as world coordinates or as tiles), I think you can probably solve it simply by dropping the first node of the path and start moving directly towards the second node instead. See the picture below for clarification: 

Solution with only Translation and Zoom It's actually quite simple to implement. The camera's view matrix transforms coordinates from world space to view space. The inverse of the view matrix transforms coordinates from view space into world space. Using this information, you can get the bounds of your camera, whether it's zoomed or not, with this simple method (I'll use a fictional RectangleF struct as example, I assume you'll understand the logic): 

Rendering Points - Method 1 (SpriteBatch) As for drawing points, this used to be easy using point sprites but they were removed from XNA 4.0. There's a few alternatives though. The easiest way is to create a 1x1 white object, and render it using in the correct screen location, which you can easily find using the Viewport.Project method. You can create the required object like this: 

Most of the entries in the Game Programming Gems series of books have an entire section dedicated to audio programming. For an overview of some of the topics covered, check the following link: $URL$ The list is not complete, as it lacks the entries in the 7th and 8th books, so cross check it with the complete table of contents provided by Zolomon in the comments: $URL$ The Game Developer Magazine also has a monthly column on audio programming: $URL$ 

PS: Where you're setting for the platform, you should apply to width/2 and height/2 too, if you want it to behave as you expect. 

It depends almost entirely on your specific game needs. It can work perfectly for a simple game, but fail on a more complex system. If it's working for your game, don't worry about it or try to over engineer it until the need arises. As for why the simple approach may fail in some situations, it's hard to summarize that in a single post, since the possibilities are endless and depend entirely on the games themselves. Other answers have mentioned for instance that you might want to group objects sharing responsibilities together into a separate list. That's one of the most common changes you might be doing depending on your game design. I'll take the chance do describe a few other (more complex) examples, but remember there are still many other possible reasons and solutions. For starters, I'll point out that updating your game objects and rendering them may have different requirements in some games, and therefore need to be handled separatedly. Some possible problems with updating and rendering game objects: Updating Game Objects Here's an excerpt from Game Engine Architecture which I would recommend reading: 

I've tried your code and it appears to be working on an empty project for the most part. But there are a few things that could make it fail: 

You wrote in a comment that because you're using Demina, your sprites are forcibly being drawn to client space instead of world space. But although I've never used Demina before, I've just checked its source code and that doesn't seem to be the case. Instead Demina takes a camera transformation matrix which is used to convert the sprites from world space to view space, but you're passing it the wrong matrix. Here's what I recommend you to do. First add a simple camera class like the following to your project: 

First of all, since the elements of a std::vector are guaranteed to be contiguous, you can pass it to Bullet with a simple trick: 

After the transformation, you check if the new point falls within sprite B's bounds, and if it does, you check the pixel at that location just like you did for sprite A. So the entire process becomes something like this (in pseudocode and untested): 

I think you should not try to hardcode this behavior as a series of if-elses like you're doing, because this will make it very difficult to extend or change if you need different values, or to add more positions in the path. Instead look into adding the capability of following any path to your entity. Here's an example (I'll give the example in 2D but it should be the same for 3D), but there are certainly many ways to do this. Suppose you're starting with: 

And it was working even without clearing the depth buffer, so I'm no longer sure if that's even necessary, but added it just in case. 

I'm not sure what sort of hierarchical FSM do you have in mind, so I'm sorry if this does not directly answer your question, but I'd really like to take the chance and add some input from my own experience using a stack based screen manager. Since you need the ability to open a popup screen but still be able to see the screens below, having a stack based implementation will make implementing it pretty easy - you can just push the popup screen into the stack, and pop it again when you're done. You can also easily wire it so that all screens on the stack will be drawn at all times (from top to bottom), but only the topmost screen will be updated. But here's a few extra tips that I find useful in my managers. Tip 1 - Provide a Switch operation Pushing a new state is useful, but I find that most of the time you won't be creating popup windows but rather transitioning between larger states. So I like to add a third operation besides the push and pop that allows me to swap states in one go. Something like: 

The reason why your character is not moving is because your acceleration values are just too small. I recommend taking this course of action: Step 1) A few improvements to the physics code First make your physics code based time-based instead of frame-based. This simply means that where you used to have something move X units per frame, now it will be moving X units per second instead. Just multiply the elapsed time when calculating the velocity and position! You could optionally also use velocity verlet over euler integreation as presented on this article for an extra bit of stability. I'll leave it out for this example though: