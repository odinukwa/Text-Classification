When you say retry you mean something like a "play again"? In this case you could use something like: 

2) When the program asks for a value to the extra bum, it says you can choose 0 for no extra bum, but you set the minimum input allowed to 1. So you must change min to 0. Answering some questions: 

(I used .format here because it's the way I know, but it's not ok to mix format and "%" styles in the code. You should change that for the sake of coherence!) 

I'm not an advanced programmer, but I have some suggestions I think could improve the performance of your code: 1) In the first line you make and then you use this variable 3 times calling . Instead, you could use , so you'd call this function just once. 2) I don't understand the use of here. At least in Python 3.5.2 I ran the code wihout the and it works just fine. 3) In the first if statement inside the for loop you test the minimum and maximum values of inp[1] twice. You probably wanted to test inp[2] in the last part. 4) Here: 

It's also a little confusing that you return from to indicate that you want to keep running the program. I would probably change the name to and return to indicate that you want to continue. Float literals have an on the end of them: 

Since there are only three valid key sizes for AES, it makes sense to not even let the AES class be instantiated with any value. I would introduce an enum similar to this: 

shouldn't be a property on the program. Nothing is going to be accessing the file, so if it's going to be in there, it may as well just be an instance variable: 

By breaking down the nested if-statement it becomes much easier to think about. Now we can add new stuff and fix broken stuff much faster. onGetLLCommand This one is a bit easier. 

Defining them early and making them static gives you less stuff to think about, which is always nice (especially when you're reading this code in six months). The next piece of code is too long and contains too much stuff so lets start breaking it up. First let's create separate methods for both of the commands you're accepting. 

I'm not really sure why you have both a perm_nfbm_disabled and nfbm_enabled flag. Try to use only one. Or if they don't mean the same thing, give them names that make that fact clear. 

I'm going to be brutally honest, because I think it will do the most good for you as you look for a job. You say you "have the right frame of mind" and "just need someone to 'nudge' [you] in the right direction." You're way ahead of most of the pack, as you are capable of something much harder than FizzBuzz. However, this code needs a lot of work and a lot of reorganization. It's going to take time to learn the culture of C#, and it's going to take time to learn OO principles in an effective way. If I were you, I'd start writing a lot of OO code in C# in my free time and posting it to codereview. This is C#. You don't need to call on strings. Instead, do: 

The most important thing we've done is create a seperate method that will check whether a block is minable. By using a seperate method, we can focus the onBlockBreak method on 'what to do' instead of deciding 'when to do it'. The rest of the method now looks like this: 

Notice how all it is doing is passing the call on the the other methods when it is appropriate. onNfbmCommand Let's look at the onNfbmCommand Method. This part is difficult because it contains a very large nested if statement. This makes it hard to think about, so let's see what we can simplify. It seems both branches are actually almost the same, except for the specific message they are sending. In other words, it doesn't matter whether the sender is a player or not. We can use that to our advantage! First lets create a method that sends a message to the sender with a color if it's a Player and without a color if it's not: 

Consistency is important. The rest of your variables start with a lowercase letter, so name the variable in the same way: 

Using namespace std pollutes the global namespace. It's better to use everything with its full name (, , etc...) 

Another shameless linq answer that doesn't require reversing or creating a new enumeration and only goes as far as it needs to: 

Of course, then you have to fix the other parts of your program that use them. In addition, I'd stop doing assignments inside of parameter lists and and headers. It's dangerous to do so, especially as a beginner. Here I've changed the first : 

I made this script to carry out a specific real-life task, which was to sort a list of candidates in a public competition by grade. The file with the informations consists of a text file copied from part of a pdf with the ID, name, grade in the exam and grade in the composition. There are a little more than 1,000 candidates. I needed it sorted by the final grade, which is obtained by the formula: 

This file had some singularities: 1) The information about each candidate was separated by '/' and not by new lines. And each information about the candidate (ID, name, exam note, composition note) was separated by ',' 2) new line characters were spread randomly throughout the text (I think that was caused by the Notepad or by the PDF program auto-break line) 3) The page numbers of the original PDF remained in the text file, and could be found beside the ID number, one of the grades or between parts of a name, surrounded by new line characters like "\n26\n". The page numbers ranged from 15 to 26. This is a fragment of the original text as read by Python: 

In , you do a lot of the same as in the else. Also, has an overload for a format string. Use that one instead of concatenating a bunch of strings and variables together. Also, it's hard to read when it's all on one line: 

The algorithm you used is the way I've always seen it - flooding the matrix. I think my sister had this question at her first interview, and I think she did it the same way as well. 

Just pick one. Here I just return void, keeping with the semantics of the rest of the parameters (pass by non-const reference): 

If the sender doesn't have permission we send a message and return quickly. We don't have to worry about permission for the rest of the method! Let's do the rest too. It looks something like this: 

These strings are all constants and should be defined at the beginning of your class. They should look like this: 

We can now use this method in the onNfbmCommand method and we don't have to worry about the difference between player and sender anymore. Hurray, that's one less if-statement to worry about! 

The implementation seems fine. I would change the return type of the method to be a bit more general. Callers don't care about whether the duplicates are stored in a Set or not. 

I would get rid of the continues on the for loop. They can get rather confusing, especially with three of them in there. You can use and to do so: 

That second is a bit long, but we can rewrite this to something I think is more readable by creating ranges and using as a cross join: 

I'm almost alright with not declaring local variables though. The function names are descriptive enough, especially knowing we're traversing a tree: 

Use when you can. It lets the programmer know (reasonably well) at a glance that a variable will never be modified again. The variable can be declared as such since it's never changed. Also, returns a , so I'd probably declare it as such and cast later: