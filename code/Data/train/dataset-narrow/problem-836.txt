When growing the array you , and . Instead realloc and memset the appended data to 0 for the pool or initialize for the indices. 

When doing emulation you should disconnect from the real world and only provide a abstract view to a world. In other words don't use a real time clock instead simulate the timer by linking it to the emulated clockspeed. For example if you pick 8 MHz you would have 133 333 instructions executed per decrement of each timer. This will allow you to pause and fast forward when debugging programs. 

The culprit is in the last else branch. This is not needed because you know that the entire list from to should be sorted and you need to continue from the old . Take the following step: 

The temporary buffer is repeatedly allocated and freed. Instead you can preallocate a buffer and pass it through as parameter. Then during the merge you copy the values with push_back, instead you can move from the selected iterator: 

if multiple threads try to read they may each decrement the buffer if one thread was interrupted right before it could decrement and after it passed the while Instead use a Semaphore which is designed for just this: 

this makes the code independent of the name but will make it dependent on the order the enums are declared in. and makes the file less human readable 

Try to avoid allowing the invocation chain to go from a valid object to an invalid object. Your allows that. Instead you can make a method which takes all the required configuration items for setting javaSE to true. 

A destructor to CSList with at least an assert that is empty. should probably disallow copying and moving. But should definatley have a copy constructor and assignment operator (plus the move variants) to follow the rule of 3 (5) or disallow them which is saner because it is hard to ensure thread safety when copying/moving. 

Catch it in controller and make it show a as appropriate. MathOperationList can be a . You can get all operations by getting the array. In there is a regex pattern you split with. It's more efficient to store a static Pattern and reuse that as needed: 

and ... Manual use of new and delete very often leads to leaks. In this case you have a destructor but not any other of the rule of 5 requirements so every List and Node will get double deleted once the queue has been copied once. If instead if you had and hold their values by value there wouldn't be any leak possibility and you could remove the destructor. You can do that because the values of and have referential consistency (the locations remain fixed once they are in the map regardless of what happens to the map). You aren't very consistent with , if you ever update priority of an element you don't update it. Every has 2 copies being stored. once in the node and once as value in the one should be a pointer to the other. Using a unordered_map with T as key requires that it has a sane std::hash and operator==. It's primary purpose seems to be to avoid duplicates in the queue, however it's not uncommon to need duplicate entries in the queue so its purpose is questionable. should take the element by and add should it into the call. you can also reuse the relink function in there: 

Comments on every line is just noise, those who can't figure out what each simple line of code does shouldn't be reading it. Instead you can just comment the big blocks: fill array, indexed set and indexed get. In there is no need to set to . As you won't be accessing except to set it again. That for can also be replaced with a memmove (it's a memcpy that allows overlapped copies). assumes the pointers were allocated with malloc and the heap of the and the program are the same. This may not always be the case. 

min and max should be const and return a const reference (allowing users to change the key like that would invalidate the structure of the tree). 

You keep recreating both the adapter and the connection, instead cache them after first creation. You will need to put the cleanup of the connection in a after making the data access class . 

To position your buttons you can look at GridBagLayout. It will manage the position and size of your buttons and text field for you. There are other layout managers but this one matches your needs the closest. 

In radixSort you assume that is a signed 32bit int. Instead you should check whether it's an integral type and alter the algorithm a bit based on its properties: 

2 Scanners wrapping the same input stream will conflict with each other. They will each read a portion of the input and interpret the data and then keep "leftover" data cached for the next call to . This cache is not shared between scanners. It's better to use just the one scanner. 

You can allocate on the stack and have simply initialize it (and rename to ). There is a define for how many bits there are in per sizeof unit: in . typically has a compiler intrinsic (called bitscan reverse in windows or in GCC) which translates to a single instruction on most CPUs. 

If HINTERNET is actually a pointer to some struct then you can use a where is a empty struct with a single function: 

will allocate a new list (as the name indicates) so there is no reason to wrap it in a . What you have is a defensive copy. This won't allow propagation of changes back to the queue, but requires you to get a new list each time you want an update. If you still want a queue backed view then you should return : 

The fastest way is to give each thread its own RNG seeded (and sometimes reseeded) by a master RNG in a thread-safe manner. 

And check with That leads me to the list itself; if you only check whether a values is contained within the list then you should consider changing the list to a HashSet. 

You should separate out the different handlers, make one for the number buttons, one for the operators, one for the equals and one for the clear. That way you don't need to test which button is pressed as much because you know the code wouldn't be executed otherwise. Also I suggest storing the first and second number as separate numbers instead of collecting the entire string and then parsing it. 

naming + all lower case makes it hard to parse the difference between the prefix and the name of the function, instead either pick or . returning is not ideal instead create a opaque (incomplete) struct and just let the use pass pointers to that struct around: 

Another, perhaps simpler, option is to locally copy the dll and load the copy. Then regularly check the original dll for an updated last modified time and then unload the copied dll, make a fresh copy and load the new copy. Do keep in mind that when debugging a dll has a pdb file associated with it and loading the dll also locks the pdb. You can work around that by making the compiler emit the pdb with a different name each time. 

With a bit of knowledge of modular math then you can know that for numbers > 0 except when dividable by then it is . This simplifies the algorithm a bit. 

My MainWindow popups a SettingsDialog. The setting dialog need to hide certain fields if the connected device is certain type. 

If you are in a single threaded environment then your implementation is okay. But if you ensure the shared_ptr is cleaned up before you return then shared_ptr's life won't be extended. 

Some won't let you seek to the end (stdin and socket streams for example). You should check the return value of and fall back to the classic then , rinse and repeat method on error. A single is more efficient than the repeated ; so you can replace the while with: 

This saves the normalization of the bisector. The rotation matrix can be constructed from a non-unit quaternion without first normalizing it. You do have to provide your own function to do so because the Qt algorithm assumes a unit quaternion: 

Extending this you can split the list up in numbers and operators and use 1 loop for the numbers 1-9 like above (with 3 replacing 4): and place the operators and 0 separately. 

No need for the when starting a new line in the middle of a expression. The semicolon is the delimiter of statements. 

and so on however given that this is just a POD you can make the fields public and not bother with the accessor methods 

Don't use raw pointers and prefer keeping the Field by value in . Each dereference into cold cache is 200 cycles dropped on the floor, you force the cpu to do 2 of them each time to get a . If you instead have a single std::vector with size indexed with (you can overload to retain the interface) you will get faster random access. Whether a is closed can be kept by adding a member field into defaulted to false. is equivalent to and you got just a little bit earlier. You may as well have just kept it temporarily. When updating a you should remove the from the set and reinsert it. The you use won't work correctly when you update it's values in place and invalidate relative ordering.