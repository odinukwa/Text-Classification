Also is a better choice than for a "large number". This reduces the number of iterations by a factor of 2. 

There is one problem with your approach: Additional sublayers are added in and in and never removed. That can cause memory problems and slower drawing eventually. I would suggest to create and add only a single instance of the animation layer, this can for example be done in 

Two problems in your code You check if the replacement string contains at least one allowed character, so that pasting "1A" into the text field would be accepted. Instead you should check if the string contains no invalid character: 

As an example, requires 720 remainder operations in your algorithm, but only 8 remainder operations and 6 divisions in this algorithm. 

This is perhaps not faster than your version, but definitely better to read and therefore better to maintain. You can also replace the recursive function by an iterative version 

does not produce the correct result for numbers with more than 17 digits, because that exceeds the precision of a double. Actually it returns for and all subsequent Fibonacci numbers. That is not relevant for the concrete problem here (see below), but if you want to work with then you should replace this with 

which tests and unwraps the optional result as a single action. Inside the if-block, is the unwrapped . You can do the same with the items: 

I quite like the idea when implementing error handlers to do stuff through an interface to remove any dependencies on modules. Sometimes I've used that in conjunction with a global static Log method. I've typically done this in c# but the theory is the same across to Java I believe. So how about something like this? 

Note, I'm not sure if TotalHours is calculated differently but if it's just a sum of the Task times then you could include that logic into the Viewmodel itself as in. 

I personally like to return early and avoid nesting if I can as I feel it helps readability. For example. 

A couple of very minor points. I noticed a bit of an inconsistency with your convention for naming variables. Sometimes you are using _ prefix, sometimes not, sometimes PascalCase sometimes not. For example some of your variables are declared as: 

I can't guarantee but this code should be slightly faster and a bit more readable. So a first crack at a refactored solution might look like. 

To me it seems like you are trying to make a async task for the sake of making it async to fit in with. 

Once you have removed these, the method becomes a truly synchronous method. As it's a pretty trivial method anyway this shouldn't be a problem and making it async only confuses the issue for no benefit. 

Project Euler Problem #2 asks for the sum of all even-valued Fibonacci values not exceeding 4 million, so using is not really necessary. All numbers fit into the range of , and the above test simplifies to 

The explicit cast to is not necessary because the method returns and that can be assigned to any Objective-C object pointer. Actually your method to read the JSON data is too complicated: The file contents is first read into a string (using some encoding) and then converted to back to data (using the same encoding). This can be simplified by reading the file into data in the first step: 

Now lets have a look at the class. There is no need to assign default initial values "noname", "nocontact" because both properties are assigned to in the init method. Moreover, name and contact do never change, so they can be constant properties with : 

which allows you to create a value not only from a string, but also from a given latitude and longitude: 

where the property names should be according to the API Design Guidelines). Avoid implicitly unwrapped optionals As of Swift 3, “Implicitly unwrapped optional” is not a separate type, but an attribute on the declaration of a regular/strong optional, see SE-0054 Abolish ImplicitlyUnwrappedOptional type: 

so you can use the same test to update either or . You compute both a sum and a complementary sum at once, which is a good idea to cut the (maximal) number of iterations into half. But the loop 

Just a small comment from me. I'm not so sure about the need for the method SetJob(). It seems like there is a requirement for this method to be called before the Start() and once called you wouldn't call it again? Hence perhaps I might look at moving this to the constructor that would hopefully imply this concept? Also that way you can't change the job. This is of course made with the assumption you aren't looking at changing jobs once a new ScheduledJob has been setup. Also probably what Stylecop might pick up anyway as suggested by Leonid; 

I would probably point out that these methods would probably be in different classes. For example the Update, Insert and/or Get might be in some sort of repository class. The CreateCustomerLog and UpdateCustomerLog might be at the higher level, maybe your UI level as it interacts directly with the UI elements. Just my thoughts. 

As I think George Howarth was suggesting in his answer you can reduce nesting and avoid the Arrow code effect by returning early from the method. This helps with code flow as well as readability. As already mentioned if you can remove constant literals from your code that is good. One way to do this is to move these to private static or const variables or even supply them to the method. 

Coalesce cases in switch statements Cases which bind the same set of variables (or bind no variables at all) can be coalesced together in a switch statement. Applied to the we get 

The output is , even if the number is not a perfect square: \$ \sqrt{4611686014132420400} \approx 2147483646.9999999513383954536814215918 \$. The reason is that a (which is a 64-bit floating point number according to the IEEE 754 standard) has only 53 bits for the "significand", therefore precision is lost in the conversion . It also fails for negative numbers: 

The only difference between the first and the second approach is whether the handler is assigned to a variable or not. None of them is more "functional" than the other. Therefore: 

You should make your type conform to so that printing an ordered dictionary gives a nice looking result. A simple implementation would be 

You have to decide how an error should be handled, but I would at least print some message when running in debug mode 

with the code compiled in the Release configuration, i.e. with optimizations. This is approximately a factor of 20 between those methods. It seems that one “culprit” is the remainder calculation in 

the array is one element too large. That does no harm, but there is a risk of forgetting to change the array size if the string on the right-hand side is modified. Better let the compiler determine the size automatically: 

I don't think there is anything necessarilly wrong with your approach especially if it works. However I personal might consider trying to leverage the DayOfWeek enumeration of c# and avoid the individual day timesheets. This way you could loop over weeks more easily as well as potentially leverage Linq to do things such as calculating the TotalHours as part of the viewModel. My viewModel for this case might then look like this: 

Just after a bit of feed back or peoples ideas on which practice is best. I currently have a method but am unsure of the best way to approach it from a readability point of view or even from best practices point of view. Or perhaps it doesn't really matter at all and they are all fine? My three options I explored were: 1) 

I want to keep it flexible so that I can decorate Enums with different Attributes as the requirements may vary i.e. using System.Xml.Serialization.XmlEnumAttribute in conjunction with System.ComponentModel.DescriptionAttribute so a UI can use the Description attribute to display a nice name while an XML serialiser can use the XmlEnumAttribute etc I would expect to either provide a wrapper class for this on my various projects so that I wouldn't have to create the delegate method everywhere however unsure of this approach. EDIT: After re-looking I thought the GetProperty() method is pretty generic and doesn't really necessary only belong to an Enum so I moved that out into it's own ObjectInspector class. EDIT: After some further thought into this I decided that actually it's not directly related to Enum's but rather the ability to get descriptions from properties in general. I've made some tweaks to the classes to try and separate this out. Any comments would be most appreciated. 

would abort the program execution if is not a number, this should be checked. I would move the calculation of the ISBN-13 checksum to a separate function, which can then be used independently to calculate or verify checksums. Putting all this together, the code could look like this: 

First, I would suggest that the function takes a parameter for the upper bound, and returns the result instead of printing it (as also suggested by @user16547 while I was writing this answer): 

where is your data type containing a property (which I assume to be of type ). The next step is to define the up/downward movements as arrays and to use a for-loop: 

I am (usually) not a fan of adding type information to a variable name, should just be named (as in the description of the challenge). Instead of starting with an empty array and adding elements one can create the array with . This also allows us to declare the array as a constant: 

Your calculations of seem unnecessary to me (and causes to more memory to be allocated than necessary). Here are some quotes of the C11 standard (taken from $URL$ 

A different question would be how "good" the hash is. The Swift language does not make any requirements here. Always returning would be valid, but of course ineffective when building large dictionaries. It may be interesting in this context that the hash value of the Foundation type is simply the number of elements, regardless of the contents. In your case, the DJB hash function is a well-known hash method for strings, so I do not see any reasons not to use it.