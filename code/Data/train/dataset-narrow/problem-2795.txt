This only works, however, if you are differentiating velocity/time. It won't work in a tile based game, and will result in visible artefacts, such as one object either tunneling through an object, or being visibly pushed out of the other object. In the case of tile based games, you can take a predictive approach, by checking where the object will be if it moves. If the movement would cause phase lock, then disallow the movement. 

I finally found a solution, on this page: $URL$ This completely elimenated both the sinking and the jitter. 

I came up with a solution: In order to record all possible intersections on a given axis, You must record a pair for every possible overlap. The code I posted wasn't doing this. Instead, my new code traverses the the list one at a time, and for each endpoint which is marked as a minimum, search the remaining elements until you find the max endpoint for the same object and generate a pair for all elements in between: 

F = ma, or a = F/m. Calculate the collision point between the sphere and plane. This is usually Sphere centre - normal* radius. If you want more accuracy, calculate how far the sphere has penetrated the plane, and adjust your calculation. This is largely optional of course, unless you want really accurate physics. Now calculate the relative velocity along the normal. For a static plane this is: Vball Dot N. Then Multiply VballDotN by -1, and multiply by mass. In physics at this stage you would also multiply this by the coefficient of restitution (bounce factor). Multiply this scalar by N and you have your force. When adjusting Vball, divide the force by mass again and you have the final acceleration, so just add this to the velocity and you have your final post collision velocity. 

From a physics standpoint, the minimum restitution between two bodies should be used. Think of gel hitting a rubber ball. The rubber ball has high restitution, but the gel has low. The rubber ball will not bounce off the gel. In the case of bounciness, lowest wins. However, gel has low density, which allows the ball to penetrate it and hit something with higher restitution, such as the ground. The gel will absorb some of the kinetic energy of the ball, how far the ball bounces, often considerably. But that's a bit off topic. Restitution is a representation of loss of kinetic energy through collisions, so the lowest value is the most accurate. Throw a golf ball at a block of soft clay and you will see what I mean. 

I'm going to ignore angular effects here for simplicity. In your contact resolution function, do the following: calculate relative velocity of the two bodies. if the relative velocity dot normal < 0 apply no force (moving apart) else correct position, to make penetration distance == 0 calculate normal force based on relative velocity / combined inverse mass apply impulses to bodies. Google "physics engine slop" for more info. 

As each object has only two endpoints, min and max, once you reach it, it can be inferred that the other end point is the maximum extent, therefore beyond it, no further intersections are possible, and so no further traversing is necessary. Naturally, this does increase complexity, but as the checks are very simple integer/integer, and boolean checks, It shouldn't have too much of an impact on performance. 

I'm writing a rigid body simulation in C++, and have come across a problem when an object should come to rest on the ground. Because gravity is being applied to it's velocity, the object starts sinking through the ground, or whatever else it's resting on. To combat this, I am adjusting the position of the object, by moving it along the collision normal by the penetration depth. This has the drawback of making the object look like its vibrating, so it never comes to rest. I read somewhere ages ago, that there is a way to counter this, by generating a force along the normal which will cancel out the force which is causing it to sink. A google search did not return any useful answers however. I suspect this is because I'm not asking the right question, but I don't know a more concise way to word it, so I'd appreciate if someone here has solved this, and could steer me in the right direction. 

Basically, you're maintaining the full text that will eventually be displayed, the current text that is being rendered, and the current index into the full text. is the delta time since the last update and is the time that has passed since the last time you moved to the next character in the string. When that time (here in seconds) has gone past half a second, append the character to the current text, increment to the next character, and reset the time. 

I won't write the code for you, but I can put forth a conceptual path forward. Assuming your text is displayed in a string, it is possible to iterate through the character array that makes up that string. The goal here is to print each character individually (or however many at a time you want) separated by a delta time. When you think about it, this isn't really any different than animating a sprite. Instead of moving the index into a spritesheet, you're moving the index into a string and appending that character to the displayed string. So, for example: 

Third, define the SpriteSheetContent with an attribute to identify its run time type (an instance of this class is generated at content build time): 

And finally, define the run time type with attributes to determine serialization at run time (an instance of this class is deserialized from .xnb file at run time): 

You'll see that the error message tells you exactly what is wrong. You are passing arguments that are invalid for that constructor. You need to pass a object as the first argument and a as the second argument. 

Establish a rate of movement in whatever units of measure you want (such as pixels per millisecond). Get the time since the last update that has passed (elapsed time). Establish the direction of movement (you're already doing that). 

I'm using the latest version of Tiled Map Editor (0.9.1) to create isometric maps. I have objects that are larger than my tile size (64 x 32), so I am breaking them up into two tiles of the correct size. Below I show that the blue blocks are made of a top and a bottom (both of which are 64 x 32). You can also see that when I am placing these blocks side by side, there is some strange rendering overlap. Shouldn't the foreground be showing if it is rendered in the correct order? In that picture you can see 4 blocks stacked side by side with the problem, 2 blocks side by side with the problem, 1 block by itself without the problem, and 1 dissected block in its two components. Anyone know what's up? Note: this is the view from within the Tiled Map Editor itself, not from within my game. 

Here's how my classes look (condensed for clarity): First, define the deserialized instance of the SpriteSheetData: 

Here I simply scale down the Y value by a factor of 0.5. Problem And it works, kind of. There are some tiny 1px-2px gaps between some of the tiles when rendering. I think there's some precision loss somewhere, or I'm not understanding how to get these tiles to fit together perfectly. I'm not truncating or converting my values to non-decimal types until I absolutely have to (when I pass to the render method, which only takes integers). I'm not sure how to guarantee pixel perfect rendering precision when I'm rotating and scaling on a level of higher precision. Any advice? Do I need to supply for information? 

Figured it out. It's due to the tile graphic extending beyond the tile. Update: I managed to work it out by playing with the tile layers. I placed foreground tiles in a layer below the background tiles. 

I want to emphasize that there are many ways to solve this and that you shouldn't fool yourself into believing that one size fits all with this problem. This is a little subjective and anecdotal from my own game, but here's how I view it. The world (level) and the beings that populate it (entities) are separate "things". That is, entities still exist even if the world doesn't and vice versa (ignoring realism for the sake of argument). That said, I tend to structure my object "ownership" in terms of a hierarchy of what populates what. For example, while the world doesn't own the player (or any other entity), the player does populate the world and is subject to its rules. A player (and other entities) in my game are managed by a third party. This third party extracts necessary data from both the level and the player when they need to interact (collisions, events, etc...). So really that was a long winded way of saying that another option is to do neither of your suggestions. 

I would not call this a that simple but here is now you can do it: Let's first have some notations (given the picture you provided): 

Changing to should solve the problem in this case but it's not a general rule. Here is why: Some math facts first, for matrix multiplication ; also So when you take a tutorial or code and you see in code and you want to do the same in the shader you have to think how and will end up in the shader code (transposed or not transposed). If it will end up transposed then you need to do to achieve the same result, otherwise A * B. If a matrix ends up transposed or not is dependent on the rendering Api and the matrix library you used. When you sent the matrix to the shader the api will copy a series of floats and interpret that as a matrix, but it doesn't know if the first 4 floats represent a column or a row in the matrix. 

Requirement: and must be normalized, and must be in the same space(radians or degrees) Also for 8 directions you must specify all 8 directions vector and the angle_threshhold must be 

Here is an approach to get the direction regardless of the how many directions you have and how many space dimensions: 

Here is a simple solution: Instead of calling everywhere , replace that with a function what has the following code: 

Setting the position before you destroy an to 'infinity' will handle all the appropriate collisions calls. 

The application is usually tested on the targeted platform with the worst case scenarios and you will always be prepared for the platform you are targeted. Ideally the application should never crash, but other than optimization for specific devices, there are little choices when you face low memory warning. The best practice is to have preallocated pools and the game uses from the very beginning all the needed memory. If your game has a maximum of 100 units than have a pool for 100 units and that's it. If 100 units exceeds the mem requirements for one targeted device then you can optimize the unit to use less memory or change the design to a maximum of 90 unit. There should be no case where you can build unlimited things , there should always be a limit. It would be very bad for a sandbox game to use for each instance because you can never predict the mem usage and a crash is a lot worst than a limitation. Also the the game design should always have in mind the lowest targeted devices because if you base your design with "unlimited" things in it then it will be a lot harder to solve the memory problems or change the design later on. 

the easy option to integrate is to store 2 texture coordinates into one float using the int part and the decimal part: 

There is not ideal way of doing it, this is a common problem with meshes. To solve this there, are two different approaches: Considering that you have a vertex that has to be used with two different textures coordinates here is how you can approach the problem: 1:Duplicate the vertex and assign to each one the different texture coordinates. As a result you will have two vertices with exactly the same position but two different texture coordinates. How you store the vertex data is not really relevant at this point (interleaved or not). There is no way i know right now (someone correct me if i'm wrong) to be able to represent an indexed vertex buffer in order to share vertex position and different texture coordinates. 2:Separate the geometry in multiple parts and draw it with two (or multiple) draw calls but this has a couple of drawbacks. First need to create extra code to be able to share the vertex position, second you need to make multiple draw calls and this hurts performance especially on mobile devices. I think the first approach is the industry standard because in the end the extra memory used is not much of a problem. One way to overcome the memory usage is to use streaming and it's much easier to use that (not to mention that you can significantly increase the amount of geometry) instead of the second approach in which adds a lot of code complexity.