Some might consider the line in too long. I'll let you split it the way you want. A last detail would be a more pythonic name than . 

A constructor taking device_id, device_type and home as an argument. a static method doing the file handling and calling the constructor previously defined. 

You use a mix of string concatenation of string formatting. This is highly confusing. Instead, you could simply write: 

For a start : your naming convention does not follow PEP 8 which is the usually accepted style guide for python code. 

Different algorithm Generating sequences and counting how many of the elements are in the right position gives you an 0(nÂ²) algorithm (at best). A different strategy could be to look at the shift required for each number to be in the correct position. Because all numbers are in , you can compute the shift with a simple substraction and a modulus operation. Doing this for all numbers can be easily done : 

I think the functions could have shorter names like and . Also it could use the module. Also, it is a good habit to move your code actually doing things behind an guard. Finally, it would be nice to have some documentation for the module and the different functions. At this stage, the code looks like this (I haven't tested it). 

Now, you could make your function a bit more powerful (and a bit slower) by returning all common chunks and not just one. This could be easily done using the buillt-in operations on set (). A final thing (a few other things could be said but I am running out of time and it might be too much for the time being) : if you want to pretend you are a cool kid, you can use set comprehension in your function. Then it becomes the concise : 

Let's go for a step-by-step cleanup. 1) Get rid of repetition by using a variable to store your html code common to the different branches. 2) Remove useless levels of indentation to make things easier to follow. The inside of the loop is now : 

Different way to get the best result Instead of sorting all the results at the end, we could get track of the best result found so far. 

I'd expect the returned value to be sorted and it's clearly not the case here. Thus, I expect something to be wrong. Playing with other inputs : , , it seems like your solution does not handle properly duplicated value. A matter of style The indentation looks weird on your question. You should try to declare your local variable in the smallest possible scope. Among other things, you can define your loop indices in the loop syntax in you use the C99 mode (). Once rewritten (but still wrong), your code looks like : 

I'm not sure what the corresponds to but it's probably be worth storing this in a constant to avoid having magic numbers in different places. 

Date format You can probably find in the documentation how to format a date as a string. I have to go and I don't know tkinter but I guess other people will have additional relevant comments. 

You don't need an array You do not need to keep track of all the computed values, only the last 2. You could write something like: 

I've not included as a divisor of n as it didn't seem too relevant. Then you can easily get the abundant numbers by doing something like : 

Your code looks good, seems to work and is somehow documented but it can still be improved in various ways (not only performances which will be only tackled at the end if at all). Code organisation Your call to could be moved behind an guard in case you ever want to reuse . It may not be relevant in your case but it is a good habit to take. Then, it may be a good idea to split your code into smaller functions, easier to understand and to maintain. By doing so, you'd also separate the concerns my having the code computing the results you need not mixed up with the logic handling the input/output. Finally, and maybe even more important, that will make your code testable. Indeed, before performing any changes in the algorithm, it is highly recommended to write unit-tests to prevent you from breaking everything (tests are usually not fail-proof but they help a lot). 

As I am messing around with your code, I use to detect quickly if I break the test case you have provided. Also, it shows something that we might want to fix on the long run : the trailing whitespace. 

Your code is easy to understand and just works but it can still be improved. Documentation It could be nice to add some documentation to tell which values are expected. Domain When I tried with as an input, I got a . This is because the recursion calls go deeper and deeper into negative numbers without reaching a stop. Adding : 

From what I understand from your comment, using did solve your problems. Here are a few suggestions anyway (that you may want to take into account before submitting a new question with the updated code): 

You could define a function to check a server status. Then you could call it to know if the server is up without bothering about the way it is done. You main function simply becomes : 

Bug found As I was looking at my original implementation, I found a bug which happens to be in yours too : try with . 

Tests Now that I have a simple function converting numbers to roman and roman to numbers, I can write a simple test to ensure everything is fine. 

About again There is still too much going on here. Also, many things seem to be happening in different places : rolling dices, printing, asking user if he wants to roll, etc. You can rewrite the logic in a much concise and clearer way : 

Don't repeat yourself (again again) I have to repeat the whitespace in the different elements of the list I a using. This is easy to forget if I ever need to add an article. Let's add the space as part of the logic. 

Your code looks nice. Here are a few detais: In The name suggests an positive integer value corresponding to a length. We actually use it for a string, which may be slightly confusing. At every iteration, you compute the length of 2 strings which is probably more than required for an optimal strategy. You are lucky because the problem you are trying to solve has a generic solution : which in your case gives (I've kept as a default value as it corresponds to the current behavior but maybe an exception is a more desirable way to handle an empty list). In The docstring says "alphanumeric" but the regexp does not include numbers. Also, if your pont is just to make an URL from a string, you may find better option in the module. In You could write: . In Instead of using lists, you could use sets which is a data type more relevant to what you are trying to achieve. Also, you may want to replace the code with a dictionnary structure: 

What you done looks good but I am wondering if it is not a bit over-engineered. Here's what I would have done (which is probably under-engineered) : 

I do not think you need to define being None before the . Scopes in Python do not quite work like in other languages. 

(I took this chance to factorize out the common part) Comparison to literal boolean When you know that a value is a boolean, is equivalent to the shorter and more elegant . In your case, this becomes . Recursion and user input In , an invalid user input is handled by calling the same function again and again. This has different kinds of drawbacks. From a readibility point of view, you could have more straight-forward solution. From a technical point of view, every invalid input leads to another level of function calls. It isn't such a big deal until: you reach the maximum depth (then your program will crash), you want to debug your program by reading the stacktrace (then it is unusable because of the amount of irrelevant and similar looking lines). A much clearer solution is to use a loop to keep asking the user until he/she provides a valid answer. 

With the test I've added, I can now tweak the algorithm and maybe see quickly if I break something. Do things the easy way seems like a complicated way to add an element to an array/list. If only there was an method on Lists. Oh great, it is actually the first method documented. 

Your code is very big but this is not the real issue. The real issue is that your code is not made out of little reusable/understandable/testable/maintainable components (functions, classes, modules, etc). But let's change things little by little. Style Python has a guide style called PEP 8. If you have no good reason not to follow it, just follow it. You'll find various tools to check your code (pep8, pep8online.com/, etc) and even to fix it more or less automatically (autopep8). The list of problems is mostly about whitespaces but it's always good to know/fix before it becomes overwhelming (well, too late I guess). Input validation First thing I noticed as I tested your code is that it didn't bother checking my input. When asking whether I was a warrior, an archer or a mage, it would be good to check that I provide valid values. It is quite easy to define a function to provide such a functionality : 

Maybe, should return when it fails (or throw an exception depending on how expected this can be). Maybe, should not return anything at all and just throw in case of error. Avoidable recursion relies on a recursion to iterate over the different activities. Python does not handle deep recursions very well because it does not perform Tail Recursion Optimisation. If needed, you can rewrite the function: 

(I took this chance to perform the renaming of the variable) Variable definition I find it a good habit to define variable as late as possible and in the smallest possible scope. In your case, instead of having defined at the very top of your file and then used in a triply-nested loop only to be reset at the end of the inner loop, it is probably a good idea to define it in the relevant place so that you don't even need to re-set it at the end of the iteration. You'd get something like: