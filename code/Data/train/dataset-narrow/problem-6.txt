So I have a local jenkins server building artifacts. I trigger this build through VSTS. When browsing through the logs when uploading the artifacts to VSTS from the local jenkins server I found this: This could pose an issue where the triggered build may get beat out by another build (theoretically). While this is not a high likelihood, I would like to mitigate all possible artifact confusions as that is one of the main points my company is moving to build automation and continuous integration. I did see something related to the VSTS Task in issue 4110 but not sure what is coming of this. What I'm trying to accomplish is that when Jenkins finishes the build it uploads it to VSTS. Because of the size of the build, when we go to releases, I would like to not download the artifacts back to our local premise, (using deployment groups) but instead copy it internally directly from the Jenkins build server. Does anyone have any suggestions? 

Feature flags are an engineering device that can be used to avoid long-lived branch and conflicts in product development. Here is how it can be used the context of an object-oriented language to help developers collaborate on a specific product feature while one handle a new version. This solution can also be used in non object-oriented contexts, provided a notion of “interface” exists. (cf. OCaml module system.) For the purpose of illustration, we assume a tool presenting reports about data stored in a database. The code implements a DatabaseClient class used to perform requests. As the dataset grows, it becomes clear that some alternative data layout would improve the application performance. Therefore Alice will develop a new version of the DatabaseClient able to retrieve data from the structures with improved layout, while Bob will maintain the historical DatabaseClient. With the following steps, Alice and Bob can collaborate on short-lived branches while minimising their conflicts. 

I have hosted VSO build agents building our exe and that pipeline setup. I am trying to deploy the produced exe to a dev testing environment. I have a deployment group set up and the files are being successfully copied to the correct location. What I'm trying to do now is launch the exe after it was copied. I have an inline powershell script task running consisting of 

From the perspective of build automation, I find that it is better to have multiple repositories. This allows for smaller configurations and more granular control of your build/release process. You can allows reference and pull in source code to build or release (of course you can also ignore source code as well in VSTS build pipeline). This leads to being able to release just the project you want or need to your desired environment. You can of course pull in artifacts from other builds and include them in your release if you need to. To summarize, I tend to go as small as possible and and only group things into the same repository if they are indeed part of the same project and no part of the project can be used elsewhere. 

whose complexity in comparison to the Ansible variant is probably tolerable: it just uses the plain, regular, boring constructs from the language. Random documentation step 3: Testing strategies Last, we meet what turns out to be the first actually interesting feature of Ansible: “Ansible resources are models of desired-state. As such, it should not be necessary to test that services are started, packages are installed, or other such things. Ansible is the system that will ensure these things are declaratively true. Instead, assert these things in your playbooks.” Now it starts to be a bit interesting, but: 

My understanding of Ansible roles is that they are the unit of reusability when implementing processes using Ansible, similarly to what a class or a package is in some computer languages. It therefore seems natural to use roles to make all tasks understanding a given data structure in a specific role, but this yields the question of how to select the actual tasks to perform? Is it a good design to use the file in the task as an entrypoint to select actual tasks according to role parameters? For instance a role could feature: 

Relatively speaking, the concept of devops is new and still defining itself in my opinion. I currently fulfill a devops engineer role. For me, this means I facilitate and develop the tools and processes used by both our dev and ops teams freeing them to focus on the product that generates revenue for the company. The ops and dev teams spin up their own servers and such as needed. I just hook up the CI for our products, ensure our processes makes sense and seek out what process can be improved/automated. I meet with all of our departments, from sales, to warehouse, to developers and operations (QA and release managers) to see what they are doing and how I can improve their process. 

So I wrote this powershell script to be ran by the deployment group agents who have access to the server locally. 

You are running into the limitations of managed services. Many managed services are great to start experimenting with ideas and can show a great value for the casual user. But they trade ease of use for flexibility and functionality, therefore as soon as we start to have serious needs and are ready to spent a significant amount of effort building up on these ideas, the first move we should do is to opt for a flexible a fully functional solution. In my judgement, you are hitting the line where you need to look for something else – and you will notice that you need to learn a different tool, because that's not free software and you cannot run it yourself. Here we are speaking about Circle CI, but the following limitations are common to many managed services: 

the release log displays but on the computer the script is running, the process isn't launched. If I run via powershell on the computer from the A1 folder, the process starts as expected. What am I missing? EDIT: Revisiting this after a bit. I have redone the script to use start-process . I have used combinations of using runas with credentials setting working directorys. The process does start...sort of. My target application is a WPF window. It launches but doesn't any any GUI drawn. I know the process is running because i can use which returns a valid process. Does anyone know how to launch wpf/console application and have it draw it's GUI? 

So what is happening is that the changed code just sat until internal testing was done (never a good thing as this is how code get stale quickly). Once internal testing was ready, the code was then merged into the trunk causing it to be published into nugget under the trunk's feed. Some business politics ensued and we finally got to a real single code base mindset from the product owner's perspective (which was the issue that got us into this situation). Moving forward I don't anticipate this to arise. Code can be branched out. However, only code in the trunk will go to our internal nugget feed or our build/deployment processes. 

each having three scripts called , and . Now that the organisation of automation items has somehow been clarified, let's turn our attention to configuration. The main conditions and requirements about the configuration organisation are set by the verb when applied on a service-like artefact. The verb should have the following parameters: 

First, while Docker is sometimes seen and used as a ad hoc packaging system, it actually solves a totally different problem: Docker is about running programs. The Docker system allows to describe services, that can be scaled at will and to control swarms of containers. Debian packages are for installing programs and they are able to handle dependencies between software versions. Docker certainly don't qualify as a descent packaging system: each “package” can only have one dependency, the system has no “recursive build” option and does not support complex version constraints! A possible answer would be that, if you are willing to write a Debian package for your application, you can also use Docker to deploy your application. This can be achieved with a configuration script which would look like