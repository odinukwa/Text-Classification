Yes, it's possible. But, just like making money with games (or anything else), it's not trivial. Like similar products, there's a number of basic ways to generate an income. The methods in the list below come in many forms, but the most basic of those forms are: 

I believe that producing a star field (long range) and planets and moons ("short range") should be two different layers. As for the star field, I've found this to be useful for my game: $URL$ That can take care of your long range, static star field. It's written in C++ and open source. As for the "short range" stuff. I've found some sources for solar system simulators, but from my shallow glance, they don't look very generic, if you're wanting to create a different solar system than our own. I put the links at the end. In reality this shouldn't be too difficult of a task to create a generic system for planets. Study up on your Kepler and you can get some good estimations of planet positions. $URL$ Probably just stick with simple non-eccentric orbits to start :) Here's some links for solar system simulators I found. $URL$ $URL$ 

So, create a vector pointing up, , then use to the vehicle to make it jump. Alternatively, you can use and supply an offset to position the force under the front wheels, thereby giving your hydraulics "the win". 

Public things like: country names, state names, county names, city names, street names, etc., are not trademarked or copyright protected. There are no licensing agreements required to use them. See Public Domain 

Again, I don't remember the specific names. But there was one that would just slow you down and have realistic body damage to the vehicle when the car was hit. 

Drag the camera prefab you want to instantiate onto the variable. You should now see replaced with the name of your prefab. Now when you want to an instance of that prefab, you just do the following: 

"map is stored in the client and on the server, server sends only coordinates and client got knowedgle of it": Pros and cons are essentially the opposite of the above. I'd suggest a hybrid of the two systems. The client can download the game, with the map data. When they enter a new area, the client asks if there is a newer version of the map data. If so, download the latest data from the server, otherwise use the local version. I assume when you say "store in memory" you actually mean some kind of custom flat file format on disk. If you only stored it in memory, you'd lose it as soon as the server restarted. So, using your own format or a database is up to you. It depends on how you want to access your data and the requirements of your game. If you know well the pros/cons of each, paired with the requirements of your game, you'll know which one to choose. 

The coordinates represent the 3D position of the cube being represented. There are of course duplicates for the corners where two faces of the same cube are represented. Now, if we were to rotate the top layer, we don't have to do any rotating, we just shift data through the arrays: 

This means that when the background is drawn, not all of it is redrawn every frame. When something on the map moves, the area it used to occupy gets marked as dirty. Then when drawing, you know you only need to redraw that portion of the background. This is beneficial because then you only need to redraw the areas that weren't shown before. So this is really only beneficial when you don't have many things moving around, otherwise your spending more time figuring out what new areas to draw than if you just redrew the entire background. This isn't too common anymore as the platform is usually fast enough to redraw everything without issue. Since this is really just an optimization feature, I'd ignore it for now, and come back to it if you find that performance is lacking. 

Where is enumerating over all the vertices in a face. And is enumerating over all the faces in a mesh. Then when writing: 

Your best bet is to attach the debugger and see where things are going wrong. If you're getting a stackoverflow it means you're recursing too far into your method. That either means your map is too large, or you're checking the same tiles multiple times. I'd bet on the latter given your screenshot. Depending on the IDE you're using, you can cause the debugger to break after the line you're targeting has been reached a certain number of times. That means you can place a break point at the beginning of your method and set it to break after 50 or so iterations. It could be that you're adding squares to your open list that are on your closed list. Which can result in you going in circles when the path is not straight forward. You might want to switch to an iterative approach to more easily track down your problems. 

I just write the whole thing in perfect pseudo code, then port that. But seriously, before you start. I don't think porting to another platform after the project is done should ever be part of the original plan. Beginners should develop in what they're most comfortable with. Those stories you heard of people porting after their project was complete likely didn't plan on that from the beginning. 

Might as well put this as an answer... I'd try implementing what I suggested and have units or objects that you want to be invisible reference a bone with zero scale. Really that's only for units that have multiple bones and you want to just make part of it invisible. Otherwise, just remove the position offset or change it to really far away when you want to make a unit invisible. Try letting the graphics card sort out what to draw. You can't worry too much about performance yet. At least try these things out before disregarding them as to costly. Premature optimization and all that. 

Your coroutine is being started multiple times. The coroutine will continue to wait in the background, even though you're starting new coroutines on top of it. If you only want to start the coroutine once, add a simple flag: 

Yes, using a physics engine for that would be a little overkill. I suggest you implement a flocking algorithm. The basics of which are: 

Read these tutorials (the beginner ones). Your question sounds like you're getting ahead of yourself. If you don't know how to move a sprite, or time things or do things in intervals, you shouldn't be asking how to do all three at the same time. Take a step back, get comfortable with the basics. If you have a specific issue you're having trouble with, post another question here and we can help. 

Think you're lagging now? Just wait 'till you have to get real-time occlusion information from the server. Now you can walk around from behind a wall and bad guys will suddenly pop into view as the server catches up and sends you the updated occlusion data. So my snarky comment tells it all. Likely the primary reason not to do this is lag and server load. If you want the server to know when another player is visible to you, that means the server has to know exactly what geometry each player is looking at and calculate that occlusion. I agree that exploits like wall hacking can make the game not fun. And I see that developers would worry about this because they want to make the game as fun as possible. However, when developers get to the point where their anit-cheat/hack counter-measures diminish game play and/or customer satisfaction, they'll lose far more customers than if they had just left it alone. See DRM. 

Having size information associated with your nodes will be very helpful to you. In the above, we see a size 1 unit can use any of the nodes. Where the same map for a size two unit looks pretty different, since all the size 1 areas are also non-traversable: 

This maybe "too spherical" for you. If so, you can try padding the edges of your map so that the portion turned into a sphere only represents a portion of the surface of the sphere. Below is an example of the spherical mapping results. A "flat" map: