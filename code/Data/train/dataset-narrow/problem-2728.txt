this should also clear previous touch since List is a reference type. The second thing is that there is no space partitioning so your collision check currently runs in O(n^2) as best case runtime. The third thing is that it's weird that you calculate the atan2 of the vector between the two objects to get theta and then you only use theta to get the vector back. 

There is no one size fits all answer to this, as is so often the case. Generally though, if you can precompute it, do it. If your robot doesn't change all the time, so for example you build it and it stays the same the whole time, then what's the point of calculating all of its parts every frame. But if it does change all the time then obviously you can't get away with making all of it one big object. You are probably aware that there are tons of things that become computationally more expensive the more objects you have, for example collision detection. So you have an interest to keep the number of game objects low(-ish). When it comes to rendering, ideally you would want to have a VBO and IBO for your whole robot, so you can push it over to the GPU once and then just reference it forever. If instead you split your robot up into bits you will have to make a draw call for each of the bits. While the amount of drawing that your GPU ends up doing will be the same, the amount of work for your CPU to translate all of those instructions for the GPU will be much higher. So in most cases treating it as one big object would be better. However there are cases where the other treatment might work better as well. Computing everything you need to treat your robot as one object is relatively computationally intensive and memory heavy. (Compared to just keeping everything as a collection of blocks) So if you are in a garbage collected environment and want to minimize your memory footprint, if each time a block is changed you have to recalculate the big object it could cause a garbage collection every time and make your game lag for a frame. 

The first question is where are you looking? If you are interested in a particular studio, outside of industry sites the best place to find jobs for the studios is on their own site. In my experience (from just looking around, speaking to people) the industry has no shortage of applicants. Because of that, there is no real need to expend extra resources paying a premium to get listed on various jobs sites. People interested in their companies will already be checking their website. Finally, the experience issue. The positions that you see advertised on these sites are generally not for entry-level positions. 

What you ask is possible. There are a variety of nice tutorials on the UDN and on the UDK forum that shows you how to do exactly what you ask. UDK, Like Unreal Engine uses the UnrealScript scripting language. Inspired by C++ and Java it's fairly easy to come to grips with. You don't have access to source code using the UDK. Also, there is a visual scripting language called Kismet And it is usually how people accomplish what you may be looking to do from your question. I also recommend Raven67854's Tutorial Series on Youtube. It's an excellent primer for getting started. 

Have a currentRotation and a desiredRotation you will also want some helper function to give you the shortest angle distance, so let's just call that angleDist or whatever. (You want that because sometimes going clockwise is shorter or vice versa). Then all you need is to interpolate between them somehow. 

My best guess is that you have some rounding errors. You aren't actually showing the movement code for the bullets so it's really hard to tell. Edit: Looking at the code, it should(tm) work. It definitely works fine to do things like this in the games I've written with XNA. The thing that bothers me is that your game doesn't seem to be running at all when you set FixedTimeStep to true, so something really weird must be going on somewhere. Could it be that you didn't separate Update and Draw logic properly? Edit2: The TargetElapsedTime is set to 16.666 seconds instead of milliseconds, so that's most likely causing the issues. 

Fourth there is also something to be said about the effectiveness of lists, especially in a garbage collected environment, but that varies a lot depending on implementation details. Fifth You can handle your collision phase differently if you don't care if objects intersect for a few frames, by just letting them gardually push each other out by applying force. It looks like you are trying to guarantee zero intersect, which you are currently not doing. (An object can be moved out of the first collision and then back into it when resolving the second collision) As a last sidenote I think that simulating n-body attraction is just always going to be a performance nightmare, so in some way you don't really need to worry about this rest, since that's what will most definitely ruin your performance. (Although space partitioning can also aleviate that a bit since you can only check with objects that are close enough to matter) I probably didn't notice everything but I think that's the jist of it. 

As your client is using the Unreal Engine, I recommend looking at the UDN. Here you will find all the information you need relating to implementing features within the Unreal Engine itself. I couldn't tell you exactly what you would need to call though as a good portion of it (any link that is red) is blocked off only to licensed developers. You will need to make some sort of arrangement with your client for them to let you access their development materials. 

I have two suggestions. The first is to limit the amount of direct skips they get, and allow them to regain used skips if they go back and complete a puzzle they skipped previously. This will ensure that the user remains motivated. They no-longer have unlimited potential for an easy ride, and it will add another motivating factor. Not using their skips because there is 'potentially' a far harder puzzle down the line. Also, as puzzles tend to effect the way that people approach a general set of problems they may get inspiration for a puzzle they play down the line. The act of returning and finishing a puzzle that had once defeated them will equal an immense amount of gratification (Consider finally one-upping someone who was better than you in ever class). For example of this, see World of Goo, although I don't know if they return skips. The second suggestion is to give them unlimited hints, from the early casual hints to helping them step by step. There are any number of factors you could use to give out hints to players, time, failed attempts but casually release more information that would make solving the particular puzzle easier for them. For you, this may seem as juvenile hand holding, but thanks to Hindsight Bias your players won't see it that way. Mentally they will say, "Oh it's that simple, I would have figured that out" and continue without feeling slighted in the slightest. (Or alternatively, they will go "No one would have thought of that, I'm happy I cheated" or "I was over-thinking the puzzle, I'm to smart to have ever guessed that" and actually feel pleased). For an example of this (in a form) see the monkey island 1/2 remakes. You can hold down a button to get a hint, and repeatedly clicking things (in general) in monkey island games (and many other adventure games) makes the character give subtle hints. The trick with that one, is to do it casually and without interrupting play. A simple visual tick could be the lowest hint levels, a sort of inconspicuous action to draw their eyes to something else (sparkles around something they should click, a change to a happier 'successful' tone when they are completing a proper chain of actions or touching the correct area) 

The short answer is yes. The long answer is that the specifics of how to do it massively depends on how you handle drawing your characters. If you use skeletal animations (like when using spine), then you can easily exchange bits of your character by just replacing the texture of it. (Since in skeletal animation systems your character is separated into parts anyway). You can do the same thing when you use sprite sheets too, but it is slightly more complicated. You already had the right general idea in your post. You split the animation up into the parts that you want to combine and you need to remember a draw order for all those parts for each animation. But then you can draw each frame of an animation easily by just combining the parts together. The drawback is that you need to make a full set of animations for each part, since every hat for example has to move the same in every animation, otherwise some combinations will just look weird. tl;dr: It is definitely possible and it is much easier if you use skeletal animation. 

I can't see anything fundamentally wrong with the shader, but here are a few things I find commonly done wrong with deferred shading that you might be doing. 1: Drawing full screen lights. The beauty of deferred shading is that you can pack your lights into geometry so that you only need to consider a part of the screen when drawing them (Like a cube with 2 times the radius as size). If instead you draw a full screen quad for every light, that will have a serious performance impact. 2: Render target depth. You are moving a lot of data around in deferred shading, so you have an interest in making the footprint of that as small as possible. If you can reduce the number or size of your render targets that can have a pretty big performance impact. 3: Rendering one light at a time rather than batching them. (Edit: You can have a static vertexbuffer and indexbuffer containing vertices for the max number of lights you want to ever render and then just patch the position and color of the lights that are active) And lastly, you can always look at the assembly of your shader and see how many cycles it will take, so that gives you an easy way to see your own performance and compare. GPU Gems has 2 or 3 great articles on deferred shading and the performance and other issues that come with it. 

For iPhone / iPad development, you are going to need a Mac. See Tetrad's comment for relevant "Can I use a Hackintosh" discussion. For android development the development tool is the same, it is the Eclipse IDE, and it is available across all three primary OS choices. You can find the relevant information about it here: $URL$ and you will find eclipse here: $URL$ -- Personally, I haven't noticed any major operating differences using Eclipse between any of my systems (Linux Laptop, Windows Desktop, Mac Laptop) outside of menus being placed in a few different places on the Mac. 

For creating your music, the first thing I am going to recommend is of course FL Studio. I mean, it's really nice, and as flexible as you would need it to be. It comes pre-loaded with all kinds of sample instruments and getting more is as simple as loading a VST. 

Were they your previous versions? If so, can you build a marketing agenda based on them? (Use cases, testimonials, and what not) If not, then the first step I recommend doing is: Find a decent sized school, and offer it to them for free. Like Bryan said before me, schools are cheap. The administration already has enough trouble without wondering why they should purchase your product. By removing that, they will be a little bit warmer to a pitch. You do of course, still have to pitch :1. But in it, you would want to maybe work out an arrangement where you can collect relevant data for future pitches and what not. Impact on Student Education overall :2, student/teacher testimonials. Why? Schools seem very receptive to what other schools are doing, students are very social and there always seems to be talk about what other people have. I've noticed that among colleges a good deal of the intranet is shared (same email solution, same billing, same online courses). Or even to use a bigger and far more broken example, look at how quickly Facebook took off among college students. After your foot is in the door, you can refer back to how it helped this school (because if something is beneficial and THEY have it, WE want it too. 

I think your issue is that you pathfind towards the players tile rather than to a tile that he can be attacked from. Since there is no actual path to the player in that case, since diagonal movement isn't allowed, of course they can't find a path. If you just want them to get closer you can put a maximum on the number of tried nodes and always move towards the minimum of your heuristic.(In which case I'd recommend the manhatten metric) Or you could change your metric a bit so that it's 0 when you're at a distance you can attack from. 

A good way to think about it is this. You can always break the textbox up into 9 bits, top left, top center, top right, etc. Now the corners will basically always be the same size the top and bottom side will be stretched along the x axis and the left and right sides will be stretched along the y-axis. The center will be stretched along both axis obviously. So the question is then how do you draw each of those. Drawing the corners is easy since they always have the same dimensions. But for the sides and the centers you have a few choices. If the textures for them tile you can just scale the sides and their texture coordinates up to fit and use sampler state wrap so that it tiles naturally. You want to make sure to round your scaling so your highest uv coordinates are integers, so that the tiling continues properly towards the corners. You could also not scale your uv coordinates and just let the image be stretched if it isn't (too) noticeable. And for the center you can do essentially the same thing. TL;DR: You don't really need to figure out how many of those pieces to draw. Instead thing of just 9 parts that make up a box and draw each of the parts appropriately. 

Apache Server, Flash, PHP, Javascript, and a few other things. Source: $URL$ This may not be 100% accurate, but it at least lets you tell what technology that front page is reporting. 

As for your sidenote. IMO: It may drive off some 'core' gamers (The group that commonly considers themselves the majority of gamers.) but looking at the success of casual games. The numbers seem to say that either the larger part of the market is of a younger / older age. Or they are the only people spending the money :p 

I do not believe that an end-user is able to redeem credits. If they were, then Facebook Games might constitute gambling and that would cause problems. You can find the entire Facebook Credits Policy here. If you are interested in applying for the credits beta program, click here. $URL$ 

From there, I take out my tablet and draw my own notes over the map (in art-editing tool of choice). 

From the problems that you are having I recommend that you do the following: First, work with layers and folders. It really does help, Group individual sprites together in folders so that you can move the whole of them around and parts that are replicated should exist on seperate layers. (So if there is a sword or something it should be on a layer, eyes should be on a layer, etc). Thats where the real power of these type of applications are for such a task. If you mess something up, you don't mess it all up just that layer. Then, enable the ruler and enable the grid. (Also take the time to set them up correctly in the preferences menu). If click the ruler and drag away from it, you can create guidelines. Setting up your own limits using the guidelines will allow you to snap the sprites (which should now be in folders) to the grid lines allowing you to position them far better. Then finally, if things still seem a bit out of phase when the animation is playing. If you zoom all the way in (you may need to make sure this is enabled in the preferences menu) you can see an individual per-pixel grid. Which should allow you to place things exactly where you need them to be.