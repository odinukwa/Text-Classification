I had no idea if I should reset X or Y position after collision. Collision handling. I'll handle collisions only when entities are moving (currently only character entities, later projectiles and some special tiles) 

if entity is tile -> do nothing if entity is character -> check collisions with characters and tiles and reset movement if collision happened 

If I were to implement grid or quadtree for collision detection, when should I populate it, when update? Should I update it every time I move one entity, or should I try to come up with a way to move all entities at once, then build grid/quadtree and only after that try to handle all collisions. So my questions are: (1) In this scenario how and when should I do collision handling? My current implementation works, but I think I do it too often and all examples I looked into grids/quadtrees assumed that I do first all movement and do collision detection and handling after. and (2) When do I clear/populate/update my grid/quadtree. For example if I have 3600 tiles and 3 moving characters. Should I seek for entity each time one moves in the grid and try to move it to different grid cell / tree branch? Edit: What I'll propably try next unless anyone gives better advice Updated update step. Is this smart or in anyway reasonable way to do this? 

I've had the following problem before when I tried to handle both X and Y movement at the same time: 

Im using SFML 2.1 for graphics and my game structure follows SFML book quite closely (SceneGraph implementation etc) My world consists mostly of characters (around 1-400, moving around) and tiles (3600, stationary) and I'll check for collisions everytime something moves In worst case scenario with ~400 characters moving around and ~3600 tiles, I have 4000 possible entities with collision and 800 collision check calls (separate X and Y movement) each frame -> 3.2M collision checks in total. Almost all my entities have size of 16x16 pixels and I've been looking into implementing either quadtree or simpler grid for collision detection, which should bring number of collision checks down quite a bit. By grid I mean $URL$ But I have no idea how I should implement simple grid for example. All help is welcome. There's propably even a lot better ways to bruteforce this. Entity update step. I do X/Y-axis movement separately. Because I want to slide against entities when colliding diagonally. 

From the video showed it just seems to be plain gravity to me. Most people think gravity makes things flying downwards, but looking at it from a more far away perspective it makes things fly in a elliptical or spiral kind of motion around the center. The particles are always accelerated towards the center, however fly beyond it until the gravity forces it to come back, again and again. Some particles fly so far that the gravity doesn't affect them so much anymore and end up burning out before changing their direction. Each particle has a X and Y velocity, to which each frame the gravity is added to, depending on the angle and distance to the center. The gravity always adds velocity into the direction (angle) of the center. So you have for the particle: position, velocity For the gravity well you have: position, strength From the positions you can calculate the angle between the particle and the gravity well. To calculate the angle you'll need the deltas between the two coordinates. 

The GPL is a so called "coypleft license" that means, everyone who uses it will have release their source code as well under the same license. The GPL does not, in any way prevent commercial use, it does however prevent DRM and restrictions on "sharing" it. And most commercial entities won't even consider sacrificing that. There is the LGPL which only applies to modified code and not to the whole project, e.g. a game could use your engine but still not be avaible under the LGPL. There are many people who prefer non-copyleft licenses such as the MIT license, the BSD license or the zlib license. These make almost no restrictions, aka "Do whatever you want as long you keep this license note" There is also a middle way: dual licensing. There are companies which release their library under the GPL or the LGPL (example: Qt) but for a little fee also give out a different more liberal license. So everyone can use it under the terms of the GPL, but if they need more they can pay for it. 

The document just describes a particle system. Particle systems are nothing new, the difference with the demo is just that it uses the geometry shader to generate the geometry needed for the single partices. You can do the same on the CPU, the only drawback is that it is slower. Everything else can be done on SM 3.0 in a similar way as described in the document. 

I am trying to use a particle system/emitter in Slick2D to produce a thrust jet from a space ship. I can get the emitter running continuously without any problem, however I can't get it to run for a fixed duration when I press the thrust key (which I need to do so that it only emits particles when the thrust is active). Note I can get the emitter to run for a fixed duration once when the program starts, but can't get the emitter to restart afterwards. I have variously tried (all attached to the thrust key press): 

... which either do nothing (no particles) or give a short burst of particles at the start of the program (for the initial emitter length if emitter length is enabled), but then do nothing whenever I press the thrust key. The last option (running 2 emitters) causes the particle system to run out of particles after about 10 seconds. Is there a way to stop and restart a particle emitter that will give the effect that I want? Just to cover any initial questions, I have read and re-read the javadocs (which are, as ever, reductive and unhelpful) and have read what I can find on the internet (mainly FrumsNL videos on youtube, which mention but don't cover this case) as well as doing my own trials as per the list above. Any help gratefully received. 

I have then just disabled or enabled the length option (which gives a fixed duration to a particle burst if enabled) depending on whether thrust is engaged or not, i.e. if thrust on then disable length, otherwise enable it (I have this set to 10ms in the xml config file). This gives nice, organic puffs of thrust when I 'feather' the thrust control, which is exactly what I wanted. (From my ship class) 

After a lot of research and continuing development using Slick2D, I have decided that the only way to do this in libGDX would be a fundamental re-write. After some tests, it also turns out that this is a Good Thing. The solution I have tried is to hold the data for the graphics in arrays, use TreeSet indexes to be able to quickly locate which items should be on screen at any one time and then draw these once per loop. Per loop, this removes the getSubImage() call and repaint of this sub-image to the main graphics canvas. Having tested the approach with both the old graphics-based class and the new array/TreeSet-based class the difference in performance is significant. Using the graphics approach the game runs unchecked at about 205 FPS. Using the new array/TreeSet approach it runs at around 280 FPS. I've included an edited version of my Stars class here to show how this works in practice. This is the simplest case since the stars are simply dots on screen. It gets more complicated for other shapes, but the logic is essentially the same except for having to check for objects being partially on-screen, i.e. check all vertices. I've also included a small class below that I use for the TreeSet indices used to search for on-screen objects. Both use dyn4j (physics engine) co-ordinates for the stars and also for the edges of the screen (picked up as an Observer of another class) to calculate what should be shown on-screen. 

The big advantage is that you will have much greater artistic control over it, since you can create textures like this with almost any application and can replace them by more complex sprites if you ever want to. 

For calculating things less often while catching most errors from this you'll need to predict if the object will change the grid cell it is in soonly. 

If you really want the player to influence the jump even more you'll need to decrease the influence over time. 

There is nothing on the client side which can not be faked, everything somebody has physical access to can be manipulated. The IP contains routing information and thus hints on the location. But the player just needs a proxy and whoops... the IP hints at a completely different location than the player actually is. Trust your players, don't give them a reason to try to trick the system in the first place. 

There is no way on windows to get "direct" access to OpenGL (e.g. load a header and link a lib), instead you need to ask Windows to give you the pointer to the different functions at run time. So you need to define a bunch of function pointers like this: 

The most important difference between Flash games and Android games is that Flash games are pretty much exclusively financed by ads while Android games are partially financed by ads, partially by selling the games themselves and partially by in-game purchases. For the customers that means they don't have to pay for their games, they can play as many games as they want and can try out any game at any given time, this means, in the end that if your game is good it will get at least some attention. The downside is, you are bound to have a lot more people to play your game, because the average every player will just give you a penny or two as opposed to a dollar or two for android games. Conclusion: 

You just need two different clocks instead of one, one for the time relevant to the gameplay and one "true" time. 

Is this a PvP game? If so you should look at ELO ratings: $URL$ There is a pretty basic idea behind it. Each game changes your rating, this change is solely based on your rating and the opponents rating and wheter you have won or lost. 

Solved it. The second line below fixes the problem (I included the first for clarity). By default, if the emitter completes its cycle it is removed from the ParticleSystem. Disabling automatic removal means that you can restart the emitter. (From my shipflame class) 

For future reference, I had a look at the Slick2D code and resetState() calls replay() and replay() also calls reset(). So, if you want to restart the particle burst use resetState() since that covers all the bases. 

I got around my problem by re-writing my code to remove ComponentListener. Doing this I got a single response to a left-click (or right-click). This doesn't differentiate between left or right-clicks - it just picks up clicks, but that works for me. My test code is posted below. 

For any basicgame or gamestate that you write in Slick2D, you have to override the render method and so you always have control of what renders and when. You can build in logic to only render if something has been changed by a user at that point. Alternatively, the call to render() in each loop is done from within the AppGameContainer (which extends GameContainer). In theory, I guess you could override the methods there to control when rendering takes place from that point rather than in a given basic game or gamestate (i.e. for the whole application as opposed to on a per gamestate basis). Either way, that could be a lot of work if you have a lot of things to track in your level editor just to reduce the rendering overhead. If the application is PC-based then what is the problem with restricting FPS to something like 60 or 30FPS and letting it run? I am developing a game that has level menus in between live-action rounds and in the menu states the application barely uses any CPU at all. I see about 4% cpu usage when scrolling around a map on-screen for example (that's on a 2.4Ghz quad-core system, but it works just as well on an old laptop). Also, if your level editor is gui-based (i.e. a real-time, drag and drop affair) then won't you need regular graphic rendering anyway? And finally... I have just tested stopping the rendering after setting up the screen in one of my applications and the screen just goes blank. So that leads me to assume that the render() method is also ensuring that the screen is refreshed or that something at the AppGameContainer or GameContainer level is clearing the screen before each frame. Overall, I'd recommend just restricting the FPS to something relatively low, e.g. using: