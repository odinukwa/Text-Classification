When second dao fails to delete and you have transactional daos not service, the first entity is lost. And you method should not return boolean, but let bubble the exception up into the service layer and let service handle the exception. 

Do not throw NullPointerException when arguments are null. NPE is thrown when you are trying to access properties and methods of null reference. Not when you are checking on some preconditions. Throw IllegalArgumentException as you do in length validation. In other method you use assertions. Chose one method and stick with it, dont mix them. You don have to define empty constructor. It is created implicitly. 

Classes in model layers should be aware only of interface of underlying layers (DAOs or something similar). If it contains than you are telling your business model what view you are using. Send text from textfield directly in you service (model) methods. Or better send them some DTO wrapper object. You misused and . belongs to the controller or view layer and belongs to the model layer and check the business requirements. Also you duplicate the name of the cities. When you want to add new city you have to change the model and the view. Put them in one place (maybe something like CityRepository accessed by the Model layer classes) and get the cities from there. So to recap Model is businees view. It should contain validation and perform your business task (in your case some traint icket processing) and should be aware only about data model. View should be aware only of controller and provide interface to interact with and methods how to get the data from the user Controller Drives the flow - it gets the data from view, wrap it in some business objects (like TrainTicket, User, etc...) and pass it to the model, takes output from the model and present it through the view. 

I have made the arrays into objects so that it this is easier to edit. I doubt it makes enough of a difference to be noticeable. That is, I replaced with a structure . It may be worthwhile to change them back though. Reduce comparisons by navigating a 1 dimensional model of the map instead. When you call you can generate a set of for a given map. For the terrain_map provided and a mobility index of 0, this would be the following array: 

(spacing to demonstrate relationship to terrain_map) With this array you can start with any coordinate and convert it into an index in this array via a the function and back with its inverse function. Once you have that you can move up or down by adding/subtracting and left or right by adding/subtracting from the index. Since this array is a padded version of the map, you never have to worry about wrapping around because you cannot move to these fake coordinates that make up the padding. This may or may not wind up actually being faster (it depends on how big your maps actually are and how easy the set of paths were to compute in the first place). code: 

In Option #2 you cannot be sure that user of your class will pass new Object as a parameter. If you really want to create a clone of parameter you should create on yourself or implement some method on MyReferenceType 

I also think that methods like Should take a File instance as an argument - it should be responsible for writing to the file not opening it or creating some directories. Same for readFile method. 

It is a bad idea for a constructor to contain non-trivial code. Constructors should assign values to fields or another simple actions. If you need complex initialization, you should use factory object or factory method 

I would separate calculations of shoe sizes and distances into separate classes. It is called SRP Name your variables properly is just a random letter not a name for a variable. For methods with a lot of arguments you can use some wraping object 

While these examples are pretty far out there, consider if your Queue class were complex enough that I might want to add an extension method to it and need access to internal variables in the method to do some algorithm in a way much better than possible with the available public interface. 

The controller is vulnerable to automation. If I can discover a list of user ids I could create the following html page: 

I would write this as an extension to the Sizzle engine rather than a jQuery plugin; I've made a few other minor changes as well: 

Before I do anything else I feel compelled to clean up your spacing convert " to ' to consistantly use only one type of strings 

This looks mostly fine by me (ignoring Reflection and other more obscure sources of thread safety failures), but I wouldn't call it a Queue per say (because of the duplicate check there). Does it really matter what order the set of items in this collection are in (if so then the duplicate check introduces a bug in that ordering, if not then why not call this a )? One change you should really make is adding to your private members. Also, while this looks thread safe, there is no reason to assume that it is safe to use any of the items inside of it or any inherited versions of it. Consider code like this (intended to obviously be unsafe): 

And don't mix classes from primefeaces and dao as suggested in axels comment. When creating this wrapper convert this view classes to some custom backend classes. in some object. I have class. It is much readible and convenient to use. Instead of use CollectionUtils.isEmpty I recommend you to extract nested ifs and loops to methods. Maybe when you extract them you will find some place where you can remove duplication. 

If there is no formula to calculate shoe size from one unit to another i suggest you to put sizes in some data structure and map them together. For example in Map. Then you just query the map instead this if-else hell. Same applies to the mapping. Also i see you use Strings a lot as a constants. Consider creating enumeration of some of them. 

cache your jQuery objects reword your condition so that it is more readable parameterize the animations and pull them out into methods of their own move your initialization code so that it is all together 

I was going to make this a comment to Dan's answer, but it started getting quite long (and I wanted to try and actually code it to see if I remembered how). Assuming is big and doesn't change between builds of the application (or if it does you have the ability to replace a single dll), you should build a dll containing the compiled regex representing it to get a much better search then you would if you used that linq expression. 

This code looks mostly fine to me, when the method gets called, gets moved to and then when happens, gets deleted (and eventually garbage collected unless a reference to it continues to exist somewhere else). However I think you could do better by encapsulating each route in a function that takes care of and for you. Something like: 

What about having generic abstract dao class which will contain these methods? You will most likely have to create some concrete dao classes anyway to have specific methods. We are using this approach in our projects (behind JPA facade) 

EDIT Also do not put on your DAO classes but on Services. Service method describes unit of work which should be done whole or rollbacked. Consider this simple code 

First of all name your variables properly. Name of the variable should describe what it is, but is just a random letter not a name for variable. Consider using logger instead of printing to sout. Stream closing should go to the finally block not in try. You are nesting a lot of loops and ifs. Try to separate it into methods soo you and up with 

Assuming is unique (if not then so you get the exception for more than one element). In both cases you should probably catch the internal exceptions and throw your own in its place to hide the implementation details (or specify in the method documentation that it will throw these internal exceptions, but I would think of that as bad practice). 

Back on topic: In my opinion, it is a bad practice to force the Javascript engine to go looking for your globals when you are not in global scope due to leaving off the window qualifier. Thus everywhere you reference without calling it (and the same goes for ) or caching it in a local variable is wrong. In the event where you run this script outside of a browser that implements you will get an exception. is slightly less of an issue because it is a reasonably safe assumption that you will not run this from a browser that doesn't supply a global namespace. For this reason I always pass the globals that I am going to use into my IIFE: 

Your method is very long. This is code smell - if method is long it maybe do a lot of thinks, but method should do one thing. I suggest you to split method into smaller peaces which defines smaller units of work and are reusable and easy to read. If you put piece of code into method you give name to the code which work as a hint to he programmer what code enclosed in method does. Also use full name of variables, not some abbreviation like . You write them once (if you are using ide) but read it multiple times so you invest the effor into the writing the proper name. I did not checked your logic. Your logic should be captured in unit test - if there is no unit test i would hesitate to refactor some code. If there is no unit test dont write them now if you dont have business requirements, but you ca try Characterization testing to capture current behavior of the method. Because without any test you cannot be sure if you did not broke something when rewriting the method. 

(unable to check correctness right now due to not sitting at my work machine, but barring any syntax errors I think that is right) Am I doing something wrong here? I think a static constructor is fine for the singleton pattern as well, but I am not 100% sure it covers all thread safety issues. I don't see how a single lock object wouldn't though. 

ignoring immutability and such (like having a getter and no setter for FlatSideArea that computes on the fly)... What you are basically implementing here is an internal usage of the INotifyPropertyChanged interface. If you are going to implement that interface, I suggest you actually do so instead of only sorta partially doing so: 

But it is even better to be commented out or otherwise removed since you aren't using it anywhere. Similarly: