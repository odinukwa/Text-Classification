Again, is it worth it? Sometimes the clever thing is not to be too clever, and keeping it simple beats trying to make it pretty. 

from (minus the case sensitivity discrepancy). Unless there are some good reasons not to do so, I'd stick to only one implementation and reuse it in both methods. 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

There's no use in putting "generic" in the name. Any C# programmer knows that indicates generics by itself. Case in point: in .NET we've got and - not . (So "drop the the" ;) ) 

Indeed, did you test how it behaves for very large (or very small) values, nevermind the performance? What will happen if I multiply by another one? What is supposed to happen? 

the else-return bloc doesn't serve any purpose. The same with calls at the end of methods (, , , , ): redundant. These methods are exited anyway. You don't need to use both and clauses. It's one too many. Eg.: 

It compiles, since ᒿ != 2. But it won't work for every digit - see $URL$ if you want to try. Even if it did, I wouldn't recommend doing this in production code :) All in all it's a fun thought exercise, trying to find a workaround and kind of trick C# into doing something it's designed not to. But the truly elegant way is to embrace the language the way it is, and not try to hammer square pegs into round holes. If you were hell-bent on using extension methods, at the cost of being unable to rule out illegal values in compile-time, here's make take on it - more heavy-weight, but providing type and conversion safety. I did it for the heck of it, I know it's not the perfect solution. It resembles @radarbob's answer in that it puts extension methods to use. Let's define the basics (it can all go into one static class): 

Using a rather complex macro rather than a function or multiple functions greatly increases the complexity of the code as does goto statements hidden in macros. The largest problem I see with this code is that it is almost impossible to maintain. Programmers, software engineers and developers generally work in teams. You may be on vacation, you may have won the lottery, or someone may have left you five million dollars when this code needs to be updated. Trying to insert a line in a macro can be a nightmare. In the days before the ANSI C standard (before C89) large blocks of code like this might have been Okay for performance reasons, these days is best to write small functions that do only one thing and build the program up from the small functions. It's difficult to get a large macro to compile since any syntax errors are all reported on the same line. It's difficult to debug because most debuggers will only show the macro, and any errors that get thrown are all on one line. If you want to clean things up after an error in C, you might want to look into setjmp() and longjmp() and include setjmp.h in the file. 

The function execute_biological_sequence_analysis() can be broken up into multiple functions as well. Here is an example of what the program might look like following the Single Responsibility Principle. 

Which reduces the complexity of the function and reduces the number of assignments to fields to 1. Use of Fixed Sized Arrays If the structs keep a record of the capacity of the arrays, they could start at a much smaller size (1024) and be reallocated as necessary when the m_Count value reaches the capacity while this performs slightly slower than what is currently implemented, it uses much less memory than the current implementation. Prefer Linked Lists for FIFO Structures It is much easier to implement FIFO structures as a linked list, then the becomes a simple removal of the first element in the list. While this does prevent with indexing into an array overall it is faster and more flexible for LIFO structures to be implemented this way. It reduces all the copying that is currently going into implementing LIFO structures. 

Now you can't call eg. . Other than removing the "m" prefix from the parameter name, I wouldn't also keep it named "activity". It's an class, not an (instance object) itself. I'd rename it to . 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

So how on earth is it able to correctly detect whether is present in the collection? Standardization Custom collections should support standard .NET interfaces such as IList. Otherwise other code can't really use it (other than as an ) unless specifically refactored to do so. Besides, your implementation doesn't allow inserting an element in between pre-existing elements, which pretty much defeats any major benefits of implementing a collection as a linked list. Generics As @MatsMug remarked already, it's supposed to be generic, yet - same as your previous implementation - it doesn't support , only its non-generic, legacy version. Documentation It's good that you now use documentation comments (at least for a class that's supposed to be of general use). But this "this is" (as in "this is a singly linked list data structure" or "this is the Node class") is unnecessary. It's just fluff. We understand that it's a class, and that the comment must refer to this class, not some other class elsewhere. Typos don't make great impression either ("Implementatoin"). If your class is opinionated about nullability (which is an improvement over your previous submission), this should be described in documentation comments. As of now, your comments are stating the obvious, for example: 

These should be defined in the HPP file so that they are shared with the implementation of the function and any functions that call the init function. Please note that the call to the init function in contains 8, 0 and 16000 which are also magic numbers. Anyone that maintains this code is going to wonder why these values were chosen, symbolic constants helps them understand what the code is doing. It also allows the code to be changed in exactly one place if the values need to change. In two years time if you have to come back to this code you may not know why you chose these particular numbers yourself. Prefer Clear Naming over using namespace std According to the [MSDN website]: 

Use Sybolic Constants Rather than Numeric Constants There are a number of numeric constants such as 6, 100, 0.1, 0.5 that could be represented as symbolic constants, here is an example of two of them 

Possible Bugs The calls to are not tested. The functions and can fail when too much memory is allocated. When they fail the value returned is NULL, access to fields from a NULL pointer result in unknown errors, but it generally terminates the program, it is a good idea to always test the return value from or prior to trying to use the pointer. It is possible that the code in the function should changed in the following manner: 

This is somewhat more readable and maintainable that multiple if then else if statements. It is much easier to add a new than it is to add a new else if statement. Another alternative would be: 

The variable x needs to be one greater than the length because --x is tested at the top of the loop. 

since (answer == 1) is a Boolean condition. The second is unnecessary since it is an unreachable statement. 

This is a nice first Code Review Question. It's not a simple hello world program and it took some real effort. Use the Tools You Have When developing new code in C++ always compile with -Wall switch. This switch provides additional compiler error checking and allows removal of possible bugs as early as possible. The compile can also treat all warnings as errors. When I compiled the code I got the following warnings: ../src/SudokuSolver.cpp: In function ‘bool isNumeric(const string&)’: ../src/SudokuSolver.cpp:46:41: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] for(int itr = 0; itr < input.length(); itr++){ ../src/SudokuSolver.cpp: In function ‘void strToUpper(std::string&)’: ../src/SudokuSolver.cpp:56:37: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] for(int itr=0; itr ^ ../src/SudokuSolver.cpp: In function ‘bool squareContainsNum(subSquare ()[9], const int&, const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:208:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ ../src/SudokuSolver.cpp: In function ‘bool rowContainsNum(subSquare ()[9], const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:231:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ ../src/SudokuSolver.cpp: In function ‘bool colContainsNum(subSquare (*)[9], const int&, const int&, const string&)’: ../src/SudokuSolver.cpp:254:1: warning: control reaches end of non-void function [-Wreturn-type] } ^ Type MisMatch When using any C++ container type that has the function . the function returns type . The type is currently defined as unsigned int. Comparing or assigning type to type can lead to surprising results because a positive unsigned value may become negative when it is converted. The loop should be recoded as 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

But why would you assume that whatever time passed between opening the connection and disposing of the entire object, was consumed by query execution? Especially since you do this at the very end, after disposing of the connection, params object, transaction and command objects :) and the object is apparently supposed to be reusable (). Disposing 

and are . Did you test what happens for very large numbers? All your tests use trivially small values, certainly not the ones that would warrant the use of . Lagging constructors are a big no-no. I would aim for lazy evaluation here, or at least replace the constructor with a static method, with a name indicating it's triggering a process (create, evaluate, convert?). Constructors should be fast as lightning. 

Who would have thunk! Not too informative... In contrast, this code doesn't comment the non-obvious stuff. For instance, now your class has a certain policy regarding nullability - which, as I said, is by itself an improvement over the previous code, where this policy was sort of accidental. But is it obvious that throws an exception whereas is ignored? I wouldn't have guessed that correctly, and yet the documentation doesn't say a word about it. It's too busy telling me that element is element. By the way, it's not just a question of documentation - I'm not sure I like this asymmetry in principle. And it isn't the only inconsistency lurking in the implementation, either. For example won't crash when the list is empty - but will if there are already elements in it. What's the rationale for that? :) That's not predictable behaviour in my book. Speaking of , this comment is just plain wrong: 

And again this is subjective, but I see these as a (common) anti-pattern. It's code, not a painting or a poem ;) We've got version control systems for that. 

A second specific question I have is would it be better to use over in the above function. EDIT While I am specifically interested in STL improvements, all observations are good, since I'm far from perfect. GetUserInput.h 

Nice first question on Code Review, and definitely ambitious. There are a definitely some good habits shown in the code, such as the guard banding in the include file and the include file including all the other header files it needs. The code isn't quite portable. I tried to build it on Linux rather than Windows and got compilation error messages. It might be better to either write portable code, or at least name the targeted operating system in the question. Global Variables Many software engineers consider to be evil. The use of global variables makes code harder to write, debug and maintain. It creates tight coupling between modules. The libasc.h header file contains 

Use the Features of the Container Classes and the Standard Template Library You may find this website useful for learning all of the features a particular container class or the standard library. There are definitely some functions you could be using, such as , , std::count_if() and that could definitely shorten the code. It might be wise to investigate std::map as well for counting words. GOTO There are almost always ways to avoid using in C++. In rare cases may be appropriate for error handling, more so in than in because has try{}/catch{} and exceptions. In the following code there is really no reason to use a : 

You should use a switch statement, that will at least be easier to extend and maintain. The switch statement will clean up the code by removing all of the else if statements. The code doesn't need enclosing blocks for multiple statements. The switch statement only shows one condition although it tests for all the conditions listed by the cases. To add a new condition rather than adding a new statement all you need to add is a new case statement. The statement is needed in this particular case to move on to the next iteration of the loop. It is possible to flow through multiple cases if the statement is not there. The link above shows an example of flowing through multiple cases without a statement as well as the normal mode. Switch statements are common to C, C++, VBA and some other languages as well as Java. Here is the code re-written using a switch statement.