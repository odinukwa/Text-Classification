Indentation. If you are using Eclipse, please select all your code and press Ctrl + I. Your entire for-loop should be indented one step further. Use methods. One method for inputting a String, one method for making one iteration of the "decompression". Did you forget about how to properly use suddenly? You use as a condition for your while loop, that makes sense. But then you're using a for-loop to determine the location of the and characters you are going to work with. This makes no sense to me. Better variable names. Thanks to your comments on your question, I managed to figure out parts of what you are doing and write a review about that. However, Daniel still has a point that your code is not readable. Close the scanner. Your scanner is a resource that needs to be closed, call as soon as you are done with the scanner (that is, after you have received all the required inputs from it) Potential problems. What if I want to encrypt the string , how should that string be encrypted in order to be decrypted correctly? Or what would happen if I gave your program the input ? I believe your code would have a hard time with that. 

This approach is essentially the same as @rolfl's, but his way of using streams totally beats this. (I think, until someone benchmarks) Either way, using a and a inner class is a bit (ha-ha) overkill. Back to the topic of... My approach did cause a break in your unit tests though, which leads us back to the topic Choice of datatypes and Don't be dependent on the implementation of . When I used : 

Note that "option b" might not do the exact same thing, as it lacks which means that the margin-left can be applied from elsewhere. 

What you need is to use a common base unit that all your other units converts to. For example, let's take a look at this: 

This uses the Math.abs function to perform the calculation of how many stars to print. If we take a look at a plot of the classic Math.abs we can see that it looks useful. We need to flip it upside-down though, this is done by taking which would look like this. Finally, we need to switch it to the right a bit, so we modify the input to the function call and end up with this: 4 - abs(3 - x) Images courtesy of wolframalpha.com 4-abs(x) 

Usage / Test Available to play here! Questions My primary concern is with passing on the to the screens. I am perfectly aware that I can extract an interface, but is it really worth it? The screens would not be useful without this game, and the game would not be useful without those screens - is it worth decoupling them? It seems to be very common for LibGDX projects to pass their main game class on to other classes - many other projects even use the , , etc as package-private fields which I wanted to avoid, I think I prefer a getter instead. My secondary concern is the data structure for the sequence. I don't think there's too much wrong with using a here. And I still want to support different sequence generators. My third concern is everything else. Comment on what you want. Note that I am fully aware that the "graphical design" sucks. Luckily, this is Code Review and not Graphics Review 

I also think that you should make better use of the keyword. There are several fields in your classes that don't need the "default" visibility but should rather be marked . Besides this, I agree with Quonux's answer (except the first part about or which you are doing totally fine). 

Imagine if I put some code in the same package and did Now I broke your program! This one needs to be 

How about ? Or some other way to access the already existing without the overhead of turning it into a ? Edge case Consider this code: 

Because of the result String being of a size that can be pre-determined, and you are handling chars on the way, I would use a (char array), and transforming the char array to a String using a String constructor. I believe this is more efficient than using a or any other approach. 

The zero here indicates the exit status, which can be used by scripts and other stuff. If a program terminates normally, that is exit status zero. Is a possible division by zero really a normal program termination? In my opinion it is not. I would do or or something. 

But as you're just creating a new file object for the same file, you don't really need to create a new file object at all, just use it directly. 

Your factory method takes an existing , but you don't provide a getter or anything for the , which means that you could also provide an ordinary 

Create an empty list, here called Loop from 2 to 2000000, call this number (as in your existing code) Check if the number is divisible by any item in the , if it is then is not prime so go to the next iteration. If a number was not found in step 3, then add to the 

Note that I think would duplicate a lot of code, so for this operator you should loop through the mesh / grid and only use the method to add the values together. 

It's quite easy, but I think it could use a bit more documentation. And I also think that it's not entirely clear which parts are your API and which parts is your implementation here. 

These variables should be and the should be declared as to allow easier switch to another List implementation. 

However, as this would make it hard to remember the ordering of the parameters, I suggest that you look at the Builder pattern 

(Consider throwing an exception for this by the way. A mistake is important stuff) Naming Whatever is doing (A quicksort I guess), the name is too short to be meaningful. Name it instead. Name your methods for inputting things as : 

When using Hibernate, you have the ability to tell it all about the one-to-many/many-to-many/one-to-one/many-to-one relationships, and tell it when to cascade operations for you. Here's an example of how your could look. 

No. Absolutely not. I don't really see why you are using the to do that. You could write a regular Java class for holding the main component of your library. Or rather, you could let the user of your library determine how to hold the main component of your library. Instead of using the method of the , you could let the user initialize the object in the of a regular . 

There are two things I want to point out that has been shown in other answers, but not pointed out why it should change like this. In this code: 

Let's read it out loud, shall we? "If not someActivity's finish time is less than or equal to nextActivity's start time or nextActivity's finish time is less than or equal to someActivity's starting time". There are two words in this sentence that makes it hard to grasp the real condition: One word is not and the other is or. The fact that you're using more parenthesis than necessary also complicates things. Let's split it up: 

Brainfuck Multiplication Elaborating a bit more about 200_success' multiplication, and the "shorter, less readable version, using similar ideas, but with more cell reuse": The ASCII values of what you want to write is, as 200_success mentioned: 

Why are you creating all these classes if you end up hardcoding all the values anyway? There are two parts especially that I would make more flexible: 

Using is not a good practice!! Instead of using , use a do-while or a loop. You want to do something as long as the answer to "Do you want to continue" is "Yes". This is perfect for a do-while loop. You should also avoid using and instead use a for-loop to iterate through the array. It could also be solved with recursion. Use anything you want except the statement! 

I'm sorry, did you just call this a framework? Never in my life have I seen a framework where I had to edit the sourcecode to make it usable. Let users of the framework pass the to the constructor instead. And while you're at it, can I please have a public method from the class? for example, it'd be ideal as a public method. 

I have to admit that this is the first time ever that I have seen that method being called. When reading the documentation for this method, it seems there is a good reason for why I have never encountered it before. 

Now, when this loop finishes, contains all the parents that was not empty. Now you can loop through that using a loop, or use it with or whatever you'd like :) 

Many of your variables can be marked as . All of them can be marked and those who get initialized directly and never change should also be marked . These include: 

Make your code self-documenting. Your "explanation" of your code in the beginning of your question confuses me more than helps me. Self-document your code by using proper variable names. can be called instead, and i and b can be called something that explains what they are doing. Right now, I can't exactly understand what they are supposed to do. 

What your original code here actually does is that it's taking the value, which you initialize to and then it's changing the internal integer value stored in the enum. You never change your variable from , but instead you change the integer value of the -state. That's definitely not how enums should be used. (You're also using the variable name which defies Java coding conventions that variable names should start with a lower case letter) So, by changing the code snippet in the way I suggested above you will get rid of a lot of the "magic numbers" 0, 1 and 2 by using your enums properly. You will also improve readability. You won't have to remember "Which state is 2" anymore. I would also mark the enum type itself with like this: because the is not dependent on anything in your outer class). I would also mark its constructor with - or rather, I would get rid of the constructor entirely. There is no use for it when you remove the and methods. You can use if you really want to access its int value (which you should generally try to avoid but is useful for things like serialization). The method returns the index of the enum. Other variables I would rename your to simply . is a naming convention for a method that returns your internal boolean value. You also have one boolean for if the timer is running () and one for if the timer is paused. This confuses me a lot. If the timer isn't running, then it's paused isn't it? Or should the possible options be , , ? In that case make it an (without any getters and setters!). On click I also agree with @thepoosh about defining for your buttons in the XML, unless you're targeting Android API < 4 (which no-one really uses anymore). For information about using in your XML, see the Android documentation.