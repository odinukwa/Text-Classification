will traverse your entire filesystem and tell you where the cross compiler lives. Let's say it printed . set and try again. The argument is there so that won't try to look through things like or and possibly have bad side effects. If you have , , and so on, on different partitions, repeat the command with the root directory of those partitions. 

The total throughput of all the connected devices cannot be more than 480Mbps. Recall that the Ethernet port also goes through the USB. Don't try to pull more than 100mA from each port. 

None of this is Pi-specific, but here is your answer: The problem is that you've set eth0 to . Go back to having it on . That you are running a dhcp server on does not change the fact that you need a dhcp client on eth0! 

Let me try to un-confuse you :) In the good old days, computers came with serial ports. The standard is known as RS232. These slowly disappeared, first from laptops and then from desktops. These days, you can use either internal cards, or USB-to-serial adaptors (but read on). The serial connection on the Pi (also on Arduinos and other such things) is not real RS232: real RS232 signal levels are -3V to -25V for logical one ("mark") and +3V to +25V for logical zero ("space"). What's on the Pi, on these cables you are talking about, Arduinos, and so on, is a TTL-levels version. Obviously, **do not connect* a real rs232 port to your Pi, or you will fry it. You either need a level converter between your Pi and the real RS232 port, or you need a serial adaptor that brings out TTL-level signals. You have to be careful, because there are also a lot of USB-to-RS232 adaptors (they have legitimate uses!). And that's what the "special cables" you mentioned really are: USB to ttl-level-serial adaptors. Note that they don't normally bring out all the control signals, but what the bring out is usually enough for console debugging. $URL$ should be good enough. Also note that "TTL levels" means that the signal can go as high as 5V. I'm pretty sure (but check) that the pins on the Pi are NOT 5V-tolerant. If you only need output (and don't need to type stuff back in), you can just connect the TX pin on the Pi to the RX pin on the cable, and you should be fine (anything over 2.5V will register as "hi"). If you want to go bidirectional, make sure your cable puts out 3.3V, not 5V levels. One last word: you'll need to set up the proper configuration registers of the SoC to route the UART signals to the GPIO pins. 

The PSU recommended is 2.5A for the pi3, so, you'll need to increase the current. You'll need to find a battery that is suitable to output high current. I know, for example, some 18650 batteries can output 20A on stable discharge. It will depend on the specific properties of the battery model used. 

Regarding this, the output is 3A. So, it must be ok. Personal approach to this: I do recommend get some 3S (11.1V) or 4s (14.8V) lipo battery, which will give you much room (in terms of current) for powering the leds, but you'll need to get a lipo charger (can be found for about 10€ some times at chinese websites) If the game is permanent and doesn't matter how much it weights (ie: not a handheld device) I'll recommend get a car-like battery. There are some with a small footprint than can provide lot of current, but I'll go with the lipo 

The pi A has a micro usb cable for charging, just use any micro usb b type to power it, using the pwr in port. 

It depends on the hardware, specifically on the current that the gpio is capable of give. If the current is not enough, it won't work. The proper (and one of the correct ways) to do this, is hook up a small circuit that uses a transistor or a mosfet. The gpio will turn "on" the transistor/mosfet by powering the gate pin of the transistor, allowing the current to flow through emitter-collector pins. It will be something like this: 

There is several projects for doing this, but the one that I like the most is blynk (that I've recommended several times by now here and iot stack exchange) I've a similar setup at home, where I've a node in the living room that reads a bosch bme280 sensor and controls a led strip with a mosfet (but the setup for a relay will be quite similar). In the bedroom, I've two devices, a nodemcu with a bme280 and a sonoff s20. The nodemcu reads the temperature and humidity, and if the humidity is below a certain value, it will send a "message" to the sonoff that turns on the relay after the humidity readed is higher that a certain value. Also, You can have charts and a lot of stuff to play with, which make it's a great environment to play with. 

Have you actually installed the cross-compilation tools? If so, you have to add the directory in which they were installed to your PATH. For example: 

If you are really ambitious, you can write your own code that continously reads from /dev/vcs1, and "types" onto the console by using TIOCSTI. 

The length limits come from two requirements: signal quality, and signal delays. A 1m cable will introduce about 5ns of delay (speed of light in circuits is a lower than in vacuum!), so if you are running at 1GHz, there are five symbols in transit on that 1m cable. It this particular case it probably does not matter (it's more important that the signal paths are of exactly the same length), but this is the sort of consideration that most people won't think about. The standard (at least what's open to the public: $URL$ only mentions length considerations for M-PHY ("Distance: optimized for short interconnect (<10 cm) but extendable to a meter with good quality interconnect or even further with optical converters and optical waveguides"); D-PHY is a lot simpler, so it should have no problem with longer lengths as far as signal delays are concerned. As @joan said, a long cable makes you more susceptible to interference from others. It also makes you more likely to interfere with other equipment, your neighbor's old analog TV, or maybe another pi on the next shelf with equally long cables. Hence my original admonition of keeping things as short and as straight as possible. If you are thinking of shielding the flat cable with aluminum foil, you may or may not get a working cable: you will be adding a lot of capacitance, changing the transmission line characteristics. I realize this is probably more detail than you needed, but someone may find it useful in the future :) 

I'm trying to get a pair of I2S microphones working on a Pi2/Pi3. FWIW, it's a pair of $URL$ Here is some relevant output: 

You can run something like or on the console, then connect to it. You can accomplish this by setting things (with ) to automatically log you in on the console and not start the GUI, and having the following as the last line in your : 

In this stack overflow question it said that the issue is caused by " a conflit between two DNS servers : isc-dhcp-server & udhcpd" and it's been solved: 

I've found this, although it's for ubuntu, debian and derivates... but might work. Try configure X for every one: 

I've powered up a raspberry pi 2 and the official 7" screen with a 3.7V lipo battery and a powerboost 1000C by adafruit successfully without any power issues. The schematic is available, so you might want to take a look at it. 

Relays have three pins: COM, NO, NC standing for Common, Normally Open and Normally Closed. It will depend on how you want to interface with the relay or relay module, you'll need to change your wiring. Usually, you will cut one wire coming from the power and pass it to COM of relay, after that, grab the other side of the wire and put it on NO or NC. Applying or removing V on the correct pad (usually labeled as INx on modules) it will change the state of the relay, thus, changing the "state" of the thing connected through it. 

There is different ways of connecting to the pi. You can use a usb to uart (serial) interface to communicate. Here is a good tutorial about how to use it. It's for the Pi Zero, but I assume it could be used for the pi 1 as well. Also, you can configure the pi to appear as a ethernet device. It's explained here. For me, the best way to do it is to connect the Pi to the router with an ethernet cable and power it using the usb. Then, configure the network settings on the pi to a static IP and then access using the mac terminal over ssh. I don't know if the speed is important to you, but the pi 3 is much faster than the pi 1 and the pi 2, so, if you're going to use it a lot, I do recommend upgrading it. 

I suggest you try contacting them directly, and return it if they don't have ARM drivers. There are lots of fingerprint readers with open-source libraries. 

Your shell script is wrong. You need a semicolon between the reassignment of and so that they are run as two separate commands. Also, this has nothing to do with Raspberry Pi; it's a shell question. 

On .33, run From another window, run . Look at the tcpdump output and verify that the DF bit flag is set. On .33, add a host route to .42: On .42, run Repeat step 2. You should now see that the DF flag has disappeared. 

I find it very hard to believe that this can have anything to do with the MTU, especially since you are on the same network segment. I looked through the posts you are linking to, and none include packet captures or any other attempts to diagnose this. Remember, just because someone posts an answer on SE does not necessarily mean they know what they are talking about (that applies to me as well, of course :) ). Before you start futzing around with changing the MTU, verify that this is actually a problem. Let's say you are on and the target you are having trouble with is . Check your interface mtus, they should both be 1500 (if not, modify the diagnostic procedure accordingly). 

USB ports on the pi are limited to 400mA total: $URL$ and it's probably a bad idea to try to draw more than 100mA from each. Exceeding that could lead to the dark side :) You also have to watch out for back-feeding the pi from the USB ports if you have a powered USB device. A schottky diode is highly recommended if you cannot disconnect power from your device's usb ports. What I would do is put the hefty power supply on the board, make sure there is no back-feeding through the USB port, and also use that to power the Pi (either sacrifice a μUSB cable or just solder +5V and GND to the Pi itself. 

EDIT2: I don't know if this will work, but seems to me like the better aproach if possible: Create a software serial port under GPIO and wire the hardware serial port to the serial software port, then, create a python script that starts @reboot and reads the terminal TX and print it on the screen. EDIT3: I've found this. Seems to explain how to create more uart ports. 

So, you will need to check out current consumption of all devices. I've found online that the servos consumption is between 0.25 to 0.75 A. Led consumption depends on the led itself. The current needs will be modified by how much resistance it will face. Raspberry pi depend on what are you using. Assuming Typical bare-board active current consumption will be 400mA. So, you'll be drawing, at minimal power consumption 250x2 + 400 + led_number*led_drawing. = 900 + LED mA which gives you only 1.5A for the leds, which I assume is too low for powering the 5 meters of the led strip. 

Following this link, .xinitrc in your home directory will be read and executed. Otherwise, you can place your script under /etc/X11/xinit/xinitrc (I don't know what OS are you using). So, both ways are supposed to run the script when X server starts (again, don't know what OS you're using) 

The pin1 (3V3) is a "power supply pin". This means that it will be capable of give all the current that the 3.3V regulator has available. GPIOs have a current limitation, depending on the hardware. Check this to know more about max current per gpio. About the resistors to the buzzer. Those are current limiter resistors. Those are used to keep current as low as needed and don't burn stuff inside your controller. It might, and probably will work, but you're risking to burn your setup. 

Raspberry pi on HDMI is an OUTPUT, so, it won't be possible to use it to gather the data from the hdmi. My approach to this will be use an hdmi usb recorder. 

All commonly sold wall-warts are switching power supplies these days, so you are not doing anything out of the ordinary. You can power the 3.3V sensors from the 3.3V pin on the GPIO header. Search the documentation for the maximum current you can draw, but a few milliamps are definitely safe. 

An xterm cannot possibly have support for power saving; you can't power-save part of the screen and have the rest be on! 

The nature of the interface does not enter the picture. If it were something specific to the interface, or to the ARP code, setting static arp entries would have made no difference. Check for spurious packet filtering that your mesh software introduces, in the form of iptables package filters, or, worse, by installing some kind of virtual interface and mucking around with the internals of existing interfaces. In the interests of propriety, I shall refrain from stating my full opinion on the whole HNCP stuff, but remember that the s in shncpd does not stand for smart. 

(I decided to save you and others some time and included an example of a static address). If you really want to route traffic between the wireless and wired segments, don't forget to add in your (or some equivalent place). 

By far the easiest way to do this is to use a bluetooth dongle for the Pi (or use a Pi3), and one of these: $URL$ No fuss, no muss, no worrying about long cables introducing noise or static hazards, no coding to do. 

You are using the command incorrectly, which also explains why you are getting those error messages about . Presumably you want to see what is in the root filesystem but nothing mounted under it, so you should say . The * would have missed any directories in / starting with a period. 

Study the installed packages, startup scripts, configuration files, and so on, of OSMC, and just duplicate those on your vanilla Raspbian installation. You will learn a lot in the process! Move all your project files from the vanilla Raspbian to OSMC (it's also Debian, remember?) and keep working that way!