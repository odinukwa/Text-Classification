I've been banging my head against the wall trying to solve this problem and I couldn't come up with a solution that absolutely guarantees two users can't book an appointment for the same time. The flow and scenario: 1 - The user enters the system and selects a service, say a haircut, and then clicks "Book". 2 - Upon clicking "Book", the server receives the date and time and the staff the user selected to perform the haircut. Based on this information, the available hours the selected staff has are calculated on the fly and sent to the user, who will see something like: 10:00, 12:00, 13:00, 15:00, for example. 3 - The user, then, selects one of the available hours and clicks "Confirm". The problem: Two (or more) users can select the same service and staff to perform that service, and when that happens, all the users will be presented the same available hours. Now, what happens is that when more than one user selects the same available hour, I need to be able to guarantee 100% that only the first will be able to schedule an appointment, and the other will be faced with an error. I could not come up with a mechanism that ensures no racing condition will occur. Note that this is a bit different from transport and theather domains, because I do not have a table with all the available hours to simply flag them. The closest I've come to a solution is to create an extra table, such as "AppointmentsInProgress", and add the starting date and time and the staff to the table, and make both columns unique. Then, before proceeding to process the user request, check this table to see if nobody else is currently scheduling for the same date, time, and staff. However, the performance of this solution is a big concern, and I read that the order of sql commands is not guaranteed, which means if two sqls hit the server with a microsecond of difference, there is no guarantee the first will have precedence. Furthermore, something tells me this doesn't really solve my problem. Any ideas? 

This will, if the table exists drop it, if it doesn't exist wont so you don't get the error. I'd also do your table declarations outside of the 'into' statements and run it as I had some issues around inserting temp tables a while ago, both methods help different aspects 

to generate your static random generator start point the $usersrandomnumber acts as a starting seed see the mysql documentation here: $URL$ it will involve you storing the user's seed in a table somewhere, or cookie /local/server storage but will get you what you're after 

This could be expected behaviour especially if you're deleting based on an index (aka where [primarykeyfield] < targetID) since that delete will take in the ms of time you'll almost always catch the process in the wait time between the two batches Say for example the delete takes 10ms (i imagine it will potentially take less than this but its just an example), the wait time is 2000ms So for every time you run the command there is a 10/2010 chance of hitting that in the period of time the delete is running (less than 0.5%) and a 2000/2010 chance of catching it during the wait for delay. If you want to observe it directly find the spid that its running over and run the profiler over it checking for the search and you'll see the delete occurring every 2s and going into the waitfor (note if you wan to see the start of the waitfor as well check the but the completed one will give you the duration of how long it takes to run each part. 

SQL Server is designed (along with most db engines) with security in mind the main areas you'll look at for viewing users are 

I cant speak for your compatibility, but general performance and security and longevity is always better with the latest version. (you'll most likely get another 2 years of support for a version 2 years more recent) The best thing I can advise is getting a dev licence (which by comparison cost next to nothing) for 2016 and use that to test your system to see if there are any issues and how easy they are to fix beyond the general these things shouldn't be used any more. There's also the question of time, since you've done a full sweep of 2014 it will be far quicker now to upgrade to that, but there's also you should now know all of the tests that need to be performed, so a second compatability test with a new system should go much smoother (and you've already got the fixed up to 2014 bypassing 2012 which had a lot of changes) so the number of required changes from your prepared system and what you need will be (in theroy) substantially less than the set you have already done. EDIT: SQL Developer edition can now be used for no cost with a visual studio subscription or visual studio dev essentials $URL$ 

Rationale: 1 - I will often query the table by only, which is why it is the leftmost index column; 2 - The column can be used for subsequent operations after the first query by (the id will be stored client side); 3 - I will never query by only; 4 - The unique index guarantees insert consistency, though it still slower than a single int; 

In my system I have temporary entities that are created based on rules stored in my database, and the entities are not persisted. Now, I need is to store information about these entities, and because they are created based on rules and are not stored, they have no ID. I came up with a formula to generate an ID for these temp entities based on the rule that was used to generate them: . This formula generates unique strings of the form My question is how should I build my table (regarding primary key and clustered index) when my keys have no relation or order? Keep in mind that I will only (99.9% of the time) query the table using the id mentioned above. Options I thought about after much reading, but don't have the knowledge to determine which is better: 1) primary key on a varchar column with clustered index. -According to various sources, this would be bad because of fragmentation and the wideness of the key. Also their format is pretty weird for sorting. 2) primary key on varchar column without clustered index (heap table). -Also a bad idea according to various sources due to indexing and fragmentation issues. 3) identity int column with clustered index, and a varchar column as primary key with unique index. -Can't really see the benefit of the surogate key here since it would mainly help with range queries and ordering and I would never query the table based on this key because it would be unknown at all times. 4) 2 columns composite key: rule id + rule index columns. Now I don't have strings but I have two columns that will be copied to FKs and non clustered indexes. Also I'm not sure what indexes I would use in this case. Can anybody shine a light here? Any help is appreciated. --Edit Here is what I think I'll be using after reading the comments, and the rationale: 

I may be understanding this slightly wrong so I apologise if I am. If you have two databases that you need to be identical and are on 2014 then use the AlwaysOn High Availability Group. Since you're data centres are at separate locations use the Async mode This will mean the database is kept completely up to date (all be it possibly with a few second delay) and you can have the secondary node as a read-only replica, this means that your alarm system can read into that database run all the checks etc you would normally. the Always on system keeps everything up to date, so if the connection drops, when it comes back online it will merge over all changes It also means that if your main centre goes down you can set it to automatically failover to the secondary, when the main datacentre comes back online it will re-sync with the (now) primary node, at which point you can fail it back over to your main centre. You can run this on multiple databases, so we have our main DB and our Admin DB synced across our nodes, however what runs all the jobs and direct actions on each side is not replicated so can stay independent of each other 

Note, are you wanting those default values in there? would make more sense (in my opinion) to have it as a required field on the execution of the proc so you don't accidentally run it with no values and presume its right 

I'm not sure what your dynamic columns are so I cant 100% promise this will work, but if you get any column errors you should just be able to put ts. infront of it to declare its from that table Ste 

It depends on what you need, the basic data for conenctions can all be found in table Main points of reference are