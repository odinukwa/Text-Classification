Sleeve - Ground Ring - Right Audio Tip - Left Audio Connected to 2 when no plug inserted Connected to 3 when no plug inserted 

I think you will be fine to assume that that part of the hardware has not been changed (Integrated Circuit Engineers are as lazy as the rest of us so if there is no reason to change things they probably won't!) - besides changing things like the individual pin characteristics means that the software that sets them up ("device tree" files and the interpreter for ) would have to also be rewritten, which is more work for other people as well...! 8-) 

The website for this notes on the installation page specifically for the Raspberry Pi that the project was included in the "Jessie" release distribution around November 2015. Did your complete correctly - you might want to reboot after that and do another to be absolutely sure everything was updated from the "Wheezy" dist to the "Jessie" one - given that this will also change the first process from being the sysV of the former to the (default) of the latter a reboot is, I think, really a good idea. My (RPi B+) went straight into the expected with a recent NOOBs + Raspbian: 

Technically a cross-over Cat-5 (or better) lead between the two ought to work but it may be a bit confusing for both you and some software if packets pass between the two and packet addresses are ignored but still get through. You may find the Windows PC, in the absence of a DHCP server, adopting an automatic IPv4 address from the link-local 169.254.x.x range (they call it Automatic Private IP Addressing a.k.a. APIPA). This takes extra time compared to using DHCP as it has to check quite hard that an address is free to use. Given that you plan to use the RPi as one sort of server already the easiest solution (if you are NOT using a wireless router, which can do this in a few browser clicks once you use a wired connection to it and can find it's IP-address in the first place), you could configure it to be a DHCP server as well - you will likely want to install the package and dependencies on the RPi. 

Are you using the GPIO as the user (or 'root' superuser) - if not I think you may need to add the user name you are using to the group to have permission to access the gpio pins. First you canÂ check which groups your username is a member of with the (standard *nix) following command (which for the default pi user gives): 

The documentation I saw seems to suggest that the keyboard repeat rate is initially set to disabled (presumably the setting equals 0 {milliseconds}) From pygame 1.8 it says you can use - what does that indicate? n - where n is repeat interval in milliseconds - configures the setting; it might be worth using anyhow, even with the default supposedly being what you would want. 

What I think you mean is that you do not want to have a GUI running on the HDMI display. You will instead turn off any local logins on the console and then run an application, probably with the NCurses library which provides the sort of low-level CLI interface that you desire except that you use functions that produce the display desired into the buffers that it provides. NCurses role in this is to provide an abstraction so that the content is transferred to the display hardware (or framebuffer) in as fast and efficient manner as possible - what- and where-ever that hardware is... There are also parts that handle getting input from the user and you could make it easier to test and construct by doing it as a program that runs from the text login console and eventually prevent it from exiting and prevent the key-presses that normally cause Virtual Termnal switching. 

One assumes that the issues with 24 and 32 bits have been fixed long ago! So, why is it necessary to run in 8 Bit mode when you can use a higher number of colours - I cannot think off-hand of any applications that DEMAND 8 bit colour but if you know otherwise please respond and I will try to enlarge/revise what I have put here...! 

When you say "and persisted even when I powered the RPi from my bench supply." were you using the same lead with the micro-USB connector on the end (I'm guessing the bench supply has some wires attached to the power pins of a USB socket that the lead is connected to? If this is the case I would be suspicious of the quality of that lead - some USB cables have quite thin and skimpy wires inside and a poor production process may mean they are not bonded properly with the connectors on either end. The end result being a significant volt drop or even an intermittent connection across the lead which may well be made more obvious by flexing the lead whilst the RPi is powered. 

I am planning to use a triplet of RPi GPIO pins as an additional bit-banged I2C bus on my RPi. This will be run at a lower than typical rate (and level-shifted via a 3.3 to 5.0 V I2C shifter unit) so that it can work over the distance necessary to be the back-bone for a Home Automation control bus that will be populated with the (popular) PCF8574 and 8574A (Philips data-sheet) 8-Bit I/O expanders. These have the nice addition of an Open-drain (FET equivalent to an Open-collector) active-low line that can be connected as a Wired-OR between devices so that the controller (the RPi) gets a low-going interrupt any time any pin on any of the 8574* devices changes to be not the level that it was set to (input pins are to be written to/default to high output level i.e. ~5V). I am aware of, and plan to use, @joan 's pigpio library with it's support of bit-banged I2C interfaces on arbitrary GPIO pins - and I will be coding in 'C', but can I use this interrupt to replace the (library's) need to constantly poll all the GPIO pins when all that is needed to do is: wait for a change on that interrupt pin? To a certain extent this is a bit of a place-holder question that I will expand upon as I flesh out this idea in practice! 

I think you must avoid changing your kernel image - the manufacturer has provided newer SD card images here and at the time of writing they offer: 

I originally flagged this as being, possibly seriously, Off-Topic but technically there is a further method that make it possible to connect a graphics card to the RPi and have the latter generate content that is displayed on the former. It is called, *inserts drum-roll*: "X11" and is what is involved when you run an X server on your PC Desktop (which has the Graphics Card in it) and connect to your RPi via : First, you will want an Xserver running that the RPi can connect to. If you already have one running like I do on a Linux Desktop then you are set to go. Other OSs like those from Redmond in the USA are more work but Cygwin may be of use (though I cannot recall whether the server is there or in the CygwinPorts testing part). The Mac platform, also being a *nix derivative may also have something that will work but I'm not an expert on those. Next use with the option to enable "trusted X11 forwarding" so that the latter are not subjected to the X11 SECURITY extension controls (which thus become a possible security hole, there may be safer ways to achieve the same linkage). ssh has the bonus that with the -Y option it will normally configure the correct value for the environmental variable but in some cases you might have set it with something of the form: "Desktop PC name""Display number" e.g. using I found my Linux Desktop PC was at so this, using the default number becomes: . Now you can run GUI commands on your RPi and they will appear on your PC desktop as if they were running on the latter (though they will not be as responsive) and they will be using your Desktop PC's graphics card...