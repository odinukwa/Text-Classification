dawn gloves -scrub your copper clad (green dish pad and ajax/commit) rinse grab another pad and acetone can. Scrub with acetone. Its clean enough when a paper towel/white cloth and acetone do not turn grey. set it somewhere clean and dry when finished, you will need it again soon Get yourself under LED or very dim incandesnt light. Remove Riston film from its roll tube. LED is the way to go as they emit only a narrow band of color in lights and no UV. LED lights are usually safe full brightness for handling the UV sensitive film. Once under suitable light, cut yourself a square of film the size of your copper clad. cut another if you are doing double sided. If your house is a grow op and you have grow leds everywhere...stop this process and move out before you get busted. also... you just exposed all your film. cut a piece of clear tape. stick clear tape in corner of uv film and rip away quickly. The uv/riston film has 2 protective films (each side) we need to remove one and this is the quickest way. Lay film on copper clad, (side you just took protective film off down.) you will know what is film and what is protective layer because film is blue, or maybe green depending on brand, protective is always clear. laminate film to copper clad. I use the amazon basics cheap laminator. note: To avoid air bubbles I like to take the protective layer off one side of film, Place Copper Clad in a tray of distilled water, Float the film on top of water and pull board up to it (gloved hands, oils will mess things up). After that i send it through laminator. Some people find ways w/o water. that just works best for me. Bubbles are bad. 

You specifically mentioned a USB to TTL converter. The Raspberry Pi is a 3v3 device and TTL is a 5V specification. Or did you mean a USB to 3v3 serial converter? 

Yes, if you setup a DNS server (Domain Name Server) you can create you own little internal network. However, you will need to make sure that the server rolls over onto an outside DNS so that you can find outside machines (like amazon.com. google.com, tvtropes.org, and other such important sites). I have a Synology NAS that has the option of having a DNS run on it. It is a fairly tedious process. I've only done this on unix/linux machines, but there must be something that runs under windows. I will be setting this up on my Synology NAS because I don't have a Linux machine that it up all the time. Then you have to have your central router (usually that machine that runs WiFi in your house) to give your internal machines specific internal ip-addresses. This is so that the DNS server can associate each address with each name. And then you have to go to all the machines and tell them about this new nameserver and not to use DHCP to get their addresses and names. And also inform the machine about their new fixed ip-address. This is usually under settings in a setting called "Network." It's easier than I make it sound. Here is a recent article on how to do the setup under Linux. One further suggestion: decided on an unique domain name. I use my first name because it's short and I can remember it easily. Sometimes people have a theme in naming their individual machines. I've seen machines with the names of science fiction characters and one with the name of small towns in Pennsylvania. Go wild. I may name my machines after cinematic superhero names. :) 

supper glue them together (blocks more light) 3.5) if you have a back layer repeat. sometimes a piece of pcb glued in between top and bottom can make a jig to slide your copper clad into to ensure alignment between layers. this is crucial if you have actual traces on the back. if the back is all ground it doesnt matter so much. if you miss and drill out the side of a pretty much flat pcb..i dont know what to tell you 

you can do multiple boards and store them for a few months if you want a ready to go supply. just keep them in a light proof container. expose 1)put transparency over/over and under(2 sided) your riston coated Copper clad 2)sandwitch between glass sheets 3) bring outside to expose 4)set in dark for 15 min to let chemical/plastic stuff happen 5)drop in developer and brush gently w/soft brush or gloved finger tip for 1min. You will start to see the areas that were exposed get washed away/ come off and the rest stays. This is your "acid resist" pattern. 6) rinse under tap water or distilled to stop the developer Etch 7) drop in acid tank for 15ish min 8) remove and rinse with h2o to stop acid 9) drop in acetone or scrub acetone and green pad to remove the resist and reveal the shiny copper wires/traces/pads you just created on your board 10) scrub with like 5% hcl and water to remove copper salt deposits that dont come off with just water. 11) wash your hands, secure chemicals or decide life isnt worth it and drink them etc etc. 12) drill holes through layers. solder on parts...etc. obviously some googling on board etching will be required but I highly recommend you try it. Unlike sending out and waiting a week, a mistake can be corrected and new boards made in 20min to an hr for just a few dollars of waste board. If you make a mistake on a board you had professionally done; you might be out a few hundred. 

The above installs everything I needed, (maybe even more than I needed, not sure) and the next step was to tweak the default snmptrapd.conf file in /etc/snmp/ 

Run the physical disconnection again, and check the output of the python created text file: WOOT! Looks like whatever that package is, is an array of 16 chunks: 

I've got a fun little problem that I have hacked together a solution for, but I'm thinking there's probably a more elegant way of going about it. (I also had one heck of a time googling any information on the hurdles I had to face, so while I'm looking for suggestions on cleaning this up, I also hope this may be of help to others who are trying to do the same sort of thing) My managed switch has quite a lot of capabilities, but what it doesn't have is the ability to email me when one of my network drops disconnects. (It's for a wildlife camera that I have a long ethernet cable to, and I want to know immediately if it is ever stolen or drops offline or whatever.) Of course, I immediately thought "Sounds like a Raspberry Pi project!" So I configured the switch to kick out an snmptrap packet to the IP Address of my Raspberry Pi, gave it a custom community ID of WLDLifesnmp, and just turned on the 'link down' notification in the management interface of the switch. On the Pi: 

then inside the fn_runmain() put the same try/except block as above. EXACT same result. The function fn_runmain runs properly without the try/except inside it, but does not when I add the try/except. 

If you can program in Go, Node.js, or Ruby, then you might want to look at GoBot.io. GoBot is a lightweight framework that has several communication frameworks and Raspberry Pi is one of them. I have my Linux laptop speaking to a Raspberry Pi Zero W, just to see if I could do this. My next experiment will be to have wired communication. If you look on the front page, they have "sister projects" written in Ruby and Node.js. The Go code runs on a larger computer (PC, Raspberry Pi, that sort of thing) and through and "adapter" (a communications protocol) they communicate with microcontrollers if necessary. The same technology allows for communication between multiple Raspberry Pis. It is a much lighter framework than ROS, though, but it is much easier to learn. 

I would suggest buying a low-power PC in a mini-tower. Just enough of a machine to fit your PCI board in. Anything I have seen has cost more than such a PC. You can even probably get it used to spend less money, but even a low-end PC will cost under $1,000. Nothing I've searched for will connect a USB port to a SAS device. If you really wanted to do this, you'd have to do a lot of work. I'd start by looking up the PCI bus' electrical specs so that you could connect to it. Then you'd need a power supply to power the tape drive and probably the PCI board. Then the real work begins: you'd need to write a custom driver. Just get the PC if there is a driver available. Otherwise you have an interesting-looking paperweight, unless you are very good at electronics and programming and have a lot of spare time. I like these things and are good at them, and I wouldn't try it using a Raspberry Pi unless somebody were willing to throw a lot of money at me. 

ugh. this is not going to be easy to figure out which port is tripped. I only want to notify if it's port 17 on my switch, not the rest of them (the above is port 39 and 35, respectively).. I have to somehow figure out how to strip that info out, but I have no idea how to do that with bash scripting. (again, I know enough about bash scripting to be dangerous) Python, however, I like Python, so maybe I can export the results to a little Python script and see what sort of packaging is being used here. It sort of looks like it's somewhat of a JSON package or something, I could not find any documentation on what sort encapsulation the MIB is using under the hood. So... enter a tiny python3 script that should run through each chunk of $vars, and write the contents on a single line to a text file: 

I can't for the life of me figure out why the 'try' doesn't allow the edge_detection to register. Any ideas? EDIT: I've also just tried to take the main code chunk that runs under the main logic check, and created itself in its own function: 

Full disclosure: I know next to nothing about snmp in a large sense. "just enough to be dangerous" so I left the log and net in the community. I could probably get away with just the execute for the WLDLifesnmp community, but it works so I left it. The most important part was finding the exact OID that was being tripped when that particular port on the switch disconnected. So I manually ran snmptrapd from the command line, just to watch what came through: 

If you only want one picture per day at the same time, it might be better on batteries to shudown the pi after taking the picture and storing it. Then use a timer to turn on the pi at the same time each day. You use use a very small, low-powered microcontroller to do this. They could run off the same power supply. I haven't heard that the Raspberry Pi has a low-power sleep mode that can be set to wake up at a given time. This would be extremely useful for your application. The battery for the power supply should use some environmental supply, such as solar, wind, or water to recharge. I'd use a lithium-ion battery. I agree with OyaMist that you'd want about a 12v battery and use a dc-dc converter (not a normal voltage regulator which wastes a lot of power). And unless you need something more powerful, I'd suggest using a Raspberry Pi Zero. It's cheaper and you save more power. 

I've never heard of trying those strategies. I've never heard of a Raspberry Pi hat or other add-on that adds a new CPU. I suppose you could use the Raspberry Pi Compute Module with multiple modules, but that would be more expensive than choosing a more powerful single-board computer. There have been people who have made parallel computers with a network of Raspberry Pi's. These clusters are more educational than useful, but they might increase your CPU speed enough, and they should be able to share a hard drive. I don't know if this will help enough, though, because I've never tried this. Have you considered a more powerful board such as the Udoo x86 series? This is an x86-based board (or rather several of them with increasing speeds and prices). It will run Linux just fine, it can also run Windows. It includes an on-board Arduino clone, which is useful for robotics. The Raspberry Pi, while a wonderful computer for some things, has too many networking bottlenecks to be useful where networking is important. Don't get me wrong, I like the Raspberry Pi. I have many of them. I'm going through my electronics, and I have many more than I thought I did. Maybe I will try making a parallel Pi someday, purely for educational purposes. 

first I just realized you are over thinking the heck out of it. There are chinese hardware .264 usb cameras that are just board and lense mount like the pi cam for 30 bucks. grab 2 of them and a pi cam. they have 1080p versions for like 20usd more. I've ran 3 cams on a pi 3 before. 2 of them were usb with out compression one was the pi cam. I then bought 2 of the cams i described and framerate was way better. I could stream like 15fps over wifi/lan when all cams were .h264. unless you want a flying robot this should be sufficent with out using the compute module. One thing you need to do is set the program you use to do the recording (likely "motion") to record to a ram drive. If you do not do this you will burn up your flash cards quick if you have your heart set on compute module(its a mistake for what you have described): imho you are going to pay through the nose for pre made boards to use with the compute module. a board consists of 6 voltage supplies, which costs $18 bucks of IC at most, if you want nice parts and are just ordering one of each. it can probably be done for $10 if not less say each usb port costs you a $1 and the hdmi costs $them 3. There are some passives and rfi and static/esd chips but places like ada fruit charging what they do for the mobo is nuts. The ddr port it plugs into is maybe $3 bucks. the little connectors you need for the cams maybe cost $0.75 flex connectors is what you should search. . eagle cad has a free version, they also have versions one my make a choice to acquire with a vpn. Kicad is completely free cad software one or the other will likely fit your current mind set better. There are part libraries for both and sites like Digikey have a checkbox to search parts with included CAD models. honestly you are best off learning to input a part from the data sheet/scratch. My first pcb took more time finding pre made parts than if i had just suffered that learning curve if you google something like "pi compute 3 minimum host eagle cad "(or kicad). you may find someone has provided a file with the psu components and the ddr2 socket already laid out. from there you will need a flex connector for the cammera. Datasheets are your friend. They tell you about the part and its connectors. most connectors have a name and pin count. this enables you to search for and buy them. cad programs have an option called "generate BOM" or something similar. Its Bill of materials. If you find a file with the basics laid out, outputing the BOM tells you what you need to order for their design. when it comes to getting a pcb made you have several options in us and china. osh park has like 5 day turnaround and priced 5 bucks per square in of pcb. This is for a 2 layer pcb and you get 3 copies of your pcb for that price.. if you dont mind waiting a month some pcb houses found on ebay will do it for less. keep in mind, working with a company in the developing world whos employees may or may not " the english so good" can add a layer of difficulty path less traveled is to etch @ home. I had plexi laying around when I got into etching. One can assemble a thin vertical tank with plexi and paint thinner (or solvent glue). tanks can be had for about a hundo premade. At the bottom you place an airline and use an aquarium pump to bubble air through your acid. Go with cupric chloride and your etchant(acid) will be reusable indefinitely because air regens it. almost every etchant becomes illegal to dump down drain after it eats copper off the board. the nice thing with cupric is its reusable so you never have to pay to get rid of it(assuming you may etch again) Cupric Chloride can be made from Pool Acid(30%hcl) bits of copper wire weighted out and hyrdogen peroxide Hair bleach (volume 40 is the product name). Alternatively the 3% peroxide from drugstore will work but it will take about a week of bubbling air to get the chemistry right. the "volume 40" is like 15% peroxide and you will be ready to go that day. There are 2 main choices for how to make the mask/template which will protect the copper we want to remain on pcb etched @home. What isnt covered will get eaten/etched away by acid. the blank pcb is called a copper clad. I will refer to it as such for the rest of this. choice 1) toner transfer. One needs a laser printer, an iron or cheap ($25 ish) laminator a witch doctor and said witchdoctors recommendation on what special paper to try to get the best results. He or she may later tell you that the printer brand you have has angered the spirits. I recommend skipping this method. choice 2) uv photolithography. this is what the industry uses and by far produces better results if done with care. It is also repeatable with the same printed transparency choice 1 is not you will need a printer for either choice. UVlith process is compatible with inkjet or laser. If you are in the market there is a 3rd option which requires a lot of DIY to your printer, but may allow direct printing of pattern to Copper clad. With that in mind, when i needed a printer for the lith process I bought an epson c88+. Printers that can use pigment inks are key but im not going to cover the 3rd method/direct print here. I just mentioned that printer because its cheap, it works and it may have that advantage later if you look into it. List of stuff needed for UV - Lithography 

Bingo, there it is. In the above example, it was port 22 I disconnected, and there it is in all it's glory, all by itself in argv[10]. I think I've done it, as messy as it may be. The above process will trip on ANY disconnection of the switch, but the Python script can filter out the noise and only look for port 17 of the switch. I think I'll trip an LED as well, so I have a visual alert, but at this juncture the only thing left to do is add a traphandle for the reverse (a reconnection). So as happy as I may be to have hacked my way through this, it does seem like a messy inelegant way of doing it. I'm open to suggestions on how to clean this up a bit. 

However, if I wrap the same statement into a 'try/except' (in order to add the GPIO.cleanup() to the end). It doesn't trip when when the switch opens and the GPIO falls. 

Now, maybe I can export the results from the bash script over to the python script instead, and parse through whatever is being sent, so I can at least sort of reverse engineer the capsule to see how I can grab that port number: Tail end of the snmpdisco.sh script: 

I have a basic system with a normally closed switch I need to monitor. If I run the program with the following setup, it works: 

I created the /usr/local/bin/snmp/snmpdisco.sh file with just the following in it, echoing the results to a text file so I could try to make sense of it: