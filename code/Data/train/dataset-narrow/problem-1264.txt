The massive advantage is that you no longer need : it suffices to use (or maybe : it's a matter of taste because was chosen such that would work in languages like Java which don't have ). I infer from your comment on an earlier answer that you haven't studied modular arithmetic. This is quite understandable: I think it's safe to say that 99% of programmers will never use it in their careers. But although it is irrelevant for most line-of-business programming, it is quite important in code contests/challenges (interpreted broadly to include katas, Project Euler, etc.) because they frequently use modular arithmetic to make large test cases feasible. If you find katas either enjoyable or useful for your CV, it's probably worth your time to study. The properties I'm relying on are (treating as an operator on arbitrary-width integers and assuming that we're avoiding overflow, which is ): 

However, this is obviously a semantic abuse. IMO the best solution is a ForEach extension method. The argument against it seems to put purism above pragmatism, but I would argue that there's a purist case that if you're writing with a functional style you should use functional control structures. 

The class is a nice optimisation for lookups, but the way it's built is expensive. This is a further argument for an extra phase: if you first accumulate direct counts in a map then the can be accumulated in a single pass with a running sum, rather than updating many entries for each . 

Favour composition over inheritance. You don't necessarily need 15 classes to implement the 15 interfaces, but if you split them into logical groups and have one class per group it should make it easier to understand the overall structure, and given the number of empty methods I wouldn't be entirely surprised if one or two of the interfaces turn out to be unnecessary. 

Under what circumstances can the final be reached? Why not handle those special cases explicitly, and then simplify the loop body by reducing it? 

Never ever ever open a file for reading or writing characters without explicitly specifying the encoding. You'll think it's all working fine and then someone will run your program on Mac OS X and send you a file encoded in MacRoman because that's the default on their platform. Yes, I learnt that one the hard way. Unfortunately the Java standard library tries to make things "easy" by hiding access to the encoding and ends up making it hard for anyone who wants to write portable code (supposedly Java's strong point). You can't use , because none of its constructors have an encoding parameter. You have to create a and wrap it in an . is similarly useless. 

â€‹ Fiddle is one possible way of making everything consistent, although you may prefer to always toggle classes instead (or to add animations). 

Performance claims The title of this question is "Find median of two sorted arrays, with complexity of min(log(m),log(n))". That's impossible: if I guarantee that the second array is of length at most 1, you're promising to find the median of the other array with complexity bounded above by 0. I think you can claim \$\log(m+n)\$, but some comments to justify correctness and performance would be nice. 

and (once I'd modified the debug output to be less frequent) the entire program ran to execution in 75 seconds. It's still painfully slow compared to my C# implementation using a handrolled permutation class (1.5 seconds), but it's a massive improvement. Run again under the profiler, it takes 105.676 seconds of which the bulk of the time goes to (57.537s), (37.974s), and (36.705s). So further speedups might be possible by hand-rolling a permutation class, but the real possibilities lie in changing the set representation. Since you're working over a very finite universe, a bit set might be a possibility. Of course, the disadvantage would be a loss of readability. On that subject, I have some suggestions. Readability 

You can avoid creating a bunch of temporary strings (copying all your character data twice) by using StringBuilder to something nearer its full potential. 

I personally don't find a very descriptive name. would tell me immediately what it's doing. I'm not sure, though, how useful a DFS is which just returns a list of vertices. Most of the time DFS is used as a building block for other algorithms, and they require additional data. 

A full sort is overkill when the only element required is the largest. Finding largest elements by a projection is a relatively common operation. Both are good reasons for creating a extension method (or using MoreLINQ's) - although here you really want 

Factoring out common code All three of those methods have a loop which does the same thing: find the factors of . That should be pulled out into a single method, which should have a suitable return type (e.g. , although there's a good case for , or maybe some integer stream type, but I'm not up to date on Java 8). Then two of the methods sum the factors: that's already pulled out into a method, so the other method shouldn't duplicate it. Instead you should have a very simple method 

Python has standard formatting conventions, known as PEP8. There are free tools to lint code to those standards (e.g. this online checker, which was my first search result). Use them. 

I find it quite hard to follow your approach. There's a static field which is updated by a static method whose variable names are virtually meaningless; this update method is called in a loop; and the contents of are used each time round the loop. It would definitely help to have more meaningful names, and might also help if the accumulator (, but should probably be called something like because it seems to contain sums of two abundant numbers) were passed into the update method and back out. You asked about performance. There are a couple of basic observations: 

Why not reindex so that (rather than, at present, )? Then you can lose the special case in . And as a bonus the variable name will be more transparent. 

There are various overloads which take , and ideally you would set both of those to . If you can't set because you're using a cheap web host which doesn't support HTTPS, at least set . 

Wouldn't be more useful? You can print to stdout given , but you can't print to anything other than stdout given only .