In your code the need for the assertion seems a bit artificial, since it checks that the first character is exactly the character pushed back by the caller: 

Meaningful Names A class named does not tell me anything about what it does. This goes twice for a method called , and is simply misleading. Give the method a name which actually explains what it does: 

Naming Conventions Variables in java should be , meaning they should start with a small letter. Meaningful names Someone reading your code doesn't stand a chance in hell to understand what you are trying to do without actually running this code in his head... Your class is called , your only method is ... at least try to tell your reader some story on what you are trying to do, especially when you post it for review! Variable names like , , , and add nothing to explain your code. Names like and are even worse. Efficiency It is very hard to give efficiency advice, if I can't say what exactly you are trying to achieve, but some obvious observations: 

It sounds like you want a JavaScript Template Engine to render raw data into HTML. JavaScript template engines also pair well with a view resolver like Bloodhound (which I wrote). Edit #1: If you need something lighter weight this would suffice: 

There is absolutely no difference between and . The and properties created using are superfluous, and only serve to add weight to your JavaScript code. There is no logic behind the getting and setting of those values. On the contrary, consider a case where you do want some special logic around setting a value. In the code below, the property is a reference to a DOM node. When setting the DOM node we also want to set properties for the and to which the DOM node belongs: 

This way all of your rule classes are hidden. All of the validation rules are portable because they are created inside a model specific class, and it's easy to use an IDE's auto complete feature to discover which rules are available since the RuleBuilder class has strongly typed methods encapsulating each rule. On top of that, the IRule interface just accepts a value and not a model, making each rule unit testable to ensure your validation library is functioning properly. And for those who do some .NET/C# development, this pattern probably looks familiar if you've used the FluentValidation NuGet package for Visual Studio. Say what you want about .NET development, but there are some gems out there. I do like the pattern that FluentValidation uses. 

I'm not sure why you'd need to pipe three different streams - one for every manipulation. I'd probably use one Stream to do all the manipulations together, something like: 

How is it better than your current code? It is not more expressive, nor is it more succinct, nor DRY. Also, these associations are similar to some extent, but they look as DRY as you can make them - one is , while the others are , one uses the default idiom, while the others have names different than the associated class, conditions are different (and though one might argue you can predict the filter by the association name, one is singular, and the other is plural...) In short, I think your current code is good enough - any change will only harm readability. 

Mutators vs. Selectors The method both populates the instance, and prints the result. It would be a lot more predictable if it would be responsible only for one or the other. Its name implies that it only prints, so I would suggest to move the population of the to its constructor, leaving only the printing to the method: 

Separating things into these layers makes them testable. You could write Jasmine or Mocha tests for your controller and repository layer: 

Your service could get the object for the view model, and then inspect the using class reflection. This could make processing multiple view models easily repeatable with little additional code. 

The Ugly Nothing is really ugly here. For that you'd need a helluva lot more Clint Eastwood. Breaking Down Your Application Into Components To really organize your code, you need to break it down into components that focus on one specific task, for example, adding a category. Looking at your code, I can see the following tasks: 

This breaks the relationship between and because we assume is the document object that contains . Instead, we want to create delegate properties for and so we can maintain that relationship: 

Trying to use JavaScript like a class based language is what you make it. It sounds like someone was expressing an opinion, rather than imperial evidence. As for your implementation, it's very confusing how you'll expect to use the object. Be very careful with mixins or, "multiple inheritance." If you need multiple inheritance, I would argue that you need Composition over inheritance. 

Naming Using member names like , , etc. is not very readable, and makes understanding what your code does very difficult. For that reason, it is very hard for us reviewers to give you an intelligent advice on how your code can be improved - we just don't understand what it does... Shadowing - to add insult to injury, you shadow the member when you loop over it. This makes your code totally unreadable. I still don't understand what that loop is all about. Loop bloat The line is very suspicious, since it bloats the amount of data your are looping on by several scales. Are you sure that is what you want to do? Where does your data go? The , which holds the result for each iteration is not seemed to be saved anywhere... Filter your data At the bottom line, you are substituting words in your input. Not all sections exist in all inputs, but you search for them over and over again. You might save a lot of calculations if you filter irrelevant sections in your code, before looping on them: 

If private variables aren't all that beneficial, or the property is meant to be public, I'll just declare that as part of the prototype: 

If the only purpose is to provide a simple wrapper around the body of the HTTP response, this isn't so bad. Things break down when you need to access things like the request and response headers. Error handling is another thing entirely. I would recommend catching all errors, and rethrowing the exceptions wrapped in your own exception classes to make error handling for client code easier: 

The form would need to instantiate the user permissions service with the proper user object before the method gets called. 

When you change anything with categories, you need to refresh the category list. Same thing with bookmarks. For this you can use events. Controllers would publish an event, say "category:updated". The would subscribe to "category:updated" and refresh the category list. Same idea with . Now the AJAX functionality is currently all global. I usually go for the Repository Pattern to encapsulate AJAX calls. For that you would have two more classes: 

If this is what you actually wanted, you don't really need all the temporary artifacts in the middle - simply do it in one swoop: 

Exit Strategy Your use of makes your code a little awkward. Initializing it with , and changing it to makes it even more obfuscated, as it is counter-intuitive to most coders. As its name does not convey it any meaning, your gentle reader is left to guess its meaning by reading your code over and over... I would drop the flag altogether, breaking from the method itself upon finding your stop condition: 

Optimizations Since you don't give any background, it is hard to give you feedback on your algorithm - are you trying to implement a specific sorting algorithm on your own? are you simply not familiar with java's own solution to sorting ()? Optimal solutions for sorting an array are with complexity of \$O(n \cdot log(n))\$, your solution is \$O(n^2)\$, so there is room for improvement there... you can find a myriad of sorting algorithms here. You could further optimize your code by making a few quick checks on your data before doing the heavy lifting. For example: if not all the strings have the same length, you can immediately determine that they are not all an anagram of one another, and save yourself the sorting. 

As an added bonus, adding a new decoration/drawing style becomes trivial. Add a new value in a attribute, and then create a new function using as the name of the function. No need to update . 

Now we perform special logic in the function for . Defining the property via is now beneficial. You might find Inheritance and the prototype chain a worthwhile read, as well as Introduction to Object-Oriented JavaScript. Edit #2: Defining a property using is useful for creating delegate properties. I'm going to build on the class from my previous edit. The belongs to a document and a window. In the previous example, there is nothing preventing you from running this code: 

The hardest part of managing HTTP requests is that there are a million ways for these things to die. Any assistance you can give for error handling will be appreciated by all who use this class. 

I tend to gravitate towards making everything public, and part of the prototype. As a personal convention properties and methods prefixed with an underscore are not meant to be called publically. Some people force encapsulation by using private variables, but this always feels like I'm trying to fit a square peg into a round hole. Unless you jump through hoops, everything in JavaScript is public. Embrace it. It makes unit testing your JavaScript code easier as well. As an added benefit, most browsers have optimized the Constructor Function + Prototype code by generated classes behind the scenes for your JavaScript "classes", making property access in JavaScript almost as efficient as native code. Browsers haven't done much to optimize Constructor Functions that use private variables --- which is not to say that kind of code won't ever be optimized. It just isn't optimized very much right now. Edit #1: From OP's comment below: