It takes a while to get used to, but once you do, everything is in the same place, and no necessary. 

For the , we're copying it. And for the array, we're decaying it and ending up with a pointer. We want to return an lvalue reference for lvalue references, and a value for rvalue references. That is, trivially: 

Now, this is the right form for template metaprogramming! So what tools do we need to build this up? 

First of all, your copy constructor is broken since you can't use an array as an initializer. But really, you don't need it at all. The default copy constructor is fine. 

Rather than generating the substring for the last two chars and reversing it, you could simply add the last two chars in reverse order: 

Your copy assignment has the same problem with clearing - prefer to use the copy-and-swap idiom. Lastly, you went through all the effort of trying to make it as efficient as possible to add new nodes: 

And have a member of class instead of a . This will give you all the benefits (checking if is ) without any of the downsides (wait, what's the mean? What's ? Why does my completely unrelated program break when I try to use ?) But there's a lot more to say than just that. Interface Your public interface for is: 

Code looks fine, I have one important issue and some minor comments: Typedefs One of the common uses of policy classes are their typedefs (cf. ). Using hides all of those, since in the delegating case, you hid , and in the deriving case, you inherited privately. So I would suggest at the very least deriving ally from and exposing it as a typedef in both cases: 

is a bad variable name for this, prefer something like , but that's not important. Consider the bounds. At this point, we know that \$i\$ is prime. We also know that this is the first time we've gotten to it, so every multiple of \$i\$ is still marked as being potentially prime, except for those divisible by some other prime \$p < i\$. So \$2i\$ we already know isn't prime, because it's divisible by \$2\$. \$3i\$ likewise. And so on. The first composite number that we have to cross off will be the first one not divisible by any such prime \$p\$... which is \$i^2\$. 

Prefer to unless you really need a . Lock-Free Queue If this is an optimization, I'd consider using a lock-free queue. You may find that most of your time comes from lock acquisition/release. () Your loop is: 

Well, yes. If they don't send you a message in 20 seconds, you're disconnecting them! Why? Simply removing that block is probably what you want. Separation of Concerns Your function both creates a server and handles the busy loop. You should split those into two functions: 

Your naming also could use some work - what is and what is ? I'm guessing is the capacity and is the key that we're erasing, but where are the values? We just have , so is this more like a hash set than a hash table? It's unclear. Looping and separation of concerns The hash function should just do the hashing (and thus shouldn't take in the capacity). The loop itself should loop over slots, not indices - this will localize your modulo operation so it doesn't creep in everywhere: 

For those types that have cheap move, this will save you some time. You also don't need a destructor. The default one works great. Should really be a public (or any) member? The user shouldn't be aware of the actual indices in your data structure. That seems like it breaks encapsulation to me. Insertion For C++03, is correct and sufficient. For C++11, we can do a lot better. First, I want to be able to move a into your heap, so you should support that: 

Unused/Barely used Variables (--> ) is unused. and are both used only on the line after they are declared, and only exactly once. They can both be gotten rid of. The latter for instance can change to just: 

is already a list in . In it's not, but you didn't tag the version, but you use parenthetical . Zero-indexing Python is zero-indexed. The first element of list is , not . When you pop the first element, you need to do not . Your loop is all off by one for that reason - you're starting with the second knight instead of the first. Improved solution 

Write Less Code The main problem I see with this solution is that you're writing so much more code than you need to to accomplish the task at hand. 

Although with that's not really necessary at all. Putting it all together So once we get , we want to print lines: 

is a redundant variable. It's hard for me to tell what it is you're actually using it for, but you're already keeping your sieve in a dynamic container that keeps track of its own size. should be how many values you've sieved up to. I'm not entirely sure what you're using , but keeping track of redundant state is very error-prone! namings is not the best name for that container (or any container) - perhaps ? Also should be called for consistency with other container types. repetition Your logic with the squares doesn't make sense to me. If you want to check the primality of , you need to make sure that your container is just at least that size. So I would write the top something like: 

takes a key The main thing I wanted to point out is that takes a , which is a one-argument ordering function. This lets you rewrite your as: 

We know what type it is, so we can use - which just does a . The advantage here is that we're just using pre-existing code. Construction Right now, your takes a that is always a null pointer and then you always default construct a in it. We can make this more functional. First, passing a pointer just as a tag is confusing. Let's create a tag type for this: 

Then, you call , which deletes . Now we have a vector of one element, which isn't even a valid element, and we will have leaked . If also needed to be erased, at this point becomes 1 so we decide we're done, and don't it. The correct way to erase elements from a vector which match a certain condition is the Erase-Remove idiom: 

Friend Operators Rather than forward declaring template functions, then friending them, prefer to write these operators as non-member non-template friends. So would be: 

and forward them into , and only there do you construct a . Never take a , you're going to shoot yourself in the foot. Minor Issues Avoid writing expressions like like you have in , just use : 

But that means if we have , we can construct it with a . We definitely need to disallow this. On a similar vein, should be restricted to those s which are the same type as and are at least as cv-qualified. Add another alias Rather than writing this: 

So it is indeed true that you only have to go up to the square root of . However, let's say we want to find out if 1 trillion is prime. We check , and is indeed a divisor. And then we check 3, and 4, and ... and we still check another million numbers. That is hugely inefficient. If you found a divisor, it's already not prime, so just stop: 

This is a more direct comparison. As is, you're comparing the levels, but there's not one unique tree that has three levels 'A', 'BC', and 'DEF'. For instance, what if your code erroneously returned one of these: 

And lastly, is a bad name for the max size of your array. Something like or or anything to that effect would be better. 

You have an object with 3 zero sides. That's a degenerate object. Rather, you'll want to make it so that once you have a , then it must be valid. Building up our Triangle To that end, let's consider . As a member function, this makes little sense - it doesn't interact with at all. The naming suggests that it's yielding some sort of member, when actually it's prompting the user for input. So let's rework it as a free function: 

Spacing The ultimate Python style guide is PEP-8. Please use 4-space tabs throughout, not 8. That is too much spacing. No spacing between a function and the parens: 

Dependency Propagation One thing that's missing is dependency propagation. So each file will be recompiled only if its corresponding file has changed. This is good, I don't want to have to recompile just because I changed . However, what if both and include some other file , and you changed some of the function signatures. Currently, neither nor will be recompiled! This is bad. However, you don't want to manually have to go through and add: