Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

Private initializers. I try to not use them if possible, but I do understand that they have a place. When code is short and simple (like this project), then I find it much easier to read if all of the UI components are setup directly in the constructor. I've found that it's easier to understand what is all happening and build a proper UI hierarchy when they're setup sequentially. A little documentation of what is being setup can go a long way as well. Plus, any variables that need to be accessed elsewhere in the class can still be final since they're initialized in the constructor. That said, in a very complex and large class it can be more readable to break apart the constructor work into some private methods. But even then I might argue that your constructor is doing too much, or that your class is responsible for too many things. 

There's a precept in Python, EAFP, which stands for "Easier to Ask Forgiveness than Permission". What it means is that Python programmers tend not to check things with conditionals, like doing . The style in Python is more to assume everything is good, and let the program throw an exception if it's not good. In this case, if there's no such file, you throw and complain. Sometimes you do want to ask permission, but I think this is a case where it's easier to ask forgiveness. This is something I also see elsewhere in your code. It's good to be safe, but in Python, people tend to really lean more heavily on exceptions than on explicit conditional checks in most cases. The case where you do use a conditional is when there are multiple possibilities, all of which are valid, and you need to figure out which case you're in. But if something is wrong or invalid or unexpected, like the passed file name not being a real file, I recommend exceptions. (By the way, you don't need in your clause. What does is skip over any code that comes after it to go on to the next iteration of the loop. In this case, there is no code after , so it would always go to the next iteration anyway.) In both and , you have some code like 

(By the way, a variant of that I have always felt has the wrong type, , is available from .) Finally, I would be remiss without pointing out that there are several good functions that already exist for doing conversions like this: 

Now, we have this branch primarily because still isn't total (it can't handle an empty input list). Instead of protecting ourselves from calling in this case, we should just let deal with empty lists correctly. So: 

My only complaint now is the name, for two reasons. The first is that isn't capitalized, which is inconsistent with the naming of the remainder of the file. The other one is more of a philosophical one: our input is an integer, not a base-ten integer. If anything, the base-ten-ness is being imposed on the output. So: 

Think of it this way: is there any way to count the number of distinct elements without actually looking at every element? (More accurately, without looking at some substantial portion of the elements?) If not, then \$O(N)\$ is the best you can do, asymptotically. There might be other optimizations you can make to speed things up in wall clock time, but the algorithm is as fast as it can be. I suspect, though, that your code isn't actually running in \$O(N)\$ worst-case time, because I suspect that adding an item to a Java TreeSet is an \$O(\log N)\$ operation, since I think they're implemented with Red-Black Trees. If you process \$n\$ items, and each time you process an item you do something with it that takes \$\log n\$ time, then your algorithm has worst-case complexity \$O(n \log n)\$. A Java hash set, which uses a hash table, should insert in \$O(1)\$ time, so your code would run in \$O(N)\$ worst-case time if you used a (as Simon André Forsberg suggests too) instead of a TreeSet. In general, I think that's the best you can do if you're just looking at an arbitrary array of items. 

Actually, most of the changes we made to can be done here, as well. In the interest of totality, we'll change the type, too; it will return a (which we happen to know will be a singleton list, if anything) instead of a . 

This isn't obviously better, since it still fails in all the same situations it used to fail, and it never returns multiple answers. So we should differentiate the two cases that lead us to the branch: 

Personally, I often prefer to , and the is complicated enough that I feel like it should be named, so I'd write it as follows. But this is an aesthetic choice that you may or may not agree with. 

This now has the magical special form of recursion that can be turned into a . Let's do so! See if you can spot where each piece of code from the above ends up in the below. 

It's a bit shorter than . (I like Java well enough, but it sure can get long.) Here's the entire code sample with my suggested changes, including the one that eradicates and boosts performance that Chris Hayes suggested: 

Caridorc gave you a lot of good suggestions for rewriting your code. I would just add one thing: if you're just getting started with Python, I recommend using Python 3. From your use of and without parentheses, it seems you're using Python 2. It's good to be aware of Python 2 since there's still a lot of it out there, but Python 3 is the future. Although Python 3 isn't backwards compatible with Python 2, it's not like the case with C++03 and C++11 or Perl 5 and Perl 6 where you essentially have a new language. Python 2 and Python 3 are about 90% similar in the core language. And the last version of Python 2, Python 2.7, has several Python 3 features backported to it, including the function. So if you learn Python 3 and then end up having to work on Python 2 code, you won't have much trouble learning the differences. Aside from that, I would just recommend carefully studying the code that Caridorc gave you. It's a very clever and concise way to write this program. 

Your MVC usage is a bit skewed. We have the GUI class (clearly the View), MusicInfo (Unnecessary model that the View uses, but is also passed to Midi?), Midi (Controller, but is also directly accessing MusicInfo which should be internal to the View), Instrument (A model) and BeatBoxConstants (More on this later...). In the MVC pattern what is supposed to happen is this: 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

Who cares if it's not selected already? Doesn't hurt anything to set it to false again, plus now it's even more clear that each method is an unnecessary wrapper. Midi Class 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

Okay, let's check our work. We already know that the final thing works differently for negative numbers, so let's only check non-negative ones. 

There's a few things I find more satisfying about this: our base-case input is , a common base for s; our base-case output is , a common base for s; and there's no duplicated code in the two branches of the . Finally, I think I'd choose to replace the -- with a pattern match, noting however that this function has a slightly different behavior for negative numbers. Since we were never really doing the right thing for negative numbers, this doesn't bother me too much. 

which we can use to index into our lookup table with the digits of our integer. So let's try to write this directly! Taking a cue from the final implementation of above, we can write 

First off, I'm going to have to complain about your taste in function names, which will probably be unproductive and just lead to hurt feelings on both sides. Yes, it's that function . I don't mind so much if small inner functions defined with have names like , but to my eye, something declared at the top level of namespace—private or no—should have a more descriptive name. I would probably not define as a top-level function at all; see below for more on that. It's also confusing that you call the top-level function , then also call the function passed as a parameter to by the name and then go ahead and pass as the parameter in . I kind of don't like that you expect the output of to be a vector of vectors, but you depend on the function passed as a parameter to to return a vector instead of putting that logic inside . If I had a top-level private function that's only used once and seems too specific to ever be useful again, like , I would consider making it an anonymous function that gets passed in the one time it's used. So I would probably rewrite like this: 

In fact, there's even a function that squashes those two things together. Veteran Haskellers will prefer to spell this function in its infix, polymorphic form as 

As with waaaay back at the beginning, I find the choice of base case a bit odd. Let's try the trick from before of letting the "loop" run one more iteration (and this time hopefully the refactoring isn't wrong!). 

(I've added a little creative whitespace to show parallels between the branches.) The only thing I'd change now is to pick a better name. For example, might be an okay name for this. I'll mention one more thing, which is that this can also be implemented quite beautifully as a list comprehension: 

Actually, this whole process at the very end is quite roundabout! If you squint, it looks like what we're really trying to implement here is a little function