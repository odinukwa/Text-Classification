Is it really you have installed? I thought Ubuntu installed by default? In any case, itself is difficult to configure and even harder to debug problems with that. So I'd recommend switching to another MTA. Programs trying to send mail won't notice a difference. Secondly, PHP's function is notoriously fussy and tries to do some things for you. This is especially so if you don't provide enough header parameters because it leaves some of the guessing up to the MTA. I would suggest you find or similar. This has a much better API which gives you much more control over what is happening, and sets up a lot more sensible defaults than does. 

You will understand your database security and how it is implemented. You will get to remove access that is no longer required. 

Have a look in the tables. It is possible that some permissions have been set on that table that remove your access. I know MySQL's permissions don't normally work that way, but it's worth looking at. Also, does the table's file itself have the correct file system permissions? If MySQL can't write to it, it might confuse the permissions subsystem as to what's wrong. 

Have a look in a musical instrument store, specifically one that sells electric guitars. A lot of effects pedals are 9V powered and have both a battery and an external power socket. Since the people who buy those often have several, there are also looms/splitters available so one power supply can power half-a-dozen pedals. I know you wanted 5V, not 9V, so you'd have to modify or replace the actual power supply. You could also look in an electronics parts store (In Australia, I'd point you to Jaycar.) or one of those PC oddment stores that sell less common PC stuff, like POS-terminal keyboards and USB-SCSI adapters. They often advertise in magazines. 

You will need the normal build chain (gcc, binutils, make, autoconf, ...) plus Apache's dev library at the very very least. You might want to run first and see what options are available; a number of them will need extra dev libraries, such as for MySQL support. And some options might need configuring if RHEL4 has some directories different to what the build/install scripts expect. 

Ext3 is a very good, all-purpose filesystem suitable for the vast majority of things you could use a Linux server for. It has only a few known performance quirks, the main one is deleting tens of thousands of files in a hurry. It is also not recommended for storing lots of very large files, such as motion video as used in a DVR system, or lots of very small files (tens of thousands) in a single directory. Alternatives which cope with those extremes better are XFS and JFS, but if you're not likely to need any of those three scenarios, then ext3 will be fine. (ReiserFS also handles the lots of small files problem and deleting many many files at once problem quite well, but doesn't handle lots of huge files all that robustly.) And if you're doing disk-heavy activities where speed of the filesystem is going to matter, then EC2 is going to be a bigger problem than the filesystem. 

Review your aggregation algorithm to see if it is designed to grow with the data, or designed to stay a fixed size. Acquire more storage. Stop storing logs in the database. 

Yes, MySQL locks the table completely whilst it does the ALTER TABLE statement. Most of this time is spent in physically copying the table, which is why it is recommended you put all your necessary changes together in the one ALTER TABLE statement. There are several approaches to mitigating this problem on a live database if you can't get a decent maintenance window. First of all, many environments have timeouts of several minutes waiting for a table to become available for their query and don't know (and it's really difficult to check) just why the table is locked. I've used this quirk of a live website to do changes to tables. On a site I used to look after, I figured we had an allowance of about 7 minutes before someone started noticing. :-) It helps to make sure your boss is on your side. Another way to do it is to do the select-insert-rename trick. This works well if the table either has fairly low frequency, or is purely the target of s. The basic steps are to copy the table's schema, make the necessary changes, craft up a statement to do a from the old to the new, and rename the tables (do the rename in one statement). You also need prepare ahead of time a statement to copy over any "new" records that got added or updated between the and the . I also did this a few times in a past job. However, there are come caveats: 

The first general thing you should do is look at the memory parameters. The default settings for MySQL are very very conservative. Whatever engine you use, you will probably need to raise a number of the memory parameters by ten or even a hundred-fold. The next thing you should do is look at the table cache. The default value is 64, which is only useful if you have no more than about 60 tables. You will want to raise that a long way. The third thing you should do is look at the thread and connection parameters. The default wait_timeout is hugely long for most web-based applications and can be reduced to something like 30 seconds. This will improve memory usage as well, as MySQL will reap connections sooner, leaving much less lying around in a 'sleep' state. 

Note that this doesn't solve the problem of updating the history file when your shells are terminated by a reboot. 

I hate to be a killjoy, but your problem is that you're using Postfix. Postfix makes precisely this exercise very difficult. I know: I had to do it some years ago and it took days and days to get it right. The option is the right one, but there are other things to get right, too. (And even the name of the option shows that Postfix's authors didn't really want to support this.) I recommend switching to Courier. Courier supports this "catch-all" method in a much more sensible way because of the way it extends its existing alias system. 

I remember researching this a little some years ago. If you use Courier for your MTA, which means maildir storage, you could use SqWebMail. This is not SquirrelMail, it is Courier's own webmail client. The advantage of SqWebMail is that you don't need to turn IMAP on because it plays directly in the maildir storage. However, it's really quite a plain client. I eventually got tired of it. What I use now is caleld IlohaMail. It connects using IMAP and is quite bandwidth friendly. It's not as fancy as RoundCube or SquirrelMail, but it may still appeal to you. 

The most fail-safe method is to take down the master database, and copy the binary datbase files from the master to the slave, bring them both up and start the replication. With 350Gb of tables, I can understand this could be a problematic solution. You can gain some time by making the copy the fastest you can, which usually means copying to an entirely other set of disks on the master server. Then you can bring the master back up and you can take your time moving the copy over a slower network link. Copying MyISAM files out from underneath MySQL will work, or at least I know it did in the days of MySQL v3 and v4. (Make sure you have the slave shutdown when you run .) However, this doesn't work for InnoDB files. There is a tool called "MySqL Hot Backup" or some such will is also capable of doing all this in a cleverer way. The catch is that you may have to pay for it, at least for InnoDB support. 

Different filesystems have fairly negligible effects on the performance of MySQL as it doesn't have huge demands on them. XFS is often recommended for how well it handles large files and large file deletions, a combination useful for video storage (e.g. MythTV), but rather less of an advantage for MySQL which doesn't delete files much. Ext2/3/4 are also good performers, as is anything else modern and current in Linux. The +noatime option will positively affect your actual disk traffic, which I have measured, but I couldn't measure any difference to MySQL. Generally, if you have enough database traffic to have to worry about the filesystem under MySQL, then you should be looking at high-end dedicated hosts in a co-lo, not Amazon EC2. 

There's soemthing about PHP in a website which means the MySQL connection thread is not thrown away even though you've torn down the socket cleanly; it still hangs around waiting for it to be reaped. You want to look at your setting for . On default installs, this is insanely long. A website will only need this to be about 20 seconds. You will probably also want it this low if you're using persistent connections. 

You're going to have to learn how to tune MySQL's my.cnf` file. The default settings, and even many of the "sample" settings file are very very conservative. A machine with 8Gb is way beyond what those files are aiming at. The settings you will want to look at are: 

You need to add your hosts by name, first. The registry interface will have an option for this, probably called something like 'Add Host'. It adds them in a special way to the DNS tree so that you can then use them as nameservers. Once you've added them, you can point to them in the same interface (as you've already discovered) as your name servers. Sounds bizarre, but it's a basic 'bootstrap' problem. 

If you have a busy site making lots of connections, you need to keep an eye on the number of threads and connections in MySQL. (They're almost the same, but not quite.) If running shows lots and lots of 'sleeping' threads with times of many seconds, you need to lower variable , probably by quite a long way as it defaults to many minutes and most web pages are over in seconds. It would be good to look at status and see if it is rising rapidly over time. If so, you need to raise the variable . I'd also look at status . If it is rising constantly, you should raise variable . Both of these are basic performance improvements in MySQL for a busy database. You should also setup Munin or Cacti or some other performance monitoring tool on both Apache and MySQL. Apache also has an Extended Status monitoring page which will help you see how to adjust it's child/thread settings.