Alternatively (and probably what I would do), you could make your components a little bigger and just have a generic "Entity" base class that your specific types derive from. This would contain the functionality of both health and armor and you could implement specific entities from that. 

You need to make the distinction between "component" and "asset". Basically, you would have some kind of renderer component attached to your game object that references a mesh (by a handle or by pointer or whatever) and uses that. It's just like how you reference textures by ID instead of having everything that needs a texture have all the pixel data. 

I'm going to go out on a limb and say that the problem might be related to your view deriving from UIScrollView that you're rendering into. You should be handling scrolling yourself inside a stationary EAGLView. 

It probably would be more effort to strip them down, but if you're curious both StepMania and Frets on Fire are open source. 

The "worth" of something can only be determined by you. For some people it isn't worth porting to android for the amount of time spent vs. sales. That being said there's no reason to just use C++ for everything. Sure, the interfaces for certain things is C or Objective-C, but you can call both of those easily from C++. 

You will definitely get something up and running faster using an existing framework that works like OGRE. It's open source, so you can change things to suit your needs as they come up. Everything I've heard about OGRE is that it's just a 3D graphics framework. It isn't really a game engine. So there (probably) isn't a lot of baggage that would make it not particular suited to one game or another. 

I'm assuming you're talking about on-site playtesters and not internet beta testers. Rule #1: Don't help them. Frustration should be the top thing you should be checking for. The ideal situation would be a two way mirror with your team on one side and the playtester on another with one video camera on their face and another on the screen. Obviously this isn't feasible for most people, so do the best you can. Just having your designers sit and watch where people get stuck is very useful information. You're not going to be standing over their shoulder when they take the game home, so you giving advice on how to pass certain sections isn't going to give you the information you need. Edit: another way of putting it is this: Don't think they're "Playing it wrong" Rule #2: Don't give them what they want. After a playtest session you have some kind of questionnaire that they fill out. The specific suggestions they have are usually not wise to take at face value. Usually there's some root cause that is triggering most responses and they just don't know how to express it. If you can figure that out, you'll be better off doing it. Although at the moment I'm having trouble coming up with specific examples. Rule #3: Data is king. If you can (and this is really another wishlist item, honestly), track everything you can. Track where players die. Track where they run out of ammo from a specific gun. Track what pickups they miss. Track what upgrades they buy. Track what enemies do damage to them. Obviously these are FPS-specific examples, but I'm sure there are domain specific ones for whatever game you're doing. If everybody's doing something or not doing something, those are usually areas that you should spend a little more time looking at. Basically, you don't care what player's think. You care about getting raw numbers for what players do. You need virgin eyes to see your game and tell you what makes them frustrated and what they're being led to do. 

Just because things exist doesn't mean that they aren't violating copyrights or trademarks. I'd recommend reading up on those two terms first and understanding them fully. I'm not a lawyer, but from my understanding the breakdown basically goes like this: Brand names, logos, etc. fall under trademarks. So if you call your fan game Sonic anything you can pretty much expect a cease-and-desist from Sega. Trademarks are funny things in that companies are practically required to defend them lest they end up losing them. Things like individual graphics or other art assets, level design, etc. fall under copyright law. If you aren't the copyright holder, you don't have legal authority to distribute them without the permission of the copyright holder. However, things like overarching game design are not. Then there are a few patents here and there. These aren't as common, but do exist. For example, I think the scoring mechanism in Tony Hawk Pro Skater 2 is patented. There are some things that probably fall under both categories. I'm pretty sure an image of Mario can be seen as both a trademark of Nintendo, as well as a copyright of them. So basically, don't do it. You can use game mechanics, and you can make "spiritual successors" all day long, but don't use the name of the game or any non-generic names of items used in the game, or any graphics/sounds/levels from the game. 

Note: To optimize your values, you can simply use the "survival of the fittest" method. Some basic approach of the evolutionary algorithm. To do this, simulate some mice and some cats (e.g. 10 mice, 2 cats). To optimize values for the mice, simulate until 50% of the mice died or some maximum time has passed. Choose the fittest of them (e.g. look at their Health Points) and duplicate them. Slightly modify the values of the duplicates (=mutation) and put them all again randomly onto the map. And repeat this for some hundred times ("episodes"). Do the same for the cats... Your parameters will then automatically adapt to the optimum. You'll see, that there are different optimal values for a different environment (e.g. less/more cheese, less/more cats, bigger map size) 

This works as a first approach, but still causes several "problems". The steering may oscillate and lead to unrealistic, quick movement. The reduce this effect, do the following: * Project the next steering direction like above * Calculate the difference between the current and the projected steering direction and reduce it, if it is above a given change-threshold (maximum speed a realistic driver would be able to turn the wheel in a time slice). You can optimize the refinement by divide and the conquer algorithm ($URL$ Meaning: you set a min and a max for the steering direction and then recursively split that range in half and further investigate only the better performing range (left or right half of the old range). For changing the lane you must allow your car to use both lanes (border of "lane" for collission detection). But, to force the car to actually change lane and not to driving in the middle of both, you have to limit how long the time until which the car must have changed lane (e.g. 10 seconds in future). You can convert this time into a distance using the current speed. Then just let the lane "end" with a straight line (orthographic to the lanes direction) at this distance. Project the lane change, with other cars continuing their current plans. If this works (no collissions, no driving rules are breached) execute the lane change. If not, continue driving on that lane. 

Assume, we are at the leave node (the one in the bottom-left) and have evaluated the game state ("10" at depth level 4). We return the game state evaluation (10) for move variation "left"... then we recursively go into depth for "right", which returns "+Infinite". As this is player B's turn (depth level 3 to 4) he tries to minimize the evaluation. So he would choose "left", as "10" is better because the move "right" would be "+Infinite" (player A wins). So for this node "10" is the result, which is returned, when leaving the recursion. Now we are at depth level 2 and got "10" returned for move "left" - we would recursively call our function for "right", which returns "5". Depth level 2 is Player A's turn... he/she tries to maximize the value and would choose "left" (10). This way we continue until we have an evaluation of the start position. When having recursively evaluated all moves at depth level 0, we will decide for one (here: player A's turn... so he/she would take "right" (-7)) of them an store it as the search result. This needs to be adapted to bomberman: Evaluation must be done/stored for each player separately. And you'll need to search all combinations of all players moves in one time step. The evaluation of a move "m" for player "p" is calculated by the calculating the minimum of the evaluations (evaluated for player "p") of all move combinations containing move "m" for Player "p". The new evaluation of the state for player "p" is then the maximum of the evaluations for those moves. In other words: When in game state "n" player "p" plays move "m" and the other players play their moves, player "p" will achieve at least a score x (= minimum calculation for own view). A player in state "n" always chooses the move "m" that maximizes its own evaluation. This way you will get "backwards" in time to the current game state and know for all players their best move. Even thought simple minimax produces optimal results, it's also -very- slow if your search depth becomes high. You should therefore use alpha-beta pruning ($URL$ which causes -roughly- that "bad" move combinations get less and "good" move combinations get more computation time. The speedup with alpha-beta-pruning is about factor 100. But you should more invest in a good evaluation function and not search too deep through all possible moves. Hope that helps... Don't bother to ask, if you need more help! Stefan 

I'm just guessing here, but are you using shaders? What video card was in the computer you tested on that threw the exception? A lot of older built-in Intel cards don't have pixel shader support. Your only real recourse, if that's the case, is to provide a fixed function fallback. 

Isn't it as simple as having a collection of tile locations and frame counters that get updated? So where you have that code now (in rough pseudocode), 

A naive solution would be to use a small quad positioned and rotated to match the surface where the bullet hit with a transparent texture of a bullet hole. There are some more advanced techniques involved if you want the hole to clip properly if you shoot near an edge of a wall, or if you shoot something rounded. These are called "decals" if you want to look into more details. Here's a blog post that goes into some of those techniques. $URL$ 

One of the biggest speed advantages from using a sprite sheet is that you can render multiple instances of the sprite batched with a single draw call. If you do it with individual images then each character (or whatever) on screen is going to be a different draw call unless they happen to be on the same animation frame. In general you probably want to atlas as much as possible onto a single sheet. 

You can procedurally find out how to do a moving AABB/AABB trace with the formulas on this page. $URL$ Basically those equations will tell you what percentage of your move you should do that frame, which will allow you to place your square at the correct location. 

My rule of thumb is that unless you're O(scary), your other issues are more pertinent. My other rule of thumb is that data is king. Unless you profile your code with a realistic data set you're just making guesses. Edit: To go into a little more detail, your big O isn't that important since (at least in my experience) most of your data sets are relatively tiny. You probably don't care about your upper bound of performance when you're working with a data structure with fewer than a few hundred elements. And if your lists have 100k+ elements then you really need to consider all aspects of your algorithms. That, and from my experience memory is more of a limiting factor than CPU speed. A faster memory hogging algorithm might not be as good as a leaner but slower one depending on your use cases. 

Sure the Game state would be huge, but there's no reason that the Game state itself can't contain a state machine to manage its data. Hierarchical state machines are useful. 

It isn't entirely clear, but what are your goals? To be a game designer? What do you think that position is/does? In the basic case, as long as you're not writing actual code, not knowing C++ specifically won't hurt you. Of course, having a fundamental understanding of programming itself (object oriented design and being able to think in terms of conditionals, etc) is going to help you. What C++ itself does compared to C# or Java probably isn't going to matter when it comes to helping design game rules that are easy to describe with code. 

The easy/naive solution would simply be to take your existing points, and for each point have a corresponding point that's at the same Y position but off screen. From there, create your polygon by taking, say, points 0, 1, 1's pair, and 0's pair and pass that to your DrawPoly method. Then continue on with (1, 2, 2's pair, 1's pair), etc. 

Unity's store page should be straight forward. If you want to deploy on iOS you need an iOS license. If you need/want features from Unity Pro, you need the Unity Pro license (or if you don't qualify for their indie license). The only other costs associated with deploying to the various platforms are the developer licenses from Apple/Google to actually deploy your app on their app stores. 

Photon Socket Server is a middleware provider which is using C++ as the underlying framework but the bulk of the logic (i.e. what you have access to) is using .NET. 

Games from Within An iPhone game blog. Deals with indie production issues, OpenGL ES problems, iPhone specific features (such as in-app purchasing) and their results, shares sales data, as well as general production issues. A good general article is Prototyping: You're (probably) Doing It Wrong 

You're trying to accomplish two things with this design. 1) Determine the "type" of an entity. 2) Separate out some code that constructs entities out of some "monolithic builder class". Comment on point #1: I'm going to frame my context within how Unity handles component based design, as that's how I'm most familiar with it. In their parlance, you have (which is analagous to in your example, I would imagine) which, basically, just contains . You derive from (specifically a subtype of Component, but that's unimportant). Nothing derives from GameObject. When a collision occurs (because you have game objects with some kind of physics components attached), the engine sends a message to every component on those game objects that such a collision occurred along with some appropriate variables. If you need to determine what course of action you can do a couple of things. 1) Check the name of the game object and do some logic. This is probably a bad approach. 2) Check the tags on the game object you collided with. The component that handles that for the player could check to see if they collided with something that's a friend or a foe. This is an okay approach, but limiting. 3) Check to see if the game object collided with has a specific type of component attached, and then do appropriate things. So the player component could see if the thing it collided with has a component of type , get that instance of that component, then do something with it. This is probably the most powerful approach. Either way, from the way you're describing it, having things that derive from your class in a component-based system is kind of missing the point. On #2: It seems like a method that constructs a "Enemy Space ship" can just be a helper function somewhere else. It probably doesn't even need to be inside a class, depending on how your engine is set up with globals. You can just as easily separate them out in multiple files without doing something like setting up yet another inheritance tree. Also, it's worth noting that Unity data drives game object construction, generally. Implementing a system that lets you design an entity in an editor will reduce some of this monolithic code you have an issue with.