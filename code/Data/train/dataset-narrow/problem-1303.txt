I agree with the other posters that a visitor pattern would be a viable solution. One important reason being, that a node usually holds some payload, not just other nodes, and you want to have a mechanism that allows you to be very versatile on what you want to do with the data in the tree. You may want to count the number of nodes, you might also want to count the number of nodes, where the payload matches some criteria, or you want to count the number of nodes that do not have a left and a right sub node or whatnot. You don't want your node to contain a method for every possible question you want to ask your tree. You might want to read my blog post on the LOD and structure agnostic access for a rather freaked out, but general solution. But be warned it's possibly not the kind of code you might be used to and you might not find it particularly "pretty", as it trades type safety for "simplicity". But a visitor is not the only good solution out there. You may prefer to implement a method that returns an iterator, or even a Stream of nodes. This way you could use the Java stream API and be very versatile. As for the interview: I often feel that programming tasks in interviews are misplaced. The résumé should give you enough of an idea if you've got an experienced programmer or not. Once the person is hired, code conventions, code reviews and tests should shape the quality and style of the person's code to your needs anyway - and there's a probation period to see if the person is not up to your standards or toxic. The only thing that a little piece of code is good for, in my opinion, is to sort out freshmen and students who don't know how to code, but claim to do so. In job interviews I might like to talk about a piece of code and discuss its style, not for the sake of labeling the answers "right" or "wrong", but to see how they think about code: Are they the pragmatic kind of programmer, are they code-poets with a love of style and readability, will you have to brake their tendency for over-engineering or will you have to nurse them a bit more? Do they make good points, are they the timid or the outspoken kind of person? You might feel you lack the one or the other kind in your team and that might make a difference in the end. But I feel that, if I look at a résumé with plenty of projects on it, that I should be able to assume they know how to code and I don't want to insult them with giving them programming tasks that are not related to their daily work at this company, but rather to their first year in algorithms and data structures class. Discussing your piece of code above, I would, for example find it perfectly reasonable, if the candidate said: "This is a pragmatic solution for counting nodes and maybe something similar, so if that's all there is to it, I'd be fine with it. Still, if it is foreseeable that we need more than just two or three queries, we should have another object do the query." That'd be bang on. 

If you noticed the only thing that does is to store a hash version of . Just a simple data structure containing name, description, price, image url, etc. Now, even if the gets hard-deleted at some point, you'll always have the raw data which will allow you to represent the in any way you want. Optionally, you could store a reference to the original in case it exists in your database. Historical data integrity is not about deleted data only. What will happen if someone changes the price for a that has been around for a year? All orders that include pizzas containing this topping will be affected. I think the keyword here is auditing. Auditing a model, means to log data changes throughout time. 

Every time an ordered pizza is created you will dump each 's data to a instance and you'll save it. For example you could have something like this: 

Saving customized pizzas this way, looks OK but it also depends on how the rest of application is structured. I think your biggest concern here should be the historical data integrity you mentioned in your second question. When it comes to data, the context they live in, helps you figure out how you should treat them. For example, when running a business like a pizza store with online ordering, toppings once available to customers can't just be "deleted". They can become unavailable, discontinued or something in these terms, but not deleted. You can't respond to customers that ask you to add pepperoni to their pizzas: "Oh, we deleted pepperoni!". Once data hit production they will always be part of your application, despite how their status changes, so you have to treat them as if they will always be around. This is somewhat a common issue and there are a few ways to solve it. I can mentioned two of them which I've used in the past. 1st Approach: Soft Data Deletion The first approach, would be to go with some sort of soft delete policy for your data. You can find many posts across the internet about this technique and you can find many gems for which could be used right out of the box. Practically, what you achieve with soft deletes, is that, when you're deleting data, you're not really deleting them, but you mark them as deleted so you can exclude them from your queries. The most common ways to do this is either by adding a new column to your table that indicates a record has been deleted (e.g. , ), or by adding a separate, mirror table in which "deleted" data will be moved (e.g. ). Both options have their pros and cons so it really depends on how the application is designed. Keep in mind that soft delete may add complexity to your app. For example what will happen when you require to be and you try to add a new topping with an identical name that already belongs to a soft-deleted topping? 2nd Approach: Separate model for customized ordered pizzas The second approach would be to treat s in a completely different way. The idea here is to decouple from . It could look like this: 

Naming is hard, particularly as is really the element that failed the predicate, and everything past that point. Multiple Parameter Lists This change was partially a help for the compiler, and partially to enable a bit of syntax that I'm partial to. 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

Alternate Implementation Another alternative, which is arguably simpler, is to implement this as a case class with function arguments. This implementation is exactly equivalent to the refactored version above, and is arguably simpler and easier to use. 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1