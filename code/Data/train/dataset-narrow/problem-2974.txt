To sum up, the curriculum given by you sounds quite good to me. Except for the adjustments proposed above, I don't see much that needs to be changed. 

1 After reading through your question another time, I guess I've misunderstood the question and you only asked for a solution for the first item in my list. I think I will nevertheless share my thoughts on both - maybe they can be helpful for you or any future visitor. 

If you already use an IDE, this could be the right way for you: Git support in your IDE Many IDEs come bundled with Git support. Eclipse, for example, uses EGit for Git integration. The JetBrains IDEs also provide Git support. The text editor Atom can be extended with plugins (e.g. Git+) to provide Git support. All of those IDEs run on most common platforms (e.g. Linux, Mac, Windows) and look more or less the same there. This would mean you can use the Git client you know at home and at work if you use the same IDE at both places. Normally, the Git support integrates quite well with the programming workflow. The Git clients are often quite mighty, but always accessible using a comfortable GUI, which could help as there are no terminal commands to memorize. However, you should keep the Git concepts in mind - depending on the IDE, the built-in Git client will follow those concepts more or less closely. 

This is just the process of making a program. The combined instructions that eventually make up your program are often called "code" by developers, so they use the verb "(to) code" to describe the process of writing down instructions to solve a particular task. 1 As Brian H. pointed out in his comment, a more precise definition of a programming language would be "a set of syntactical and grammatical rules bundeled with a standard library that provides instructions to tell the computer what to do". However, as you asked for an explanation in layman's terms, I wouldn't recommend this definition to explain what a programming language is. 

Source: Executive Office of the President, Office of Science and Technology Policy, Fact Sheet, Oct. 14, 1999 After review, and an appropriate comment period, it was finally edited to read: 

How much access should I allow the students to files (theirs, the common directory, and lesson-based directory)? I.e.: should they be able to access them from outside the classroom and/or school's network? And, should they be allowed to create a public-facing web page/site as part of the server's function? I'm thinking that full access from anywhere will allow them to work on projects outside of class without having to move files back and forth with thumb drives. That will also mean that I can give them larger assignments as homework rather than having their coding work only be labs. I'm also considering that the ability to have their own website will give them greater investment in the class, and greater desire to learn things to make their "Own" website better, and stand out more. Again, IT claims they can handle the setup and security for any of the ideas I've presented them, so security and maintenance are not issues, just how it may affect their education. I am also wondering if it's better to configure the server with the latest stable packages, or if I should make it closer to what most low-end shared hosting accounts have. The shared-hosting environment is what they most likely will encounter if they choose to do something personal on the Web now. Doing so, however, will restrict some of what I can demonstrate with newer packages. 

The language of the books is aimed at college-level students, and the equations and explanations seem to assume the student has a prior understanding of the "language" used in the mathematical analysis. Therefore, I couldn't recommend using that as the textbook for the class, or even for that segment of class. I can, however, recommend it as an excellent starting point for your lesson plan. Using the progression of his explanations for finding the growth rate of an algorithm, you can rework the examples, and the application of mathematical concepts so that it better fits the knowledge of your students, and carry it forward in a manner consistent with your style in the class so far. The method used to show, and find, growth rates, and the Big $\Bbb O$, Big $\Omega$, and Big $\Theta$ are decidedly non-math in their application, and adjusting the material for the students you see in your classroom should be reasonably simple. I agree that you should give your students the exposure to the subject, and deepen that exposure as much as the curriculum will allow. I've found, after learning from that chapter, that I am equipped to explain my analysis of a routine, and its possible optimizations, much better to other programmers - whether they know Big $\Bbb O$ notation or not. If someone does know Big $\Bbb O$, it is an excellent shortcut to explaining why a routine is slow, and if they do not know Big $\Bbb O$, I am now able to quantify and explain what I used to intuit and couldn't explain. The Mathematics Involved Again, the mathematics is more for explaining the results than for finding them. Understanding what the graph looks like helps a lot, by orders of magnitude. The online graphing calculator mentioned by Buffy in another answer is an excellent way to deal with the math involved in understanding the growth rate that Big $\Bbb O$ notation signifies. I once made a similar, if much simpler, tool for explaining the concepts of linear, logarithmic, and quadratic to GED students. What they couldn't grasp with words and text, the readily apprehended with interactive visuals. The Testing As this will be the introduction to Big $\Bbb O$ notation, and at that only a "dip your toe in the water" type exposure, testing on the subject probably shouldn't be very intense. If you covered the complexity of heap sort and can write a heap sort in a manner they have not seen, then use that and ask them to find the Big $\Bbb O$ of the new version. It's still a heap sort, and they should be able to reach the same results as for the one they've already seen. Additionally, with some short code fragments, have them classify the fragments, or use pairs or fragments, and ask for the one with the better Big $\Bbb O$ for a significantly large value of $n$. The idea is to reinforce the usefulness of the analysis, and that Big $\Bbb O$ notation is only a simple, common, way of expressing the complexity that allows for comparing algorithms and selecting which one to use in a new situation. Leave the finer details for later courses when, and if, they pursue a CS curriculum. 

When comparing it to your curriculum, I think there are many good elements in it. However, here are a few things I noticed: 

Why should you try to teach every interested student and assist them in reaching their different personal goals? I think you've already given the answer in your question: Because each of them is genuinely interested in learning something. In my opinion, one of the wonderful things about schools is that they are designed to be places where knowledge is spread. People who already know something about a topic (often these people are the teachers, but even this doesn't have to be the case every time) share their knowledge with people who want to gain knowledge about this topic (usually the students). In reality, this principle is sometimes hard to encounter: As there are usually a lot of required courses in most school systems, you'll always have students who aren't interested in learning something, but are just forced to attend. Still, as I want to focus on the idealism here, I think the reason why teachers should try to teach everyone who is interested is because teaching every interested person is the primary objective of a school. When discussing this question with some others, it might be good to reach a consensus on the level of the discussion: I could imagine that somebody argues with you about this question assuming you are talking about a given, realistic situation and wants to convince you that in certain situations it's (as you also already stated) just not possible or incredibly difficult to teach everybody. 

I once wrote a course to introduce Java. My order of topics was as follows: (Note: Those are not lessons, just the order I've written the topics down). 

1: Source: BBC Bitesize - KS3 Computer Science - Introduction to computational thinking 2: Source: Jeannette M. Wing "Computational Thinking" Communications of the ACM. 49 (3): 33. 

There is, most assuredly, a lot of ground to cover there, and it does not look any "easier" with a full breakdown. The referenced web page (ibid.) lists a breakdown of the topics followed by the learning outcomes. I think the learning outcomes likely to be more significant in answering the OP's instant question, and have reproduced them with their subjects below. 

will cause more students to stumble, and not necessarily later. The emptiness might make apprehending the statement block concept more difficult than it already is. I'm also not so sure you should even divert into the infinite loop of at all. If you do use the LED-alertButton combination you presented in the question, modify it to respond as a toggle rather than a one-shot that turns on and then appears to ignore all future button presses. The program might loop forever, but it will look to the students like it turns on the LED and then stops responding. 

To balance that out, and to show the difference, here is the recursive version, also tested and timed. In this case I've removed the comments, just as a visual enhancement of the difference between the two versions: 

Since your students are getting the beginning of Boolean from you, you have the advantage of being able to lay the proper groundwork to work within. To begin with, hopefully, you will be stressing the point that Boolean logic is two-state. You can use the word binary if you choose, as long as they are not predisposed to think binary = computer, since while Boolean logic is handy for computers to deal with, it is not just for computers. To connect the symbols, meanings and math together, make it explicit, and demonstrate. Start with the concept that is the same as nothing and is the same as something. "I have an apple in my hand" is if you have no apples in your hand, even if you have an orange, or a pencil. The same statement is if you do have an apple in your hand. It is not, however, more if you have two apples, or twenty apples, in your hand, however, it is still just . Zero, as a number, represents nothing as well - zero apples is no apples. Therefore, it makes sense (dare I say it is logical?) to use the number to represent . Using the previous demonstrative phrase, it only takes one apple to make the statement , and at least one is something. Five is also something, but that would leave out everything from one to four as maybe, and Boolean logic has no , so that creates a problem. If some starts at one then there is not need for a . Using for something, and therefore , gives two symbols to use instead of the words and , which can get quite long to write in a very short while. The next step is to introduce the symbols for and . Here I will, marginally, disagree with how and why your are using center dot for . I am not opposed to that usage, only the reasoning behind the choice. The students have not had algebra yet, so it seems a safer choice than . You can tell the students you have chosen for because it is what they are most likely to encounter later. They should also be told that it can also be written as , and that both can also be used for multiplication ins algebra. The same way that means for this class, and will mean in mathematics (and in rectangular coordinates). Likewise using for in your class, while it will mean addition in mathematics. Rather than shelter them now, only to create confusion later, deal with the reality that we only have so many different symbols we can use, and many times they will have different meanings in different places, and knowing when, and when not, to use as is part of learning about Boolean logic. We need to toss in one more symbol here as well. Replacing the word with the symbol (or symbol of your choice) also comes in real handy. Since the students have not had algebra the next step might be difficult. Connecting the Boolean operators with the mathematical functions. Connecting the addition to first, because it is easier to apprehend, you can give the samples , , and . Rewrite them in symbols as , and . The first two will be obvious, make sense, and get no questions. The third will start them thinking and should get some questions about "why not ?" Return to the apples: zero apples made the statement false while any apples, one, two, or a dozen, made the statement true. So, any number other than zero is true. You can call it part of being a two-state system - either it is zero, or it is other than zero. Therefore, the last of the three samples can be expanded to: 

It probably won't fit particulary good for you, as you want the same GUI on every platform, but I want to suggest GitHub Desktop for future readers, who don't have the platform requirement. GitHub Desktop GitHub Desktop (source code available on GitHub) is a graphical Git client by GitHub, available for Mac and Windows. It's especially designed to integrate with the hoster GitHub, but should also work with other Git hosters. I think it's intuitive to use the version-control features of GitHub Desktop, which could be an advantage in your case, as this helps against forgetting commands. It, however, does not follow the concepts of Git closely - so you will encounter some things that may be intuitive in GitHub Desktop, but appear strange to Git users who know e.g. the command line interface. As Steven Vascellaro points out in his comment, this could be a major downside when wanting to learn Git: 

As with the human languages, there are multiple programming languages. To develop in a certain language you usually write (text) files containing the instructions (you could now mention how this looks in a programming language you like). These text files are read and executed by the computer. Depending on whether the language is low- or high-level, the computer might need additional software (the interpreter) to understand the language. Often, developers use so called IDEs which make development easier as they offer hepful features (for example, automatically creating instruction(s) you normally use a lot or immediately pointing out errors). 

I would therefore recommend GitHub Desktop to Windows users that want an easy and intuitive way to manage Git (e.g. because they have to use it inside their company) without having to deal much with the sometimes counter-intuitive (looking) concepts of Git. 

As a guest in the computer class, you could look for any instructors that rely on computer programs in their course material. Especially useful would be any that employ a program that is Free/OpenSource software. (If it is hosted on GitHub where they can also look at, that's even better.) A good candidate might be an art class that uses GIMP. 

Source: Federal Register Vol. 65, No. 235, Dec. 6, 2000, pg 76262 I did find one good academic source: 

A modification to the traditional classroom arrangement that is relatively simple is to replace the straight tables with half hexagon tables. Place them so that the center seat is facing the front of the room and the other two seats will only need to pivot 60 degrees from their screens to see the front. The students will still be able to look at other screens, but not without being obvious about it. It naturally groups the students into teams of three for when you have team-based assignments. You can have a pair of mirrors installed in the two rear cournes near the ceiling. In the mirrors you will be able to see basically what they have on their screens. Reading it, or even knowing for sure what it is won't be possible, however, you will be able to tell if it's what should be there. Games and videos will have a totally different look from an IDE, for example. Set the tables into a normal rank and file arrangement with a gap between each column that allows you to walk between the students when seated. (The gap with students in their chairs will be less than it looks like with empty seats.) In this arrangement you can get to any student's station to assist them when needed. In addition, because of the geometry of the half hex layout, the gap between neighboring students is increased, allowing more room for you to reach the table top without disturbing either student. Half hexagon tables are available in some different set ups. You can use the standard, non-computer style that may even be in storage already. I've found some online that are designed, nominally, for computer use, and a bit larger to accomodate the keyboard and monitor space requirements better. I've also found one that's designed completly for computer workstations, including a keyboard tray and a cage for the tower. (Links at the end.). Not knowing the constraints of the classroom itself, I can only give a sample layout. Allowing for 36 students, you could arrange the room similar to this.