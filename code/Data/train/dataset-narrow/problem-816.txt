So that the user could input the values. A program where you need to change the source code to get what you want from it is not very useful at all times :) A simple input method helped me a lot in testing what the correct answers were. (I did not find any erroneous output by your program, well done on that bit) So I changed those two lines above to: 

Naming Your class is named , it should be named as all classes in Java should start with a capital character. 

That is, the opening brace goes on the same line and not on its own. As you're coding Java, I'd recommend using the Java convention. At least your style is consistent though, but as it seems to be code for teaching others, it's important to teach the correct conventions. 

As your input never contains (and I see no reason why it should), I don't get the point of using that non-null check. I modified your code to use instead and removed the non-null checks and all worked well still. It even got rid of some indentation steps and felt like a cleanup overall. Iterate over what? If you would have your as instead of you could use your iterator in your method as well as in your test method to fetch the results. This would make you have to modify your iterator implementation though (but as your tree is not a real binary search tree, it's quite broken already). Or you could just ignore the tree structure and use arrays.... Summary Given how many trees I've seen you implement, I really thought your code would be better than this. Your current code doesn't live up to your requirements, or your requirements are messed up. Additionally, the "raw type" mistake is a mistake one just should not make after having written just a few Java classes. 

I'd recommend getting rid of these special cases. To do this, you can check for special conditions inside the for-loop. Loop through all the positions in the string, and check if there is a on that position. If it is, then check if the position is more than 0 (i.e. it has a char in front of it) or if the position is less than (i.e. it has a char after it). The details about how to write this can be done in oh so many ways, but here is what I would end up with: 

I get it that you're writing this in ideone so you cannot do this, but for the record, that class should be 

Well that's one useless constructor. A public constructor with no arguments is always available if no constructors has been provided. And is automatically being invoked as long as the superclass only has one default constructor. 

This will make it a lot clearer to see which actual exceptions that can be thrown by which code. Avoid catching the overly-generic and . Only catch the exceptions that need to be caught. 

By using a method, you allow multiple objects. (Not at the same time, but still multiple objects). Other comments You have one field and one local variable in your method: . They share the same variable name. This leads to confusion for me. I don't see much of your field. (Of course, I don't see your subclasses to this method). You might want to pass the object on to the methods instead of storing it as a field (again with the principle **Tell, don't ask). Will that object ever be used again after has been called? If not, remove it. In your , you declare a new local variable on the last line of the constructor 

I understand that you're doing this because the possibility of returning null, but a slightly better way in my opinion would be: 

What does all winning conditions in Tic Tac Toe have in common? They are all straight lines! The idea of having one method that can be called multiple times is a good one, to do that we need to input the starting position, and how much we should change x and y with every time. We also need a way to stop the loop, we can either stop when we notice that we will go out of bounds, or we can stop after a specific number of checks. In this implementation, I chose to hard-code as the limit for how many tiles to check. 

Private, final, and constants There are plenty of instance variables in your code that could be private, final, and possibly static. 

Or at least, if you don't like the conditional operator (), use the for but do before or after the if/else. 

And now, speaking of , we can transform this for-loop into a traditional for loop, by adding both the initialization and the iteration to it: 

Your actual code While reducing the code duplication for the individual buttons is important, let's take a look at the code that is actually performed for each button! Step 1. Adjust spacing to adhere to the Java coding standards and remove unnecessary parenthesis. Step 2. is used in both and , so put it outside. Step 3. In the part, you're doing the same thing no matter if and is the same or not, so reduce code duplication by simplifying that logic. Step 4. Remove empty statement After these steps, the code is: 

A different approach that's capable of doing the same thing Consider Google's EventBus code. With the right event classes, this can accomplish the same things. Example code following: (not tested, but something similar would work) 

...actually says just as much as the default one, if you would not catch the exception in the first place: 

Reusability If you want this re-usable, you might want to not have all the methods static, so that they can be overridden for example, and you might also want to look into using the Strategy pattern for the method. Appending zeroes 

Only being able to do the job on is quite useless. Your method can take an argument of type instead. 

has some duplication from . It might be better remove the output from and call the methods like this: 

In you have the name , and in / you have . Notice the capitalization difference? And what is that doing in that name at all? It seems like it is being used as a , so and would be better. Speaking of your and classes, I really think those two have way too much in common to be considered different classes. Make one class and instantiate two objects of it instead. 

Additionally, I'd again recommend using percent values to avoid the division with stage size. Help pages Your returns a First of all, use the interface to return . However, as the keys for this map are essentially indexes, you can use . In fact, as you don't need any dynamic resizability, you can use , which will allow much easier construction of the help pages. 

(Note that I changed to ) Additionally, after (which could be btw), it can have a negative number. Make sure that never goes below here. (or technically , as it is increased by one directly after) 

To get an array of all the muppet enums, use . If you want the possibility to add muppets dynamically at run-time, I would make a and get the position of an item using . 

Let the user whenever he likes create a object, and call the method on it (as you've done in the sample). There is no need for your to know which is the current showing activity, it only needs to know about an activity (or rather, ) when it should do something - i.e. possibly show a dialog or read/write the preferences to keep track on how many times/days the application has been used. When the user of your library wants your library to possibly show the dialog, let it call a method on your library and pass along the current as a parameter. That's it. No need to make things more complicated than necessary. Summary By extending Application as you've done in your question, you have only added a middle hand that doesn't add any value at all. All the things that are done there can, and in this case really should, be done in the instead. 

I consider this a long and tedious way of adding data to a list. A , just like many other collections in Java, has a copy-constructor where it can take another list as argument. This makes it possible to write a much shorter way to setup your list: 

This method does exactly the same as your original one, but indentation has been drastically reduced (which often helps readability) and some special-cases are dealt with first. 

If you use this , then you won't have any use for your current and classes. Each time, you just subclass the and override the method you want - leading to very similar functionality as that of how default methods in an interface works. 

Finally, imagine if you would have the requirement to handle more than one grid at a time. Your program would really need as an independent class in that case. (Currently, it doesn't need it, but it would be useful). Many of your methods are returning and doing the output inside the method. It is a better idea to return the values required for the output, and do the output outside the method itself. Imagine a grid ...who said it has to be 10 x 10 at all times? Consider the name ... anyway, consider a class with these methods: 

One thing that I find is that it is not necessary to wrap your keys inside their own inner class. Putting them inside directly is enough. 

I would personally recommend the first version, as the second version creates a long statement and is a bit more difficult to both read and debug. 

Ah, this is where the score comes in again. It's important to distinguish between a Question and the user's answer to a question. Maybe your system should support multiple users that should be able to answer different things? Then you need to connect each question that a user has answered to a score. So, besides the Question class that I've already mentioned, you could have some more things: 

Formatting USE PROPER INDENTATION - Please! If you're using Eclipse, press Ctrl + Shift + F. If you're using Netbeans or IntelliJ, press Alt + Shift + F. If you're not using any IDE, start doing so! 

Checking if a list is not null is a bit dirty. Avoid using null when you're dealing with lists, use an empty list instead. I don't like that you are passing on a list of Strings to this method. You aren't loading from XML currently, you are doing things programmatically. So I would pass a to the method. Then, later when you are loading from XML you can check the strings in the XML and map those to actions this way. 

At least four places. What if you forgot to change your code on one of them? OOOPS! - . First of all, notice that all the cases in your big is actually doing the exact same thing? 

Whenever you find yourself using multiple numbered methods that does very similar things, think: Array!! (or possibly if you want to be able to add/remove dynamically) 

Iterating through adjacents There are two main approaches to take while iterating through the neighbors in Minesweeper. The first and most common option is to use a nested for loop: 

There actually isn't so much to improve here (at least not that I can think of). Instead of using an index to iterate by, you can use a Java for-each loop. Since you only used the iterator variable to read the index of the list, it is usually more readable to use a for-each loop. You were not indenting your code correctly (before the edit of your question), which I also fixed below. And, below I use the opposite way of checking if the text is empty, by using if the if-statement is not true, you can avoid having to indent the code an extra step. 

Algorithm Now, about that algorithm... You have a variable called and yet it isn't a stack structure, it's only an array. Using a somewhat real stack structure can be helpful. In the code below, I have used the class to provide this structure (Even though there is also a class, I like the interface and wanted to go with ). In this code, I have improved the variable names, the return type, and I am using a to store all "special" characters in. The method of a HashSet is performing in constant speed, so you should not experience any significant lack of performance. I noticed that in your if-statement, you had hard-coded the values that were put into your , this is what made me want to add the . To make this work, I had to flip the key/values of your HashMap. The key is now the starting character, and the target is the expected ending character. The loop through the string here is pretty simple and straight-forward: 

DING DING DING - threat static variable has been detected. This static variable is a big no-no. When you are accessing this variable you are breaking the Tell, don't ask principle. You should pass methods the information they need to do their job, they should not access static variables outside their scope to grab information. As there can only be one version of a static variable, this value can never have two separate values, limiting you to only one available at a time (and don't even think about making a to solve that!!) This static variable is the biggest problem in your current code. Expression enum