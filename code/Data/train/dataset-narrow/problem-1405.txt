On my 4 Core machine with VS2015U3, this reduced the execution time from 120 to 20 Seconds and reduced the error roughly by a factor of two. Small style tips: 

I don't think there is anything wrong with your general approach (or at least I don't have a better suggestion). On an implementation level I've a few suggestions 

For some time it has been bothering me that there is apparently no way to directly initialize variables from input streams (something like ) My solution is this: 

In response to the comment about multithreading: You can (more or less) trivially parallelize by letting each thread generate the new cells for a slice of the world (e.g. a quarter of the rows on a 4-Core machine). There are many parallel loop implementations out there that can make that Task even easier. Obviously this is only sensible for very large grids. 

Using STL algorithms If you want to advance an iterator by a certain number, you can use std::advance instead of a loop: 

You default construct all nodes upon construction of the stack and destruct them when stack is destructed, in which case is unnecessary. One can just use an array of nodes and pass it to the unique_ptr. In this case you also don't need a destructor for . Obviously that only works with default constructable 's and makes only sense, if T doesn't hold any resources after it has been moved from. You actually create and delete objects upon calls to push and pop, in which case you have to use placement new () and manually call the destructor (not ) 

As mentioned before, I'd replace the class member with a local in and pass the array as a const ref parameter to . This gets rid of the mutable problem and might even increase performance. I'd write the function a little different: 

A final remark: although, you said error checking is not necessary, I'd probably at least put an assert into place, that checks that the indices in p don't exceed the size of the list you want to print elements from. 

Const correctness: A lot of variables are only initialized and never changed afterwards - make them const range based for: You could use more range based for loops (e.g. when joining the threads, creating the seed, or some loops that go over the array of the random number engine. 

I also made the deliberate design choice, to not provide a virtual destructor due to the overhead it would incur and the fact that I don't see any use case, where I would want to destruct const_string via a pointer to . Still this goes against best practices and might be suprising for other people using that code - would you accept such a code in your codebase? I haven't finished documentation and the unit tests yet (I hope the code is readable enough), but here is some sample code to play around with: 

i would add a comment which explaines detailed what this regex is suppose to do. So if there is an Problem with the Regex everybody can check if the regex is doing it's job or if there is a problem in the expression. Throw an exception in your constructor, so the errormessage can be cought. Now the error Message is displayed in the frontcode. 

Last but not least: try using "'" for strings, so its more readable and you make less errors by escaping not escaping closing, whatever 

Why does the Methods and return null? Wouldn't it be better to throw an exception, that you can signal that something went terribly wrong? In my opinion returning null is always bad for developers who are using your code, becaus they don't know what went wrong and what to change. At your example you are expecting CallMethodB to return an Object. So if nobody throws an exception everything has just worked fine, use the return value, if it is null let the nullReferenceException occur and enjoy writing well code. Removing Null checks would increase your readability and the reusablility of your code! 

Developed and successfully tested on Mono/OSX As far as i can see, yes there are some points where performance can be gained, but i would be intrested, if this is the real bottleneck. As the others before i believe the huge performance gains can be made in the database update code. But I'm ready to be profen wrong and so I would be verry interested in your performance mesurements! Output Snippet: 

Hope i could help, please contact me if you have questions about my snippets or if you are interssted in my decisions. I would enjoy learning from you and also would be glad helping you! 

Try assiging values first to a named variable and then concating it, so its sustainable in the future like: 

I think this should do what you expected to do. Enqueue all Numbers greater than 20 if no number is in the queue of the thread. Please leave a comment if you wanted to do something else, i would be glad giving you the right examples. 

Remove empty try-catch blocks and replace it with propper checks If in the lower section is null you wouldn't set Selected Property of Row due to the thrown exception before. In my code i want my exceptions to be seen or recorded by the system, so I can fix it. You don't know what else has gone wrong in that Method. Throw speaking exceptions so any user can change his input to fullfill the requirements of the application or can create a new bugtracking issue with the propper information. Try using local Variables instead of calling Properties over and over again. Current you are using 5 times. If the Propertycall takes about 0.5sec you are currently burning 2sec :-) Try redusing it where possible. It also gets more readable. 

Aside from general advice of how to improve my class (I bet, there is a lot), I'd especially like to know if 

First of all, as DarthGizka mentioned, your code is mostly easy to read and understand and except for the memory leak I mentioned in the comments I don't see any errors. I can't really contribute on the general question, of how effective skiplists are or what would be the best algorithm to determine the height of each node, however, I think there are still a few things that can be improved in your current implementation: General Interface I believe this is more of a proof-of-concept, but on if you go on with it, you should probably strive to make a interface more similar to STL-like associative containers. Meaning in particular: providing iterators, template the class on the member (and key type), providing the typical typedefs and functions (e.g. ) etc. As mentioned by others, this would also make it easier to compare it to other data structures. Making a nested class Skip_Node is an implementation detail that should not be visible outside of the class, so you can just make it an nested class of . Const correctness and static member functions You have a few member functions that should be specified const (, ) or even static (, ). Structure It seems that you assume, that you will never add an item to the container with the same key as the key. If that is the case, you should probably document and assert that. However, this also means, that there is no need to treat the node in a special way. More to the point: The main reason for using dedicated and nodes is so that your member functions don't have to care about empty lists, or whether a new node is the first or last node in the list. If you embrace this concept, then you can e.g. make a one liner that simply returns the size of the vector. Also, insert and erase seem a little long to me and share a nontrivial amount of code, so you might want to refactor the common functionality in a separate function. Finally, seems to be a pretty heavy member for the list nodes (due to the size overhead and the additional memory allocation). If the maximum level is a compiletime constant, you could try e.g. a member array instead (possibly using multiple different node classes of different sizes, as suggested by DarthGizka). Dead Code With the above in mind and when you carefully think, about what invariants hold at each line of code, you might see, that there is a lot of test that always evaluate to true or false and code that never gets executed. Comments Nice to see a thoroughly commented code. Personally I would write the function documentation at the point of declaration (in the class definition) and I also try to avoid to write comments basically repeat the code the code. After reviewing and refactoring your code, I ended up with the following (some of the changes are just personal style):