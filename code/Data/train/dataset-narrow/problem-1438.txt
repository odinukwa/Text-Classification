Consider doing this at the getopt stage itself. That is the right place to ensure correct number of arguments to each option. I would also consider just printing usage if the number of arguments do not match. 

Regarding your problem of performance, time the program with the itertools permutation output alone (without dict checking). My guess would be that the permutations is taking the time, but it would be nice to verify. You may also want to check where the valid words are getting filtered. (Since you say that not all the words are being output). My guess is that permutation produces them but is not present in the enchant dictionary. But please verify. Here is a possible rewriting of your code. It removes the redundant sorts 

Think how you would like to keep the seconds minutes hours, Keeping it as seconds as in previous comment is a valid option. Another that does not require you to recompute it but will still simplify your code is to keep it as an array of 3 and index it by enum. Note that it can be extended easily for date, month year too. 

grouping list separated by some values intuitively seems like a group by operation. That is, abc,def,ghi => (abc)(def)(ghi) So groupBy seems more intuitive for me, and it results in more concise code. 

What happens when the name extraction fails? Also you assume that the name extracted is a valid file name. Is that always the case? (What happens if it is a query?) And I much rather prefer a smaller match like 

Now, as far as extendibility goes, You need to add newer conditions, it is not a good idea. What you have coded here is just an FSM (A state machine). The easiest method to capture a state machine is to turn that into a regular expression. In this case, Say, the ordering is 

Here, I think you wanted to exit the for loop if start was found true right? Add a break after the assignment for both. You want to do this for most of the loops. 

Nice effort, :) here are a few comments. unless you are calling this as part of another class, do not use @member syntax. What you really want is a global. 

We should always be on the look out for general functions. These help us tremendously in refactoring the code. Here is one such function. 

Ignore every thing except the second line, the Unknown implict .. tells you that ghc expected any exprssion in place of ?check would be a string. Now try finding the type of our expression 

A side benefit is isConsecutive which is now applicable for any arrays that have Enum defined for their elements. 

Two ways of doing the doubleSecond, I prefer the second way, and I think that is a more ruby way. But as a beginner, you might understand the first better. Choose which ever you like. 

Smaller width lines if you can :). It helps, and it looks good. Also make use of case in these cases. 

I found isThree to be rather similar to isFour. So in the interests of consistency they are defined similarly 

Why do you use a separate match? Also name j some thing descriptive. And why \w ? Do you want to catch spellos in hint? 

The scaleDiffs can be written in two ways, one by recognizing that it is actually a and the other, using the functions in to manipulate the pair. The second gets you a pointfree form. Use which ever you feel comfortable with, but understand both. I have replaced genericLength with because it seems from your training set that the set is not very large. If that is not the case, change it back to 

Here, while it may look nice, the method clean_hash is not general enough to be valid across all Hashes. So adding a method such as clean_hash to all Hashes would only serve to increase the coupling which is bad. A second problem is that you are mutating your method argument which is almost never advisable. The solution is to define the method outside, perhaps as a part of your internal API object and call . I would also define the clean method this way 

Note that the way you declared your data structure for Classifier, you get the function 'training' defined. So there is no point in extracting it using @ as you did. 

A possible suggestions. By looking at your data, I see that the difference between the strings may be small. Since Levenshtein distance is a costly metric, it may be profitable to compute some other easy metric such that it is not too different from what may be obtained from Levenshtein metric, and use it to presort the arrays. Once you have presorted them, merge the arrays together, and find the neighbors with in a delta range. For these, you can compute the Levenshtein distance and verify. Possible metrics to use for pre-sorting include 

The training function is clean, but remove the extra $, and make use of your training accessing function from classify. 

First, it does not make sense to use a loop if the number of loops are just one. On the other hand, I also notice that you have 

I modified your implementation a bit to make it clear what is happening. We take letters while they are not numbers, and drop the suffix that start with '<' If your parsing goes beyond this, then go for parsec. 

Are the strings like pre-defined? If the number of such strings are limited, then you would also profit by making them into methods such as if not, you can go for where could be an attribute in the class. Consider memoizing the lookup. 

We are using the return value by returning the even though this information is no different from the parameter that was passed in. Secondly, if the buffer was small enough, the function is zeroing out the remainder of the memory. This seems to be a wasteful effort. Perhaps it is enough to just null terminate the string? 

If it were upto me, I would move the entire name processing and saving into a and do the entire processing there. It would also have the advantage of not having to change a relative to format, and then again extracting the . 

A few general remarks I find that stepped whiles are as evil as nested if statements for readability of the code. Here, you have three levels of nesting. Relying on the surrounding environment for variables can some times obscure possibility to generalize (You make use of x and m for inner definitions) So here is what I would do 

How can I improve this? This question is a rather interesting one. By upping the count of stacks to three, we can no longer be assured of an optimal utilization of the array (for two, each stack could start from one of the ends). So the problem here is that of optimal utilization of the array, Your solution divides the array equally into three, so that even if there is space left in one of the stacks, your other stacks are unable to use it. Perhaps it would be profitable to consider the more general case of storing stacks in the array. If you think about it, the problem is remarkably similar to memory allocation or file space allocation in a hard disk. This would be my approach. I assume that the array is an array of integers.