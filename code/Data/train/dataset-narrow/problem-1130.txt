I would prefer to use a whitelist when including stuff. This isn't an immediate thread anymore, as null byte injection was fixed a long time ago (although there might possibly be alternatives, depending on the system). Still, code like this gives up some control over the control flow of the website, as an attacker can include any PHP file on the system, even files you might not want to have included. An example: You store uploaded files outside the web root, as an additional defense against users uploading PHP shells. An attacker manages to upload a PHP shell, because your upload code is vulnerable. Now because of this include, the attacker can actually gain code execution, which would otherwise not have been possible. OOP and reusability 

I would also rather use a loop for the menu than using your recursive approach. Single Responsibility Functions as well as classes should only have one responsibility. You only have one class, so it obviously does everything. Your function for example handles the game loop, gets and checks user input, applies the input, updates the game, and prints. Don't Repeat yourself You have the functionality of counting how often a character appears in a string twice. Just extract it to a method. OOP Java is an object oriented language, so try to make use of this. Using is always a sign of bad design. There are situations where it does make sense, but every time you use it, you should think about it. Try to create more classes. It's better to create too many than too few. At least I would expect a board class, a class handling the word management (reading and writing to a file, etc), a class handling user input, a class handling output, a game class, and maybe even a word class. Type of You don't care how often the guessed character is in the word, only if it was in it at least once. So I would make this a boolean. Variable Names 

No, definitely not. XSS is a vulnerability that happens when printing something to the user, so that is when it should be defended against (in PHP eg by using ). Also, isn't really recommended for hashing anymore, you should use something like bcrypt. This also has the added advantage that you don't have to take care of salts, etc. The relevant function in PHP is . Structure globals are evil (not necessarily always, but definitely in this case). If you have to return more than one value return an array, do not set it as global. I personally would choose a more OOP oriented different approach of having a user object and setting the email there, and then returning true/false instead of an integer from (because either the login is successful or not, there are no other states). Misc 

That looks way less nice. There are definitely variables directly inside an SQL query. So is this secure? To know that, we have to dive deep into the code, as we have no idea what the variables actually stand for. If we do that, we can see that: 

For proper defenses, see below. Relative Path Overwrite You include your CSS file with a relative path, which leads to vulnerable code, as it makes CSS injection possible. If an attacker can inject CSS code - which they can via the username - this injected CSS code can be parsed as CSS code by appending slashes at the end of the path. This can lead to phishing, defacement, limited data leakage, and other problems. Filtering the username is not the correct solution for this, you need to include your CSS files via absolute path. You should also set a doctype as it mitigats this vulnerability in most browsers. CSRF Your code doesn't have CSRF protection. In case this isn't handled elsewere, you really need to include this, even for login pages. An attacker could force-login a user in the hopes that they reveal sensitive data while logged into an attacker-controlled account, or they could exploit XSS issues in the user area. Redirect Your redirect function is vulnerable to open redirect. Currently, no user input is passed to it, but each function which uses potentially vulnerable functions - a redirect in this example - should be secure, in case it is used differently in the future. Improper input sanitation @insertusernamehere already pointed that calling on a password is a bad idea. Their example is a bit contrived (a password of ), but it's a lot worse. becomes . Users may not use often, but password managers may. Apart from that, calling either or on input is not a good approach at all. XSS is an output vulnerability, and that is where it needs to be defended against. You should have input validation though! Ideally, via a generalized class that handles all input, and which provides methods such as , , , , , and so on. Then, always(!) access all input via these methods. Proper XSS protection XSS is an output vulnerability, so defend against it when printing. You also want to do this by default. Having to remember encoding each variable - or worse, thinking for each variable if encoding is necessary - will lead to mistakes sooner rather than later. XSS is also context sensitive, meaning a call to will not be enough in many situations. , would be two examples. Use a decent templaing engine which HTML encodes by default, and use JavaScript or URL encoding when necessary. SQL Credentials Store your database credentials in a special file outside the webroot. This makes it easier to exclude them from version control, and avoids accidentally exposing automatically created backup files. 

You can easily prevent this by passing to before echoing it. If also contains (HTML) content by non-root users, sanitizing this will be a lot more difficult, but I am assuming it's only ever created by you. Config Your file seems to be located inside the web directory, you should move it outside of the web root. Having a password in a PHP file inside the web root could leak your password in some instances. Handling Exceptions Right now, you are echoing the exception (not a good idea for production code as @ratchet freak mentioned), but are not handling it, you call anyways (and it will fail, uncontrolled). You should either try to recover, or redirect to a custom error page. General Code Comments Style 

Nested if Personally, I really don't like nested s. You could rewrite your JavaScript success function like this: 

But this isn't enough to make it run lag-free in Firefox for me. It works fine with max 3 fireworks and 300 particles (although a bit boring). Realism There are a lot of things that could be done to make it more realistic (with a lot of work, and probably heavy performance costs), but I think that your version is quite good. It doesn't actually look that much like real firework, but it's a great representation. It looks good and everybody knows that it's supposed to be fireworks. The main difference to real fireworks is that the particles of real fireworks don't look like dots most of the time, but like lines (or drops, especially when falling down). Also, real fireworks tend to come in groups of explosions, not in timed intervals (because it's more exciting to see one giant scene instead of a steady stream of small once). This is not something I would aim for in an animation though. Naming 

Security Validating data when inserting it in the database is always a good idea, but should not be the main defense against anything (SQL injection should be handled with prepared statements, as you are doing; XSS should be handled via HTML encoding, etc). You are probably open to persistent XSS via name, username and email. When echoing variable data, always HTML encode it. This is a self-XSS, but it still matters, especially if your login is not CSRF protected, in which case an attacker can perform CSRF to force-login a victim and then execute the injected JavaScript code. It also seems that you are open to CSRF attacks. Your forms should have an anti-CSRF token, which is at least not present in the code posted here, and which I could also not find in the rest of the code on github. When including things like this: , it would be ideal to check that no directory traversal takes place. Zero byte poisoning and path truncation are not possible in newer PHP versions, but it's still a good practice (an attacker could eg still include PHP files). Structure View Your view template does a lot more than present data. It also handles data. Ideally, a template only contains HTML and echoes variables it was given. It should not read out user input, and it should not perform changes. Router Your router also does more than simple routing. What I would expect from a router is that it reads out the given URL, and then calls the appropriate methods in the right classes. Ideally, you create a config file which contains allowed classes/methods and which maps those to a given URL structure (this is important as a whitelist for security reasons, and also gives you an easy way to reconfigure your URL structure later on). A router should not care about what those methods are, or in what classes they are. Right now, if you want to add new actions, you have to not only update the class containing those actions, but also the router class. After a while, your router will grow quite large and will be hard to handle. To give you an idea, here is some dummy code how it might look: 

Now you don't have to pass empty strings to the function (which is really confusing to use), and the functions have a proper name as well. 

Regarding your security code I'm glad to see that you have some defenses in place so that you are not completely vulnerable. That being said, having one (or more) input filter functions in place is not really a good approach to security. It will catch some attacks (maybe even most), but there are always cases where it will not work. It will also lead to usability problems and bugs, which isn't good, but not necessarily your main concern. Still, these bugs can have security implications. For example, my super secure password becomes the way less secure for your website (because of strip_tags). You are also still vulnerable to XSS. doesn't work when you are already in a tag, eg here: ( is user supplied, and an attacker can add additional attributes to get into a JavaScript context). Allowing your mods to post any tags is also not a good idea, as they can relatively easily escalate their privileges to admin. You don't need to write some kind of filter yourself (and you shouldn't, as it's quite difficult), just use an existing library, eg HTML Purifier. Regarding SQL injection, the code you posted is probably safe (although strongly discuraged; there is a reason that magic quotes isn't enabled by default anymore), but if you have queries where user input is not surrounded by quotes, it will not work (eg when passing ids, when using limit, etc). Also, don't store passwords in cookies, and make cookies httpOnly.