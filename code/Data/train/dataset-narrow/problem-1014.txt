Looking at the source code for your code more or less does what it does. Here is their code for reference: 

Your naming of variables is hard to reason about. When I think about what your program is doing you, I come up with the following sequence of steps: 

Are extremely similar and should be placed into a function. This is doable if you put stuff like into an approprate dictionary (maybe ?) - chains Instead of: 

Is prone to errors when you don't use braces. Python enforces indentation so it is hard(er?) to make a mistake with the lack of braces, but in Java the indentation doesn't influence anything here and some programs will silently "work" that shouldn't and no error message will be given. 

Too long is way to long. It is hard to read and interrupts the flow of statements that call that function. may be a better alternative. You probably wont get a name quite as descriptive as what you came up with but I would just write it in the docstring. XSS sounds like you're talking about an XSS exploit or something. Why do you use that as a variable name? Why not or ? (Same goes for etc.) Some hardcoded stuff. 

For O(1) performance you could precompute the factorials for values up to 12 (all factorials in int range). 

(I would initialize with a ternary operator instead.) Types As the values of , and are always in the range , you can use instead of for these variables, arithmetic is likely to be faster than arithmetic. Alternative implementation The remaining range is quite small -> you could cache the results for every number in the range to avoid calculating the sum on each invocation. 

Currently each future processes elements (increasing the increases the total workload ()). Instead you want to divide the workload between each of the futures: 

In my opinion returning an is the best option as the method requires ints, anything else would imply additional conversions. 

Alternative implementation Your current implementation supports arrays with a maximum length of 30, you could provide a method to support arrays with up to 64 elements (or a larger datatype than to support way larger input arrays). 

There may be some others. Please read the link so you can find the issues, or run pylint on your code to correct all of these issues. Structure You really should avoid using global variables unless you absolutely have to. In this case, you don't need them. Classes Given that you have some global state at the moment, it might be a good idea to write a class describing your game. 

divides so now assign to and update . Update by multiplying it by so and increment . divides so now assign to and update . Update by multiplying it by so and increment . so terminate the algorithm. Return which is the number of divisors for . 

PEP 8 Please follow PEP 8, you ca use tools like pylint to find PEP 8 issues immediately. But for instance: 

As you never use , by convention you would use instead. More importantly, I'm not exactly sure what you hope to get out of shuffling the deck three times. I think once is probably enough. Using is usually bad practice. You can use the return value of to get around this. (I'll leave that as an exercise.) I would change to . Although they do the same thing is considered better style in at least Python. 

The array can be an int array instead of a long array. You can replace the modulo operation with a multiplication and a subtraction (which could/should be faster). 

As sorting by frequency works for every input type and not only strings, I would use a parameterized class instead of to support all types. Possible implementation: 

Stream vs Loop The main problem I see with a stream based approach is (besides the overhead of the streams), that it is more difficult to optimize compared to a loop approach as the abstraction level is higher. For example converting the implementation to a parallel approach is in my opinion way more complicated with a stream approach. Algorithm improvements (not directly related to the question) You can use a (or directly a // array) to ensure that each entry in the sieve consumes only one bit (instead of currently (likely) 8). You are storing all values from to in the sieve, you can save memory by skipping multiples of (and , , ...) at the cost of some additional calculations to convert between sieve position and value. For larger values of it might be advantageous to divide the sieving process in smaller steps and use a small array instead of a large array for all values and sieving the complete range at once. The sieving process can be converted to a parallel implementation with nearly linear speedup as two or more values can be sieved simultaneously (sieving process of each value is independent from other values). Approx. performance for , included my implementation (which utilizes most of the improvements mentioned above) as reference value: 

Do you really need this? You don't save any characters (not that it is always about saving characters) and you use once. I would just get rid of the line. I would also say the same about: 

This could be vastly simplified using JSON and the Python library. tl;dr JSON is a convenient way of storing data (in file) that roughly resembles a Python dictionary. (There are also alternatives to JSON like XML, but I prefer JSON). You can also refactor using JSON. Place stats into a dictionary. I would put the player stats into a dictionary so you can make access stats like: 

Just get rid of it. Also, in this instance in particular I would get rid of it, because when I read it, I believe there might be a way to abstract it. "Maybe let the user change the , somehow?") There isn't a particularly good way to "abstract" this out in particular. Furthermore, it is considered good practice to use format instead of the addition of strings so: 

Besides that could (and should) be a local variable. The spacing between operators is inconsistent, you should add whitespace around the operators (except for unary operators) to improve readability. 

In the array version you can use post/pre increment and pre decrement (most likely no difference in terms of performance but shorter and in my opinion better readable). 

Space efficiency: Currently you are storing 50% of all values, this can be reduced to 33% quite easily by not storing any multiples of . (Excluding additional values is possible but complicates the calculation between value and index, you might have to check until which point excluding values is advantaguous.) Sidenote: You reduced the space consumption by the factor 2*8=16, not 64, compared to an implementation that uses a (at least for the OracleJVM). Performance: You are iterating over each bit, I would use to process the bits in blocks of 32 bits. You might want to use multiple threads to sieve, a simple implementation could use multiple threads to strike of multiples of different starting values. (For comparison: my quite similar implementation that skips multiples of (and uses instead of ) is around 25% (singlethreaded)/60% (multithreaded) faster than your current implementation.) Implementation: You don't need the variable as it is equivalent to . Your current implementation may overflow for larger sieve sizes. I would iterate over the indices rather than over the values to avoid converting while striking values off. Possible implementation (the resulting array should be encapsulated in a class that provides methods to operate on the sieved values): 

is the name of the Garbage Collection interface module. It shouldn't matter too much, but, when reading your code, it feels like that you are asking the garbage collector to find books and then I remind myself that it isn't actually the garbage collector. 

Organization As Simon points out, you shouldn't put the list of functions inside of . It doesn't make much sense. Move them out into the class. Use in python is equivalent to in C# and many other languages. This: 

But you can abstract this further! Create a higher order function, that depends on a string parameter and pass in either or . 

(or better yet ) Instead of doing . You could just use and get rid of altogether. But even better than that, just . This: 

The biggest issue I see with your code is your ability to extend it effectively. I would recomend you store a lot of you data in a format like JSON. So you could create for a something like: 

In the context of the quoted task I would stick with , documenting the possible return values should be sufficient (besides maybe renaming the method to something more meaningful like ). getCoinToss Using or would avoid quite a few calculations and thus would be significantly faster. Additionally the current approach will perform poorly if the method is accessed by many threads. 

Current implementation You can reduce the variable scope of your static variables by accepting the array input as parameter and returning the queue. You are currently iterating the queue three times if the queue contains the word (, iterator loop, ), this can be reduced to one iteration by only using the iterator. 

generateValue The conversion to and from strings slows your method down, bitshifts are more appropiate ( returns the same result). As @Piers Williams already stated, an iterative approach is preferable. A possible implementation: 

This assignment is not terribly necessary. Your algorithm can be simplified considerably. I think this should be left as an exercise, but here are some things you shouldn't have to do in the new algorithm: 

Based of the statement I would know that this the purpose of . I would omit it, but it does explain why you increment , so there is some grey zone here. You write some good comments toward the end, let's analyze why they are good: 

About () I guess if you really want to "encode" it fine. I wouldn't really bother, but ok. But along with don't appear to mutate so I would use a tuple (change the and ) to ensure that they don't mutate. 

My main concerns is that I have an "inefficient" (possibly incorrect?) formulation of the axioms. The code runs and compiles, but it feels like for instance, somehow, and could be somehow made into one axiom. Nevertheless, any advice is appreciated. (This is also on Github here in the file ) 

Implementation You can invert the values for and to avoid the initial . The innermost loop can start at instead of : 

Runtime improvement If you take a look at the last digit of the first few fibonacci numbers you will see that the digits are repeated after 60 numbers. As the digits in this range have a sum of you can calculate the sum for instead. Bug The task states that the given integer are non-negative, is a valid value. Currently you are returning i.e. for the range as is treated as , the initialization of sum has to be changed to: 

You can use the method to require only one lookup for most map implementations (esp. important for concurrent maps that may contain values to ensure reliable results). 

Minor changes As @coderodde already stated, there is not much to improve, nonetheless a few minor things: You can reduce the scope of the variables (which has always the same value as k prior entering the inner loop) and to the inner/outer loop. can be written as . Your inner loop starts at but only uses , you can start the loop at to avoid the subtraction. Depending on how s should be handled, you could use to throw a NPE if elements are present. If s are permitted, I would prefer that the string is added to the resulting array rather than a reference. You could start and at and use the (in theory) more efficient preincrement operator instead of the postincrement operator. Possible implementation (not using preincrement for and as I think it makes the code more difficult to read): 

I wouldn't call it result. I'm not that familiar with Kotlin, but sometimes APIs will write to the value you pass in and so the function doesn't return anything but it modifies the variable. Maybe is a better choice? datatype I would change your datatype from to . You are returning a pair of integers satisfying the equation so why choose an array when there is a data type object? I also suggest that if no solution is found that you, yes, return . is often a bad design choice, but I strongly believe this is the exception. If there are no solutions we say that the solution set is null (or the empty set). So if there are no pairs the solution set is null. Reads just like math. Generalizing to You could just iterate over an array of values, but more generally you probably want to iterate over an collection of integers. The one cost of this is you have to say . The code