I am attempting to write a RNG which returns a normal-like curve. For example, say I define X to be 4, I would like to generate a range of numbers from 1 to 8, but with 4 being returned most of the time (say 60%). How can I accomplish this in a way I can easily define X, and the range of the numbers? 

I guess this question pertains more to games like MMO and Diablo-like games. What are the usual designs for implementing a drop table, where a monster could drop different type of items depending on a percentage? I guess the simplest way there is to have a dictionary of 'percentage weightage' to item types, but this is hard to extend if we wish to introduce new item types (for example, when D2 expansion includes runes and new class items) 

I am coding a rather "simple" 4X game (if a 4X game can be simple). It's indie in scope, and I am wondering if there's anyway to come up with a passable AI without having me spending months coding on it. The game has three major decision making portions; spending of production points, spending of movement points and spending of tech points (basically there are 3 different 'currency', currency unspent at end of turn is not saved) 

Suppose I am doing a JavaScript game, and I wish the game to update the server if the user has successfully completes the game and his outcome. How should I ensure that the request came from the JavaScript game, and that the data sent has not been tampered with. I am using PHP as the server-side language. I do understand that no strategies are going to be 100% fool-proof, and any measures taken is more of a deterrence than absolute protection. On Edit: Let's supposed we're not using server verification of each user's step (as in a traditional MMO). The game could be a mini-game as part of a web game or educational game (space invaders or a real-time game, for example) and requiring a server-side component for each of those games could be tedious. Example: Supposed, when the game is completed, a request is sent to the server via. AJAX 

I would play some of those games, and try to get addicted to them. I guess there's no shame to be addicted to Mafia War, Ravenwood Fair, Plants vs. Zombies and some of those Flash games for a while :P (even though I am too a hardcore gamer). Like designing hardcore games, I believe that casual/'non-gamer' games revolve around presenting challenges. However, those games usually focus on one challenge and slowly scale it up, instead of pushing all of it to the gamer. Then you ask "What is the simplest form of this challenge?" and set it as the first level. After that, you think, "How complex can this challenge be?" and do additional levels. Second, it is the theme. Most of the time hardcore games deal with themes not accessible by non-gamers, such as fantasy, science-fic, military (which is, however, very accessible to male) and etc. It is possible to take a game, give it another theme, and it appeals to the casual market. There's a game on the iPhone now where you collect candies (or something) and it looks a lot like Sonic. Just a change of theme, and it could be a casual game. 

The plan for me right now is a brute force approach. There are basically 4 broad options for the player - 

I am doing a simple 4X strategy game in space where each node is a point-of-interest (a planet, an asteroid and etc.). To randomly generate a map, I would follow the steps below 

The core issue, from what I can see, is not C++ or Unity3D, but rather do you need a high-level solution or a low-level solution. A low-level solution is one which you get dirty with the processes of handing input, managing memory or loading the models. A high-level solution is which you get one neat package, like Unity3D. To me, whether to use Unity3D (or any other game engine) or C++ depends on the goals of your game and project. 

There are more tutorials online for OpenGL than Direct3D, last I check. Beginning OpenGL Games Programming has a second edition, so it may be more recent. If you are looking to do an engine, I have read C++ Games Programming from Start to Finish and found it helpful. 

Do I need the cutting edge MacBook Pro or iMac for 2D games development? Would a iPod touch (with Wi-Fi support) do instead of a full-fledge iPhone? 

There are formulas out there for a diminishing return equation; however, those usually involve exponential. What other ways are there for coming up with such an equation? Take, for example, the following test case -- One farm produces 10 food, for every 10 farms produced, the production rate drops by 5%. 

Unity3D is more of a wrapper/library than a 'drag and drop' game engine. It doesn't generate code nor does it come with 'off-the-shelf' scripts. For example, Unreal has a default first person camera, character controller, collision detection and AI. You have none of that in Unity3D. What you get from Unity3D is a game loop, component-based entity system, a comprehensive math library, means to load media, handling of meshes, camera, immediate mode GUI, shaders, rendering pipeline and other low level functionality. Plus a nice editor. You just have to worry about high level functionality. For example, you still have to code your own first person camera (if you are not using the default one). However, you do not need to deal with calculating the look-at vectors and such. Unity3D doesn't generate any code for your game, strictly (It does generate code for running your game, to be more accurate, but none for your gameplay) You will have to use the API to define your game. You can look at the examples that come with Unity3D and re-uses those code; there are a couple of pre-defined scripts, but usually you have to customize those to meet your needs. You create the game through scripting; you write scripts for behaviours, design the level in Unity3D, and assign those behaviours to entities (or game-objects). It's very flexible, but it still requires effort to write a game. I would compare it to Flash for 3D. 

I'm not sure about the architecture of your game, so what's follow is a rather generic answer. Usually there are two different 'rates' in the game - the screen refresh or draw rate, and the logic update rate. The draw rate is the FPS - some game engines will try to draw as often as possible, while others will try to draw at a fixed rate. Regardless, it is not a good idea to tie logic updating to the draw rate of your game. Most game engines instead will have a update loop, which is governed by the logic update rate. This is the rate you you to speed up, slow down, or pause the game. To pause, you simple stop updating. To slow down, you increase the time between each update, and so on. As an example, Unity3D has a variable called , which affects the variable used by all most logic functions to determine the elapsed time each frame. By setting the time scale to 1.0f, the game runs at normal speed. Setting it at 0.5f will run it half the speed. 

You have to identify the problem before you can solve it. Why do you lose interest? For me, it usually happens because I am spending so much time on the framework, and after weeks, I couldn't even get a single gameplay element up. One way I find to improve my motivation is to do iterative prototyping, or some form of Test Driven Development. Usually that involves automating test cases, but as games are graphics intensive, you can't automate screens and animations as tests, but your game logic could be automated. For the parts which can't be automated, basically I'll plan a couple of milestones for the game. Milestone 1 probably would be render a sprite on the screen and get WASD to work, for example. Gradually, I will add more features, and refactor. It's a form of divide and conquer. Break into small chuncks, work on the one you are comfortable with, then integrate. Rinse and repeat. Eventually you may see a better way of re-arranging stuff, and you can refactor your code. It's messy not to have an architecture up front, but usually when getting started in programming it's hard to visualize the architecture till you have some years of experience. 

A user could 'fake' the server in believing that the game has been completed correctly by sending that request to game_finished.php. How could this be made more difficult? 

I am aware that there are opensource drivers for interfacing Kinect with the PC. My question is - the drivers at OpenKinect seems to provide only the images and depth data (from the reading of their wiki and API). It seems that you need to provide your own imaging solution. My question is - is there any all-in-one package, with samples/sources that not only grab images from Kinect, but also do the imaging/motion detection for you? 

I am currently working on a text based game, where the outcome of a combat round goes something like this 

Suppose I have a game where there are several predefined constants and charts (a XP chart, cost of goods and so on). Those could be defined at runtime, or load from files at start-up. The question is how should those logic routines access the constants and charts? For example, I could try using global variables, but that cause all classes relying on the variables to be tightly coupled with them. 

If you have knowledge with C#, and wish to work with a strongly typed library that supports C# and .NET, try Unity3D Pros: 

Upgrade planet(s) to its his production and tech output Conquer as many planets as possible Secure as many planets as possible Get to a certain tech as soon as possible