The first thing that comes to my mind would be to render your 3d graphics with a cel shader. I'm not too familiar with the technique, but basically, it makes your 3d models look cartoonish. I think some game companies put a lot of effort in this kind of technique to really give a nice look to their game and they really make it part of the artistic process. In any case, if you decide to go with that kind of technique, you'll have to work with your artists and give them tools to rapidly view the result of their work. You could do that with you writing the exporter/converter and giving it to them. Another way you could get some results would be to render your models to images, then edit them manually in photoshop by applying filters. I know photoshop can be scripted so you could automate the process there. 

Draw a point like you do but change the size as you zoom in and out (more complex because it's harder to determine the size you should have your point). Draw a sphere or a cube, this will have a volume and will change size correctly as you zoom in and zoom out. 

Please note that I don't have unity, but my example is in c# so you'll be able to follow along. First, since your question concerns a bike (assuming it'll always be on the ground), I've taken the liberty to 'flatten' the question and use only the x and y attributes of the used directions as in this context the z is irrelevant. The way I'd do it: 

How to get X and Y coordinates in a 2d array from a single index? You use the modulo () for the coordinate and you use the integer division () for the coordinate: 

A level designer imports the model into a home made level editor that can edit the 3dsmax model, and adds paths for AI in a separate file based on that model Another converter loads the AI file and outputs it in binary format A script places the binary file in the correct folder for the game to load it based on information in it 

I would suggest you start by building a node graph (a bunch of nodes and arcs (sometimes called edges)). 

The collision detection is based on geometry (primitives like line, planes, spheres, boxes, capsules, cylinders). If you need to perform collision detection on shapes made out of triangle, for instance a terrain that is not flat, you have to test against all the triangles that form the mesh. If you get to that point, I would strongly advise to use a pre-made collision detection engine, as this kind of stuff get pretty complex, pretty fast. 

Now you have to ask "Who's responsible for calculating the damage of the fireball on the enemies?", if you answer "The fireball", then the approach you suggested, 2., is the way to go: unless the enemy knows anything about a fireball, there is no need for it to keep track of those; the fireball however should probably know about the enemies. Another option is that if your fireball and your enemies are completely decoupled and the damage is managed by a 3rd party (e.g. 'DamageManager'), well in this case, the DamageManager will have to keep track of the enemies and fireballs combinations that have occurred and not re-apply the damage. To be honest, however, ultimately, as long as it fits your game architecture, and it's efficient enough (you check that by using a profiler), any method to make it work is ok :) 

Your input class should tell your weapon to cast a bullet. You'll be able to use the same functions when the bullet will need to be fired from an AI entity. This will help separate concepts: your input class knows that the weapon can fire a bullet, but does not have to know how it's being done. 

From what I understand from marmalade, a call to Iw2DSetTransformMatrix(Transform) sets the transformation for all your subsequent calls. Then you have to use the same data if you want to have both your objects at the same location. Edit: See my comments in the code, and more explanation: You could have used the x/y of the Position and of the BoundingBox if you did not use the position in the calculation of the Transform (and the subsequent call to Iw2DSetTransformMatrix). By using the x/y of the bounding box, you were actually moving your bounding box twice: one because of the position/call-to-Iw2DSetTransformMatrix, and once because you were offsetting it by it's position again. 

As you see, there seems to be more cons than pros, but the first pro is a real one, IMHO, so it's worth considering :) 

The odd calculation in 3 is to determine the ratio the player has to complete in the current gate span, and takes into consideration that the player could be off-track. 

I am not a lawyer, and this is not a legal advice site. To get a final opinion, hire a lawyer. There are 2 aspects in your question: 

From experience, if the publisher of an API or library stops supporting that said API/library, you'll be fine for some time, then it's going to start to be harder to work with the API as new OS will require new API binaries, access to core OS functions will change, and such. That is, if the source is not released. If the source is released, yes, a community can emerge and keep the support for the API, but development will most likely be halted or very slow, just like the bug fixes. IMHO, if a technology has reached it's end of life, there is no point in putting time in it, and you'll have a better future to chose the technology that replaced it. 

You have your answer: don't do it. To build a game engine, you have to know how to create games. And you'll have to create games with your engine to prove that it can work well (in a single genre or in many genres, as @Philipp mentions in his answer) and display what cool stuff you can achieve with it. You'll not only have to be interested in it, you'll have to be passionate about it. Thus the logical conclusion is: chose another type of project. 

You'll achieve the same effect, so effect-wise, yes, they are equivalent. However, if this situation will occur often during the run-time, it would be wise to reduce the number of unnecessary calls to OpenGL to increase performance. Thus they're not equivalent efficiency-wise; you should use Option 1 as much as possible. 

However I don't think there is a common way to name them across all game companies. You should use common sense and what works best for you and your team internally. What's important though is that what the player sees is consistent across the board: don't use 'collectible' on a specific pane, and 'currency' on another, this would create confusion (you'll probably even end up giving it a specific name like 'Coin' and use only that term everywhere). 

The fastest code to compile is the code that has not been written. If you don't intend to modify the libraries (which is the typical way to use 3rd party open source libraries), you should not include them in your solution. You should compile them in a separate solution and make them available for your main project, whether they'll be statically linked or dynamically linked. Another thing you could check, even if it's stating the obvious: when compiling, don't use "Rebuild Solution"; use "Build project". 

The genre is a infinite runner. Or an endless side scrolling runner. The goal of the game is to get as far as possible. Generally, this kind of game has it's content randomly generated as the player advances. The player advances automatically, while s/he has to perform some other actions to 'survive' as long as possible. One of the most popular early games of this genre was Canabalt, where the player only had the option to jump at the most appropriate time. The genre has evolved since then. 

Find the centre of mass of your object. Compute the vector between your centre of mass and the pivot point of your object. Use that vector to move your cubes so that the centre of mass of your object is at the same place of the pivot point of your object. Perform your rotation. (Also rotate your computed delta vector.) Replace the cubes with the negative delta vector you computed earlier. 

You seem to have taken the image on Wikipedia, on the bilinear interpolation page. The legend of that image says 

While the answer posted @dnk drone.vs.drones is technically exactly about what you asked for and a viable solution, here is another suggestion that goes a bit further, and is based on my comment on your question. I'm assuming: 

You had two issues with your use of atan2: first, as pointed in the question's comment, why did you multiply your calculation by , and second, the parameters for atan2 are , not . And as I pointed early, your use of was not appropriate. Spamming stuff to the console helps see what values that should be constant vary and helps track where the problem is coming from. When I say variables I suggest to also include in there calculations results. 

Here is a way to view this: Generally, games are sold with a "minimum requirements" and a "recommended requirement". This is decided by you, the developer. This means you should try your game on both of these systems, and the game should run without lagging or bugging or glitching on these setups (with the appropriate settings). What if you found set of machine specs that would fit in between these 2, which could be what the average joe would have? You could define this machine as your default machine, on which the default settings would make the game run ok. Now, if you have a lot of money and time, you could try and implement a way to gather the capabilities of the client machine, and match the default settings with that; or interface with the NVidia and ATI APIs to ask them to configure your game the proper way. 

Optionally, you could try and 'merge' the arcs going from the start of a current to it's end, removing the nodes along the way. This will leave you the optimal path for this spot. 

This said, with OOP, I would suggest you have your player use a sprite, and not be a sprite. A player is not a sprite, a player has a sprite. Making this kind of architectural choice early in the development can get you in a big mess. 

Adding to ZEKE answer. There are situations where changing a setting gives a temporary weird behaviour, and that is acceptable. In this case, really, it depends. Is your game based on the sound? Do you expect the player to use the mute/un-mute feature often? If the answer is yes to any of these, you'd probably want to play the sound, but set the volume to 0 when it is muted in any case. In this case, the "weird behaviour" could be an issue. If the answer to both of these question is no, I would suggest you wrap the into one of your classes (for instance ) that will relay calls to it. In this case, the "weird behaviour" is probably not an issue. This class will offer the same services, but the "play" will be different, the "play" will check if the sound is muted by the user, and will not play it if the user has muted the game; the you wrote in the OP will be encapsulated in the function. This will allow the end user classes to just don't care about the mute state, (because, in fact, they don't care) and the code that calls the play sound methods will be cleaner. With this you'll still have to set the volume to 0 for sounds that are already playing when the user wants to mute. This said, since the library you're using seems to be open-source, you could go in there and add the feature directly to . The advantage would be that you'd have one less class to build and carry around, and all your code base would work right away. The downsides to it would be that if you update the 3rd party library, you face chances of changes in the original code base and you'd have to re-implement the feature in the new version.