Furthermore do not check things that other code will check anyway (DriverManager.getConnection). So omit 

First some general information. Your code currently solves a specific problem of the "object relational impedance mismatch" in a specific way. Consider to minimize the effort and complexity to handle this mismatch by using an object-relational mapping framework. Here is the thing: Every single step of code improvement code will lead towards an implementation of an more generalized object-relational mapper anyway. But that will be a hard way to go. Every answer given will be one of those: 

The parameter is not technically connected to the return value but semantically. You can see the strong relationship between those return values. They were built to present text. 

The provided answers mostly deal with the current state of your code and will improve it of course. And as this solution will work so or so I will not say anything about that. I want you to focus on another subject that wasn't adressed specificly: You did not identify the possible movable parts. Will the number of operations increase? Will the number of operands differ from 2 in the future? Why is this important at all? If you do not support the movable parts then often you will have to implement your algorithms nearly from scratch again and again as it is based on assumptions that are cutoffs to only address the "next" requirement. The principle that is violated by restructuring your code everytime a new requirement occurs: Open-Closed-Principle. You know that you have currently four operators. The movable parts begin with 2 elements. So you had 3 times to identify that the if-statement was an inappropriate structure as it will have to be extended everytime a new operator occurrs. You do not need to implement all operators known to you but you should implement a structure that represents the nature of an operator: It is independent from other operators. So every operator should get its own class. You know that some operators need only one (faculty), some more than two operands (complex functions). It is easy to reflect this if you separate the operators into classes. You only need to specify how many elements does the operator need. 

1 and 2 are not that interesting as they may differ slightly from implementation to implementation. And in general you did not reach a code mass to address any modularization issues. Number 3 is the part I want to address. You chose the egoistic variant of the dining philosophers. A philosopher may face starvation if other philosophers keep taking the forks in unfavorable point of times. Another variant is cooperative. You have to introduce one more artefact to do so. Philosophers may give aquired forks directly to their neighbors if they registered for usage of a fork while the fork itself is currently unavailabe. This prevents a philosopher from releasing the fork and aquiring it again immediately so other philosophers have no chance to introduce themselves in the process. 

Currently I cannot provide any specific suggestions on the existing code in good conscience. This is because it would be symptom fighting if I suggest something like this: 

Then you can wrapp this JSONObject into your own object and have the getters returning their values directly from the JSONObject: 

Maybe you find a better name for such generics like "line" or "lines" The categories "client", "process" and "device" could also be held in an enum. That would express those categories as central elements of your current algorithm and maybe future algorithms. 

The most interesting part is you can clearly see, where the responsibilities are located. Using the iterator pattern identifies the fragment -1 as the EOF for the iterator. The user of the iterator via contract has to ask for if another element is available, so the "Solution 2". But there -1 is not translated into false so the the caller has to interpret it by himself. 

The Calculator will not return a list anymore (this would be my design decision, but it is only an option) but notify the registered listeners after finishing its calculation: 

You said you have a business layer but the separation isn't proper. And here is why: Your "business layer" is responsible to serve a web service by throwing a BadRequestException. You are mixing in technologies that belong to other layers. You do not distinguish between proposal objects, consistent business objects and communication objects. They are all same (StudentDTO in, StudentDTO out). The null checks are not business relevant. They are a result of mapping from one representation (String) to another representation (Std, Division) while you do not know if the source made proper assumptions of the presents of the requested business objects. This is related to the web service layer that has to ensure to pass correct non-null values to the business layer. On the other side you have code that composes an entity in the same method. That should be separated at least into another class but after all it is a different layer, maybe the business layer, in my opionion the dao layer. 

If you are missing to represent semantics as structure you will have to deal with it with algorithmic as you did. Refactorings I omit the "continue" and reformulate (negate) the if-statement as it hindered me to apply the refactorings. I introduced the "guard"-variable "potentialMessagesToSend" and initialized it to true. I abstracted from which path a Message was created. If a Message is created it will be sent no matter from where it came. Code I do not know if I got it totally right, but you can get the idea: 

So the method "KeyGenerator.next" has to return null if no more key is available. And instantiating the keyStream will be a little different: 

Injecting Repositories or anything else into the business layer is an overall bad idea. You business layer should be free from framework mechanisms. You will pollute your most important parts with unneccessary complexity. What you can do is to place DI in certain objects that will initialize the dependencies around your business layer. So you may use a "RepositoryProvider" as an DI dependent artefact that will initialize a "RepositoryRegistry" which is DI independent and is used by the business layer. Keep your your business layer clean. 

Even if FXMLDocumentController is called a controller it is part of the UI. You can easily argue that: It is bound to the JAVA FX technology as it uses @FXML Annotations. Knowing this: any UI independent logic that may be lost if you change the UI technology is subject to be extracted into separate compile units (Seperation of concerns). Like Swing, JavaFX as well is not thread safe so you have to handle multithreaded access to your UI elements on your own. The Proper way to do this is to put the UI Update into a Runnable or a Task and use JavaFX concurrency mechanisms like you did at one place: Platform.runLater(...). But you should do this ALWAYS to avoid inconsistent states in your UI. As JavaFX is not thread safe and you are using lambda method references as asynchronous tasks you should always pass immutable values. You do not knoww WHEN the Task is executed. The values of your UI component may have changed in between. So do following change: final String text = binaryTextArea.getText(); Callable task = () -> binaryToAscii(text); Your runTask-Method is not beneficial. Your task is certainly pooled and maybe executed on another CPU. But as you are waiting for the Future to reveive the value the current thread is blocked. Furthermore to instantiate a Threadpool with only one thread for only one Task is a little too much. My suggestion is to put "Platform.runLater(...)" on the end of your long running Task. As you would mix up concerns (UI logic in Business logic) I would implement a Callback-Mechanism to inform the UI. 

... to have a technology free core. Finally I only see the method "getNewsMessagesFromUrl(..)" to have potential to be taken apart. Everything else seems to me pretty straight forward. 

Some annotations: In the model there is now a little business logic to illustrate that you may get an adapted result to present to the ui. ("Bill" will be converted to "Billy") All former public or package scope variables are private now so you can ensure they will not be manipulated accidentially. Lazy initialization is introduced for all ui components. The single responsibility principle was applied here. Furthermore, lazy initialization makes the code more flexible as you remove the neccessity to care about the instantiation order/timepoint. The creation of the ActionListener is now part of the button creation. It was removed from the controller. Previously it was neccessary to have the Button public to access the "addActionListener"-method. The Button is private now. Furthermore you established a "long" dependency to the method "addActionListener". The "law of demeter" was applied, I shortend the dependency. This was the first step to make the controller independent from Swing. The introduction of the listener pattern is the second step to make the controller independent from Swing. (dependency inversion) The model informs the listener once when the listener is registered. So the listener can initialize itself. The model notifies all listeners if the first name changes. The model is created within the UI class. Now you have some less classes knowing the model. (less dependencies) 

So you have some issues in encapsulation, locality and dependency. I provide you an advanced version that meets these requirements. 

General This is a perfect example as multiple implementations of an interface make it very robust. So I only have only little to address. Normalization Break your implementations of the search(.., ..)-methods into smaller pieces By doing so try to preserve/improve locality, avoid rampantly parameter declaration and avoid passing working references. Especially your search()-method of the BidirectionalBFSPathFinder is very long. Extracting methods and introducing inner working classes should help. Multiple return statements, break, continue If you experience difficulties by extracting methods or other classes then maybe multiple return statements within a method are the problem. Try to have only one return statement per method at the end. This will make sure that your code can be refactored and extended easily. "break" and "continue" cause the same problems. Avoid them in general and search other structures that preserve a well-defined control flow. Often "break" is used after checking a condition. This condition should be where it supposed to be: The loop header/footer. If you have multiple break statements the breaking conditions are spread all over the place. But they should all be at ONE place. default methods in interfaces Do not use default methods in interfaces to substitute the introduction of an abstract class. As they are public scope these methods are accessable to any client and confuses him/her about the usage. Introduce an abstract class where you provide general functionality for every concrete implementation of PathFinder and extend it (AbstractPathFinder). Then you get rid of the public scope and make it protected so subclass cann access these utility methods. Your interface will then look as clean as heaven: 

As I do not know the other entities beside "Student" it becomes very hard to evaluate it. One general thing: having duplicate code does not mean you have a problem. The problem comes if the duplicate code comes with real duplicate semantic for your business domain. It may be that you are missing an business relevant abstraction of "Student" and the other entities that have std or division in common. But you should think about that if there is really a proper abstraction. You can test it by making up an artificial requirement that affects the Student and the std or division. If the other entities must change as well to have a consistent model then there is semantic duplication and you should consider an abstraction or composition. If you have identified an abstraction to be proper then you can abstract the null checks as well. Another way is to encapsulate std and division in one object and provide a validate-method that does the check. Furthermore search the internet for refactoring methods like "introduce parameter object". If you haven't identified an abstract responsibility then leave your code as it is. Otherwise you may fall into a type II error. (Acting if there is a problem, but there isn't). This is related to the SRP. Robert C. Martin shows this in one of his talks: $URL$ As well as you should remove duplicate responsibilities you also should separate different responsibilities. Some other things: 

I could tell something about conventions e.g. you should name "DOMAIN" and "URL" to lowercase. I could tell you about creating a real class out of AbstractAuthenticationToken. I could tell you to extract some magic values to meaningful constants ( ... , true, true, true, ...) 

An exception should be handled at a point it can be handled. And this is not neccessarily the method it occurs. Logging an exception is the last option for exceptional cases that have no previous mentioned handle. And this is also not neccessarily the method it occurs. Remove Optional-construct To exit the loop you determine the existance of a next "url". That should be your single point of truth. "getResponse" is called if "hasMore" is true. But If "getResponse" gets called then it is called under the assumption that there "is" more. If the getResponse-method cannot fulfill the work it is an exception. My view is that getting an "Optional" when "hasMore" has determined before is contradictory. Throw an exception and the same mechanism as described in "Exception handling" is used. It is transparent to the caller. The caller always will get all necessary information and can decide on its own what to do. Either the getIds()-method returns normal or an exception is thrown that contains the Ids received so far. Ambigious next-key and semantic redundancy Currently you have two next-keys holding different values: boolean and String. Theoretically a JsonObject should have unique keys. But any behaviour you rely on to retreive values from this key is specific to the JSON library you use. Maybe GSON does it right somehow. Furthermore you have semantical redundancy. The existance of the next URL is sufficient information to determine if there is a next URL. My suggestion is to get rid of the semantic redundancy as early as possible so that further algorithms work with a single source of truth. Maybe you have a preprocession of the Json String and return the JsonObject as the return value of your execute-method(). Reuse JsonParser I think that is a little issue. But I would reuse the JsonParser-instance as I do not know if this is an expensive operation to instantiate this kind of object. Extracting constants There are code fragments that should be extracted to constants. the "key" String is repeated but adresses the same semantic. But also the other keys to access the json object. Variable scope The subjects become pedantic... You may reduce the scope of the "hasMore" variable by using a for loop rather than a while loop. Types You should also have a look at your GSON-Types. To determine the id you ask an JsonElement. A JsonElement may also be a JsonNull-Object (see here). Maybe you have to introduce some type-check. Code