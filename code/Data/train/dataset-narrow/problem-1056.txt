But if, heaven forbid, you're doing some assignment that explicitly states that you must use malloc on pain of death that you ever use any of the multiple better alternatives that have so kindly been made available to you, this is how you do it: 

Finally, if you're absolutely positively 100% sure you can't use std::vector or new[], ask yourself if you can do it via calloc: 

Several people on this thread have talked about how a for loop works, but few have mentioned the semantic difference between a for loop and a while loop. When a programmer encounters a for loop when reading code, the semantic is that the loop definitely terminates and iterates over some range of numbers or some list of elements. That's why all programmers immediately know what the following loops do, and they are very easy to mentally understand and parse. 

I'm unhappy with the one jQuery call with $.extend() but this proved the easiest way to accomplish an object merge and I use jQuery quite predominantly in the majority of my projects. Despite that can anyone suggest a different way to do this? While this works fine I know it's far from perfect as it's limited to one search term. My thought was to add in another loop within but I'd prefer to avoid doing that, my second thought was to map the object and perform the lookup once I'd found an object with the first property match. Again any suggestions on how I might accomplish this whilst keeping the script clean and fast I'd really appreciate it. Any other suggestions welcome, thank you for taking a look. :) 

within a class scope, the Extension object seems to extend the calling objects prototypes allowing me to bind a callback within the class scope. And then attach a handler after I have instantiated the class. 

These requests will quickly dominate the performance of your code. You should go through your code carefully to see where it's making requests, and see if you can eliminate some of them, say, by caching results or batching requests. Currently you have (at least) 1 + n requests made by the loop, where n is the number of iterations. No wonder it is slow! 

For this reason, both of your first two arrays are well designed, and are quick and easy to understand during a code-review. The two lists are iterating x and y over all of the items [0,0] to [max_x_index, max_y_index]. But if you poison one of the two for loops so that they no longer look normal by adding some semantically unrelated variable (count) to one of the loops, suddenly the entire loop becomes harder to mentally understand. count is not related to [x,y] iterating over the loop. It's semantically related to how many elements are in some2DArray, and moving them far from each other makes the code as a whole harder to read, and inevitably, harder to maintain and debug as well. Instead, good practice is to modify variables close to their semantic meaning, which aids comprehension of the code. To do this, you should modify count at the point where count ought to change - not when the loop iterates, but when you modify some2DArray either via inline increment: 

Only functions parenthesis start on the same vertical. Objects and arrays are always indented 4 spaces beyond the function. 

I would say that there isn't a correct or incorrect way of achieving this. Everyones requirements differ. You probably want to expand this out, there's a lot going on in the one static method you have in that class. Whilst I don't have anything against mediator patterns, I would probably combine a number of patterns to build a powerful caching class, as well as utilising magic methods (I know some people are averse to this). I need to note the below is a lot more complicated and would benefit from some refactoring to be stored against the actual method rather than a key. 

Make your code scalable By this I mean using techniques that allow you to do some relatively advanced things without the need for re-writes / re-factors in the future. One of these is to bind events to a lower level element with rather than or . If in the future you modify the menu for some reason with jQuery/JS and DOM elements are removed / re-added, event bindings will be lost. Using avoids this problem. Refactoring your code I've deliberately not included any CSS changes in this code as you can and should include these in your CSS rather than dynamically with jQuery / JS. I have however added and removed a class, this should contain all the style changes required for the mouseenter and mouseleave events. 

Firstly, decide whether your program actually needs to be C and not C++. It's much safer and generally easier to use a std::vector<check_t> than a manually allocated region, as std::vector does automatic memory management for you (it makes it hard to memory leak) and it makes it hard to index the vector outside of bounds, which would cause a potentially exploitable memory corruption vulnerability in your program. If for some reason you must do this without the standard template, next decide whether you can't use new[] in C++. This will simplify your code and be more clear what you're doing: 

So in answer to your question, it's almost never a good idea to increment multiple variables within a for loop. The for loop should deal exclusively with modifying elements that are being iterated, and leave other variables well alone. Violation of this confuses the semantic of the program, and makes it much harder to read. 

There is nothing wrong with this approach at all. Rather than say you should or shouldn't do it any other way I'm going to give you an alternative approach that allows you to write less code in your file. I've noticed that your deals with a lot of different types of requests. This can get very hard to manage when your application grows. It's a good idea to separate out your controllers into manageable classes that deal with one area or feature of your application. The example below would ideally be in a class for example. Taking this chunk: 

There is some form of JS voodoo going on here that I can't programatically work out, can anyone help me shed light on how JS is interpreting this and why when I call: 

Going into the nuances of having a single Cat that can bark out of a set of possibly hundreds of Cat instances is beyond what you're trying to learn but I'm hoping you get the gist of where I'm going with this, behaviour as interfaces generally work better than types and give you a lot more flexibility when actually determining what your classes do. I'm making general statements a lot here, but you will see that your interfaces become very specific to actions. As such they are smaller and make more sense. I have found it much easier to have a class that implements 5 smaller interfaces than 1 or 2 monolithic interfaces due to the increased flexibility available and it keeps things DRY.