A quick and dirt hack would be to edit /etc/rc.local and add "mount /mnt/media". This will automatically be carried out on boot. The correct way, I think, would be to add the nfs-common init script to the default runlevel. This can be done by using the update-rc.d command. 

Try adding and to the file of the SD card. This should put the Pi into a generic video configuration that works almost all of the time. 

The programs started from don't have the environment variable set, even if you're starting them with a delay so that they launch after X does. Just add 

The foundation has been working on an accelerated browser which may work better. The goals they've stated are to improve rendering speed which may help. Unfortunately the limit you're hitting with display probably isn't so much a browser issue as a more fundamental issue with the frame buffer being slow to update. There's not much you can do about that other than maybe move to OpenGL ES, but if you're working on JavaScript that's probably not the right solution. 

2) OK. There's things happening here on two levels. The system level and the motion level. I'll start with the former. The sudo command is making it so that the wget application is running as root. wget is a tool to fetch web-pages from the command line. The -O /dev/null means that rather than saving the file it's sent to /dev/null, which means that effectively all that's happening is a GET request is happening. It's equivalent to going to that link in your browser, but then ignoring what shows up in the browser window. The -q just means we don't hear anything about what's happening in the console. The > /dev/null in the cron line is the equivalent to both the -O and -q parameters in wget. What's happening at the motion level is that motion runs a webserver on port 8091 which works just like a regular web page to allow controlling the software remotely. This particular link to the changes the threshold for detecting motion to 10000, which makes it relatively insensitive compared to the default value of 1500. It uses the username username and the password mypassword for access to the server to verify it's actually you sending it the change threshold command. 3) It depends on who owns the /etc/motion.conf file. If the user 'motion' that runs motion also owns it then it will be able to write. If it doesn't then it won't. The easy way around this is to run which makes it so that everyone under the sun can read and write to the file. You can use to find out who owns the file. You can change the ownership of the file by running instead of using to make sure it writable by the user motion only. root will still be able to write to it too because root ignores these permissions. 

However, the SHELL will use the first binary that it finds (when searching through the paths in the PATH environment variable, so if you put /usr/local/bin at the start, like so 

If that still says Andorra, then you may be better off setting the correct code in this file manually and ignoring the GUI menu, for the time being. I would also ensure that you have the latest update, as the issue that you have found may already be fixed: 

If you have to authenticate, add the following lines to the following files: For general browsing, in add 

If that still says Andorra, then you may be better off setting the correct code in this file manually and ignoring the GUI menu, for the time being. I would also ensure that you have the latest update, as the issue that you have found may already be fixed: 

Try typing . The man pages give you a complete list of the options that a command can take, and an explanation of what they do. In the case of : 

Looking at WiFi country code resets, it seems that the Wi-Fi Country Code menu to which you refer, by default, the version of Jessie that you have, displays Andorra, even if the actual country code is set to something different, which indeed sounds like a bug. However, if you look at the actual config file, what country code is listed? 

As other folks have said, not at "the same time". However, this doesn't mean they can't be configured simultaneously. When you plug in the Ethernet cable, you'd need to unplug the Wi-Fi, and if the Wi-Fi is plugged in you'd need to unplug the Ethernet. Keep in mind that switching would probably break current connections, so don't do it in the middle of a download. 

If you want something internal to a program, the next best bet is accessing /dev/mem directly to control the GPIO. Frank Buß has written some demo code for this. It's quite complex, so unless you really need something stand-alone, I'd recommend the Servoblaster approach. 

Exit status 4 of GCC means that the system doesn't have enough memory. Which Pi are you running with what memory split? Use the command to see how much RAM you have. If you don't know about the memory split, it's basically how much of the Pi's RAM is allocated to the GPU vs the CPU. You can change it by running , then selecting "Advanced Options", then "Memory Split". Set to 16 MB for maximum system memory. You can probably keep it as low as it goes unless you're doing OpenGL ES, in which case turn it back up later. 

The difference between including the option or not, is slight, and is irrelevant in this case, as you can't poweroff the Pi anyway, not without manually removing the USB power. 

I have one of the newer Raspberry Pi 2 B, and wish to install Pidora. I have downloaded Pidora-2014-R3 (the [latest?] version available from the front page of the Pidora site) and copied it on to a microSD card, and inserted it into the microSD slot on the RPi. When I power up the Pi, the green LED lights momentarily, but then goes out and the RPi does not boot. I have followed the installation instructions from Pidora as well as the two guides from Raspberry Pi Documentation: Installing Operating System Images on Mac OS - and Installing Operating System Images using Windows. I have tried both copying Pidora on to the microSD cad from both a MacBook Pro, using the various command line methods, and a Windows 7 laptop, using the Fedora ARM Installer. The microSD card is fine as I have checked it with h2testw and also, if I copy Wheezy onto it then it boots sans problème. I have also formatted it correctly, using SDFormatter. Why will Pidora not boot on a RPi 2? 

Check your ~/.xinitrc file. It sounds like something listed there to be launched at execution of the startx command isn't starting properly and is hanging, making it look like X hasn't started. (It probably has, it's just showing a black background. Misleading, I know!) 

OK. I read your question more carefully and I think I've worked out what's going on. Your bridge and everything is working fine. What's not working is that nothing on the bridge is talking to the internet. Which it can't do because it's not actually connected. On your Pi, two completely separate networks exist. The network, and the network to your router. The simple thing to do would be just to glue them together, by changing the interfaces file. 

The optimal solution is probably to build a distribution that does only exactly what you want it to on boot, this way you're guaranteed minimal times (using a minimalist init system like sinit). Alternatively, you might consider using the suspend to disk (hibernation) feature of the Linux kernel. Once booted, the suspend and resume operations later on are pretty quick, and the system is entirely off in the meantime. 

The reason SSH stops working when you switch interfaces is because each one has a different IP. The SSH connection is active to the old IP each time, but because that interface is down it no longer works. If you configured both interfaces with a static IP address, it may get around the problem, but you'd have to ensure that both interfaces were never up at the same time or you'd loose access completely. 

The GIT repositories on kernel.org contain the source files. Taking one at random, i.e., a/src/gatt-database.c b/src/gatt-database.c, you can see that it is written in C. 

The source code is written in C. Look at the BlueZ download site, and follow the links to the source code on github 

There are many different types ranging from $1 to $5, depending if you want a single display, a dual display, as pictured, or up to a quad display that also shows power (Watts) and charge (Coulombs) 

Surely any OS would do, so long as it supports Java (i.e. it has a JRE), you can specify which binaries execute upon startup and it supports OpenCV - which is all of the common Pi OSes. As you will only be running this app, you don't need an OS with every service installed, nor would you require a desktop environment, just a minimal setup. You should google for "lightweight linux for Pi" to see the full range of options, as it is difficult to give you a single answer without it being an opinion. Nevertheless, some of your options would include: 

Looking at WiFi country code resets, it seems that the Wi-Fi Country Code menu to which you refer, by default, the version of Jessie that you have, displays Andorra, even if the actual country code is set to something different, which indeed sounds like a bug. However, if you look at the actual config file, what country code is listed? 

Anything you redirect to gets dumped out an airlock. For example if you were to what's happened is effectively nothing. Of course, would normally just write to the terminal, which is also only a short-term memory cache on the screen. That never gets written to the SD either. There are generally only very specific instances you might want to write to for actual benefit. For example, doing first pass video encoding still prodcues an output file. This you can send to to save writes on the card. When you do the second pass of the encoding then you do the actual writing. 

Have you looked at the Atrix Lapdock? It's an add-on for a Motorola phone that turned it from phone to essentially a laptop. It has an internal rechargeable battery, 11" screen, HDMI, USB, mouse, keyboard. Sounds like exactly what you want. Powers the Pi for at least 6 hours. Several people have used them. They go for around 70 quid on eBay at the moment, but they're cheaper in the US I think. If you really want a bit of snazzy custom kit, check out the MoPi board. It takes pretty much any power input and converts it for the Pi. 8 to 10 hours on 8 AAs. With a screen and Wi-fi that time will go down, but should still be pretty respectable. What's pretty neat in this case is the ability to hot swap battery packs. Current batteries getting low? Replace the pack on the go! I loved it when my old Dell Inspiron 8100 did this, but with most laptops being much smaller and focussed on reducing weight, it's pretty much a dead feature. Oh well. The MoPi board also tells the Pi when the batteries are low so that it either shuts down nicely or prompts for new batteries. 

As I have already commented, I may be running into this issue shortly, as I am planning on using a Razberry, a RPi dongle for use with Z-Wave home automation devices. The partial answer to your question, and I am paraphrasing it heavily, "Is lib8 on my machine, and if not how do I get it on there?", may be found in a small, typo riddled, article from the Razberry support pages, Will Z-Way run on my specific platform?/How to check is v8 runs on my platform?[sic] 

then it will execute binaries, of the same name, which are in in preference to those in , for example. If you modify your (or .) and then save it, re-source it with , and then type , to confirm that your path has been changed. If I understand correctly, as both of the binaries that you want to use are in , then this should fix your problem. NOTE: The fact that they are links to other locations does not matter, in this case, as neither of them point to , or any other directory in your path. 

If you do not have to authenticate, add the following lines to the following files: For general browsing, in add 

This way, anyone can access it, including the CGI Python. In general for security reasons this might not be advisable, but if it's just something you're using on your home network it's probably fine. 

You can do it. The only catch is that you may need to start the program as root (via ) so that the program has permission to take control of resources (like the keyboard) you're not technically in front of when you SSH in and start it. 

That's off my 16 GB SD card. The sdd1 is the boot partition, which you can see is listed as FAT32. Windows reads this no problem. The second partition, sdd2 is Linux (ext4) formatted, which Windows has a problem with. As a result usually it just hides it. You can see this a bit better under Windows if you go to Control Panel, Admistrative Toosl, Computer Management, Disk Management. You'll see Disk X for your SD card. You can right-click on the second partition, select Change Drive Letter or Path, and Remove the current drive letter to hide it. 

Do you have different gpu_mem settings for each Pi? The camera requires at least 128M to be specified. 

As of December 2013, a slightly accelerated frame buffer driver was made default in Rasbian. There is still as far as I know no "proper" accelerated GPU driver. The recent Broadcom release makes it slightly more possible, but no one has done it yet. 

Use . This should give you the data that you require and enable you to determine which FD points to which device. 

Whilst your question has nothing to do with the Pi, I will quickly point out what you are looking for. I, rather extensively, looked into this a while back, and blogged about a number of XBee modules than can do this, see Using XBee 868 as R/C. However, there are a few caveats, the main one being that as the power used is very high, there is only a 10% duty cycle. This, effectively, means that after 6 minutes the XBee will shut down, and not work again, until 54 minutes later. This is due to some legal reason (FCC/ETSI rules?) There are ways around this, by having some external circuitry that can reset the XBee to make it think that it is starting afresh. Also, there was an issue related to the quality of the video, as bandwidth was not sufficient. In addition, 900 MHz devices are for the US, whilst 866 MHz are for the rest of the world (apart from a few other places where civilian use of the 900 MHz bandwidth is permitted), due to conflicting bandwidth with GSM/3G mobile networks. See XBee Pro 866/900 MHz, or similar, but you will only have a 10% duty cycle. See XBee Guide. NOTE This post is a work in progress and I am trying to find all of the links that I found a year ago. 

If it says "Encryption key:on" it will need some sort of password. What type of encryption is later on in the scan results. In this case it says "WPA2" and "TKIP"/"CCMP"/"PSK", which is essentially standard security for a few years ago. 

OK. Some good questions here. I'll try to take it in order since that's the easiest way to answer, but it may make the text a bit rambling. As far as I know there isn't an inbuilt package for the GPIO other than the Python GPIO package. However, WiringPi has been packaged for easier installation. It hasn't yet been included into Rasbian. I think it will be at some point. As for information about the GPIO itself, eLinux is the best source of information. The registers between the Rev 1 and Rev 2 boards are the same for the pins. I believe that GPIO 21 and 27 are the same pin between them is an annoying paradox for anyone who wants to specify GPIO pin by header number, i.e. by pin 13 in this case. Pin 13 on a Rev 1 is 21, on a Rev 2 is 27. But calling for BCM pin 21 will get you 13 on a Rev 1 and I'm not quite sure what on a Rev 2, but not physical pin 13. The best way to make sure of this unfortunately I think is to actually look at the code of WiringPi or one of the other libraries. As far as I know it's DMA writes shifted up from a base location of 0x20000000, but I've not looked at it in too much detail. Far easier to stick with a library here. Ultimate details of the spec are probably in some of the Broadcom documentation. Personally I use the bcm2835 library when I'm in C. All of the really good documentation for using GPIO on the Pi, however, is for doing it in Python. The syntax can be a bit of a stretch if you're used to C, but you really want to get up and going quickly it's probably easier to get used to those differences and use all of the available tutorials. There are literally dozens. C and C++ cross compatibility is one of those interesting things. In the case of the libraries for GPIO they're effectively compatible as they're all written in C and are linked as dynamic libraries. Keep in mind that gcc is for C files and g++ is for C++ files. But you can compile a C++ file with gcc as long as you don't use any of the special C++ features. Like classes. I'd stick to C for now until you get used to things again. It's much easier to learn one thing at a time.