I have spotted too many simple issues in order to review this code in-depth, therefore I will point out what simple issues I am seeing and I encourage you to post a follow-up question such that the code can be properly reviewed: 

You have your phrases first, you want to simply have an object that holds your s. Here a is a suitable object, because you only need to have a view on your object, there is no point in actually storing the new data. You do this by calling . 

A mapping that can safely map instances to . The only methods to interact with it are and , the ensures that the types are correct on compile time, it also uses which is from Java 7, but you should be able to convert that. The method can safely cast back to , because the method ensures the types. 

This application is written using Groovy 2.4.3 and Grails 3.0.2. I'd like to have this code reviewed and if possible extra attention on the transition from Java to Groovy and on the mixture of Grails and Spring code. domain/User.groovy 

Code My program structure is based on calculating the indices of 4-tuples that can be found diagonally, anti-diagonally, horizontally and vertically. I obtain this by reading the input grid into a single vector, then doing some magic to get respectively the diagonal, anti-diagonal, horizontal and vertical lines, and then I partition each line into segments of size 4 with an offset of 1. problems/problem11.clj 

I first played around with , but it turned out to be only of use for formatting, and not for parsing, as it only gives one specific format per locale. So I decided to roll out my own code whilst still intending to use as many Java library features as possible (mainly from and ). The test class: 

Put all s together in some structure. Keep track of how many occurences they have. Sort the list to have the words with the highest amount of occurences first. Return the top x occurences. Then decide what you want to do with it. 

I'm not an expert on HTML, but I am quite decent in using it and can give you the following pieces of advice: 

The caveat then is that I don't think methods accepting an now, would accept those sub-interfaces then. 

I have decided to create my own , because I wanted some abstraction and a couldn't give enough in my opinion. I'm also using the class, as I really like how it is being used in JavaFX 8 and figured it would be useful. The basic properties of a cursor are: 

Then you start at the method, which returns a , again to offer the flexibility to do what you want with the results, they are not stored yet at the point where it gets returned. First I added some error checking. Then I obtain a that will compare what the entry is with the lowest number of occurences. This is done by using a on the value of the entry, which is obtained with the method reference . Then I start the chain of operations on the input : 

In the invisible documentation I have written that in both methods that must hold. The abstract test class that should be extended, is the following: 

You could remove the dependency on in your class by adding a dependency on a , now your instance creation could look like: . While your styling is in no place bad, it still has room for improvement. You inconsistently sometimes have two lines of white-space between methods, this should be only one. Your statement lacks breathing space, it should be of the form , not and in one case you have unnecessary spacing in a method call, see the call. 

In response to your German overengineering™, I raise you some Dutch overengineering™. I have managed to get rid of almost all unsafe things, like creating instances via reflection etc. My implementation has one unsafe cast, but I'll explain that it's no issue as we go. I have decided to re-implement your solution as a whole, so this will not be a review about existing code. Your problem statement, according to me is that: 

Create a single regex that captures what you want to do, thus needing only one call. Go really into micro-optimizing and get rid of the regexes in a whole, operate on a and only store the resulting character array. 

Read all lines into a (care with large files!) Turn it into a . Turn that into a by flat mapping every to a splitting on the blanks. Collect all elements into a grouping by the identity () and using as downstream such that the map-value will be its count. Get a from the map. Turn it into a . Sort by the reverse order of the value of the entry. Map the results to a , you lose the frequency information here. Collect the stream into a . 

I have been thinking quite some time and asked an StackOverflow question about extending abstract test classes, but I haven't been able to do it until now. I'll list my approach and then discuss some pros and cons and am asking you for a review of the code. Consider the interface: 

I'll review this code with keeping in mind that you want to leave Apache Spark intact, as you intend to use it in the future for purposes it is intended to do. I strongly believe that your current code can be written in pure Java 8, though that is not the point of the question. Use lambdas wherever you can! This will greatly enhance readability of your code. As an example: 

I'm still working on a parser that can parse log entries from a game called HearthStone, the overall idea is that it will read the log file live when the game is running, parses the log file and show interesting and useful data in real time. The focus for this question is to load the card data from JSON files, as can be found on $URL$ which represent accurate card data in HearthStone. I wanted to not use any external libraries and I know Java 8 came with the new Nashorn ScriptEngine, so I decided to play around with that. The main reason why I did not want to deal with external libraries is that in my opinion creating objects to store all properties of some item down a JSON object is really annoying and I want to quickly have a result available. Of course it turned out to take somewhat longer than I hoped, but I am still happy with the result. 

Judging by the overall structure it looks quite good, I would change a few things though with respect to formatting: 

Ultimately I plan to release this as a separate GitHub repository and provide it as a Maven library. 

As you can see I'm treating the planet coordinates as a string rather than how it's done now and this will eliminate the need to have both a and a delimiter. 

You are using some random object range in , I suppose you wan to use such that it scales with your input. Please try to use meaningful variable names. and are utterly meaningless, for I do not know a replacement right now, for I suggest . Your code currently only works with s, consider making it generic and providing primitive overloads. 

I'd like to get the code below reviewed on all aspects, specifically I wonder if it's common usage to use like this, as currently more computations are done in the statement than in the rest of the code. 

(For reference with respect to variable names: The 29 DR item is called a "Le Noir" Armor) When testing this application, you can use prices in the range of 300,000 to 1,000,000, that is the regular market value in the game. 

To get familiar with the Rust language I've decided to implement the method of Sieve of Eratosthenes to find primes up to a number N. I have created the following code that both prints the prime number and whether it is prime in tabular format and prints a vector consisting of the prime numbers. As additional library I'm using the external library bit-vec. 

And it now executes the tests from on my class! The pros are that the instance only needs to be passed in once and most importantly that you must pass it in or you will get a compiler error. Another pro is that the list of classes to be tested is not defined in the abstract testclass itself. The cons possibly are that issues can arise with dependencies and mock objects, but I'm not too sure about that and would love to have that included in a review. Does this seem to be a reasonable way to do it? Small update, changed signature in from to to ensure that a compiler errors, rather than warning, will be thrown on an accidental override. Second small update, changed signature in from to , now it cannot be overridden anymore. Last update, appereantly the latest change was showing weird behaviours when executing unit tests on my whole project, rather than a single file. I have changed the following: 

You need to give a as argument, and that is exactly what is. Reduce logic involved in In my opinion too much is going on is this method, there needs to be a way to write it in a cleaner way. An example is the following, though it still does not eliminate all increment and decrement operations: 

Here we explicitely specify an over the general interface and to obtain it we use the third parameter of , which is one that takes a as argument, which means that you need to provide the map yourself here. Another difference is that we here use a method reference, , over for improved readability. 

For the online text-based browser game OGame I am working on an application with as aim to assist the users where possible, for this I have a server-side part and a client-side part, the respective repositories can be found here for the server-side part and here for the client-side part. The client-side part is implemented via an userscript, it has been tested to work with GreaseMonkey in Firefox. The script currently offers the following functionality: