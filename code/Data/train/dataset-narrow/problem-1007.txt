I would probably stick with the original, though. I only mention it because a fair number of people don't know about it and sometimes it does matter. Your naming breaks PEP8. Don't let fool you; was written by heathens before the style guide was standardized. A quick touch-up is 

It's also more typical to on failure. As Caridorc says, is much better than at the end of the function. should also use 's clause to minimize the area under it: 

So there we have it. Python is over an order of magnitude faster on 75% of interpreters, and under an order of magnitude slower in the worst case... But why is it so slow with ? is a good utility: 

...although immediately ing the result and not giving it a meaningful name is a surefire way to confuse readers on what the code is actually trying to do. Back to . 

It might be better to stick with the origingal logic for zeroing if this doesn't doesn't seem self explanatory enough, but it's the same deal as the old function or Java's . would be better named as a positive; . It should also be removed from the class because it's neither used internally nor really benefits from encapsulation. The class is a behemoth with only one method; . This seems completely the wrong way to do it, especially because shouldn't really be mutating things. If you want battleships to be made inside boards, add a method to the class. In fact, you write: 

IMHO, this is more explicit about what the probabilities are. I would also do and remove the decimal point. Your 

should just iterate over ; the is optional. You probably shouldn't return on failure; I suggest as before. In , you have . It makes sense to call this . I would also do the loop as: 

It's worth noting that the whole thing is confusing - why is it ? The lack of documentation on why is special-cased is confusing too. I have a feeling at least some of these are bugs in the program. 

There's absolutely nothing wrong with putting multiple classes in the same file, especially if it makes the code more readable. That said, there's nothing saying you can't re-export your classes from another file if you would like the code and the module structure to be somewhat orthogonalized. 

Note that even this is suboptimal since we recompute the same stuff on every call to , but fixing it is less simple. 

which is simple enough to basically be ideal. A more advanced programmer might want to handle errors or put code into functions, but the advantages of those only really apply to larger programs. 

In , there's another minor style point which is that should be . Personally, given that only uses and once, there's no great need to shorten them so much. YMMV. 

Note how the comment can now be removed. Here's an attempt at a cleaner version. I've also added a couple more speed improvements, because I'm a hopeless addict: 

Note that does not currently handle the changes to game flow made with regards to finishing the game. 

By using a well-defined API you can avoid such strange results and give better errors messages. Even better would be building a parser yourself, but that sounds a touch harder. I would also consider doing substitutions and finding all name tokens at the token level simply because it allows supporting things like 

This operation thus filters the friend list by the person's friends. You can then do an along the y-axis to find once-indirect friends. 

However, this fails for since ! What to do? It seems like one could flip into the negatives instead, and flip all of the comparisons. I don't think this would work, though, since 

which means that you're returning instead of in the first branch or if all three s fail. However, it's OK as you never use the result. Remove it. In , you can simplify generating with a list comprehension: 

but you should be using anyway. Further, you should be reading from its output, not directing through a file: 

You should be more careful about how you handle errors in ; if the constructor closes the file should also be left closed. Your first read to find the endianness uses the default, platform-specific endianness. I would imagine you want a more sensible default like . remakes its entries every call to . It makes more sense IMHO to generate once on creation. All in all, I get something like 

However, this hasn't separated logic from UI (output), which is another important aspect of code quality. It also doesn't deal with invalid input (such as non-integers being passed to ). 

Rust does have inline functions, but if you have them trailing you do need to explicitly . Further, the expected way to do is , which is nowhere near as pretty. 

produces the same number of instructions total, but early-outs () faster for the exceptional case. Unfortunately the normal case () gets an extra , though that can in theory be done in parallel to the main operations by the CPU. 

The delayed action from doesn't give a noticeable speed improvement and adds code complexity. For that reason, I suggest you remove and just use . As before, make a full method, not a property, since it's not a trivial computation. spends a lot of effort finding the 0 before actually giving results. This would be a lot faster if tracked the 0. You can also use chained comparisons to make the check neater. is a very hefty check for something called so often. It shouldn't be a but, more importantly, it should short-circuit. A quick idea is just 

For the next part, note that cyclic shifts like this are not at all fast on lists, so should be strongly avoided. But note also that you can avoid it entirely by just being more intelligent about how you produce values. 

The difference is obviously much less, but it exists. This is probably due to improvements in memory locality. It actually turns out that just terminating the range with gets you almost to this point, so the optimization, IMHO, isn't worth it. Sadly, CPython still trails the first version on PyPy. Janne Karila gave a good suggestion in the comments for speeding up CPython. The key part is to use (or ) to apply a filter and to do the counting. The large advantage comes from the iteration and counting being done inside C routines. I went with from Python 3.1 and Janne Karila's use of to get the wanted element: 

Note that is a poor naming choice since it refers to the type and not the value. Something like would be better. These: 

You want the first in the text, so you can either also use Ashwini Chaudhary's method or something like 

Secondly, some comments about the code. You use and as constant indexes into a list of length 2. You should use a class instead. Here's one: 

If you care about optimization, use maths to simplify the problem before the search. Starting from the bottom. 

Instead of generating in and , elements sequentially from them. Turn them to lists at call-point if needed. 

Note the use of / instead of is because of lexical lifetimes. Since this is currently pretty ugly and the speedup probably doesn't matter, I'll leave this as a hypothetical. You say you "don't like the asterisk", but that's kind'a how it's meant to be done. I guess you could go the Julia route ( + + ), but that's not really better. After a few miscellaneous changes, the code for me looks like 

cannot fire until after . This lets us fix our . Back to . The documentation is not written idiomatically. Documentation should be to the point, direct and not talk in third person. 

I would change to to make it clear that it returns a value and not a boolean. I would use to improve the formatting of the regex. Maybe: 

The result of both of these is that you force a rather strong well-formedness requirement on input and it's basically impossible for input to do something bad. Errors are also better and identifiers can be of any length. The one thing I can think of that isn't covered by this is that it still allows improperly matched brackets: 

Perhaps an easier compromise than Corbin's three classes is having just one to encapsulate most state. This separates the iteration and printing from the iteration step, and IMHO comes out cleaner. 

I would then change (generally) to and to (or even ) - there's no reason to be using variable-length integers in this day and age for these types, and you don't need signed values. When you do want variable-length values, you'd probably rather stick with . (If you find these unwieldy, them to , and . Just don't use and 'cause they're prettier.) Compiling with warnings, I get 

Instead of checking if it's a , I try to make a from the number. If this suceeds, instead of returing I return the type I have casted to () and the value, which I later sort by. If it fails, the type is and I sort by the string itself. Instead of using two lists, and , I have a dictionary mapping types to the sublist. I used the decorate-undecorate idiom to sort the keys while retaining their string form; namely I sort objects of the form by their keys. I use objects instead of tuples to aid comprehension, since s are so easy to create. Instead of using and , I use on lists. There isn't much advantage either way, but this seems cleaner to me. I use instead of a comprehension because I don't like mutating within a comprehension. I backport Python 3's function with . This allows me to just write . This is basically the same as . 

You know that from reading the code so you don't need to repeat it. An example of a good comment would be 

variables might seem like a good adherence to "no magic constants", but in reality they have effectively no useful purpose. If you wanted to update your code to support other character sets, you'd want to redesign the whole parser anyway. IMHO, it's simpler to inline these. You're not required to in modern C, and it's somewhat typical not to. Your integer parser should be generic in the base. I suggest extracting this into a function like : 

For low numbers, , , , this hits a lot of those later values. We can then split the work into an upper part: