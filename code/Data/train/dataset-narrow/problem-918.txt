I like your use of , but would suggest that you likely need to add some more meaningful validation than what you have. Obviously, validation of individual field values would probably be deferred to individual models in the MVC, but is there some other basic validation that needs to happen here? For example, if POST http action is called, but is empty you could raise an some sort of exception against the request before getting to routing step). You also need to actually check the return from to determine if the filter passed. What if the data payload (for POST or UPDATE) is not pre-populated by PHP in because you are not dealing with form-encoded data type (like you are using for example)? In these cases, would not be meaningful. 

Note particularly here the bolded text. What you should take away from this is that you need to begin to think of sessions and authentication (login) separately. Really the sole purpose of the session is to persist data on the server between client calls. PHP Sessions are not authentication or reliable data access control mechanisms. You do not need to "destroy" the session at all upon a logout event in your application. You can simply upon this change in authentication state (just as you would need to do when user logs in). But before that action you would need to programmatically set the data to expire on the current session id. This is the only reliable way to "lock out" this session data. This of course means that you would also always need to validate that the session id passed to the page does not contain expired data directly after calling near the beginning request processing and treating this as an invalid session if expired data is encountered. Also, think of it from an application functionality perspective. Just because a user is logged out, doesn't mean your application might not need to still store some data in session. For example, maybe you might need to store something in session before performing a redirect to let the destination page know some piece of information (like the fact that the user just logged out). That target page might need to change the display on page the user is redirected to (like perhaps a successful logout message in your case). 

I would agree with your concern over naming, as this doesn't really seems to be a "service", but rather a simple data store. So perhaps or similar is more appropriate. You have some portions of code that are omitted that might suggest a more permanent data store being used in conjunction with this class, so perhaps this is really acting as a cache ()? 

If you find you have one schema that is used multiple times for validation, then perhaps it makes sense to have concrete validator objects like this: 

Note, use of arrow functions is optional, but since you indicated you are writing for ES6 and transpiling, and since the callback logic is so simple here, I thought the arrow function made sense. Alternately, you might perform reduce then map like this: 

I think from a practical standpoint though, you might see explicit or method calls used most frequently, as oftentimes one might find themselves working with dynamic key names, which would eliminate the first usage example from each of the the sets above. Oftentimes developers choose to simply be consistent and use the getter/setter methods rather than mix direct property access when key names are known vs. getter/setter or "array-like" access when the key names are dynamic. More complex applications may also abstract out direct access to and altogether, especially when dealing with browsers that do not support web storage (and therefore may need cookie-based fallback). In such cases, you would absolutely not be able to have hard-coded key names when interacting with the underlying web storage, because you might have a usage pattern like: 

This appears to be hard dependency. You should use such that this script fails out of you can't load the dependency. Also, your style of adding space between function/method name and opening parenthesis would be considered non-standard by most PHP developers. Typical usage has no space. This makes reader less likely to confuse this parenthesis with a logical operation. 

I do see that you at least try to give Singleton-like concrete behavior to the , but really, the properties should not be static in this class. I am not really sure why Singleton is that important to establish here either. Would it be simpler to have all your instantiation logic triggered in your constructor, with exception being thrown if there is any invalid data that should prevent the object from being instantiated? Why introduce static/concrete duality? 

This gives you clear separation of logic such that your collection no longer needs to understand how to instantiate the object. It also removes the obfuscated logic of calling on a object returned from . Why would be expected to return a object instead of simply adding a object to the collection? Passing the dependency like this would also allow you to type hint that a valid object is passed. Right now, you are doing absolutely nothing to validate that that the parameters being passed to this method (or really all other public methods across these two classes) contain good values to work with. 

Really, the best way to optimize performance is to make the HTTP requests in parallel. After you have done that, you could consider further optimizations with regards to parsing. Consider using or similar for this. I have a REST client based on that you can feel free to take a look at for inspiration (or just use as-is in your application based on MIT license). $URL$ 

Now on to javascript, where most of my feedback relates: Don't cram all your game logic into one function. You have way too much going in this this function - game setup, cards being dealt for individual turns, card deck being shuffled, win/loss resolution, etc. 

This could, for example, just map various actions, modules, etc. to different controller class names. Each of these controllers would need to be able to accept a object as a dependency and know what to do with it when is called. The router would instantiate the appropriate class and then pass the to it. As a developer wanting to add new action/behaviors to the system, all you would need to do is build a new controller for it, and then add the new controller to the route map as appropriate. You would not need to change one bit of code in the rest of the application (i.e. the top-level routing script) unless you were introducing a non-compatible change for some reason (i.e. your whole route map would need to change). And in case you were wondering what happened to all the handling of invalid requests, that would be something that would live with the . If it cannot successfully route the request, it could just instantiate an or similar to fulfill the request. So your method might look like: 

Do you really want to be updating unix timestamps into the table as opposed to using appropriate MySQL datetime or timestamp fields? 

This reduces your problem to only having to figure out how to populate the value into , not trying to determine this directory when you are at the point of trying to conditionally load configurations for various components in the application. This could be hard-coded (not ideal) which is quick and dirty, but you might consider an approach that allows you to conditionally determine the include path. For example, if you control the environment, you could modify your Apache config to inject an environmental variable holding the include path or, if missing, perhaps looks into a file that you specifically deploy onto your shared host to determine how to get to that include path for the host you are on. So perhaps something like this near the beginning of your application bootstrap process. 

In your class. Your methods are unclear in intent, possibly due to poor parameter naming. Why would a caller be passing a to these methods and then have totally different objects instantiated inside the methods? What is happening here? Why would a method get objects passed to it when the intent is to get objects returned from it? Are you really passing ID's here (meaning perhaps the parameters should be renamed)? 

I honestly question your use case. Can you expect a user to realistically interact with thousands of elements in any given view? Should you be considering pagination or some other means to allow the user to interact with smaller groupings of these element Also, just because you have attached an event listener that could possibly impact a number of elements, the user is only going to be dragging one element at a time I presume, so I am not sure you are going to have to worry about the performance of the animation to any great extent. 

In save method, it seems that and are perhaps reversed in order. I don't know that it really matters, but there is no reason to rewind before truncation, and it seems more logical to place rewind call directly before you are attempting to do write. There is no reason to even rewind the file pointer if you cannot successfully truncate the file, right? 

You would be 100% guaranteed from the perspective of this class that you have a valid dependency to work with, as you likely would not even trying to instantiate the class if the PDO instantiation failed. You are also type hinting the parameter as valid PDO object. The constructor would fail with exception if this condition is not met - a good thing as it saves you a lot of guarding code. 

Are you sure this is reasonable error messaging? If you get to this state, then you likely have incompatible rules defined between the client and the server. Just listing the names of the fields that failed on the server may not be useful for the user in understanding how to address the problem in the client (or can they?). Is this even a recoverable error from a user standpoint? Perhaps an error like shown in the ajax error handler is more appropriate. 

I would however suggest you guys consider using dependency injection rather than (or at least in conjunction with) singleton. Taking a dependency injection approach allows you to remove code in classes that need a dependency (such as a PDO object) and enforce strict contracts in your code. So rather than this sort of code: 

You have unreachable lines of code in . When is called, any lines of code after that call in that code path will never be reached. You should never have unreachable lines in your code. 

That gives you the ability to easily iterate over this object to create transformation strings. An example of this iteration might be: 

Just remember that as soon as you modify an array assigned in this manner, you remove the ability for PHP to perform it's behind the scenes memory optimization. But really you should not be relying on this anyway, as IMO it is bad coding form to be relying on some hidden, undocumented and possibly subject to change optimization for your code to be working in the best manner. Alternately, instead of associative array for data, why not use an object (even ), then you are always working with reference to the object (unless you specifically clone it)? For example: 

Should you support caller-provided setting for parsing behavior (i.e. )? This means the caller got get different datsa structure renderings which are potentially unreliable to other areas of the system. Should you consider as default parsing behavior, as this would tend to yield data values in your array that are more meaningful to be used in other areas of the application (i.e. booleans vs. 'yes', 'no', 'on', 'off', etc.). This could of course be a problem for persisting to file as you would need to potentially have a conversion back to 'yes', 'no', etc. Perhaps functionality needs to make boolean conversions? I guess my summary thought here is that you are potentially introducing inconsistent conversion behavior with different parsing modes, and I don't really see this addressed in your code. 

You will note that the core logic in both examples is pretty much the same. So really the only difference here is whether you allow the function (class) definition to be callable from global scope. In the second example, wrapping the logic in an IIFE has the effect of hiding the function definition from global scope, in essence providing singleton behavior. Which you might use could depend on the needs of your application. 

I would think that, this being a class and all, the server address would not be hardcoded into this specific method. 4) 

To me this helps make the data model for more clear. And decouples the operations of data model definition from data population/decoration more clearly. The init() function could, for example, be an external function. If you want even more decoupling, you could simply pass the data structure to the decorator function, rather than having the decorator function living on the object. 

In class B, I don't understand declarations throughout. Using is generally a PHP coding anti-pattern that should be removed from the code. It seems as if the intent here is to access the class properties, which should be done using . 

You should cache jQuery selectors that you are going to be using repeatedly, rather than repeatedly querying the DOM. 

Even if you choose to keep as public method, you could still reference common validation function like: 

Why would be part of the conditional criteria for this POST logic? This variable may or may not even be populated with a record. 

Note that this is simple example and doesn't have proper error handling around statement preparation and execution. You should make sure that you just don't assume these things work. Make sure you understand all possible results and/or exceptions that can occur from a function/method call and handle those outcomes accordingly. 

Consider naming your property to clearly represent to someone reading this code that this is what you are working with. 

This would allow indexed - O(1) - lookup by country code. The class should probably be called or similar, and have method. A class named should probably be a red flag that you have really just built a function. If you want a class for this, make it a class and name it appropriately. This class is where you should hold any methods to validate a country code as representing a valid EU country. 

I have recently refactored a REST client library and was hoping to get review for both the class itself and the unit tests that cover it. This code is developed against PHP 7.1, but tested against PHP 5.6, 7.0 7.1, HipHop VM, and PHP nightly builds. The full library can be seen on GitHub RestClient.php 

Move this outside loop. Consider parameter typing here. If you truly want to store integers, or doubles in your DB table, then you should enforce that here as well so you are not accidentally invoking potentially unexpected type conversion behavior in the database. Your current binding logic assumes happy path. What if binding fails? 

The first question I always ask when considering using an htaccess file is - does this really need to be in an htaccess file? By that I mean ask yourself a few questions: