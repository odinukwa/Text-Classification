Just one suggestion for starters... nesting- When a method is strictly doing only one thing or another: 

To make the performance better, you can consider using a instead of a . To avoid the huge nested -block after , consider -ing early: 

Since Java 7, you can rely on for safe and efficient handling of the underlying IO resources. For example: 

An additional benefit of this is that you eliminate to risk of calling accidentally, when the argument is really a URL. Auto-boxing You rely on auto-boxing for your and classes. The problem with this is that you get a nasty if there is no mapped/array value, and the JVM is trying to unbox the to one of the primitive types. Also, if the value is not the desired primitive type wrapper object, you will get a too. You should consider checking for that, for example: 

What that means is to ensure all matches the (lambda) . Input validation Your input validation can probably be better done as a method: 

This particular way of parsing is entirely dependent on the representation of a implementation, which is not always guaranteed to be in this format, much less for all implementations. In other words, this may be prone to breakage and you'll probably have to revisit if you want to include any form of validation. Ok, so let's just assume this suffice for now, and review the next part: 

You have pretty consistent and decent whitespacing... until here. You can probably shorten your code as such: 

The sample implementation shown below for does not perform any validation. Actually, as a result of the operation in the previous step, it will be quite tricky to make sure that \$1 \le m \le n \le 1000000000\$, so I'll leave this as an exercise to the reader... (hint: map each input as a to facilitate the validation first). Collect all results into a for further usage 

Much simpler. Premature Optimizations If you ever have enough members in a room for the optimization to gain you anything, you'll probably be exceeding the length of the Mongodb query. This needlessly complicates your code. Ironically, any gains are lost when you forgot to use rather than , which needs to iterate through the lists you just made to avoid iterating through the lists. It looks like the accessors for the attributes already return values, so this can be much more readably rendered like this: 

Ok, now that's out of the way, to the good stuff :) Use interfaces if they are already there Scala's interoperability with Java is one of it's strengths, so re-inventing an interface isn't really needed. Additionally, using gets rid of the structural typing, which is a nifty feature, but it's better to avoid if it's not strictly needed. This simplifies things considerably, particularly the type signature. FlatMap is a Monad, which means a bunch of stuff to category theory buffs - which I don't particularly care about. What I do care about Monads is that they have two methods defined on them that can make life much easier. is the first, and you've basically defined the content of this method in your outermost pattern match. Refactored Version 1 

If you have any control at all over you should be using instead. If you have no control over , define these methods using an implicit. These checks should only every be made in one place, not every place that accesses the code. Assuming that is a (just a guess). The signature should in should be: 

Normally, I'd suggest trying to get rid of as much mutable state as possible. That's not really possible here, the circular reference to the parent pretty much guarantees that something is going to need to be mutable. Vanilla Version Without deviating much from your original design, there are a few cleanup suggestions that I can make. First, as suggested by @Carcigenicate , could use some naming fixes. In the version below I used , but it could have been any number of choices. I also inlined the creation of . 

As per my interpretation, you don't need empty string check inside the if clause you can put it out side, and last condition could be expressed in one line. 

by using this you have only a reference of interface will be there in viewmodel . but not the whole view itself 

I would write an extension method to do parsing of input string. so it should not be inside your query method. I have declared a class named SearchCriteria to encapsulate all data member you want t o query. 

One more tip for , reading the content from the HttpRequestMessage you could user some model binder , I did not find any async version of the code though so you might need to look for it. 

okay first of all, you need to use buffered stream to read data from the file, there is no need to write data once in file as it might hung altogether. so I would suggest that read the file line by line , parse it and then write to file. 

You have multiple options a. Use an event Aggregator where publish the message from the viewmodel and subscribe from view. see prism documentation for event aggregators:here is sample code 

Well I have changed your code a bit to make it cleaner.It is recommended to have a uniform interface for methods, so now you have two methods in FamilyExpense class is addExpense and another is getExpense rather explicitly calling each method. I am not sure why you have used getFamilyId and setFamilyId. 

2) Always dispose the connection In above code your opening connection and closing it, but this can lead into connection leak in case of errors. Please wrap your code into using statement or try clause like this 

Please separate out your code into at least two classes 1) Fetching data class 2) UI binding stuff class 4)inline SQL vs Stored Procedure Stored Procedure is good as your code lies at one place in db but creating Stored Procedure for one line of SQL is not a good idea. If your logic is going to be complex and big ,Use a Stored procedure other wise inline sql. PS: I have created a gist named SQLHelper class for you to abstract out the sql connection and command things, $URL$ 

It has some very nice features, one of the most important is the helper function , which scales the threshold with the size of . This makes the non-termination check for unnecessary. It's tail-recursive, and flagged as such, honestly it shouldn't make a difference for this algorithm, but it's a nice touch. Here's the test suite I used to verify it has the correct behavior. 

This won't actually work. It'll print something different depending on where in the array you put it, but if you append the rule, it'll return this for 1 to 5: 

Along those same lines, became because that's really what it does. I also moved the helper functions into 's companion object. It's a good default organization strategy. itself had mostly structural changes. I changed the visibility of , so that mutating it has to pass through the helpers. It also became a Set, as the OS doesn't generally make guarantees about listing order, so I wanted to avoid implying that the order was something that could be relied on not to change. became just and passes a defensive copy of the internal set. That gives us this final version, with a small driver to make testing easier. 

Pattern Matching The next change moved from to pattern matching. I did this for two reasons. The first is that it allowed better naming that and generally made the logic a bit more clear. The second was that it paves the way for one of the other changes that I had my eye on. 

Your logic is good, and the API is pretty solid as well. There are a few point that could use some work. Organization can be moved inside of to simplify the structure slightly. It's also tail recursive, so you might as well add the annotation. I cannot recall if this is required, but even if it's not, it's a good habit to get into. For readability, I'd recommend reversing the so that the one-liner is in the clause rather than the clause. Generally speaking, it's easier to keep track of what part of the code it belongs to, the closer it is to the construct - particularly if there is a bunch of nesting. Here it doesn't make a big difference, but as a matter of course I'd swap them. Return Types & Misc As you are forgetting everything except when we return, we can actually simplify the return type to just . I'm going to assume that was intended, so needs to become . As the name of the trait was dropped from the question, I'm going to use . Early Termination What you have marked as an "early termination" is just "termination", it's the base case. Limiting this to the length of candidates isn't really early termination. A similar effect could be achieved by replacing in the call inside with . If you want to the library users to terminate early, which is not a bad idea, one way is to have return rather than just . Refactored Version 

Besides the slightly odd class name (nothing wrong), one suggestion I can make is to use some sort of a builder (or "fluent"?) pattern to construct your linked lists... Possibly along the lines of: 

Now, by right, we need to negate our first condition to make sure we only when it is the second condition that has been satisfied. However, if you look at the computation of , it is always positive when , which so happens (?) to be the negation of the first condition. In other words, when the second condition is , we already know that the first condition must be . Explicit negation of the first condition is thus unnecessary. The second and final statement is just to . If we are not -ing , then that means we should check whether we need to perform the following two steps: 

Construct an with the values . Box it into a . Collect the values using an instance of . For each , print it using . 

My advice is that if there's a variable on your class that should be immutable the moment an object is instantiated, it should be done in the class constructor. That's because you can declare the variable as and you can reliably use it within your class knowing that it cannot be changed. Your class seems like a good example of this. :) A suggestion (using your coding style): 

using a that uses as a method reference for the first comparison, the end time if two s have the same start time. Loop through the sorted and compare using , which is easier to read and understand. 

Model classes You may also want to consider having a suitable model class to give a better representation to the three-column row inputs you get over the current . With a model class, you can have a custom implementation that only compares the ID and date values between two 'instances' aka rows, so that the next different row will return for the comparison. This may simplify not only your approach within the method here, but outside usage as well for the method callers to deal with the of results. Also, food for thought, would it be better/more efficient to return one object that contains an , and a of , since the and are the same for all the names? 

What's happening is that you are avoiding having to check for the mod 15 case by combining the mod 3 and mod 5 cases. This is fine if that's all you'll ever have to worry about, but if you intend to add cases later it's better to be explicit about things so you can be more flexible in your later rules. These two changes will replace un-modified numbers with 'Zazz': 

I found about 5 things that can be improved, or maybe it's more accurate to say that I did 5 passes over the code in my efforts to improve it. Here's the changes I would recommend, in the order that I encountered them. Better Names The first change was mostly cosmetic, but it was very helpful laying the groundwork for more changes later. 

By switching to a signature with multiple parameters, the compiler can infer types more easily, and as an additional bonus users can now use the shortened function literal syntax. 

The basic premise is that exceptions are exceptional, so they should never be swallowed. Refactored Version 2 

This has a major weakness. Tail recursion lets us work with large s, but a is a singly linked list, and they do not append well. To fix this, I created the list in reverse, then at the end reversed the result. I was not particularly happy with adding this complexity, but it was necessary to gain access to tail-call optimization and avoid blowing the stack with larger lists. Program to the Interface The best way to remove the unnecessary complexity introduced in the last step was to switch data structures. This would be more difficult if this had a bunch of code that called it, but it was simple to modify the signature and use a instead, which has excellent append performance. 

This had the added bonus of eliminating a level of nesting, but the big gain was being able to easily decompose the results into , , and . Tail Recursion One of the big remaining issues is that this will blow the stack on large lists. So the next step, facilitated by the simplification we gained by switching to pattern matching, was to rework it into a tail recursive version. 

Actually, I'm not that sure whether you really need to map the Pojo in order to determine if a row with the primary key exists or not... Perhaps there's a simpler way? 

The should be on the same line as the first closing . To reduce an additional level of nesting inside your method, you can invert the case for your statement to return early first: 

Also, what you are doing is to store one token into a new via , this is then iterated for elements to be stored into a new , which is finally added to . May we know what exactly are you trying to do here? I'll attempt to illustrate the output for the following: Input: 

Bonus: Oh yeah, is it the largest or longest palindrome you are looking for? Since you are dealing with s, my suggestion is to be consistent and stick with permutations of 'longest palindrome'. :) 

Instead of having to pass around a thread-safe to gather your non-pingable servers, you can call to get a , which you can then retrieve the results. First, I'll suggest having an implementation of : 

I did some formatting myself and shrank your code down to 48 concise lines. From there, I can see that the calculation for the phone and TV costs are the same - so you definitely should consider creating one method for each to wrap them and call them in the relevant places. This will also make future updates easier as you only need to modify two methods (which can be as simple as a one-liner method) instead of potentially six different lines. Why is there a need to cast the number of days as a double type? Also, as pointed out by @ChrisW, the first if-condition has a nested if-statement that doesn't make sense - a bug from copying-and-pasting?