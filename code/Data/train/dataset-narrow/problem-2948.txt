As you are teaching business people, not computer scientists (though what I say may also be true for teaching them). I would start on the more practical. Teach them stuff that is useful. , (Don't use float types for currency, it will cost you your job, and someone a lot of money), (A float type with base 10 radix: it has less unexpected behaviour), and . Integer has some value, but manly for performance. If when doing loops you use , then integers are not needed. Also looping is simpler and safer. Booleans are only needed when doing conditionals, and conditionals are over used. 

Note: Be careful with the halting problem. I keep hearing it said that it is impossible to determine if a program halts. This is clearly not true, for we have done it (here I mean: we = you and I). It should be stated that “it is impossible to determine, in the general case, if a program halts.” That is it is impossible to make a program/machine that will be able to tell you if a program/machine halts, that will work for all program/machine inputs. 

Some technical solutions I am not looking for technical solutions, but I have included a few here, in case they would be useful to others (and this is not the right site for asking for such solutions). 

Some related research There has been some research into how to hire people: How do you select people that can do the job. The traditional methods reject too many “good” people, and accept too many “bad” people. It terns out that the best thing to do is to test them doing the job, and selecting for attitude. Therefore to test programming you should test programming (I don't care how good an essayist my heart surgeon is). Google is one of the companies that has done some research in this area. There will be others. I heard about this on BBC Radio4, so there may be some info on there web site. Some other suggestion 

I have worked of projects where every file had its own style. It was not a problem to read, but when a file had many styles it was. Switching style may take experience. There is more buy in when a person is involved with the decision. Therefore each pupil should choose a style and stick with it. It is also easier if problems are found automatically and as early as possible. Therefore use an IDE that does it for you. Then as a second level of defence use a lint tool that detects problems. If these two can to do it then it is usually not worth it. However there is still a lot of judgement, that can not so easily be put into rules. 

However there freedoms are immutable, no one can, legally, distribute it without also giving these freedoms. \begin{array}{|l|l|l|} \hline & Student\ has\ copyright & Student\ does\ not\ have\ copyright \\ \hline Propratory & Student\ can\ use,\ modify,\ distribute. & \\ \hline GPL & Anyone\ can\ use,\ modify,\ distribute. & Anyone\ can\ use,\ modify,\ distribute. \\ \hline Permissive& Anyone\ can\ use,\ modify,\ distribute. & Anyone\ can\ use,\ modify,\ distribute. \\ \hline \end{array} \begin{array}{|l|l|l|} \hline & Student\ has\ copyright & Student\ does\ not\ have\ copyright \\ \hline Propratory & Student\ can\ fork\ and\ change\ licence. & \\ \hline GPL & Student\ can\ fork\ and\ change\ licence. & \\ \hline Permissive& Anyone\ can\ fork\ and\ change\ licence. & Anyone\ can\ fork\ and\ change\ licence. \\ \hline \end{array} 

You could have different implementations of a bit of hardware, e.g. printer. Or a concept such as sorting. sort ⇐ bubble sort, sort ⇐ merge sort, sort ⇐ insertion sort, sort ⇐ quick sort, sort ⇐ a hybrid sort, … A stack implemented with an array and with a linked list. A queue implemented with an array (circular buffer) and with a linked list. 

Now the terminal switches to an editor, when I quit the editor the new definition is invoked, and I return to repl mode. 

When I am teaching, sometimes, I am asked “How is this useful to me? I don't use a computer. I won't use a computer in my job.” How can I, quickly, answer this question? I only have a few pupils with this attitude, so don't want to spend too much time on this. However ideas for a short-ish introduction, or ways to answer the question, will be welcomed. 

With snap you can make it look like any other language. I have made it look like python. Unfortunately I could not get all of the blocks to work, but I did use them to create a printed work sheet scratch to scratchy python to python (they did not know that I used snap to help me create it). You can also teach snap to auto generate code in another language. E.g. write program in snap, click generate, and get a python program (I have not properly tried this). 

I also think that selection is over used, except we need it if we use recursion. And we need it latter to process inputs. Once I realised that any program can be written without mutation, with out selection (except to get out of recursion), and with only two unbounded loops (if you have lambdas and full multiple inheritance), my programs got better. A lot better, nearly bug free. 

I am wondering how much of this is because they can not express in natural language (don't know terminology). How much is because of just fiddle until it works programming. Learning to express in natural language This is important, to allow them to communicate with a larger team, to allow them to look stuff up on an internet search, and to answer some of the exam questions. Programming by fiddling / tinkering This is an important technique to use some of the time. However it should then be followed by evaluation. For example: Trying to find the angle of a triangle, when drawing using turtle graphics. 

They have to take your code and change the 0s to the correct code. Parsons problems Give them all of the correct code, but in the wrong order. They have to rearrange it. Pupils can do a lot of these in a short time. Each one is, supposedly, nearly as powerful as doing a normal programming exercise. However you can do more of them, and there is less frustration. 

A simple hash algorithm is modulo or remainder (they are the same for positive numbers). You only need be able to count. To calculate $n$ modulo $m$, take $m$ empty pots, and $n$ marbles. Place one marble in front of each pot, then put the marbles in the pots, and repeat until you do not have enough marble for each pot, count the marbles that are in-front of the pots (that is the answer). In is not a cryptographic hash, but it is a hash. I doubt that you will be able to do a crypto hash at this age. Another algorithm, would be horizontal and vertical parity. (not very hashy, but related) see CS unplugged. $URL$ and $URL$