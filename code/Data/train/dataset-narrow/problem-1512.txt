From this I would suspect that the running process may eventually block after you have closed the input stream. There are a few options: 

Apart from the less-than-ideal variable and type names already mentioned you are doubling up on code just to check first and then separately doing the same again for every other node. The only difference is that you need to modify head if the element to be removed is the first one. This can be condensed into a single loop: 

Since you also have an class this is a bit distracting. General C# naming convention is to prefix generic type parameters with . So better would be: 

The timing and recording of things should be encapsulated in as a method. Something along these lines: 

It's good to see that you used dedicated lock objects and . A minor improvement would be that those can be marked as . I find the locking and unlocking processes quite hard to follow. It is not easy to see when what gets locked for which purpose due to the combination of using standard locks and the use of state guards. I'm pretty sure that the pool will be left in a bad state should the provided unit factory throw (for example triggered by a triggering an ) due to the pattern (if throws you're in trouble). Probably not extremely likely but a potential issue. 

The idiomatic way of accessing an item in a map and adding it if not present usually goes like this: 

You can reduce some of the indent by checking for the negative condition and bailing out early. E.g.: 

A slightly better way to wait for the queue to be not empty in your method would be to use a instead of an . 

I'm not sure why your change all of a sudden would expose data to the business layer when it didn't before. If you have a pattern of methods which look like this: 

Consider making your plain data classes like , etc. and immutable. Their properties don't change after they have been constructed if I read your code correctly so you might want to reflect this in your design. Immutability makes a lot of things easier. Eric Lippert has written some very interesting blog articles about immutability. At least consider making the properties which don't change either fields or give them a . The method in should probably live as a factory method in instead. The method in should probably live as a factory method in instead. should live in (factory method) should live in (factory method) should live in (factory method) should live as on (non-static) There seems to be a magic loop in your implementations which seems odd. Once you actually remove all those static helper classes from then there is not much left in so ask yourself: What should be the purpose of this class? You repeat a lot of code in , and - especially the last two share a lot. The central point of the calculations seems to be this block: 

I'd prefer 2 or 3 because it enforces the readonly-ness in a much stronger way. Update Number 3 could be simply implemented as 

is never used and can be removed. is not really the best name - would be more appropriate. You should use spaces more consistently. Your indent is off here and there and you often omit a space before the opening brace which doesn't help readability. Also a lot of people prefer 4 spaces indent but YMMV. Use a consistent bracing style. Sometimes you put the opening brace on it's own line and sometimes it's on the previous one and sometimes the entire block is on one line. I'd return a bool from instead of writing directly to - let the caller deal with the output concern (Single Responsibility Principle). in is never used and should be removed. You don't have to explicitly from . 

Before you ask: The code was written in times of .NET 3 and is still required to work in .NET 3.5, so was and is no option. Anyway the code works fine but now looking back in retrospect the design strikes me as a bit non-optimal. So I'm looking for some input regarding design/best practices/style. Base cache class implementation This is the base cache class. The cache entry holds the value to be cached and also some meta data, mainly time of last access and an index reference. The index reference is a node in a linked list. Whenever a cache element is accessed it is being moved to the front of the list. This allows for an easy LRU eviction strategy for a size based cache. The access time can be used by the age based eviction cache. My main quarrel with this is that the base class contains knowledge about both strategies although it does not implement any of the eviction strategies itself. 

You access after calling . Generally you should cleanup resources in the reverse order and since the mutex been created last it should be destroyed first. You don't check the return value of . It would be cleaner to release the allocated memory and simply return and leave the caller to deal with it. The header file is basically the public interface to your implementation. Internal details like have no business of being there. In the end most variables or field are or or whatever other primitive type is available - what distinguishes them is the semantics the programmer gives them. In languages like C the only real way to convey that semantics to the reader is the name you give fields and variables. This makes the code easier to read and maintain and understandable by others. Short-cut names like or are fairly useless since they simply fail to convey the purpose properly. Using descriptive names is more important than saving a few keystrokes. This code: 

should be equivalent to Your loop is one based for some reason but inside the loop you have to subtract 1 from everywhere. You should just make your loop 0 based which would de-clutter the loop a bit. I would find just as descriptive a name as . You could get rid of the by calculating the position: 

The constructor silently discards items where the parent can't be found. This is usually a bad idea since it means the caller has no real idea why items are missing and why the created tree is incomplete (from the callers point of view) - debugging ensues and wastes some time. If you throw an instead stating the the parent can't be found - it's immediately clear what's wrong. This is probably a bug: If you call on an empty tree passing in an item with then you will get the current tree as the parent even though the tree contains no items at all (the first two blocks should probably be swapped around). In the the local variable is called even through you're looking for the parent. In generally if I call a data structure to remove an item the I do expect the data structure to be modified (i.e. the item removed) if the call is valid but not the item to be changed. changes the passed in item which violates that expectation which is probably not a good thing. The code in the methods will throw a when being passed in an invalid item since may return . It would be better to detect this and ignore the call (the general expectation usually is that just does nothing if being called with an item which is not in the structure). Documentation for the public interface of the class is missing (see point 2 above plus your comment - documentation would have made clear what the exact purpose of the method was) 

One other gripe I have with the code is the static member of . Maybe I'm missing something but I think this can get you into trouble. Assume you have two databases you want to talk to and you fire off to calls to - now the member is set to whatever instance where the calls happened to be executed last which will probably cause funny results as might now wait on the wrong database instance for one of the calls and/or in the lock will be released against the wrong instance. While this might be a rare use case I don't see the benefit of making this a static member in the first place - it's only accessed locally in either the task trying to acquire the lock or in the method. For the case a non-static member would work fine. For the locking task the instance can be captured locally in the closure as it's passed in. So it should be easy enough to remove the problematic hidden gotcha. 

Please give your local variables some more meaningful names. Reading all this , , , , etc. just hurts the eye. Intellisense and auto completions have been invented a long time ago, no need to try and save characters for sake of typing. Using names like , , etc. would make the code much easier to read. 

should be generic as well. Seems odd that the serialization method works on while the deserialization method is generic. I'd consider adding methods which de/serialize from/to streams. While you have effectively applied YAGNI, writing/reading to/from stream is something I encounter quite often once the projects grow beyond basic experimentation. 

makes things very hard to read and is scattered around in various places. Create a class, define the interface to it in terms of how the Interpreter should interact with it on the most basic level. This should clean up some code. I'm not 100% sure what exactly the purpose of the methods is and how they are related to the methods and how it is all related to . So at the first glance it seems your has at least two responsibilities: Turn the AST nodes into nodes and execute the nodes. This is at least one responsibility too much and turning the AST nodes into nodes should probably be extracted. Also reading a lot of code like seems like a step backwards in the age of OOP. 

One thing I noticed is that you have a fair amount of code duplication. It's something I try to avoid because it means if you find a problem in a piece of code which is duplicated then you have to go and them all and fix them. If you just have one place where you perform a certain operation then there is only one place to fix/extend. Some examples: 

Have a method which creates the list (and initializes the object). should also delete the list object (probably needs signature change to ) Add a method which just clears the contents of the list. 

returns a . You probably want to wait until the tasks you have started are finished before you quit from main which you can do with . Something along these lines: 

It's ok to use a local variable to store the value of some lengthy de-referencing sequence if it's used more than once in the scope. Although something like would be a bit of a code smell indicating that your abstractions are not quite right. Glancing over the code it seems ok. But if you want to be sure: Write unit tests and use a tool like valgrind to check for memory leaks. Some unit test frameworks like Cpputest have build-in memory checking which can be handy. See below. 

However the predicate is at that point and evaluates to . Hence the condition has no effect on the result and the block can be simplified into: 

You have probably taken the name from the C function but is actually not really a good name. or similar might be better. You could write it as an extensions method to which would result in a nicer calling syntax. It would look like this then: 

For it is not entirely clear if for example the end index is included or not for the removal. C# usually follows the convention of specify the start index and the count of how many elements should be removed (i.e. ). I found that approach more robust in the long run. I don't think dumping the entire list content in is all that useful, especially if the list can grow larger it could be problematic. 

Same holds for cloning the parameter. Your implementation of is re-inventing the wheel. See . Your parse the line over and over again to extract a specific filed from it. Instead you should break the line up into the individual fields once and return the array of fields. You can then read the field you want from the array.