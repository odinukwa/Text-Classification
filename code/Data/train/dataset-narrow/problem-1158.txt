Why have both? You can get the stated meaning for with . Why keep an extra variable that does the same thing? Also, a leaf is normally a node with no children. A trie node can terminate a word and still have children. 

Note how adding the function saves the extra in that you used. Note how I get the string sizes first and store them in variables. This avoids the overhead of function calls. Your version had at least two function calls per iteration. Mine only has one, and that one allows for simpler code (that avoids two more function calls). I also avoid doing a subtraction for every iteration. On the bright side, in your version the function calls probably get optimized out. Mine won't be because I use a loop in that function. C You use the C . If you wanted to use the C string functions as well, you could say: 

This saves calling on each iteration of the loop, plus it eliminates the calls. The whole TrieNode.java using a rather than an : 

Are you sure that these should be functions? If you are naming a bunch of nouns, maybe these should be classes, each of which could have its own or method. This is even true of 

Note that both of these are limited to squares at or below the top row with a filled square. So you don't have to fully check every row. Assuming rows are numbered from top to bottom rather than bottom to top: 

Note that calling setCalibratedValues with both 762 and 763 will give each the same Calibrated object. If that's not what you want, you could give Calibrated a copy constructor and make a new one each time. Also note that this method requires creating all the calibrations at the beginning. This can be wasteful if you only use one per program invocation. Not so bad now, but what if you get more calibration sets? It would be possible to put the rules into a file or files and then read them into the objects. That would eliminate most of the constants. You'd have to make sure that you read the file by the first time that you needed the values. Perhaps put them into a Singleton object? At worst case then, the Singleton constructor could read the file the first time that it was needed. Or you could prime it earlier. Some things that I don't like about setCalibratedValues that you didn't mention: 

Also, newer versions of Java do not require you to specify the type in the on the right side. The compiler is smart enough to figure it out. I would also have made a class variable. In fact, it might make sense to have a class that is separate from the Euler project altogether. That would allow you to create a more general implementation that you can reuse for other problems. This would also simplify which has more of the programming logic than necessary. 

It seems like you should be able to do a bit better here. There's a lot of list creation and copying, which seems unnecessary. 

The type is what is used in library functions dealing with sizes. Using it here means that if you add an additional sort that does a , that you will be using the right type. I also changed the name of the variable. One, because I prefer the name for something that represents the number of elements in a collection. Two, because words should be separated by something. In C, the standard is to use underscores. In other languages, they often use casing to indicate where new words begin (I disagree with that actually, but at least it is common). It's much easier to read if you use something to say where new words begin. Otherwise, the reader has to think about it when we want the reader's attention on what the code is doing. Similarly, I added spaces around the . This makes it easier to see where one token ends and another begins. I didn't change it here, but I would prefer a name like or instead of . I can easily see the type of the variable. What I want to know is what it represents. Thus, or would best tell me what I wouldn't otherwise know from the declaration. 

As a general rule, you don't want to do processing in your constructor. You don't show your function, so I don't know what should change there. It could be as simple as calling right after calling the constructor. Note: this is a very common thing to try when first encountering objected-oriented principles. It's just that doing this makes it harder to reuse the code in different ways. For example, you might have reasons to do something else before running the search. As a general rule, constructors should just allocate and initialize variables. They should not attempt to read input or process things. 

While I understand that it can often be helpful to define a global variable to do some quick and dirty debugging, by the time that you are sending code out for code review, this should be gone. You should be done debugging your code, so you can leave just the actual code. What I would actually like to see here are the results. Given a particular input, what is the output? 

Why isn't this sufficient? If we found the target node, return it as part of the path. By the way, I changed "out" to "our" in the comment. I think that's what was meant there. Note that you'd need to change the method to return rather than void. 

As a general rule, you shouldn't unless you know that you will always want every column in the row. In this case, you only want , so . You currently return the last row with that ID even though you fetch all of them. I'm guessing that is unique -- only one entry with a particular value in the table. If so or if you're just happy with returning the first value found rather than the last, it's more direct to say 

It seems like this code has a bug where it doesn't output the first character after a number. And it may not check for the terminating immediately after a number. I haven't tried to fix this. 

I changed to , as that seems to better describe it. SQL is what I'd call the input to , not the output. The function returns a resource handle representing the statement that SQL will create. I also changed to , as that better reflects what it holds. I removed the variable and took the out of the block. This way it returns a consistent value when it does not fetch the title successfully. 

Rather than a , consider using a instead. is designed for appending. Regular values are not. Using on a implicitly creates a new every time. If you're lucky, the compiler might rewrite your version to use instead. 

I also switched to using a named element instead of letting it default to . Alternately, you could pass nothing into the function and use in the as you did. That would work but isn't a best practice. You may not have realized but the was a regular expression with single quotes as the delimiters. I prefer to use curly brackets for regular expressions. If you wanted to be really plain about it, you could have said . 

That way you don't have to choose between errors if you don't want to do so. You have the option of returning any or all the errors at once. I also removed the extra line breaks. There's no reason to separate these defines. They go together, so you can just put them next to each other. Putting them on separate lines is like breaking a paragraph into one paragraph for each line. Doesn't this seem like overkill? Also, it's not clear what goes together and what does not. You separate by the same amount between things in a group as you do for things not in a group. In http.cpp, you shouldn't have to include all those prototypes. Just define the functions in the order in which they're used unless you have two functions that call each other. Obviously in that case, at least one will need to be prototyped. However, I don't see that in any of your functions. In , I have the same problem with spacing. Everything is separate, so I can't see what goes with what. I might reorganize it as follows: 

We could even reduce this further, as we only need to check or , but adding costs us nothing and saves us a function call if it equals . The only reason we need it at all is that is an unsigned type, so subtracting from zero will have odd results. This also avoids the oddity of passing a perfectly valid to the function only to be told that something is "out of range". 

This looks suspicious to me. Is the post title really a person's name? If so, you should comment and explain why this would be true. Otherwise, someone will later create a bunch of posts whose titles aren't people and wonder why posts are showing up under a list of people. Alternately, if post titles are not names of people, then this type is misnamed. You also might want to consider extending your class rather than using a in . Then you could have a class and a class, and each could define its own . 

The class is reasonably safe, although I am more accustomed to seeing the user ID saved than the user name. There could be issues elsewhere. For example, is the cookie info only passed via HTTPS? How secure is the session? 

As a general rule, you don't want to do your database connection in your constructor. You should be able to create an instance without having it connected to a database. What you might consider doing is creating a that runs the constructor and initializes it, returning the result. You should pass $_CONFIG into this function and . That way you can connect to more than one database at once. Your version is almost a Singleton but not quite. I don't see the point in things like 

I changed to the more standard which does the same thing. I also optimized your so that it won't call unnecessarily. And changed it so that it uses the shorter object-oriented notation. This hits the database every .2 seconds for almost twenty seconds. Are you really in that much of a hurry? Also, be careful of timeouts. If your HTTP connection times out after five seconds, there's not much point in continuing to poll the database. Note that if you have a lot of people chatting but no one saying anything, there will be a bunch of people doing this at once. You may want to look into solutions that allow for sharing these results among multiple HTTP connections. For example, something that caches the last two message times and returns a cached result for times between them (older results would be returned from the database). APC would work for a single server or a shared memcache for multiple servers.