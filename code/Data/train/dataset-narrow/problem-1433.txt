C++ Vs C As has been said in the comments, your code reads very much like it's been written in C. You're using C functions like instead of the more C++ and you haven't broken your logic down into classes etc. Commented out Code Commented out code creates noise that distracts from the rest of the code. If you want to have conditional compilation, it's better to build it in to your process. So, instead of: 

This isn't really aimed at the core of your code and is more a reflection of the code challenge you're solving. isn't a great name for the exception being represented. It doesn't tell the caller that the name was too short (the exception could be used to represent a length that was too long). The exception as you've implemented it has no why, so the exception itself doesn't contain sufficient information to tell the caller that it was too short / too long. With that in mind, I would have been tempted to actually implement a and then create so that the supplied code still worked: 

I'd also consider moving the warning to before the question. Telling me there may be a seg fault after I've already selected that route seems like a waste of time. I'd prefer to have that information prompted before I select Y/N (or given the question have it assume that I already know that information). 

You're creating a buffer of 250 bytes and then initialising 256 bytes which will overflow into whatever is next in memory. You also seem to be making things unnecessarily complicated. 

This might be ok if was sorted, however this doesn't appear to be the case. The assumption that you can add 10 if the rolling value is <= 11 is incorrect because it means that the order you draw the ace is important. If you get (A, 7, 7), then I don't want the ace to be worth 11, I want it to be worth 1, which is what it would have calculated if I had got (7,7,A). This can be demonstrated if I force cards to be drawn: 

I'm sure this is subjective, but the way you're constructing your snake seems a bit circular to me. You essentially have: 

This might be ok if is expecting , however I tend to think of positions as . Either way, using and as the variable names for the loops would have made it easier to have confidence that the code was correct. Your method seems to confirm that there is an issue, since it updates the cell: 

No Updates? The main thing that stands out about your current code is that none of your class members can be set after the class has been constructed. This probably makes sense for the , however for and are probably going to need to change during the course of the game. You'll need to consider if you want to go down the simple property style: 

casting and malloc Unnecessary casting is generally frowned upon. returns a , so you don't need to cast it when you're assigned it. 

First, notice that the Category attribute can be used at a class level and applies to all tests within the class. Secondly, notice that because I'm supplying the input and expected values to the test, the test itself becomes a one-liner, which is the common method call. Test Naming This may be somewhat subjective, but I don't find your test names particularly intuitive. It's not obvious to me from the name what tests. It turns out it's testing that when 1 is subtracted from 2, it results in 1. So your naming convention seems to be something like: 

The version without comments looks fine to me. What I would say is that unless you're working in a very constrained system, or have significant memory requirements this: 

One of the benefits of circular buffers is that they can be filled up to the entire size of the buffer, with completed fields being extracted from the head of the buffer immediately freeing up space. This isn't the case for your buffer. Space in the buffer is never freed until the entire buffer has been read, so if partial fields are consistently read there is a risk the buffer will get to a full state. dataTail You've declared your other access methods, including as . Is it a mistake to not declare as const? It's not entirely clear to me why a client would need to have a pointer to the bit of the buffer you haven't used. Or are you expecting the client to actually write to the , without amending the afterwards?!? push Your extended seems like it has a bug (or allows a very strange use case): 

Not only will this collect related data in one spot, it will make it easier to keep track of that information across method/class boundaries. At the moment, you get the players name in your , say hi and then forget about it. Creating a Player and passing it to your method would allow the name to be used in future interactions. Unused Arguments Your method takes an parameter, which you're not currently using. In fact you're passing as the parameter when calling it from . When you're writing fresh code, it's tempting to introduce concepts because you might need them in the future. Usually it's a bad idea. It is more productive to try to only introduce code as and when required. If you stop using code / parameters remove it straight away. This helps to minimise the complexity of your application. If you're worried about losing work / getting yourself into a state that you can't undo then consider using a source control system. Something like git allows you to commit regularly and rollback to previous versions if required. Variable Naming As you get more code, naming becomes increasingly important. If methods, classes and variables are well named they help the code to tell a story that describes what it's doing. This reduces the need for comments and makes your code much more approachable. Consider this line: 

Enum Values Again, somewhat subjective, but I'd be tempted to assign values to your operator enum like: 

seeds the random number generator using the current time. In a lot of cases this is what you want. However when you're comparing the performance of the two queues you want pseudo random numbers, but you don't want them to be different every time. That way you know you're comparing like with like. You don't want to end up testing your queue with a maximum length of 100 and the stl queue with a maximum length of 10000. 

You'll notice that I've contracted the case statements for each word into a single method , which I pass the word into. That's because there is a lot of duplication between the different case statements that you should be able to remove. You can use to get the length of the word to guess for example, rather than hard coding the value (4/5). Rather than hard coding the letters for the word to guess you can use . etc. Nesting Too many nesting levels are bad. They make the code wander across the page to the right until it falls off the edge of your screen. You can avoid excessive nesting by breaking your code into appropriate methods. You can also avoid using it when it isn't necessary. For example, at the start of your program you do: 

This comment is after you have called and assigned it to , so from the comment I would assume that you've established a connection to the remote server and started processing. In the context of the subsequent calls however this seems unlikely. It seems more likely that the connection is actually established when you call , after you've setup the URL, Agent and Read callbacks. Try to make your code as self-documenting as possible (through constants, functions, variable names) and use comments to supplement this only if there's actually something to add. 

My reading of the specification suggested that by supplying a delimiter list it should replace the existing default list. Your interpretation seems to be that it is additive, so the default delimiters are used as well as those supplied. I think this is ok, however I'd prefer to see a test that explicitly indicates that this is required behaviour, rather than just having it in a test case along with the other delimiter tests: 

In your small program, this will be cleaned up when the program exits, however you still want to get into the habit of freeing memory that you're allocating. If you were to reuse the sanitize method in a longer lasting program you may well end up crashing the program with an out of memory error. One way to do this would be to free the memory from your main method: 

Wrapping the calls in a method like might make it more obvious. There would also be scope for re-usability for some of the methods, between your applications (your previous post has very similar curl connection setup). Error Handling On some errors you exit the program (failed to parse JSON), however on others you don't . I would assume if curl returns an error for the call you will probably fail to parse the JSON so might as well abort early. Constants Consider using constants for your magic strings. Whilst it's obvious that the argument to this call is the targetURL: 

A couple of things stand out. init Since doesn't take a parameter my assumption would have been that it would take care of initializing the global list. It doesn't, this has to be done first and init doesn't perform any checking to make sure that the global has been initialized / that init hasn't previously been called. clear You clear the list by repeatedly calling . This means that you have to traverse the entire list, remove the last item and then repeat for each item in the list. It would be more efficient to remove from the head. With your existing interface, it looks like you could just call . 

Header file includes I know this is subjective, but as a general rule, I don't include headers from other headers (there are some exceptions when advertising a library / using a precompiled header). I then add includes to source files in a particular order, from most general (standard library headers) to most specific (project specific headers). There is a maintenance overhead with this approach (if you introduce a dependency you have to update every source file that includes the header), however I've found that it pays for itself with other benefits, including helping to pinpoint naming conflicts to the most specific file. On large projects it can also make a significant difference to compilation times. You mostly include your local headers first, however this isn't always the case (telephone_book_utils.h). I'd say consistency is key... Consistent return values I'd consider defining some constants for your return values (particularly your error conditions). This will encourage consistency across your API and will make the code that little bit easier to read. For example and some other methods return 1 for errors, whereas (which doesn't have its error return code documented in the function comment) returns -1. They could probably all be returning -1. 

_pin overflow You're relying on the caller to prevent a buffer overflow. Consider if the calling code was this: 

The overwhelming first impression I get from your code is that without the text description above, I wouldn't have a clue what it is you're trying to do. A lot of these types of problems have some kind of prompting which helps, however your code doesn't have that, its only output is after it's finished. The two main improvements I'd suggest are: 

You're not making the most out of your regex's. Regex's are good at checking for pattern matches, but they also have support for capturing elements of the expression. If you use the regex's fully, I believe it will simplify your code significantly. Consider this expression: 

What should ZERO be used for? You're using it as a direct replacement for 0 in your code, but not always: 

You do the computation, however you don't reset the machine ready for the next customer. It seems like this should be zero'ing out the currentPurchase, items, purchase (and possibly adding it to a totalPurchases etc variables). Since it doesn't reset, you're currently having to create a new CashRegister for each transaction. 

I haven't tested it, and it has been a while since I did script programming, but it looks to me like your algorithm breaks down if the oldest file in either folder is being used at the same time that you breach the usage threshold. It can't delete the oldest file, so it just keeps trying over and over again without succeeding or sleeping. Rather than having a loop that keeps trying to remove the last file when the threshold is breached it might be better to calculate the amount of files that need to be removed in order to come back under the threshold and try to remove several files in one go / or to skip files if they are in use and move on to the next file rather than stopping and trying the same file again next time. It may also be worthwhile extending the cleanup to clear a bit more than you need, so that you don't immediately trigger another cleanup next time you go through the loop. So, for example if you breach 70% usage, clear down the files to 65% or 60% so that there is some growth space. Your script also has some declared an unused variable, which you should probably either be using (or remove):