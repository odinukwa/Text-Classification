In a typical shaders, no mater if it's a vertex or fragment one, you have somewhere a dot product between light direction and surface normal. Then you have a check if the result is less than , which means your surface has light at its 'back'. Now, if you compute instead of just you should get lighting on both sides of your geometry. 

When you're rotating your phone and not moving it then the acceleration returned will lie on a sphere with Earth G radius. For example let's say your phone lies almost flat on the table - your acceleration X and Y values will be small and your method should work, but when you turn your phone 90 deg your acceleration X or Y will get its maximum value and your method will break. In practice, for rotations just around 15-30 deg you should start noticing some strange effects, like non-symmetrical steering in front-back directions. To solve it you could store entire initial rotation, computed from initial acceleration vector and during the game compute actual rotation and a X/Y differences between them. 

It's not a full answer, but it's too long for a comment... From your question I presume you want to use a LOD system (geomipmap approach) and you're creating your mesh by cube subdivision, so why not to think about a LOD during both stages - mesh creation and rendering? You start from just a 6 planes, so it's really easy to tell which sides are connected. Then, when you subdivide one of the planes you know which neighbors are at the all 4 edges. You can also store the newly created, internal edges. This way you can create a hierarchical, tree-like data, where you start from 6 quads and every quad have 4 child quads. Having such data you can easily iterate over all LOD levels. You can even store the mesh data precomputed for all LOD levels, or you can create them on the fly, depending on camera move. There are really many possibilities here, but I can't help you more as I don't know what data are you going to need for your algorithm to work. 

How about another approach: Assign an area of influence to objects based on their mass--they're simply too small to have a measurable effect beyond that range. Now divide your world up into a grid and put each object in a list of all the cells it has an influence on. Do your gravity calculations only on objects in the list attached to the cell an object is in. You only have to update the lists when an object moves into a new grid cell. The smaller the grid cells the less calculation you'll do per update but the more work you'll do updating lists. 

I think the real problem here is the PipeSegment having any vertices at all. Rather the PipeSegment should have two Ring objects that are a collection of points around the pipe and are shared between adjacent PipeSegments. The rings would come in two flavors to offset the points. 

Packet delivery times won't be consistent, you can't count on them. Thus any approach that uses them in the calculation is going to produce bad answers. 

A good reason for having the fireballs in a list of projectiles rather than owned by the wizard is what happens when the wizard dies? Do you want his fireballs in flight to suddenly vanish? 

As has been said you should aim the missile for where the target is expected to be when you get there rather than for where the target is right now. This will stop MOST missiles from going into orbit but an orbit is still possible if the target evades just right. This is a legitimate tactic used by aircraft pilots to dodge incoming missiles--since the missile is going much faster than you it will have a larger turning radius and a sharp jink at the right instant causes it to go on by. (Although you could still be at risk from a proximity detonation.) Since we are dealing with a missile that can still track and still has thrust you get an orbit situation if the target evades into one of the zones that FxIII's post talks about. However, I disagree with his solution to the problem. Instead, I would program the missiles thusly: if the missile has been thrusting at 90 degrees to it's line of motion for 360 degrees of movement you are in orbit. Adjust the thrust to 120 degrees from the line of motion. The missile's orbit will widen as it's not turning as hard but the missile will also slow, thus allowing it to maneuver better. When the range to target opens to 1.25x the diameter of the dead zone (note that this diameter is based simply and only on the missile's speed, no complex calculation is required at runtime) the missile returns to it's normal tracking behavior. Alternately, use dumber seeker heads--when the range to target ceases to count down you detonate. 

What I think you need is to create a object that will allow you to set up players position and orientation. Next, connect a object as a child of so it moves and rotates with your main object. Then connect a as the child of so it moves with , but can rotate in its own local space, so you can rotate a head. At the end connect a as a child of the and move it backward by some amount. This way a will be always at some distance from the , looking at it, regardless of the orientation. 

I'd consider a grid as a "base" type of tiles in any game. Such grid is simple to imagine and moves over this grid are simple to understand. It's also very simple to implement "under the hood". Those are few reasons why even the Chess game uses it :). Additionally, this grid helps you make "regular" levels, because and are natural directions here. So if you make, let's say a SimCity clone it's very easy to have perpendicular roads. The biggest disadvantage of grids is that they doesn't keep distances very well, because when you move by one tile in directions you basically move by one tile size, but when you move in directions like then you'll move by . It's not so big problem in computer games but it was a big flaw in board games. Because of this problem people tried to find some other way to divide 2D space, so the movements between tiles would be more similar to the real movement. It happens that the only possible way, better than squares is to use . grids are much better for strategy-like games because movements are more natural, but they are much harder to implement. They have also 3 main directions, where one of them may be OR but not both! So try to imagine a city with perpendicular roads built on a such grid... Personally, for a game like I wouldn't think much and used . In fact, I'd use squares in every game that is not a turn-based tactical game. But depending on your taste you need to choose your own. Maybe you'll want to make a one-of-its-kind, clone :) ? 

The problem here is you are trying to key the item on the name "Ring of Power" and thus running into a conflict. Instead, use a hidden key for the item, multiple items display as "Ring of Power". 

If the terrain is fixed you can do some precalculations to cut down on the problem size. For example, for each sector (pick reasonable sizes to work with) you can define a guaranteed-clear altitude. Each object also has a maximum object height variable. If the object position - object height is greater than the known safe altitude then no further checks need to be done. This won't do anything about your worst time but if you have a lot of moving objects that are mostly clear of the terrain then it will do a lot for your average time. 

It looks like the problem is that the missile is simply pointing itself at the target without regard for it's current velocity. Assign your missile a maximum angle by which the thrust can deviate from the line of motion. At each guidance iteration you calculate it's velocity perpendicular to the target. Figure out how much it must tip it's engine in order to zero out this component of it's velocity and then clip this to the maximum that it can tip it's engine. During the first part of it's flight it's going to move somewhat to the right of the straight line in figure #2 but as it flies the engine will zero out this component and it will end up heading straight for the target. Note that in this scenario there will be only one frame in which the engine has a deflection of anything other than zero or max. If you were tracking a moving target you could get lesser deflections on every cycle as the target moved.