It looks to me like it is thread-safe. But don't take my word for it; you better consider each answer as a vote, and go with what the majority says. (Multi-threading is tricky!) Note: comments should not be considered as answers. 

Passing an int with the keyword does not involve any boxing at all. Do not confuse this with "passing an int by reference" (as in, a function with return type returning an ,) which is quite a different thing, and it does involve boxing. Your code seems quite efficient to me, I have nothing to comment on. 

My advice would be to abandon the idea of treating the file as a text file in order to search through it, but then as a binary file in order to write into it. Your calculation of the offset to seek to is flimsy, and guaranteed not to work if the file has non-single-character end-of-line markers, (LF in Unix, but CR+LF in Windows,) if it starts with a unicode BOM, or if it contains any UTF8-encoded characters. You need to either treat the file as a binary file all the way, in which case you will have to write your own code to read chunks and search through them, or to treat it as a text file all the way, meaning that every time you will be creating a new file and then swapping it with the original. 

You are using , so most of your code gets compiled into the same machine code regardless of the bitness of the target. Also, A^A = 0, so the compiler might be optimizing your entire for loop with a single call to with zero. I would recommend that you move different values around instead of xoring the same values together, and I would recommend that you use int32_t for the 32-bit version, and int64_t for the 64-bit version. 

Make your method return an , not a , as the built-in binary search methods do. Make an additional overload that works with instead of . Make an additional overload that works with neither nor , but instead it assumes that implements . Keep the part, it is supposed to avoid arithmetic overflow if by any chance you are sorting an array with an incredibly large number of elements. (Not very important, but it demonstrates attention to detail.) Code the method as follows: ;-) 

In the SetFileText/GetFileText functions, is not symmetrical to . Consider either using , (the preferred solution,) or using and also asserting that the text to be written does not already contain any s, because if it does, then will not return the same string that was given on . The functions and expose implementation details of the class. These implementation details should not have to be exposed for a class which simply acts as a repository for a single string. It should be possible to rewrite the class to read/write the string from the Windows Registry, or from application.config, without having to change the interface of the class. So, replace those methods with some method which abstracts their usage. And, by the way, why are you doing all this instead of just using the Windows Registry or application.config ? 

The solutions proposed by Jeff and w0lf are very fine, but have you considered simply rearranging your code a little bit? Because even though the following does O(M*N), your question was about readability, not performance, and I think that people unfamiliar with linq will find this more graspable: 

Looks fine to me. The only thing I have to notice is that should instead be . The reason for this is that if you were using bit #31 (the 32nd bit) then the expression would yield a negative number, so it would not pass the test for . 

One more note: I see that when your colleague declared the email address variable he assigned to it, and then further down he re-assigned a meaningful value to it prior to using it. Some people believe that when declaring a local variable you should always initialize it with some initial value, and they follow this rule in an almost superstitious fashion. This is wrong. It may have been advisable back in the times when all we had was some primitive and crude C compilers, but not anymore. Modern compilers of C, C++, C# and Java are quite good at warning you if a variable might be read before it has been initialized. So, by pre-initializing the variable at declaration time with a value which is by definition meaningless, (since a meaningful value is not yet known at that time,) you are circumventing the safety checks of your compiler, and you are actually opening up the possibility of error: if you forget to assign a proper value to your variable further down before you actually make use of it, the compiler will not warn you, because as far as the compiler knows, the variable has already been initialized at declaration time. Furthermore, even if the compiler was incapable of warning about uninitialized values, you would still have to wonder which outcome is better for a program with an uninitialized variable bug: to fail with a null pointer exception the first time it is used, or to appear to work but never send any messages to anyone. In any case, you should not really have to worry about the above note, because if you follow the rule which says that the scope of local variables should always be as minimal as possible, you will always be initializing your local variables with meaningful values precisely at the moment that you are declaring them. 

Fancy is not the word for it. This is insane. Ever heard of the KISS principle? Keep-it-simple-stupid. Unless of course you are intentionally looking for ways to make your code look obfuscated, and your executable file bloated. 

Jesse's answer is good. My personal preference would be to put it inside . I would do this because this code does not have any state, and since it has no state, it does not deserve to be a class. (The only state it has is trying to make sure it does not get invoked twice, so that does not count.) 

It is kind of hard to tell by looking at your code, (you have not shown us the definition of , and you appear to be doing some stuff which appears to have no purpose in the sample code you provided,) but it appears to me that your approach of removing the last item from the list is not inefficient. Do you have any reasons to believe that it could be made any more efficient? 

This is probably (I repeat: probably) going to be unacceptably slow for users who type fast, but then again it will probably perform much better than you might expect. Try adding some fake data to your database to test the performance of the scheme before optimizing anything. If it turns out that there is a performance problem, try opening the connection when 'DeleteEntryWindow' opens, and closing it when it closes. Make sure that an index has been defined in the database for DataID. If there is still a performance problem, then move the checking code to a separate thread. Do NOT do gimmicks like caching the IDs in an array, you will regret it later. 

If a question of this sort pops up in a job interview, it may be a trick question, and you might actually be expected to demonstrate that you are conscious about not re-inventing the wheel. A big part of the value of .Net is that it is a very rich environment which provides programmers with lots of things already built-in and ready to use, (not to mention tested, debugged, and known to work problem-free,) so an essential skill for a .Net programmer is to know what is already there so that they do not waste time re-implementing it and debugging it. If you can rule out the scenario of the trick question, then here is what I'd say: 

The scope of local variables should always be as minimal as possible. So, I would declare the variable precisely there where it is used even if I have to re-declare it in multiple places within the same method. As a matter of fact, I would declare it precisely where it is used even if there was no condition. Many people do not know it, but you can start a new scope with curly brackets anywhere you want within a method, even if you do not have a control statement to put it under. For example: 

In the case of string parameters it gets more complicated, because you need to ensure that the string does not contain any characters below , that any single quotes within the string are properly escaped by performing , and that any other characters that may have a special meaning under the RDBMS you are using are stripped away. 

My recommendation would be to first make one pass through your cells and populate a dictionary in which the key is the name and the value is the cell itself. Then make a single pass through the checkboxes, and for each checkbox use its name to lookup the cell in the dictionary and there you have it. 

is cute, but it makes one pause for a moment and think whether it is correct or not before moving on. It is better rewritten as . Your arraylist is allocated once and never changed, (its contents are ganged, but not the object itself,) so it should be declared as . Right before you start using it, since you know how many items are going to go into it, do so as to help it to avoid resizing itself as it is discovering its capacity by itself. Use better names; should be or perhaps just . In : Get rid of the and variables and simply use and instead. Declare inside the loop, not outside it: Rename to , or , or just . In : Again, declare inside the loop, not outside it. Declare inside the loop, too, and do not initialize it to null. It is bad practice to initialize things when there is no need. It prevents the compiler from giving you useful warnings. When you do this, the compiler will give you a warning that you may be trying to use before you have assigned a value to it. That's because your if statement checks for , and then for , but there is no clause to handle any other possibility. So, add an clause and throw an exception: Get rid of these: they are not used. Actually, the fact that you have these in your code, and you have not seen a compiler warning about them not being used, tells me that you are not compiling with all warnings enabled. Do yourself a favor and enable all warnings so as to have the compiler help you. That's his job. Replace this: 

Leaving aside philosophical issues like why do you bother with a language which today is only used for programming micro-controllers the size of a contact lens, and why would you ruin a something written in C++ by converting it to C, I must say that it is a well written piece of code, authored by someone who has a good understanding of what he is doing. (Then again, of course, you really cannot accomplish anything in C unless you have a good understanding of what you are doing.) Notwithstanding that, there are a few issues. 

I would not waste any time at all worrying about factoring away one of the two comparisons, because a good compiler should be able to optimize them into one anyway. (Maybe during Kernighan and Ritchie's time compilers were not smart enough to pull such tricks, so maybe this question was meaningful back then, but believe me, they have gone a very long way since then!) The compiler knows that and (or the result of calling the comparison function) are not changed by the statement, so it can emit the code which compares these two operands only once. The results of the comparison will be stored in the (C) and (Z) bits of the register of an x86 CPU, as follows: If Z is set, it means that the two operands of the comparison were equal; otherwise, if C is set, then the second operand was greater than the first; otherwise, (both flags are clear,) the second operand was smaller than the first. So, if the compiler is smart at all, after the comparison instruction it will emit two consecutive conditional jump instructions: one which will branch to the part if the result of the comparison was 'greater than', (Z=0, C=0,) immediately followed by another which will branch to the part if the result of the comparison was 'less than'. (Z=0, C=1.) A jump instruction never modifies the register of the CPU, so after the first jump instruction has examined the flags, and decided not to branch, the flags will still be intact for the second jump instruction to also examine them. And if the second jump instruction decides not to branch either, then the CPU will fall through to the code which will handle the last remaining case, where the operands were equal. I would be willing to bet money that a decent C compiler will do this for you. Even if it turns out that it does not, the whole topic can nonetheless be dismissed as belonging to the general class of problems that compilers should be taking care of for us, so that we can spend our time thinking about more useful things.