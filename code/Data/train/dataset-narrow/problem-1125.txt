With this function, will always be at least 2 characters long. Now before updating the charts, check to see what are current value is. If it's the same as the new value (which will be typical for minutes, hours, days), then there is no reason to update them (or there text for that matter). Adding a element with jQuery is a great way to keep track of this. 

Also since we don't care about the order in which this is done, we can use a loop. It is typically the fastest ways to loop in JavaScript. 

First we encapsulate the code in an IIFE, then on , we get are selections and add our event. Now, if you can't change the HTML, you can still use this code with some slight modification: 

Then when you are ready to show the content, you can just do to show the area when the is clicked. FYI: I changed to a simple class in the examples. Here is the adjusted code: 

Notice how that is pretty much the same thing repeated over and over? That means it needs to be it's own function: 

Next, you have each droppable in its own call. That is unnecessary. You only need one call. We will add that in at the end of the code. Since most of your code is actually in the event handler and it is almost entirely the same for each instance, we can DRY out your code. Just pass in a string that contains the one difference between each function and cache some of the variables. 

The first thing you should do is encapsulate your code inside of an IIFE. This will create a private scope and help prevent pollution of the global namespace. Since you are using jQuery, you can pass it to the IIFE to make sure your reference to is always . 

What this code does is move the charts onto there own rendering layer. This prevents the browser from having to check the surrounding areas because each chart is now separated from the rest of the content. In Chrome, you can see the performance difference this makes by watching the Timeline in the Dev tools. In the original, it spends ~180 ms repainting the screen and ~100 ms performing calculations. In the updated version, it spends ~20 ms for each. Add this over four graphs and you can see why the cpu is pegged. The is a new CSS property that will basically do the same thing as the two lines above in the somewhat-near-future. I have updated the fiddle with just this change and you can see the difference. Now, the code review: As always, the first thing I recommend is to remove your code from the global scope. The easiest way to do this is to use an IIFE. This will basically create a private scope for all your code which reduces the amount of code you place in the global scope, which in turn, reduces the chance of collisions with other peoples code. Since you are using jQuery, this also provides a way to make sure always points to it. 

One quick item that no one else seems to have mentioned is the use of an IIFE. I always recommend this. It basically creates a private scope for your code and prevents your code from polluting the global scope (which is a very bad thing). The more code you have in the global scope the more chance of your code conflicting with someone else's code. Here is how to do it: 

You don't need to specify and . By having all three, you are making the code get evaluated three times per key event. 7) As stated previously, naming your variables a little more descriptively will help you and any other developer later on. when you have to come back to this code in six months or a year, it will be much easier to figure out. Congratulations on learning to code! 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

Something to remember about the Java libraries (especially older ones) is that they were written when Java was a new language. Some of the techniques and patterns we use as standard now were not available and the compilers, optimizers etc were a lot less smart. A lot of things we can just ignore now and let hotspot handle had to be considered in the code, and since these are core libraries that must run well on every possible Java device they cannot assume anything about the environment they run in so have to do as many optimizations as possible by hand. Sun's code to compute hash of string: 

In general for OO programming you separate out code into objects and each object focuses on doing one thing and doing it well. Each object should then generally have it's own source file in your code tree. 

The separate variable h is needed for thread safety. Otherwise you could potentially have a second thread see a partially computed h (or as already mentioned have two threads calculating a hash at the same time and interfering). Both will break things badly (for example inserting a string into a HashMap with the hash wrongly calculated and you will never find that String again). Copying value to val[] looks like a now-obsolete micro optimization. Again the immediate check for the array being empty is a micro optimization to handle the empty string case without entering the loop. 

You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically. 

This is a very nice implementation, and in fact will be just as fast as the sun one since over an Array internally uses a style approach. The problem with it is that it is not compatible with earlier versions of Java since the loop is a recent addition to the language. Micro optimisations You will see this term a fair amount in this sort of discussion and in general it can be read to mean "something that makes such a small performance increase that it is not worth the increased code complexity". In the usual development scenario keeping code simple will reduce bugs and increase developer performance in terms of functionality provided for time spent far more than the micro optimisations can increase application performance. In fact in some cases micro optimisations actually degrade performance as they confuse the compiler which otherwise would make the same or better optimisations behind the scene. "Premature optimisation is the root of all evil" - Donald Knuth This is a well known quote in this field, although actually if you go hunt down the full quote there is far more to it than the catchy tagline. As a developer you should focus on writing clean and well structured code and on the big optimisations such as choosing the right algorithms, data structures, etc. Once that is done if you still need to increase performance then assuming you have the right algorithms and data structures (which will save far more than any amount of micro optimisation) that is when you look at progressively finer optimisations. But keeping the code clean and readable will gain you far more in the long run...quite apart from anything else it makes it easier to get the algorithm right! The core Java libraries are a special case as every single Java program is written on top of them, so slow performance there slows down everyone...and they have to run on every single JVM so they cannot rely on clever compilers or virtual machines. In many cases the core Java libraries are a bad source of coding examples. Partly for that reason and partly because they were written when Java was new and people were still learning the best ways to do things. In fact the book "Effective Java" by Joshua Bloch uses examples from the core Java libraries as things NOT to do. That's an excellent book by the way, you need some Java experience to appreciate it but I recommend it to all developers with a year or two of Java behind them. 

With this in place, we just need a to loop over all of your items. So add each input name into an array and loop over it creating the s. 

After looking at your code, I don't see any real issues with your CSS and HTML. If it works it, then nothing else to do there. However, there are a couple things you can do to simplify your JavaScript code. Since you are using , you are supporting IE10+ (unless you add a polyfill). So this means you do not need to use the old events and you can use the newer and to simplify your code. My first suggestion is always to wrap your code in an IIFE to provide yourself a private scope. This will keep your code out of the global scope and help prevent issues with other peoples code. Its easy to setup: 

I am also passing in local references to the global and objects for a ever-so-slight performance boost. You also select your drop downs multiple times. So we can just create a single variable in our private scope to hold this selection. That way we can get the elements once ( on load) and not worry about it further. 

I prefix all of my jQuery selections with $ so I know they are jQuery objects. You should also start using for defining your events instead of the shorthand of . Behind the scenes, uses so just skip the middle man. 

Also, repeated is the actual function on each implementation. So you could create a single function and change to something like this: 

Also notice, the parameter for the function. It isn't required but it's one of those things you should use anyway. That way the parser doesn't take the extra time to figure this out on it's own. I hope that helps! Feel free to post any comments or questions. Updates based on comments/fiddle I have created a fiddle with all of the updated code, including some of the things you were trying to do on your own fiddle. To show you the performance improvements, I created a couple of screen captures. Note these are both showing when the seconds chart goes from 1 to 59. This first one is your original fiddle linked in your post. Performance Before This is the updated fiddle I linked to above. Performance After By reducing the number of times each of the charts have to update and using the CSS above, you can see the execution time has improved significantly. These samples were taken with Chrome dev tools. If you are seeing significant CPU thrashing, try running in an incognito window to see if it is something else (tab or extention) interfering with your performance. 

As you explained in the comments you are looking for something shorter. With that in mind, I completely re-wrote your javascript code to be much simpler and much more concise. First off, if you can modify the HTML it would make life a lot simpler. To make an accordion, all your really need is this: 

This reduces a lot of your code. You could follow a similar technique for height (it's actually easier than width). 

So what do 40 and 20 represent? I'm guessing its some sort of minimum height you want this to be. So create variables for them and comments to explain what they are: 

The first time through, the data element is not set so it will update the chart. Each other time through, it will check that existing value and only update the chart when the value actually changes. Once the code is added for each chart, it becomes obvious that this can be DRY-ed out as well. Maybe with something like this: 

There are a few simple things you should do first. 1) Move all of your tag to the bottom of your html right before the closing tag. Because of the way browsers parse your page, having them at the top will only slow down the page load. 2) You have two references to the jQuery library. You only need one. 3) Your HTML is not consistent. You have some open tags without closing tags. You also have different markup around some of the form fields than around the others. For instance: