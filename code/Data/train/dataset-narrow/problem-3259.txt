The systemd files ensure that when the installer is done and reboots that the system automatically logs in. The .bashrc file ensures that when it logs in that first time, it performs the remaining installation that you choose in the full Raspbian rather than busybox, which makes it a whole lot easier. 

I'm struggling to figure out how the WiringPi C library manipulates the GPIO hardware. Is it possible to change multiple output pins on the GPIO simultaneously in C using the library? For example, writing a byte onto 8 of the pins? And would this be slower than modifying one pin at a time? 

Beginning Raspbian Jessie (and I presume future versions as well), has been replaced by . So instead, follow instructions here. It will automatically log in as user To quote the answer, create this file: 

Without USB devices attached to the Pi it should use under 1 amp., certainly nowhere near 2A. Mainly guessing, but your power supply is probably ok, since most now have 2.1A ports - and the fact that it only says it gives a total of 3A out implies to me that all ports share a single supply bus. Your cable might be a problem, some are better than others, but a higher rated cable would help. It might help to also have a shorter cable, but not necessarily. If you get unreliable operation from your Pi then I would first change the cable to one rated at 2A, and if still a problem, get a PSU that has a dedicated 2.1A output - both dirt cheap on eBay. But my guess is you won't need either unless you attach thirsty USB peripherals on the Pi. 

If you want to make a full keyboard to actually type on, you'd probably be best off with the IC out of a USB keyboard. Either retain the PCB itself buried deep in your system where it can't be seen and run wires up to your switches, or fabricate something custom with the same matrix. If you really need to change the electrical matrix then you might need to make your own design from scratch, but otherwise it's not really necessary. Even with a custom board, you can still end up with something that enumerates and functions as a USB keyboard, removing the need for custom drivers. 

First, your diode is misplaced. It should be placed in reverse orientation, in parallel with the FET. Where you have it in series, it is simply reverse biased and will prevent the circuit from operating. Next, an IRF510 is a dubious choice. It is both delicate (subject to damage from static discharge) and has a threshold voltage which may vary from 2-4v, while the pi only outputs at most 3.3v. To utilize this FET well you would really need a gate drive circuit - it's specifications are characterized at a gate drive of 10v. What current does your solenoid draw if you connect it directly to the 12 supply? If it is not too much you may be able to use a simpler NPN power transistor circuit. Or you could use a small relay (driven by a small transistor or the optocoupler version importers sell everywhere) to control it. 

What is the pin numbering for WiringPi on the RPi model 2 B and 3 B? The pin page on wiringPi only gives the numbering for Pis with 26 GPIO pins. This is not a duplicate because the WiringPi library's pin numbering is different to that of the RPi GPIO pin numbers and the Broadcom CPU pin IO numbers. The proposed duplicate Q&A's do not give the pin numbers for the WiringPi library; only GPIO and BCM pin numbering 

I want a quick and dirty way to upload files to /var/www and /home/pi via FTP. I followed this tutorial to set up FTP access to /home/pi/FTP using pure-ftp. But how should I then set up a new "virtual ftp user" (as described in the tutorial) so I can upload to /var/www and /home/pi? I have set up lighttpd to serve pages from /var/www, which works fine. Doing "ls -la" in /var shows that /var/www is owned by user and group "www-data". So I thought the following should work: First, make a virtual user "www" for pure-ftp, which will give access to /var/www: 

Then just create some script, and in call your script, and ensure the script will not get called in future. There are other possible solutions; in the issue discussion, one person explains how he made his own repository and package which he configured the installer to use. He also posted a link to the source. And there are one or two other suggestions as well. My method isn't perfect, but for the sake of keeping things short I will leave it as it is - it will get you off the ground. Mainly I suggest reviewing secirity since everything is done as root. But please do let me know if you have any issues or suggestions. 

GNU screen may give you an interactive terminal to a usb serial device such as an Arduino, but for use in a program you want to use the serial APIs for C, python, or whatever you are writing in. There is very little distinction between the pi and other Linux (or even unix) systems in this regard, except that some runtime framework too heavy to have a practical pi port wouldn't really be an option. What the Arduino does in response to commands on the serial channel would depend entirely on the sketch which you create and load into it; out of the box it will do absolutely nothing. An Arduino by itself probably does not exceed the pi's USB peripheral current limits, however an Arduino with accessory shields might. Powering the Arduino from a hub is one option, but some Arduinos/Arduino-like boards will allow you to use an external power supply for the board, even when USB is connected. 

Yes, you can use multiple input circuits driving multiple GPIOs, provided that the voltage range is appropriate and all share a common ground with the pi. No, this is not a particularly good way to do time measurements, as the pi typically runs a multistasking operating system such as Linux (or, if you must, Windows) and that is notorious for resulting in a substantial and variable latency in responding to external stimulus. In theory you could overcome this by doing the timing in the kernel, or better yet using a realtime kernel - but it is a lot of effort for marginal results when the real issue is that the wrong platform has been chosen. Theorectically, if you wanted to do it in the simplest way anyway you could use another checking the other photogate input, or better yet use something blocking on a read of the interrupt node for that gpio, and hope that this results in the scheduler waking you up as quickly as possible. But it will only approximate the timing. If you want to build a good photogate timer, use a barebones microcontroller and/or feed your inputs directly into a counter timer block's capture trigger. This could potentially be a $1 class part accessorizing the pi, if you really need the capabilities of that for other purposes. (Or to put it in hobbyist language, this is properly an Arduino problem not a pi problem, but you could potentially use a baby Arduino to accomplish it and report the time difference to a pi). 

Why? They use relatively little power, are easy to set up as a cluster since come with ethernet, and are quite cheap. If you use the graphics processor to crunch numbers, the Pi is actually rather powerful. They have minimal components, a powerful and efficient ARM processor, and are well-supported software-wise. They might not be the very most efficient solution in one way or another, but easy and affordable for a tech hobbyist. Like with any cluster, some possible uses: 

The advantage of the Pi is once you have two of them working well together, it isn't too hard to get up to about 100 working together - limited only by the communication between them. (ZeroMQ) makes it relatively easy. 

I want an external circuit to know when the Pi has started booting up and finished shutting down. How early/late is it possible to control the pins? And how might it be done? I'm thinking of writing a simple C program and using systemd to control when it's run. But how early/late would this actually be able to work? What software alternatives are there for controlling GPIO state as early/late as possible, short of recompiling the kernel or other high-skill methods? Also I want to avoid hacking the hardware, as I would want to make a hat for the Pi with this circuitry, and I want to be able to install it on a normal Raspbian installation 

Or replacing /dev/ttyUSB0 with whatever device file actually corresponds to your USB serial port (for example, the first Uno connected would likely be /dev/ttyACM0) Even with regard to the PI's own native serial port, this behavior of DTR is ultimately under software control - anyone who argues otherwise is ignoring the fact that it is only the Linux driver, and not the hardware, which has any knowledge of the port being opened or closed. The actual port hardware can only tell that it is being read from or written to or reconfigured, none of which are actually synonymous with opening the serial device. 

You should not be running the power for a stepper motor (or any other moderately hi or pulsed load) through the pi, period. At the least give the load its own wiring directly back to the supply. While it is true that higher voltage supplies can yield much better stepper motor performance, a boost converter is going to be a poor way to do this. If you want to run your motor at 12v (say with a ) you should use a 12v supply, not one upconverted from a lower voltage where higher current would be required. If you have a good supply in the 12v range you could consider using a buck regulator to also power your pi from it, but you may find it simpler to use independent supplies for the pi and motors driver. 

The result is that via FTP I can view files in /var/www, but uploading folders or files doesn't seem to work. What am I doing wrong? I've missed out the chown command that was used in the tutorial, but if I did that then lighttpd would not have access to /var/www? 

You can monitor the entire install process via the UART if you connect a serial-to-USB converter to the Pi's UART GPIO pins and the USB of your PC or similar (using Putty if you're on windows). The systemd files make it log in as root with input/output via the UART so you can easily interact with it without having to rely on a working SSH connection. Just change the contents of to perform the remaining configuration of your system, eg install and configure Apache etc. You can bundle your files for with the installer files directly on the SD card. In case my blog goes down or whatever, the key to my method is you create a file with this in it: 

I would recommend FooDeas/raspberrypi-ua-netinst as the base for making your installer. Download a released zip, configure a few files, put it on the SD Card, put the card in your Pi and it will boot up and install however you choose without needing any further intervention. I have written a blog post here that explains how to turn it into an installer that can do anything you want. (By showing how to automatically install NodeJS). There are a number of ways raspberrypi-ua-netinst can be made to perform complex installations but I only explore one method fully (both here and in my blog). The raspberrypi-ua-netinst installer, as it is, is slightly limited. As it is, you can easily do the following: 

The 5v pin on the Raspberry pi is simply not controllable, at all. Your edit provides a picture of a relay module with an optocoupler input. It is quite likey that you can successfully drive this from a pi GPIO output (I've used similar ones with an ATmega at 3.3v), ideally using where the pi connects to the cathode of the LED and the anode goes to the 3.3v rail through an appropriate current limit resistor (the resistor can really go on either side as long as it is in the path). You would then output a "low" to enable the relay. Ultimately you should determine the part number of the optocoupler and check its data sheet for the required current. If that is more than the pi can handle, you can use the pi to enable an NPN transistor which functions as a low-side switch in the optocoupler LED's drive circuit (much as how TV remote projects typically drive high brightness IR LED's), but that will probably not be necessary 

No, it is not possible (at least on the model B I'm familiar with, you can check the schematics for others) to toggle the USB VBus power, as there are no power switching devices on the board to implement this, and USB lights typically use only (abuse) the USB power without being command-able over the data lines. It's true that a few USB hub implementations provide per-port power switching (many hub chips have the output pins to drive power switching FET's, but few hub PCB's have the FET's installed), and there may be ways to command them under Linux, but that's not relevant to an implementation where they are not present. You should be able to accomplish your goal with a USB- or GPIO- commanded switching device - FET or transistor driver, mechanical or solid state relay, etc. These are available both as bare components or already packaged on a board/module, direct wired or opto-isolated, etc. If buying a USB-connected device, be sure to get one where driver source code is available either from the vendor or someone who has reverse engineered it, as neither a windows driver nor a binary-only x86 linux one would be much use on the pi. 

Where it says the type "24Cxx" must be used: if an EEPROM has the prefix 24C, does this mean it might still be 5v only? And if it has that prefix, does that still mean it might not be 16-bit addressable, might be paged, might perform clock stretching, and might not have a WP pin that protects the entire memory? To save a lot of work, is there a list of potentially suitable EEPROMs? 

The USB ports run off a single USB controller so you can't just disable a single one. And the ethernet also runs off the controller, so you wouldn't be able to use it if you disabled it. Even if you did disable USB, it would save very little power. Wifi, CPU and RAM use the most energy, as well as the graphics processor. To use less power you could also disable the LEDs which would probably help more than turning off the USB controller. So reduce the software running on your Pi that uses a lot if CPU, that will help the most. And use ethernet instead of wifi if you can. Disable graphical output if you're working headless. "Tearing" off the USB ports is a really bad idea, and wouldn't do anything anyway. 

How do developers of Raspbian test it on the Pi? If an install takes say 30 minutes, then that's 30 minutes for every combination of installation configuration and model of Pi and its components - let alone hardware that might be used with it. Would this be run on a farm of Pi's? (Or should that be a bakery...) Or the majority of the code split into modules that can be tested without going through the whole installation process? And I assume much of it is done on virtual machines that are close enough to being equivalent to the Pi? The reason I ask, is I use a minimal version of the Raspbian distro (FooDeas/raspberrypi-ua-netinst) and AFAIK it is slow to test; not ideal for development. I want to extend it, and maybe contribute to it, so wondering if there's a better way.