There is one strategy, at least, that often works, especially with older and more experienced students. Using it in Secondary School would, perhaps, be too risky. It is also probably not indicated for core courses except when no alternative can be found. The underlying principle is that you should not lie to your students or present yourself as other than you are. In other words, don't fake it. On the other hand, what you are is a scholar: someone who can learn. Someone who knows how to learn. The basic technique is to run the class like a learning lab in which everyone contributes ideas constantly. There is more discussion and almost no "lecture" unless you can get the students to give mini-lectures on cool things they have discovered about the topic. It is teamwork in the extreme with yourself just a team member. EXCEPT, that your main job is to show them how to learn: research, reading, experimentation, trial and error. You don't supply a lot of course content but you do supply learning strategies and feedback on the things that the students learn. A slightly less important task is to guide the students away from pure chaos. You will need to get them to focus on things in a reasonable order, delaying things that seem deeper or less connected to the main ideas being presented. To ease your comfort level, try to find a few recognized experts in the topic at hand. This doesn't necessarily mean text-book authors, unfortunately. You might be surprised that some of them are willing to give you guidance (pointers to papers, etc) that will help you guide the class. One trick is to have daily summaries produced, perhaps by yourself, and perhaps by students, rotating this task and making the summaries available to all: What are the two or three most important things we discovered today. If the course is about programming you can organize a very agile team to try to produce something interesting within the framework of the course. If it is about theory you can try to teach students how to find the crux of the proof of a theorem (for example). Note that this is exactly what you are forced to do if you are teaching a topic that is state-of-the-art, edge-of-the-known-world stuff. Nobody knows how to teach it methodically, so try to develop the method yourselves. Another use of this is when a group of students forms a Learning Club to explore some topic. The group leader may know a bit more than the others and can try to guide them, but it is a learning-for-all situation. Learning how to learn is likely more important than any specific topic. Without that you can never leave your guides behind nor can you outshine your teachers. Older students have, hopefully, already experienced learning and, hopefully, have a few learning strategies developed already so it isn't as big a task as teaching novices in a field in which they have no preparation at all. 

We're introducing some aspects of parallel processing quite early on in Scratch. Each sprite has its own script which appears to execute in parallel with those of the others. Scratch has a broadcast and receive message protocol, and support for shared as well as private variables and lists. Children might encounter this in a maze game, perhaps programming a number of similar ghosts to chase the player's avatar. It's also useful for agent-based modelling, e.g. the spread of an epidemic through a population. Of course, it's not true multi-threading, as all of Scratch runs inside Flash, inside the browser, on just the one core, but I doubt those using Scratch will be aware of, or care about, the distinction. This does, though, lead to potential difficulties in 'graduating' from Scratch to a text-based language such as Python - young Scratchers who've been used to programming in parallel in Scratch can find it hard to adjust to doing just one thing at a time in introductory Python programming. 

Any programming is a two step process: deciding how to solve the problem, then implementing that as code on a particular system: choosing or designing an algorithm is the first step. There are great ways to illustrate how the choice of algorithm matters. An introductory one might be search - comparing random, linear and binary algorithms to, for example, find a missing number, or a word in a (printed) dictionary, or a book in a (physical) library. Another might be exploring different sorting algorithms, for example bubble sort and quicksort using this CS Unplugged activity. Mathematics provides a rich source of contexts, for example asking students to think of an algorithm for finding the greatest common divisor (i.e. highest common factor) for a couple of numbers. Have them try their algorithms out on paper before coding them and then testing with some big test numbers. 

The object in myNoiseMaker makes the actual sound. But by changing that object the Animal can bark or meow or roar or what ever is needed for that animal. The value can be set in a constructor to produce a Dog or a Lion, of course. All animals behave the same (same set of public methods) but each in its own way. Don't start thinking that we need switch statements to achieve this. There is no test for the kind of thing we are. One possible value of myNoiseMaker only knows how to bark. A different object knows how to roar. We just create (or replace) the object as needed. This of course is well known as the Strategy Design Pattern. The strategy here is an object with one method: . It is also possible to use inheritance at this level and one Strategy can inherit from another. Usually you want a Strategy that implements shout as a no-op. You can inherit from this to create a Dog and from that to create a LoudDog. So an object built by composition (lots of Strategies) and using Delegation is pretty rich and very flexible. Each instantiation of an Animal object only knows how to do one thing as appropriate. This is polymorphism, actually. But, once you grasp the idea of a Strategy you can do much more. As a program runs, its state changes. One possible way to develop programs is with State Change Diagrams. At certain state changes it is possible to replace one delegate with another, changing the behavior of the containing object that uses delegation. For example, the first time you press a number key on a calculator it shows that value in the display. But the next time you press it something different happens and the new value is accumulated into the old. So pressing a number key after pressing the equals key has different behavior than after pressing a number key. This can be handled by having the calculator delegate the key presses to (various) strategy objects as the state changes. Again, you don't need flags and switch statements to remember what to do next. The Strategy object knows what to do since it was designed to do only that one thing. To go even farther, another design pattern is Decorator. There are various kinds of decorator but the essence is that it is a certain kind of thing and it also has something of the same kind. A Strategy Decorator is a strategy (it has the shout method) and it also has a strategy as a field. When the containing object delegates to the Decorator it can first fire the shout method of the held object and and also add a sound of its own. Since a Decorator is a Strategy it can also decorate another decorator as the held object. This is essentially a linked list of Strategies with all but the last being a Strategy Decorator. So, you can illustrate inheritance and dynamic polymorphism very nicely with small classes such as strategies and decorators. But it requires a mental model about how to build objects - use composition primarily (for the big things) and inheritance for the small things. And notice that this mechanism (composition + delegation) moves the focus of change-of-behavior from the class to the individual object. 

I have no recommendations for the theory part but since you are asking for implementation advice as well, here we go. If you are looking to use C sharp (you haven't specified a specific language of choice) then, as a dot net guy myself, I would recommend you start your self learning on concurrent programming with .NET implementation of same at Threads and Threading. The link provides with what you can (most of the things you have discussed can be done in C sharp Threads) and what you cannot do. If you wish to dig deep, there are no specific books on threads in C sharp, but you can use the reference book I used which contains detailed implementation notes on the same at C sharp 70 483 

I kind of like this question because I have faced this situation many times, and I have in fact, told my students, that yes, they should change their specialisation or at least pursue something else. Most of the time, the students hate me for saying that. Some have accused me of interfering with their lives. Others, think I am overstepping my boundaries. However, as is always the case, some of them are happy to sit and discuss why I said that. These sessions can go on for long hours, but eventually, we are able to figure out what is right for them. For instance, I had this student who was just terrible at programming. If not for decent repetition and memory, the student would have failed the class. I found out that the student had extraordinary artistic skills. I was able to sit and map out a career path which used these skills. Now the student is working hard refocusing career goals, away from computer science. Like this, there have been many cases where I was able to realign people towards their goals. All said and done, I tell students that they are bad at this (by providing historical data for the same) but I also tell them what they should be doing instead. This seems to work. Over the years, I have learnt that some students are more open to such suggestions than others, and have gotten good at identifying such students. So, the process works something like this. 

One design for such a course pairing is to have students do the design of some project in one term and then swap designs for implementation in the subsequent term. These can be team or individual projects, and part of the evaluation done by each team is to discuss the quality of the design they were asked to build. This assumes a stable student population, of course, to be really valuable. However you need to have a fair grading plan for this to work. Students struggling to build a poor design shouldn't be penalized for decisions made earlier by others. Even when students build their own designs, it should be possible to recover from earlier mistakes. Don't let early errors put students on a path to doom. 

If you are willing to drop the word "design" from the question, however, the possibilities expand. "How can we show students the consequences of their early decisions?" This is amenable to any sort of development process, including agile, in which design and development are done by the same people and iteratively. Here the suggestion of user @Keelan can be easily applied. But not likely in a single term. If one course has students building tools of some kind and a later course has the students using those tools themselves, they will learn about earlier bad decisions, either of design or implementation. But, again, make sure the students have a path to success even if they have made early mistakes. 

A variant on the usual random drill and practice test would be to pre-populate with the questions and answers, then remove question and answer from each as they get answered correctly, allowing players to get more practice on the questions they get wrong. Here's an example for times tables. You could try something for an adventure game, building up an inventory of items collected in a list. Another possibility would be an adaptive 20 questions style game, adding additional questions into a database (of sorts) as the player gets to the end of a branch of the tree. 

When we were drafting the English national curriculum, we found it easier to think in terms of the foundations, applications and implications of computing, all three of which really should be included in any broad and balanced approach to the subject. You can map these to computer science, IT and digital literacy if you wish, although you would need to accept a rather broader definition of digital literacy than that used by the Royal Society Foundations would be about the underpinning principles of computer science (logic, algorithms, data representation, abstraction), as well as their practical expression through programming and more generally in computational thinking. Applications is about skills in using digital technology to get useful work done, including collecting, managing, analysing and communicating data and information and creative work in a range of digital media. Implications is about a critical understanding of the impact of digital technology on individuals and society as well safe, responsible and ethical use. I'd include intellectual property, privacy and security here too. I've an illustration of all three in response to the question 'How does Google work?' Foundations: big data, Page Rank, Big Table / the Google File System (GFS) etc Applications: type your query, click the button (well, these days it starts searching as you type), but also filtering results, advanced queries etc Implications: profile, filter bubbles, advertising, smart creatives, separating costs and revenues for accounting purposes etc 

Computational Thinking is a big deal in the US now. It can start very early in a kid's life. Piaget and The Montessori method took a shot at this long ago, with success. But it needs to go beyond just math, into, say, Algorithmics and Big Data. 

A second example of fairly simple lambda expressions that lets you delve into some interesting side discussions is the problem of reversing a linked list in linear time. It is easy to use list 'head', 'tail', and 'cons' to write a method, putlast, that puts the head of a list at its tail, removing it from the head, but otherwise leaving the elements intact. This function runs in linear time on a linked list. It is easy to write reverseList using putLast, but it is quadratic in time and a discussion is useful to students if you are doing this sort of thing at all. It is a bit more challenging to write a linear-time reverseList. The technique is very cool and teaches a lot about functional programming, not using intermediate variables to hold things. I won't give away the secret here as it is a mind expander to discover it. 

I hesitated to answer since most of the answers given are already so good. However, I've also used $URL$ as an introduction, though it isn't precisely recursive. It is more focused on a list as a stack, which leads naturally to recursion. In my class we occasionally had "Choir Practice" in which I'd ask a number of students to participate in various "games." For this exercise I'd give each of them a Script card. Starting with only myself and one student, I'd do one verse of the poem, then "push" another student on to the stack and continue. I start (with one student) and say: 

Use a wireless mouse and keyboard. This allows me to walk around the entire classroom, and standing next to students who have the doubt and there by allowing them to select what they want, saving me a ton of time and making things interactive. Sure, carrying a huge keyboard around is a pain, most of the selection is done with a mouse, so its small and easy to carry around. I use a Wacom tablet with the pencil that comes with it. A lot of times, I am expecting a code block that will probably be discussed a lot. Since I know in advance what these code blocks are, I take screenshots of them and add them into a drawing app (I normally use Photoshop, but you can get free drawing apps on the App Store on the Mac). Then, I use the Wacom pencil and tablet, turning the entire projector into a virtual drawing board. 

The ones who finish early, are also the trouble makers. I suppose that is somehow related. Once they are out, I can actually focus on guiding the ones who need my help. These early finishes become a constant source of interruption and that energy can be used on the slow folks. it acts an incentive. Knowing they have an opportunity to leave early, some students tend to put in a little extra effort learning the programs they need. That allure of leaving early can be great motivator. The slow kids also seem to be encouraged by this because they don't have to bear the gloating of the fast finishers for the next 2 and half hours. 

I'm sure there are plenty of others. Not sure I'd use them in every lesson, but they might be a useful incentive towards more purposeful use of the devices they bring. I know one school where in free time pupils are only allowed to play games they've coded themselves... 

Lots of things you can do via role-play, e.g. simulations of how a processor works, how the internet work, how e-mail works etc, but also playing through some scenarios or dilemmas in online safety. Plenty of scope for debating broader moral and ethical issues around CS, including AI: What should Audi's programmers and managers have done? Should end-to-end encryption be available? What rules should a self-driving car be programmed to follow? 20 questions, or something simpler such as guess my number? Lots of fun with hand-drawn graphs, e.g. minimal spanning trees, shortest paths or the travelling salesman problem. 

Some interesting projects for those working with block-based languages (such as Scratch, Snap! and Blockly): For Scratch, check out Dr Scratch, which takes a rubric approach to evaluating how much 'computational thinking' is evidenced by a project. Whilst the analysis might seem a bit reductive, it can be used independently by learners and includes some useful guidance on how to progress. The developers describe their approach in this paper. Dr Scratch is built on Hairball, a Python module which does static analysis of Scratch projects. A more conventional autograder, lambda, is being developed by Michael Ball for Snap! It's already integrated into UCB's Beauty and Joy of Computing MOOC, and I think there are plans to make this more widely available. Michael wrote about this for Hello World #3. Chris Roffey has developed an autograder for Blockly used in the initial round of the TCS Oxford Computing Challenge programming challenge, although I don't think the code for this is shared publicly. 

First up, I started my talking to some of the folks who are already working on large projects. I am talking folks who are in the industry for a few years. These experienced gave me knowledge about the kind of tools they use, programming languages they use and stuff like that. After that, I decided to build a 'project atmosphere' right at home. For instance, I was advised about using servers and databases extensively for every project. So, I used Azure to create my own IT department, and then consume all those IT resources in my applications. Another individual suggested that I become 'full stack' developer, so I learnt all the languages/components of dot net that are required to go from a project concept to delivery. then, I decided to fill the gaps in my own learning. For instance, I had realised that without even knowing, I had become extremely good at the basics of programming but throw an advance component, I would falter. So, I grabbed all the industry authored books (the ones aimed at working folks rather than students) and pretty much went through them, essentially relearning things. Finally, for practice of getting that 'team' feel, I had some of my students to act as my project members by create real but practice software projects. I would take upon on the role of the project manager or team lead, distribute the work load, conduct presentations, coordinate code over repositories and then deploy the whole thing myself. 

There seems little value in students copying code off a display, but much in watching the teacher model how they think about the task, talking through the problem solving process of coding, as well as debugging (in the case of, ahem, deliberate, mistakes), iterative development and refactoring. I think this works if it's editing a longer program or writing short examples. I'd say good practice would include sharing the code produced, via Github or elsewhere, as well as screencasting the talking through of the development process itself. 

There are some history topics that link really well with computing - for example a history of communication, taking in writing, printing, semaphore, the telegraph and Morse code etc, through to the internet and the web. The English history curriculum for 5-7 year olds suggests that pupils compare William Caxton and Tim Berners Lee. Another great topic would be cryptography, perhaps starting with the Caesar cipher, mono-alphabetic and poly-alphabetic substitutions, Enigma, Colossus and other work at Bletchley Park, public / private key encryption (with applications to SSL), some of the contemporary issues around privacy and perhaps a look ahead to quantum cryptography. YMMV, but I think context like these may make these topics more engaging than a straight history of computing unit. 

Harvard's grading policy for CS50 is worth looking into. There are four components for the grade on problem sets (each of which involves submitting code). The overall grade is calculated as scope * (3 * correctness + 2 * design + 1 * style) Scope: to what extent does the code implement the features required by the specification? Correctness: to what extent is the code consistent with the specifications and free of bugs? This is done by the check50 autograder, and it's essentially unit testing. Style: to what extent is your code readable (i.e., commented and indented with variables aptly named)? there's a component for formatting: I think in Harvard's case these marks are awarded by teaching assistants, but basic static analysis or linting might suffice. Design: essentially, is this good code in terms of clarity, efficiency, logic, elegance - again, Harvard use TAs to award these grades, and it's hard to see a machine (or an inexperienced grader) being able to award these marks accurately any time soon. If you were determined to use automatic grading, I guess you could do something with run times for test data or the more sophisticated forms of static analysis. A compromise might be the use of peer-assessment and a detailed, criteria based rubric: peer assessment might have other benefits.