However this will align it everywhere. You might want a GPUVec3 which is aligned, and has copy constructor from your general vec3 so you don't burn that extra float everywhere. I would, however, suggest stuffing your alpha into the w component of some of those vectors to improve bandwidth since you are just burning memory there. I wouldn't surprised that, in addition to losing a float per vector3, you are also losing 2 floats at the end of your uniform structure. 

The tutorial describes the m_BoneMapping as an array, but the source code suggests otherwise. It appears to be a which maps a name (string) to an index (unsigned). It is populated in the method, and used in If you add that to your Mesh class it looks like it should all work out. 

A lot dependa on what an 'object' is and how complex its topology is. Consider a character model with 16 bones. Each bone has a physics volume used for hit detection in an fps. But when you render the object all you care about is the player. In this case thr physics representation is complex but visibility is a sphere-v-frustum which is cheap ans rotationally invariant. A tank with articulatef parts is the same. The key to effectice culling is to make sure the cpu cost of culling is cheaper than the cpu costs of drawing plus the gpu costs of drawing. Spend too much time culling and you lose. Often the AABB of an entity in the broadphase works as long as it is not a complex object - there is a one to one relationship between the physics entity and a draw call. One additional thought is that sometimes you wany to use some kind of hierarchical structure to accelerate culling. In this case the broadphase aabb would need to be inserted into this structure or the frustum ia tested against the broadphase for overlaps. Finally some things have no physics such as particle systems ao you will want your culling system to support those things as well. Hope that helps. 

There are a lot of engines that work this way. The important thing is to make sure you don't transition from one language to the other too often as there is usually a cost there. 

An important consideration here is that when an object has it's world matrix affected, we need to broadcast that dirty state on to the children, since their cached world matrix is invalid - the parent has moved. When any child has it's world matrix requested, it will rebuild the hierarchy from that point up to the first non-dirty world matrix. This requires the manipulators/gizmos to understand this kind of transform complexity, instead of just performing transforms agains the matrix, but I think it is more concise in and editor. Obviously in a game, at runtime you wouldn't have all of these things if you were not editing the object. 

Maybe posting your question on an unreal-4 forum would yield more specific answers. Sorry I can't be more helpful. 

Right off the bat I think your units don't need neighbours. Zones should hold neighbouring zones but I would likely add a class called a zoneEdge that contains two pointers one for each zone sharing the edge. Each zone would hold a list of edges. Walking the edges would get the neighbouring zones. When it comes to pathfinding this will really help. Zones should store references to the units in them somehow be ita list or some other structure. For example if each zone has an id and each player has a dictionary where the key is the zone id and the value is a list of units the player owns in that zone you can reasonably get all the units for a player in a zone and move them to other zones without having to mess with sorting and filtering lists of mixed user units. A game needs access to all these things. One important thing to remember is that experience makes these things clearer. Don't get paralyzed trying to find the best solution before starting. Get in there and see what works. Only you will know the pitfalls your specific game has. 

I read a really great article about SOTC and how the made it. I found a copy of it here. To summarize, they use a 'deformable' mesh, where by parts of a triangle mesh are weighted to bones, using the same technique as rigged characters. The edges/lips that can be grabbed are specially tagged. I suspect that they keep the previous and new position of each vertex so they can calculate the velocity of each contact to help resolution. I do not think many physics engines could do this out of the box, but I imagine you could implement it yourself with diligence. Fundamentally I don't think it is hard, but getting it to run fast, and getting good collision response requires effort. Encapsulating each triangle in a bounding AABB tree (3D version of the box2d broadphase, for example) would help speed up queries. The fact that triangles change size and orientation is a complication but obviously not insurmountable. 

I think there are too many factors to consider to make a cut and dry decision. That is why all styles are still in use today. Some projects use more then one in concert - animate the core elements and use physics to drive some additional dynamic objects or particles. The latest GTA worked that way in many places - some dynamics but a lot of canned animation since gameplay elements were important and objects and characters needed to end up in the right place for progression. Games like Star Wars: The Force Unleashed uses both predefined shatter points and dynamic mesh splitting because it is core to the power and structure of the player, and everything needed to be slicable by a sabre. Voxels are popular now for all over 'everything is destructible' but there are trade offs there, as well. 

First we write all of our snapshot bit-wise: bools are only 1 bit instead of 1 byte (or more depending on compiler). We wrote a bitstream class that reads and writes data to a stream. This saves a fair bit of data all alone when packing flags down. For an example of a decent C++ BitStream class have a look at the RakNet source recently made available by Occulus here: $URL$ We found the smallest way to represent data, bitwise - if an integer can only be in the range of 0 to 15, for example, we only store it in the snapshot as 4 bits. We perform this range packing on signed and unsigned integers, minimizing the amount of data being sent at the cost of having to write the data to our snapshot stream bit-wise. There is CPU cost here, but the data bandwidth is greatly reduced. We do this for enumerations as well - if there are only two states, it only takes one bit, for example. We exploit templates here to make this easy to write in code. We establish some data types that can be quantized - data that we are satisfied to lose some decimal precision to reduce the over-the-wire bandwidth. Combined with the range packing we can compress floating point numbers down from 32 bits to a smaller, range and precision specific level. Again we exploit templates here to make this easy to write in code. Delta compression - you have identified this already, but it makes a significant impact. We group blocks of data where the delta compression allows us to group a number of related, unchanging fields under a single dirty bit to indicate if they have changed or not. This reduces the cost of sending a bit for each field indicating it has NOT changed. There is less of a win here, and one has to be careful about how you group them, but infrequently changing fields that generally change in tandem are good candidates. We take the entire packet and compress it using a quick compression engine - lz4, for example. This reduces the data even more - every thing helps. We don't send ANY data for objects that are too far away to be part of the local player's simulation and bulk-synchronize those objects when the player enters proximity. Some objects are excluded from this system such as mission objects, keys and locks, for example. We don't send ANY data that can be reliably reproduced on the client. For example, we send animation state and time instead of the position of each bone - the client can reliably pose the character with that information, saving us the bandwidth of sending the transform of every bone (and anything attached to those bones - hit boxes, effects, etc). We extend this out as far as we can. As one comment pointed out, "the best compression is not sending it at all".