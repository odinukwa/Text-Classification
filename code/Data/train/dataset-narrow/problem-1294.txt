Disclaimer: I'm rusty with Haskell, there may be a cleaner way to do this. Code review: your code looks fine to my eyes, it's just that is overly complex, as you suspected. Also note that can be written as (source). 

This makes it clear to the reader that each element of the input array will be assigned to. Now we can keep track of where the next element for our array is coming from: 

Let's explore what this would look like with an adjacency-list representation of the graph. Apologies for any errors I introduce along the way. One motivating factor is that a lot of operations that we do are local, not global -- we're often just interested in the neighbours of a particular island. First let's change the data types: 

We want to hash the properties of an instance of (actually, many instances of ). I assume you're currently getting these properties via reflection. Something like this: 

If you just want to do this for the unit circle, you can use to choose the angle \$\theta\$ defining the unit vector. If you want to deal with the more general case of the \$n\$-sphere, there is a method mentioned on Wikipedia. 

This problem can be solved by finding the edit distance between the two sequences, where an edit is defined as being an insertion or a deletion (the usual definition includes substitution as an edit operation). You can use the distance matrix computed by the following code to reconstruct the edit sequence. You then need to check that it consists of a single insert and a single delete, where the items inserted and deleted are equal. 

In fact, will always be empty, and that line will always run. This is because a new instance of is being created: 

Edit From your comment, you don't want to use an to sum the bits. In that case, let's look at the addition table 

There are a few problems with this code. If then should be equal to . In this code, it is equal to . Similarly, if then should be equal to . In this code, it is equal to . 

I know the style in F# is for short variable names, and I'm all for that for the most part, but I think in this case we can/should make them a bit clearer. 

Remove property I think enabling/disabling inspections should be handled at a different level. Especially if you want something more complex like a project-specific settings file overriding a global one, something like an class would be good here. Inspections might have more than one fix (or none) Consider returning an for quick fixes. Rename The return type is , so I would recommend something like . 

You can use a regular expression to find the ID. The pattern will match one or more occurrences of 0-9 at the end of the string. You can use it like this: 

The largest possible answer then is \$25! = 15511210043330985984000000\$. This value won't fit in an , a , or even a . I would recommend using a . 

is unused, which means it can either be removed, or there's a bug in the program. The first line in , , is superfluous and can be removed. The use of parameters can be avoided by just returning a value. Methods that can be marked should be marked . In , it is probably faster to iterate over nearest neighbours just one, like so: 

Having worked on a similar system, I came up with a very similar design. So either we're both doing something right, or we're both doing it wrong :) Here are some things I would change, but obviously different requirements call for different decisions and may not all be applicable here. Remove class I don't think you gain much from having a base class here. Now your inspections look more like this 

(I haven't worked with dynamically generated code before, there might be some things that could be improved.) Now our loop looks like this: 

Now you want a variable number of phrases to look for, and it seems that some will need to be at the start of the line, while others can be anywhere. We can write the tests like this 

A rule of thumb for performance in C# is to avoid allocations. In this case, we should try to remove , as well as the calls to and that appear at the end. Of course you need to set performance goals and profile the code yourself on realistic input. Single line strings can reasonably be expected to be quite short (say 200 chars?), so what you have already might be performant enough, but I'll illustrate an alternative way. First let's make this a static method so it will be easier to unit test. As I mentioned in the comments, there's a bug in the code -- unit testing can help you catch such bugs. 

Of course, for many applications, 2.5MB is just a rounding error, but sometimes it matters. I'm just trying to reduce memory usage as a learning exercise. 

Granted, you might not come across such an input very often, but I don't think that's the result you want. Two other points: 

I find that helper methods and on can make tree code a bit cleaner, in general. It's not of much advantage here, but just for reference: 

but I would probably recommend not overriding and for this class, if you don't have a good reason to do so. 

I would suggest changing the type of from to . It hides implementation details, allowing you flexibility in your choice of data structure in the future. It also gives you more control over how client code can access/modify the state messages. Make the backing field to ensure that it's not null. 

It doesn't seem like this method should be responsible for locating the inventory. It is probably better passed as a parameter. 

Let me introduce you to your new best friend... Hoogle. Seriously, it's the best thing since sliced... monad analogies. Install a local copy as well. We're producing a sequence of values by repeated application of a function, so let's search Hoogle for 

I would make it clear that is modifying the array by changing its return type to . This could go either way, as it is nice to be able to chain method calls, but here I would err on the side of . 

The elements of are never used; the only thing of importance is the number of elements in the list. You can thus replace the list with an , or better yet, stop iterating early using : 

This implementation will exhibit \$O(N^2)\$ performance when all the array elements are the same. Consider what happens in this loop when all the array elements are the same: 

that is, assuming you don't really care about the value returned by , you just want some non-negative integer. 

is being called twice, so you can assign it to a variable to remove one of the calls. Since we know there's only one per line, we can use to find it, and to extract the relevant parts of the string. This may be a little bit faster than calling . 

And on my machine, it takes 0.39s, which is pretty close to the baseline. I've put the code up on Github if you want to play around with it. 

would be , while your code gives the answer . Also a window size of 0 throws a . While there are minor stylistic complaints I would focus on in a normal code review, I believe the bigger picture is that you are using the wrong data structures for this problem. You are duplicating the information stored in , an array, in a linked list. You don't need this duplication, you can just index into the array. Second, to find the maximum in a range in the array, you are iterating through the entire range. Using a skip list would change this from an \$O(n)\$ operation to an \$O(1)\$ operation, with adding and removing elements being \$O(\log n)\$. Assuming an implementation of a class, the algorithm would look like this: 

I'm sure that someone who knows more Python than me will be able to provide more feedback, but I see a couple of issues. The first is that the core of this functionality is implemented by . We can just write this: 

It's not a big win in this particular case, but I think it is a bit cleaner. Processing Data with Java SE 8 Streams, Part 1 has more examples of where streams can be a powerful tool. Note that unlike the original code, this will return for zero-length arrays. You can of course change it to return 0 instead, if you want. 

The logic is confusing. A direct translation of the problem specification is possible, and clearer. Let's deal with the first half of the problem: 

It might be worth introducing an abstraction for the type of piecewise linear functions that bound your intervals. For example (warning, there might be errors) 

A similar problem is also present in the method presented here: we end up writing 403 bytes, not because of buffering but because of how we're counting. If you want to be precise about the total file size, you will need to modify it. 

Spoilers How would this look in code? Suppose we have a stack containing pairs of the amount of pesticide in the plant and the day on which the plant dies. If we are in the interesting case, where the plant doesn't die on day one, then we keep popping elements off the stack while they have at least as much pesticide as the current plant. While we're popping elements, we keep track of the maximum number of days it takes for these plants to die. If we have popped all elements off the stack, the current plant will never die. Otherwise, the plant will die on the maximum number of days that we've seen, plus one. One we have calculated the number of days it takes for the plant to die, we push it onto the stack. Since exactly \$N\$ elements are pushed onto the stack, we cannot have more than \$N\$ pops. So we can see that this algorithm is \$O(N)\$. 

That's a perfectly cromulent implementation. I would just suggest making the style more consistent, with regards to spacing and braces, and maybe using instead of : 

Next, we don't need to construct a list containing .. ; we can instead operate over a sequence, meaning we don't have to have all those values in memory at once. 

Let's start by analysing the current algorithm. Each day that plants are dying, we iterate through all living plants. So the worst case would be if only one plant dies each day. In this case, we can see that the algorithm will take \$O(N^2)\$ time. For example, the input sequence \$ 1, 2, 2, 2, 2, \ldots, 2\$ will exhibit this quadratic behaviour. From the problem statement, \$1 \leq N \leq 10^5\$, so we will have to do better than \$O(N^2)\$. 

I would recommending getting rid of the property entirely. Instead, provide one or more constructors like 

There's a typo in the setter, it should be . As it stands, calling the setter will cause the program to crash. You can avoid typos like this by using auto-implemented properties, e.g. 

I think there are issues with both implementaitons, though I do find the first more readable. The main problem is that neither makes it immediately clear that we are assigning a new value to each element of the input array. I would expect an implementation to look something like this: 

So where does a segment start? It starts at the sum of the previous lengths. We can use to calculate the partial sums of the lengths. This gives us the final solution 

Why not just handle this case separately? It's then simple to prove that if , we don't have repeated values, and we can just generate them in increasing order. 

Now to the main part of your code. I would say that it's functional and idiomatic, but in my experience with F#, sometimes it's best to compromise on the functional approach. For example, consider . The basic idea is to go through a sequence, building up lists until a certain predicate is met. I feel that the functional approach, with its list reversal, obscures the intention of the code. Here is what I would propose: Edit Fixed a bug where last elements might not be returned. 

In , consider removing from the end of the list instead of the beginning, as it will be more efficient (elements do not need to be moved around). Also consider throwing an appropriate exception if there are no more cards in the deck. 

My first reaction is: don't do this. By creating your own encoding for an array of strings, your XML is not going to be (easily) consumable by other programs. By Base64 encoding your strings, your XML is not going to be human-readable. These are two major benefits of XML, and if you're willing to sacrifice them, maybe XML is not the right format. If the serialized data is only going to be consumed by the same program, binary serialization would be a better option. That said, if you want to serialize a list of strings to XML, this is what I would recommend: 

As you mentioned, a would be a better option than manually resizing the array. If you ever find yourself resizing an array, is almost certainly what you want. When a resize is required, it doubles the size (source) of the backing array, so you're trading some space to save a lot of time. As a bonus, it makes the code more readable. 

Here's an alternative. Suppose we have a class that has x- and y-coordinates. Represent the offsets of neighbours using an array of s. Something like this 

Then we can store the current chunk in a . Using the constructor that takes the initial capacity should be good for performance: 

This prints , but the second call to should throw an exception, since the queue is empty. I would follow and throw an . If we call another 15 times, we do get an exception, but it's an . This bug also stops us from enqueueing: the last line here will throw an , since is -1. 

It's unfortunate that only implements the non-generic (though that's being fixed), but we can use to get around that. This is how I would suggest writing the main part of the first method: 

doesn't play nicely with empty sequences. This line will throw an exception, which I consider unexpected behaviour: 

The interface is overkill. As is the class, probably -- as @NickUdell mentioned, a regular expression looks like the right tool for the job here. 

Of course, take this with a grain of salt and be sure to do your own measurements. I've put the code up (including the tests and test files) on GitHub if you want to play around with it. 

First thing I would do, is remove the and the idea of inserting a separator. If we know where to insert a separator, we can just build up tokens using a . 

Now, this chokes if the strings contain a null-byte, which you mentioned was a possibility. It's hard to say what to do about this without knowing more about your problem domain. Hopefully, stripping null-bytes is an option for you. Serializing a as a Base64-encoded string can be done using a surrogate property: 

With a big enough input array (10,000 elements did the trick on ideone), this will result in a stack overflow. The site for Algorithms, 4th Edition has a good discussion about this issue and provides an implementation that avoids this problem. There's also some good discussion of partitioning in Quicksort Partitioning: Hoare vs. Lomuto. 

A new instance of is created, with a new, empty . An item is added to that list, and then goes out of scope and is later garbage collected (along with its ). This code effectively does nothing. 

The code and unit tests are available on GitHub. All feedback/improvements are welcome. There are some parts I'm not particularly happy with: 

As @Pimgd pointed out, it is also incorrect. So how can we fix it? Two strings are anagrams if each character occurs the same number of times, so that seems like a likely approach. Let's write a method to count the occurrences of each character in a string. We'll use a to keep track. 

Use the overloads of / that take a argument. If you provide constructors as suggested below, check that the values passed in are non-negative. 

So what has all this done for us? For one, I think the code is more composable and amenable to change. But in practical terms, I set up some unit tests to compare the two solutions on a PDF and a BMP. Each test was run 1000 times, and the cumulative times were 

is an async method, and you most likely want to wait for it to complete before returning the . In order to await it, we must declare the method with the keyword. This also means we can simplify the statements: 

Look familiar? I'm going to re-post part of an another answer of mine. Suppose our array \$s = s_0 s_1 \ldots s_{n - 1}\$ is of length \$n\$. We define a function \$f\$ such that \$f(i)\$ is the number of ways to interpret the suffix of \$s\$ starting at position \$i\$: \$s_i s_{i + 1} \ldots s_{n - 1}\$. In this way, our final solution will be the value of \$f(0)\$. How many ways are there to interpret the empty array? Just one, so we can write \begin{align} f(n) &= 1. \end{align} Now how about the suffix \$s_{n - 1}\$? Well if it's \$0\$, that's invalid; otherwise there's just one way to interpret it. \begin{align} f(n - 1) &= \begin{cases} 0 &\mbox{if } s_{n - 1} = 0, \\ 1 & \mbox{otherwise}. \end{cases} \end{align} Now for the general case, the suffix \$s_i s_{i + 1} \ldots s_{n - 1}\$. If \$s_i = 0\$, there are no interpretations. Otherwise, we have two cases to deal with. If \$10 \leq s_i s_{i + 1} \leq 26\$, we can interpret the suffix as \begin{align} (s_i s_{i + 1}) \underbrace{s_{i + 2} \ldots s_{n - 1}}_{f(i + 2) \text{ interpretations}} \quad \mbox{ or } \quad (s_i) \underbrace{s_{i + 1} s_{i + 2} \ldots s_{n - 1}}_{f(i + 1) \text{ interpretations}}. \end{align} Otherwise, we can only interpret the suffix as \begin{align} &(s_i) \underbrace{s_{i + 1} s_{i + 2} \ldots s_{n - 1}}_{f(i + 1) \text{ interpretations}}. \end{align} Putting that all together, we get \begin{align} f(i) &= \begin{cases} 0 &\mbox{if } s_{i} = 0, \\ f(i + 1) + f(i + 2) & \mbox{if } s_i = 1 \mbox{ or } (s_i = 2 \mbox{ and } s_{i + 1} \leq 6), \\ f(i + 1) & \mbox{otherwise.} \end{cases} \end{align} So in the worst case, for example , this reduces to the \$n\$th Fibonacci number, giving us space complexity \$O(F_n)\$.