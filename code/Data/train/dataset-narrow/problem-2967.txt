I feel it is very bad to say "no, don't ever use this". For recursion, the second most important detail is to have an . That is the condition upon which the recursion terminates. So long as the exit statement is good, recursion is a very, very powerful tool. 

Now, as for answering students' questions: If you don't know the answer to a student's question, then say so. But also say something like 

Simple Eclipse console Input\Output and user input (print what the user inputs etc.) as well as variables (just primitives, and just ,, and ). Mathematical operators: ,,, as well as . The curriculum has an option to teach increment as well as , and the rest. Conditionals: , and nested s. Also is introduced. . Not much to say about this at this level. library. This is one of the things that caused me to doubt the order of things in the curriculum. loops and various uses. Arrays are not taught in the curriculum at all loops. Nested loops. functions. yes, functions: 

After this shock, explain that each one of those has a security measure taken to protect that information. So if they want to hack that stuff, explain that there are people more or less like themselves on the other side. Hacking is never attacking a computer, it's attacking a person on the other side. So this can be in addition to what you already plan to say to them. I think that most, if not all, would get the message of the ethics. They'll understand that those protective measures are there for a reason. 

It is easy to see that bullets can be inserted from the top, and only the topmost bullet is accessible. Such is a stack. A magazine works by LIFO (Last In First Out), and so does a Stack. Furthermore, the four (five1) basic operations of a Stack are applicable: 

Obviously, each option has its merits. I am wondering which one would increase understanding more. The first option shows them uses and the reasoning behind that usage, which is great for understanding the subject. On the other hand, option 2 lets them experience it first hand, which is (almost) always good. So I am torn between these two. 

Another analogy which comes to mind is buildings. Abstraction: You never build a building. You build a house, an apartment building or an office building. Polymorphism and Inheritance: An apartment building is a building, but also implements the functions of . That would be an interface. So, you have 

This year I'll be an unofficial teacher assistant in the CS class of 9th graders. Background This question is about a curriculum for introducing students to programming in java. The students are in 9th grade (14-15 years old) and are not expected to have any background whatsoever in computer science (usually some do have, but that's not relevant to the curriculum. Differentiating it is something relatively easy at this stage). This curriculum spans 2 terms (1 year - Sept. to June), and is meant to build a firm foundation for students. The subject is compulsory in 9th grade. I have some doubts regarding the ordering of the subjects in the curriculum. How it stands Students are initially introduced to computers in general. The first lesson is always brainstorming: "What is computer science?". It's established from there that programming ("computer science is writing code" is usually a response of a few students) is writing something, and then converting it into binary (it's expected that they know that the binary numbering system exists). The students use the remaining time ($\pm$10 minutes) to write the famous: 

That last sentence is a red light. Such a question hints about , and about passing parameters. When using a singleton, you don't need to pass any parameters, except for the name of the person (not even the password). After that, put in the question you wrote, but make it clear that the design flaw is in the code you gave them, and not in the one they wrote. Phrasing the question in this manner and order makes it so that when they answer, they are already thinking about static and parameters and instances of the class (if only subconsciously). All of this focuses them on Singleton. 

It can often be good or bad, but that depends entirely on you. If you happen to find resources on those sites that align with your curriculum, great. You just need to be sure they don't contradict each other. If one of the resources on one site is covered by one in another site with a different example, your students might be confused by that. What I would do is go from site to site and for each subject in the curriculum, and select the site which explains that subject as closely as possible to what is to be taught in class. Then I would direct the students to those sites for each subject, should they need more examples or details. 

In some programming languages, many data structures use (The examples in the question are in Java, but I suppose they are similar in other languages): 

I'll answer the second part before the first one: I'd recommend Project Euler. Many problems, at varying difficulties. Just starting to solve them, from the start, and sticking to it. The variation in the problems gives students a very handy skill set for solving problems. As for the competitive programming, Project Euler is arguably still useful here. But I think it would be even better to form a few groups of students (2-3 students per group). Ask each group to write a program\algorithm that would complete some task (such as pathfinding or something similar) and the algorithm that completes the task in the best way (you can decide how to define "best", but I'd go for minimal complexity and execution time) wins. This teaches them teamwork as well. 

I've been trying to learn the differences between Functional Programming and OOP, but I can't seem to find a comparison of the two. A Google search did not yield any chart or table showing such a comparison. From the unclear Google search, however, I have come up with this: OOP keeps actions and data encapsulated in objects, Functional Programming separates the two. But that doesn't actually give a useful comparison of the usecases for each one. So, my question is where might I find a thorough comparison between the two, which can explain which should be used for some kinds of tasks\projects? I'm looking for some explanation\comparison of various aspects of these paradigms. The types of projects or tasks I am referring to are varied, but can be classified into: Computer Management (similar to what userscripts allow in browsers) and Utilities (units conversion, custom shell). (off site resources are considered an answer, as well as answers giving such a comparison without an off site resource) 

For those interested in 3D (though, it can be used in 2D) game making with an engine, I would suggest teaching Unity. It's an engine and a platform for creating games. Unity can be used with C# and Javascript, which means that those who choose to use it will also have some experience with some very popular high-level programming languages. Additionally, Unity is, in part, a graphical engine. This means that the game is made in a graphical way, and the student can decide how much coding would be involved (Unity has an asset store, in which some scripts can be used. Some are free and others are not). This allows students to be comfortable with the game they are making, and they decide how much programming they do. This degree of freedom is often very beneficial for students. A portion of making a game in unity involves designing, and artistic work. This can be a very convenient environment for the students who are into interactive design. Overall, Unity fits the bill by being flexible and answering each students needs and areas of interests and expertise. So I think that it is a very good choice to start with. From my experience, it's quite enjoyable to make games with it just for the sake of playing around with the software. This isn't too relevant to the question, but students who enjoy working on projects are more likely to make great projects. 

You are exposed to some other field. Who knows? you might end up finding interest in it. Even if you don't having someone listen to one's recount of one's learning provides a platform for a sanity check. The person telling their friend checks each part of what was learnt, as they talk. It makes it easy to "get back in the game", and you continue learning after those 15 minutes, as though the previous session was just moments ago. This is especially useful, and is overall what makes this suggestion worthwhile. 

I'd say that it can fit very well between the Inheritance and the Polymorphism. Interfaces are a way of promising that any implementing class supports the interface's functionality. for example, given an interface : 

I have met teachers that deal with that issue like this: First, teach the students about version control, and introduce GitHub, and tell them that they need to create an account. Then say that each group should have their projects in a repository. Then ask the students to provide a link to the repository, along with the project. This allows you to see on GitHub how much work each student contributed. GitHub allows you to see a person's contribution (# of commits etc.), so this method is quite convenient. 

Play on their terms First you should either know what qualities some of those students have. Are they competitive? are they bookworms or maybe enthusiastic about other subjects (for example, physics or biology)? Once you know these things (which can be discovered with a simple mandatory questionnaire of some sort), then a few options branch out:      1. Class Competition      there are many ways to go about this, but my personal favorite is to divide them into groups (the entire class, with the under motivated ones fairly distributed). Ask each team to create a program that would complete some given problem that is related to the most recent subject taught. The team that writes the least complex or the fastest or one that's best by some other criteria is the winner (and gets some prize which isn't related to grades). Make sure to take note of the participation of the under motivated students in each team. Emphasize that team members should try to encourage one another to participate. This would work quite well for the competitive students, including the under motivated ones.      2. Reading assignment You can casually mention at the end of some lesson that the material for this lesson is freely available in <some book name>, and you highly recommend reading it, even if one isn't so interested in the topic. Of course, make sure that the book you tell them about actually is recommended even for people who are not furvant fanatic for the topic (online book reviews can say so). This gets those who are bookworms interested in the topic, or at least it gets them up to scratch in the subject.      3. Inter-subject project For the students who are interested in other subjects, you can suggest they try to make a project in computer science, that has to do with the other subject. A physics simulation, a biology-related program (I have near to nothing knowledge in biology, so this is the best example I have, but don't worry; your students who are interested in a subject usually come up with a good idea for a project that combines both subjects) or something else. This option depends entirely on the students' enthusiasm in other subjects. But students are rarely uninthusiastic in all subjects. The idea is to encourage them to do something that they want to do, but that also involves Computer Science. This would both teach them much, and show them reasons for being motivated to learn Computer Science. This solution obviously won't work for every single situation, but with some tweaking it does cover a wide variety of students. 

I just started teaching an introduction to web development to high school students (they have the most basic knowledge of java) and this year my school has decided to make a change in the curriculum. Previously we used JSP to dynamically generate pages, but now we decided to look for a different technology to replace JSP. So, I am looking for a language for dynamically generating webpages (again, a replacement for what JSP does: servlets in Java). Bearing in mind that they know a bit of java, it would be highly preferable to use a language that is similar to Java. I am well aware that there might not be a Java like language for this (other than JSP), but the more the language is similar to Java, the better. If they end up learning a new language (not necessarily one for dynamic webpage generation), all the better.