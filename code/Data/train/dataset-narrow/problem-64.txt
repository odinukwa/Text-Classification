To get the axis of rotation you could multiply the x-axis by the inverse of the view matrix: $b = V^{-1} e_1$ Where $b$ is the axis of rotation in world space, $V$ is the view matrix and $e_1$ is the x-axis unit vector. Now, to make the object to spin around the axis of rotation $b$, we have to translate the object back to the origin, spin it, and then translate it back to its position in world space. Suppose you have a translation matrix $T$ that send the origin point to the object's location. The translated rotation (spin) of the object $M$ would be: $M = T R T^{-1}$ Where $R$ is the rotation matrix around the $b$ axis. The matrix $R$ could be obtained using the Rodrigues formula or from a Quaternion or through some other methods out there. Finally you need to multiply the matrix $M$ to the existing transformation matrix of the object $W$. $W' = M W$ and use $W'$ for transforming the object. 

If you have an oriented triangle mesh (a non oriented surface would be the Moebius Strip for instance), you can check the triangle inversion by looking at the signed area of triangles. The signed area is positive when the vertices are in CCW order and negative if they are in CW order. If your triangle vertices are all sorted in CCW then all triangles with negative area are inverted. Fixing that depends on the deformation technique, I don't know your case. Checking self-intersection is more involved. You should actually do Collision Detection of the mesh with itself. Collision detection is fast but need to implement proper data structures such as AABB Tree for narrow the amount of triangle-triangle intersection tests. Collision Detection is usually performed using very low-poly version of the meshes. In some computer games, the bounding volume hierarchy (spheres, AABBs, etc) that approximate the mesh is the only thing considered for collision, no the mesh itself. Once a collision is detected, there are several ways to response, applying a bouncing force for instance, is common. 

None of today's graphics interfaces support quads by default in the first place. This means that quads, when actually set up for rendering, are just pairs of triangles. 

Without seeing the error message I can't be sure but I think it's failing on the 1 being int instead of a float. 

memory leaks, both normal ones and opengl resources. lack of precision after incrementing a float to a big number. After 4 weeks your millisecond counter will be at 2.4 billion which is well beyond the point where integers cannot be expressed exactly in a single precision floating point number. Make sure that those numbers are wrapped down to a smaller value explicitly. 

Instead of having a binary on/off per pixel you can instead make a heat map. The more points fall within the pixel the brighter the pixel is. Essentially create a 2D histogram which you then renormalize to get the grayscale for the output. If you want to blur the points then you can move a portion of the brightness to the next pixel based on the remaining fraction after multiplying to the resolution. If it the coordinate is and your resolution is 1000x1000 then goes to , goes to , goes to and goes to . This is distributed linearly but there are other options. 

A gpu only cares about the full transform used for a particular object. It's much better that the CPU (webworker) collates the transformation hierarchy into a single matrix. What you can do is use UBO and create a block where the final transform is stored and as you traverse the scenegraph update the data on the gpu. In the vertex shader you then index into it to get the data that applies to the vertexes. But you shouldn't store graph data in there only the final data needed for rendering. 

Whenever, I click the first triangle of the pair I am getting values as , whereas the correct value should have been , and for the second triangle of the pair, I am getting as . Please let me know what am I missing here? Update I have found that stencil values can be applied on quads. When I tried to apply the stencil value on rectangle it worked correctly. Though it is not the solution I was looking at, still, I can live with that. However, I would still like to know what was the problem with triangles. 

I am trying to pick objects on mouse click. For this I have followed this tutorial, and tried to use the stencil buffer for this purpose. Inside "game" loop I am trying to draw 10 (5 pairs) 'pick'able triangles as follows: 

The above code seems to work. However, I would like to hear your opinion about this approach. Specially as my math is not really very strong, so any mathematical insight regarding Euler angles would be very helpful. Also appreciate any reference to online resource on the same, that is easy to understand. Note: Though later I also came to know about certain limitation of modelling rotation using Euler angles and use quaternions instead. However I would like to save that topic for future discussion, as I am yet to read about that in details. 

I am new to OpenGL and Computer Graphics in general. Lately I was learning how to model a camera, specifically how to model the rotation of camera. I was introduced to Euler angles for this purpose. I got a rough idea about how to use Euler angles to model camera rotation from this post. Based on that, I wrote something like below: