It can be hard to learn writing drivers when interfacing with complicated devices and/or complicated buses. Because of that I would recommend either using some simple and well known devices (ignoring existing implementation of their drivers in the kernel) like I²C/SPI devices that are usually used with microcontrollers. For example you could find any device that is "supported" by Arduino community (meaning there is a library/documentation for it) and try using it with RaspberryPi. If that's not enough or you don't want to buy too much hardware, you can create one yourself. Just get some microcontroller (like atmega or something), create a program for it to become some device and then try interfacing with it using Linux drivers. This way you can easily create programs that will emulate different classes of devices. And since you will write your "firmware" yourself, it will help you debug problems. You need some microcontroller programming skills for that but it's not hard to learn programming with Arduino and I believe it's useful knowledge for driver programmer anyway. 

Since you want to create NAS, you can't use network storage as this would require you to have working NAS already. This leaves you with only USB connected storage. USB is the weakest point of RaspberryPi right now but you should be able to use it. USB performance is not really big - theoretically, with USB 2.0, you can get 60MB/s max (it's the bus limit so no matter how many devices you connect, you can't get better throughput) . Even with cheap SATA II disk can get about 100MB/s unbuffered read speeds and using RAID technology, you can get much more. Also remember that Ethernet chipset on RaspberryPi is connected by USB so your bus will already be quite busy when transferring files. That being said, it's perfectly fine if you just want to do your own NAS solution and don't need great performance. But as you can see, storage medium won't be your bottleneck here. 

Timing question The answer is unfortunately - no, there is no amount of time that is sufficient for RaspberryPi to halt. The time is not constant and it depends on what packages are installed (each package may add additional shutdown script) and what is happening on the system. It is possible that it will not shutdown cleanly at all. So there is no warranty. What you can do is to test what is the typical time your system needs to shut down and use this as a reference value, then add some buffer to this. Relay question Using relay should not be more dangerous to the Pi than physically disconnecting it from the power and this is actually the only way you can power it off. As far as I know, the only problem with relays is that there is some energy in the coil which may produce voltage spike in it's circuit. This may be prevented by the diode but this is not always enough (but those are rare cases). This shouldn't be a problem for RaspberryPi, however, since it won't be connected to the coil circuit (it won't be controlling the relay). Also, if you are going to control AC voltage for the power adapter connected to the Pi instead of 5V connected directly, there is even less concern here - it's much harder to damage power adapter than RapsberryPi. Please keep in mind that I'm not an electronics expert so I may be missing something in that regards. Side note You may be interested in project. It tries to solve quite similar (but not identical) problem as you. In first revision, it used relay but they had some problems (but not related with damaging RaspberryPi) and started using MOSFET instead. 

And it doesn't mention that it has to be set to . Experimentation seems to confirm this. We can also check the [kernel driver] itself3: 

Note: I can't figure out why counter is compared to . Acoring to a datasheet, if high state is hold for 70us, it should be considered logical . Logical should be transmitted for 26us-28us. The counter is updated each so the threshold of 200 should never be meet. 

.Xauthority file is not needed when X session is not running so you could safely remove it and it will be recreated next time X is started. But the message does not seem to suggest the file is corrupted so I don't think this can solve your issue. 

That's not exactly a way to enter runlevel 1, but there is "safe mode" boot option in raspberry Pi firmware. To enable it, you have to insert a jumper between pins 5 and 6 on P1 (GPIO) header when booting. 

So to sum up, if your userspace applications don't use too much CPU (which is indicated by ) then it can be used by kernel processes which is indicated by or it can be used for I/O processing which is indicated by or it may be used to handle hardware related tasks which is indicated by . In the same information is showed by colours in CPU usage bar. I find it less readable so I prefer for reading that. You can hit to see the help page where you can check which colour is what. Here's a map between and mnemonics: 

Where is 0=auto, 1=analog, 2=hdmi. By default it's set to auto which means HDMI if present, analog otherwise. Unlike changing video output, this change does not need rebooting. 

Now what this line tells the system is that after starting in 5th runlevel, it should run command. What you can do is to change this line in order to run your own program/script that will start X server and your Python script instead. This way, if someone kills your app, the script will end, it will be restarted and there will be no login prompt. If, on the other hand, you want this login prompt to be visible, you can run slim in your script just after your program ends. So, you could put something like this in your (commenting line first): 

Not really. Board revision is not printed on PCB. You can, however, easily check if you have the latest (right now) revision - it has mounting holes and older ones did not have them. It also has "made in UK" text written while older ones did not have them. If Foundation make some other future revisions, you won't be able to differentiate them in such easy way. 

In general, if someone states that, he should also provide some arguments about his claim. Otherwise, you should ignore such statement. I am using such adapter without problems and I really have no idea why it could be wrong. The only thing I imagine is that many such adapters are not really good quality and you can easily break one. 

Adding initramfs This does not provide instructions on how to create , however. Since this is very broad topic (basically, you have to create working Linux userspace environment ant there is really no limit on how complicated it can be), I won't cover this here now. I will only note that can be used in two different forms - standalone one, where it's separate file and buildin where it is integrated with kernel image file (like it's in ). The second option should be supported by RaspberryPi bootloader but there some rumors that it's broken on current firmware version so you should probably use buildin version. The best way to start is to use working initramfs content (that is being used for kernel_emergency.img) by downloading it from another foundation github repository and only after you are able to boot the kernel using this image, try building your own. All that should be needed for this is to point to the downloaded directory uing kernel configuration option. Final notes So you should do this in 3 steps: 

Looks like ghc is configured to use distcc version of gcc. I don't know Arch Linux too much so I can't check this but maybe it was build with "--with-gcc=/usr/lib/distcc/bin/gcc" or something like this. This should be fixed by installing distcc. 

Yes, you can configure to only allow the user to run certain commands with additional privileges. You can changed this in your file, but it's advisable not to do this directly but use command for this. In default system installation you should find such line: 

So we at least know that it is safe. I've checked by experimenting that it is supported on RaspberryPi. This gives us a hint that reading output pin state is probably supported by the hardware itself but we can't be sure since it may be cached by the driver, for example. Lets check documentation: 

(assuming you only have one USB disc connected) can put your device into sleep. If you do this after unmounting the device, it should stay in this powersaving mode until you try to mount it again. You may also try option for sleep mode instead of stand by. You can also try: 

This should change ownership of all files in pi directory (and all directories inside of it) back to the user pi and group pi. xauth application has a commandline option which is intended to clean stale locks if they exists so you could also try running (when logged in as user pi): 

You have a typo in your config file - should be changed to . Fix that and try again. Also, please add line to your config, preferably just before line. This line tells Debian to start this interface automatically at boot. Without it, you have to run some commend like to configure your interface. 

Keep in mind, however, that hotpluging any USB device that takes much current may reboot your RaspberryPi because of voltage drop. So its suggested not to use high current USB devices or plug them before booting. And yes, you can now (almost) safely power your RPi from USB if your device back feeds power. Keep in mind, however, that USB specification says that devices should not do that (but some USB hubs and probably other devices do not have protection about back feeding power despite what specification says). Since there is no current limit, you should watch out for devices that could give more than 2.5A of power at faulty conditions as this may burn traces on your PCB. 

The short answer No, you (almost) don't. It's actually the other way around - you have to set them up not to be GPIO but to serve their special purpose. The only exception are UART pins. Also and I²C pins somehow special. UART pins UART pins are used by the kernel for the console. You will have to configure the system not to use them if you want them to be available for your usage: 

Changing IP range for clients If you want to change IP address range for clients you have to do the following: 

You can try adding config option to your . It should, in theory, disable sending initial active source message by RaspberryPi which is probably responsible for changing input source to HDMI in your case. 

Testing card read speed: There are two easy ways to test read speed (listing directory is only a read operation): 

Internal pull-up and pull-down resistors are weak (they are something like 50-100 kOhm; I believe it's not specified exasctly). This may be to much in some cases. Also, as you sugested, pull-up/pull-down resistors configuration won't be persistant after boot so if your circuit depends on fixed configuration all the time, it's better to use external resistors.