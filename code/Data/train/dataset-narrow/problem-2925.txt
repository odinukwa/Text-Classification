New graduates don't need to be an expert in anything, but they need to be able to get stuff done. By that I mean, if you have Java listed on your resume, I should be able to hand you a laptop with a clean OS on it, and you should be able to write and run a basic hello world program. You should know how to download, install, and run Java, and you should know how to write, compile, and run a basic program. You should know how to look new stuff up in the documentation, Google, and Stack Overflow. That's how programmers get stuff done in the real world. The best way to prove that you have this knowledge is by putting together something like an online portfolio. What were some interesting projects you did in school? Can I see them? What personal projects do you work on? Do you contribute to any open source projects? tl;dr: Give me a link to a list of cool things you've done, and be able to setup your own workspace. 

Most of the IDEs that have been mentioned are more confusing than just using a basic text editor and the command line. If I were you, my plan would be: 

You have to understand the implicit relationships of the hints: if you know somebody wears a green hat, then you know they don't wear a blue hat. You could even go a step further and have students create their own puzzles. 

You've mentioned before that your students are adults who are attempting to make a career change to a programming role. With that in mind, I think the best thing you can do is show them how what you're teaching helps them achieve that goal. Think about it from their perspective: I'm an (older?) adult, who has had a "real job" for the last years. Now I'm trying to change careers. I want to know how to get a new job, and how to perform the tasks of that new job. So it's hard for me to sit in a classroom and memorize stuff from a textbook and from lecture slides. You and I know that memorizing that stuff will help them in their new careers, but that's not always obvious to students- especially novice programmers. So my suggestion is to always make sure that your lessons directly tie into their goals. Find out what kinds of applications they plan on working on. Make the first assignment a very basic version of that. With each lesson, build on that assignment so that every step gets them closer to a "real life" end product. Instead of saying "okay now you have to memorize that" and pointing to some lecture slides or a textbook chapter, ask "how can we improve our product?" and then show them concrete things they can do to make those improvements. The lectures and the textbook become references that help get them to their end goal, which I think is easier for professionals to digest. For a concrete example, let's say your goal application is a point of sale system. Maybe your first application is a command-line program that mimics a basic transaction. Then the next assignment introduces variables by having different items with different costs. Then maybe the next assignment introduces statements that apply coupons. Then you could have a lesson on creating a basic GUI, or using loops to repeat actions, etc. That's just a dumb example off the top of my head, but you get the idea: use your students' goals as a motivator, and tie your lessons directly into those goals. At the end of your course, students should have specific concrete usable information and a newfound ability to accomplish their goals. 

Here, “sum_of” is a noun. “sum_of(1,2)” is not an action, it’s a thing. Having a line that consists of nothing but “sum_of(1,2)” wouldn’t do anything; it’s not a complete sentence. However, it can be the object of a verb; for instance, “printf(sum_of(1,2))” would be a complete sentence. Advanced programmers naturally go back and forth between treating functions as verbs or nouns, and sometimes use them as both (that is, they use the return value in a calculation while also taking advantage of their side effects), although many people frown on such behavior. Your students clearly aren’t able to distinguish these two attributes on their own, so you need to make it more explicit. Naming a noun-function “add” really isn’t helping; that’s a verb-name, and so your students are going to be expecting it to be used for its effects, rather than its return value. If you were explaining in English how to calculate the norm, would you say “Take the square root of add the square … “? Have your students pay conscious attention to whether a function is being used as a noun or a verb, have them give them appropriate names, and model this by giving your functions appropriate names. If a function is being used as a verb, then you can just run the function, and whatever code is in the function will be run. If you’re using the function as a noun, however, then you need to tell the program what value to assign to the function. That’s where the “return” command comes in. The “printf” command is still in verb-land. It’s doing something, not being something; if you write printf in sum_of, you’re telling the program what sum_of does, not what it is. When you write “return x+y”, on the other hand, you’re telling the program that “x+y” is what sum_of is. 

We can then have a line that says “print_sum(1,2)”, and the computer will print the sum of 1 and 2. Here, “print_sum” is a verb, and the parameters are the objects of that verb (the implicit subject is the computer, of course). Thus, saying “print_sum(1,2)” is a complete sentence. “print_sum” is an action, and putting it in your code tells your program to perform that action. On the other hand, we can have: 

Instead of using diagrams, you might have the students break the problem down into smaller steps and write those steps out in English, or pseudocode. The real goal is to get them to break the problem down into smaller steps though. You might go a step further and break the problem down for them, at least for the first few assignments. Break the assignments into steps, or split the project up into multiple assignments. Tell them what you're doing, so they see the process and eventually do it themselves. I'd also recommend checking out Processing. Processing provides a simplified reference which helps with the first problem, and it's visual which can help with the second problem. (It's much easier to reason about stuff you can see instead of abstract concepts.) There are quite a few questions and answers on this site about using Processing in the classroom, so I'd start by searching here. 

The second approach would let you know who is working on what, without making students call attention to themselves for being slower than their classmates. 

You should teach nesting as soon as possible, as it's always a point of confusion. Start with nested statements above. 

Like many things in programming, pseudocode and flow charts are both tools that a programmer uses to accomplish their overall goals. It doesn't make a ton of sense to ask which tool is better overall. A carpenter doesn't ask, "which one is better: a hammer or a saw?" The answer is that they're different tools, used for different jobs. In my experience, here's how I'd use each: 

I'm going to echo ctrl-alt-delor's comment and say that as one of the answerers on the original question, my understanding was not that "a few people suggested intro programming with true novices might not be the best place to introduce critical thinking/planning skills for programs". I don't think anybody suggested that. In fact I'm pretty sure that 100% of the people on this site would agree that critical thinking and problem solving are very important lessons to learn, especially with computer science. (And maybe even that computer science is a great way to teach general problem solving, but I'll digress.) 

When I teach metaprogramming like dynamically defining methods and method delegation, students usually understand what it is fairly quickly because it's simply a dynamic way of doing something they've already done. I now want to assign them a project that utilizes the metaprogamming I've taught. I'm having trouble thinking of a project to assign them which would be made significantly easier by using metaprogramming. The only use I know of is in a DSL. Creating a DSL is a rather large project to assign a group of high school students, so I'd prefer something smaller. Specifically this project is for fairly advanced students working with ruby, but more general answers are better. So, what projects could you assign to illustrate the utility of metaprogramming? 

In my APCSP class (using app lab, which is javascript based), I noticed that there are many students who struggle with the difference between a string () and a variable (). I've explained that strings are surrounded by quotes while variables are not, but this is still one of the most common mistakes I see. For example, a programming task could be: 

It will repeat these steps every time a character is typed. When writing code, it's clearly easier to write: 

I find that there is no real way to explain it without drawing it out. Usually, when I teach this, I've already covered basic HTML and CSS syntax, including a few properties (e.g. ). I like to give the example of creating a span with some text inside, so I draw on the board: 

I would recommend looking into a static code analyzer or linter for whichever language you are using. These are designed to examine code for any unintelligible code and to make sure that the code follows the best practices. For example, a code analyzer or linter may suggest that you limit your line length, keep your methods small, and reduce unnecessary complexity. Now, while this sound very useful, this is something that you have to be careful with and configure very carefully, because some of the metrics that are used can trigger it when the code is actually fine. It may be good enough for your situation to simply give the code analyzer to your students and let them use it to optimize their code. If you do use a static code analyzer or linter, I'd recommend setting the limits high for how much room the students have for mistakes, because the contortions to get around a strange reason their assignment was poorly graded could make things much worse. From some quick research, it seems like the most widely used python linter is pylint. From a quick glance at the docs, it seems to fit your goals. As a rubyist, I use rubocop which is both a linter and static code analyzer.