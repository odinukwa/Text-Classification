Check out this link $URL$ this link shows another question asked on unity forums and shows an answer which also contains a link to a showcase video. 

Use rigidbody.AddForce instead of transform.Translate so that the collisions are detected. For the direction create a variable with the difference between the target and the object itself and then normalize to find out the direction. 

I believe this happens because the bullet's speed is very fast so the collision doesn't have enough time to be detected, that's why I prefer using raycast for the shooting. 

When I run it and move around my second cube with "Respawn" tag the first cube doesn't always looks at it, at certain point it just starts rotating the opposite side as if it has bounds to it's rotation. What am I doing wrong? 

I believe what happens is that you set the Time.timescale to 0 in the start menu script but at the same time you have the pause menu script setting the Time.timescale to 1 because your variable pause is false. So what you could do is change your pause script so that it only is able to resume the game (set pause to false) if the game was previously paused. Another option is to make another public Boolean variable (for example called "canRun") in the pause script then when ever the game starts (eg. Start button is pressed) you set canRun to true from the start menu script. In your pause script you adjust your if statement to check for canRun as well. Change this if statement: 

You can use contact point so first you check for collision and then you have an if statement to check which side it way eg. Vector3.up, here's an example: 

I solved the problem! It can easily be fixed by setting generate lightmap UV to true in the import settings of the model. 

Attach a button component to your image after create a script with a public function (any name) then attach your script to any game object, add this game object to the button component and call the function. 

I think most of your problems might be solved by understanding the use of category masks. Simply set the masks to ignore contact and collision between the sword and player categories. Specifically, this is done by assigning unsigned integers to the categoryBitMask, collisionBitMask, and contactBitMask properties of the SKPhysicsBody of the SKSpriteNode in question. 

While it is, of course, possible to implement animations within an AI architecture, it would be a poor methodology for a number of reasons. One such reason would be an agent that chooses to walk but cannot for some reason. Another reason would be needless complexity (many decisions would have to implement an exact-copy of an animation node because they all result in the same sort of behavior). Most importantly, however, is that your pathfinding will not be handled in the behavior tree, and the pathfinding algorithm is what will actually implement agent movement. Remember that the AI is only meant as a means of decision making, not implementing those decisions in the world. A much more appropriate solution would be to tie the walking animation to the method that adds velocity to the character, which would be the pathfinding algorithm. This would implement the walking animation, or could implement a different animation for a different form of movement (running, crawling, teleporting, flying). It would be able to handle obstruction, difficulty in determining a path, and more all of which should interrupt any walking animation occurring. And it would simplify your behavior tree significantly, which is incredibly important for readability and debugging. 

If the only difference between the enemies are sprite changes and simple quantities (number of shots fired, rate of fire, etc), multiple classes would not be needed. This is exactly the sort of game Sprite-Kit was designed to make easily and quickly. Classes would be more appropriate if there was some unique behavior between the different kinds of enemy types. A common example is that of the player compared to enemies. There are fundamental differences in how those two logical structures behave within the context of most games. Thus, different classes would be more appropriate. Different enemies with different sprites, on the other hand, assuming no fundamental differences between types, would more likely warrant a single "Enemy" class with properties defining the sprite to be used, the rate of fire and number of shots per attack, etc. With a simple enough game, even an "Enemy" class isn't necessary, which may or may not be applicable to your game. Sprite-Kit has some impressive functionality that can be accessed entirely within the editors. 

Objects shouldn't pass through each other if both have colliders. You could disable isKinematic on the rigidbody and then use AddForce to push. You could use also transform.translate() to move the player. 

So I'm creating a zombie game where the zombies are passive and just walk randomly all over the area when player is not near. My question is: how would I make zombies move randomly? I code in C#. Basically, there is a town filled with zombies that just wander around the area (walk randomly everywhere slowly) until the player is seen or is very near. Thanks. 

You could increase the friction when player enters the collider of the platform, you can increase friction like this: GetComponent '<'Collider2D'>' (). sharedMaterial.friction = VALUE FROM 0 TO 1 (FLOAT) without '' 

At start you could disable its Rigidbody component or the script that is moving the tower. Then re-enable it when ever you want. 

You can use: transform.Translate(Input.GetAxis("Mouse Y"), 0, Input.GetAxis("Mouse X")); Or if you want to use physics: rigidbody.AddForce(Input.GetAxis("Mouse Y"), 0, Input.GetAxis("Mouse X")); 

You could try making the sword and the hand same object so when you animate the hand the sword will be animated too. 

I have done a texture in GIMP and imported it in Unity but for some reason the texture appears to be squashed in the sides. Image done in gimp: 

or you could create an empty game object and make your model a child of it and then change the position of your model that is parented to the empty game object, this will make your empty game object the pivot of your model. Hope this helps. 

You could use RigidBody2D.AddForce(Vector3) to make knockback or you could have and animation of the player being bounced. 

Try decreasing the amount of the rotation, so change 5 to a lower number like 2, if that's still a lot decrease it even more. 

In my scene I have two cubes one has a tag "Respawn" and another one has the following script attached: ` 

I have a model of an SMG with arms exported from Blender and set to generic rig in unity import settings. I was creating an animation for this model in Unity Animation tab, it included changes in position and rotation of the individual parts like magazine and left arm and gun itself. Then when I was satisfied with how the animation worked (I saw it by pressing the play button IN THE ANIMATION TAB). My problem is that when I click play IN THE GAME TAB there is no rotation and some movement, only some parts move (but not rotate). Does anyone know what could be my problem? I am not sure what screenshots to post so tell me what you need to see and I'll add some. Thanks in advance.