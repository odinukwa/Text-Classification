Be careful not to ramp up the energy as well; annealing works as the states move slower towards the solution. When reaching a non-solution, instead of restarting one should consider finding the most displaced fraction of points and permuting their positions with their close neighbours. This will allow near-solutions to complete more quickly. The radius of permuted points should probably increase with the number of failed attempts. 

This is not good; don't use dead variables as comments. There are other places you do this; fix them all. Secondly, this once again implies you should be using some kind of higher-level container. 

leaks a file handle. Always (almost always) use for files. Do so in too. The flush here isn't needed: 

I would do: def loadWords(filename="english.txt"): with open(filename) as f: return [line.strip() for line in f if line] and ditch the global. For 

At first glance, the primary problem is that you have too much in the global scope. Ideally, the only globals you have should be constants. This is as simple as 

The cost of caling is low (constant time lookup of a C attribute), so I'd remove that last line and just call when need be. You're mixing and somewhat haphazardly; stick to one. You seem to be using more, so I'll adjust others to that. Now, I'm confused about what this actually does. Why separate out and , as opposed to all other calls? 

This is way faster than before (again). But we can do better; there is a squaring version. Stealing from $URL$ means that the whole summation takes only \$\mathcal{O}(\log n)\$ operations. Here's a table of the maximum sum computable with a budget of 1 second to one significant figure. 

This is a mistiming; you're forgetting that Java has a JIT. JITing the code swamps the algorithm's cost. Allowing the JVM to warm up by running 

These are on top of 200_success' suggestions because I agree with them and there's no point me repeating them. You don't need to write in the tests if it does nothing, so remove that. I find this very confusing: 

There's no harm in doing a bit of parsing at the start since it's only run once. These probably shouldn't be module-scoped, though, so I'd put them in . Now, half of the time seems to be spent iterating over , so you should cache these. 

We'll come to the run-on effects of doing this later. We enter the inner loop and get another encounter, 

Note that your formatting is not standardized; some start with an uppercase and other identical errors have the word-order switched. This should be fixed: 

is operating on Numpy arrays, typing these will not give you any speed improvements. Instead, you should look to either 

This splits your code into two sections; rather you should deal with the same way as you deal with the start and end. The hardest thing is keeping track of whether you've got a next or previous value; helps here somewhat. Suggested implementation 

It's not markedly different, but I would argue that without using a declarative approach to layout there isn't much more you can do. 61 SLOC isn't a lot, and most are dedicated to declaring properties about the buttons, such as strings. 

Oops! There is no simple way of removing this safely, although AST introspection helps. I suggest just not doing this. However, your code seems to crash inside such strings, so this is no good either. As such, you really should be doing this through an AST and proper parsing. You do 

Then we want to go over the characters in the string and add the respective indices to the particular list: 

Note that the duplicates here are allowed, as removing them requires knowing the value of . Further, consider the contribution of x: 

This does highlight a problem, though - you still increment one of them if they are equal. Try instead 

instead of . This is still very slow, though, and you should speed it up by caching the count operations: 

The main loop would be better with an early exit on the check, and it should be spelt (or when inverted). 

Rust doesn't have a equivalent, so you again need to it. Further, chars aren't ranges in themselves, so a bit of casting is needed: 

This code is written very idiomatically, so I don't have any style points. For speed, the first thing to do is use PyPy. That gives a 5x throughput improvement. Then one should consider your algorithm. A quick run with gives 

This is because messes with the internal index in the list. You should always try to avoid changing the length of a list you're iterating over, even if that means dropping idiomatic tools like and using indexes instead. Luckily I don't think this will actually ever hurt you. Note that a 's will get you this much more quickly. is from the recipes, so should be used instead. 

Note that is actually cheaper to calculate at once, simplifying to just . Further, note that we can just compare to instead of to ; given the approximation of in the input this is basically the same as comparing to . Now, this might be problematic if you want to generalize, but there's actually little reason to have a . If the number doesn't stabalize, you'll just get a . That said, I'd actually avoid generalizing too much; a good square-root algorithm is not in this case a good general algorithm. It makes sense to specialize this use-case because you get both speed and accuracy improvements from doing so. A general algorithm should also support several cases you currently don't; look at how works for useful ideas along that line. 

I would also put application of into a function, and stop calling it (in general, most variables are temporary - stating this is pointless): 

This keeps clean. However, you don't want to start with everything available to since you'll never get a that way. Instead, build a dictionary as you go. What might even be better is abusing 's argument with a lazy cached evaluation strategy: 

We expect for \$\mathcal{O}(n^4)\$ that a doubling of size will give a factor-of-16 change; we instead see closer to a factor-of-12 change, or \$\mathcal{O}(n^{3.6})\$. This is probably partially because slices are fast relative to interpreter overhead. As \$n\$ increases, this will likely change. When testing with Python 3 ranges, one gets 

Since you're using and , you should just consider a . This is flat in memory but much easier to use. Before I do that, though, let's consider some nicer ways to write . Firstly, your is disingenous. You never intend to loop in it. You use it here: 

Note that this doesn't actually correspond to an order done the previous way, since triplets are discarded in order, not by an arbitrary sort of their elements. Then there is: 

The dashes don't seem to be particularly useful at this point but do make me a little confused; if you are using them to count elements then why does 

Similarly some of your spacing elsewhere seems inconsistent or excessive. In particular, trailing spaces. 

In theory this has speed benefits for larger grids since you don't need to copy the whole grid each time. It loses this benefit on 3x3s, though, where it actually does more work in the worst case. These changes make it reasonable for to also be a since it's actually immutable. This gives us and for free. can be just 

But then because... why is throwing an ? Surely that's a bug. Before we get there, quickly change this to 

Although this kind of makes sense, it doesn't really make sense. Fizz isn't 3. 3 is just the factor that triggers "Fizz" in the output. You should really be encapsulating the state not over the result (///) but over the input (/, /). Java doesn't have tuples, so let's use , and give it a loose abstraction: 

The slowest part of the code is probably , which involves a prime check. There are much faster ways to do this, like precalculating with a prime sieve. 

The second can never run since the condition is the same, but it doesn't matter as the body is the same too. Just remove the . The same thing happens again with . Are you sure you understand what does? This simplifies the first function to 

You'll see very clearly that the code is buggy. Investigate this yourself, and then come back to this post. 

This is normally frowned upon (this in particular should be written ) and use where not needed is a very dangerous sight to the untrained Pythonista. Use with care. From the the function: 

I would hesitate to implement , and instead implement (and vice-versa). This is because you make no attempt to preserve the rhs' modulo, so you probably shouldn't have one there. Consider the code 

Then you should split into two arrays, which I'm tentatively calling and . They can be initialized as 

You should consider making the first argument - it's a -like argument so normally should be at the start. Finally, consider replacing the edges with tuples, since their length is always . 

You should order your imports. should just be called by convention. and the tiles being loaded should be done inside a local scope like . shouldn't be in capitals. The tiles (, , , ...) should be encapsulated into a or class. This makes it simple to pass around handles to resources without making them globals. You repeat 

The file should be closed as soon as you are finished with it, and the comment should be reformatted. 

You should almost never ; instead raise appropriate specific exceptions. In this case I would use . Don't line break onto the indentation; add a hanging indent. This code is overcomplicated: 

Checking for prime numbers isn't something ideally done in one particular way. Depending on what you're doing, lots of different techniques make sense. 

just tracks . Remove it. is recursive but it doesn't need to be. Try making it a , and make it its results instead of saving them: 

Why and ? You are using haphazard recursion to generate loops. Instead, define suitable functions to guide your loops and make functions self-contained where possible. For example, instead of using , have an outer loop that calls after the game has ended to allow it to restart. This should remove the need to call from the functions (you shouldn't be doing that). Because the game seems a bit underspecified, I wasn't able to bring all behaviours across: what exactly is meant to do? It seems to do nothing. has duplicated logic in the s. Move it outside of the s. This is also duplicated in , so extract it into a function. I would move to new-style formatting ( instead of ). In , you don't need since it's just . You shouldn't give a default to ; it just hides bugs. You don't need a argument to . In fact, I would write it as 

We know it's way faster on CPython, but how does this compare to the original version on PyPy (once stuck inside a function)? 

I suggest inverting the in the array to make this simpler, and then you can just do . Why? Well, it lets us use on Python 3: 

For a more thorough review, I'll point out that your functions aren't equivalent. The first strips whitespace and the second doesn't. One of them must be wrong! In the second case: 

This is evidently too much, so some thought should go into fixing this. Perhaps caching some things might be better: 

is deprecated and removed in Python 3, so it should be avoided (favour ). Plus, you should really be ing over a generator, like 

shouldn't be needed so remove that too. makes a string of the form crops the final and then splits it. You can just do . seems to be what you're merging into, so call it . You use once, so just put its value where it's used. This does nothing: 

are bad; if the programmer needs commenting then the user is going to be confused. The function should just use a dictionary: 

This creates a heap of length-element pairs (equivalent to your list), only with the length inverted so it acts as a max heap and not a min heap. It will yield the most common element that isn't the previous element at any given time, maximizing the chance that the most repeated element will be used up by the end. This is not as brilliant as Antti Haapala's solution, though. 

You should probably prefer as it's less likely to vary on different systems. It's not a big deal, though. You should use , even for , so names like and . Don't call ; use instead: 

You still have global data but you localize it to the function. To me, this seems a sensible trade. Note that and the original were not constants so should not be in ALL_CAPS. Another thing that irks me is your use of strings to represent the board. Tuples of integers makes more sense and can replace your . Strings might be neglibily faster, but it seems like a poor readability trade to me. You don't use as far as I can tell. Just remove it. You do: 

In , you shouldn't need two checks to determine if the human cheated. Namely, the first seems unneeded. I like the use of a higher-order function with . It's very elegant. However, don't abuse it; should not be running the game; that logic should be in . It's unfortunate that you don't get an indication that you lost, or if you lost due to being caught cheating. This would be easier to sort out if more was in and not in the respective classes. You only use each method of in one place with these changes; it makes sense IMHO to make these functions on tuples of digits to remove the need to create classes. This makes things a little cleaner. It also allows one to speed up further. You don't validate the user's input in . also shouldn't be in the business of saying ; that should be game logic. Using to shuffle in-place is fancy but it isn't good. Just use on another line. This all gives: