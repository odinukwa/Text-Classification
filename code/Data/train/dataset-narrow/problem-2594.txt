Measuring the length of a Bezier curve is hard. If you don't mind a slight inaccuracy, a simple solution would be to approximate the Bezier curves with straight lines and calculate the sum of the line lengths. The more segments you create, the better the approximation. 

The "export movie" command exports the currently active timeline as a PNG sequence. You can export any kind of animation, that means frame-by-frame, tweens or shape-tweens. It also doesn't matter if you're animating bitmaps or vector objects... a good rule of thumb is: You'll get exported what you see when you play the timeline within the Flash IDE (hit Enter). Animations within MovieClips won't work. If you have nested animations, your best bet would be to export to QuickTime (which would even allow you to export scripted animations). Make sure to tick "Ignore stage color (generate alpha channel)", choose a lossless codec (eg. Animation) and then convert from QuickTime to a PNG sequence. Your further progress seems fine as it is. Drag the folder with your exported PNG frames into TexturePacker and let the tool handle the rest. Most likely you'll want to support retina displays, so make sure your assets are double the screen-size in Flash or set the stage-size or DPI to double the original size in the export dialog. Also be aware that the maximum texture size on iPhone 3G is 1024x1024 and 2048x2048 on iPhone 4 (since this will use retina assets, it basically translates to the same amount of screen-points for iPhone 4 and 3). Switching texture during animation can be cumbersome and also have an impact on performance, therefore I suggest you don't split up animations to multiple textures. 

Personally, I would also use XML for rulesets or other config-files. There are some other alternatives like YAML or JSON though. These are usually smaller in file-size than XML files (if that's a concern) and there are robust parsers out there to read these files. Their syntax is also closer to CSS if that's important to you :-) 

I doubt that the getter really belongs to the GameOver class, but that's an architectural decision you have to make. Alternatively, you could simply discard the whole getter/accessing via another class and just do the following in your Play-screen: 

Assuming your slope-tile is at a given position (origin is bottom left as in the image). You have the player position and the width and the height of the sloped tile (). and are world coordinates. Given these parameters, your players Y-position () would be: 

TexturePacker does all of the things you're looking for. There's a Linux version but according to this (rather old) post, the command-line interface isn't working yet. I don't know if that has been fixed in the mean time or if it's still an issue. 

I mentioned in my comment to the question, that your assets need little to no modifications, since the iPhone 4 (960 x 640 px) has almost the same resolution as the iPad (1024 x 768 px). If a slightly smaller viewport doesn't have a negative impact on your game, then you can basically leave your assets as they are. In cocos2d, high-res assets (for retina display) use the suffix, as opposed to the suffix introduced by apple. So you might want to add a suffix to your existing assets and create scaled down versions without the suffix if you plan to support iPhone 3GS and older. More importantly though:, the native unit for coordinates on iPhone and iPad is not pixels but points. The screen of an iPhone has 480 x 320 points (if it's a retina display, one point contains 4 pixels). The screen of the iPad has 1024 x 768 points. So while your assets probably don't need scaling, your coordinates are vastly different. You might be tempted to simply scale all your stuff down, but in case of physics, this could result in quite different results (differing object mass, etc.). You should not change your physics-world at all, only perform the scaling on the view (eg. multiply coordinates with another factor () than used on the iPad). If you didn't use any easy modifiable constants to convert from physics-units to device-units, then you'll probably have a lot of work ahead of you now :) Here's an interesting post about creating an universal app (iPad, iPhone 3, iPhone 4). It might help you tackle some of your problems. 

There are two "bones" (or vertex groups) called "LEFT" and "RIGHT". We simply established a naming convention for these bones (eg. LEFT, RIGHT, TOP, BOTTOM, CENTER, etc.) and moved these bones to different positions in code when the model needed scaling. If you need to scale in all 3 axes, you might be better off with vertex groups for all the corners of the model, but even then you won't get perfect results with every type of furniture. In case of your nightstand you could have a bone in every corner (8 corners) of the model. Then you would have to move 4 corners to adjust one side. This requires careful preparation of the model though and you can still run into issues, especially if the center of the model needs special scaling/treatment and with texture scaling. If your app allows the user to upload his own models, then I guess you'll be better off with uniform scaling of the model (as your approach with individual scaling just won't work). 

Regarding that link you posted: The creation of a SQLite Database has nothing to do with XML, nor is XML needed. What you see there is a MXML document, a special XML flavor introduced by Macromedia/Adobe. But the majority of this document is just plain Actionscript 3 (wrapped in tags). So you're going to use Actionscript to create and access the Database. But since you're new to the whole database thing, I suggest you first take a step back and actually learn some SQL. This is going to be easiest by using a tool that allows you to create Databases and run queries. There's even a Firefox addon that allows you to manage SQLite databases from within your Browser. Once you are comfortable with SQL (you can also look up the exact syntax for SQLite here), the step to using this in Actionscript is really small, because in Actionscript you do nothing else than sending SQL queries (so it's actually good practice to learn the query syntax before you integrate it into more complicated code). The help documents over in the Adobe Flash help should contain enough information to show you how to use SQLite in Flash/Flex. Update: Here's a short explanation of the most important SQL commands and when you're typically going to use it in your application. 

From what I understood reading your question, I'm assuming you want to procedurally generate a character, given some arbitrary data. Eg. a given username will generate a unique creature for that user. The way I would go about this is to extract a number from the username (by using something like a CRC sum, or some other form of hashing). Then use that number as seed for a random-generator. As Byte56 already mentioned in his excellent answer, going for a fully procedural approach is going to be very hard. I think it might be simpler to have multiple basic skeleton setups that can be parametrized. So maybe you have an armature for two, four and six legs with some extreme setups. Eg. a humanoid with very short legs, one with normal legs and another one with very long legs. Ideally you would have existing animation data for (at least) the extreme cases, so that you can interpolate/morph intermediate states from one extreme to the other. If you then have a user-name, you would seed the random generator as described above and first do a random roll which basic armature to use. Then perform other random rolls to determine other factors, such as which "intermediate state" to use, "animation speed", "skin color" etc. Even though this approach isn't fully procedural, it will still generate a unique character for every username (given that you have sufficient base-armatures and variations thereof). As long as you just use this to create creatures using a given input and don't allow the users to add more limbs (like in Spore), the outlined approach should be much simpler to implement than a fully procedural character-generator. 

I guess it's because the display-name doesn't matter that much in Starcraft 2. Even if you were about to meet a player with the same name in an online-match it wouldn't be an issue, since there are several other "layers" that help you distinguish players in game. One is the color of the units on screen, another one is the team the player belongs to (in 2v2 or other team matches). Impersonation is probably also a non-issue. This is most likely going to happen where there's a bad player that wants to use the name of a very good player. Nobody is going to believe that located in the bronze-league is actually the real . As soon as you're playing in the top levels, you're most likely opting for a unique name. Since the ladder is segmented into leagues and the leagues are segmented into divisions, name-clashes are also very unlikely. Maybe Blizzard even makes sure that there aren't players with the same display-name in the same division. I think the non-unique display-name can work in every game where the name isn't an important part of the virtual identity. In the case of Starcraft 2 you have an character-code (ID) or your battle.net account e-mail that can be used to find friends. The display-name is just what is shown on screen and can even be changed (a limited amount of times). You might have noticed, that the same is also true for the gamedev.SE site. You can have several users with the same name here. As soon as you have several properties that can help distinguish players and the display-name isn't used as ID, non-unique display-names can work fine. It also has the big advantage that players don't have to search hours for a display-name, because all the "good" ones are already taken. 

All that is left to do, is to connect the signal to the update method (slot). You usually do this somewhere at initialization time, but you can also add/remove listeners/slots during runtime. eg. 

Then you keep track of level-index and load the level file at the current index. If the level is complete, you load the level at the given index. If you always use the same assets and the level-data easily fits into memory, you could preload everything. But since you have intermediate cut-scenes, that isn't really necessary as you can use them to load the next level. Another idea would be to have some sort of "story" or "progress" data file you load. Sometimes you need meta-data that is external to your actual level data.. for example if you have a time-limit on the level. I prefer to not have this time-limit inside my level-data, but rather separate from it, so that I can easily tweak it. Also if your level should have a name, you could put it into the "story" data-file, and this could easily be translated. Here's how such a story-file could look like (JSON): 

Well, all of these techniques are used in modern games. I guess the 3D modeling and rendering to bitmaps has become less popular with the possibilities to use rather high-poly models directly in your game. But any technique is valid. I just recently saw a game where all assets were hand-painted. It looks gorgeous. 

I doubt the string concatenation is the culprit here, but you could always use the CSS property, which is supported in almost every recent browser. Since most CSS transforms also use values (for example: ), you should use raw matrix coordinates. So to offset an element by say you would use: 

You probably want to look into sockets-programming. Here's a basic introduction that will help you getting started. Or just perform a Google search for java sockets and you'll find plenty of material. 

If you need some sort of rewind or replay functionality, it would of course be foolish to remove all the events from the queue (meaning you would have to add them again when rewound). Instead you could also use an array that holds your events. An event would consist of a and . You would have to keep your array sorted by . Then instead of removing items from the array, you would keep track of the current array-index, and with every update seek ahead from that index and execute all callbacks with while also increasing the index accordingly. Implementing a faster playback-speed works with both implementations and would be as simple as: 

Possible candidates are UDK, Unity or ShiVa. These are game-engines and not "libraries" in the common sense. There's no library that covers all your requirements, as each of your bullet point would be a library on its own. 

Objective-C is the language of choice to develop for iOS. But you can also include plain C or C++ Code in there, so you could write large portions of your code in these languages. XCode and MacOS-X provide you with all tools needed to develop such Apps. There's (currently) no easy way to develop iOS Apps on Windows, except maybe a Virtual-Machine or trying to install OS-X on your PC. Alternatively you can also create iOS Games/Apps using Unity3D, UDK or Flash. As soon as you want to test your App on an actual device or sell it in the AppStore you'll also require an Apple Developer Membership. Update: You asked about Angry Birds and there's actually a nice tutorial out there on how to create such a game using the excellent cocos2d framework. 

Checking collision on circles should be easy and has been described very well by Valkea. If your entity amount doesn't go into the thousands, checking all collisions shouldn't be a performance problem, since circle vs. circle tests are very fast. As for the resolving of the collisions: Don't write if-statements for all possible collision types. Consider something like this instead: Each of your Cell-classes has a method which takes a cell-class as parameter. Your collision check could look like this: 

Please note that this affects the texture, not only the sprite at hand. So if you're using a texture-atlas, the whole atlas will be affected by that. But I think this is really useful behavior in your case. 

Then create the different color-variants by setting the property in Unity (which will tint the sprite). 

I don't know how your background looks like, but with a dark background and bright lines, I suggest you additionally set the of your Sprite to or (see BlendMode). With dark lines on a bright background, could be a good blend-mode. Update: In terms of performance, the fastest approach is probably a simple image of a blurred line. But that's not very flexible, as you would need an image for every possible line-length. A vector-based approach (with gradients or different fills) is going to be slower than the glow-filter. These filters are very fast and optimized and will outperform the drawing of lots of complex vector shapes.