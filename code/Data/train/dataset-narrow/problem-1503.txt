I've made an attempt at writing class wrappers around basic OpenGL objects to make managing them easier and more intuitive. Writing a generic one for program uniforms proved to require a little bit more effort than the other objects, due to there being different OpenGL functions for manipulating uniforms of different types. So, I came upon this solution, using templates and inheritance: 

I recently wrote a concurrent, mutex-less (but not lockfree) queue and wanted to know if it is actually correct, and if there are any particular improvements I could make: 

It's platform specific to GCC on x86_64 and a CPU that supports double width CAS right now, but I assume it wouldn't be that hard to adjust it for other platforms. I've stress tested it with multiple threads pushing and popping, with both POD types and with memory-managing types like and haven't had any issues so far...before I put in the double width CAS I encountered the ABA problem and had segmentation faults, but with it it seems to be fine. However, I'm new to all this multithreaded stuff, and wanted someone more experienced than me to tell me if this would work, say, on a system with a weak memory model. 

Do you really need every column? Even with proper keys/indices in place, this will typically force a table scan. Explicitly state only the fields you need to return. It will result in less I/O and could possibly turn a scan operation into a seek. If it doesn't, you'll need to find the missing index to be added. The next thing you can do is remove the duplication. 

First, stop using as an all purpose variable name. It makes your query nearly impossible to follow. Using lambdas does not excuse us from using meaningful variable names. Next, take note that SelectMany takes an , so you don't have to materialize the query by calling . You should be able to simply call it on . Which in turn makes me wonder what exactly you're trying to flatten here. ??? Something doesn't quite sit right there. Typically, you'd call on the property of an item in your enumerable, like in the doc I linked to above. On the same note, this call is completely useless. 

I decided to invert the class scheme: instead of having a class and having each specialization derive from it, I now have a single class which owns a copy of a class that provides the specialized uniform-setting functions. This way, I have static polymorphism without too much complication, and with the same external interface. 

Again, I'm really new to writing parsers, so how can I clean this up and make it more extensible? My next goal is to parse into a tree instead of text-based RPN notation. I figure that won't be too difficult in itself, but I'd also like to later include the ability to handle operators of arbitrary length, and possibly even function names and variables. To be able to do that, would it be necessary (or at least prudent) to write a separate tokenizer? A side question: for implementing a parse tree, would it be a better choice to use an abstract base class for all nodes and implement leaf nodes and operator/function nodes as children, or to use a struct containing an ID of some sort, and a union that contains all the necessary data for each possible type of node? 

This version completes in O(nÂ²) time, with limited memory usage and only random calls. If only the first elements are randomly ordered; the rest are simply an incrementing series. That's unexpected behaviour, so a guard makes sense. As for the random number generation itself, that's a rather complex field. The Linux man page for random(3) suggested a book (Numerical Recipes in C: The Art of Scientific Computing) with a chapter on that topic. A rather infamous example of failing to devise a fair algorithm for this - which also did show the browser dependency in Javascript - is the browser ballot that resulted after a judgement against Microsoft regarding anti-competitive practices in the web browser integration for Windows. Rob Weir's article Doing the Microsoft Shuffle: Algorithm Fail in Browser Ballot covers the details, and is an interesting read. 

I think you minimally owe your future self some comments as to why it was done this way, if not a general rethink about what you're doing here. 

I'm going to go down through the code line by line. I may be harsh at times, but remember, I say these things so that you might become a better programmer. 

Which means that you'll need to modify the signature of your method to be compatible with async/await. 

The first part of the if , so there's no real need for the . Like I said, that's pretty nit-picky and could be considered to be a matter of preference. I don't much care for the style here. 

I've been messing with metaprogramming and variadic templates in C++, and I came up with this very primitive implementation of a tuple: 

maintaining a degree of type safety. I like the interface as it stands, as it does what I want it to do. However, I am looking for suggestions for improvement in the implementation, as it is kinda messy. 

Being template metaprogramming, of course it looks terrible. Are there any ways I can clean it up? I've been picking up the nitty-gritty details of how templates work by messing around with stuff like this, but I'm sure I'm missing something that would simplify this. 

This makes it more clear that after the call, we're no longer working with an , but with an . I've found that people are a bit too quick to overly shorten variable names in lambda expressions. Having a short scope doesn't excuse us from naming variables well. 

Instead of checking for the negative condition, check for the positive. It removes several lines of code and a comment. 

That's poor form whether or not you already have a table scan in the underlying query plan for the CTE. I think you misunderstood the article you linked to. It is warning against doing exactly what you've done here. SQL just doesn't lend itself to code reuse in the way a "regular" programmer is accustomed to. It's a different beast that way, it takes a different mindset. SQL is a set based query language. Code reuse comes in the form of (well tuned) views and stored procedures. If you need this kind of fine grained control over the SQL, then keep it where it belongs, in the database. Depending on just how dynamic your queries are, you may not always be getting the benefit of query plan caching. Each time a query that the analyzer hasn't seen before is processed, it has to generate a new plan, so you'll take a performance hit. Lastly, I left a comment, but I should mention it here too. Be careful using query hints. You may be able to outwit the analyzer now, based on the current data, but the data will change over time. When the data has changed and your hint is no longer the most efficient query plan, the analyzer won't be able to choose the most efficient plan because you've told it not to. Performance gained this way may degrade over time. 

It depends on the proportions of and , obviously, but most importantly on the behaviour of the random number generator. ECMAScript leaves the behaviour of random() to the implementation, so there's no immediate answer; it would be platform dependent. Expressed in Python, because it lets me have less fluff around the algorithm, your two algorithms are basically: 

You'll find that there are many attitudes, but the type of commenting you've shown here is largely only helpful as a language learner. When I look at the code, already familiar with the language, the comments are way too explicit. You've essentially got comments repeating what every line of code does, often overshadowing the more important question of why. I already know that a line defines a function, what the arguments of mean, I can see the number of arguments in the code, and I know that an block has the opposite condition to the . It's even easier, knowing Python's slice conventions, to read as the last word than something involving function calls (). Also, the descriptions of functions really belong in docstrings, so I can look them up in the interpreter. As for naming, there is very little to complain about. and could be expanded, mostly to avoid confusion with the word fin, and the iteration name is a holdover from the old days of interpreters that only handle single letter variables; nowadays we use it to avoid tedious typing, but that's not a good reason when it's only typed twice. A descriptive name such as would be better. The one bugbear is , because that doesn't describe the procedure at all; it seems to do batch processing of files, generating a subroutine call for each line. I suppose that iteration processes lines in isolation, but it's really not clear from the call what is manipulated or in what way. What I'm missing in the comments is an example of how the input and output data in files would look. The actual column format (looks like , where key is an integer, e means encrypt, and message may contain spaces) isn't easily read from the parsing code. We also run into logic mistakes when you remove and from ; you really ought to use , such that it's impossible to confuse which item you're removing. Converting to and from int, and searching by value rather than place, will break for some lines, e.g. . The last comment demonstrates the biggest problem with comments that describe what the code does, rather than what it is intended to do. They invariably get out of sync, and at that point only cause confusion. The code itself could be reduced considerably using Python's high level libraries (for instance, and ) but that is quite separate from the naming and commenting you asked opinions on. 

I'm going to preface this with "I didn't actually try this, and the code may not even compile.", but I think you can greatly simplify your code by utilizing the DataReader class instead of parsing everything "by hand". I'm imagining your routine looking something like this. 

You're returning the that you passed in as an argument to begin with? I guess it also returns other items that match the arg as well. It's not as immediately obvious as it could be. Consider the Linq query here. 

I agree with @Heslacher about this particular statement, but I think it's a bit foolish to say that all s are bad. It's just senseless to use it for what could be one line of code.