Downgrade to Raspbian Jessie. Build GitLab from source using their provided instructions. Try this hack which suggests running to trick the script into thinking you have Jessie. Note that this might be a poor idea in case you mix Stretch packages with Jessie ones, but this option is provided nevertheless if you want a quick fix to try. 

It doesn't look like Mosquitto is available from the backports repository, so you're limited to compiling it yourself, I would think. 

Since you said runs synchronously, you should be able to use instead of . runs scripts asynchronously, which effectively means that the script launches in the background rather than your Node.js program waiting for the script to finish before moving on to the next one. If you try something like this: 

You cannot install Google Play on Raspbian — Google Play only works on Android. It's the exact same reason why your Windows PC can't have Google Play installed — they just aren't compatible at all. While Android is based on the Linux kernel, just like Raspbian, the similarities end there. It is unlikely that Android will ever be ported to the Pi Zero, so you can't simply run Android instead, according to the Google Group 'android-rpi': 

For your specific issue with Fuchsia, you may be interested in viewing Magenta on Raspberry Pi 3. This is Google's documentation of the current state of Magenta, Fuchsia's kernel, on the Pi. It is specifically stated that: 

See the python-mpd package listing in the repositories. For Python 3, install instead (but this will only work for Raspbian Stretch onwards; no Python 3 bindings are available for Jessie). Alternatively, you might consider installing from PyPI via Pip, using: 

Alternatively, you can use the unofficial image which supports the Pi 3 natively; but 18.04 and 16.04 LTS are available. 

The command will have created a directory called . Just delete that as normal (for example with ); essentially, all Git has done so far is download a repository into a directory on your Pi. Deleting that is all you need to do. 

My original thought that it was a global/local installation issue was incorrect. The issue is probably caused by using the package from the repositories instead of directly from Node. On Jessie, v0.10.29 is provided, and on Stretch, v4.8.2. Version 0.10 is from 2013, which is, in Node terms, ancient. JSDoc isn't compatible with 0.10.29 (the Jessie version), but it is compatible with 4.8.2: 

The implementation is for you to do what you like; the code simply illustrates the point that you can serve a web page from a server in this fashion. For a stream of data, you might consider sending the data over a Web Socket. JavaScript can connect to those, so you simply allow clients to run some JavaScript to connect to your web socket, then process the data with P5. 

Converting HDMI to VGA is actually rather more complex than just flipping a setting, as HDMI is a digital protocol and VGA is analogue. You typically need an active converter, like this, to make it all work properly. See also: Can a simple cable convert HDMI output to VGA? 

CryptoNight mining is possible using a CPU-based mining program (such as ) on a Pi, and RasPiNews was able to set it up on a Pi 3. does indeed support pools, as required, and can mine many cryptocurrencies, including Bytecoin. You will need to build yourself, using the instructions given in their README: 

... and press a few keys. If you press your left Alt, and the program prints , good. If it just prints a strange character combination, or nothing at all, press Ctrl+C, change to and repeat. Keep going (replace with and so forth, if that doesn't work) until you find the input that does work. Once you do find it, remember which device file you need. Then run: 

where is the one you put with in the configuration. You need to put the above in , but since there is only one config file, you'll need to also put in the bits for your Lifx plugin. You can do that by taking this bit of the above configuration: 

It sounds like Node RED isn't installed properly after all. Your .desktop file is throwing an error because doesn't exist (not because the .desktop file is in any way invalid or corrupt). I'm not sure exactly what steps you've done so far, so it might be easier to start with a fresh Raspbian image and follow along with the official instructions. Node RED is preinstalled in the Raspbian image (for any version later than November 2015), so you can just use that. It'll be a little out of date, though, so you should also run: 

Most likely, you'll need to pick a language and a graphics library or GUI toolkit. The way that the GUI is rendered on a Linux system is relatively simple, once you understand what each part does. We don't need a really in-depth knowledge of each part, but I'll give you a brief summary, with the aid of a nice illustration I found: 

(you'll need to change as appropriate). This tells systemd that you want your script to run before getty does, and to take the console's stdin and stdout and pass control to your program. It also resets the TTY, blanking out any previous contents. You'll need to enable the service with: 

As noted on Super User, the Pi itself doesn't have a HDMI input port, but there are various products which will allow you to add a HDMI input (either from a USB adapter or through a dedicated HAT like the PiCapture HD1). Be aware that, as noted in the linked question, a USB port is unlikely to have the throughput to carry a HD video/audio input. You would need to add HDMI input functionality (or another multimedia input method), then stream the input into your captioning program in order to process the speech. Note that speech recognition is not trivial for a computer, and I have my doubts whether the Pi would be able to do it in real-time. Google's Streaming Speech Recognition API may well be useful, but this adds network latency in exchange for not using the (slow) Pi processing power. It is perhaps worth testing this yourself to see before committing any financial resources. Once you have your input stream, and have run the captioning program, you would end up with a string representing your caption. You would need to take the video input, add a box with the text in, then send that back to the HDMI output. There do not appear to be many products on the market that do this, probably because speech recognition engines struggle under all but the most favourable conditions; AccessibleTech.org suggest that the technology is simply not reliable enough: 

You can use systemd to run a service before getty can prompt for a login. Create your service by adding a file called in , with the following contents: 

It sounds successful enough. It doesn't matter too much that the current rating is beyond the recommended, as current is only drawn through as required. Having a slightly higher rating (only 12% above the 2.5 A recommendation anyway) won't matter a lot. Note that the turbo modes would not be appropriate, unless you like fried Pi! No, seriously, using a 12 V supply will destroy your Pi. While it probably won't actually ignite (that was a 12 V lead-acid battery which probably supplied a lot more current), it certainly will be a paperweight after overloading it. Fortunately, a brief read of the technical documents (that's for Quick Charge, which is largely the same as turbopower; see the marketing material for a reference) suggests that a device specifically has to negotiate for higher voltage; by default, it'll send just the normal 5 V of the USB standards. 

That video is for installing on Windows. Windows uses .exe files as executables; other operating systems don't. Unix-like systems such as Linux and macOS don't generally use extensions in the same way as Windows does to indicate file type, and usually an executable has no extension at all in a Unix-like systems. The history of that is quite complex, but you can read a little more about the differences here. You should also notice that doesn't exist on your Pi, because that's a Windows path. Once again, different OS, different rules. Probably most important for you when you follow along is that Linux systems use rather than as a separator. None of the above really matters though, because all that command wants you to do is run Python. As you've correctly identified, you can just run to run it on your system. As I mention above, it looks like you'll just need to do minor adjustments to the commands in the video to get it working on Linux. Since you want to run: 

1That said, clusters are very interesting, and if you do have a use case for them after learning more, do consider trying to make one! 

... and press F12. Now, will create the configuration file you need. You then need to edit it with your editor of choice (mine's nano, so I'd run ). You'll see a line like this: 

Looking at the error message, it appears that Erlang is crashing with an internal error ("internal error in v3_kernel"). My initial thoughts regarding the issue seem to have been incorrect, and the ARM build isn't being hung up for the reason I initially thought. In fact, the error message is proving rather elusive. I'd guess that Erlang is either installed incorrectly, or broken somehow. As suggested in a question about a similar internal error, it may be helpful to purge Erlang from your system, then reinstall it. To do this, try: 

It appears that is a cross-compiler to ARM (from x86), i.e. it allows a fasm installation on an x86 machine to compile to ARM machine code. While FASMARM can compile to ARM machine code, it doesn't allow fasm itself to run on ARM. Since fasm is written in Assembly, this makes porting it or compiling it for ARM challenging. I would not expect there to be a way for you to run fasm on your Pi. You might be able to try compiling the code you have with a different assembler that is available on the Pi, but note that assembly is not always compatible between different assemblers. It may be wise to check the project's documentation and see if there is already a way to compile for the Pi, or ask a new question on this site otherwise. 

If the steps you're following are incorrect and do say vevn, you should let them know. If you've just misread the package name, you can just install the correct package and continue without any issues. 

This will read the systemd journal logs for your service. just gives you a brief summary of whether your service is functioning; it's not the full log. 

suggests you have a 64-bit version of somehow. If you tried to replace it manually with a different version you found somewhere else, that's probably the cause of the error. Generally, replacing system shared objects is unwise as you never know what depends on them. If you are unable to replace with the correct version for your operating system (Raspbian is still 32-bit as far as I'm aware), you will probably need to start with a clean image. version 4.9.2 in the repositories is available here if you wish to attempt to extract it and replace the .so file with the appropriate version. Note that you need to copy both and for this to work properly. This is at your own risk however; if you have valuable files, save them before doing anything further. 

This will send an email to , with the attached image, and a subject of "Subject". The body will be empty (the file to the right of the is the body of the message; replace it if you need to). (Optionally) Put this all in a shell script so you only have to run one command rather than remembering two more complex commands. 

It appears that GitLab only build packages for Raspbian Jessie, not Stretch. You can see in the repo link from the sources file that all the recent releases are tagged "raspbian/jessie", which is bad sign. I did a bit more searching and this issue confirms that's the case; builds are only available for Jessie at the moment. Your options: 

It's worth noting that is run by root, rather than the user which you are likely using at your terminal. It seems likely that your installation for the module is installed only for the user, and hence when root runs the script, the module cannot be found. If this is the case, you have two options: 

Debian (and, by extension, Raspbian) is comprised of free software. One of the core tenets of free, open-source software is that you should be able to modify and distribute changes to the code you have, so it is natural that you're allowed to modify Raspbian and redistribute your changes, under certain conditions. Debian actually publish some guidelines on what you should do if creating a Debian derivative; notably, you cannot call your distribution "Debian" or in any way infringe on the trademark. I do not believe Raspbian is officially a registered trademark, but it would still be good etiquette to change the distribution name to avoid confusion and any doubt about the legality. Note that Debian packages are distributed under various licenses such as the GNU GPL, BSD license, and so forth. If you've made modifications to these programs, generally, you will need to disclose your changes in public, or offer source on request. The terms depend for each license, and not all packages use the same license. If you have simply used packages from the Debian repositories, you will probably not need to do anything additional to attribute the packages beyond the mechanisms already provided by Debian (such as checking licenses with APT). See also: The Debian GNU/Linux FAQ — Redistributing Debian GNU/Linux in a commercial product.