I haven't looked at the whole code in detail, however two things stood out. push Because of the nature of the list, I can't help but wonder if should return a value to indicate that it's started overwriting existing items. This could be useful if the client decided it needed to slow down when this occurred. copy bug Because you're using raw pointers in the buffer, you want to make sure you protect them. At the moment, you can cause issues if you assign one instance of the buffer to another one. 

Implementing these two basics would go a long way to making your code easier to follow. For example, your might be people?!? You could have a method , which took in a list of people and returned the time. Whilst your variable names might have meaning to you, they have no meaning a new reader without context. One final point is that whilst you can do this: 

All the Twitter stuff shouldn't be in the controller, rather in a utility class. This makes testing easier, makes plugging in implementations easier, makes extension easier, and so on. Also, should be already adding the if truncation was necessary. Personally, I prefer Amit's answer. IMO it's easier to read and more obvious than mine. I would probably tighten it up a bit after an initial review to something like this: 

Min/max position locators in class This is essentially the same as the previous suggestion to use , but I'd still wrap it all up so the mainline code doesn't have to see how it's implemented. This way or that, it's significantly cleaner, with an appropriately-named . 

This is quite nit picky, but I don't like the way that you've got multiple classes in the same file. Whilst the underlying protocol is shared between the Client & Server, they are distinct and having the classes in the same file makes it difficult to follow (if I search I always have to check the owner of the method I'm in rather than relying on the file). This is made worse by the fact that you haven't grouped the implementation for each class together. If you really want to do this, then at least group the methods for each class together. At the moment, the constructor is at the top of the file, followed by the Client methods, then the Server methods and then the rest of the ProtocolHTTP methods. 

It's formatted to highlight the similarities between the two, another option is to use string interpolation again, but it seems redundant in this particular case. (Obviously the string creation would go into a method in some sort of support decorator etc.) All the above is untested, but probably close. 

IMO the amount of extra work/code to remove the method from its rightful place (a method of a collection) isn't worth the effort. in bounding box The and utility method could live in the collection, too, if the bounding box class isn't yours to finagle. 

For me, these things progress in stages. The first thing I noticed was that the logic of the two chunks was identical, just using different values. In my head: 

This alternate calculation of is not especially interesting in itself, but note that can be computed: 

is shorthand for , so if is undefined (), as it is here, causes ; if is already defined as an array (so is neither nor ), is not considered. Alternatively (as @Nat mentioned), we could substitute for following . Next, is assigned the value . We compute 

My answer is concerned exclusively with the algorithm for computing the best solution. I attempted to find one that is both efficient and easy to follow. I am confident I have succeeded on the first score, but will leave it to the reader to judge how it fares against the second criterion. Code 

Don't put type into name ( etc.) Lose the Hungarian; appropriately-short methods remove its utility. Create an and method to get specific coordinates. Create and methods in a taking an . 

Shorter is good, but which reads nicer? Which is more communicative? With static imports, you're still left with: 

Essentially the same if needs to be in the collection. My quibble with having the method in the bounding box is that it makes getting the position a bit bulky; I'd actually prefer this: 

Justifications (working backwards) PageAreaCollection Static utility methods strike me as un-OO, particularly when there are other options. Create a type, with type-appropriate methods: code shrinks, and reads better: 

I think it's unlikely that interviewers are expecting you to write perfect code up on the white board. The main goals of these tasks is to get an insight into how you go about solving problems, knowledge of the language features and attention to detail. You can demonstrate attention to detail by writing 100% correct code, however you can also demonstrate it in other ways. My starting point is usually to clarify the requirements with the interviewers. You can do this in the context of unit testing to help identify some test cases that you are considering and getting them to clarify what the expected outcomes from those cases would be. These can be added to the board so that you have a reference. So, for example: 

The function is very long. Functions should do one thing, do it completely, and do it well. Long functions are difficult to reason about. Move the subject and pupil data entry into separate functions to isolate the functionality, and streamline the mainline code. I'm assuming the presence of and methods, each containing the code currently in the mega-function. Naming conventions Minor, but you call an instance of the class , which is confusing at best, misleading at worst. Non-static-final variables should always begin with lowercase letters. Use typed collections should return a (or ). (Or at least a properly-typed array; nothing with s.) Reduce the amount of code in conditionals There's a lot of code in block that loops over the school's subjects, most of which is the block for when the subject is found. In order to understand what happens if the subject isn't found, I have to scroll down to the end of that block, make sure I'm reading the indentation correctly (assuming the indentation is correct), only to find there's nothing there. In cases like that, might as well do a negative test and , slightly "flattening" the loop's guts. (Code turned on its side is not a graph of how awesome it is ;) That said, this functionality is available in a method--looping in the mainline code isn't necessary. See next. Localize functionality Deciding if a school has a given subject should be moved into the class, for example: 

I've only looked at your unit tests, not your actual code, but there are a few things that stand out. TestCategory It seems odd that you're marking every single test with a category that is essentially the name of the class being tested. You can sort tests by class name, run tests by class name, so it just feels wrong. I tend to use categories for cross cutting tests that have a similar purpose that I might want to run / exclude from test runs. So, things like "Integration Tests", "Database Tests", "Some large feature Tests", etc. Duplication / Framework choice There's quite a lot of duplication in your tests. Some people like to be explicit about what they're doing, so don't like breaking down the tests into common method calls. I don't know how tied to MS test framework you are, however other frameworks like NUnit make it quite easy to maintain explicit testing whilst reducing duplication. For example: 

I have formatted the numbers to make them easier to read and also added three statistics I thought might be of interest: 

To see where each search terminated, divide by , round up and subtract . For example, for , this would be: 

Initially, ball is at offset in . If , it is offset zero, and therefore will remain at that location. For any other ball , after one rearrangement if will be at offset: 

Edit: I just completed changes to the code and explanation to fix problems that @Jonah spotted. Thanks, Jonah. I believe it is working correctly now, but I hope readers will let me know if they find any other problems. I have just a few comments about your code: 

You only need 1 terminating null at the end of the string. This is already accounted for in the size of (since you declare it as a string initialized ). You can simply allocate: 

If it is only concerned by the clicks, then great, you only need to worry about clicking the mouse. If the program does care about the movement then you might want to think about using the function, which supports an additional parameter . The default speed is 20, with larger numbers being faster so increasing the number should either make the function return faster, or allow you to wait for less time before clicking. Depending on whether the movement is async, you may also find that you need to wait less time for shorter movements (i.e. the mouse will get from 8 to 7 faster than it will get from 8 to 1). Clicking the mouse After you click the mouse, you wait before doing the next thing. You may be able to make it so that you don't need to wait as long by using playing with and passing in different values for which is how long the mouse button is held down for. Alternately, depending on how your application works you may be able to detect that the mouse click has been recognised (because some pixels have changes from red to green for example). The library appears to have a few functions that might support this or would appear to be good starting points. You could then loop until the click has been recognised, rather than waiting.