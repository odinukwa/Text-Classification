Where are the doc comments? Your naming is intuitive, the formatting familiar. If you used (thanks, h.j.k.), I wouldn't have considered factoring out histogram collection. If using s that can be constructed with an expected size provided, do so. I'm convinced using one histogram is better: smaller memory footprint, no need to "filter" entries. Downside: separate s opened a promising opportunity for concurrency where my half-assed timings indicate adding a to h.j.k.'s approach to just slow things down. Using a sorted vs. a fast one and sorting the results is an interesting choice. You can combine both using a modified counting sort: 

Docstrings with every method: Way to go, document , too and revisit PEP257 for details. Your tackles the same task as module using much the same strategy, and you express dissatisfaction with run time - a side by side comparison: 

is on the long side. If you factor out recreate_node_array() (under a better name), you can return early from that avoiding the repetition of . Guess confused me - oho: following the pseudo code in the Fibonacci heap chapter of CLRS quite closely (consider referring to that near the top of the questions). 

Naming: is weak - it has a doc comment (way to go) suggesting or . Contracts: doesn't follow 's "strong recommendation" to document the inconsistency with (I do that on both class and method). : could be different for and with . I suggest . Tactics: 

Note the order. Start readable. Start with What shall this be good for?: (doc)comment your code. No slower than what? A "well known implementation" for reference and as a base-line would be useful. Things I liked: 

The very first line of the code presented features a strategic mistake: This is an undocumented not implementing an : "no one" will ever be able to provide a drop-in replacement for any implementation, let alone pick it from the likes of trove or Goldman Sachs collections. "Hearing" list-of-strings in a Java context, I "see" . Looking at what interface specification there is, I see a lot of (just as Timothy Truckle did), and a bit of : I'd willingly take serious a implementing if it extended a "standard" implementation: just consider supporting streams. I follow the concern regarding (the very first conditional statement prevents fulfilling the comment above), but beyond insisting on monotonicity, only seems guilty of not using (just as ). You claim (without providing a MCVE (which would likely render the question OT on CR)) - I'd look elsewhere: what about decreasing twice? A nice touch would be copying the beginning of the array up after a removal if it was shorter than the end. And using any unused indices at the beginning when adding (hey, half-way to circular buffer). I'd let petty concerns lie if it wasn't for - just don't get into a habit of (ab)using like that. 

Doc comments for public methods are indispensable. I'd probably just use a foreach-loop and a DIY stack: 

You noticed that just the last bit of the value of SimpleFunction is used in the described check, and implemented using an "early-out" encountering the largest common digit. Apparently, this uses O(N1 * N2) evaluations of SimpleFunction. (I failed to find an analytical approach promising to be much faster for just shy of a million pairs.) The evaluation of SimpleFunction better be fast - you seem to plan to cache function results, an do back-of-the-envelope calculations of the resources required. The impact of memoisation depends on the time taken to (re-)compute a result and to retrieve it, respectively - let's try to make computation fast. The signatures for the digit strings are the sets of digits used, in a normalised representation. As long as is no larger than the number of bits handled in a basic operation, this can be handled as a "bit set", allowing fast intersection (bitwise and), union (or), â€¦. With nine digit values allowed, there are 29(-1) possible combinations: one could represent the baskets with 2*511 10-bit counts, one for each possible set of digits, instead of 2*1000 9-bit signatures. To check if SimpleFunction for a pair of signatures would be even, get "the and" representing digits common to both strings, find the highest common digit using or some such and map to even/odd. 

(I am under the impression this question justifies three largely independent answer parts: 1) documentation/description of the approach chosen (and the analysis leading to it) 2) problem analysis 3) coding (and maybe 4) asking CR_). I don't quite feel like doing every part justice.) In the first revision, there was no description of your overall approach; in particular, not in the code presented - try again, top down as many levels as needed, using what documentation tool support there is for C#. For "everything" in the code, document what it is to accomplish. If any one description needs more than "one screen" (cannot easily be viewed without scrolling), it (or the entity described) probably is too involved an should be broken down/simplified/shortened. (A "page" of about 65 lines by 80 characters is a lot, a FORTH screen used to have 16*64 (my #1: polymorphism support).) For lack of documentation, your approach and analysis has to be second guessed from the code. (I will use signature where you used hash (which I imagine different from the use I have seen here).) For each test case (not intending to give iteration through test cases notable attention): 

I am having trouble getting this to be more scalable. Adding a row/column would currently require adding another two lines to the code, so for a larger number (128 / 256 positions), this would become unmanageable. Also, for each added row, the print() function in draw_graph needs another line. If anybody has any suggestions on how to simplify the graph matrix or draw_graph / update_graph functions, or otherwise on how to improve the code, I'd love to hear. 

Getting this right is possible, but you must be willing to spend time and effort to do research, lay out an API, and document it. 

Unless you plan on extending the class with methods, is superfluous. A is enough. Move to the body. Try abbreviating names less. While abbreviating is customary in other languages, in Python, developers should be as verbose as possible (within reason). Make functions and attributes private when it makes sense. Especially when you're designing a public API, you want to hide away all the unimportant / difficult to comprehend stuff. For example, in , all the arguments should be private attributes, because developers should not be allowed to modify them after initialization. Add docstrings to public functions and classes. 

What follows is a list of things I think you could improve on. I am not a C developer, so feel free to correct me if I'm wrong. 

Don't use If you need to clear the screen, you can do something like where is the vertical height of your terminal. You could also use a carriage return. This has the added advantage of being cross-platform, as opposed to system calls. Questionable code Here's some things I thought were quite unusual: 

Most of the code is docstrings, so I'd appreciate if anybody has remarks regarding the documentation. Also, the security of a session depends completely on the implementation of the developer. Is it worth the trouble designing a truly 'encapsulated' class, or is this design okay? 

Yes and no. Your approach works, and it is easy to understand. If, however, you want to keep track of what type of exception was raised, it could be improved. What if you have some super complex function that can raise 10 different exceptions, and you need access to the exception traceback if something goes wrong? You'd need 10 instances. In that case, you should use a instead, which is thread-safe (untested snippet): 

You can massively simplify this by using regular expressions. Python includes an efficient module for that, named (short for regular expressions). In this case, check if a given string is a valid credit card number (): 

Rewritten I've rewritten your code to be easier to follow and read. I've avoided using functions (but seriously, learn functions, they're helpful). 

Using wildcard imports () is discouraged for a number of reasons. For one, using wildcard imports can cause conflicts if two symbols with the same name, defined in different namespaces, are imported into the global namespace. Secondly, for other developers, there's no way to quickly tell where an object was defined. PEP-8 proposes sorting statements alphabetically. Unless you have compelling reasons to use Python 2, switch to Python 3! Version 2.7 will only be supported until 2020 (see PEP-373). 

Appendix: Design API design Since you plan on matching PyGame's functionality, you should take the time to think about how you want to design your API. You've taken an event-driven (callback functions) approach, which is probably the most sensible thing to do for user interfaces in general. As it stands, though, the caller can't retrieve the return value of the callback functions, which means in more complex cases, you'd have to modify a shared variable, which can get really messy, really fast. And I haven't even covered threading yet. Interrupt handling If I press Ctrl-C, I get a bunch of traceback lines, but more importantly, my terminal is still in cbreak mode. Once your codebase starts growing, it becomes tiresome to wrap every call in a -block. You could put the block in , but that would mean a forceful exit any time the user presses Ctrl-C. Unfortunately, there's no trivial solution. Backend I have my doubts about the UI backend: 

Functions You can greatly improve your use of functions. For example, you could wrap the game logic into a function called and call that. The same goes for your 'main' loop, which can be wrapped in . Improving 

No, it is not mandatory to use . Your observation is right: calling might make the thread hang indefinitely. 

I've written a primitive Python script which "draws graphs" based on a list. It works, but it's a lot of lines for what I am trying to reach. The idea of the script is to function as a module that can be imported for a quick visual representation of data. Here's nextgraph.py: 

This is a very nice implementation, and in fact will be just as fast as the sun one since over an Array internally uses a style approach. The problem with it is that it is not compatible with earlier versions of Java since the loop is a recent addition to the language. Micro optimisations You will see this term a fair amount in this sort of discussion and in general it can be read to mean "something that makes such a small performance increase that it is not worth the increased code complexity". In the usual development scenario keeping code simple will reduce bugs and increase developer performance in terms of functionality provided for time spent far more than the micro optimisations can increase application performance. In fact in some cases micro optimisations actually degrade performance as they confuse the compiler which otherwise would make the same or better optimisations behind the scene. "Premature optimisation is the root of all evil" - Donald Knuth This is a well known quote in this field, although actually if you go hunt down the full quote there is far more to it than the catchy tagline. As a developer you should focus on writing clean and well structured code and on the big optimisations such as choosing the right algorithms, data structures, etc. Once that is done if you still need to increase performance then assuming you have the right algorithms and data structures (which will save far more than any amount of micro optimisation) that is when you look at progressively finer optimisations. But keeping the code clean and readable will gain you far more in the long run...quite apart from anything else it makes it easier to get the algorithm right! The core Java libraries are a special case as every single Java program is written on top of them, so slow performance there slows down everyone...and they have to run on every single JVM so they cannot rely on clever compilers or virtual machines. In many cases the core Java libraries are a bad source of coding examples. Partly for that reason and partly because they were written when Java was new and people were still learning the best ways to do things. In fact the book "Effective Java" by Joshua Bloch uses examples from the core Java libraries as things NOT to do. That's an excellent book by the way, you need some Java experience to appreciate it but I recommend it to all developers with a year or two of Java behind them. 

I would try and approach this more generically. Define a rules interface, run each section of the string through the Rule and add the result. The rules can then check individually for all caps, exclamation marks, etc rather than hard coding it into your central method. (i.e. a rule that returns 1 point for every exclamation mark it finds or something). Might be worth having two types of rule - "full string rule" and "word rule". the full string rule can process things like total number of exclamation marks and stuff, then you split the string on whitespace and run all the found words through the word rules. For things like nice/nasty words I would have a configuration file somewhere listing words and a positive or negative score next to them - for example please -10, swearing +10, etc. Your word rule can then scan your words against that dictionary and apply the result to your score. 

The separate variable h is needed for thread safety. Otherwise you could potentially have a second thread see a partially computed h (or as already mentioned have two threads calculating a hash at the same time and interfering). Both will break things badly (for example inserting a string into a HashMap with the hash wrongly calculated and you will never find that String again). Copying value to val[] looks like a now-obsolete micro optimization. Again the immediate check for the array being empty is a micro optimization to handle the empty string case without entering the loop. 

In general for OO programming you separate out code into objects and each object focuses on doing one thing and doing it well. Each object should then generally have it's own source file in your code tree. 

You are using a lot of different variables to store the objects in and declaring them for your whole main method. If you really needed four it would be better to have an array of but in this case you are better just having 2 (maybe still in an array) but only create them when you actually need them and set them to the right type then. By using the array that then lets you change the player 1 and player 2 while loop into one for loop to run over the array[] and you can remove all that duplicated code. It also lets you support any number of players virtually for free. For the loop you can use a do-while loop as you know you always have to run through the loop at least once. It would be more efficient to use one Random object created in Main and then passed into anywhere else that needs it. Other than that your Pile object looks fine. Your Player object is a classic case where inheritance should be used. Create an abstract base class Player and then create subclasses HumanPlayer, ComputerPlayer and SmartComputerPlayer (the computer players may or may not also have a common ancestor). Then you just have a Player object reference in your main class and it calls the relevant method in that - which gets sent to the right subclass automatically.