Or, as suggested in the other answer, test the number modulo 4 to figure out which path to take and avoid recursion all together. 

Decrement The next challenge is to find the digit to decrement. This turns out to be simple: decrement the first non-zero number on the right... 

With this approach, the same result is achieved, but with much less code. Combining this all into a single function yields: 

The biggest improvement you could make is to generalize the two-gram, three-gram, and four-gram functions, into a single n-gram function. This can be done with using lists instead of manually assigning , , and so on. 

Notice that this isn't contained within a because there isn't really a need for one; a method does the job better. Also, I made some (bad) changes to make the algorithm less readable. This new regular expression counts the number of 's that occur successively starting from the second-to-last digit backwards and replaces the old loop, the at the end absorbs the original . Now, if we really want to make things unreadable... 

The first thing you expect from a queue is to be able to , and for some reason you are hiding this function by declaring it where this should be . Do I really need to care about growing and shrinking the array in this queue, I am not supposed to know that they exist, so these should be declared . 

. note that your connection is never closed, and thats a memory leak, you could make your class and close the connection there. 

Note that here I am using instead of string concatenation, YOU SHOULD always use command parameters to avoid . Moreover, the proper way for closing a connection is not calling explicitly nor calling it in a , the proper way is using statement. And as mentioned in previous answers your queries can be reworked to stored procedures that accepts parameters from your application, and there is a lot of benefits from doing that. 

In addition to the recommendations suggested by @Austin, you could inherit from to create an object to register and recall your functions. For example: 

Iterating backwards was smart, but, yes, there is a much simpler way to do this using a list comprehension â€“ this is how one typically filters a list in Python. 

The code itself is rather concise, but the weird data-flow out of the function makes it difficult to understand what's going on. This is complicated because the function is recursive and so you then have to keep track of the calling stack when figuring out how is being changed. I don't think the module is really necessary here, I bet that it is heavier that just searching for strings and doesn't seem to offer any benefit. I've kept it for now, but I might offer another solution without it. Here's how I would approach the problem: 

Your code will be easily broken if someone adds a node to the , and your code should be as flexible as possible. Never do such an assumption (It's gonna be the first node) Your method is blocking, consider making it . 

And now you are sure that suit always has a valid value and there is no need for the error msg in the method. Your in the Card class is not type-safe, it will throw an if the passed parameter is not a Card, You can instead implement 

Because of the short circuit here the function will not be called if value is , which is not the case if you pass the object directly. 

You mentioned OOP, and thats great, and OOP is all about code reusability and extensibility,and this code is a good example of a Candy Machine Interface. And that is, users of this class might do mistakes while using it. users could call the static the method before calling instance method and this would lead to wrong routes because weights weren't computed properly. You should try your best to force right behavior. 

Sort But wait, this decrement function suggests that we turn into and turn into . This clearly isn't correct. While the outputs are larger than the original and the digits sum to the correct value, they are not the respective minimal solutions. However, if we sort all of the digits after the incremented digit in ascending order, the minimal solution is achieved. 

Since will always be by the virtue of the list not being empty (as previously checked). This second line is equivalent to 

We can't increment the because decrementing any other number would result in a number that is less than the original. We can increment the , because we can then decrement the . From this, we learn that the right-most digit should not be incremented. 

I echo both of the previous reviewer's sentiments, but I'd also like to add that regex is overkill for the parsing here - will work just fine. Implementing this and some of the other suggestions might produce code like: 

This code here is a bit dodgy, you shouldnt never trust values you getting from the , so you got to handle the exception and refuse the request if the value is not parsable to 

Generics would be quite useful here, because your only works with , so your classes could be reworked to take type parameters 

has a high dependency on , why not to inject it and make the code flexible (easier to test and change). 

When you see yourself going and editing the same function again and again to extend its functionality then thats a code smell. The problem is that whenever you add a type you have to add an if condition to your converter. So the conversion could be the class responsibility. in Java 8 you can use for that and if you don't have Java 8 then is your friend 

To be honest, I didn't read through your code much because I don't have the attention span and it seems the biggest issue is the approach rather than the solution. Nothing about your code looks terrible or un-Pythonic, so I'm going to go through a different approach instead. The first thing that I noticed about the next number is that all but two of the digits of the original number remain unchanged. When going from to , the was incremented to a and the was decremented to a . When going from to , the was incremented to a and the first was decremented to an . This pattern suggests that we may be able to increment one digit, decrement another, and arrive at a solution. The first challenge is to find the digit to increment. Increment 

Threads??? Once you have threads in your code, your code becomes obsolete even if it was written 2 seconds ago. are the way to go, and you can easily replace your code by a single Task that keeps running and a function that accepts Tasks 

I wouldn't start this Task in the constructor as you doing with the ,thats quite dangerous, I would rather have a method called Start that does the heavy stuff where I am sure its gonna get called after the object got constructed properly. ADVICE: Such a data structure is reasonably hard to implement properly, I would try to find something implemented and tested. 

You using for everything and hence no type checking. You shouldn't be able to compare oranges with apples, and the solution is simply to use generics. One more thing your code doesn't is convenience, what if I want to check if this value is equal to a value that a I can get from a method or from a different object without doing eager execution, and the solution is using lambdas. 

One immediate, fairly significant improvement that I see would be to calculate and outside of the loop in . This provided a 30%-50% reduction in time in my tests depending on the computer and Python version. 

Finally, we want to create a decorator which will do the following things: (a) create all of the objects, (b) generate and enter the required contexts, and (c) execute the supplied function. 

To address the recursion depth error, you could either change , or you could rewrite your initial solution to use as an argument to avoid the global variable. 

I don't really understand what this function is doing, but it seems messy and could likely be improved. Then your function can be greatly simplified. 

With this one change, you've gotten rid of half of your code and now can work with five-grams, six-grams, and so on. Making some small other changes, many of which are noted above, cleans up the code pretty well.