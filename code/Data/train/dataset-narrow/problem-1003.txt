Yes, you don't need break if you are exiting or returning. Having a default is still a good idea though. But you shouldn't exit. Helper functions and classes in general should not exit/die, they should throw exceptions or return false. If you just die, the calling function has no change to recover, thus making the function hard to reuse. 

I don't think so. But generally, you can see that yourself, when you enable warnings in development (don't forget to turn them of in production though). 

Error Handling First of all, your return values are quite confusing. If you were to check them, you would get code like this: 

You could also replace the assignment with two statements, which might be easier to read. Also: your approach with iterating over the string and using is quite complicated. Just use to check if a string contains another string. And just out of curiosity: how would you pronounce or ? 

Storing data in session $_SESSION isn't really the right place to store temporary data like this, as it is global and only meant to store data across requests. I think that you are doing this because it makes it easier to see which values are safe, and which are not. If you don't want to switch to prepared statements (which you should), you should use some other means of doing this, such as storing the values in your own array or appending "safe" to the variable names. 

So you have a wrapper that slightly renames the functions of PDO, adds very minor changes ( can be or ), and limits its power (lots of functions are missing). Additionally, your comments are not nearly as in-depth as the official PDO documentation. The PHP documentation is often not great, but still, for eg fetchAll, I can read what parameters it accepts, what it returns, etc. Yours only says . So now I have to look into your actual code (because I can't trust that it does exactly what does). This may easily create confusion. At a minimum, I would stick to the original names (doesn't really matter if yours are better or worse, PDO is quite well established, so most people will be familiar with it). But really, I'm not sure that it is worth it to have a class like this. Everyone who is newly added to your project will have to get familiar with your not-quite-PDO class. If it's just this one class, that may be acceptable, but if you handle similar situations the same way, and always create thin wrappers that slightly change how the details of something work, introducing new developers to your project will be difficult because they will have to put a lot of work into getting to know your code base, and they may introduce bugs (because they assume that your wrappers will work like the original thing, while you slightly change the behaviour). Misc 

I think that your feeling is correct. I could for example imagine multiple usages for the function , but the way you are writing it, it can't really be reused, as it needs the value to be set. Ideally, the signature would look like this: . I also just noticed that it doesn't actually get the user, so which then returns true or false would be more fitting. 

This isn't very easily understandable. Sure, it updates some table, but a reader has no idea what exactly is happening without looking at the code itself. If you go with something like a query builder, you might get code like this: 

as well as are user controlled and inserted directly into a query, opening you up to SQL injection. These two queries are likely not vulnerable, as the partly user controlled values and are created via , but they still do not follow best practice: 

Unnecessary Operations in Loop You also have some operations which you perform quite a lot of times, for example . You could extract that to directly inside the x loop as well. Unnecessary Function calls Function calls aren't free, so in performance critical code it might be a good idea to avoid calling the same function a bunch of times. You could for example try to save the result of in a local variable. Data Structure Transformations You perform a lot of transformations from one data structure to another. For example, is a linked list, which you then transform to an array, which is then transformed to a float buffer. Try to reduce the amount of different data structures you use. Misc 

The advantage of this approach is that it is rather simple to write for you. The disadvantage is that it is rather difficult to use, especially without very good documentation. An example for a query builder may be this: 

Check input Your comments mention that shouldn't be null, so it's best to make sure that it really isn't: 

@Vogel612 already provided you with very good feedback, I just have a couple of smaller points in addition to that. 

I would pass the object to the class in the constructor instead of using . It looks cleaner, and it would make writing unit tests a lot easier as well (you could pass a connection to a test database without changing the code or mock the PDO class). It also has the neat side-effect that you are able to define the type and thus enable auto complete. Misc 

You are still recreating the if-structure, just with a worse syntax. Performance I did not profile your approach, but in many situations, the extra cost of the additional function calls for the simplest of basic expressions will be noticeable. Misc 

At least for now, I did not look at improving performance or at the general approach, but at some more basic things I think would improve the readability of the code. vs Constructor It seems to me that takes the role of a constructor here. In that case, I would just make it a constructor instead of making it a method. Sure, this would result in the creation of a new object, but it would result in cleaner code (the would always be a valid object). Naming First of all, in Java CamelCase is used instead of underscores. It's always good to follow the conventions of a language, so for example should be . Variables should always have expressive names, but this is especially important at class level. Your names wouldn't tell me the difference between and for example. is also not a very expressive name (I cannot think of a name that's a lot better, but even or would be better. For consistency, should then be changed to the same name). could be , , and could be . should probably be and also should get a more expressive name (something like ). access modifiers Your fields should be . Your should probably be as well. The method is private, and not called from within the class. But it is the main parse method. This seems wrong, I would make it public. Unused Fields Defining fields and then not using them is not good practice. You should remove , , , , , , and . I see that you do use these fields in a different context, but not in your parsing code. So I would create a new class for them instead of tagging them onto this one. You should also remove and change 

An attacker could read .doxc files outside of the (if the FTP server allows this, and if the local server is writable at the given directory, both rather big ifs, but I would still protect against this). Security: SSL Your FTP connection will not be encrypted, meaning that a theoretical man in the middle can intercept your FTP credentials or the transfered files. This may or may not be a problem for your use-case. An alternative would be ftp_ssl_connect or using sftp (see also here). Security/Funktionality: DOS & Performance From what I can tell, each time I visit the website containing the form that lists files I can join, you open an FTP connection and retrieve a list of all the files (which may be quite a lot). A user (or multiple user) may accidentally or on purpose reload the form a bunch of times, causing performance problems. I would definitely profile this and see what strain it puts on your server. It may make sense to cache the list of docs locally (if it doesn't change that often). Usability / Bug / Security: File Listing Your mechanism will hide all files which contain a dot in their filename, which may lead to hard to trace bugs. Your current mechanism may also have security implications, as files with no extension (for example ) are listed as well, even though they shouldn't be. Instead, I would probably use an approach such as this: 

This means for anyone, for the group, and for the owner. The problem is that the owner is the webserver, as the webserver is the one creating these files. To make the directory actually non-executable, or similar would be better. Misc 

What you should do is check the file extension as well as the actual file type. The functions that are generally recommended for this are and respectively. Ideally, you should use whitelists, not blacklists. It is a good idea to additionally forbid execution inside the upload directory, ideally by using server configuration as well as OS configuration, but this should not be your only line of defense. 

I wouldn't go that far. I think that the code generally looks fine. Style The indentation and spacing is generally fine, but sometimes it is inconsistent (2 vs 4 spaces, spaces around ). validate I would validate right in the constructor instead of in a public method, because someone might forget to call the method, and then you end up with an invalid object. And as has side-effects (it doesn't just check the string, it actually changes it), I would add a JavaDoc comment. removeSameWord Is this method really needed? Your database schema should be able to use a unique constraint to not allow duplicate rows. Or, since you are using , you should also be able to just remove it completely, since merge updates existing entries. Naming 

Sure, why wouldn't an attacker be able to do that? You can test this yourself, either by writing a short script, or using a plugin such as tamper data for firefox. Or, as you are using instead of , just pass the values as . So if you want to avoid this, you need some kind of authentication mechanism (and you obviously need to fix the SQL injection). Other than the use of which is deprecated for a long time, and the SQL injection, your PHP code looks good. I would probably move some of the code to it's own function (such as , , , etc) to make it even easier to read. And instead of setting the header and status message yourself you could use . 

Error Handling Currently, you don't really have any error handling (that you have posted). It seems that incorrect user credentials would result in the same page for the user as an incorrectly written query, or problems with the database. I would either check the return values of , etc, or manage this with exceptions, so that you at least have the option to report to the user if it's their problem, or a server problem. Security Your system seems secure. You use prepared statements (and you use them correctly), and you hash your passwords using bcrypt, which is also recommended. There also do not seem to be any logical errors with your login process or your session management. It's generally recommended to regenerate the session id when session data changes (such as on logins), although that's not as important as it used to be (as is false by default). Still, regenerating session ids is good practice to limit the dangers of session fixation and session highjacking. 

It's not that important that it is internal. You may be vulnerable to CSRF, XSS, etc (not in this piece of code, but maybe somewhere else), which may allow an attacker to attack your internal website (they would need some information about the infrastructure, but you already posted part of the source here, and your security shouldn't rely on the secrecy of script names, source code, etc). But no, there shouldn't be any way to attack your server. You removed all your SQL queries (or did you just not post them?), the filename that is written to is hardcoded and cannot be overwritten, you don't echo anything, don't use any dangerous functions, etc. The only thing you do with user input is to write it into a .json file. So as long as your server isn't configured to interpret .json files as something else - eg PHP files - (which it really shouldn't, and no server would be configured like that by default) there is no danger in the code you did post (but I'm guessing it's just a very small part of your program anyways). Misc 

You use prepared statements, secure random numbers, and didn't make any other giant mistakes (from what I can tell), so that is already very good. Still, there are two issues: 

If you don't do this, an attacker can inject a javascript key logger, perform phishing attacks, bypass CSRF protection and thus do anything the user can do, steal cookies, etc. It only requires the victim to click on a link or visit a website where the attacker can post javascript code. All this will happen in the background, so the victim will not be aware of any of it happening. 

To add additional security as defense in depth, you could move the upload dir outside the web root and check the content of the file (eg that it doesn't contain opening PHP tags). Returning Early Your ifs are quite nested. If you return early, you can avoid this, and make it more obvious what condition returns what error. Eg: 

Comments There is such a thing as having too many comments. Most readers will read the first two or three, realize that they were not particularly useful to them, and skip the rest. You should not document how the language works (eg or ). Some of your comments also don't really add any information (eg or ). Generally, in-code comments should only explain why you do something, not what or how you do it. What you do should be expressed with good code, good function names, and possibly good PHPDoc function-level comments. For function-level comments I would choose some organized comment style like PHPDoc: 

First of, you are vulnerable to SQL injection. "remember to check if the value is an integer before setting it" would not be a reasonable defense against injection, you really need to defend in the same place as you build the query, and you need to use prepared statements. Structure On the PHP side, the structure seems fine to me. Spec is a classic model, holding the spec data and containing the business logic. The calcPressure method also doesn't do quite as much as you say (it doesn't prepare the output, which would indeed not be good). But the fields should be private and accessible via getters, which would break your view. The question is if you actually really need the whole object in the js view. In the example you posted, this is not the case, you could simply do this: 

This way, it's easier to see what you are checking, and also easier to see if you made some mistake. Cleaner Code You can always use two loops instead: 

Security General Approach Your reason for this approach are not reasonable. The only reason to provide a different hash function is to deal with systems which do not support . And really, those systems should be updated. You definitely do not want to switch to a weaker hash function after a breach. You can ask users to change their passwords via other mechanisms. tl;dr: Yes, just use bcrypt. Salt vs Pepper Based on your comments, you seem to understand the difference between a salt and a pepper. But your code doesn't seem to differentiate, both your salt and your pepper are a pepper (this is also not as easy to fix as "replace this string with a random function", as you not only need to generate the salt, but also store and retrieve it). A salt should be unique for each hash, so that it actually slows down attacks. Bcrypt usage The bcrypt part of your approach is fine; you are using and correctly. Note that bcrypt actually handles salts for you though, so adding your own salt is unnecessary. As bcrypt can only handle passwords up to 72 characters, your approach may actually be harmful, as a long salt + password + pepper may cut of (parts of) the pepper. I would at least comment on this, but ideally, just remove the salt for bcrypt. Custom Implementation: Empty Hash If you set your to something invalid, you will - silently - store an empty string instead. Currently, you actually return false on the check, so it's not catastrophic, but it can lead to usability issues. I would throw an exception here.