I'm trying to learn how to safely and reliably start and stop the pigipod DEOMON process from within a python script. If pigpiod happens to be running already, then this script is always successful. It stops pigpiod and then starts it again. But if pigpiod is NOT running when I run this, then MOST of the time it fails, and the standard message block that starts with "Can't connect to pigpio at localhost(8888)" appears when I try to instantiate pi = This happens even though returns , there are no exceptions, and a was executed "just to make sure". 

For the next 1000 milliseconds, a transition in either direction on pin 22 will result in a call to , passing the new level and the tick number (microseconds). If I understand correctly, in pigpio one can set up one watchdog per GPIO pin, so there could in principle be many running at the same time. My question is what are these watchdogs? Are they CPU threads, or are they running in the GPIO electronics itself, or something else? Like real dogs, can they compete, conflict, or collide (say two watchdogged GPIO pins experience edges at exactly the same time), or do they get along nicely with each other? This is from and may be of some help: 

After disconnecting the WiFi, I captured a few responses. According to the page 22.13. Checking the Status of NTP the column labeled is "how long since last poll (in seconds)" and it increases with time as expected. But I don't understand why between 155 and 434 seconds that "jitter" changes, or between 434 and 687 seconds "delay" changes. Right now I'm classifying that as an inconsequential bug and ignoring it. To me, the value of "when" is most important 

Presumably you looked at $URL$ from Adafruit. Once you get your data with the microphone, what you want is an "audio spectrum analyzer" . You will need to do Fourier Transforms to convert the time series data from the microphone into frequency data. You can look for the standard musical note frequencies in the Fourier Transforms. There is a computationally fast way of doing Fourier Transforms aptly named FFT, i.e. Fast Fourier Transform. See $URL$ for info on how to do that on a Raspberry PI. There is a LOT to understand about FFTs and spectrum analysis. For example, the frequency resolution of the FFT depends on the number of samples that are processed. You also need to understand windowing. See $URL$ . For this specific example, if there are multiple notes playing at the same time and the same note is played in different octaves, you will have to distinguish between overtones from lower frequency notes and the fundamental frequency of higher notes. For actual music versus isolated instruments, this is non-trivial. 

Take a look at this link at github. It has a patch for WebioPi that makes it work on the PI2 and PI3. I have used it successfully on the PI2, but have not tried it on the PI3. There is a discussion of the patch at raspberrypi.org 

Use a voltage divider to monitor the 12V at the light bulb. Make the resistors large enough that they do not significantly affect the bulb. A 3K resistor for R1 and a 1K resistor for R2 divide the voltage by 4, giving you 3V at Vout when powered, and a 1K pulldown to GND when the switch to the light is open. 

appears when trying to kill it. So for almost a minute, the DAEMON is a zombie (so to speak). This means that the idea of quickly turning it off and then on again is a bad one. Instead, if the OP (me) really wants to do this with Python, the script has to honor this transient zombie status and not just start and stop it willy-nilly. 

I'm trying to check on the status of the pigpiod process from within a python script. These two methods both appear to work so far. Are there any significant advantages or disadvantages of one over the other? Are these likely to be reliable ways to do this? 

This is a partial answer; I am going to try to understand further why this is so. If someone is able to explain further that would be wonderful. The behavior described by the OP (in this case, me) is: 

Today's announcement at raspberrypi.org: Raspberry Pi 3 Model B+ On Sale Now at $35 describes several improvements. In the linked YouTube video changes to the power supply are discussed between and , but I'm not quite sure which parts are historical review, and which are related to the most recent changes. Could someone point out which are the main points they make here about the new Pi 3B+ power supply? 

I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

Assuming that your pH meter does not have a common ground with your RPI, you can connect the "GND" input to the pH meter to a 3.3V/2 resistor divider from the PI 3.3V supply and use a PI PWM output with an RC low pass filter to generate a programmable voltage without any DAC. Tie the RC low passed PWM output to the non-GND pH input and as the PWM value is set above and below 50%, the voltage into the pH meter will vary above and below zero, relative to 3.3V/2. If you want finer voltage control, you can use pull up/down resistors on the capacitor of the RC filter so that the resistor from the PI PWM output can only drive the output to some fraction of the 0-3.3V range as the PWM varies from 0% to 100%. The ratio of the RC resistor to the pull up/down resistors determines the range reduction. As for generating the PWM outputs, you can use the pigpio library to easily generate PWM signals on any PI output. All of this assumes that the rate of change on the pH voltages is relatively small, since it will be limited by the RC low pass filter time constant. In general, after a large change, the voltage through an RC settles to the final value within about 10*RC seconds. The PWM period should also be much shorter than the RC time constant, say ~1000 times, in order to filter out the PWM frequency. See $URL$ for a detailed PWM DAC application note from Texas Instruments. LTSpice Schematic: 

will display the results on the console, but I don't know how I can get the python script to see if ntp is active or not, since this call returns only . I could always just force a reset even if not needed using 

It turns out that this sluggishness in the pigpiod DAEMON's status is real. It's not a problem in the script. I saw this by accident while trying to stop and then restart pigpio while debugging a DHT22 script. Here's some text from the Pi's terminal. After the killall, pigpiod can not be started between and . The message: 

but it seems like a bad idea to do that if it wasn't necessary. edit: using Raspbian GNU/Linux 8 (jessie) Question: How can I test the status and then conditionally force a synchronization only if needed? This answer suggests the package $URL$ but I'm not sure if this is advisable or not, so I thought I'd ask before installing and running it, and I'd still have to guess the status by comparing the results to the system clock and deciding if the agreement were good enough or not. I'd still like to know if ntp is active and that it believes the synchronization is close. 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

I've turned the WiFi off about five minutes ago so that explains the watchdog timer being 372 seconds. Is the value for frequency what I'm looking for? Question 1: Is using the lowest value for "when" a reasonable way to gauge roughly how long it's been since the system time has been checked against internet servers? Question 2: Does the ntp daemon make an estimate of system clock drift rate available in any way? If it's say 10 ppm or 100 ppm, is this reported somehow? Question 3: What do the characters in the first column such as '+', '*', '-', or absence thereof indicate? System: using Raspbian GNU/Linux 8 (jessie) 

Instead of waiting for an edge, you should debounce the switch input. The same code that gets rid of glitches when a button is pressed can also get rid of glitches caused by external events. The link is for the pigpio library, but if you google switch debouncing in software on the Raspberry PI, you will find other possibilities. 

EDIT: Note that the question was changed from "how to detect 12V turning on a light bulb" to the current question about doing so for a backup bulb in a car. Other solutions are better for an automotive environment. 

Your best option is to use a USB Wifi dongle that has an external antenna and disable the on board WiFi. For really long range, they make dongles with two antennas. Just Google "usb wifi external antenna" for many options. To find one with two antennas, just click the "images" button on the google search results page. The description of the dongle usually lists the WiFi chip used. Make sure to get one that has a chip that is supported by Raspbian . If you need REALLY long range, you can use an external antenna dongle with a long range 2.4 ghz antenna . 

Below is a schematic of the RPi GPIO circuit. As you can see, the input buffer is always reading the external state of the pin, so if you want to read the pin, as that shoe company likes to say, just do it. 

What caught my eye is the "stability" measurement. I'll let it run for a while to see if it becomes non-zero, hoping it might address Question 2 below. edit 2: Looking at the question timed out, nothing received on ntpdc> loopinfo? I found the command 

The scripts and the results mostly speak for themselves. returns good data when I use the standard I2C GPIO pins, but the bit banging I2C returns what looks like random data. What might I try to debug this? note: I didn't forget to move the SDL and SCA leads to the appropriate pins. Using 3.3V to supply the DS3231 Real Time Clock. 

Comments by @Joan (above) were extremely helpful! MCP3008 does indeed use , where I had it erroneously set to . The following works very nicely! 

I started to try to read an MCP3008 ADC using SPI bit banging with pigpio. I wrote the unattractive little script below, starting from the example in the pigpio documentation and here is a screenshot of my output. I believe that this should read the lowest four channels of the ADC and print the output. Channels 0 to 3 are connected to +5V, GND, +5V, floating, so I expected to see values like 1023, 0, 1023, xxx where the last would be noise. Instead I see all 1023's. Have I done something terribly wrong? 

Question: What could cause to fail to start pigpiod successfully some of the time, but still always return and throw no exceptions? edit: RPi 3, Python 2.7, Raspian 8.0 jessie Failure looks like this: 

Here is a paper that discusses the frequency response of silicon image sensors in general. The graph below from the paper, shows that the image sensor response is about 20% of the peak sensitivity at the short wavelength end of the range. However, it doesn't drop to zero until around 300nm, so with very bright 390nm illumination, you should be able to see something, assuming that the RPi camera has typical silicon sensor response and that there is not significant UV attenuation from the lens. With really bright illumination, you could use a pinhole lens to eliminate glass attenuation. 

As you can see below, I somehow have duplicate file names. I'm not sure if the files themselves are duplicate. Any idea how this can happen? The PI is running Raspbian Jessie. 

(Picture from this page about RPi GPIO) All of the GPIO libraries such as pigpio(my personal favorite) and WiringPi have library functions to set the pin direction. If the GPIO data output register is set to 0 and you set the GPIO as an output, it will drive a 0 on the pin. Set it back to an input, and the resistor will pull the pin back up. In pigpio you use the set_mode function to set the I/O direction. Looking at the protocol, after you pulse the pin low and it is pulled high, the TX23U pulls the pin low and then eventually sends a start of frame pattern followed by the data. There is a pigpio application called piscope that records the state of a GPIO pin that you could probably adapt to record the sensor data stream. It has the ability to trigger on edges in the data stream before starting to record. It can store the data in a file. 

Questions are at the bottom. When adding a time stamp based on the Pi's system time to a data file, I'd like to include some information about how reliable that time is. For example, if the Pi has not yet made an internet connection since power up, the system time will be quite wrong by hours, days, or worse. If the last opportunity for synching to ntp servers was say 24 hours ago, it could potentially be off by many seconds, and if it were ten minutes ago, it's "good" as far as I'm concerned. I'm using the following python to capture all of the lines in the response so I can decide later how to interpret them, the suppresses the header of column labels 

edit 1: per @Joan's comment: pigs, the socket interface to pigpio also returns random bytes. The following are the pigs equivalents to bb_i2c_open, bb_i2c_zip, and bb_i2c_close. All bytes are non-repeating. 

I'm using pigpio bit-banging script (download, GitHub) that interprets the pulse durations generated by the DH22 Temperature/Humidity sensor. It sets a 200 ms pigpio watchdog to the GPIO pin and attaches a callback, passing the tick count and new level. Here's a generic example: 

My PiBox module, I've left the verbose print statements in to help explain what I believe each step is doing. It's certainly safe to ignore or delete them: 

After turning WiFi on again and letting it run for a bit, I see the following, which suggests that it's periodically checking.