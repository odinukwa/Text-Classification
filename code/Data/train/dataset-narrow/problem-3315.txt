If it is a local media center that will not stream multiple HD streams at the same time from harddrive, any modern hard drive will have enough speed for media center applications, so if cost is your consideration, go with HDD. Morover, your data transfer rates will be more constrained by USB2 speeds, which are generally slower than HDD, so SSD or SSD won't matter unless you figure out direct SATA connection, like with X300 extension board, but with that board I'm not sure you'll be able to pull real SATA2 performance to benefit from SSD speeds. BUT there's one very good point for SSD, even at slower speeds, there's NO moving parts. RPI does not have any moving/rotating parts like fans, so if you want silent operation for your media center, go with SSD, you can't get quieter that that. Plus HDD have more power requirements, so you can say SSDs are greener to operate. 

You don't send the code to RPI. With Java ME what they advertise is remote development for headless setup, when you develop on PC, and then upload to RPI, where it RUNS DIRECTLY on RPI. you can compile your code on RPI as well, but IMHO running good IDE for Java development is a stretch for RPI. If you are up to use text editor for java files, you can totally edit/create files on RPI and compile it using javac on RPI without the need for PC. The only thing that Java ME provides on PC is ability to develop and test for RPI on PC with build-in emulator, so you can develop without access to RPI and then upload the final compiled code for execution on RPI. So yes, you can edit and compile java ME directly on RPI, but you won't be able to efficiently use NetBeans or Eclipse IDE on RPI. 

I suggest you perform these tests in this order: 0) Check that your USB power adapter is working properly (5v, ~2A). ( I assume it's OK since you mentioned that you have successfully powered other Pi units. So I'm including this step for logical completeness.) 1) With power disconnected, check the polyfuse (near the USB input power jack) using a DMM ohm meter to determine if it is open or closed. This resettable fuse is circuit protection for an overcurrent condition and normally resets itself after a few hours once tripped. 2) With power disconnected, check the TVS Diode (PCB location D5) using an external variable power supply at the USB power jack (constant @10ma, apply 5v and turn up to 8v) and use a DMM volt meter to observe shunt behavior. This diode is circuit protection for an overvoltage condition and might be smoked and stuck in an open condition where it is shunting all your power to ground. If you got this far, your 5v power rail appears good. 3) Now connect the power. Check either of the GPIO 3v3 power pins using a DMM volt meter to determine if it's providing power at this level. If it is powered, that means your voltage regulator (buck converter) is working and it should also be supplying power to the SOC which performs the boot processing, so you may have a faulty SOC. If the pin is not providing power, that suggests your regulator is faulty. These few tests should narrow down the troubleshooting considerably. 

The figures are the maximum rating for the supply. Don't expect it to work if you hook up a load that exceeds the supply. It is not a problem when the load is less than the capability of the supply. For the phone packs with the USB ports, I wouldn't worry about anything getting damaged (some mobile phones will draw much more and they need to protect against that), but I might fear that the max current is optimistic. It could be that the inexpensive ones will provide low voltage at the high end of the current spec. You could end up with a misbehaving system if it draws too much. For a zero, I'd certainly plug it in and try it (and make sure you have an image backup in case the filesystem gets corrupted when you run it to empty without shutting it down first). 

I just installed OpenElec on a Pi 3, and it puts the partition that is normally mounted as on other distributions as . 

It sounds like you're thinking of it like a USB storage device. Where the TV is reading video files directly from USB. That's going to be a bit tough I would instead suggest attaching the Raspberry Pi to the TV via HDMI. Then install Kodi and point it at the videos on the hard drive. (Yes, they can be uploaded over the network). Then you can either use a web interface or a smartphone app to select which videos play. You can create a playlist and set it to repeat. 

The only pins you really need to be concerned about insulating are the power pins. There are four of them on the B+, two are 5V and the other two are 3.3V (you can readily find them on a B+ GPIO schematic). The simplest way to protect these pins from accidental grounding or shorting to an adjacent GPIO pin is to cover them with an empty female dupont connector. You can buy a package of these little plastic connectors on eBay, or just cut off the end of a GPIO jumper cable and use it to cover the power pin. When you need to connect something to the power pin, simply remove the dupont housing cover and put it aside. 

Power noise is a good example of an analog signal on the Pi that is best visualized with an oscilloscope. I measured the noise on the 3.3V power rail and wrote about it in this BLOG ARTICLE along with a screenshot of the waveform. 

No, it exceeds the normal power range for USB. Just above 6V, circuit protection in the Pi will kick in. What's most likely to happen is the overvoltage condition will cause the TVS Diode to start shunting power to ground. This short condition will in turn make the current draw increase dramatically, which will cause the polyfuse to open, thereby cutting off power completely. This is a quasi-crowbar circuit protection solution, and it's rather clever. Stick with a 5V supply for USB. If your motors are only controlled by the Pi, they can be powered separately. 

I'm having a problem similar to this one Solving “RTNETLINK answers: File exists” when running ifup My setup is basically 2 separate networks one via Ethernet and one WiFi. I want to have a simpless plug-and-play connection, if Ethernet is connected use it, if not, fall back to WiFi. It worked nicely with DHCP setup on both networks, but now I'm forced to use static IP with Ethernet and DHCP with WiFi, and now have to reboot every time I plug Ethernet back into RPI... Here's my network config: auto lo iface lo inet loopback 

Now what happens, at boot everything works in any configuration of Eth0/wlan0 availability. But if I unplug Ethernet cable, WiFi successfully kicks in, but when I plug Ethernet back I'm stuck with no connection, ifconfig reports eth0 as Up and running with static IP address, but it is not actually connecting to internet. If I forcefully do ifdown, it fails saying eth0 is not configured (which is weird as ifconfig reports it in "Up" state with assigned IP address) and ifup eth0 fails with the same “RTNETLINK answers: File exists” error... Anyone has any ideas how to fix that for the case when one network is static and one DHCP? Removing gateway entry does not work, as in such case static IP won't work... and I don't really have gateway entry for wlan as it uses dhcp... 

There are two types of pins on the GPIO header. The predominant type is for digital signal processing. These are I/O pins and operate at 3.3V. The second type of pin is a power pin. There are power pins for 5V and 3.3V. These pins typically supply external devices or sensors requiring an analog power source, but they do not support 5V digital signal processing. It might have been a cleaner design to designate all the GPIO pins exclusively to digital signal processing and provide separate terminal headers on the Pi board for the 5V and 3.3V power taps. Perhaps this would require board space they didn't have to work with. The Pi's power network has multiple levels. The input power to the Pi is 5V so that explains why a 5V power pin is provided. The SoC and signal processing operates on the 3.3V power rail. And there is a third power rail at a lower voltage of 1.8V that supplies the Ethernet controller chip. I can't imagine a scenario where you would damage the GPIO by using the 5V power pin. The only limitation is the current draw and that will vary by Pi model and any other current consumers (e.g., connected USB devices) running on the Pi at the same time. I wrote a blog article about the supply of power from the 3.3V rail if you're interested in a deeper dive on that topic. 

At this point you should be able to use an editor to modify . Reboot the system and it will go back to being read-only (which makes it more resilient in case of power loss. 

As is a default share, the likely only valid share here is . The server can be identified either via the IP (192.168.2.253) or by name (SMBSHARE). Unfortunately in the mount command, the two are combined, both in 

With uid=0, you are explicitly telling your machine that every file should be owned by root. With file_mode=0775, you are telling your machine that "everyone" else should only have read access, not write access. For a single-user machine, it probably makes more sense to set your option to be your user's uid, not root's uid. Either that, or set your file/dir modes to , granting write access to "everyone". 

You can configure it as long as you know the SSID and the credentials. A more detailed process is listed here, but the basics are to create/modify with contents similar to : 

My alternative would be to purchase a chip/module that lets you run from battery and charge without unplugging anything. Then run the Pi from that and design your case to expose the charging plug on the module. What kind of batteries do you have, and how do they normally charge? 

When considering the best use of an oscilloscope, it's useful to classify the basic types of measurements and the most appropriate test instrument for each: 

I assume the 5V you are supplying to the ADC is the reference voltage. As you might guess, any voltage level that serves as a "reference" should be reliable within a tight tolerance. Consequently, you want a stable voltage and you cannot expect that when powering the unregulated 5V rail from batteries that lose power over time. If you were supplying the Pi from a conventional micro-USB power adapter, and any other loads were modest and not varying to a great extent, then you may have a stable 5V power to use as a reference. If you need to use batteries (e.g., for mobility), you might try testing the operation of your ADC under varying voltages to determine the range where it works correctly. Then implement some form of power monitoring to alert you when the batteries need to be changed. Another option, which is kludgy but might be acceptable for a non-commercial DIY project, is to connect a step-up voltage converter to the 3.3V rail that outputs 5V. The voltage on the 3.3V rail is regulated and very stable, so the output 5V will be stable, as well, even as your input battery power falls below 5V. Assuming the ADC requires minimal current from the reference voltage connection, the 3.3V rail & converter should be able to supply it without any problem. This is a creative solution (offered in the spirit of brainstorming) that attempts to work around the constraints and deficiencies in the power architecture of the Pi. You would have to test it as a POC to assess if it works for your configuration.