You can hard code each level, testing the map array for a specific total state, making sure that A2, A3, and A4 are all orange. You can program a pathing algorithm to test if there is a path between the two colors. 

TL;DR: In order to do what you want to do, you should be using the Boussinesq Approximation, which does not assume a flat seafloor surface. This is a very interesting question by the way, I don't see many people try proper water simulation often. 

One thing to think about here is that you are updating the entire mesh UV state for each tile you modify. I'd be sure to check and make sure it's not refreshing the mesh after each tile. you might return the UV updated array one level up and marge them all at once. Basically restructure so you calculate all, then apply the changes to the chunk/mesh. I also notice you're searching for the chunk index once for every tile you update. Do this outside of the tile loop, and pass the result to the SetTile() so you only do this search once per chunk instead of once per tile. 

One thing I would be careful about is using the correct input callback. I would suggest one of two things, read the API's on the input methods available, and choose the one appropriate to your desired behavior. Some callbacks only fire if the key is held down, and others fire on a tap. Secondly, your architecture should change a little bit. The callback should only set the Target transformation. When you click on a pot, copy the transform from the pot to the target of the move script. The move script should be changed to automatically strive to achieve it's current target transformation until it reaches it, at which point it will wait until it receives a new target. This is best done by having your movement code in the Update() method within the script. For a small game, this will achieve your goal, and not cause much overhead. (Bigger games with many moving entities need to approach the problem a little differently) These changes will mean when you click a pot, the target will be set, and on each frame the movement script will adjust the chef's position if it doesn't match the target. The beauty is that you can reuse the "moveto" script for any other objects, with either a fixed, random, or controlled target transformation to add a little extra to your game. (a rat, or an assistant for instance) 

3D objects still have an X and Z coordinate. The only thing you have to do to make it isometric in 3D settings is to ensure the Y value for all the tile objects are the same. Generally we set this to 0. Put your camera wherever you like the angle, and voila! I hope this clears things up. 

The second option will be better for you in the long run, as it means less work for you to design new levels. Do a little research for finding paths in an array between two points. It's an old problem with many solutions. The most optimal solution, if my memory serves me, is the A* (A-star) algorithm. 

In a nutshell, what makes a shallow water equation a shallow water equation is that the water height is not zero and it assumes no variation in the seafloor. Note: No fluid dynamics equation will allow for a water depth of 0, as that would mean you have no fluid. You should read the Wikipedia article on the shallow water equation. Basically, in shallow water, the vertical velocity is ignored because the value is so small and has minor impact to the wave propagation. To quote the section in case of modification of the source page: 

There's a trick to this: Selecting Areas: As you move the mouse, the only tiles you need to check for new impassable tiles are the newly highlighted tiles. If the mouse is dragged from X=25 to X=26, then you only need to iterate over the tiles at the X=26 column from the Y of the starting tile to the Y of the tile the mouse is over. The worst case scenario is you cross both X and Y axis, in which case you will only iterate over L+W-1 tiles. Deselecting Areas: The catch is if the player selects a large valid area, crosses an invalid tile, then backs off of it to go back to the large valid area he had a moment before. To keep from having to check the entire space when your area shrinks, keep track of how many impassable tiles were crossed as you cross them. Then when bounds change, subtract the number of impassables that were in the column or row that was deselected. As soon as your impassable count is 0, you no longer need to check so long as the selected area is shrinking. This still ensures you never iterate over more than L+W-1 tiles at any time. Highlighting: While Selecting areas, as you iterate over, spawn a red rectangle at the location of the impassable tile you are currently looking at. Store them in a 2D array for when you need to remove them. You could do some magic and scale a single rectangle for contiguous blocks of impassables with a little thought. While Deselecting areas, iterate over the column or row in the 2D array mentioned above and remove any object found in the row or column. this will be fast, as you know the column or row you're looking at, and since most will be empty, they will more or less be skipped. 

This question falls into the subject of Runtime Analysis. Assignments are, by nature, constant time operations. From a performance standpoint, you generally don't need to worry about constant time operations. Since you asked: Any primitive operation(assignment, logical evaluation, etc) are generally considered to take one flop from a runtime standpoint. Occasionally there may be more cycles for other overhead, but as a general rule they are considered to take one flop. Lets compare pseudocode: 

Most games use some form of quadtree or octtree to organize and sort entities efficiently at runtime. The item's typeID is stored in the tree, and the renderer loads an instance of that type of entity when the player is within the same part of the octtree as the entity. 

This only works, however, if you are differentiating velocity/time. It won't work in a tile based game, and will result in visible artefacts, such as one object either tunneling through an object, or being visibly pushed out of the other object. In the case of tile based games, you can take a predictive approach, by checking where the object will be if it moves. If the movement would cause phase lock, then disallow the movement. 

I'm going to ignore angular effects here for simplicity. In your contact resolution function, do the following: calculate relative velocity of the two bodies. if the relative velocity dot normal < 0 apply no force (moving apart) else correct position, to make penetration distance == 0 calculate normal force based on relative velocity / combined inverse mass apply impulses to bodies. Google "physics engine slop" for more info. 

As each object has only two endpoints, min and max, once you reach it, it can be inferred that the other end point is the maximum extent, therefore beyond it, no further intersections are possible, and so no further traversing is necessary. Naturally, this does increase complexity, but as the checks are very simple integer/integer, and boolean checks, It shouldn't have too much of an impact on performance. 

From a physics standpoint, the minimum restitution between two bodies should be used. Think of gel hitting a rubber ball. The rubber ball has high restitution, but the gel has low. The rubber ball will not bounce off the gel. In the case of bounciness, lowest wins. However, gel has low density, which allows the ball to penetrate it and hit something with higher restitution, such as the ground. The gel will absorb some of the kinetic energy of the ball, how far the ball bounces, often considerably. But that's a bit off topic. Restitution is a representation of loss of kinetic energy through collisions, so the lowest value is the most accurate. Throw a golf ball at a block of soft clay and you will see what I mean. 

Your problem lies in the fact that you have no "resting" state for your bodies. Any physics system has an amount of energy, be that kinetic, thermal, and so on. In reality, solid object deform slightly, and tranform some kinetic energy into heat, though it is hardly measurable. It's also worth noting that in reality there is no such thing as a completely solid object. Even dense materials, like diamond, have space in between the atoms, giving the atomic structure room to flex, and absorb kinetic energy. To make this relevant, resting bodies are in a state where the only forces in effect is the "normal force", which is to say, the force that prevents bodies from floating through each other. The magnitude of that normal force, is proportional to the density of the objects, and how far they have penetrated each other. Physics engines call this value "slop". Here's the trick: Calculate the slop, and correct the position of the bodies, and apply the normal force, based on the relative velocity of the two bodies. during the update of the bodies themselves, calculate the kinetic energy of each body. If it is below a minimum value, then put the body to sleep, until a force of sufficient magnitude is applied to it. (usually twice the minimum value). 

This method is accurate to the formulae of collision response. If you want even more accuracy, you will want to take friction into account, which will cause the ball to spin, but I don't know if you want that in your game. In case you do, this is how you calculate the tangential force: 

I finally found a solution, on this page: $URL$ This completely elimenated both the sinking and the jitter. 

F = ma, or a = F/m. Calculate the collision point between the sphere and plane. This is usually Sphere centre - normal* radius. If you want more accuracy, calculate how far the sphere has penetrated the plane, and adjust your calculation. This is largely optional of course, unless you want really accurate physics. Now calculate the relative velocity along the normal. For a static plane this is: Vball Dot N. Then Multiply VballDotN by -1, and multiply by mass. In physics at this stage you would also multiply this by the coefficient of restitution (bounce factor). Multiply this scalar by N and you have your force. When adjusting Vball, divide the force by mass again and you have the final acceleration, so just add this to the velocity and you have your final post collision velocity. 

Correct the overlap between collidable objects generate a "normal" force which will push objects apart, should they collide. 

It sounds like you are trying to implement a mass spring system for deformable bodies. Your bodies springs must have a "breaking" value that will separate them into individual bodies if the force applied exceeds this value. That will handle the smashing effect. for deformation, the mass spring system will work, but I should point out that it's processor intensive, so a GPGPU solution will be desirable. Fracture mechanics are very complex, and a field of study in and of itself. Many games just fudge it, as "close enough" effects are often enough to fool the user. For example, take a stick. If an impact halfway has enough force to cause it to break, just create two more sticks with half the length, and noone will be the wiser. 90% of games tech is smoke and mirrors, and creating convincing fake physics. Only the trained eye will notiice the difference. 

I came up with a solution: In order to record all possible intersections on a given axis, You must record a pair for every possible overlap. The code I posted wasn't doing this. Instead, my new code traverses the the list one at a time, and for each endpoint which is marked as a minimum, search the remaining elements until you find the max endpoint for the same object and generate a pair for all elements in between: 

I'm writing a rigid body simulation in C++, and have come across a problem when an object should come to rest on the ground. Because gravity is being applied to it's velocity, the object starts sinking through the ground, or whatever else it's resting on. To combat this, I am adjusting the position of the object, by moving it along the collision normal by the penetration depth. This has the drawback of making the object look like its vibrating, so it never comes to rest. I read somewhere ages ago, that there is a way to counter this, by generating a force along the normal which will cancel out the force which is causing it to sink. A google search did not return any useful answers however. I suspect this is because I'm not asking the right question, but I don't know a more concise way to word it, so I'd appreciate if someone here has solved this, and could steer me in the right direction.