Your approach provides zero forward security. As soon as Bobs private key is compromised, all past communication with Bob is compromised as well. You should use a Diffie-Hellman like handshake protocol for agreeing on a common secret for the actual communication. 

Specifying the times as strings for readability in the config module is reasonable, so let's keep this as a requirement for now. This leaves us with either increasing the sample rate on the timer, or with refactoring the logic which handles the state at any given point in time. Since the sample rate can't be increased arbitrarily, let's go with refactoring the logic. 

Eh, nope. Looks like you actually managed to bake the game state and logic into the class which was only supposed to be responsible for presentation. Well, at least that means the setup of the game state is still in a single location? 

Even worse - what you just implemented yourself can have unitended side effects if the row object has additional properties with special meaning, which coincidentally collide with (not actually ignored) keys in the passed data. So your logic can be written more compact and less error prone once again: 

Depending on where your ORM does validation, either of these two lines can yield runtime errors. Especially in the case of the multi row persist, you need to think about how to handle the error case. If one row fails to insert/update, what to do with the rest? Try to persist as much as possible? Inform the invoking site? And how does the ORM handle validation / SQL errors in the first place? Error codes? Exceptions? 

Version A is definitely better, as it employs a more familiar pattern to get the job done, and it makes use of bit of trivial code () to save you from duplication of non-trivial code. () I would trivialize the trivial code even more, by saying right before entering the loop, and as the last instruction of the loop. Note that even though this is two lines of code instead of one, its complexity is smaller, because it deals with constants, not with variables. I could perhaps give more advise if you explained what you mean by 'algorithm to position boxes in a grid'. A grid is generally thought of as a two-dimensional structure, but I only see operations in one dimension, on variables which are defined outside of the code fragment that you provided, so... what is this code trying to accomplish? 

You could, perhaps, derive RecursiveObject from FlatObject. In the degenerate case in which all objects belong to a single lineage (every object has one and only one child, except the last one) and you have lots of objects, then your recursive method will try to use an awful lot of stack space, possibly failing with a stack overflow exception. The way to correct this is by avoiding recursion and adding a stack data structure within your function, which then works in a loop. But of course you would not want to do that unless there is a very clear possibility of such a degenerate case ever occurring. 

More curly braces and indentation please. The syntax with multiple directives on the same indentation level should IMHO only be used when the declared disposables are independent. If they are dependent, they can no longer have the same life time, and that should be reflected by the code structure: 

Just to avoid confusion, the former paragraph isn't applicable for , and alike. However, these are not exactly clean either. Abusing a to pass in the render surface of the parent is a horrible hack. Especially when you then continue to render to absolute coordinates in the parents screenspace. At least have the decency to leave the layout to . That is simply reached by additionally passing and offsets to , so that these components (at least internally) don't need to know the layout. The clean solution would be not to let these components draw directly to the render surface, but to use separate panes instead, completely separating them from the parent component. 

This would give you directly the first node of the first node. Internally, it does mostly the same as what you did manually. 

Even generating the last few names (before there are absolutely none left) will lead to a major performance problem. But not just that, worst case, even a faulty random number generator can break this miserably, if it doesn't guarantee that every number in the range is even possible to be generated as part of the current sequence. Which, as far as I'm ware of, isn't necessarily the case. That means, even if you did reset the name pool after exceeding a certain number of unique names, there is no guarantee that the RNG even allows you to hit the upper border, so you might get caught in an endless retry loop much earlier than expect. Plus, with over half a million elements top, that is easily going in the range of a few hundred MB of RAM. 

The best way to implement a public generic method for binary search is by invoking the method of . (Better yet, don't implement such a method at all, and call directly.) 

Another solution would be to properly filter your input. It is easier, and it is also more dangerous, because it is easy to miss something. For the example at hand, you need to parse the user input into a number, and then convert that number back to string in order to append it to your SQL string, as follows: 

There is a much, much, much easier way to do this. You can use real values for order, so when you want to move the row from position 16 to position 7 you give it an order value which is the average between the order values of rows 6 and 7. The precision of real numbers is huge, and I presume that the re-orderings of images in your database will be happening at human reaction speeds, so you probably won't run into precision problems during the remainder of the expected lifetime of the universe. But if you are really insecure about the possibility of precision problems, you can rectify your table every once in a while, by reading the rows sorted by their order, and writing them into a new table, re-assigning the order values by copying them from an integer identity field. Then you delete the old table and rename the new table to the old name. 

Why did you bother writing this explicitly for every potence of 1,000? Have another look at how the numbers in the english language are constructed, and try to find ALL patterns. If you that, you realize that for every number, every potence of 1,000 is formed identically: 

The only exception to that is the part below 1,000 which has no suffix. However, a missing suffix can simply be approximated by an empty suffix instead. So the logic approach is to write yourself a helper function which correctly formats every number from 0 to 999, because that is the range you need commonly. Your next realization should be that it is easier to start constructing a number from the LSB, than from the MSB, since you then only ever need one set of constant numbers to extract the relevant part of the number. Once you have that function, can be written much clearer: 

Well, except that this isn't exactly a clean way to manage a collection of products in C++ either, better use a dynamically growing data type with checked bounds: 

That recursion in the template of . Not going to lie - that's rather difficult to trace. A comment would have been in place, explaining what you are going to do. 

If you cannot modify , then write two helper methods, one for getting and one for setting the value of the day member of : Each method has a and modifies the appropriate member of . Good luck and have fun. 

is an awful name for a class. The name of a class should always be a noun. No exceptions. Read-only fields should be marked as read-only using the keyword. is an awful name for a function. It does not give any hints as to what it means by 'File Status', nor any hints as to what it means by 'Checking' it. Looking inside, I see that it performs operations that change the state of the system, so 'Check' is an awful choice of a name for what it does. When a function begins with 'Check' it is supposed to return and to perform absolutely nothing that would change any state anywhere at all. No exceptions. is not a good name for a function that checks whether a file is empty, because it may be confused with a function that actually empties the file. Call it instead, and make it a property, not a function. This is lame: 

Add a parameter of type called, say, . Replace the fields , , etc. with a that has a key of type and use to access values within that dictionary. Do the same for your , etc. global variables. (For which you will burn in hell, incidentally.) 

I reordered the clauses to ensure that the product remains as small as possible after each single step. Further, I eliminated the unnecessary join on the schema. However, you don't actually need full either. If your database system supports that, you can safely replace the 2nd and 3rd of the with operators instead. 

Well, at least it could if you hadn't called . Because of that, now returns false. Instead of a deadlock you now have something far worse: Use after free! As the thread pool is destroyed, all the mutexes, , , and are destroyed despite being still in use by the worker threads. The next allocation reusing these memory sections, will result in a bloody mess. 

This is already a disaster waiting to happen. is an array of pointers, and you should only treat it as such. Try to imagine what happens one of the pointers in is actually the ? That's perfectly legit with the original array, and also when using the old C functions such as to sort the array itself (given that the predicate is aware). As a matter of fact, using on the referenced values as you just did isn't even semantically the same as applying original straight to the array. You are copying around values while the array remains unchanged, whereby would have resorted the array while keeping the values constant. 

As GregS pointed out, macro arguments need parentheses. does not really do what its name says, nor what the comment above it says, because when we say "whitespace" we don't only mean the space character. You need to use from to tell if a character is whitespace or not, and this applies to all places in the code that compare against the space character. The comment looks like it has been added after the fact, in order to describe what the code will actually do, rather than to specify a requirement for the code. I would suggest that you replace it with a comment saying , because if you ever decide to implement that function differently in the future, you don't want to have to do tricks in order to precisely emulate the bizarre functionality of the old version, do you? Obviously, will fail if it is ever given to parse some text containing a word larger than some buffer, and the way it is written precludes the possibility of ever having any control over this so as to prevent it from happening, because the size of the output buffer is not passed as a parameter. In the test code, you would have a failure if you used a word longer than 100 characters. You might say, "you gotta be kidding, who would ever write a word longer than 100 characters?" One answer is, my son did, when he was 1.5 years old, and got a hold of my computer while I was in the kitchen, and he typed his first word document by holding the z key down for a couple of minutes and watching the 'z's fly by on the screen. If Microsoft Word was using your code, it would have crashed. Another answer is that this is precisely the kind of stuff that buffer overrun exploits are made of: the hacker will intentionally give the kind of input that the programmer did not expect. 

Note: Appears to work only with CLANG and gcc. Visual Studio e.g. fails to handle correctly. Obviously the preprocessor output isn't even remotely that nicely formatted, so good luck debugging that! 

I'm going to stop here for now. There are still many undiscussed problems with that code base, but after resolving the already mentioned ones, the code base will already look entirely different. 

This also goes for return types and method parameters. You should never require a specific type, if other implementations of the used interface work perfectly well either. 

If by "finished" you mean the executor is ready to be destroyed? That is already the case. Otherwise if you just mean to wait until the pool runs empty? Well, you do have in there. All you really need now, is a second condition variable: 

As for your implementation, you don't need a linked list. In fact, you don't need to store the input nor the output sequence at all, at least not for the algorithm itself. Take a look at the problem carefully again, and try to think about how you can rephrase the operations, when do you need to consume input, and what the earliest point is, at which you can create output. Last but not least, how long do you even need to store each specific piece of information. The first observation: Whenever an operation has finished, the value at is no longer mutated, and no further insertions or deletions occur prior to . The second observation: During an operation at , no value other than has an effect on that operation. At most is either removed or added in. The third observation: As all numbers are guaranteed to be natural numbers, even must hold. Which means that in any case, is always output in the same operation as which it is mutated in.