I am considering ideas about exact quantum algorithms. In particular, I am considering likely limitations of $\mathsf{EQP}$, which consists of languages exactly decideable by polytime-uniform quantum circuit families over an arbitrary finite gate set. The quantum Fourier transform (QFT), given by $$ F_N = {\frac{1}{\sqrt N} \begin{bmatrix} 1 & 1 & 1 & 1& \cdots & 1 \\ 1 & \omega & \omega^2 & \omega^3 & \cdots & \omega^{N-1} \\ 1 & \omega^2 & \omega^4 & \omega^6 & \cdots & \omega^{N-2} \\ 1 & \omega^3 & \omega^6 & \omega^9 & \cdots & \omega^{N-3} \\ \vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\ 1 & \omega^{N-1} & \omega^{N-2} & \omega^{N-3} & \cdots & \omega^{(N-1)^2} \end{bmatrix}} \quad\text{for $\omega = \mathrm e^{2\pi i/N}$},$$ is a celebrated part of quantum computational theory. In the case of $N = 2^n$, there is well-known decomposition of $F_N$ into Hadamards, SWAP gates, and diagonal gates $$\mathrm{CZ}_{2^T} = \mathrm{diag}(1,1,1,\mathrm e^{2\pi i/2^T\!})$$ for various $T \geqslant 1$, which is due to Coppersmith. If $\mathsf{EQP} \smallsetminus \mathsf{P}$ is to contain any problems, one might hope that one of these would make use of the QFTs $F_{2^n}$, in which case one would require the family of operations $F_{2^n}$ to decompose into some particular finite gate set. Using the recursive decomposition of the QFT, this is equivalent to there being a decomposition of all gates $\mathrm{CZ}_{2^n}$ into a single finite gate set. Obviously, by the Solovay–Kitaev theorem, we may approximate the gates $F_{2^n}$ or $\mathrm{CZ}_{2^n}$ arbitrarily well with any approximately universal gate set which is closed under inverses. What I would like to know is whether there is a finite gate-set which may exactly realise these families of operators — or, what I suspect is more likely, whether there is a proof that no such finite gate-set exists. Question. Is there either a decomposition of $\{ F_{2^n} \}_{n \geqslant 1}$ as a polytime-uniform circuit family on a finite gate-set, or a proof that this is impossible? 

appearing as Lemma B.3 (page 38) in the published version, and Lemma 12 (page 23) in the arXiv preprint; in both cases occuring in Appendix B. If anyone can point to an reference to a proof which is older than this question, I'll accept and reward the earliest such reference which is provided. 

— that is, a bitstring $x \in \{0,1\}^n$ describes all of the edges which are incident to it; of which there are always $n$ in this graphical model, albeit some of them may be the "empty edge". This puts us in a much better position to describe the hypergraph as a product in some conventional manner. The hypergraph $H_C$ obtained from a multiset $C$ now has a composite number of vertices $m$: we would like hypergraphs $H_A$ and $H_B$ such that $V(H_C)$ has some particular bijective correspondance with $V(H_A) \times V(H_B)$. A diagonally restricted tensor product of hypergraphs. Consider the alternative formulation of the problem, replacing bit-wise OR with bit-wise AND, alluded to in the recent revision of the problem. (To do this, we take the bitwise complement of all of the bitstrings.) The Cartesian bit-wise meet condition (rather than "join", as we're using "$\wedge$" now in place of "$\vee$") corresponds to the existence of a particular bijection $$\varphi: V(H_A) \times V(H_B) \to V(H_C)$$ such that the edge labelled $e \in [n]$ in $H_C$ contains only the vertices $\varphi(a,b) \in V(H_C)$ such that both $a \in V(H_A)$ and $b \in V(H_B)$ are contained in the respective edges labelled by $e$ in $H_A$ and $H_B$. This seems somewhat different from most graph products, in that we do not take combinations of arbitrary edges, but only those with consistent labels. 

As I have noted in the comments above, I do not think that the operation which you describe on state vectors — specifically, involving renormalization of state-vectors independently in each branch of the probability distribution over measurement outcomes — corresponds to post-selection, as many people in the field (epsecially experimentalists) would describe the concept. It may even give rise to some 'unphysical' properties, if extended to a mapping on density operators. However, it is a possible means of constructing something like decision trees whose nodes are labelled by state-vectors, and so it is in principle a reasonable process of study in its own right. I just wouldn't call that process 'postselection'. 

Details. Adiabatic Quantum Computation is a model of computation which is meant to exploit adiabatic evolution to perform possibly quite difficult computations. The idea is as follows: if you prepare an initial state which is the unique ground state of an initial Hamiltonian H0, and slowly vary the Hamiltonian of the system until it is another Hamiltonian H1 which also has a unique ground state, then the final state of the system is that ground state. There are all sorts of details: Interpolation of Hamiltonians. The most common way to describe how the Hamiltonian varies is as a time-varying Hamiltonian which interpolates between H0 and H1, that is H(s) = (1 − s)H0 + sH1, although any parameterization of a continuous curve in the space of Hamiltonians, from H0 to H1, is in principle allowable (subject to the considerations below). Adiabatic Theorems. The reliability of obtaining the ground state is guaranteed by Adiabatic Theorems (often called "the" adiabatic theorem, though there is more than one and they seem to be incomparable). For instance, Ambainis and Regev show that if: 

I am interested in the complexity of a problem involving spanning hyperforests (a union of hypertrees, which covers all of the vertices) of a $k$-hypergraph. I describe the relevant definitions for hypergraphs below, but the following is the problem on 

The class of instances of #2-SAT which are shown to be #P-hard are then the monotone bipartite instances. Question: What are the other special cases of #2-SAT which are #P-complete, as a result of this or some other reduction? It would be interesting if, in addition to showing/citing a reduction, people could also describe an intuitive reason for how the special case might provide obstacles to natural approaches to counting the satsifying assignments. For instance, although MONOTONE-2-SAT is trivially solvable ($\mathbf x = 1^n$ is always a solution), monotone instances are the ones in which assigning some variable to a fixed value will routinely fail to impose many constraints on the remaining variables. Fixing any variable $x_j = 0$ only restricts the values of the variables immediately related to it by some clause; and setting $x_j = 1$ doesn't restrict the possible values of any other variables at all. (It's not clear that the comparable restriction to bipartite graphs is significant in the same way, however; the bipartite restriction seems to add structure rather than removing it, but it fails to add structure enough to count efficiently.) Edited to add. Bonus points will be awarded for any such class which doesn't ultimately rely on the existence of monotone instances (as #2-BIPARTITE-SAT does above, whose hardness is apparently due to the inclusion of the #P-hard special case #2-MONOTONE-BIPARTITE-SAT). For instance, an argument for the hardness of #2-BIPARTITE-SAT which doesn't rely on monotonic instances (but might rely on some other sub-family) would be interesting. 

First, note that the monotone problem is equivalent, by substitution, to the problem in which for each variable $x_j$, either $x_j$ occurs in the formula $\phi$ or $\bar x_j$ does but not both. In particular, the "monotone decreasing" problem in which only the negations $\bar x_j$ occur for every variable is exactly as hard as the monotone case. For any graph $G = (V,E)$ with $m$ edges, we can construct a monotone-decreasing 2-SAT formula corresponding to matchings — collections of edges which do not share any vertices — by assigning a variable $x_e$ to each edge, representing whether it is included in an edge-set; the property of a set $M \subseteq E$ being a matching is equivalent to the incidence vector $\mathbf x = \chi_M$ satisfying the CNF formula $\phi$ whose clauses are given by $(\bar x_e \vee \bar x_f)$ for every pair of edges $e, f \in E$ which share a vertex. By construction, $\phi$ has as many satisfying solutions $\mathbf x \in \{0,1\}^m$ as there are (possibly imperfect) matchings in the graph $G$. If the graph $G$ for which we want to count the matchings is bipartite, then it contains no odd cycles — which we can describe as a sequence of edges in the graph which starts and ends with the same edge (without counting that final edge twice). Then there are no sequence of variables $x_e, x_f, x_g, \ldots, x_e$ of odd length in $\phi$, in which adjacent variables are involved in a common clause. Then the formula $\phi$ would be bipartite in the manner described earlier. Counting the number of matchings in arbitrary bipartite graphs, in particular, can be used to count the number of perfect matchings in a bipartite graph: given an input bitrarite graph $G = (A \cup B, E)$ with two bipartitions $A, B$ of the same size $n$, one can create graphs $G_k$ by augmenting $A$ with anywhere $0 \leqslant k \leqslant n$ extra vertices connected to all of the vertices of $B$. Because all matchings in $G$ of a given size contribute differently to the number of matchings in $G_k$, by counting these one can determine the number of matchings in $G$ of size $n$ (that is, which are perfect matchings); and note that counting the number of perfect matchings in bipartite graphs is equivalent to computing permanents of $\{0,1\}$-matrices by a simple correspondance.