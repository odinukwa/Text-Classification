WRT the staging directory, you can use the cross-compiler's sysroot directory (which contains all the basic libs, e.g., glibc), however, it is probably a better idea to make one specifically for that purpose and add to . I have not used the x-tool from your link, but I presume it uses crosstool-ng. If you look in the crosstool-ng docs at there are extensive notes about this. That pre-built x-tool may already have something configured along these lines. If your library requirements are fairly straightforward, building them from source is not much of a hassle. However, one thing you could try is to mount the pi's root directory as an NFS share (or Samba? I don't know much about windows) and use that as a staging directory. Then you just need to install the '-dev' packages with . 

Anything you put in on the first machine will then be accessible in on the second. You can have them both set up this way at the same time (in fact, you can have multiple directories on offer and mount them all remotely). You probably then want the NFS server running at boot (). 

So this is a discrepancy of a few kPa. However, note that weather stations report the pressure adjusted for temperature and altitude. Unfortunately the altitude adjustment actually adds (unless you are below sea level) and so does the temperature if you are above ~freezing. I have some C++ code for the Adafruit BMP085 board; I believe they say these two devices have the exact same interface (the 180 is a replacement model). BMP085_C++.tar.bz2 To unpack that: . I can promise you it works as I have been using it to record data for more than a year and occasionally check the pressure against local weather stations (well, right now I'm 0.2 kPA high). There's a README in there which will tell you how to how to compile a quick demo which will spit out the pressure adjusted for temperature but not altitude (since it does not know the altitude). The adjust for temperature formula is in . There's a constant in there () and a static function () you can calculate the altitude adjustment with. Here's the formula, which I must have gotten online somewhere: 

That's not unusual; I have a wifi adapter that causes this. The problem is that the A/B pis can't provide enough power to properly fulfill the USB 2.0 standard. It's still enough to run a small adapter, but when first plugged in, the sudden current draw causes a small voltage drop which browns the pi out momentarily. This may not necessarily always be enough to reset the whole thing, in which case it might just cause a sudden ethernet disconnect. I haven't found that a better power supply makes any difference, but then I haven't experimented too much -- it is not a big deal to me. Not quite as perplexing as the Pi 2's light sensitivity. 

Will show you if the module is loaded. You won't see the column headers (to understand that, leave off ). This doesn't necessarily mean it or the adapter are working. For evidence of that, at least on the most fundamental level, you want to see if the kernel is reporting a wireless interface attached. 

Is a message from the linux kernel, so this indicates it has loaded but has a problem with the root filesystem. 

They've used different colored PCB's (light vs. dark green) in the past, and that orange piece of tape -- actually, the whole HDMI connector its on -- is another. Note that Farnell and RS are not really the ultimate manufacturers either. As far as I know, they don't even do something involving assembly. It is all contracted out under their management. The B I have with a slightly different styled HDMI connector is made in China, and I think I got that directly through Farnell/Element 14; my other made in the UK B I think I got through Adafruit but it came in an RS box. I'm not positive about that though. However, Farnell and RS are in themselves just partners with the Foundation and distributors of the Pi. I believe there are, or have been, other such direct distributor partners that are more localized -- e.g., there was a red Pi B made for distribution in China by one such partner. But today the Pis themselves are "mostly" (sometimes this is stated as "only", but then there turns out to exceptions) made in a Sony plant in Wales. I believe there do turn out to be occasional minor differences (such as the HDMI jack) but this probably span time and space, and they will not simply be between Farnell and RS, although I think it's the latter that tends to be more involved with "not actually that plant in Wales". 

You can set the fsck and mount up at some point in the boot process yourself to get around this. The simple version would be if there's nothing else in the boot process which requires the drive, in which case you can add to (I'm presuming debian, btw; arch using systemd will be somewhat different). 

Actually there's a third, because almost certainly this library will have to make use of native code, i.e., be compiled from something that isn't pure Java, meaning it will have to be open source, unless you can find one precompiled for ARMv6 or 7 (depending on your model of pi). Anyway, Arduino tools are written in Java, run on Linux, and require use of the serial port. They are also open source, and apparently the serial com library they use is RxTx -- no ARM binaries, but the source repo is available via the downloads page. That's one example, and an explanation of what it is you are looking for, to make it easier for you to look yourself. 

I'm going to try and strongly disuade you from doing this. It is a gigantic waste of time. 4.9.3, released upstream at the end of June, and the most "modern" currently in 4.x, is available in Raspbian repos. Check to see what's actually available in jessie but I am sure there is a 4.9.x. Forget about 5.x (first public release was April) and especially 6.x (no official public release) unless you have a very clear reason for doing so. Which you don't, or I think you would not be asking this kind of question. 

1. I'm happy to write a daemon for this, since it should exist, but I will not have time for a month or so. 

In the sense of making it easier for you to mess with stuff you shouldn't mess with, sort of. This was made particularly easy on Raspian due to the idiotic choice of its creators I mentioned earlier. I would guess that decision was intended to increase the "spoonfeed" factor, unfortunately it was (again) a completely idiotic mechanism to use. OTOH, we don't get as many problems reported here as I would have guessed, so the choice to stick with it may not be as ridiculous as I'm claiming. In a more general sense you are correct, GNU/linux does not prioritize a normal audience, its primary real world use beyond the pi is for a range of things including internet servers, supercomputers, and embedded devices (which is how it ended up on the pi). However, there are obviously lots of normal PC systems using Debian, Ubuntu, Fedora, etc. It's probably worth finding a book or reading stuff online about, if you are into reading at all (if you made it this far into my post that counts, lol). Raspbian is a standard GNU/Linux OS so anything like "Linux for Dummies", etc. will apply. 

(see about ). You should see a few lines about those libraries. If the base C includes are useful too (in addition to those of the C++ wrapper library in ), those won't be in the compiler's default path, so you could use or else add to your environment: 

This may not work exactly like that, since the nature of the prefix isn't clear to me. However, it should at least change the error such that you now get something like 

Avahi uses a SysV style init script, with which Systemd is backward compatible, and enabling the service reports this: 

Which makes sense in this case, since the previous message was about wlan0 not receiving anything. Whether you actually want that to happen is up to you; it's certainly not necessary. I presume this is not a mandatory feature of either, so you'll have to either figure out how to configure it differently or else stop using it completely. 

This is modified version of MatsK answer. First confirm your default gateway is through the ethernet with just plain . It will probably include this: 

All of which provide PWM for at least the hardware driven pin(s). Python for has wrappers for all three. PHP has one for wiringPi and may have ones for the others. However, while the underlying libraries are I think reasonably well maintained, sometimes the wrappers are half-complete and/or abandoned. Since python is probably the most widely used method, it is probably the safest bet other than C. 

It can be like that (commented out, since the default is "yes"), but it shouldn't be uncommented and set to "no". You also need: 

Note these names correspond to another sysfs directory, -- but the information there does not look pertinent. However, in the same directory as there is , which apparently has a range of 0-255; normally when running it's 255. Although that node is writable, trying to change the value has no effect. But reading its state is obviously possible. 

Will show all the .jpg files in your current directory. For instructions on how to advance from one picture in the list to the next, see the KEYS section of . You can also set an automated slideshow with the option. You may get this error: 

In theory probably yes, since it appears to use an I2C interface, which the pi has. However, since there are various other control lines, it may be impossible to get the complete functionality. In reality, almost certainly no. There is always the chance that there is a linux driver for this camera kicking around somewhere. First, though, you need to identify the chipset in the camera, not just the phone it came from. That might be listed by Nokia (or someone else) somewhere online. If not, you would have to ask them, and likely they will just ignore your request. Manufacturers generally don't care if you want to hack on their products, but they won't necessarily give you the time of day in support. If there is no driver, one could be created, but it would require reverse engineering. Even without that -- e.g., if by some miracle the manufacturer of the chipset gives you the specification -- writing a camera driver is a serious task. If you paid someone to do it, it would cost you orders of magnitude more than the camera, or anything comparable to it, is worth. And if you could do it yourself, you would not be asking this question ;) 

To emphasize a point made in joan's answer, a quick glance at current "longterm" kernel releases shows that 3.2 dates back to at least January 2012 (I think the first 3.2 would be some months older), a month before first generation Pis became widely available, so it is very unlikely there is any branch of the Pi kernel predating that. You are not strictly bound to using a specific kernel with a specific version of Raspbian, however, you will probably have to compile it yourself, install the modules properly, etc. and there are no guarantees. 

No, the total bus speed of everything combined is limited to 280 Mbps. This is in theory enough if you are passing 40 Mbps through from USB to ethernet. 

The source pin isn't referred to because nothing about it changes. It's just a +3.3V source. The switch has two positions, and the inputs have two possible states when read. If the outcome looks like this, it means that Input B is pin X. If it's the other way around (i.e., B is always low and A changes state with the switch), then Input A is pin X. From this you can also deduce what X connects to in each position. Following the table, when the switch is left, it is connected to the source pin. When the switch is right, it is connected to Input A. The third possibility is that the source pin is pin X. The table will then look like this: 

On Fedora it will look a bit different. You need to deal with all the lines that read , except, in this case, some things that were installed into from ; to weed those out instead use (if this seems a bit odd it is -- is actually a shell script which does something similar with linking): 

Although it should be regarded as a last resort since it does increase the risk of filesystem corruption, unplugging the cord is usually okay if the green ACT light is not flashing intensely. By default the ACT led shows I/O activity on the SD card. If it is off, most likely the system is idle. This is not necessarily true, but killing a system that is busy with CPU intensive activity (and not I/O) is not inherently a problem anyway. The operating system does cache filesystem information in memory, meaning it can be out of sync with the actual storage on the SD card, but this should be dealt with at least every few seconds (you might sometimes be able to infer this pattern from the ACT led). So, if it appears idle after watching it for 5-10 seconds and you have no other choice, go ahead and unplug the power. Again, this doesn't guarantee anything and there are unfortunate scenarios whereby the system may get locked up and filesystem syncing doesn't occur properly, but in most cases you should be okay. I've probably had to pull the cord on a pi (or had power fail) over a hundred times this way and can't recall ever having grief because of it. Sometimes I will put the card in another machine and run on the root filesystem, which is worthwhile. The OS will check the filesystem automatically on boot but it is possible for this check to fail (or not be done correctly) and go unnoticed. 

This will show you some options but they are probably not very interesting. The only one you need to use is and even that is usually irrelevant. You will need some stuff installed first; on Raspbian at least: 

Commands like are also implemented, although things like , which I think was a Debianism to start with, are not -- except on Debian (and derivatives including Raspbian). These Debian things like may remain indefinitely or may disappear in the next version or so, but I expect that systemd's implementation of more core SysV commands like are permanent. The current on Raspbian is still the old Debian one. The Fedora one also includes this link which may be of interest: $URL$ Beware that while will show everything, only applies to this that are managed via an script. There are various commands that have parallels to : 

I think this is really post processing -- you want to work on video that is already encoded in some comprehensible, portable format such as H264. In this case, if the processing is fairly intensive, you may benefit from offloading it to another pi but don't bother looking beyond ethernet, which is sufficient to transmit as high a data rate as the pi camera can produce anyway. Wifi should also be fine as long as you are in decent proximity to the router. However, if the ultimate goal is processing on a PC, I doubt it is worth bothering with 2 stages. A 3 Ghz intel based quad-core PC is, for many or most purposes, not simply the obvious (3.0 * 4) / (0.9 * 4) times faster. It is more like 10 or 20 times faster. You should be able to easily test whatever you are doing this way, of course. 

Here's two methods you can try; both require you edit files on the SD card. Blacklist via : You can add an instruction to . is actually the first, small vfat partition on the SD card. Mount that somewhere and add to the beginning of the text in : 

You choices there are I think limited; there are no real VMs available, but you may be able to use containers. 

There's no problem with the GPIO system. The problem is that inotify, to which is an interface, won't necessarily work on all sysfs files, and it seems that this includes these. If you skim down the inotify FAQ, you'll find this perhaps overly optimistic note: 

I'll agree with that; I don't see why there needs to be more than one. In fact, I don't know how it could be done, since will refuse to start if running and the default port is taken by a previous instance. You should compare this to the output from . 

The sysfs GPIO interface is fairly straightforward. I'll demonstrate it using perl to respond to events from three buttons connected to GPIOS 17,27, and 22 (by the Broadcom numbering). You don't need to have any experience with perl to follow the methodology. Although all of the working code is provided at the end, I only refer to a small portion of it in the conceptual explanation. Recent versions of Raspbian give permission to anyone in the group for this but on other distros this may not be the case. Note files aren't regular files, which is why they have a size of zero. They are not stored anywhere because they do not really have content. When you write to a sysfs file, you are sending the kernel a message. When you read one, you are asking it for information. As per the documentation linked in the question (which you should look at, since I will not regurgitate all of it, and it is assumed below you are referring to this), the first thing that needs to be done is to open or export a specific pin by writing the number to . I'm creating an object oriented API, so I do that in the constructor for the GPIO pin class, if necessary. The sysfs interface is text based and line buffered, meaning it will output newlines at the end of each value, and "0" and "1" refer to characters, not integers. I.e., looking at this byte for byte those would be 0x30 () or 0x31 (), 0x0A (), 0x00 (). Of course, in most languages you might as well just use strings. You don't have to include the newline in input, but for simplicity with using and comparing constants in perl I do.