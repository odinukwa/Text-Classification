The program first determines the set of all possible values that can be entered into every blank square in the puzzle board. The possibility set is determined by iterating through the row, column and the block, and eliminating the set of numbers already present. The possibility-set is stored as a bit-filed value for each square. Every blank square with a single possibility gets the number entered into it. The algorithm is repeated from the first step again, until there isn't a square with just one possibility. If there aren't any blank squares left, the current board's state is returned as the result. It chooses a blank square and enters a value into it. The process of choosing the blank square, out of all the available blank squares is guided by an analysis algorithm. The value entered into this blank square is chosen from all the possible values that can be entered into the square. A recursive call to this function is initiated with a clone of the current board's state. Note that the current board state now contains the modification done to it at the 4th step (entering one of the possible values). Steps 4 and 5 are carried over until all the possible values in each of the available blank squares are tested with, or until the puzzle gets solved. 

The following defines bit-field values associated with each symbol accepted by the sudoku board puzzle: 

The class's function solves the entire puzzle. Understanding the functioning of this function will be enough to understand the working of the algorithm. The following, 

The signed integer values from represent the numbers in the Sudoku puzzle board. The value zero signifies a blank-box in the Sudoku puzzle board. 

The value represents a null-set. The values starting from to represent the values in the Sudoku board. For example, the bit-field value represents the set of numbers: . Therefore, unlike this stores multiple numbers in an integer field. An object of this type is used for holding the possible list of values that can be inserted into a particular square. 

Lets have a look at the algorithm you are using, and see if we can tweak it. First you get each vowel. Then you reverse the list Finally you get the index of each vowel and replace it with the next vowel in the list. There is a bug here, list.index will return the index of the first occurrence of a vowel, so if you replace the word with "aapiple" you will see the bug in action. The main area of interest is getting the index of each vowel, so lets do that. 

The padding works well up until 45 rows are entered, after that, it was too wide for my screen to properly read. 

This is not really written pythonically. Opening and closing a file (or anything with buildup/teardown) can be done with with. One small point is that loop=0 is essentialy trying to break out of the while loop. There is a nice keyword break that will do that just fine. The code would look more like: 

I may have missed some bits and pieces, but the idea here is to give you a starting point so you can look at your own code and decide what is good, and what needs to be changed menu.py 

This piece of code doesn't actually achieve anything, you are basically copying a String array to another String array, using an unnecessary parse too. Since it is not needed, you can just delete it, and change any later references in the code to it, to input instead. 

Presumably, from the many links you have many pages in the site, changing the header and footer on each page, every time there is a small change gets tedious, and a waste of time. A server side script like PHP would be able to fix this problem, or if you really want, you could encode the headers and footers in javascript and have to wade through that code for ever small change. I think doing it server side would be much smarter in the long run, and you can then learn how to make other features like a login, or a contact us page that sends emails 

This Sudoku puzzle solving algorithm follows a brute-force approach mixed with rule-based approach. To further improve performance, an extra analysis step is added, to determine which squares to be prioritized while choosing it to be filled. The priority value is inversely dependent on the number of possible values that can be filled into a particular square. This value is used in computing the priority weight value of each of the blank square that is to be filled. This priority weight value helps in ordering which squares must be filled first. 

These are the definitions of the generator functions. This shows the vital functions involved in the analysis process (the process to determine the priority of selecting blank squares): 

The following is the header file, containing the primary functions that are used in the evaluation process: 

Though this algorithm may seem to provide an alarmingly bad worse-time complexity, this algorithm almost never hits the worse time complexity regardless of the (legal) puzzle entered. List of types defined and used throughout the program : I. BoardGrid 

initializes the evaluation for the current iteration. The statement called before these is the program's attempt to try and solve the problem purely based on the rule-based procedure, trying to eliminate the set of numbers that can be entered into each square. The function iterates through each bit-field trying to discover the possible elements (values) that can be entered into the blank box. The set of values are then stored as bit fields. This function runs in a loop because, an empty box getting filled by a value might help provide enough information to figure out the value in a different box. Therefore, until such a possibility is ruled-out the function iterates. The above process configures the bit-fields, which would help the function to compute the number of possible elements that can be entered into each square. The next function, which relies on the result of the function, computes the which assigns a floating-point value to each square in the sudoku board following the expression and later the function is called followed by the function, which returns the list of all the empty cells, along with its associated priority value. The function sums the number of possibilities across each row, each column and each cell (the smaller boxes, which must also contain values from 1 to 9) and stores them in an array. The function returns a priority queue, sorted based on the priority value derived from the result provided by the other three functions. The final depth-first search is computed by recursively calling the function, belonging to a locally declared instance of the class. The sets the puzzle board for the next recursive call. Recurrence is brought about by calling the same belonging to a local instance of the same class, declared within the function. In what areas does my code need improvement? And how can I improve the design of my code and algorithm? I wrote this code intending it to be Object oriented. How object oriented is it? (I.e.., is there a better way to structure the same solution) And is there a better algorithm to solve this problem more easily? For complete code, please refer this URL: $URL$ 

I am implementing a game in python, which will give the user a sample encryption, and explain each step from plaintext to cipher. The task for the player is to decrypt a word by undoing each step shown above on the new word. For this, I have created an abstract algorithm which requires an encrypt function, and a current development status. In the future I think it will require other properties such as explanation text or a difficulty level. The abstract algorithm looks like this: 

There is no need to overwrite choice with the default again and again if it fails. Also a more explicit error makes debugging and reading easier. Finally I only catch on ValueError as something unexpected would be better off thrown back up rather than silently dying here. 

This also means you only have to check if both of the input co-ordinates are valid and on the board, which can be done before the method 

There is a bug here, if you reach the end of the array, and the longest sequence is at the end, what happens? I'll leave it to you to figure out the fix. A hint towards what I would do is try to add an extra check at the end 

This is discouraged, I don't think it makes much difference in a program of this size, but it can be a bad habit to rely on. 

This code appears many times. It would be a great candidate for a function. That way, adding a new set of problems doesn't require a whole load of copy pasting 

This is the code from the itertools docs here, with one amendment, to yield from instead of returning the iterable it creates 

I only have a few quick points, Names and consistency: In general, keep variable and function names to starting with lowercase. When I see an uppercase word, I think it will be a class. A second point here is if you are getting input, make sure the function name states that. There is no reason NameAndEmail couldn't be getNameAndEmail, and I know what the latter function does immediately. NameAndEmail looks like a class. 

I had written a Sudoku puzzle solver that accepts puzzle boards, and completes them with the least possible time. Rather than purely depending on brute-force, my algorithm first attempts to fill in the squares that have an obvious solution. And for each square being filled this way, the amount of information increases (I.e.., more number of squares get filled which aids in filling in the remaining squares) which makes the further iteration process easier. Once this method fails (this happens if there isn't an obvious answer to fill-into any of the squares), the algorithm immediately switches over to brute-force search. (Note, the source contains a few spelling mistakes, like the word recursive misspelled as Recrussive. Please ignore spelling errors. Anyway, it has been a while since I touched this code, and this was my first object oriented code written in C++). The basic working (High level view) 

Rule-based search: This method involves identifying the set of blank squares that can be filled immediately with the available information. For each iteration, the amount of information increases, and eventually as each squares get filled, the puzzle board gets completed. guided brute-force search: The evaluation algorithm, on a high level, is a brute-force algorithm which relies on an analysis method which prioritizes the blanks that are to be filled first. During each search iteration the rule-based search is called to complete the evaluation if the amount of information on the board is sufficient (as each depth first search iteration increases the amount of information on the board). The analysis method that guides the depth first search: This assigns a weight value for each of the blank squares based on a measure which determines the influence of filling-in that square with a possible value. 

type represents the set of all values that can/can't be filled in a square. This type is specifically defined for storing bit-fields for representing a set of values. This follows the following convention: 

This holds the priority value of each square in the puzzle board. This is used during the evaluation process, where each instance is sorted based on the . A detailed explanation will be provided in the later sections. 

It has been a while since I did any c++, so I'm going to focus more on the concepts rather than the language features themselves. There probably are more concise ways to implement this in c++ than I can illustrate. Note #1: Typos. You can use a spell checker on code, there is no reason you couldn't. Why I think it would be a good thing to do is because it will highlight 

including the width and height in HTML tags not good, HTML is about content, while CSS makes it look nice and pleasing. Mixing the two leads to difficulties down the line. As a small note, if you want an image to be a certain size, resize it yourself, and upload the resized picture. This means you don't have to adjust it with code. It also means that every time the page is opened, the image doesn't have to be resized. Its a win-win for both you and the users. 

This is the perfect time for if/else statements. One good piece of logic here is if they aren't equal, and a isn't bigger than b, we know the answer to a < b without needing to check. There are more things to mention, like moving the check if two numbers are equal to a method, and making use of the library of methods available, but get it working first, then post a follow up. Best of luck 

Algorithm What can we say about a knights move? It moves the piece 2 squares in a line, and then 1 square perpendicular. You have listed all the possible moves, but we can just check if one of the absolute differences is 2, and the other is 1. 

I think keeping it simple is the way to go. When would you really need a function to square a number though? That's all i've got, its not much, so hopefully someone can comment on the c++ itself 

To resolve this, use the standard practice of trying something, and asking for forgiveness later. I would suggest either an iterable you build up. Still this seems like a case of reinventing the wheel, it is unfortunate python doesn't have it built in to the itertools library. It does define grouper in the docs of itertools, which is kinda what you want, except it pads a fill value to the end of the iterable.