I actually wrote some code to do this. The gist of it is using statistics to correct unlucky streaks. The way you can do this is to keep track of how many times the event has occurred and use that to bias the number generated by the PRNG. Firstly, how do we keep track of the percentage of events? The naive way of doing this would be to keep all numbers ever generated in memory and average them out: which would work but is horribly inefficient. After a little thinking I came up with the following (which is basically a cumulative moving average). Take the following PRNG samples (where we proc if the sample is >= 0.5): 

As far as I know SteamWorks also provides lobby services - but your game needs SteamWorks approval before you gain access. You could also roll your own using Azure (e.g. using AppHarbor - for free); given how simple your requirements are. 

Diatribe: You should be trying to figure this out yourself - I was myself in the exact same position as you a year ago; and now I am doing soft-edged water etc. without copying code because I figured it out myself. I will try to explain the thought process you should be using - but you won't get one complete snippet. Furthermore, he uses a - which we don't have in XNA; so my answer will vary slightly. To start you should first search on how to use s, and how to use custom ones with a (if that is what you are using). Firstly, if you look at the video you will notice that the waves are moving outwards from the center - in order for a shader to perform any form of animation over time you need to provide it with knowledge of time. Therefore provide it as a uniform parameter (this means that it will retain its value over an entire frame): 

The user selects a unit and issues a move command to some place. The command is packaged up and sent to the server. Some times passes as the server gets the command and starts sending back the 'update position' commands. The unit starts moving. 

I am going to play the devil's advocate here: but you should really be doing this on the server - even with this method you still need to have logic on the server which is arguably more complicated. One way to is calculate metrics based on what the user has done. For example (e.g. let's say we were writing Diablo 1): 

Remember that an 'edge' might actually be just one vertex (we are colliding with the corner on another box). You will also note that this applies to B's hit normal. 

I assume you mean that forwards and backwards are working fine (from what I can tell they should). In order to move left and right you merely need to make the perpendicular and use almost the exact same logic: 

Remarks The way I did the distance-based one would likely emulate the (possibly more expensive) angle-based one - this is because of the . Either way experiment with them and see which you like best. 

Your actions should be both immediate and outcome-based. You would see an immediate increase in "good" because of the barrel you have placed; however at such a point it causes a disaster you would see a larger change toward "evil". This means that you would need to be able to store 'interaction attributes' with everything in the game world. "The player has interacted with this barrel", "the barrel has resulted in evil", "the player is evil." - or - "The Orc has interacted with this village", "the Orc is evil", "the player has killed the Orc", "the player is good." At the end of the day you need a set of basic outcomes that ultimately determine the good/evil of an action: create vs. destroy, heal vs. damage, assist vs. hinder etc. When correctly designed this would be entirely emergent behaviour; for example if, during the second play, the player went and killed the Orcs before they had committed any evil it would count as evil - you can't kill someone on the premise that they will do evil: some other condition might arise that would prevent them from performing said evil. Remember that "good" and "evil" are relational to your upbringing/faction/religion - therefore as an Orc partaking in their raids would be counted as "good" - however you could spin this as "Orcs tend toward evil, as such your standing is higher as an evil entity." 

With this system I saw no significant problems with grabbing assets when graphical objects were constructed (and storing them in fields), but grabbing them each frame is just wasteful and lazy. Also be careful about your ordering when it comes to adding and loading assets. You should always add the assets to the dictionary before they are loaded - this fixes cyclic dependency problems. 

This means that it isn't a proper 3D fluid simulation (I doubt you could do a 3D one in realtime at that scale) - I did some research into the topic myself a while back and pretty-much every post/article/paper I came across dealt with accurate 3D fluid dynamics: you just don't need this. If was to actually implement this I would do the following: 

This might get you close to what you want - but I never tackled it because I didn't have a concept to back the technology; and it's no small under-taking. Finally, remember that once you get past the fluid simulation From Dust is a really simple game - I don't think they had much bandwidth left after implementing the technology. 

You can use the same techniques as above-water landscape generation - but simply apply different principles. Here are some examples: Basic Landscape Underwater landscapes have much more pronounced features than above-water. This is likely because (as far as I know) the ocean beds are more tectonically active. None-the-less you will need to tweak the generator/perlin so that you get immensely deep ravines and so forth. Erosion/Weathering Typical above-water landscape generation relies on the fact that there is infrequent rainfall that runs downhill: contrast this with underwater where you have permanent erosion (so exaggerate the erosion effect) and where it also/partially runs in the direction of the local currents (so don't only send it downhill: create some currents before eroding). However keep in mind (depending on the depth of the area you are eroding) that the amount of deposits (sand) might be relatively small so you would reduce the weathering effect. This type of erosion could likely get very expensive to the degree where I would consider skipping it and just use classical erosion. Features Due to the depth variance (shallow to extremely deep) the features on the seabed vary widely. At relatively low depths you get coral reefs and so forth, at the other end of the spectrum (trenches) you get volcanic vents and so forth. Summary Read up on weathering and tectonics under water and try and simulate that. Remember you don't need to perfect it and create the perfect seabed - just something convincing so that the player doesn't think to question it. On my first attempt I would concentrate on: 

Note that this center is local to the texture - in other words don't pass the coordinate in in terms of screen space. Also, remember that you perform Texture lookups on the GPU using 0 -> 1 (not 0 -> ). In most cases you could probably just set center to . Finally we need to access the texture - to read colors from a texture you use a sampler - this will contain the graphic for the ship. 

Now you need a way for the player to control his spacecraft. From reading more about basic physics you will learn that motion is the result of force - I can't find a source but (as far as I remember). So when the player presses a key you would simply set the and variables to something and apply the equation during your update. Ultimately you need to think about the physics around the objects in your game - and instead of trying to make them move in the way you would think, rather look up the equation. Future Note: Remember that this is definitely not the best way to do physics (this is called Euler Integration and can lead to some odd scenarios at low frame rates) - you need to look into other ways of doing things (That article has quite a nice write-up on the bare basics as well). However, stick with Euler Integration for now, as it is means you are trying to learn one thing less. Which games would teach you how to think in the correct mindset? 

Some remarks which won't fit in a comment; low quality answer here because it's bed time. That code looks nearly right. I don't like the manual matrix creation (especially if you got it from an OpenGL website: OpenGL uses a different 'hand' for the co-ordinate system to DirectX): instead use the built-in . You might try fiddling with the order of multiplication of the matrices: with matrices. In addition you are not looking for , instead . However, again, it doesn't work like elementary algebra so - so you will need to recalculate the entire chain of matrices again. Camera classes usually have this information baked in, which you should find extremely useful for your entity class. Basically: 

You could also use resource IDs to decouple your resources from paths. On your development environment you would have a file such as: 

Now we need to bias the result of the value sampled from the PRNG, because we are going for a percentage chance here things are a lot easier (versus, say, random amounts of damage in a RTS). This is going to be hard to explain because it 'just occurred to me'. If the average is lower it means that we need to increase the chance of the event occurring and visa-versa. So some examples 

So for example lets say we have two ingredients; X and Y and blanks being *. Take the following recipe: 

NB: I am not asking how to use it, I merely want to know how it works as a matter of personal enlightenment. 

Also remember that dealing with 100's of users (as opposed to 1000's) is actually pretty easy. If you keep your networking code and your game code on different threads you might even be able to get away with blocking sockets (non-blocking/async was involved in solving the C10K problem). I have a blog post on the matter which you might find useful. 

I don't really know python at all. If your monster list changes often classical weighted chance probably won't work for you, at least if you are pedantic about performance. The problem lies in calculating the maximum chance; you need to iterate over the list at least twice to get the value. Option 1: Custom List By creating a custom list class you can skip one loop over the values. Let's say for instance we have some class that you can use as follows: 

The Disposer pattern helps you set up a predictable way to ask objects to clear their private fields. For example: 

Draw unscaled at the top left of the destination rectangle. Draw scaled horizontally (with ) at the top of the destination rectangle, with the left offset by the width of (1). Draw unscaled at the top right of the destination rectangle. Draw scaled vertically (with ) at the left of the destination rectangle, with the top offset by the height of (1). Draw scaled in both directions (with the width of (2) and height of (4)), offset by the width and height of (1). Draw scaled vertically (same height as (4)) at the right of destination rectangle, offset by the height of (1). Draw unscaled at the bottom left of the destination rectangle. Draw scaled horizontally (same height as (2)) at the bottom of the destination rectangle, offset by the width of (1). Draw unscaled at the bottom right of the destination rectangle. 

Have some disk-based dictionary/hashmap (B+Tree/SQL-Light) - the value would be the item ID of the recipe result. When a user is crafting something simply find the first row/column with an item INDEPENDENTLY; combine those into an offset. Find the last row/column with an item, again, independently. Compute the width and height from the items and add it to the key. Loop over the range of the bounding box you just computed and append the ID of each item (using your usual ). Look the key up in the database. 

You should be able to use GameSpy. According to their marketing you also gain access to (above and beyond lobbies): 

That subtraction and is so that we can contract the size of the gradient (remember it occurs in a small space around the current desired distance, not all the way from ). Now we can finally get to the bit where we mix the two textures, remember that I said we are going to repeat the shield texture. Another nifty the thing the GPU can do for us is wrap textures, that is, if you ask for a pixel at 1.1 it will actually grab it from 0.1 (if you think about it you will see that they are also just using /mod for this). So in order to repeat a texture we can just multiply it by the number of times we want it repeated: 

Why did he gain 2000g worth of items? Clearly he is cheating. You could either decide on a suspend or a ban based on the percentage gain; or, you could find a curve that fits the users gold gain (before he cheated) and calculate how long it would have taken them to make that gold - and suspend the account until that time period lapses. It becomes more involved though, some other questions your server needs to answer is: 

That accuracy tweak could also take distance into consideration - I think using the 'length squared' of would get a pixel-perfect result. Narrow Phase Do a binary multi-sample using something like PMask - the logic will be exactly the same as above; just using a different collision routine. Finally You will be able to work out the time-of-intersection from , and your current and (assuming you have a reasonable integrator). 

The user selects a unit and issues a move command to some place. The command is packaged up and sent to the server. The client starts moving the unit. Some times passes as the server gets the command and starts sending back the 'update position' commands. The client starts receiving the position of the unit and over a duration of time (possibly one second) gradually moves from its prediction to what the server will be saying further down the line (depending on the current latency) - once again you would use a lerp here. Furthermore ensure that you smooth (a moving average of the latency might work nicely) the latency so that the unit doesn't jump around.