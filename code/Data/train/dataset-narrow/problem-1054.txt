Introduction First of all: well done you for writing your own framework! (Just don't forget to throw it away once you feel you've learned enough). Configuration is, architecturally speaking, much more solid than relying on convention, so you score points there to! Some minor issues 

General impression You are not actually injecting any of the dependencies into , you are injecting a service provider that has to locate the dependencies. It may feel like dependency injection but it really isn't. What you are doing here is, basically, creating spaghetti code. Suggested improvements My question would be: What is the responsible for? Your UserProfile class depends on a View, ORM and FormBuilder class. It is in control of retrieving the user from the DB, outputting a header and outputting the user in the view body. The FormBuilder does not even seem to be used. There are several ways this could be cleaned up, for now I'll use "classic" MVC. Assuming (based on the function name) that this class is primarily a View, it should only need the user Data and your ViewCreator to function. Your router would call the Controller that would retrieve the Model and pass it on to your View. The suggestion below completely removes the service locator from the picture. Please note that the code is written for clarity in conveying the message, it is not meant to be 100% working or correct (especially the static call syntax in the controller). 

@Donals's suggestion was a good one. I do not check for overflow - I suppose an exception will be thrown then. I did not try to compile and run this using Java. Please do try it yourself. Note that fast code quickly starts to look ugly ... Remember to properly measure the performance of your code. $URL$ Also these two could be used to figure out if the number is a power of 2, and what that power is. $URL$ $URL$ Basically, the lowest and the highest should be the same. Here is an interesting and useful page: $URL$ 

There is a different way, supplemented by documentation. One can say that it goes against OOP, one can also say that it keeps things simple and favors composition over inheritance. Here is a convention for local connection. This approach condenses the entire state to a single string value. This is not the only way. Sometimes this is a bad approach, sometimes a good one - depends on how big your architecture is and what your use cases are. 

Here is my version. I made it a bit more "functional" - less state, more static (not to be confused with noise). I have two methods instead of one; An helps me pack an open-ended input (a string of arbitrary length) into what I really want (tri-state). I tried to minimize RAM usage by initializing the dictionary and the list of allowed keywords only once. At this small size, the dictionary is not a perfect choice in terms of run time; two plain arrays would do a better job, but it is a premature optimization. The code is also slightly more unit-test friendly since it takes and as parameters. I am still not perfectly happy with the code though. The body of the method should be shorter; the logic and the textual "UI" is still not well separated, plus the language for interacting with a user is not that great. ideally the "engine" would be completely separated from "reporting". 

Things could be cleaned up even further by not initiating classes from the router but injecting them into the router from your delivery mechanism/root/index.php/etc. Further Suggestions You say you're not well versed in any framework but what you seem to be doing here is very similar to the way Silex works, which uses Pimple (which was mentioned in the comments to your question). The learning curve is quite flat so it could be worth the effort of seeing how Silex does things. If studying an entire framework takes too much of an effort I would strongly suggest you take a look at PHP-DI to observe the way a Dependency Injector should work. 

You are putting way too much logic into your controller methods. Most of the logic should be placed in a service that should be injected into the controller. The logic in the controller methods really shouldn't do much more than grab a value from here, set a value there and maybe call a function on a service. The most extreme way of achieving this would be to make the entire controller a service, creating a new controller and see how much you need to move back from the service into the controller. In regards to the "how", you may want to take a look at Chris Fidao's talk about hexagonal-architecture, 

I would also suggest that you look into some popular MVC frameworks (Zend Framework 2, Symfony 2) to get comfortable and confident with the concepts. 

I like the idea of this utility class, but there are a few points I would like to mention. Let's start with naming. I would rename the class, probably, to one of the following , , or . The rule of thumb is to put the / nouns in the end of the class name. Personally, I like the first two. Then come the constant fields which could be shorter. For instance, they could be named as instead of and instead of . That is, the 'BETWEEN' part is redundant because it's already obvious that a separator separates the one from the other. Two other fields would be better named as and , which is more intuitive. Another thing is that you have two separate methods for adding the field names and values and then you check that there is a corresponding value for each field name in the method. You also check for indexes and arrays' length in the method. All these checks are error-prone, but they could be eliminated by enforcing the one-to-one correspondence rule of the field names and values in a single method for adding those fields and their values: 

I am basing my answer on Jesse's. It would be unwise to throw away some of his optimizations. The only improvement I can offer is not using Regex but doing the equivalent check manually, because it is such a simple regex. If you have to use a different one, then this will not work. Note that I also made the methods static, made them take every parameter explicitly, thus making this code more "functional". Also, it looks less like Java because method starts with a capital letter and I use instead of . You are probably storing stuff as a HashSet but I am taking Collection as an input. Firstly, I was not sure which exact container you have. Secondly, this should not affect the speed, but if you prefer to do it differently, then you may do so. 

My biggest issue is with ambiguous variable names and excessive comments. The reason why you wrote so many comments is that the variable names and the method names do not speak to you. Here is my first attempt to clean it up: 

So, default argument values are nice, but in this case I favor the old-school (multiple methods with the same name) approach 

As a first pass here is what I got. It is nowhere close to what it should be, but it is a start. If you gave more code, I could perfect it further but right now I do not know where the variables are coming from. 

The first code snippet is an example of Active Record, which, I believe, violates the Single Responsibility Principle by mixing the logic with the logic. The second code snippet is thus better in that it separates the responsibilities. The naming of classes is somewhat ambiguous and inconsistent with the commonly used terminology. The aforementioned responsibilities would often go into two separate layers (namespaces) called layer (sometimes , , etc) and layer (sometimes , , , , etc). The layer contains objects, like for instance. The objects may extend a base class often called or . The layer may contain , , , or classes depending on which strategy (Design Pattern) you choose for persisting the objects. So, eventually you might end up with something like the following. Package structure 

Let me make it clear for myself. You have an array of images, which sometimes can be empty. You start off by checking the first image, if it's valid for your needs you take it, and if not you keep on checking the next one, and the next one, and so on until you find the one which is valid. Is that right? If so, here are my few thoughts. Firstly, I must say that Glenn has made good points, namely: 1) factor the common code in all cases out to a separate function, and 2) if you have nested conditionals, most times it's better and more readable to replace it with Guard Clauses. However, personally I would prefer the following solution: 

I like static methods, Rich Hickey likes static methods. Static methods are one honking good idea! Let's have more of these. The static methods hatas will keep on hating. 

Since you are printing at the same time as you are trying to figure out if it was found, then no, you cannot. If you do not mind using higher level approach such as Linq, then here is my version below. It just might be a tad faster for large number of combinations if and are slow. 

My answer is heavily based on that by @WouterH, so if you upvote me, then you must upvote Wouter twice. What I did is provided a "full" code listing, cleaned up some variable names and comments (many comments were removed after the proper variable names were used), added a class for the image header and added the placeholder for the error checking. I am not too happy with the magic constant because I do not fully understand what it does. You could replace code contracts with exceptions in order to use fewer assemblies. You can speed the code up a bit by pre-computing some variables in the ImageHeader class once. Other improvements are possible, but we have not seen your entire code, so it is hard to tell. I would also split up this one file into two different ones - one per class.