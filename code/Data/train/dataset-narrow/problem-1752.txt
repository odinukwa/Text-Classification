In this instance, the OpenVPN would be used to logically extend your LAN. This would allow your devs to connect to the web server, database, etc. as if the EC2 instance was a computer plugged into your network. The alternative is to tunnel everything through a SSH connection using port-forwarding. Each developer would have to manually set up their SSH client to do this and for each TCP port they wanted to connect to. Functionally, these two options are equivalent (and even use the same encryption technology). But a VPN is generally easier for users to use because it "just works". 

With a NAT connection, the host computer (your primary, physical machine) is acting like a router/firewall. The VM piggybacks off the network interface of the host and all packets to/from the VM are routed through it. Since the host computer actually sees IP packets and TCP datagrams, it can filter or otherwise affect the traffic. When the VM is using bridged mode, it's connecting to the network via the host at a lower level (Layer 2 of the OSI model). The host machine still sees the traffic, but only at the Ethernet frame level. So it's unable see where traffic is coming from/going to or what kind of data is contained in that traffic. 

I have successfully set up OpenVPN connection between my firewall at home and my EC2 instances. It works quite well, but I'm using Linux at both endpoints, so my experience won't directly translate to your config. As much as I hate IPSec VPNs, you might find that an easier route to try. Have you looked into Amazon's new "Virtual Private Cloud" service yet? This sounds ideal for your needs. 

is the most reliable way to get a user's IP address when your app is behind a reverse proxy/load balancer. However I don't know what you mean by "trust"? is an HTTP header that can be easily modified by the client or any system between you and the client. You don't want to use it for anything like authentication. 

According to this answer to the same question on the devkit mailing list used by upower, newer versions no longer emit that signal since this handled by systemd. The replacement in systemd-land is logind, which has a signal called PrepareForSleep: "The PrepareForShutdown() resp. PrepareForSleep() signals are sent right before (with the argument True) and after (with the argument False) the system goes down for reboot/poweroff, resp. suspend/hibernate." Here is a simple python script for watching suspend / resume events: 

I have to say that this list here is helpful, if a bit confusing: it includes low level protocols (like NX, VNC, and now xpra) as well as high level wrappers (like neatx, freenx, and now winswitch). Also it points to some VNC implementations, but not the more recent TigerVNC fork... 

If advanced routing is a bit difficult for you then I would not recommend this approach. The problem is that by default each dhcp lease will claim the default route and also update the list of dns servers. Then there is the firewall issue: how to detect when the it is down, etc Buying a cheap and easy to configure router might just be better for you. 

One option I have used before is to define your own delivery wrapper (I use maildrop for actual delivery - but this should work with any) then you can just do your stuff there. Something like this in : 

When I have had errors like yours they were normally fixed by replacing the drives (even though smart did not report errors - it's not always 100% accurate and I prefer to be safe). However, since this is a recurrent problem, you should consider the possibility that it is the cables (already changed so probably not) or the controller (try to add a PCI/PCIe controller and see if that helps?). Maybe upgrading the OS kernel would help too if interrupts get lost because of buggy chipset support. 

So, the requirements are 1. Solid product with a lot of features that 2. Costs little to no money? This sounds like a job for open source! For the NAS part, take a look at OpenFiler. It's a great application that let's you roll your own NAS/SAN device. It installs via a bootable CDROM image and is managed via a web GUI, so you don't even need any Linux experience. To give the remote users secure access to files on Openfiler, set up a firewall that also functions as a VPN endpoint. My personal preference is a dedicated Linux server running Shorewall and OpenVPN. Shorewall is extremely powerful/flexible but unless you're familiar with managing firewall rulesets in a corporate environment, it has a steep learning curve. A better solution for a small biz client might be loading DD-WRT onto a Linksys WRT54GL and using that in conjunction with the OpenVPN on DD-WRT instructions. Good luck! 

I'm using CentOS 5.5 x64 on both the dom0 and domU. I am attempting to pass-through a 3-port NIC (Realtek Semiconductor Co., Ltd. RTL-8110SC/8169SC Gigabit Ethernet (rev 10)) to the domU using pciback. However, when the first port on the NIC is brought online, it causes the domU to crash. Any suggestions? (eth0 is the on-board NIC, which works fine). Edit: By the way, adding 'swiotlb=force' to the domU kernel line (as recommended in the dump) causes the domU to fail with the same error, only it happens immediately upon launching the vm. 

This is not possible with Elastic Beanstalk (at least not without really misusing it). Elastic Beanstalk is "fire and forget" type of PaaS solution aimed at simple deployments. If you really need this type of functionality, look into CloudFormation which lets you get much more granular with your instance configurations. 

Just tossing this out since it hasn't been mentioned yet. But MS's own PowerShell is actually a really good CLI for Windows. It has some Bash-like features that should make it feel somewhat familiar. In my opinion, it's worth learning if you do any type of scripting or automation with Windows, even if you're primarily a *nix guy (like myself). You'll be able to do more in less time compared to trying to hack together something that runs atop Cygwin. 

Postfix Virtual Readme is the mandatory starting point and covers what you are trying to do, then google for more (ie: distro specific instructions, etc). There are many tutorials out there, all slightly different, most use a database like mysql as backend, but if you understand the postfix concept of maps then using plain text files is no different. 

Short answer is that you cannot do this with VNC. Each TCP port will be bound to a unique session. As far as I am aware you will have the same conundrum with Xpra, VNC, NX, etc. (going via a server, like freenx, and connecting via ssh is a workaround but not an ideal one!) You may be able to workaround this by writing a simple load-balancer type of application, but this will still require one port per client. As for the rest of your question: the dimensions are specified with -screen. For just starting Xvnc with these options, something like this should work: 

You can run it before or after calling maildrop, important note: the script will receive the email via stdin, so you will have to buffer it if you intend to pass it to maildrop later (which the example above does not do). I would probably recommend using perl for this as there are more mail handling libraries there than in bare shell. Edit: If you only want to do this for a single user then this is overkill, have a look at maildrop - in particular the section about "external commands" via backticks. Define a maildroprc for this user with the rules required. 

The Xvnc session and application startup: I would place all this in a script and start it from xinet.d The tricky part is to prevent users from re-connecting to an existing session. This is a unusual requirement since that is one fundamental feature of VNC. You may be able to get away with parsing the output of the Xvnc process and killing it (with the app) when you see a disconnection event. For killing the Xvnc when the app terminates, just wait for the appication to terminate in your script and kill Xvnc if it is still running at that point. 

Edit: I see that the device is showing up as "p2p1" in the . I altered my manually created init script and the interface now comes online with an command. I can ping myself too. Working to get it online in the proper VLAN now. I will update this post again with the results. Edit: Very cool. It's now working! I wish I knew why a) the device name is "p2p1" and b) the OS didn't automatically add the init script? Thanks again for your suggestions! 

This is expected behavior of EC2. If you want more granular control over your IP addressing, you're going to have to create instances inside of a VPC. 

Python (by far) is the best all-around language for this type of stuff. It's cross-platform and is used for everything from 3D games to web apps nowadays. Investing the time learning it will give you a very portable skill. Python also has a very clean syntax and easy to pick up the basics. 

Ideally, I don't want this large of a range specified. Is there any way I can specifically configure and ? 

Yes, if you have reserved instances purchased in , for example, then you explicitly want to specify at launch. RI's are purely a backend billing thing that function like an invoice credit. The EC2 instances themselves have no awareness of whether they're an RI or not. The way RI's are handled is actually one of my top five complaints about AWS. I'm hoping that they improve on this soon. 

I am building a CentOS 5.4 system that boots off a compact flash card using a card reader that emulates an IDE drive. It literally takes about an hour to boot. The ultra-slow part occurs when Grub is loading the kernel. Once that's done, the rest of the boot process only takes about a minute to get to a login prompt. Does anyone have any suggestions? I suspect that it may have to do with UDMA. Everything IDE-related in my BIOS seems to checkout. The read performance hdparm is telling me 1.77 MB/s. Ouch! (But even at that rate, it still shouldn't take an hour to decompress and load the kernel)