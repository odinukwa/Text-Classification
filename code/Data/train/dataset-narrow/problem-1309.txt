Writing useless comments is definitely a bad practice. For instance, doesn't make much sense: it is absolutely clear that it is a without any comments. I'd recommend simply deleting comments like this one. Comments inside a function that tell what a block of code does, like here: 

Unfortunately, your algorithm is not correct. It evaluates an expression to , but it is clear that the right answer is zero. It is not an implementation bug. The logic itself is wrong. So what can be done to avoid(or, at least, to minimize the risk of) ending up with an incorrect algorithm? 

The second one contains a lot of redundant code: is already the answer, it could be just something like instead. So the second one does not compute anything, it just prints the answer, while the first one can be used to find an LCM for different values of , not just 20. 

Blank lines: it is conventional to have a blank line between methods, constructors and so on. Here is a refined part of your class: 

The Logic.java class contains a lot code duplication. It's easy to get rid of it. For instance, the expression is used four times. I would rather create a method for it. There are a few "strange" reassignments: for example, in the method and are initially set to and unconditionally reassigned a few lines later. Creating them upon the assignment of the second value (the only one that is actually used) makes the code more clear. The case when the equation has complex roots looks pretty convoluted in general. I suggest doing it this way: 

First of all, using a pool to make it easier to work with memory is a bad idea. It definitely doesn't make it easier. Your code is quite non-trivial. If you want to make it easy, just stick with standard containers and smart pointers if you really need them. Odds are, you don't need any pointers at all. For instance, why can't be a map from an to ? Why can't you just create items without dynamic memory allocations? It's not clear from the code you've posted. A valid reason to use a custom pool would be performance. If standard containers are too slow for your application, you might need it (but again, I'd recommend implementing it without manual memory management and measuring the performance. You'll save a lot of time and effort if it turns out to be satisfactory). You also seem to maintain some kind of linked list of free items. Why not use instead? Are there any good reasons not to use it here? I don't see the point in reinventing the wheel. This part: might be incorrect (I can't say for sure as you didn't post your class). Not all objects can be copied byte by byte. Do you have any reasons not use instead? To sum it up, I'd recommend to start with standard C++ containers and algorithms first (they are efficient for most of the practical purposes) and try to change something only if you run into performance issues with them (Again, measure it. Don't assume that they'll be too slow). It would be great if you can avoid manual memory management altogether. It's very easy to get it wrong. It's also quite possible that your custom solution turns out to be slower than standard C++. 

The time complexity of your solution is , where is the length of the given string. It is possible to do much better. Here is a linear solution: 

is usually used for something with side effects. If you want to transform one sequence into another, is an idiomatically better choice. 

I would also load the in the class constructor from a file because it looks like a reasonable thing to make customizable. There're also a lot of "magic" constants in your code (for instance, (64, 0, 96, 64). What does it mean? I have no clue). You can make your code cleaner by creating a variable with a meaningful name for each such constant. 

You can also use the operator in this line: The names and are kind of confusing in your code. normally stands for a counter while stands for the number of elements. For instance, I'd change and in the first line of your function to and (when is not the counter, the thing gets pretty confusing). Assuming that it's python 2, you can save some space by using instead of . It can a have a serious impact if the gets really big. What is the point of creating the variable just to return it? Why not return the directly? The function actually changes the . Your documentation doesn't say anything about it. This could lead to unexpected results for the users of your code. You should either make a copy and not change the input, or document the fact the input is changed explicitly. Instead of printing the return value of the function to the standard output (and checking that it's correct by looking at it), I'd recommend to write unit-tests. This way, you would be able to check that code remains correct after your change it automatically (moreover, it's quite easy to overlook something when you just look at the output with your eyes). 

There should be one whitespace before an opening bracket. Again, there is an inconsistency in your code: a whitspace is present most of the time, but it is not present, for instance, here: . Not following established style guidelines is not good, having inconsistencies is definitely bad. A little bit about blank lines: they should be present between different methods and it is fine to have them inside one method if it is really big and you need to separate logical blocks from each other(however, too long methods should be avoided). But having a blank line after each statement is pointless and it makes your code less readable. 

Pick an arbitrary vertex . Find the furthest vertex from (let's call it ). Find the furthest vertex from (let's call it ). The distance between and is the answer. 

If a is passed to this method, it will throw a . If is not an instance of the class, it will throw a . Such behavior violates the contract of the method. I would write it this way: 

It looks much better now(and it passes the test)! The old version was incorrect because we can have several different lines with the same number of points on them and there is no guarantee that , , and lie on the same line(you can take look at the unit test I have shown above to understand it better). 

Separation of concerns Your class is a mix of an allocator and a container. There's no point in doing that. One class should do one focused thing. Some of your functions (like ) are essentially a reimplementation of standard C++ algorithms (like ). Why would you add them? Proper vocabulary An "allocator" term has a very precise meaning in C++: $URL$ Your allocator is not exaclty an allocator, even though it uses a similar vocabulary (like the allocate function). It's quite confusing. Moreover, the vocabulary of your class is not consistent. The words "allocate" and "dead"/"alive" have a different level of formalism. The whole indirector related thing is also not that easy to comprehend because there's no such notion in C++. While these things might seem unimportant, they actually play a very big role in making your class easy (or hard) to use. Overall design and API Your class's API is very complicated. It provides a lot of functions with similar names and slightly differnet behavior. It feels overwhelming. All an object pool needs to do is allocating and deallocating objects. That's it. Having more functions is not necessarily a good thing. Keep it simple and focused. The code itself 

is a strange name for a function. It's name doesn't give any clue about what it actually does. Even something simple and generic like would be better. It's a bad practice to use one variable for two different things. and stand for the user's input as a string and then they turn into integers. I'd rather create two separate variables for each of them (one for the input and the other one for it's integral value). 

loops can never terminate if the table is full. If all the slots're used and you're trying to insert a new element or look for a key that isn't there, it'll keep wrapping around as there're no elements in the array. You can fix it by terminating the loop after iterations, but it's only part of the problem. The real question is: what is the desired behavior in this case? Being unable to keep more than elements (which should be known at compile time) is a serious limitation. In fact, a hash table that can hold only 20 elements is likely to be quite useless in practice (if the amount of data is so small, a simple array is unlikely to cause any performance issues). Ideally, the table should grow when there's too little room left. Roughly speaking, you should allocate a larger array, rehash the elements, but them into it, and delete old array. Even if you decide to keep it fixed-size for simplicity, you need to indicate that the table is full somehow. It shouldn't silently fail to insert a new element. Using error codes is a typical way to do it in C. You can run your program under valgrind (or some other memory-checking tool) to see if it leaks memory. If it does, your function's wrong (or is called improperly). Assuming that always returns a valid pointer is dangerous. It may not. You need to check if its return value is not before working with it. is not a good name. It doesn't delete a hash. It deletes a key. It should be called correspondingly. It's not clear how you code behaves if the user tries to insert a key that's already in the table. Does it allow duplicates? What value does it return upon lookup in this case? Whatever the policy is, document it. 

You should always test your code in a systematic manner. Unit tests are a good way to do it. They will help you to find and fix bugs and to make sure that it works properly(but not to prove its correctness, of course). They will increase maintainability and reliability of your code. You should write unit tests for all public methods. Do not forget to test edge cases(deleting an element from an empty heap and so on). You expand an when necessary, but you never shrink it. It can lead to a big memory overhead. For example, if we insert a lot elements into the heap and then remove most of them, the will not shrink, consuming much more memory than necessary. You can fix it by either adding a method or by using a instead of an array here. An can handle all required operations for you. So I would use it, unless you decided not to use a on purpose as an exercise. If it is the case, I'd still recommend creating another class that implements the interface(or provides a similar functionality) to decouple a heap from a dynamic array. It will make your code more readable, flexible(what if you decide to change the implementation of a dynamic array one day?) and testable. Code style: 

I'd suggest using a loop here because it would make declaring the counter outside the loop natural and the number of iterations is not known beforehand (which is a common use case for a while loop). 

The code is much simpler and more efficient. To find the path itself, we can just iterate starting from the destination vertex and going to the current vertex's parent until we reach the start vertex. This way, it requires a linear amount of time and space. The code itself is rather obscure, in my opinion. Why do we multiply something by -1 here: (probably you do it to "reverse" the order, but it's not that clear when you read it for the first time)? The fact that is actually a weight of the edge is also confusing (I would expect to see something like distance or weight in the name of the variable if it stores the length of the edge). By the way, depth-first search works with unweighted graph, so I don't see the point of storing the weights, anyway. 

This way the meaning of the indices is clear. It's also clear why should move right while is moving left. There's no need to handle any corner cases. I also suggest returning an empty list or if the target sum is not found. I don't think that throwing exception is reasonable. Not finding the sum is a normal, not an exceptional situation. 

It looks like you are not confident in your code. It is a good practice to test the code in a systematic manner(using unit tests) to be sure that it works(of course, tests cannot prove its correctness, but they can help to ensure that it behaves properly for specific cases. It is much better than nothing). 

I'd change it this way or rename this class to . Object reuse Creating four new objects for each operation per each expression evaluation can be costly and is unreasonable because the operation are stateless. You can use a static factory to reuse the same objects in different expressions. 

Writing self-evident comments is a bad practice. For instance, this comment doesn't serve any purpose. 

That's pretty weird. It makes no sense to continue the computation if the throws. What is the point of having a finally block that throws the same exception? I would rather let the exception pass through instead of catching and rethrowing (the original exception is likely to contain a more meaningful message, too). Variable scope Try and use the narrowest possible scope. For instance, here: 

Variables naming: their names should start with a lower-case letter(it might not be the case for constants, but there are none of them in your code). You have it almost right, except for the , which starts with a capital letter. You should also give descriptive names to your variables: and , are not really good. Indentation and whitespaces: there should be a whitespace after the opening bracket, before the closing one and around binary operators. For instance, 

It looks like a bug. For instance, when you erase the 0-th element all other elements get shifted, so the new element at position 0 will never be deleted. You can just iterator over the vector and clear it after the loop. I don't see the point in removing the graph edges after the vertex is processed. I'd suggest to create a separate vector ( or ) to keep track of processed vertices and leave the input graph unchanged. If the graph is sparse, you can improve the time complexity from to or even using an appropriate data structure (like a heap). I'd also suggest to create a separate class for an edge instead of using . It's hard to confuse with . It's easy to confuse the and the elements of the pair (it's not easy to keep the meaning of the and the elements of the pair in one's head). You can make the code more readable by naming your variables in a more meaningful way (for instance, what is ? It's something like , isn't it?). When you need to iterate over a container and you don't need elements' indices, you can use a range-based for loop. For instance, this: 

"Magic" constants. It is not good to use such numbers as or directly in your code because their meaning is not clear. You should create variables with meaningful names to hold these constants. For instance, you could have a 

That's actually wrong. Let the array be . Your solution would take the whole array as the maximum during the first step (the sum is 11) and remove it, leaving an empty array, so it would return 11. But that's not correct. Two subarray [0, 1) and [2, 5) add up to 12, yielding an optimal solution. It also implies that your solution to the stock selling problem is also incorrect (a counter example can be constructed in a similar manner). You can use dynamic programming to solve the problem correctly. There's a constant number of states in each layer, so the extra space complexity is constant (the code is in python, but it should be easy to implement this algorithm in any other language):