This question falls into the subject of Runtime Analysis. Assignments are, by nature, constant time operations. From a performance standpoint, you generally don't need to worry about constant time operations. Since you asked: Any primitive operation(assignment, logical evaluation, etc) are generally considered to take one flop from a runtime standpoint. Occasionally there may be more cycles for other overhead, but as a general rule they are considered to take one flop. Lets compare pseudocode: 

I think the issue is that the input is being polled every frame as part of the Update(). I would suggest pulling the input from the Update() and using input callbacks instead. That way the input is only polled when fired, and not every frame. That should cause the direction to only update with input changes, and the Update() will continue to render the same direction until the value is changed the next time the callback fires. Unity doesn't have callbacks, I forgot that I emulate them. This is going to take some more thought on my part. I will update soon. If your game is a top down on an 8 point compass this gets a lot easier, but I'm trying to come up with a generalized solution. 

One thing I would be careful about is using the correct input callback. I would suggest one of two things, read the API's on the input methods available, and choose the one appropriate to your desired behavior. Some callbacks only fire if the key is held down, and others fire on a tap. Secondly, your architecture should change a little bit. The callback should only set the Target transformation. When you click on a pot, copy the transform from the pot to the target of the move script. The move script should be changed to automatically strive to achieve it's current target transformation until it reaches it, at which point it will wait until it receives a new target. This is best done by having your movement code in the Update() method within the script. For a small game, this will achieve your goal, and not cause much overhead. (Bigger games with many moving entities need to approach the problem a little differently) These changes will mean when you click a pot, the target will be set, and on each frame the movement script will adjust the chef's position if it doesn't match the target. The beauty is that you can reuse the "moveto" script for any other objects, with either a fixed, random, or controlled target transformation to add a little extra to your game. (a rat, or an assistant for instance) 

I have no idea whether this will work well for crowds; you may run into too much artifacts after an order of magnitude of simplification. If you do get it to work well, it will make an interesting paper. 

I'd like to examine two multiplayer class-based FPS games with support classes as case studies: Wolfenstein: Enemy Territory and Team Fortress 2. Both have separate classes that give health and ammo, and I think it's helpful to consider both types of support. Enemy Territory has three support functions - healing, reviving and ammo - given by two classes - medic and field op. Healing and giving ammo are similar: the medic or field op uses up "charge" - a limited, regenerating meter - and throws down a pack of health or ammo not far in front, which can be picked up by any other player. Medics could also revive dead teammates by using a close-range "needle" on the body, and in practice medics rarely ran out of needles. The game also rewarded support actions in the form of "xp"; gaining xp would eventually make the player gain ranks, improve or even gain new abilities. This provided an extrinsic reward to supporting teammates. In practice, there was an abundance of revives and a shortage of ammo giving. Revives were common because of two factors: it was obvious who needed reviving, and it used up practically no resources. Ammo giving was rare for the opposite reasons; in addition to using up "charge", the field op was a peculiar class in that it can also call in powerful AOE attacks, but at the cost of charge, so there was resource contention. Then there's Team Fortress 2 which hopefully needs no introduction. I feel that the medic was designed very well, whereas the engineer's dispenser ability is flawed. Whilst medics can be rewarded by earning assists when healing teammates that produce kills, the dispenser does not reward the engineer when being used. In practice (and echoing Thijser's observation on dispensers), medics were abundant but dispensers were often placed at inconvenient places. To encourage players to give ammo (and support each other more in general), I offer the following tips: 

In a nutshell, what makes a shallow water equation a shallow water equation is that the water height is not zero and it assumes no variation in the seafloor. Note: No fluid dynamics equation will allow for a water depth of 0, as that would mean you have no fluid. You should read the Wikipedia article on the shallow water equation. Basically, in shallow water, the vertical velocity is ignored because the value is so small and has minor impact to the wave propagation. To quote the section in case of modification of the source page: 

TL;DR: In order to do what you want to do, you should be using the Boussinesq Approximation, which does not assume a flat seafloor surface. This is a very interesting question by the way, I don't see many people try proper water simulation often. 

One thing to think about here is that you are updating the entire mesh UV state for each tile you modify. I'd be sure to check and make sure it's not refreshing the mesh after each tile. you might return the UV updated array one level up and marge them all at once. Basically restructure so you calculate all, then apply the changes to the chunk/mesh. I also notice you're searching for the chunk index once for every tile you update. Do this outside of the tile loop, and pass the result to the SetTile() so you only do this search once per chunk instead of once per tile. 

Most games use some form of quadtree or octtree to organize and sort entities efficiently at runtime. The item's typeID is stored in the tree, and the renderer loads an instance of that type of entity when the player is within the same part of the octtree as the entity. 

As far as I know, phaser is 60 frames per second only, and you don't have access to the delta time. If you want to simulate 30fps for example, you could skip the every second frame. Read more here: $URL$ It is therefore up to you to make sure that every frame runs within 16ms (1000 / 60) so that things appear smooth, across all devices, otherwise the engine begins to lag. If you want to have better control over such things, it's probably better to try a different framework or maybe a faster language than javascript. By the way, there's no need to calculate frame rate yourself; phaser has the which (when is enabled) has fields like , , and for you to monitor the performance of your game. 

Asking how many levels to include in a game is sort of like asking how many paragraphs to include in your essay, or footsteps to take in your journey. Once you have a clear idea of your destination and your path, the question answers itself. But it is a question worth considering because it leads to some interesting observations about game design. What is a level? Let's take a step back and look at what a level is, what it does, and what is its purpose. 

It's not too difficult, provided that you have a sudoku solver. Making sudoku solvers is a hard / interesting problem, so it's best to save it for a different question. Or you can just read this and see how you go. 

I can't believe no one has mentioned successful MMOs centered around PVP permadeath: DayZ and Eve Online (or almost-permadeath in Eve's case). These are games that reward player killing, and have the entire gameplay experience built around that ability. If you are familiar with these games, you can stop reading and use them as case studies on how a permadeath MUD can work. I want to offer these as a counterpoint to the prevailing attitudes in the other answers, which seem to assume that player killing is a bad thing, even going so far as to suggest punishing the killer. Here's a short description of the two games: 

There's a trick to this: Selecting Areas: As you move the mouse, the only tiles you need to check for new impassable tiles are the newly highlighted tiles. If the mouse is dragged from X=25 to X=26, then you only need to iterate over the tiles at the X=26 column from the Y of the starting tile to the Y of the tile the mouse is over. The worst case scenario is you cross both X and Y axis, in which case you will only iterate over L+W-1 tiles. Deselecting Areas: The catch is if the player selects a large valid area, crosses an invalid tile, then backs off of it to go back to the large valid area he had a moment before. To keep from having to check the entire space when your area shrinks, keep track of how many impassable tiles were crossed as you cross them. Then when bounds change, subtract the number of impassables that were in the column or row that was deselected. As soon as your impassable count is 0, you no longer need to check so long as the selected area is shrinking. This still ensures you never iterate over more than L+W-1 tiles at any time. Highlighting: While Selecting areas, as you iterate over, spawn a red rectangle at the location of the impassable tile you are currently looking at. Store them in a 2D array for when you need to remove them. You could do some magic and scale a single rectangle for contiguous blocks of impassables with a little thought. While Deselecting areas, iterate over the column or row in the 2D array mentioned above and remove any object found in the row or column. this will be fast, as you know the column or row you're looking at, and since most will be empty, they will more or less be skipped. 

I'm working on a dungeon generator and I'd like to be able to connect rooms through other rooms. What I currently have set up is two dictionaries and a map (an int array.) The first dictionary holds room templates separated by height, width and type (so: .) The other dictionary holds rooms that have already been added to the map and uses rectangles as keys. I'd like to be able to find the maximum rectangular area that could fit into an empty space, then select a template room accordingly. So what would be the simplest way for me to do that? Edit: Admittedly, I was a little vague before so here's a little more information. My current method for creating the map follows certain steps: 

I'm working on a small maze puzzle game and I'm trying to add a compass to make it somewhat easier for the player to find their way around the maze. The problem is: I'm using XNA's draw method to rotate the arrow and I don't really know how to get it to rotate properly. What I need it to do is point towards the exit from the player's position, but I'm not sure how I can do that. So does anyone know how I can do this? Is there a better way to do it? 

With the black representing walls. After the map generates, it goes through the map and finds all the outward corners and places a node on them. The end result is something like this: 

The way I've programmed it, AI traveling to a destination will calculate which tile gets it closer to it's goal (they use jump point pathfinding to find their way around) and then they calculate which tile they'll move to the next turn. Other AI check to see if a traveling AI is around them and if there is, they move one space to the side (or at least they're supposed to move.) Does anyone know a way to keep this from happening? 

So in this specific instance, nothing special needs to be done to draw these tiles right. You simply pick the right version based on where the tile is with respect to the observer, and render a normal 2D image. As for the path itself, it is simply drawn from the sides to the center, and back to front, a la the Painter's Algorithm, so they overlap properly. As for where to draw each tile, this is very much specific to what perspective and dimensions the artwork was drawn with. You can simply load up an image editor, piece the tiles together until they are seamless, then measure the offsets. There's only 13 tiles so you can easily do this manually. Or better yet, just ask the artist, who probably knows. 

To be as concise as possible, an SDK is engine + tools. It gives you all you need to make a game for that platform. Sometimes you don't need specialised tools to make a game; in that case you only need an engine. Sometimes they are required or at least very helpful. To give a few examples: 

Yep, looks right to me. The specular area for directional lights is supposed to be more or less constant w.r.t. the camera, given the same reflection surface. To compare, we can look at the phenomenon known as sunglint, which is basically specular reflection of the Sun on water, and since the Sun is approximately a directional light source for terrestrial purposes, and the reflection surface is the Earth which is approximately flat, this is a good analogue of your Phong lighting. Example 1: area of sunglint roughly the same as a residential lot 

Using a similar method as before, create rooms necessary to the game (shrines, barracks, treasure rooms, etc.) and place them randomly throughout the map, checking if they collide and moving them accordingly. 

I've started rewriting some of my code (npcs, navigation and such) and I need some help with my new navigation system. Basically the way it works is: the game generates a random dungeon. For example: 

I've been looking for articles or tutorials on this and I can't seem to find any, so I thought I'd ask here. I've created a bullet class in my game that is added and removed through a list. If I'm going to make these bullets work the way I want them to I need to be able to do two things: One, I need to check if the bullets are colliding with each other and then remove the two bullets that are colliding. I've tried doing it by updating the bullet list with a for statement and then checking for collision with another for statement, but that occasionally crashes the game. Two, I need to be able to check how far away every other bullet in the list is from the current one. So how can I go about doing this? 

Okay, through some trial and error, I've come up with a system that works. The ai chooses a target node, then uses this method: 

When it finishes that, it goes through the nodes and connects the nodes that have a clear line of sight to each other. Like this: 

Blue is walls, white is floors, orange is doors and green is the designated "center" of that room (usually used only for A* pathfinding.) I kind of already had an idea of how I could find the available space, but decided to ask because I wanted to know if there was an simpler way of doing it.