This should give you a "fluid" where each particle swings around its origin when the player stirs the fluid. The springConstant changes how much a particle swings away from its origin and the dampingFactor how fast the particle comes to rest. You may have to tweak the code since its the modified version of a 1d simulation I use in my game. Now with a demo: Demo Just tweak the 3 constants at the top until the fluid behaves like you want it to. 

I'm working on a platforming game with tile based levels. I store the collision model for my tileset in an array. This is how the collision model for a 4x4 tilesheet would look like (I can't post pictures yet so this link will have to suffice: Tileset example). The red dots are the vertices of the b2ChainShape. When I load a level, I look up the collision model for each tile and create a b2Body at the corresponding place. The problem is that between the tiles, my character can experience a "bump" because it gets stuck on the edge of the shape of the next tile's body. Is there an existing algorithm to connect the bodies of neighbouring tiles to a single b2ChainShape? Or should I ditch the idea of tile-based collision models all together and simply create the collision model for the whole map with the Tiled map editor? I don't create the the collision map with the Tiled map editor at the moment, because it is very time consuming for slopes and hills. 

I am not sure where are you calling your method, so I can give you a generalized solution on this. You'll definitely need a second condition before you choose to increment the level count. One way would be to have a boolean field which'll be true as soon as you increase the variable. Check it as another condition in your statement and if the level increases then make it false, so that level doesn't get increased before next increment of . Code snippet 1: 

Google Play Gaming Services are free and doesn't have any limit for any number of concurrent users. The aim of the service is to provide tools at par with Apple's GameCenter. Since GameCenter is free, GPG service is free too. PS: Doesn't this question belong on SO? Just asking. 

PS: LVBen got a point that using will give weird results. It's upto you if you want to use it or not. will be the better option anyways. 

would cause the RPMS to max out instantly when the gears are shifted, not allowing for any smooth transition from gear to gear. The proper way would be to solve for RPM's using the speed variable as an equation. 

I discovered VBO's recently and changed my code to use them instead of immediate mode. Now I'm rendering 25000 squares and it's really slowing down my FPS. If I drew all the squares VBO's to an FBO, then bound it to a single VBO, would it increases performance? The 25000 squares is more of a stress test, im trying to optimize my rendering code for snow. Edit : Each snow particle draws one of three static VBO's, this helped performance. 

First create a vector. It's angle is equal to ball spin speed (degrees per frame) plus the balls trajectory angle ( looking down from the sky). Set the magnitude to however much you want it to effect the trajectory of the ball. Add this vector to the balls vector, or position if you don't use vectors. Probably a good idea to make the magnitude diminish over time, that way it won't turn forever. This can be applied in 2d games, and can be modified to be used in the third dimension by doing the same process from the side. 

We end up with having a static mesh and animating it. Add some particle effects and we can make it stormy and mobile ready. I didn't require any real water reflection so this worked for me. 

So my question is How do I get this data in Unity? Has anyone tried any other method to get the data? 

Unity supports only , and for scripting. However as Philipp mentioned, if you know Java then you know 90% of C#. I still know only Java and C++ and its easier for me to translate my logic into C# (Given that I didn't know much about C# even after coding for a year in Unity). You can however write plugins in Java for any native feature not provided by Unity or to implement some third party SDK such as ads made specifically for Android platform. Same is true for Objective-C for iOS platform. 

You can make a raycast from your character into all all four directions. If you only hit the ground then you don't have to do anything. If you hit a wall or the ceiling you add a weld joint to your character and the wall. You destroy and recreate the joint inside your update loop, so the character can move, but is tied to the wall/ceiling and doesn't fall down. There are still two tricky parts left. 

1.If you want something that's close to your mockup I'd use particles (It doesn't have to be a fully blown particle system). Render your particles in the form of the polygon on a RenderTexture. Make sure to use additive blending on the particles. The particles inside of the polygon will smoothly blend into each other while the particles on the outside will give the soft edge that you want. (An example of the effect can be watched in this youtube video: Additive Particles Video Now render the RenderTexture onto your main screen and you're done. The RenderTexture is necessary so that the particles don't blend with your background. You can try to put the triangles directly onto the particle texture and see how this works out. Otherwise render them on top of your "particle soup" as a separate layer. Created a quick mockup in an updated jsfiddle that looks like this You can find the updated demo here 2.Each particle has a velocity and an origin. When your player touches the polygon, you change each particles velocity proportional to the players velocity. The farther a particle is away from your player, the less it is affected by the players velocity. The formula to calculate a particles velocity would be something like this: 

I am not sure what would be the more accepted definition, but I and the folks at my previous company considered "any game which looks like isometric 3D, but is rendered via 2D sprites" to be 2.5D. Now let me explain why we did that. Generally rendering a 3D world with a lot of objects in it will create too much pressure on the processing, lowering the FPS count. So to overcome this we generally created objects in 3D rendering software like Maya and rendered them as sprites. Which can be used in the game. Not to mention that the angle were considered while rendering. So to speak about this tech with publisher we normally used this term. A 3D world which looks like it's a 2D world is still technically 3D for us. So we generally didn't use the term for this method. I thought I should share my bit here. 

You need to move each part to 0,0 then rotate them, then move them back. Without doing this they just rotate around 20 units fron your character 

Which is the problem, it wont turn around. Iv'e tried every possible value for LightDir in all it's values, but I cannot get it to illuminate the back pf the tube. I've even tried to transform to light around the scene with glRotate and glTranslate. The light is supposed to function as a flashlight. Is this something that would be potentially solved with Shaders? Thanks in advance! EDIT: Anytime LightDir[2] goes above 0 the light goes dark. 

Problem: The spotlight I've set up with OpenGL won't light up anything behind it, no matter what values I set for GL_SPOT_DIRECTION 

The angle of the light goes up as expected, but seems to stop turning once it's pointed straight up. Which looks like