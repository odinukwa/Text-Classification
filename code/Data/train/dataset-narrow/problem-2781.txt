Now in this example you could inherit, but your Update may become a bit tricky then without changing your base class to alert you if you had changed, but it is up to each scenario to choose if its inheritance/implementation or composition. Also the above implementation will re-cache within the rendering cycle, which may cause performance stutters but its just an example of the scenario... Ignoring those facts as you can see that in this example you could use a cache-able component or a non cache-able one, the rest of the framework needs not know. The problem here is that if lets say this component is drawn mid way through the game rendering, other items will already be within the default drawing buffer, so me doing this would discard them, unless I set it to be persisted, which I hear is a big no no on the Xbox. So is there a way to have my cake and eat it here? One simple solution to this is make an ICacheable interface which exposes a cache method, but then to make any use of this interface you would need the rest of the framework to be cache aware, and check if it can cache, and to then do so. Which then means you are polluting and changing your main implementations to account for and deal with this cache... I am also employing Dependency Injection for alot of high level components so these new cache-able objects would be spat out from that, meaning no where in the actual game would they know they are caching... if that makes sense. Just incase anyone asked how I expected to keep it cache aware when I would need to new up a cachable entity. 

According to your current code, both the x- and the z-component of my movement need to be pointing up the slope for me to start climbing. Consider a slope with the normal (0,1,-1) normalised, and my horizontal motion (0,0,1). I would not pass the conditions in the x-direction, even though I'm going straight up the hill. I doubt that's what you're trying to accomplish. The dot product will tell you whether you're going up or down and by how much: 

Let's first discuss the dot product. A·B is a measure of A's component in the direction of B or vice versa; of the magnitudes of both vectors as well as their similarity in direction. Vectors pointing in the same direction have a dot product equal to the product of their lengths, perpendicular vectors have a dot product of zero. Turn the vectors even further apart, and the dot product becomes negative. Though normally defined as (x,y)·(u,v) = xu + yv, it has the property: A·B = A B cos θ, where θ is the angle between the two vectors. The sign of this product can be used to determine whether a vector B partly points in the same or opposing direction of a reference vector A, i.e. if A·B is positive, the angle is less than 90° (or greater than -90°). It doesn't tell us if the vector points left or right with respect to the reference. Below is a graphical description. Blue vectors B would yield a positive A·B, red vectors a negative. 

This is a slightly vague one but I am currently looking at a couple of areas of my current framework, such as spatial partitioning and UI based menus, and with UI menus it makes sense to have an event based system so you can tell if the user has clicked on it etc... its like your own small version of winforms. However for some other areas it got me thinking that I could expose a lot of evens for other things, such as when an object moves so it could be re-allocated in a spatial tree of some kind if needed, or if it needed to calculate a collision it could return an event. Anyway I quite like using events everywhere as it decouples you from having to know about who needs to know what, however I was wondering if there were any hidden gotchas with using events on the Xbox/Phone. I read a few older posts that mentioned that there are performance penalties with events on non PC platform (i.e $URL$ So is this still an issue or has XNA and the .net implementation on these machines improved in this area, as it would be nice to add events of all kinds to high level entities, like Player.HealthChanged, Creature.AnimationStateChanged etc, but I dont want to go exposing these for usage if there is a major performance overhead with doing so... 

However as AnimationObjectAWriter has its Write method protected I am unable to access it, however I was wondering if WriteObject will know of the AnimationObjectAWriter so if I did would this work? 

As far as legal issues go, the usual remarks apply. Laws are not universal, your mileage may vary etcetera, etcetera. If you are required to obtain the user's permission to publish his score, it doesn't follow you need to ask. Permission can be implied by simply playing the game, as long as the player is informed of this, for instance through your terms of service. Once again, one paragraph of legal advice is bound to cut corners all over the place. Most answers so far have been focussing on these legal issues, but from a gaming perspective, there are very few reasons to pose the question whether scores should be submitted. Obviously, the less you bug the player, the better. Interrupting gameplay to register the user's preference adds no enjoyment to your game, regardless of which option the player would click. Assuming the score should or should not be submitted is intrinsicly better than prompting, but you risk getting it wrong. By automatically submitting the high score, getting it wrong is not such a bad thing though. Players simply uninterested in competing on the leaderboard, will not be harmed by their own achievement being on there. After all, it might just as well have been someone elses. Other players may however still benefit from the score being on there, as it allows them to compete with it. The leaderboard will be more competitive and fairer; it is not limited to a non-representative selection. Moreover, showing the leaderboard with the player's name on it, might awaken his interest to compete, even if he would not have posted his score, had he been given the option. Perhaps he realises his score was far better than expected, giving a sense of reward, or quite the opposite, letting the player know there is a lot of room for improvement. Perhaps he sees he has beaten a friend, or that he has been beaten by one, inspring him to play again. All experiences he would have otherwise missed out on. Worst case scenario: the player looks at the list and doesn't care at all. A leaderboard can definitely make your game more interesting. If it does, you should probably just go ahead and get the player to participate. If it doesn't, you probably shouldn't even have one. 

I am in a situation where I am writing a framework in XNA and there will be quite a lot of static (ish) content which wont render that often. Now I am trying to take the same sort of approach I would use when doing non game development, where I don't even think about caching until I have finished my application and realise there is a performance problem and then implement a layer of caching over whatever needs it, but wrap it up so nothing is aware its happening. However in XNA the way we would usually cache would be drawing our objects to a texture and invalidating after a change occurs. So if you assume an interface like so: 

assuming no real optimisations and just looping through every tile would this just retain the tilesetTexture in memory, or is it going to keep removing/adding the texture after every Draw() call? As I do not know how it can manage this unless it keeps some state under the hood between draw calls (maybe thats what Begin/End is for on spriteBatches). So will I be getting 4096 (64x64 tiles itterated) texture swaps, or will it only do 1 texture swap in this instance? 

Usually in 3d drawing you want to ideally have fewer larger textures rather than lots of smaller ones, and make sure you render the same kinds of textures at the same time. So there is less texture swapping going on behind the scenes. This is not a difficult thing to do as most textures are purely used for models or terrains/structures. So you may have a terrain texture, a structures texture and a couple of player/enemy textures. Then just draw the terrain, the structures and any enemies and the player, only requiring a few texture swaps there, and if you are also using some sort of model instancing for the enemies you can get away with some other improvements there. Anyway now enter the 2d drawing world, rather than applying a texture and then drawing lots of vertices using it you are giving a texture to each draw command. So I am wondering how XNA handles this behind the scenes. Take for example a top down 2d game, you have a tileset for the level containing many ground sprites, an enemy sprite sheet which may contain anywhere from 10-20 enemies sprites and animations, then possibly a player/equipment sheet which contains anything for them. Now in this instance if I were to draw my level which was lets say 64x64 tiles (a tile being an x,y,tileSetIndex), and I have a tileset with 8x8 sprites (lets say 32x32 each): 

Here, F is the magnitude of the force generated by the thrusters, rx and ry are x- and y-components of the vector from pivot point to thruster. Positive torques tend to rotate the ship counter-clockwise. Using the four formulae above, it is trivial to deduce the sign of the torque each thruster produces. For a modestly accurate representation of physics, you need not only know the sign of the thrust, but also its total magnitude and the rotational inertia. Moreover, you might not simply want to activate all properly aligned thrusters to do a rotation. 

So you're looking for a parabolic function y(x) that equals zero at two known points. Let's call those points r1 and r2, after robots 1 and 2. One solution is easily found: y(x) = ( x - r1 )( x - r2 ) On top of the robots, one of the terms in parentheses becomes zero, which, multiplied by something else, remains zero. For that reason, we can multiply the entire thing by a factor a. This stretches the parabola vertically (or flips it upside down for negative values) without changing the location of the zeroes. We manipulate a to make sure the curve passes through the vertex, defined by coordinates (xv, yv). We solve the following equation for a: y(xv) = yv a ( xv - r1 )( xv - r2 ) = yv This yields: a = yv / (( xv - r1 )( xv - r2 )) We get the function y(x) we want by multiplying our original function with the scaling factor a we just obtained: y(x) = ( x - r1 )( x - r2 ) yv / (( xv - r1 )( xv - r2 )) 

Hopefully this will be a simple answer, but as RenderTarget2Ds are Texture2Ds under the hood I was wondering how it handles swapping in and out. Lets say you create a default one and assign it as the render target at the start of your Game.Render(). Then at a few points during your render process a new RenderTarget is swapped in, rendered to and then kept as a texture for later and the original one is then put back in. Some more rendering occurs and another entity swaps in its own RenderTarget, puts it in another texture and then swaps back to the default RenderTarget, and finally everything is rendered and done. Now as the RenderTarget2D is a Texture2D without setting preserve mode on the RenderTarget will you be able to swap it out and swap it back in without losing your current contents of the RenderTarget? I know there are some issues with the Preserve settings for RenderTargets on the Xbox, but if the render targets are being stored as a class member somewhere, are they subject to different rules? I am sure the answer is, they obey the RenderTargetUsage behaviour, and will be subject to the same rules regardless of how they are stored in the game, but I just wanted to be sure. 

Then I was under the assumption that we just draw everything directly to the screen, then when performance becomes an issue we just add a new implementation of the above like so: 

I have quite a lot of custom content pipeline components, and I was just wondering if under the hood XNA knows about these things when doing its magic... Here is my scenario. I have animation objects which basically contain 2d animation frames and timings etc, which can be loaded as self contained objects or can be embedded within other object. Now I was expecting that my CustomObjectAWriter could contain an instance to AnimationObjectAWriter and internally just call through to that to write out each animation object, i.e: 

If I have understood your question correctly, as units A and B start attacking each other, you want the camera to move to a target position with a certain elevation and at equal and set distances from both units, thus defining two possible targets, both at opposite sides of the plane defined by A, B and the up vector. You want to determine which side of that plane the camera is on, so you can select the nearest target. As you have calculated the normal of this plane, the problem has already been solved for the most part. The dot product of the normal vector and the vector from A (or B) to the camera will be positive on the side the normal is pointing towards and negative on the other. If, by definition, the normal is always perpendicular to the z-axis, you can omit that component and simply calculate the two-dimensional dot product, e.g.: 

A win rate of 50% is the only number a matchmaking system can possibly aim for. As an example, if the system were set up to create matches in which players have an estimated 60% chance of winning, then from the pigeonhole principle, it follows that there must be a probability of at least 20% of the match ending with both teams victorious. League of Legends, as most competitive games are, is zero-sum. For every match you win, someone else must lose. Regardless of how your matchmaking system works, if the total number of wins equals the total number of losses, the average win ratio will always be fixed to exactly 50%. That doesn't mean everyone is winning only half the time, but if your win rate is above average, someone else's must be below. Better players will naturally gravitate towards high numbers, worse players to low. That's fun for neither. It means better players are insufficiently challenged and are conditioned to expect a win, decreasing the rewarding experience when they do and increasing the frustration when they don't. On the other end of the spectrum, frequent losses disappoint, people feel they are not given a fair chance to compete and new players are alienated from the game. Generally, the less certain the outcome of a match is in advance, the more exciting the game will be. That is what a matchmaking system hopes to achieve. By putting players against opponents of their own skill level, it does not ensure the win rate averages close to 50%, but it lowers the variance in win rate across skill levels. Not necessarily to a minimum, by the way. A matchmaking system could actively have new players face veterans instead of other rookies, so their win rate starts off low and increases as they get better at the game. This pushes the ratio of seasoned players to an optimum between 50% and 100%, whereas new players experience a sense of progression. In conclusion, why aim to keep everyone winning only half the time? The alternative is to have some win too often, others not enough.