I'd say match it to the way you want your game to be perceived. If you want it to come off as a casual game, name them something like casual, normal, tough, hard, etc. If you want the game to come across tougher, name it like gears of war--casual, normal, insane, etc. It's really up to you. Keep in mind that how you name your difficulties will also somewhat affect how the player feels after finishing them. It's much more rewarding to complete "insane" than "hard". 

Those two noted, I consistently come back to the following article almost every time I write a generic shader: 

No, there is nothing equivalent to XNA on the Xbox 360. There is LittleBigPlanet though, depending on how complex your game needs to be ;) 

One way to do this is to add "markers" in the scene geometry file itself. You would use a specific naming convention on these markers (which are just pieces of geometry) to represent various things. For example: 

Unfortunately it's really hard to stop people from cheating, which is why software like Punkbuster was created to try to catch some of them. For an MMO, the biggest thing you can do is to just not trust anything the client sends you. The client should not be able to tell you where the player has moved to, how much damage they have dealt to whom, etc. Instead, you should send control input to the server, validate that it is practical (pressing the "attack" button 1000 times in 1 second, for example, is not valid), then update the simulation on the server. You would then send the relevant parts of the new state of the game back to the client. While you are validating user input, it is also possible to look for trends in their input. If you don't allow macros, you could catch them here by noticing that the user has clicked the same button at the exact same pixel coordinates in perfect 1 second intervals for the last 30 minutes. The client itself is the main place people can cheat, so programs like Punkbuster can cut down on wallhacks, aimbots, etc. Other than that, not trusting the client and validating anything sent to you by the client will help cut down on cheating. 

I am programming a fighting game that uses a UDP client/server architecture for multiplayer. The server can handle multiple clients, two of which (or one being the server) are playing and the rest are watching and chatting. I would prefer to use UDP for everything, including: player input from client, player state from server, and chat going both ways. My concern is keeping the order of the player inputs in sync from the client to the server. Since moves involve a specific sequence of inputs (e.g., Left,Left-down,Down,Light Punch), if the server processes them out of order then the game is ruined. What is a good approach for dealing with packet loss and packets arriving out of order in this case? I have considered having a linked list of outgoing packets in the client and server. With each step the list is traversed and unsent packets are sent, and if an ack packet(one I program the receiver to send back) was received for a particular packet (which I can identify simply with an integral value) then the outgoing packet is removed from the list. However, this does not guarantee order of delivery. Perhaps the server could keep a queue of inputs and evaluate another integral value in the packet for each input, organizing them into the correct order. I'm not entirely sure, if someone could point me in the right direction I would be very grateful. I have working client and server chat code but before I starting seriously designing the network architecture I wanted to see what others have to say. 

The problem was in the Android manifest. My main class inheriting from Application was not added as the main application class in the description. Once added, the app called a new object and the OnCreate method where I could initialize OpenFeint. As OpenFeint is open you can now statically call the OpenFeint functions to open the different views. 

I am trying to add an image to the scene, but it should just be added to the scene invisible, FadeIn and then be deleted when the effect finishes. My problem is that the images blink once when they are added to the scene, then they do the intended effect. My best guess is that when they are added they show on the scene for a split second before starting the animation. I though of making them invisible for a split second before activating them, but I am not sure how to code it. 

It does it because you are running two actions at the same time. Before making the sprite take an action just make it stop current/all actions he's doing. 

I am trying to implement OpenFeint for Android in my cocos2d-x project. My approach so far has been creating a button that calls a static java method in class Bridge using jnihelper functions (jnihelper only accepts statics). Bridge has one singleton attribute of type OFAndroid, that is the class dynamically calling the Openfeint Api methods, and every method in the bridge just forwards it to the OFAndroid object. What I am trying to do now is to initialize the openfeint libraries in the main java class that is the one calling the static C++ libraries. My problem right now is that the initializing function 

Install the blender2ogre add-on in Blender and you can select what you want to export. You just need to place the python script in the scripts/addons folder where you have Blender installed. Once you are ready to export, go to File->Export->Ogre3D (.scene and .mesh). 

If you are using Ogre3D, a logical choice would be to use Blender for creating the map, and Blender2Ogre to export the map into a .scene file. Then, in the code, you can use the DotSceneLoader class to import the .scene file into the game world. This will automatically attach each object to a scene node and you can access them as needed. 

I'm working on a 2D fighting game (using SDL) much like the original Killer Instinct on SNES. I want the camera to keep both players an equal distance from the left and right sides of the viewport. When either player moves, the camera adjusts to keep this equal distance and both players in view, except for when both players are at either end of the stage, during which the camera remains still. Here is an example of how the original KI camera works: $URL$ I will provide a diagram of what I am trying to achieve. 

You could do a ray test straight down from the rigid body and test the distance of the ray hit. One way is to simply use the rigid body position and subtract 10,000 or some arbitrary number to get a destination for the ray test. 

is not accepting the context parameter that I am giving him, which is a "this" reference to the main class. Main class extends from Cocos2dxActivity but I don't have any other that extends from Application. Any suggestions on fixing it or how to improve the architecture? EDIT: I am trying a new solution. Make the bridge class into an Application child, is called from Main object, initializes OpenFeint when created and it can call the OpenFeint functions instead of needing an additional class. The problem is I still get the error. 

If I have a texture with known metrics (pixel size, byte type) and a GL surface to render to of a know density and measures, and I want to draw a quad composed of two triangles that correspond to the size of the texture in proportion to the size of the surface. For that I need to recalculate the needed quad's vertexes. Can someone explain me the math involved in this process? Example: I have a screen/surface of 800x600 and a texture of 100x20 that I want to position in (20, 20). How do I calculate the vertex of the quad needed for it. My shaders are simple v 

I am trying to create a generic C++ bridge to use OpenFeint with Cocos2d-x, which is supposed to be just "add and run" but I am finding problems. OpenFeint is very exquisite when initializing, it requires a Context parameter that MUST be the main Application, in the onCreate method, never the constructor. Also, the main Apps name must be edited into the manifest. I am trying to fix this. So far I have tried to create a new Application that calls my Application to test if just the type is needed, but you do really need the main Android application. I also tried using a handler for a static initialization but I found pretty much the same problem. Has anybody been able to do it? This is my working-but-not-as-intended code snippet 

The red box is the viewport (camera) which slides over the background image file to display the portion of the stage the players are currently in. Goal: Each frame the player positions are checked and an algorithm is used to calculate the src.x clipping position for the camera. The midpoint, I believe, in addition with the distance between the players can be used to calculate this value. The viewport width and image width are stored in memory and can also be used. If one player moves, the camera moves at the same velocity, and if both are moving in the same direction, the camera should double its velocity to keep up, all whilst keeping both player's distances from the left and right sides in sync. Currently, I am using integer math for all positions. I specify the clipping width on the image file using configuration files, so for example, my current background is 768 pixels wide and I clip it to 425 pixels wide, which is displayed in the viewport. The fighters have basic acceleration and max velocity. I use a Camera class to logically represent its x value from 0 to the right edge. The camera's x position is subtracted from the player's x position before rendering. Before rendering the background, I add the camera's x value to the clipping x value (src.x). I have tried many silly things such as using the ratios of the image and clipping widths to get weird x values. I've tried simply using the midpoint and modifying it with whatever I could think of using the distance, but no luck. I do have semi correct movement by setting the camera x position to the midpoint - (image width - clipping width). However this of course does not keep the players at equal distances. I've been trying to figure this out for a while and it seems so simple, yet the solution continues to elude me (I'm probably exhausted at the moment). It is possible there are some strange architectural decisions in my code that are making this needlessly difficult. If someone could help me figure out an algorithm, that would be all I need. I can provide more information as needed. 

Given that the event bus post is synch the results are the same, so it all boils down to architectural differences: centralized logic and hundreds of event objects or disperse logic with less objects. 

I'm putting together a ECS for my game with another two main components: an event bus for communication and a Lua interpreter to load scripts. Now, the parent element is a framework/game object with references to all this three components. My question is, what is the best communication pattern: drill the interpreter and any other orchestration objects down to every system or centralize all those calls in a subscriptor for the eventbus, and make everything from there. Example: // Plan A 

What I am trying to do today is to import a full project to Android, but no tutorials are available for that that I have seen. My approach was to create a new android project, copy all the classes and resources in the folders and calling ./build_native.sh but I get an error because most of the files are not being included in the project. I tried opening the Android.mk and I can see why "LOCAL_SRC_FILES := AppDelegate.cpp \ HelloWorldScene.cpp" are the only files linked. Should I manually modify the make file or can it be automated by some way I don't know? Thank you. UPDATE: I manually added all files and headers to the make file and I get errors linking Box2D or cocosdenshion libraries. 

I highly recommend RakNet; it's relatively lightweight and implements a virtual connection over UDP for you (you don't have to manually send acks). I've had great success in using it across multiple projects. 

So then, creating and destroying entities is simple. To create one, use it, and destroy it would look something like this: 

I think what you're looking for is an object pool. You can create such a pool with constant time (O(1) complexity) creation and deletion, which is perfect for your case, I believe. Let's say you have an Entity class: 

Unless you are interested in the details of implementing your own reliability layer using UDP, I would recommend using RakNet, especially since it has been made open source. This would be the way to go if you are focused on making a game rather than a networking protocol. With RakNet, you can send packets with certain reliability flags such as RELIABLE_ORDERED. This ensures each packet will arrive (it is re-sent if it's not acked) and it uses an underlying ordering system so that the packets are processed in order on the receiving end. This would be very important if you are sending inputs for something like a fighting game where order is crucial for calculating moves and such. This is all very easy to accomplish using a library such as RakNet. This will however increase the bandwidth, but you can choose appropriately which packets need to be reliable and ordered and which ones you can afford to lose. Edit: Also consider following these articles for implementing fast paced multiplayer. It's quite easily done with a powerful library like RakNet. 

The problem was the library naming, as the standard Android project has the library names as "cocos2d" (my project had cocos2dx) and "cocosdenshion" (case sensitive into "CocosDenshion") 

J2EE is the superset for Java SE and Java ME, meaning that you have as many libraries available as you would for those two. Now, it does not make much sense choosing EE, because most of the additions are oriented to big servers and databases. 

Install the Tegra Android Development Pack. It includes Android simulator, the SDK and preinstalled Eclipse just in case: $URL$ Then go to the android-sdk-windows folder and open AVD Manager.exe. In that screen you can create a new emulated device with any specs you want. Then use Start to open it. It will have internet connection so you can try your remote app. The thing is that none of the emulators (iOS/Android) are near the performance most devices would give you, so you can't measure performance and framerate. 

I'm implementing engine tools for my hex board game and this one is becoming messy. I want to get a list of all the positions that a cone of size N would have, given "caster" origin X,Y and origin in X0, Y0 taking direction into account. So far I have been able to get a size one cone using a "simple pattern" approach, but it doesn't translate well for N-sized cones. This is the original cone