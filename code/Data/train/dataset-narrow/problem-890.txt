(Potentially the best way to deal with this would be by looking at file extension, but since this is only supposed to be an illustrative example and since we're already talking about a file header validator, I'll work with the somewhat contrived assumption that you're additionally required to treat header validation as the only reliable way of determining whether or not a file is valid code which needs to be processed) So, this causes you two big problems regarding the OCP: 

So, looking through those options, you'll probably see that in your case, generally the best one will be the last. This will actually have the opposite effect to what you were worried about. Not ing means that your (for example) won't silently fail and return , instead it will cease operating and the exception will keep bubbling on up. On the other hand, if you do surround it in a block and leave the empty, that would silently gobble up the exception, and that's where you're at risk of getting weird, hard to debug behaviour. 

I'm honestly not quite sure what your version is doing, so I can't compare very closely. But actually, there's something even simpler we can do. Really all we want to do is merge two lists in a special way: for each value, the number of times that value appears in the merged list should equal the maximum number of times it appears in each individual list. By taking advantage of the fact that our lists are sorted, we can do that very easily: 

Override logic Admittedly, the above actually looks worse than what we started with, but there's one more problem to tackle: the use of override-type logic. The issues with this: 

Now we have a , but we can't really do anything with it. I already decided that the constructor shouldn't be exposed publicly, its behaviour seems too confusing to expose directly to consumers. LINQ-to-Objects can give us another hint here: static constructors and extension methods are likely to be very powerful. Let's start with: 

Finally a higher-level point. This example mixes together what I'd call presentation concerns and business logic. Usually those terms wouldn't be applied to such a small, straightforward application, but essentially, presentation is how you display and get input from the user, and business logic is the actual logical work that your application is doing. Since your entire application is so simple, this probably doesn't matter much, but it's a good idea to start early with thinking in terms of how you're going to separate out responsibilities. A single method shouldn't be taking responsibility both for presentation concerns (deciding how to ask for the numbers and print the response) and business logic (in this case, doing the number comparison). Refactoring these into two different methods your class might look like: 

Additionally, my usage of any features in more recent C# iterations (C# 6 most notably) may not be up to scratch, so I'd appreciate any suggestions for making my code more condensed or 'modern' I apologise if this question doesn't fit perfectly here -- I was concerned it was a bit too specific and if it is, please comment and I'll try to open it up a bit. 

I wanted to remove this very strong coupling which my components have (as a result of specifying exactly which component should receive the message), and transition towards an event / message system. As a result, I've written an implementation which seems ideal, however it uses run-time dynamic typing which has me concerned that there may be a better way to achieve my goals. 

Originally, I began writing code to loop through my list and my list and then realised I was going to be writing duplicate code for every list of data and switched to having a and looping that and ended up having to use reflection. I was wondering if anyone can think of a way of achieving my goals without using reflection or having duplicate code for every type of model stored. I'll attach my current completed class below. I don't mind doing so much but it's the code: 

For every list, Open or create Sequentially load each file in the folder into memory by creating a new instance of and calling 

I am quite sure this code is okay, outside of the overhead induced by the run-time typing - my apologies if this makes it a bad fit. I am just hoping for a once-over review by someone more experienced to reassure me that this is a good design. 

Exhaustive set of event properties which components can subscribe to manually - adds extra code overhead to each message type, which I'd like to avoid Dictionary from event Type to handler in each component - have to subscribe at run-time, which feels undesirable. Switching dynamically inside a non-overloaded handler - more viable than it sounds since most components will not listen to more than a few message types, but still has unpleasant code overhead 

Adding a new message type does not require any modification elsewhere to be supported. Subscribing to an event is as easy as creating a method with the correct event class. There is practically no overhead for listening to a specific event - no need to instantiate a class, inherit some event-specific interface, register interest at run-time with a subscribe method, etc. As messages are represented by classes (like a MoveMessage), they can contain all the relevant data without needing to be cast or coerced. 

Resolving That last problem is the one that screams out most for a particular answer, so let's start out with that. Say we've written a service class with a private method that does a complex query for us. Now we're writing another service class, and though the functionality isn't that similar, we find ourrselves needing the same query that was in that private method. We do the obvious thing and pull the query out into its own class: 

I'd second mjolka's comments that the behaviour of and is confusing, and that would be preferable to NaN and infinity You have a single case for a zero denominator called . By comparison, has , , and . Likewise, it has static , and constants. For consistency, I would consider renaming to , and splitting into three cases, for the numerator < 0 (negative infinity), == 0 (NaN) and > 0 (positive infinity). These can be used when converting to and from float. Parsing You should use rather than . For example, if the numerator or denominator is larger than , you want to return false rather than throwing an exception. (and similar methods) actually guarantee a particular value to their out parameter. It's hard to think of a situation where this is important, but if you wanted to be super-conscietious you might consider doing the same. Note that unlike most numeric types, is actually not but . You might want to think about which of these you'd rather return- 0/1 for consistency with other numeric types, or 0/0 for consistency with . And either way, you could state your decision explicitly in your xml comments. You might also consider having a method like other numeric types. It's not crucial, but it saves the consumer some work in the (common) situation that an invalid input is considered exceptional. Simplification It seems a little unpredictable when fractions get simplified. I wouldn't necessarily expect that I could define a fraction 2/4 and it would remain that way until I multiplied it by 1, at which point it would become 1/2. Especially by making public, I think you imply that simplification is something should work in a way understandable to a consumer, without having to read through all your method implementations. You could go through and try to use it consistently, but I think the simplest way would be to do the simplification inside the constructor so that all fractions are guaranteed to always be simplified. I can't think of a convincing reason that you'd want to work with unsimplified fractions. In this case you'd want to make methods relating to simplification private. And obviously they would need to take a numerator and denominator as parameters rather than fractions. Avoidable overflows This maybe falls into the category of "nice to have", but you should try to ensure you don't hit overflows inside arithmetic operations when it's avoidable. For example, if you have defined as int.Max/2 + 1, then a/2 * 2/a would overflow, when it should equal 1/1. For multiplication, if you have a/b * c/d, both already simplified, then the easiest way to do this would be to first define and simplify a/d and c/b, then multiply those. I don't think there's any improvement that you can make for addition as long as the input fractions are already simplified. EDIT: Actually, one thing you can do is instead of using the product of the two denominators, instead use the least common multiple. You'll need to work out what to multiply the two numerators by before adding them. This one is actually probably more important than multiplication because even adding 1/50000 + 1/50000 will overflow as it is now. Comparison According to msdn documentation for : 

... that way you declare 1 float4 return value, and do the math for .rgb and .a separately. B/c as you're doing it in your initial way, you're wasting calculations a) generating a float alphaChannel var that never gets used, b) calculating color.rgba when you just replace color.a in the return anyways (by re-calculating alphaChannel), c) you're casting another float4 in your return, and inefficiently comma-delim'ing your color.r, color.g, color.b values when you can just color.rgb them together. The idea is to reduce the number of variables casts you make... so while you can "float4 ( somevalue.r, somevalue.g, somevalue.b, somevalue.a )"... if you're already creating a return value, then just use it as the return value instead of recasting it. Sometimes your return value you're dealing with may just be a float3, eg: if you're only pulling the rgb of a texture, working with it, and the alpha .a will always be 1. Even then.. just cast a float4 from the start, do all your work with the .rgb float3 parts of it, and then set the .a part of it to 1 and return it... eg: 

You create a single float4, and then just work with it's .rgb through the shader, but return the float4 whole at the end. You can do this in other places, too... often people will pack HLSL vars full.. eg: they'll take 2 float4's and use the .rgb parts for colors and then pack a float2 in the .a alphas of them... eg: 

.. I mean... it does the same thing: loads the float4's with their values. But, it casts a second float4 on the right-side of the equation to do so. We're casting 4 float4's there.. the sunU and skyV, and then the right-side equations to piece together what we're packing in them. The way I wrote it eariler, you only cast 2 float4's in the struct, then use swizzling to tell them what goes in what parts without having to cast more vars to do so en-masse. It seems like such a minor thing, and overall it probably is, but when you have something like that in a pixel shader firing off for every pixel... it's just unnecessary overhead ... X many pixels times Y number of frames per second... it adds up. 

You save yourself having to cast another float2 (for the x & y math operations), and you leverage .xy per-component math which is faster then doing it each separately. In your pixel shader... 

... HLSL has an intrinsic function called "lit" that you can read more about here... $URL$ Basically you hand it a sun luminence dot (NDotL ... dot ( normal, light)), a specular reflection dot (NDotH ... dot ( normal, halfway)) and a specular pow value (your materialPower) it does all the pow, saturate, etc.. basically creates your float specular luminence to * by your float3 specularLightIntensity. While you still have to calculate the dots in the shader, you'd use the lit function, b/c it replaces the pow,saturate,etc you have with a built-in function doing it more efficiently then you coding it in the shader yourself. I would also change this stuff around... 

I am implementing a multi-player game in C# and having seen all sorts of projects, from indie developers all the way to large studios struggle to patch networking into existing products in the past, have made the decision to get the networking aspect done first, and build the game on top of that. I've so far gotten to the stage where my server can accept clients asynchronously, but I have a strong feeling that I've implemented the threading very badly. I think it is possible that I am misunderstanding and/or misusing async/await and Tasks, but having read documentation and similar questions I think I will need practical experience to get my head wrapped around the correct usage of these. As a result, I am hoping that someone would be generous enough to look over my code and help push me onto the right track. I have excluded 'using' statements and the client code for the purposes of this question, however I can confirm the code does function correctly. I am not too concerned about issues such as naming, and the fact that I have a bit too much code logic in the Main function right now -- these will be modified and extracted to more appropriate locations respectively as the project progresses. I have denoted lines I am particularly concerned about with 

However, as mentioned at the beginning of my question, I am concerned about using run-time dynamic typing in this fashion (See my dispatch code in Entity - the second snippet in this post). This system will probably be handling a lot of messages, and I have some concerns about the overhead incurred (it also feels like a code smell in general) I would really appreciate feedback on this approach; particularly whether it seems like an abuse of dynamic to more experienced C# developers than I, but would also appreciate alternative suggestions. Alternative approaches I've considered, and why I did not go with them initially: 

That's really bothering me. It just feels wrong and suboptimal and I'm sure I'm not thinking this through properly. Full code below: 

I'm not sure whether my distaste for reflection is justified or not, but it feels ucky that I'm using reflection here. I'm trying to make a very simple class which has a number of where with a load and save method. The load method should: 

I'm working on a game which utilises a variant of the entity component system pattern. In my current code, I have been communicating between components using code of the form: