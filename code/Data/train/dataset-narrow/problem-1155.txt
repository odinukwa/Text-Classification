Note, the Node is private, and not visible outside the KDTree class. It is possible that you need some other form of data structure to represent the actual data in the Node, like a class, and, your Node could have a reference to a instance. Point strikes me as being a data structure you need anyway, and probably already have. Note that your x and y values are doubles, and any time I see comparisons with doubles, I caution people that it is not as reliable as you would expect: 

What am I saying there? I am saying that the Matrix can consist of any combination of values that may have an Iterator. The mnemonics I use there are that: 

Our factors for 20 are thus 1, 2, 10, 4, 5, and 20 itself. The rules for this challenge exclude the number itself, so 20 is not part of it. The sum of factors is thus: 1 + 2 + 4 + 5 + 10 = 22 In order to find all factors, you only need to loop through to \$\sqrt{num}\$, and you need special handling for the input value 1, and when the root itself is an exact factor of the number. Conclusion Putting this all together, I propose the following: 

I believe so. So, the magic number is a hard-coded number of quotes you support. A simpler solution, that is more managable, is to store your quotes in an array, and the only hard-coded content is the actual quotes: 

That way, anyone calling gets an instance of the standard formatter for my system, and it is local to the current thread. I don't let them 'hang around', so you can't assign them to class fields, etc. The benefit is that there's at most one instance per thread, it is thread safe (if you don't do silly things with it), and it is neat: 

Now, having done that, why do you need the initial not-a-function-key check at all? Can't the whole thing just be a positive test? 

Your code is somewhat simplistic in that all it is doing is ensuring that the same values appear in each document. XML is a lot more complicated than that, though, and you may have problems when: 

The point is that it is very bad practice to have returns in the finally block. Don't..... EDIT: Update to include a better solution.... Use Java try-with-resources (since Java7). 

If you're interested in better-performing options than that, I suggest writing up some benchmark tests and using those to improve the performance of the method. See benchmarking notes here: $URL$ 

Then, as you recurse, you have a single instance of that Result object that you pass to all nodes on the recursion... 

Note how index 5 ended at position 8. Using the above function, you can create a 'rotation' in the vector. Take an index in the vector, finc out where that index needs to be relocated, take the value from the target spot and save it in a temp variable, then put the source value in to the new location. Then find the new location of the value we just pulled, and save away the value at that spot, and replace it, and so on, until we get back to where we started. Once we get around the loop, we stop, and we have 'rotated all the values tghat form a sequence in the input vector. Note that there may be multiple discrete 'loops' in the vector. For example, in a vector of size 5, there are actually 3 loops: 

As a general comment, your code has improved significantly in the last few months. It is to your benefit for multiple reasons.... the 'easy' things to review have gone (code style, variable names, etc.) and the core logic is much more readable. Reviewing your work is harder now because the easy things are all done right. TreeNode 

at sum 3, that would be ball 1 and 2 (sum to 3). ball 1 and 3 sum to 4, balls 1 and 4, as well as 2, and 3 sum to 5, and so on. Now, with this data, it is easy to calculate the mean, and standard deviations.... I used some Java 8 streams to do it... 

and then the function returns the largest value. Now, about the algorithm, this is more complicated. There is a way to do it in \$O(n)\$ time complexity. You can scan all the data just once, with a zero-counter, and multiplication and division. 

In here, two threads may call at about the same time. The first thread may get and convert it to . It may then pause there. The next thread may get the , and call . The first thread may then overwrite the previous thread's value with the older lap. Then, both threads may get the laps , and try to simultaneously add their lap values to the same synchronized ArrayList... the order they are added is unpredictable, but, for sure, you may end up with two really long laps, instead of a long one and a short one. Atomics are atomic... they do not prevent race conditions (they just give a way to identify and handle them). Synchronization Here you have done a half-OK job. You are synchronizing on two methods, but you should be synchronizing on more. I would recommend you throw away all the other concurrency tricks, and use only synchronization. Believe it or not (you will believe it if you test it), synchronization blocks can be really really fast, and as a result, concurrency is still PDQ (Pretty Damn Quick). So, with the following code, let me point out some things: 

In each of these cases, the code should be 'exemplar', and you should clarify exactly why this code is needed... but, if the answer includes the 'parallel execution' reason, then the concurrency had better be accurate. forEachRemaining() one of the performance advantages of Spliterator is the method, and you have chosen not to implement it. Why? Queues are Queues Your code really boils down to being a queue processing tool. The is a queue, you have content on it, and you process it from the beginning, and add stuff to the end. Occasionally you split the queue. Use a Queue (Deque). Specifically, you should probably use an LinkedList (which is a Deque). If you use a queue, there is no need for the variable, and code like the trySplit becomes (here, is an LinkedList`): 

find the length of the longest series of either increasing, or decreasing numbers sum the values in this longest sequence. 

In Python, the best practice is to use exceptions for many more situations than is best practice in Java. In Python, you shoot first, ask questions later .... you seek forgiveness, not permission.... you ... {add cheesy analogy here....} In Java, Exceptions are expensive. When an exception happens, the virtual machine needs to backtrack the call stack, often synchronizing on critical aspects of the runtime, perhaps bringing the entire application in to a locked state, while the exception is built. The Java compiled code is often inlined, and optimized, and the call stack for the actual optimized code has to be translated back to the source code, etc. If you expect your input data to have invalid double input, then it is not an exceptional case to have invalid data, is it. In Java, you seek permission before having to seek forgiveness... so, you validate the data before doing the hard work. The documentation for even goes so far as to show you exactly how to validate an input String before parsing it... using a regular expression, and shows how to use it too. So, let's compare two ways of parsing the values.... the forgiveness way: 

That will extract just the MANIFEST.MF file from the zip archive, and output it to standard output. You can thus skip the whole temp-dir process entirely. 

Serious stuff If you cut through the crap, you have an incomplete script... Lets go through some things.. Traps This is your trap: 

you cannot start processing the first data until all the data is sorted, you have a latency problem. you cannot process data in parallel, you have a scalability problem. 

Your code certainly looks like it works, and the use of recursion is 'OK'. What I don't like is that you repeat blocks of code in a way that makes the maintenance a problem. There are some style nit-picks, but on the whole your code reads well. The indentation is a nice and consistent, the variable names are meaningful, and you are using braces for 1-liner conditionals. In other words, it is mostly great. There are some problems: 

Better joins. I really struggle to believe that you need all of those outer joins. Outer joins are a really, really poor performance choice. Are you really sure that those all need to be outer joins? Only you can answer that, but, you should investigate. LIKE clauses. LIKE clauses are also really slow. They require a scan of the data rather than an index search.... Further, your LIKE queries are bogus ....: 

Now, about your algorithm... Really, there's nothing wrong with it, but I believe you can simplify the logic a bit if you treat the mid-point only when needed. Consider the following helper function: 

So your code/concept looks functional to me. There are some comments though... and they are a bit scattered, forgive me.... Threads You use the class to create three ExecutorServices. Each of these services create threads that are non-daemon threads... This is a problem because you will need to manually shut down all threads before you can exit your program correctly. Using the default ThreadFactory is also a problem because the threads have horrible names. It is very convenient to name your threads so that, if there are problems, the stack-traces and java dumps are more easy to interpret. creating a class like: 

Using String concatenation in a tight loop is a poor choice when it comes to performance. This statement has to go. the variable names in your loop are almost meaningless. You are using a String as if it is a Stack (adding a value to the String in the loop). Since most combinations are not going to add to the target it seems like a lot of String manipulation to get there. the recursive method should not be public. Java classes should be named with a capital letter, i.e. it should be . 

Note that a zero-sized, or null array will cause an Exception to be thrown when indexing . You should probably be more defensive about that... 

I feel @spyr03's answer is great (+1 it), but I would like to extend it a but further in a number of ways. Algorithm The suggestion that you can validate the move by checking one axis moves 2, and the other moves 1, is an interesting, but not ambitious enough solution. A knight moves in a right-angled pattern, with 2 steps on one side, and 1 on the other. Pythagoras indicates that the square on the hypoteneuse is the same as the sum of the other two squares. Putting those together, there is a really neat trick.... 

First, the slow part of this method is probably compiling the pattern, and you do it multiple times, each time the method is called. First, you compile it explicitly, second, you do a later on with the same pattern. How can this be improved? Well, Patterns are thread-safe, and reusable. Let's move the pattern compile to be a static, final field: 

Here's the thing... you're not really doing callbacks at all. You're ignoring the error values, and the result values, so you may as well have the code: 

I would strongly recommend a use of Java 8 features to make your library (which has an API) an easier to use system. Your Task interface should be a . It is one already, but you should make it formal with the annotation: 

Breathing space Your code is suffocating since it has little breathing space. Many of your statements are compressed around the operators and other symbols. Consider lines like: 

Error handling is boiler-plate that can be made more readable by separating the error conditions out explicitly. In checking/refactoring this, I found an apparent bug, too (which was hard to spot because of the compound exit condition). The bug is that if the arg-count is more than 1, you print the message "Excessive arguments, only the first will be considered" but then terminate anyway..... so much for ignoring the subsequent args... I would prefer: 

Will your input files change in the middle of your application running? If not, a better solution would be to read the file just once, and keep the lines in memory until needed. This will significantly improve your performance. This can be done really easily... but first, there's a much simpler way to read the lines of data from a file: 

So, I would agree that naming is a concern in your code, but it extends beyond just your method. Your method does not tell me what it does, and the code in the method does not help much either. The code in the method does not help me help you rename the method. 

If your situation requires that these values are populated, then you should throw exceptions instead of the other println methods. Also, you should consider checking that the number of arguments in the matches the number of arguments expected in , but with var-args, that can be hard. Additionally, this line: 

All in all, an interesting approach to the problem, and seeing JavaScript used in such an efficient way is a pleasure (stick it to all those people who think JavaScript is ... ). I have the following small criticisims of the code (nothing can be perfect, right?)... Variables 

Use the power of the force, ... I mean parameters, Luke... I mean Daniel. Your method should take the two files as parameters, not as class-level fields. As it stands, your code is not "reentrant", and it should be. Your method is: 

So, I set out to suggest why your solution was a problem, but then found that it worked better than I thought. This intrigued me, so I set about understanding your solution, and, bottom line, you do text-break-processing on punctuation and before-consecutive capitals.... Essentially, you split the word with spaces between all sequences of characters, and then you also add a space before the capital of a Xx combination, and before the capital of a xX combination (or both). The process you are using, though, is really ugly. Regular expressions are a better tool for the job. They may be hard to understand, occasionally, but they 'compile' down to what are called Deterministic Finite Automaton. So, your code does a lot more than the description, since it can deal with space and punctuation separated words (i.e. sentences), but it does it in a way that is slow, and requires intermediate results (a space separated string), which is then post-processed to words. I took this system, and implemented it as regular expressions as an exercise myself: First, I compiled two patterns, one to split the content in to words, the other to split the words in CamelCase, etc. 

In your case, volatile does nothing useful, and lots of things that are bad. Remove it. Synchronization Synchronized methods are another red flag in multi-threaded Java. synchronization consists of two parts, a "monitor", and a "code block". The "Monitor" is something Java can find in memory, and is used to control access to the code block. In Java terms, the Monitor is always an object. When Java is running and it encounters a synchronized code block, it (conceptually does, the fine details are more complicated): 

Your question would do better with a more detailed description. The way I understand your situation is: 

EDIT: Request to get help on how to debug the code: To debug the code, you need to set a break-point in the method. Select the line and use the key-board short-cut Ctrl-Shift-B which will toggle a break-point, and you will get the 'dot' marker like the picture below: 

Code like this makes me itch ;-) , and not because of the , but because 'dangling declarations' of the are a smell to me. Note that the conditions can be simplified since they are boolean checks. Your try/catch code would be better written as: 

The nice thing is that you can then run it with much larger counts, like 1,000,000 I ave put it all in an ideone here... enjoy!. This is what the results look like: 

So, with that in mind, I 'played' with your code. This is not a review of your code, but, rather, it is the result of me solving your problem in a different way. There are pro's and con's to my solution... so, use it with appropriate care. The goal of my 'refactoring' was to hit a usage-model something like: