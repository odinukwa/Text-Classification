The big advantage of this method, besides requiring no complicated mathematics, is that it works for any arbitrary exp-per-level function. If you like, you can even just make up arbitrary exp values per level, and store them in a table. If you do (for some strange reason) need an even faster solution, you can also precalculate the total amount of exp needed to reach each level, store this in a table, and use a binary search to find the player's level. The precalculation still takes time proportional to the total number of levels, but the lookup then requires only time proportional to the logarithm of the number of levels. 

The bug is not in the code you've shown us. Anyway, your tile drawing loop should look something like this pseudocode: 

You could, of course, also combine the alternatives above, e.g. by giving each entity two PRNG instances, one of which is only used to reset the other every frame. 

To briefly answer your main question first, the main advantages of a procedurally generated game world are that: 

However, the lemniscate of Bernoulli may be visually more pleasing; it has a parametrization very similar to the lemniscate of Gerono, except that both axes are scaled by a factor of : 

Multiply the car's velocity by some constant Δt and add it to its location. (That is, calculate what the car's location would be Δt time steps in the future if its velocity remained constant.) Call this the target point. Have the camera chase the target point in some natural manner. A simple way to do this would be to let the camera position be the exponentially weighted moving average of the target point position; this is essentially what you're doing by repeatedly interpolating between the current camera position and the target. You could also try adding some inertia to the camera movement, so that it takes a while to change direction. 

Edit: Another way of writing the formulas for ρA, ρB, ρC and ρD, which may make the symmetry of the definitions more apparent, is to define dX = max( |x − xX|, |y − yX| ) as the chessboard distance of the unit at (x, y) from the center of the cell X at (xX, yX), measured in cell widths/heights. Then, for any cell X, 

where is the average of the velocities before and after adding in . This latter approximation to Newton's laws of motion is actually exact as long as is constant, and in any case is a better approximation than the former even for changing . However, for games with a small and constant timestep , the difference is generally not noticeable, at least without side-by-side comparison. The main advantage of the more accurate form is that it makes object trajectories less sensitive to changes in . I should also point out that (dry) friction is not the only force that can slow down moving objects. For example, objects moving through water or air experience drag, which follows a formula that generally looks something like 

where and are constants that depend on a lot of things such as the density and viscosity of the fluid and the mass, size and shape of the object moving through it. (See the Wikipedia link above for details; above corresponds to Newton drag, while corresponds to Stokes drag.) For macroscopic objects moving through fairly inviscid fluids like water or air, should be very small or even zero, whereas a viscous fluid like lava or molasses calls for a higher . For game purposes, just play around with the values until you get the effect you want. Note that, unlike with dry friction, drag forces never bring a moving object to a complete stop, so we generally don't need to worry about accidental direction reversals. The exception to this is if , which can happen if is too large or if the object somehow acquires an unusually high velocity; if that might happen, the solution is either to dynamically adjust to be smaller for fast-moving objects or to use a higher-order motion integrator (which really goes beyond the scope of this post). 

where gives the length or magnitude of the vector . To keep objects from jittering after they come to a stop (and to avoid dividing by zero if we try to calculate the direction of a prefectly stationary object), we should also ensure that the change in velocity never exceeds the original magnitude of the velocity — that is, friction should never cause an object to start moving backwards. Putting all this together, a reasonable implementation of friction in a game is: 

I assume you already have some code (using something like the A* algorithm) for the enemies to find a path to their destination. Every time the player tries to place a tower, you can just put a temporary obstacle where the tower would be and run the pathfinding code to check that there will still be a path for the enemies. You can optimize this in various ways. For example, if the newly placed tower only touches at most one existing obstacle, it cannot block the path. You can also save the results of previous checks (at least until something changes), so that if the player tries the same location several times, you don't have to re-check it every time. Also there are some techniques that only work in some cases. For example: 

I assume you've already read the Wikipedia article on radar. Here's another site I found (radartutorial.eu) which might be useful. If you really want to implement realistic radar (or sonar), you'll probably want to use ray tracing. The basic principle is just the same as in the usual light ray tracing used for 3D rendering, so you can use any of the usual implementation techniques. One difference is that, for distance/time-of-flight estimation, you'll want to keep track of the total length of the ray. Also, you'll typically have only one "light source", which is located at the same position as the "camera", which might allow some extra optimizations. (However, if you add the possibility of radar jamming into the mix, this is no longer always the case.) The tricky part will be in coming up with realistic values for the radar reflectances of various surfaces, as well as modelling any relevant atmospheric effects as well as reflections from the sea surface. Also, at longer wavelengths, diffraction effects (which cannot be fully modeled by ray tracing) start to become more significant; however, I think the typical wavelengths used for modern marine radar should be short enough for these to be mostly negligible. In any case, most of the basic code should be the same for both radar and sonar, so if you're going for a realistic implementation of one, you might as well start with that and then reuse the framework for the other. 

Whatever wording you settle on, you might also want to show it to the OSI/DFSG folks and ask for comments (and maybe even request formal approval). Of course, if you don't really care that much about whether your license officially qualifies as open source, then you're always free to ignore such issues and just make up whatever requirements you think your target audience will accept. 

(Authors: Wikipedia users 195.157.197.108, Mmmbeer and others; used under the CC-By-SA 3.0 license.) Ps. The main trademark article on Wikipedia is significantly more detailed, and well worth a read. 

Divide your objects into 1×1×1 cubes, assigning to each cube a picture of the parts of the object that would physically be in that cube. This is easy if you're starting with actual 3D objects and rendering them down to 2D. If you're drawing your objects directly in 2D (or if you have existing art that you need to split), it takes some manual effort. Fortunately, the split doesn't need to be exact, as long as you make sure that none of the image parts assigned to a given cube spill outside the hexagonal area that a solid 1×1×1 cube at that position would cover. It may help to make an overlay showing the outlines of each cube as an extra layer in your graphics editor. Then you just assign a priority to each cube as p = x + y + z (assuming that all three coordinates increase towards the camera) and render the cubes in ascending order by priority. 

where returns a vector of unit length pointing in the same direction as . (For one-dimensional movement, if and if .) One way to calculate it is as 

The line might need some explanation. In pretty much all languages that I know of that have it, the function returns the angle in radians. Dividing it by 2π converts it from radians to fractions of a full circle, and multiplying by 8 then converts it to eighths of a circle, which we then round to the nearest integer. Finally, we reduce it modulo 8 to take care of the wrap-around, so that both 0 and 8 are correctly mapped to east. The reason for the , which I skipped past above, is that in some languages may return negative results (i.e. from −π to +π rather than from 0 to 2π) and the modulo operator () may be defined to return negative values for negative arguments (or its behavior for negative arguments may be undefined). Adding (i.e. one full turn) to the input before reduction ensures that the arguments are always positive, without affecting the result in any other way. If your language doesn't happen to provide a convenient round-to-nearest function, you can use a truncating integer conversion instead and just add 0.5 to the argument, like this: 

You could wrap that into an that you can call before testing the state bits to ensure that the state makes sense. However, one limitation of this approach is that it can't account for the order of state changes. For example, if you want to have a different outcome for hot items that become wet than for wet items that become hot, you can't do it like this: all the method sees is a hot and wet object, with no information about how it got to be that way. Instead, what you could do is make the item state private (at least conceptually) and manipulate it through a set of methods like , , , and so on. That way, the state change methods themselves can take care of any additional changes. For example, the method might look something like this: 

If your room layout is consistent enough (all connections are the same length and can be traversed in both directions, and no rooms overlap), this is a simple exercise in recursion. Here's a quick piece of code that should do it: 

One thing that pre-allocating a large chunk of memory could do, if your computer was low on RAM, might be to force the OS to free some extra space by swapping parts of other programs' memory space to the disk. Since such swapping is generally a very slow operation that pretty much freezes your program while it's happening, there could be some advantage to ensuring that, if it's going to happen anyway, it will happen before your game starts rather than in the middle of gameplay. That said, forcing a swap-to-disk like this is not exactly 100% reliable: 

You can express these quantities in any units you like, as long as they're consistent. For video games, a common choice is to measure time in update steps (which might typically occur, say, 20 to 60 times per second for smooth-looking motion), position in pixels, velocity in pixels per time step and acceleration in pixels per time step squared. This simplifies the formulas, since, in particular, Δt = 1. Also, if the time step (and/or the acceleration per time step) is small enough, the (a × Δt² / 2) term will be so much smaller than (v(t) × Δt) that it can be left out of the second formula without anyone really noticing. A lot of games do that, since it makes the formulas even simpler. And, before you ask, usually the positions, velocities and accelerations will indeed be two- or three-dimensional vectors. This is not a problem — you just apply the formulas to each component of the vectors separately. It's also perfectly okay for any or all of these quantities to be negative. 

Note that I've assumed that you want the ship to accelerate upwards when the up key is pressed and downwards if the down key is pressed, regardless of its orientation. Depending on what kind of game you're making, you may instead want to add or subtract the ship's heading vector (normalized and scaled by a constant) instead of the fixed vector to the acceleration. 

This sounds like a pretty simple task. First of all, you need a database to store your messages; presumably you already have one for your user accounts, but if you want recommendations, MySQL, PostgreSQL and SQLite are all common choices and should do fine. Next, you'll need a table to store the messages. A typical message table should probably contain at least the following columns: 

I suppose the answer depends on just what you think of as a "berserker". The historical Berserkers were shock troops who focused their attention on engaging and slaying their opponents with little regard to anything else, including their own safety or that of others on their side. Different sources disagree on just how indiscriminate they were in their killing: some describe them as willfully slaying anyone and everyone around them, while others merely describe them as fearless warriors. Here's a fairly middle-of-the-road quote from the Ynglinga saga, via Wikipedia: 

I see several things wrong with your code. However, before trying to list them here, let me just show how I would rewrite your main loop: 

For a city-building game, I'd definitely use a square grid, for one simple reason: many real-world cities are built on a square grid plan, while very few if any are built using a hexagonal grid. The main disadvantage of square grids is that, if you allow diagonal movement, a single diagonal step covers a bit (about 1.414 times) more distance than an orthogonal step. The solution to this issue is to make diagonal movement slightly slower to compensate; if you're also measuring time in discrete ticks, having an orthogonal step tack two ticks and a diagonal step take three ticks gives a pretty good approximation to realistic movement. The other option would be to go "gridless", allowing the player to place roads and buildings at (more or less) arbitrary positions and angles. This could be implemented by having a very fine underlying grid (say, 0.1 to 1 meters per grid step), allowing roads to drawn in a straight (or curved) line between any two grid points, and allowing buildings to be placed at arbitrary positions and angles. Of course, this makes overlap and proximity checking a bit more complicated, but it's not that hard to implement. To make things easier for the player, you'll probably want to snap road endpoints to existing roads and building entrances, and snap building positions and orientations to nearby roads. (In particular, if I try to move a planned building on top of a road, the game should position it along the road instead.) You may also want to give the player the option to snap roads and building to a secondary, coarser grid (possibly with a customizable grid spacing) to make it easier to keep things tidy. Depending on how fancy you want to get, you could even let the player rotate the grid or set up multiple grids and custom guide lines. In any case, using a gridless (fine grid) design and a fine time step gets rid of any issues with diagonal movement: instead of counting ticks to move one grid step in some direction, you just measure the distance along the road from point A to point B (using the Pythagorean theorem) and make the time proportional to that; the fine grid and time step make any roundoff errors negligible. 

Don't think of the database as some kind real-time shared world model storing everything about everything at all times — as you've noticed, that can't possibly work. Instead, treat the database more like an automatically-updated save file: you update the database only occasionally, such as when players log in or out or move from one zone to another, or whenever something important happens that you don't want to be lost in case of a server crash. The actual real-time world state should be held by the game servers, in memory, just as in your original example. Now, the trick for horizontal scaling is that not every server needs to know everything at every moment. For example, if player A is playing in zone A on server A, server B running zone B doesn't usually need to know what player A has in their backpack — and, if it does need to know that for some reason (say, because player B in zone B casts some kind of remote spying spell on A) it can just ask the other server for that information. This does require you to assign clear responsibilities to the servers, so that when server B wants to know about player A's backpack, it will know which server has the authoritative information on that. You will also likely want to include some kind of update subscription mechanism, so that e.g. server B can just tell server A "I have someone spying on player A, keep me updated about everything they do until I tell you otherwise." You will probably also want to include some kind of global broadcast system for important global events that players may need to know about no matter where they are; of course, such events should also be recorded in the database, but having them actively broadcast to all server means that the servers won't have to keep polling the database for updates.