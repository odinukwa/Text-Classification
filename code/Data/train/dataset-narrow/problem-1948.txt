Have you replaced the power adapters and found that the devices still work? Have you bench tested the failed power adapters or tried them on other devices (assuming you have another device with the same plug and power requirements)? If you mean that both the power adapters (i.e. “wall wart” or inline brick) for your router and external HD have gone bad while attached to your UPS, then maybe your UPS is the problem. I would find it abhorrent that a UPS would fail a way that would destroy a connected device's power conversion hardware, but I suppose it is possible. It should be fine to power non-PC devices through a UPS. You would not want to run high-draw devices through a UPS (think Blendtec or KitchenAid), but a router and external HD should be fine (both should draw less power than a whole PC). 

For some Mac fonts, the font information is stored entirely in the resource fork of the file. On Mac OS X, such fonts look like normal files in Finder, but from tools like ls (and anything else that uses the POSIX layer) these look like zero byte files. The files from the Zip file are AppleDouble encoded versions of the combination of the resource fork and some extra Finder information from the original files. AppleDouble files are used by Mac OS X when storing files that have a resource fork or Finder info on filesystems that do not support resource forks and Finder info (here Zip is considered a filesystem). I am not a Windows user and my searches did not turn on any pre-made tools for this. I did find a set of tools that might work. It would be best to run them on a Mac, but they might work on Windows, too. 

I described using a binding in the second answer that you linked because it lets you use a single key as if it were simply the prefix in the nested session. For example, with (the configuration as you described it in your question), you could type C-j c to create a new window in the nested session. If you do not mind having to type the prefix, then a non- binding is probably better since bindings can be quite intrusive (they make it difficult to use the -bound key with stuff running in tmux-controlled ttys). 

You can use the public part of a key to to specify which private key you want to use from the forwarded agent. This requires creating an extra file (the public part of the key) on any “intermediate” machines (machines to which you forward your local ssh-agent). 

It makes sense that full escape sequences are not interpreted for these status strings: there is not much point to doing (e.g.) cursor control since they are always rendered into (part of) a single line. 

You type C-b. Your local tmux interprets it as the prefix key; nothing is sent to the processes running under the local tmux. You type C-b. Your local tmux has it bound to the command. 

The device is not especially related to the Console application. In Mac OS X 10.6, the Console application has two kinds of data sources that it reads: normal log files (e.g. the files in ), and messages logged through the (Apple extended) syslog facility. If you have a log file that you want to monitor, you can use the File > Open… menu item (⌘O) to view the file in Console. Note: The only way to remove a file from Console’s list of files seems to be to use its File > Move to Trash menu item (⌘⌫); be prepared to pull the file out of the Trash if you just want to stop watching it in Console. You can use the syslog command-line program to send messages to the syslog facility. 

Either way, you need to make sure that the appropriate is in your PATH. Also, you will need to use the option (“do not fork”/“run in foreground”) because otherwise will probably delete the temporary files before MacVim has had a chance to read them (at least one file from each invocation will be a temporary file). 

Unless there is some reason you can not run an SSH server on your guest, it is probably easier to use SSH to login to your guest (let the SSH programs handle connecting over the network and managing the ttys) and attach to (or issue commands to) the resident tmux that way: 

This maps the key sequence ( defaults to , but it can be customized), to the following sequence of Vim commands (separated by ; see ): 

A solution with a wider scope is to edit the terminfo entry for your terminal so that it does not include the alternate screen control sequences. The terminfo entries form a database that tell programs which control sequences to send to a terminal to create certain effects (moving the cursor, clearing the screen, erasing part of the current line, etc.). By editing the terminfo entry that your terminal uses, you can arrange to ‘neglect to tell’ all terminfo-using programs that the “alternate screen” control sequences even exist. From the list of the control sequences for xterm, we can see that the control sequences of interest (for xterm-like terminal emulators) are 

Most shell programs (shell “scripts”) will include a “shebang”/“hash-bang” line. The shebang declares which interpreter (shell) should interpret (run) the program that follows it. As several other answers indicate, shell programs that use a shebang line will not be affected by the user's selection of login shell, nor by the interactive shell that is the parent or Nth-parent of a launched shell program. If you are installing a new version of zsh and including it in your PATH, programs that use a shebang like will use that new version (when the are started with a PATH that puts the new zsh first). This can only cause problems if some incompatible change was made between your old/original version of zsh and the new one. Note that this would be an intra-zsh (inter-zsh-version) problem, not the inter-shell problem about which I suspect you are concerned. This is usually a much smaller category of error than if (e.g.) you tried running a ran a bash program with ksh. Not using a shebang line is inherently not portable between user environments. The result of trying to run an executable, non-binary† file that lacks a shebang depends on the environment (OS, shell, possibly login shell, and environment variables). When such a file is run on my Mac OS X 10.4 system, the behavior varies according to the shell that runs it. ksh, and bash both interpret the file in a forked copy of themselves. zsh always passes it off to . If some program were to try to it directly, it would fail with (this happens inside the shell, they just “cover for it” by “running” it in an alternate way). I have a vague memory of some ancient systems even trying to use the user's login shell in this situation, but my quick searching did not turn up anything useful. † A non-binary file is a file that the kernel does not recognize as one of its supported binary object formats. 

I put all my scripts (anything that is potentially platform independent) into ~/cmd and prepend that (and a bunch of other stuff) to PATH in my .zlogin and .bash_profile. I use ~/bin for some hand-installed platform-specific binaries (or symlinks to such binaries). Keeping the platform/machine-specific stuff out of ~/cmd makes it easier to copy it from machine to machine (I have mine in Git to provide history and transportation between machines). 

If you just care about data forks, I would go with something similar to pra's answer, but using instead of and instead of for a bit more efficiency. 

This example shows less cruft. All the s are other machines and the local machine is easily identified as 127.0.0.1. 

Your regex is prone to running into some O(N^2) behavior of the “backtracking” regex engine used in Vim (and many other languages and environments). Luckily, there are ways to write equivalent expressions that do not cause excessive backtracking. For example: 

The DVD Player app keeps some information about discs that it has played, but the storage is keyed by some sort of hash (the main part of each filename is a 16 hex digit number). The info is stored in plist files under , but those bits of information might not be terribly useful. My collection of files represents 40 “unique” discs, but only two of them have a “MediaName” key that gives a meaningful name to the disc to which the data corresponds. Here is a short shell script to extract any MediaName keys that exist: 

You can always set your own PATH in any of your shell's initialization files. Put something like the following in your of your shell's startup files (, or //): 

These files are also used to store extended attributes on filesystems that do not support them—most commonly the FAT variants. These variables will not really help when dealing with files on other filesystems, just archives. The HFS+ filesystem used in Mac OS X is perfectly capable of storing actual files, so once you use the variables to extract the files to the filesystem, the files can be accessed properly in all the normal ways. 

The easiest, built-in way to do this is to just drag the items from Finder to a Terminal window. When you drop them, Terminal will “type” their (escaped) pathnames. You can then use your shell's command line editing to enter the rest of the command. Or if you are thinking ahead, you can type the command first then drag in the items. The “drag first” version: 

As others have mentioned, Dropbox can skip parts of files that have not changed. But also, Dropbox will skip uploading files if it already has a copy on the server side (one that you or anyone else has already uploaded). So, if you are trying to upload a file that is identical to a file that Dropbox already has, the upload is skipped (and the other linked machines can start downloading it from the Dropbox servers). If you are uploading a file that is nearly identical to another, already uploaded file (it is not clear whether the already uploaded file has to be ‘yours’ or could have come from any user), then it will just send enough parts of the file to recreate it on the server when combined with the file that was already uploaded. FTP can do none of these things (it is a simple protocol to send and receive streams of data without reference to any other data that is available on the remote end). Tools like rsync and Unison can ‘skip chunks that the other side already has’, but are usually limited to comparing chunks inside files at an identical path in the synchronized hierarchy. Dropbox appears to extend this idea to collections of files (so if you ‘upload’ two nearly identical files, presumably it could arrange to only send one plus enough of a ‘diff’ to re-create the other). 

Note: The above example adjusts the global value, but each window can have its own custom values since these are window options. If you end up with a some particular window that you always want to be displayed in full, then you can (re)set just that window’s value.