In the end of the day, as you can probably tell by now, it all really depends on your game, how many assets you have, how you organize your levels, how you designed your animations and textures, and a bunch of other factors. However, I hope this gives you a general idea of what to consider when you look at the problem of texture management. 

The iOS application sandbox only allows a certain amount of RAM to be used and once you reach that threshold, any more texture loaded kicks out other textures out of RAM (cocos2d manages this for you I believe.) However in the worst case the application will crash if it does not have enough memory to run. So load only the textures you immediately need. You're holding a lot of unused textures in memory which is inefficient. iOS WILL clear your game out of RAM if it needs it. So if your game has a lot of textures loaded (using up a lot of RAM) and the player multi-tasks out to another memory intensive app and iOS needs more memory for that app? Your app will be killed and your memory cleared. The next time the player switches back to your app, they will start from the beginning. You can avoid this situation by not using more RAM than you really need to. Cocos2d also will clear out unused textures when it receives a memory warning. You may end up faced with a situation where the textures you thought you loaded, are no longer in memory and your application will crash when trying to create a CCSprite using the texture. 

Your declaration is correct, however, your instantiation should not have the CCSprite class name in front. Just 

Assuming that all your bubbles are the same shape and size where the only difference is just their color, you can instead use a white bubble and change the Sprite's color like this: target.color = ccc3(0, 0, 0); Where the 0 values should be replaced by RGB values respectively. Then you can just generate a different color bubble each time, so you can just keep calling addTarget: until you have enough bubbles. 

I'm implementing Lua scripting in my game using LuaBind, and one of the things I'm not clear on is the logistics of reloading the scripts live ingame. Currently, using the LuaBind C++ class , I save references to Lua callbacks directly in the classes that use them. Then I can use using that object in order to call the Lua code from the C++ code. I haven't tested this yet, but my assumption is that if I reload the scripts, then all the functions will be redefined, BUT the references to the OLD functions will still exist in the form of the held by the C++ code. I would like to be able to swap out the old for the new without manually having to manage this for every script hook in the game. How best to change this so the process works? My first thought is to not save a reference to the function directly, but maybe save the function name instead, and grab the function by name every time we want to call it. I'm looking for better ideas! 

After looking into this for a while, it seemed that zlib wasn't going to satisfy my needs. It seems to be focused on compressing and decompressing individual files. I need something that is able to handle archives. One potential solution I've found would be to use libarchive, which is an archiving library that will handle extracting files from an archive such as a ZIP file. It even allows you to assign the extracted file to a standard FILE pointer, which would make interfacing with any other libraries (PNG, my model loader) potentially more straightforward. 

I am currently using the DirectX June 2010 SDK. Everything was working fine with my installation until recently. Unfortunately I'm not sure what changed or when, but now when I create a device with D3D10CreateDevice1(), it always crashes with a memory error if the device is created with the D3D10_CREATE_DEVICE_DEBUG flag. Even reverting to old code which used to work causes this error. Additionally, PIX always crashes every time I use it with my game. I did some searching and found a lead that I may need to update my SDK installation. This page also indicates that I need to "install the updated SDK Debug Layers". How do I do this? I have no idea how to install the "Debug Layers"... Additionally, is it a mistake for me to be using the June 2010 SDK? Apparently DirectX is now included with the Windows 8 SDK, which I haven't been using because I've no interest in Windows 8 development. Is this foolish? Is there any downside to me using the Windows 8 SDK just for Windows 7 DirectX development using Visual Studio 2010? 

is fine. If you're using ARC, then you can leave out the retain. I normally like to just use properties though so I can refer to them easier and also have the option of accessing the ivar from another class. 

The answer to this question may be "NO" but it's quite important so I think I might as well ask. This should be a problem for all client-server location-aware games where player locations in the world are central to the gameplay. Is there any way we can make sure that the location data that's coming from the client is real (i.e. the player is actually there)? Working on client-server games, we all know that we should never trust any information coming from the client and therefore all important game logic should be done server-side. However with location information, we MUST receive this from the client. Is there a way to double check this to prevent cheating? 

I would recommend lazily loading textures as and when you need them. This also means you have to do a few things: 

I think that the answer to this question is quite dependent on the structure of your game (level based? infinite runner?) However in general in my experience you don't want to load ALL of your textures at startup. There are a few reasons for this: 

I have not come across a way to define the type of axis that you're talking about, however I can offer a method that I've used to overcome this issue. The best method, and most easily explained to the artists on the project, is to make all the sprite frames for all animations for a particular character the exact same sizes. For example, if your character walks and punches, of course the walking sprites will usually be narrower than your punching animation. If you crop your sprites without leaving any empty spaces, your character will appear to pop around since the anchor point for a sprite is usually it's center, and the center of a walking animation and a punching animation are different. If you keep the sprite frames of all animations for the same character the same sizes and position the head in the same spot within the sprite frame each time (don't worry about the empty spaces within the PNG, since TexturePacker will strip those out for you) when the sprite is animated, the sprite will not shake around, of course, the bounding box for the character will be affected since your sprite's size will always be as large as your largest animation frame. This may or may not impact your collision detection code, so adjust accordingly.