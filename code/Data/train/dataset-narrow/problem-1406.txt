I've written 3 factories as a part of a sign up process in AngularJS and Firebase. After completing them, I thought to myself, would any of these fit better as a service instead of a factory? From my research it's a bit fuzzy when it comes to choosing whether to create a service or a factory. If so, why would they fit better as a service? How can I tell when to create a service and when to create a factory? I've documented the to explain what they do, and the ones that lack a documentation explains themselves in the name. 

This might need a bit of editing but you get the idea. However I'm not sure if any of these are actually better ways of doing what you want, but it's other ways of doing it. It might make everything more manageable if the code gets even bigger. Hope this helped. 

Personally I would create loops for this, it's very unreadable at the moment and you are repeating yourself a lot. Remember the DRY rule (don't repeat yourself). Also if you do it via loops it's easier to maintain and change in the future. 

I also work on an e-commerce platform that has tons of data in it. What I've found is that if you have more than a very basic query, write the query yourself. EF speeds up saving records and very basic selects, but as soon as you start doing something a bit complicated, EF will spit out thousands of lines of SQL for something you could have done yourself in 100. You are better off just trying to create the SQL for it and use Dapper or just create an object that you can map directly back to from the query. Use context.Database.SqlQuery(sql, parameters).ToList() and you'll be able to get exactly what you need. Though, naturally, it is going to be way more work on your part since you have to do all the joins manually and type that out, but if you need it to perform, then I would really recommend just typing it out. I've had calls go from 60 seconds down to < 4 by just doing it myself instead of relying on EF. 

I'm going to use this above method to point out a couple of things that occur throughout your code. The first is minor: according to Java convention, your access modifier should come before the keyword (e.g., ). Not a big deal, but something to be aware of. More significantly, your method violates the "do one thing and do it well" policy. The method is called and returns a . That means it should evaluate the two numbers and check to see if the number is correct -- and nothing else. Instead, you're using this method to also provide feedback to the user. If you published your API and I wanted to use it, this would in no way be intuitive. 

Putting it all together, we get something that looks like this. If it were me, I'd probably further specify the function so that you could pass in something like or rather than the three decimals, but that can be for a future release, haha. There's some further encapsulation you could do to make the code still more elegant and readable, but I leave that as an exercise to the reader. 

If you know the queries you affect, you just have to give it the query type and it'll take care of the rest. I made it async in case it took some IO to figure out all the types. Decorators The most important decorator I wanted to show was the exception handling one that is at the top of the chain: 

There are specific scenarios in my logic where I can easily not throw an exception and have the above layers just check those boolean flags to determine what to show the end user. If a real exception occurs, I can put that on the ErrorMessage property and pull it from there. Looking at CQS, I realized that returning an IResult with this for a command is okay because it isn't returning any information about the actual process. Either it succeeded (IsSuccessful = true) or something bad occurred, meaning I need to show something bad happened to the end user and the command never ran, anyway. I created some helper methods for creating results so coder's don't really care. The only thing that gets added to the main implementation is: 

That's just my particular style, but even if you don't like mine, there should be a consistent structure you use throughout your code. 

Your code is really good and very well written. I think that's why you haven't received a response; not much to critique! You have good comments, good style, pretty much good everything. I wish I saw code like this in my production environment. The only thing I noticed that you might clean your code up a bit is this part: 

If you don't know what an enum is, now's a great time to learn. It's a very useful data structure which lets you define exactly what its potential values are. Here, it seems like your missile types are PAC-3s, GEM-Cs, and GEM-Ts, so that's what we have above. This is why object-oriented programming is so powerful. A missile is a thing in the world with its own properties, and so it is here. This enum may have been more appropriately named , depending on your preference, since technically it will hold values for multiple missiles, like the . But having this data structure set up is what will let us completely rewrite your method in just five lines. 

Validation The validation decorator will run validation on multiple threads (if you want) and async will not block. I didn't use expressions since a lot of times validation involves multiple properties and has a lot of overhead. The BrokenRule() parameter is the "Relation" and it can be used to tie the rule somewhere on the UI. 

This way, I don't have to handle any exceptions to change the flow of the code except when a truly exceptional thing happens. It is caught like this in the top level exception decorator handler: 

Edit The last point here is that Exceptions actually are pretty slow. When I throw an exception, it ends up taking around 150 ms to get the result back. When I switched to not throwing an exception, it would get around 25ms response for the exact same check/data. That is 6 times slower! Thus, avoiding exceptions seems like a really good thing to do! :) 

If you are still reading and your eyes haven't glazed over yet, what are your thoughts? Is this too much? Thanks! 

No need for these lengthy declarations since they all do the same thing and all you're doing is printing the stack trace. will do and make your code more sensible. 

In general, you should try to have more descriptive method names. Following Java naming conventions, they should always be verbs or verb phrases. It just makes your code more readable and easier to follow. For example, this could be called or something. 

This entire block is very difficult to scan. What it does isn't readily apparent by the way you've named all your variables. For example sounds like the rightmost node in the tree, but in fact it's the left node of the right node in the tree. Then with all the subsequent processing, it's very confusing without stepping through line-by-line to get a better understanding. Consider renaming your variables to be more meaningful. In my opinion, the most beautiful and elegant code is self-documenting. Also, if you were looking for ways to further improve the code's functionality (besides adding recursion), you might look into generic types so that your nodes can hold any data, rather than just an .