You interpolate to find states between known values, and you extrapolate to find future states. Think of the problem in terms of state variables, like positions and velocities. In the best of all scenarios, every computer which needs to work with state has access to the state data for the time they want to work on. For example, a collision algorithm to see whether laser-rifle shot X interesets player A's head, the best of all cases is when the algorithm knows the exact position of every object at the time the laser was fired. In the real world, we are not always so lucky. Sometimes the truth information we receive is more sparse. For example, if player A is a remote player on another computer, you may not know exactly where they're going when you fire the laser and need to calculate the shot. In this case, you need to create an estimator for A's position, typically with interpolation or extrapolation. The difference between the two is whether you have data that is bounded on both sides, or only one side. Let's say that Player A has already announced their truth position for t=0 and t=1. Player B shoots a laser at t =0.5. In many situations Player A's announcement of their position at t=1 can occur before Player B pulls the trigger. Why? In many games, the responsiveness of the controls is less than perfectly instantaneous. In a racing simulation, much of the player's position is bounded by the physics of a moving vehicle. You may choose to announce a "future position" because you know you really can't steer all that much in a short period. If you have information in the future, you can interpolate between the two values. What if you aren't lucky enough to have a t=1 value? What if Player A wasn't in a position to announce their future location, and you're stuck deciding whether you hit or missed with only the information from t=0? In this case you have to extrapolate. In extrapolation, you use what you know about the motion to extend beyond any data you have. You might know that Player A has a certain velocity, so presume that if you multiply that by time, you can get a position at each time. The difference is in the behaviors. Interpolation requires you to have an upper and a lower bound, which you do not always have. However, in nearly all situations it has vastly better results than extrapolation. Extrapolation can easily lead to unrealistic movements. Consider the case of a player who is sidestepping left and right to avoid being shot while advancing. At any given point, their velocity is along a diagonal, so if you extrapolate, the player may appear to run off to the side when, in fact, they never do. If you only do interpolation, the values tend not to stray outside realistic values. Interpolation and extrapolation are two extremes in the world of filtering. There are many many many many many filters out there for handling data like this which mix and match properties between interpolation and extrapolation. Accordingly, don't be surprised if you see algorithms that are not clearly interpolation or clearly extrapolation. Those two are just the tip of the ice berg. 

The number one thing I have found that limits educational game is a hard lined insistence that the adult programming the game define what will be learned in the game. Much of a game's appeal is from the player deciding what they want to get out of the game. The game maker can make suggestions, but in the end, it is the player that decides. If your game suggest "You should want to learn to add positive and negative numbers," and that's not the player's definition of "fun," they'll quickly put the game down. Instead, make room to permit the player to decide what they want from the game. If they want to have fun in their particular way shape or fashion, let them! Sure, reward them for wanting to have fun in ways that support your educational goals, but don't make it hard to enjoy the game outside of a narrow window. Let's use your cannon game as an example to brainstorm on. Unless you feel like adding numbers to get to a zero, it's a rather boring game. However, what if summing numbers to zero instead offered you power ups, and the "game" was a more standard cannon game. Now the game is just a game, but there's a way to make it easier by doing math. If a player wants to win simply by shooting every number out of the sky, guess what: they learned geometry! As the game progresses, you may try to encourage them to play the math part of the game more by making it gradually harder to progress without playing the part of the game you want them to play. If they want to stick to the easy stuff, that's fine. If they want to rely on raw twitch fingers to blast everything, that's fine. If they want to concentrate on the math, great. If they want to find their own balance between math and twitch, that's even better! Now, consider that paragraph with respect to Candy Crush, one of the more addictive games of all time. The primary focus of the game is on studying patterns in the game grid. Instead of making that the game, they make it a way to power up: cookies kill off whole colors, wrapped sweets slaughter columns or rows, etc. At first you can just play the game any way you like. However, as you progress in the levels, the power-ups smoothly become more and more important, until you reach a point where some of the simpler power-ups are absolutely and utterly required to beat a level, and the game encourages you to reach for the more powerful power ups. Candy Crush is a good example for how to not make a game boring! 

It sounds like you need to modify your XML file that defines your spritefont. You want to ensure that the and tags are correct. Below are the ones that I use in my file. 

What you need is called a painter's algorithm. You want to draw the furthest tile first, including any doodads or characters on it. Then draw the next closest, and repeat until finished. Your objects that span more than one tile must have an anchor/origin point declared. This is the grid cell that when drawn, will result in your larger object also being drawn. The origin point is chosen so that it is drawn after all cells the object bleeds into are drawn first. Based on your question, your origin point will be the tile that is closest to the camera. (If you are using square, rather than diamond-shaped tiles, either the bottom-left or bottom-right tile should be chosen.) Example code for a square-grid. Alter the loop direction for your diamond-grid. 

I experienced some problems with in XNA when I tried to mix two different SpriteSort modes. (Begin with deferred, end, begin with BackToFront wasn't sorting properly.) I've settled on just giving everything I draw with SpriteBatch a depth value. To that end, what is the smallest increment I can use on the floating point variable that will be used as the depth parameter without running into rounding problems? The valid values for this float are between 0.0 and 1.0. It is a float, not a double, and the language is C#. UPDATE: My testing has shown that 0.008f is the smallest amount I can change my depth value by and be certain the sorting will work. I'm guessing there is something else at play in BasicEffect or SpriteBatch. What I am trying to use this for is the rendering of my game's map grid. I want to make heavy use of transparency and overlapping to create a specific visual look for the tiles, the doodads, and the characters. Essentially, I am using a painter's algorithm to draw the tiles in order from the back row to the front. I have them numbered so I know the ordering is correct. The doodads I am trying to draw on top of the map are not appearing when my depth decrementor is set to a low enough number to draw everything I will need. It only works properly in a range where I can only access about 100 unique depths. UPDATE about SpriteSortMode problems (as requested): Thus far in my project I have got by just fine using SpriteSortMode.Deferred for everything. I have all of the standard UI components you would expect, windowing, clipping, etc. working. Now I am attempting to draw my map grid. Like windowing/clipping this requires things to be done in a specific order to look right. The grid tiles draw in a certain order. To accommodate overlapping, doodads/characters draw on top of a tile before the next tile is drawn. No matter what I did, my doodads/characters would always be drawn under the tiles. Changing the order of draws had no impact. Even drawing all of the tiles and then drawing the doodads resulted in them showing up underneath the tiles. Especially odd was that my UI elements continued to appear above the problem tiles as I scrolled around the map. I switched to SpriteSortMode.BackToFront and with a high enough depth difference (~0.01) I see things drawing on the grid as expected, but this depth difference is way too high to support every visible tile of the map. I am searching for a better solution than to write code that will End and Begin a new SpriteBatch every time ~100 pieces are drawn. 

Magic: The Gathering Duels of the Planeswalkers has AI that simulates possible future game states. Different AI difficulties are allowed varying lengths of time to plan advance turns. Additionally, the decks of easier AI opponents are sorted so that rarer cards are more likely to appear near the bottom of the deck. Here is a detailed article with pictures(!): $URL$ 

I am looking for a tool that will output spritefonts for XNA consumption that have an outline effect. I know that this can be done by rendering the text multiple times, but I'd like to take care of it in the content pipeline. The options that I was able to find reference to were hosted at sites that are now offline. I know Nuclex has a vector font option, but again, I'd like to stick with sprite fonts and handle the rendering at compile time. If anyone can link to an archived copy of those free tools, it would be appreciated. 

You'll want to use something like Amazon S3 or Azure Blob storage. Both of these services will charge you for data transfer both IN and OUT; as well as the average storage amount you are using on their servers. They both offer a simple API to read and write data to and from, you can write iOS, Android, BlackBerry, Windows, Mac, Linux, etc versions of your application, which would all consume the same web service API. This gives you the ability to have users interact with data on any platform, and have those changes immediatly available on any other platform. Optionally, you could write a simple web-service which handles your data conversion between platforms, you could use something like Amazon EC2 to host a service like this. Depending on the complexity of the data you are storing this might be over-kill. 

I think that the positives of a local loop back server, far out weigh the negatives. The amount of code reduction is extremely valuable, in my opinion. With regard to running redundant physics simulations, you should look into server ticks, Valve has a great writeup on it here. In a local server environment, you maybe able to remove the "client simulation" and simply send full-world updates, in a local-only situation to avoid the redundant physics simulations since you'll have plenty of bandwidth. 

I don't think that half of your code base will turn into network code if you decide to implement a feature such as this. In my opinion, the most simple way to do this, is to setup a "central" server (even if that means that one player "hosts" the game and then connects to his own server) that accepts all user input as fast as possible, and sends it back out to each client. On the client, you implement this no differently than if you were doing a co-op game for two players locally, except you read P1 from keyboard, and P2 from network. You'll need to have the server send out a full game state every once in a while, and both clients can either snap to the new authoratitave state from the server, or they can slide into the new state (over a few seconds). Unless you have horrible packet loss or tons of clients per server, this approach should suffice for the situation you outline. 

I presume that you mean MonoTouch + MonoGame (formerly XNATouch). There are several successful iOS games deployed using that combination. It seems that either way you can port to/from iOS/Android, so the question be comes which do you like better? I believe that the iOS terms were adjusted to permit things like MonoTouch; however, (my optinion follows) Since Apple runs the iOS environment, you will alway be at their mercy, whatever Steve Jobs decides isn't kocher for iOS will be given the boot. with that said; I would probably not hesitate to use MonoTouch to develop commercial software for iOS. In terms of Unity if you really think it might be a better option than MonoTouch and MonoGame, I'd try out the free version of Unity and see if you like the tooling and the development experience, if you like it go for it and if you don't, head to MonoTouch. 

You are in the catbird seat. You have a complete and working game. Your options are limited only by how much additional effort you'd like to put into this game. In my mind you have three basic options: 

Provided that your interface is intuitive and you don't price yourself too high, I don't think its too much at all. On the contrary, I feel that the tower defense genre of games is mature enough even with casual gamers, that they will not be intimidated by these new features. 

XNA Games on 360 use and are required to use -- which as I recall means max users per "game" is 32, and you can not connect to any outside services at all. 

As @AttackingHobo said, the memory is very fast and expensive. Also, you must take into account that these consoles launched years ago, when memory and hardware prices were higher. Another factor that goes into making consoles very performant on what appears to be very limited resources, is that since every console is identical, we as developers can take advantage of platform specific optimizations. On a PC you can't do that as much, and thus you are required to have a beefer PC so it can brute-force its way through a similar unoptimized task. That isn't to say there is no optimization in PC games, but it is in different areas than consoles, and in general due to the wide range of supported hardware, it is less effective.