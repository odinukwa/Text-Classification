I feel like your approach of adding levels points in the right direction. I one implemented a similiar system with generic crafting parts. Like a sword need a hilt, a core and a blade / a gun needs a handle, a barrel and a muzzle. Each of this components is defined by materials, like the hilt need 1 metal and 2 wood or leather and so on. The player can then combine raw materials to get different components (like a wooden hilt or a leather hilt) and combine these components into a weapon. This approach will allow you to have a small defined set of reciepes with quite a lot outcomes. You can then extend the system by addind some special reciepes (like hilt with a gem slot in it for extra elemental damage [ruby = fire, onyx = earth and so on]). Hope this gets you started with the general idea, feel free to comment if you got questions. 

My guess is that I may be projecting the depth texture in a wrong way. Thanks in advance for any help. 

The shadows are still rendered fine, but the grass lighting is completely off, alternating between dark and bright grass. The small "scene" above the grass is also very dark (I use the same shader as the one for the grass, for convenience purposes). Even the debug text in the upper left corner isn't being rendered anymore... I use the same shader for both scenes, except I use a uniform to let the shader know when I use instancing and when I'm not. Here is the lighting shader: 

I have been trying to get texture compression using ETC1 (specifically PKM files) working for some time now. I am trying to do this without having to upgrade to OpenGL ES 2 so I have been using multi-texturing. I have the multi-texturing working now (finally) but the problem is that it is not behaving as one would expect and I think that I have figured out why. When creating the PKMs you end up with PKM with the color components only and one with the alpha component only. Problem is that the alpha PKM seems to be storing the alpha value in the RGB channels. Black seems to represent full transparency and white seems to represent full opaqueness. My question is: Is there a way to combine and convert these RGB values into an alpha value when using multi-texturing? If not, then I don't see any options for using ETC1 and supporting alphas under OpenGL ES 1.1 (please correct me if I am wrong). 

If I run this and inspect the backpack after the for loop, it contains 1 stack with count 10 and 5 stacks with count 1. Try to check if you are actually generating Items with the new keyword, this should fix your first error Feel free to comment as soon as new questions arise! 

To create maps like the one in the video you could start with 'tile-base maps'. Tiled maps implement the idea that your map is created from similiar sized blocks with different textures. There is a good tutorial for tile based maps with XNA. This tutorial explains some of the basics and shows different concepts which may be usefull. You question is very broad, so feel free to refine it, or get in contact if you got any particular problems with your journey in XNA ;) LostGarden provides you with some graphics to start withenter link description here, if you just want to get your hands dirty with XNA and tile based maps. 

So after looking into this quite a lot I have found that you can only really do it using shaders as @Andon M. Coleman mentioned. This, however, only works in OpenGL ES 2.0 and up. I almost got this working in OpenGL ES 1.1 using multitexturing but eventually it became clear to me (through my own experimentation and other questions that I asked) that this was not going to work since it requires you to combine RGB channel values to get the alpha channel values. If you want to stick to OpenGL ES 1.1, then I found that the best approach is to just compress your images that do not require alphas using ETC1. I then used quantization (via pngquant) to dramatically reduce the size and memory footprint of my images that do require alphas to be preserved. This approach has dramatically decreased my game's memory usage while still keeping the quality of the textures at a more-than-acceptable level. 

You keep your objects in the same list (_targets). Therefore the game can not decide if you are talking about a cloud or about a sol, both are just CCSprites for the game. Therefore it loops through every element, handling it as a cloud and then does the same thing again, handling the objects a sol. To prevent this save the objects into 2 differnt lists: Clouds into _cloudTargets and the sol into _solTargets and change the two loops to: 

You may want to give this paper a read. It is about constructing platformer level based on jumping rythm. The simplest approach would be to define rules for each layer and match the tiles agains it. You may define a range the character can jump with single (and maybe double ) jump. Then evaluate possible next tiles in this range and pick one at random. 

The depth buffer seems OK, so I guess it comes from a transformation done in the SSAO shader. Here are the shaders (I'm using the bgfx library, but the shader language is very similar to GLSL): Here is the way I output the depth from my SSAO for testing : 

(Yes, every pictures are done with MS Paint...) The areas in gray are the surfaces that you're not going to discard in your computation of the effect. To do that I would compute the dot product of the ray and the surface normal and discard the ray if it is under a certain threshold set beforehand. Also, try playing with this value until you get a decent result. In doing so, you'll not get falsely occluded rays and you'll avoid your heavily occluded areas. Hope this helps anyone ;) 

I feel like there is a conceptual error: Do you really want to destroy the 'cheapest' obstacle, or rather preventing the player from placing this last, full blocking, tower. If this is the case you should recreate a new route as soon as the player clicks to place a tower. As ratchet freak said you can assign a much higher cost to passing through towers and you will find out this way if there is still a valid route (no high cost). If there isnÂ´t you just prevent the player from placing the tower. 

Is it possible to see how many of your users have unlocked certain achievements on the Google Play Developer console? This information would be very useful. I guess that one could achieve this through integration with Google Analytics but I was wondering if there was a simpler way to get this data. 

One of the problems that I am having is I don't know which texture ID to bind to when rendering this multi-texture and if I should make GL_TEXTURE0 or GL_TEXTURE1 active when rendering. The code above is from the load() method within my Texture class. On startup, I load all of the necessary textures using the code above. I then keep a reference to these Texture objects while I still need them and when I want to render them, I bind to the ID of the rgbTexture (as shown above) and I make GL_TEXTURE0 active. Is this correct? Should I be binding to the alphaTexture's ID? Should GL_TEXTURE1 be active when rendering? Or both? Or is multi-texturing supposed to happen at render time? Ideally I am looking for a solution that combines these textures into one at startup and then when rendering, I just bind to this one combined texture. 

Now you pick a random number between 0 and 50 and then choose the corresponding action (0-19 eat,20-49 escape,50 roam) I hope this idea get you started 

I think you are running into some other problems here. What if the player is faking to be a normal client (by simulating your network traffic) and is using to corrupt your game by wrong validiation? Instead of trying to build a bullet proof client system, which will lead you to continious bug / exploit fixing and banning, I would try to simplify the server system. I do not know enough about your game mechanic, but maybe you are able to boil the information on the server down to a minimum. In general you should assume that the client you are talking to could deploy any code and game mechanic it feels like deploying. And this makes client side validiation nearly impossible