first, you create appropriate mask by shifting single color mask to correct position (alternatively, because it is static value tied to source pixel format so you can pre-compute it), then you extract all bits of the color channel by and shift them to get the value . After that you shift the value to its correct position in BGRA8888 format and last you or it with zeroed BGRA8888 pixed . You can skip some shifting if you know the formats in advance and hardcode it. 

There is a sweeping algorith for this with logarithmic complexity, precisely (n+k)log(n). The algorithm is described as follows: 

Yes it is possible. And it is called texture. Textures are not just pictures - it can be any kind of data*. Another option would per-vertex data - if you dont mind smooth border between (un)explored. Or just as other post suggested - pass it as per-tile uniform. * Ofcourse, you need to stay in reasonable array size, defined by maximum texture size. Also note that editing such texture would mean sending it all over again, which could be slow. 

You should have a look at sampler objects, if is it a solution that would suit you. Basically a sampler object is openGL object which can store these kinds of settings for later use(binding) in shaders. Example of usage: this tutorial. 

note: did not checked up and right vectors are the "correct" ones(direction of AB and BC), if not just try one of the other pairs. You can also replace normalization with multiplication by constant of value because you know the length of hypotenuse of unit square. The is getting vector "between" AB and BC direction, minus is for inverting. It is effectively the same as computing angles. 

Some times it is hard to determine who is the real actor. Why not saving the players tokens in the player itself so that each player has a reference to it's tokens (even if you only have one) then let the board roll a dice. The board itself (being a representation of the actual game rules) should be called to move a specific token (by players choice if there are more than one) with a specific dice roll. So in a monopoly style game it would be the only token a player has wich is moved forward for a given ammount of fields. In a Ludo game the player would chose wich token is is, that he wants to move and submit it to the board class. Why do I put the dice roll into the board? Because it depends on the boardgame itself what dice is it to use or if the actual player has to roll the dice more than once (because of special game rules (e.g. prison in monopoly) So your Player would actually be a class that holds every information about a player. Name, Points, Money, game tokens that belong to him etc. . While the board says whose turn it is and what options are open to that player. How you move your game tokens is up to the game rules. Is it important that a player cant cross specific fields without stopping, then you should have a method that moves that token only one field at a time to check if such a field has been crossed. If it isn't that important you could just say "move my game token for 4 fields in that direction". You could even go all the way down to writing a standard board game Interface that you can use to implement several different board games wich have a more or less linear game plan layout (monopoly, ludo, game of life). 

But that Hexagon is quite complex and I don't know how to calculate an AABB - Polygon intersection, is there maybe an easier way? Any programming language that you like the most, I can easily port it. Thanks. 

As you can see the AABB just falls through the bottom Line, when it should stop. I have been trying to do this for a month now, and I can't find any solution at all. Why does this happen and how do I fix it? Project: $URL$ - Move with WAD and draw lines with mouse Source Code: $URL$ and $URL$ 

Here's also a video of it: $URL$ These ghost collisions occur when there is no velocity on for example the x axis, but there is velocity on one, the y axis in this case. They occur because we know that there only is velocity on that axis, and therefore we only check that axis, there is one very easy and very good way to fix this. This fix will only not fix this problem, but it will also improve the performance. So, what you want to do is this: 

I asked just this question on SO a while ago, same language aswell, and no one didn't really care, so when I found the solution I didn't really bother to put it up there, but now more people are interested and I am glad for that, so now I will post the answer here. Here's my original code, it's the exact same thing as yours, just a bit more clear of what it's about, since it checks for every axis in a loop (You can even add one more loop and boom, it's 3D if you want): 

1. Buy a notepad for keeping every idea you'll get. You don't have to actually put them in your game but you can use them for further inspiration. 2. I'm also trying to hold everything I still have to do on a corkboard or a blackboard so I always can look for my next targets to finish. 3. Don't try to implement things the best way on the first attempt. Try to get things running and make them nice in a later step. So you could have different features on different states of niceness: 

If your weapons only differ in some stats, you dont have to use any of this. Just put the stats in the base class and fill them accordingly to your wishes (boolean twoHandedness,int damage, String name, ....). 

you clutter your code with many sublclasses, that you obviously don't need you have to keep track of your depth of inheritance (?) if you change something in your weapon classification hierarchy I don't think there are many advantages to this approach 

Are you using 3D? Then you could just add slightly scaled versions of the same object wich are coloured in your halo colour and have 0.2 alpha. Then just render the real object after all these halo-objects 

There are many ways of reusing your classes this way. Want a cannon that is also a sword? Just put the two types together in a class and implement a supertype SwordWithCannon ;) (you can't do that with the first approach that easily) Less code You could even change the behaviour of the weapon during the game. So your Sword gets blunt, just change the swordType to "bluntSword" (or something similar) 

Let's say your checking collision between A (blue) and B (red), before you perform the sweep/continouos collision test to get the time of impact, check if they even can collide during that frame, to do so, wrap them into these green boxes, which are created by using the and of both A's and B's position (min and max corners) in this frame and in the next frame. If these green boxes intersect, do the sweep test, otherwise, just move on to the next two objects. This will not only fix the problem, but also as I said, improve the perfomance drastically, since you dont need to run unnecessary code. This took me a while to figure out, but it's rather easy to implement and it works nice and smooth. That article you found is good, but not really when it comes to collision response, which I think is horrible. I know it is very hard to find information about sweep testing, since only a few even know what it is, but if you get the concept, you can kinda play around with it and find your own solutions. There is almost no information about collision response for sweep testing either, which is kind of annoying, but you can ask me if you want. Also I am quite curious what kind of project you need this is for, not many use sweep testing in their games/apps but I think people should, because it's much more accurate and smooth imo. 

It helps a lot in motivation if you get things running first before considering making them nice and smooth. The downside of this method is, that you will be coding more code that you'll put in the trash in the end. 4. Dont implement too much features parallel. Try to conentrate on <=3 features at once. So you have some place to switch to if you stall at one feature but not that much features that you are overwhelmed by the ammount of work to do. 

Aside from the fact that even loading a file with some data of this dimension shouldn't take minutes (could you post your loading and tile filling algorithm?) you should try to load only what is instantly needed by your game and load the rest while the player is playing your game. You could take your loading code and the fields that it fills and put it in an seperate thread that notifies the game if there is enough data ready for the player to start. I'm writing a small 2D RTS Engine in Java and I use 2DArrays (ArrayList>) while every Entity has its own z value (they wont change in my game). So it breaks 3 nested for loops down to 2 nested for loops. Even that approach isn't the most efficient way I think. 

Python is fine I think. Often LUA is also a good alternative if you want to add scripting capabilities to your programs. You could either use XML to describe the behaviour of your monsters, this would involve some coding in the actual game code because you'll save only the "name" or some attributes according to the behaviour (speed, type of weapon the monster uses, etc.) of the behaviour to use in your game code. If you use a Scriptengine (e.g. LUA) you could transfer this code out from your precompiled program to scriptfiles that are loaded during the runtime. To do this you have to expose the API of your "monsters" to the scriptengine. That allows you to call the methods of the monster-game code from the outside.