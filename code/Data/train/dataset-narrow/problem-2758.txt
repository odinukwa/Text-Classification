First of all: most computer trigonometric functions takes radians as input. Even if the code worked, I am 99% sure it will not rotate by 90 degrees. So if it is that case, try changing it to pi/2. Secondly, if you would rotate by not-multiply of 90 degrees - the code would still produce axis-aligned rectangle (bounding box), NOT rotated rectangle as you are iterating in axis-aligned loop. And last: when rotating, you are always rotating around origin point. If you first translated the rectangle - it can very easily end up outside of the screen. The order of transformations matters! I imagine you tried it on input like (1,1,4,4), such rectangle is already translated, try the code with pi/2 and input like (-4,-4,4,4) where the rectangle is centered in the origin. 

Edit: (for downvoters) please, look up definition of game(moreover the game above is just for illustration purposes): a physical or mental activity or contest that has rules and that people do for pleasure or 

This illustrates the arguments why games with at least some abstract rules are hard - this is exactly what AI would try to ask: how do I measure it, how do I describe it with an equation? AI is not capable to think out of the box or make complex abstractions (such as having fun). The correct answer is: 

also I would improve the method a bit - as for now it could(though unlikely) cause stack overflow, crashing the game. Again the problem is recursion. Rather then using recursion, I would translate the result to correct range, I would replace the code above with these two lines: 

I think you problem is caused by continuing to execute the method when invalid position is generated: 

If I am not mistaken these types of problems are usually solved by backtracking family of algorithms. I would use an algorithm similar to DFS: recursively search the solutions tree and whenever leaf node is reached, save the path if it was the longest discovered. After reaching leaf node, backtrack to last "crossroads" and take the other turn(s). In order to prevent infinite loops you will also need to mark visited/searched nodes. 

The solution is easy implemented but very very computionally heavy - I would not be suprised if this was NP-complete problem, similar to the travelling salesman. The solution has two steps: 

None of above alone will make it impossible (the go is good example of that) but with careful design you could make it at least infeasible for a few years/decades. A very, very simple game for illustration purposes using said suggestions: 

To expand @Alexandre Vaillancourt answer, I would even consider using a collection that keeps your data sorted, instead of re-sorting it every frame. 

The idea is right, the execution however is chaotic. First of all "So far I have tried finding the vector perpendicular to its forward direction", you already seem to know the trick - swaping x,y and inverting one axis, but why you apply it to some random products of calculations? 

Second: "But then I realised it is only calculating around the origin.", there is nothing easier than moving your problem to origin - by using relative position to your car(just substract its position). 

Every level 50 sword now has 85 to 115 damage. To improve randomness we will say random factor not same for all swords, but rather within some specific range, lets say from to . 

The simplest and probably fastest option would be to iterate your mesh and set edges vertices transparency to 0 (or any other desired value). This assumes you v got (fan shaped)adjacency information: 

EDIT: the exact numbers are even worse, when rendering 1m triangles render time increase from 1.5ms to 2-6ms and in spikes up to 15ms. 

to further enhance randomness, you can use the idea of perlin noise - "overlay" several random numbers, each with different "locality". 

Now you have all you need to get all 4 points of the segment rectangle, just offset endpoints by half of the desired width in perpendicular direction: 

I think we can agree the quality of the story playing this game with average human players will be much better than any AI just as well as the fun for human players playing the game(this is ultimately the goal of games isn't it?). This game is probably even older game than go. just a note: noticed how this game above incorporates all of the suggestions? The feature extraction from speech alone is not trivial task, paired with abstract goal of the game with insanely huge state space (natural language is infinite) makes it nearly impossible for AI to crack(=play better). 

Whenever player would at his current speed cross a junction there is decision to be made which way he will be moved. You have many possibilities what logic choose here, first one to come to mind is pick the last held(=last pressed, still down) button direction. You could implement this for example by storing keydown(up) events on a stack. In your original image, if player was on edge between nodes A and B, 1.1 units from B and moved 1.6 units in direction of B, decision would be made(trivial check 1.1 < 1.6). If he held button S first(for moving down) and "short" before junction pressed button D, he would cross the junction, turning right and continued (remaining 0.5 units) on edge from B to D. 

Yes, you can perform simple binary search on region divisor vectors. If you pre-process and sort your divisors ccw(and you probably should), it is sublinear log(n) complexity for n regions (oposed to other answers with linear complexity), moreover it doesnt rely on inaccurate and slow functions like , in addition your regions does not need to be quadrants or evenly spaced, it works for any number of any regions. All you need is to determine if queried vecor lies to left or to right to the tested divisor(that is one vector operation) and apply this greater/lesser logic on same binary search like you already know. Code example(not tested): 

You may also want to handle cases for almost zero values(all three points are on the same line) picking, for example, the closer one. You can also find a library with more accurate isLeft implementation. *this should work for any convex and star-shaped polygons. 

Does your A* implementation expect undirected graph? Do you have one-way mirrors? no, unless you require logic for finding not-visible-paths 

After the edits, if I get it right - you are overcomplicating things: you need a single level of n-ary tree that, looks like it has all previous levels generated randomly, right? Well, why not take n-ary tree level, for simplicity binary tree. Lets say you want 6th level, that is 32 elements if that is full binary tree. Now generate random 32-bit integer AND it with the 32-member array if true, there is a person, if false there is null member. 

If I understand question correctly, you wish to reduce width(x scale) so that total area of object is maintained. In order to do that, when setting x scale you need to set y scale to . Second part is finding the x scale. Please note that it is relative to object width: 

tl;dr you will have to do math and read some tutorials on ray casting. Code and step-by-step explanation would not fit few paragraphs. EDIT: another solution could be using trigonometric functions. Because you know hypotenuse is distance / cos(th). Where th is angle between direction to target and aiming direction and distance is...distance. Now you only calculate the length of opposite: sqrt(dist^2 - hypotenuse ^2), and that is your result. 

There are two more options solutions to overwriting single buffer in 3.x (few more in later versions): 

Arachnophobia is very widespread. But, as an arachnophobic(and gamer) myself, I do not get panic attacks. Actually I do not know anybody who gets panic attack for looking at drawn spider, those cases are very rare. If it is so advanced illness, the person would be probably even afraid to turn a computer on - there are pictures of spiders everywhere. Surprisingly, killing spiders as an arachnophobic can be even more satisfying than killing regular monsters, especially if you can kill them from afar (and if they dont jump onto screen).I really doubt high number of really serious arachnophobics(heart attacks) play games - spiders are very favorite monsters in games (show me any RPG without spiders!). For my original link to paper listing exact % numbers see comments(or Anko's new answer). 

Do you see what is wrong now? If the value of is higher than your size of VBO, it is a problem. Moreover, for VBO it is recommended to have around 1-4MB of vertices in it - only 4 vertices/VBO will very likely kill your performance. You might be interested in instancing instead. big edit reason: cant read right(solved in comments) 

Where did the go? The renderer does not need it now - its IDrawable for it, and if you do, you would probably have to duplicate the references data anyway and this way you can separate actual and logical order/storage of you data. Why suggesting this solution? Even though, judging from your code, you dont aim for performance, this spares you re-sorting every frame and makes you code simplier. If you are looking for faster solution you should rather change design of your engine to be more data-driven. Note: I did not check the syntax, and in the end which solution is better depends on personal preferences, on your preferences. While it performs great for mainly static scene, the fact that you cannot change keys makes this solution worse if nearly all objects are moving (moving in Y axis requires re-adding the object to the collection - you need method instead of writing to the data directly). Alternatively, you can keep only static objects(trees, building, etc.) in this set as it handles inserting and deleting for you, and do manual re-sorting every frame for your your moving objects(orcs, player,...) . 

I would personally discourage you from any kind of direct map-player communication there is no need for it. It is game logic responsibility to handle such interaction. Often, there is some kind of GameObject manager or component system. As for multiple players/maps, server should be resonsible for instantiating maps and moving players between them. 

To test whether a point lies inside of polygon you have some options, best known crossing number algorithm or more "stable" winding algorithm(there is pretty fast implementation too). Alternatively, you can also use some of spatial partitioning algorithms too, most notably BSP-type. While spatial partitioning will probably offer superior query performance, it will require dynamic updating structure(if rooms can be changed later) - there are dynamic variations of those algorithms, but it will be significantly harder to implement. 

Please note you might need to implement additional logic if you allow regions greater than , but I assume you need use this for more smaller regions 

because you found those node by raycasting, in order to find the shortest path the weight of edges must be naturally equal to distance(or multiple of) between those nodes and not influenced by the goal node. Dijskras algorithm does not care what the goal node is - the output of the algorithm is w-distance(weighted distance, in your case just the "distance") from one node to every other. 

...and that is all code you need. Judging from comments you originally wanted 45deg slice, and you were probably on the right track there too - just be aware it might require chcecking against both vectors and (if you think about it, point in 45 slice must be right of forward-left bound AND left of forward-right boundary). 

As other option, you could split the path into straight parts. Then you only need to find the points where your original path leave a path part (no need to compute, just switch by direction of the next part). Only what remains it is connect points of your new smooth path! 

Human readability: anyone(and you when you review your code after few months) see what will will happen without looking up the precedence Compilers can go crazy and you never know on which compiler you will compile it later. Even though compilers should do something, it does not mean they will do it. 

Profile first, judge speed after. Dijsktra runs in ~n^2, raycasting all vs all will cast n^2 rays and check up all objects in scene each, moreover contrary to the pathfinding algorithm there is quite complicated math behind it that takes time. To speed things up there is for example very popular A* algorithm, however I would not be surprised if it were actually slower than Dijkstra for input with few number of nodes(<1000?) just because it is more complicated algorithm. You can imagine(very simplified!) Dijkstra as filling the map with water from start node(that does not stop until all map is full), A* is analogy with the map tilted towards goal node. Alternatively, you can use Floyd-Warshals algorithm which runs in n^3 and computes shortest path "all vs all". This way, you can run the computation "offline" before game is loaded, effectively reducing time to ~zero. Note: because paths are pre-computated, it will not handle moving obstacles. 

It is possible and Unity documentation is very helpful in this matter. First you need a ray to raycast from mouse position, the documentation for mouse position provides an example how to get a ray from mouse position: 

At this point you are at the solution you wanted, level 50 sword can be anywhere between and swords, all of these having exactly same DPS. If you want to play with the randomness even further, you might say you dont want to have all the possibilities from above equally likely and for example want the more unbalanced versions(93-107 and 76-124) less likely so that the player would find "average" 85-115 swords more often. In that case you should also choose the distribution. As I mentioned above, you can also separate the required(displayed) level and the actual level so player can find slightly worse or slightly better swords of same level, that can be achieved in similar manner: 

same applies to all buffers. For the out of range problem I suggest you use and instead, this should avoid any of these problems completely. Summing it up: 

I dont think the question should be "How to force players" but rather, "how to make very appealing to players" to kill low level monsters. The more natural and logical way it is, the better. You could take example of the pokemon series (I personally think, its one of the best RPGs ever made). You couldnt die. You would be just moved to nearest center (that is similar). You wanted to kill low level monsters to advance your pokemons and thus allowing take down the big boss and gain badge (story goal motivation). You wanted to "catch them all" including the low level ones (collection motivation). And lastly you needed a skill to advance (cut, swim...). Those are hard limitation (unlock restriction motivation), plus you could visit previously inaccessible areas for big rewards, you can go as far as make visible big shiny swords across a obstacle. To break it down: you want to kill small ones, to kill the big one and get "key" to next area, all appearing natural and very RPG. You could hide it just as you suggested - give boss hp regen as dps check. 

If the ball didn't move on the line, its path would be a circle. You know the popular parametric equation of circle (=how you usually generate points on circle)? 

Note that provided PriorityQueue is far from optimal, but I wont go into details of proper implementation of PriorityQueue as there are dozens implementations around, and it is well-defined ADT. And usage: 

The while cycle is effectively the same like yours and feel free to replace it if you don't need to parse numbers above int.MaxValue (the remainder would be ). because you are not interested in naming numbers below 1.0E+09, providing you direct index in your posfix array. You might also consider adding some error checking. Also please note I did not check the syntax. sorry for the edits, it was not so straight-forward to implement as I thought 

I implemented color picking recently and I would like to use it as kind of highlight when mouse is over an object but I am concerned about performance. Color picking requires whole frame to be drawn, loosing effectively up to half of performance (MouseMove can happen nearly every frame). Also, when mouse moves it is very likely to be nearly above previous point - is there any way how to use this fact to improve performance of 3D picking? Or is my best chance to use some other technique of 3D picking or approximation of results? tl;dr If I wanted to do "realtime" 3D picking - on MouseMove, what is the best technique for doing so performance-wise? 

To enable/disable script, just change the on parent to true/false. This turns off its logic - it does not, however, completely remove the script form the object - the script will remain on the object but will do nothing. If you need to turn off multiple different scripts separately, just change the flag to List of Type and in the scripts method check if the parent list .