Basic problems with input Your code will blow up if there are fewer than two fractions in the input. Even @janos's solution (which can cope with only one fraction) fails if there are no fractions in the input. Is that reasonable, especially given that the sum of no numbers at all is 0? Your code also fails on any badly formatted input but there's enough else to talk about to leave that for another day. Style apply method It's common practice in Scala, with types like your , to add an method to dispense with the need for . It can be added directly to the class or in a companion object. 

Using old-style c-loops always opens a possibility of a stupid error. Since you can cache the last value you inserted in the array, you don't have to use the old-style loop. My loop also has just one check, and that check is cheaper to do than yours (or 200_success's) because it doesn't need to do the array look-up. Note that my solution inserts the first value without checking, while yours does this for the final one. Not only is this more logical (I think), it eliminated a check from the logic. Your method is called eliminateDuplicates but it will only do that if the list has already been sorted. If that was not done, it will only eleminiate sequential duplicates. That is, it will turn (3, 1, 2, 3, 3, 4, 3) into (3,1,2,3,4,3). Is that what you want? The fact that you always keep the last member implies this, but how can we be sure? If it is so, either document the intent or maybe name the function more clearly (e.g. eliminateAdjacentDuplicates). If you want to eliminate all duplicates, then you could start by sorting the array. But since you are using the collections api, why not use a set? 

Hardcoded values They are usually a bad idea (what happens if, per example, you use this value somewhere else, and decide to change it someday?): 

I am running a simple OCaml program which opens a CSV file with a pseudo dict-reader and hashes "key" + "value" (where key and values are strings). Then some counts are evaluated on the hashes (but it is not really relevant for what follows). After a quick look at the default OCaml profiler (), I noticed that my program was mostly spending time in hashing elements (I don't know what does though). 

Comments I don't really see the point in on top of your methods. You can just type which automatically propose a neat documentation, per example, in the MatrixCreate function : 

In order to have a "unified" (I realize how ambitious this actually is) syntax when working on dataframes, I wrote the following functions that is a general purpose dataframe set of tools in R. 

So that is how to use folds and iterators to process collections efficiently, traversing them as few times as possible. And how to do that without mutable state. Note: I did it entirely with immutable state to show it can be done. However, using one mutable variable inside a function, where nothing else can see it, is not a functional sin. Updating immutable maps (that is, returning a new copy* can be just as fast as using a mutable map, depending on the usage pattern. Really, you should test both options with a range of inputs to compare. The (slightly) mutable version can be done simply by using a mutable map and the update method - very small change to the code. 

You have no way of knowing whether any html you generate with one call to gsub is violating the constraints of the HTML containing it. After the first gsub call, you iteratively apply it to text which now contains some html. You may mistakenly replace parts of an html element with an html element. 

Function naming and are kind of misguiding, I would expect that , but this is not the case as each function treats the diagonal in a different manner. In order to improve readability, I would write a method and a 

I don't really like the methods which forces the user to call it every time before calling . Besides, the algorithm is very basic... Are there libraries doing this already ? Is there another algorithm, simple to implement (performance is not really an issue, this was working with roughly 1000000 elements) My tests are really poor as well, are there better guidelines to write them ? 

This is a simple implementation of a generic binary tree that holds elements of type T. I was wondering if there was something that could be done better (especially in the EnumerateNodes methods). 

Note : I am using OCaml 4.02, but I could upgrade it to 4.03, especially for the Array.map2 methods. 

This should show how much pattern matching simplifies a recursive procedure. Each match defines one of the possible states and the appropriate action. Because I used pattern matching in this way 

creates a pattern which is even more useful than because it only matches properly formatted lines with genuine numbers in them. Optionally, 

You deal with this by carrying all of your state forwards, making your code more complex and hard to read than it needs. All you need is a nice functional way to return 3 states and your code can become much simpler. You must have been introduced to the Option monad by now. All you need to do is have your helper function (which should be hidden inside your hasSublist function, by the way) return Option[Boolean]. Now you can return 3 states: 

then you should have two different classes to represent them. The first type should not have a car field at all. The second should not be creatable without being passed a non-null car object. Depending on the rest of your code, the second class could be a subclass of the first (with the addition of a car field amongst other things) or share an interface with the first (preferred option of those two) or the request could be an entirely separate class, replaced with a car-containing rectification by a factory. Either way, only need specify the second type as input. And immediately a whole category of errors is eliminated. There is no need to check for the existence of a car when it is guaranteed to be present. If you do it this way, you never have to check for the presence of a real car. Any method that depends on the existence of a car simply has to specify the car-owning type. I would not be surprised if other stages in the lifecycle of rectifications can be treated this way. If you create a common rectification interface but 

I wrote a simple online logistic regression, calibrated using gradient descent to compare the speed of an OCaml implementation vs the same Python script, executed with Pypy. It turned out that the OCaml implementation was slightly faster than the one run with Pypy (by about 10%). Now I would like to optimize my code even further. The assumption about the data is that the values of each rows are sparse (can be considered as factors), they are encoded as integers (collisions are allowed) and stored in a large array. maths.ml 

Another option would be to have a or value in your class. Multiple accesses inside the same loop Here you have to access every time in the second loop. This harms performance and makes this second loop unclear. 

I want to plot (on the complex plane, with ) the power series whose general term is the number of partitions of an integer. The more points I want (and the larger the degree is), the longer the plot takes. I first wrote a naive version, added memoization of the sequence, changed the naive evaluation of the polynomial with the Horner algorithm. All these modifications led to speed ups, and I want to know if there are more optimizations I could do. 

Be lazy (use views, iterators or streams) Don't keep a reference to any of the intermediate transformations. 

As long as the target number is near the top of the range (which of course it will be), working backwards like this will involve much fewer operations, which makes this cheaper even with the higher cost of modulo division. Here's a simple attempt: 

A simple way to provide better error reporting is to turn the partial functions into complete functions, raising errors when no match is made. So the regex version of the first transformation could become 

In the companion object. In this case, functions should use pattern matching to decide what is the appropriate option for the particular case class. Abstract methods defined in the abstract class (where appropriate) and concrete implementations in the case classes. 

Filtering out the diagonals threatened by this queen is a hell of a lot simpler than your . Note that it also contains an infinite list of numbers (1 to infinity) but laziness means it doesn't crash. I'll save comments on idiom/style in your code for a separate answer. This answer is to explain why the whole approach is not Haskellish. Laziness for the win.