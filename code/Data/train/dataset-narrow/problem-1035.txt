Metaprogramming is all about convention. If everybody doesn't agree on convention, everybody's metaprograms may as well be written in different languages. The most core convention is that the "return" of a metafunction lives in a type named . But a fairly common one is that when you need a "metafunctor", you pass something like this. The advantage of something like this is that it's always easy to create a type, but usually not so easy to create a template template (which would be the alternative). Specifically here, we need: 

You don't provide a copy constructor, so the default just is a simple copy of all your raw pointers. Which will then get d twice! Also, what if you never called ? Now you're leaking memory. I don't know if should be copyable or not - but right now it is and that's broken. So at the very least, we can easily fix it by using a smart pointer: 

In other words, this methodology is good for idempotent, non-mandatory tasks such as "clean up the temp directory" or "remove any unused profile images from the file system" 

Or for the totally and absolute 1337 (meaning you shouldn't do it for something this simple but it demonstrates some useful techniques) 

A direct answer to your question: Just remember what dropdown controls have been initialized and hide those. 

you have non-unique ids! This is against spec and you will find that many tools and libraries have problems when using non-unique ids. Instead you should use 

Javascript Javascript naming convention are to use with no underscores. It's not a big deal but it's pretty standard. The only exception is to use for variables that are intended to be used with the keyword (which you don't have here). To a lesser extent than php, but with the javascript community where it is, its probably time to start considering choosing a javascript framework (like angular, backbone, knockout, or the like rather than using jquery directly. In my opinion you are over-specifying your selectors, no need to do when id is already specified as unique, no need to when holds no semantic nor structural meaning. Consider that all this stuff is indexed in the browser so by adding more selectors you might actually be slowing things down however slightly. You don't need to use to select, you can just say Your scope management looks pretty good, I'm happy to see you using - another syntax which achieves the same purpose and you might find flows better (or not) is . You've got inline styling and html. Why? Just put the element on your html page and show or hide it from javascript. Finally, just about everything you're doing in js is handled in a very elegant manner by the jquery.form plugin. Just use that. 

You are outputting each character one at a time. That's fine, but you could instead use the function: 

Now, if you want to add a new attribute, you need to add one line of code. Just another . That's tough to beat! 

Note the reference! alpha You pass in an array but there's really no need for such a thing. Instead you should prefer to take some sort of weight class that is callable with two letters and returns the weight: 

Missing Deletes In and , you're not ing the node in case of size one. Supporting \$O(n)\$ operations You currently have member functions for a few expensive operations: and . This may suggest to users that these operations aren't expensive. Note that for instance does not provide for this reason. I would suggest that somebody using a singly-linked list should not be using indexing anyway, so I would omit it. If you do add it, you should have a overload as well. Performance One thing to point out here. In a lot of places, you implement a lot of member functions in terms of other member functions (e.g. uses , and uses ). This is great for writing, but could be better for performance since you don't need to do lots of checking in these cases. can simply loop over each node calling , then setting everything to . Assign can similarly do a bunch of s back-to-back-to-back without the need for a branch. Whether or not these are worth optimizing is up to you. 

This is honestly pretty good. I usually use to set the paths and configurations on require (it's going to grow a lot as you add things like shims, urlArgs, etc). You will also probably want to reuse it in several places. See my blog article on how I recommend doing this. The general idea is that you don't use to bootstrap things, you instead have a request for the configuration file and another to actually bootstrap the specific page of your application. Next, I'll ask why bother injecting and manually into ? Injecting dependencies is what RequireJs already does. app.js 

where your clicker span gets a class of and your gets the class of . You could just use directly, but I find to be somewhat more descriptive. 

You move it into , but then you copy it into the constructor anyway! Make sure you delay construction as far as possible. should just take whatever: 

Note that is not a good name. Prefer more descriptive names. Division All of your numbers are s. Which means that when you divide, you're going to end up with as soon as you have any number that isn't . That isn't particularly interesting, so I'd suggest using floating point numbers instead. 

Your code does not at all resemble that algorithm. I do not know what your variable is. In the algorithm, the heuristic is a lower-bound estimate for the remaining cost. It is a per-path estimate, which for 2D grid we would just use Manhattan distance (or straight-line distance if diagonal steps are allowed - I cannot tell). It is not a algorithm-level variable. Ultimately, you have a (named ??) that you are doing something with every element on every iteration. That's really not how the algorithm works. Neighbors You have four huge blocks of code that all do the same thing, just with different neighbors. Just write a function that given a point returns its neighbors: 

While this is the simplest and is certainly acceptable architecture it is always a good idea to also consider Composition over Inheritance So instead you might do something like 

I'm getting more and more into programming js in a functional manner which makes heavy use of multiple returns via tuples (especially useful with recursion). Also, a pattern that I use often is creating simple temporary values for projections 

Since this is a public method I added some checks and downcast List to IEnumerable, which is a looser contract and all you really need here. By the way, .Net naming conventions are pascalCase for private and local variables CamelCase for public and protected. It's rare to use underscores. 

That is much more natural. You can also drop the overload. If you don't want to go the proxy route, you can still imply this: 

You can sprinkle in your prime count and sum in there as appropriate, this is just the general idea. This runs about 10x faster than checking divisibility for each prime. 

Why are you using the specific word format as a signal for something? Also, all the words in end in a hyphen so you always go into this block. 

But two of our cases for compare ( and ) know their own sizes. Why would we drop this information? Instead, use the case that doesn't know to simply forward to one that does: 

This is of course fairly advanced coding but it is possible and probably only about 10 lines of code. Like I said you can look at Automapper for some of this functionality out of the box (though I don't know how well it would do with windows/web forms). I will say that what you're looking for is similar to the functionality provided by the MVVM pattern so if you're doing windows forms you can look at Truss. If you're doing web forms...well I wouldn't do web forms, this functionality is already in ASP MVC and silverlight which are both like a million times easier to work with but I remember there being some buzz about the ASP MVP project that would help with those issues. 

Sequence should generate the sequence . That will make it much more useful. Otherwise, you will end up calling a lot. Also, you should provide an alias template from , so that you can simply write: 

Separate Your Concerns The function at the moment does two things: finds matching customers and checks that it's nonempty. Let's instead add a default checker: 

Never use There are times where you have a compelling reason to use . This really isn't one of them. Either make your function recursive, since it is in all but name. Or rewrite it to be iterative. Both of those would be preferred solutions. The reason I say this is because your logic is sort of logic a binary search, except the two different changes in range occur in different places and use different mechanisms. This makes it difficult to understand and, I imagine, debug. A Better Algorithm Add a helper function that will count the number of elements in your given range, breaking out early if you hit the amount you're going for: 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

It's not really a problem, and I like to gently prod newcomers into learning features like lambdas. That being said, I don't think that your url duplication int the first case is anti-dry, its a perfectly acceptable method extraction and it's private. Within the scope of private methods you can do pretty much whatever you like and it's not going to offend anyone too much. Another possibility that you might consider (though it would be a greater scope) would be to extension method the url so you can do url.ConfigureUriVariable("foo", "bar"). The above would be a bit clearer if instead of a string you used a dedicated Url class. I recommend the built in Uri or make your own. But really, I think you're all good. BTW - the lambda is still compiled to a delegate so the generated CL is pretty similar using either of your techniques.