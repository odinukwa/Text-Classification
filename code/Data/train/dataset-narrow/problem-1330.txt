Assuming you're protecting yourself from SQL Injection and the like, there are just a couple things that stand out to me: 

Also, I would add that some very notable programmers have emphasized the rule of a single assertion per unit test. As such, give some thought to this as well. Lastly, I would recommend being a bit more descriptive than object0, filename1, etc. Try to give more meaning to the variables. It'll help immensely in 6 months when you look back at your code and sit there wondering what the purpose of this or that was. 

In your setUp() method, you call several other tests to prepare future tests. With unit testing, you want to keep the tests separate. In your code, if testNewObject2() fails, testGetSuffix1() will also fail, even though it is unrelated. To reduce code duplication, use private methods for specific needs. Maybe something like this: 

With some meta-programming you can add a method to the InputStream class that would allow you to move a line ahead of another using concise code like this: 

If you were dealing with two properties that were in the then you'd probably be able to use a derived property. But since one of the properties in an association, a derived property won't work. Instead, you can do this: 

The meta-programming You can start with a Groovy Category that adds the method Writable moveLine(Object, Object) to a class, such as an InputStream. 

After loading the parameters into a Map, a Range is created from the start and end values. The added method calculates the fizz buzz and returns them in a list. The method is used to iterate through the fizz buzz list and write it to the output sheet. Finally, the output is saved through the added (and overloaded) method . 

Depending on the size of the application, it may make sense to take this one step further and take advantage of object-oriented programming. 

Coming from a language without the ?? operator, I find this even easier to quickly read and understand the intent of however I recognize that is probably just because I'm not used to reading ??. 

Part of the goal for using the Repository pattern is to separate the storage from the domain. By passing the IDataReader in to a Foo object, I feel like the domain gains too much knowledge of the underlying storage mechanism. So, between the options listed, I prefer setting the object's properties in the Repository. That being said, if the object doesn't make sense without a certain property, it should still demand it during its creation. However, even in this case, the Repository would still be responsible for setting all the properties requested. 

How it works It's actually quite simple. The method signatures are gathered from the class's MetaClass. Then some hefty formatting is applied to write the method signatures correctly. Also, final methods are excluded. Example 

In addition, since in the JVM is immutable, concatenation can create temporary objects which the JVM must then dispose of. It's typically better to use . Testability To make the code testable, meaning that it can be executed via a method call and the output can be validated, I placed most of the code into the method. As a consequence, I converted the closure into a method. I know the challenge states If a map is invalid, STDOUT 'Invalid map.' (That includes if the map is unsolvable). However, I disagree with using the same error message for multiple problems. That's one reason I replaced these messages with insightful exceptions. The other reason is to keep the Groovy Console from exiting. 

For example, could this variable be renamed to make it self-descriptive? Perhaps . Perhaps something else that would eliminate the need for the comment. One File Per Class Generally speaking, you want one file per class. I also believe it is common practice for C/C++ programs to have one file for the header and one for the code for that header. Maybe something like and , as well as your . Scope Why are your Tpacket_list variables protected? Is there a reason they aren't private? Also, list_head is declared in main, then freely accessed as a global variable within the Tpacket_list class. Rather than do this, it is considered better practice to use Dependency Injection. Pass this variable in to the class that requires access to it. It will make your code far easier to maintain later. It will also open up the possibility of unit testing your class. Random Thoughts 

Since , , and are public, you can just pass the to the instead. Also, has so much functionality that it might as well be a class rather than an enum. In fact, it would be even better if it's an interface: 

In order to resolve the client with a GORM/Hibernate query you basically need to persist the resolved client value. Based on your method I'm assuming your domain class model goes something like this: 

How it works The method iterates through the and calls a closure with an object to aggregate with and the current item in the list. Iteration begins with an empty as the aggregated object, which remains empty unless the un-matching countries are found. When a mismatch occurs, it is recorded in the . The closure purposely returns the because the output of the closure is what's fed back in during the next iteration. Finally, if the resulting is empty, then all of the countries are the same. Otherwise, the contains one or two keys indicating what the problem was. If all you really need to know is whether all the countries matched or not, you can simply use : 

First off, as a disclaimer, I don't code in C/C++, so I may critique some common practices that are considered acceptable as it's the norm. Nevertheless, a few things stand out. Comments Comments should be used to describe why something is being done. The code itself should be self-descriptive as to what it is doing. 

Regarding documentation, I have found Eclipse and other tools to utilize the following style of doc-blocks. The @return is especially useful for code-completion of methods available on the returning object in my IDE. Documentation tools tend to have built-in support for other tags like @author as well. 

All in all, it looks like you're off to a great start. I'm going to skip around a bit in what I recommend however there are definitely a few things that could be cleaned up. 

The new property , which is maintained by the and methods, takes care of saving the current resolved client to the GORM store (database). With that value persisted you can use it in GORM queries: 

This has the additional benefit of not having side-effects. Another improvement is to change the location s to s so that instead of you can do . This improves readability. To build the path , I think using is better suited than because it helps clarify the code's intent. can be used on the output of , but that would have been more trouble than it's worth due to the need to keep multiple things in context (accumulator). So I used instead. 

If you're interested in creating some Groovy mixins, you can make your Fizz Buzz program quite simple, while getting some reusable Excel functionality out of it. The Fizz Buzz Program Here's the business logic of the Fizz Buzz program: