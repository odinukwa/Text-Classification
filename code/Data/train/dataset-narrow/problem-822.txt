Idiomacy Idiomatic c# expects PascalCase class names and public members. Member names should be a description of their function. Consider , , , etc. OOP Dependency Inversion Your constructor is hard-coding the values needed for your connectionString. If this is simply demo code, either hardcode the entire string or do it right and have the values passed in. Scope 

I would join both and in recommending to guard your implementation and throw an appropriate error as well as exposing an external status check method such as or . Also I agree the card should be popped from the end of the list when using an as the backing collection. Finally, you have a very well formed class with clear and concise public members. Be sure to add just enough javadoc comments to allow a the class to be consumed without needing to open the code. 

To answer the question which was asked, no. The best method of document protection will be found in a technology designed with document protection in mind. HTML is not that technology. As others have pointed out, there are plenty of methods for copying the text both by disabling or modifying browser features such as javascript, as well as just requesting the document directly. There are, however, technologies available to protect documents. While nothing is foolproof, using something like an encrypted PDF document with the appropriate permissions set will likely be the "next best thing" that can be done in a digital form. 

I would recommend an interface with read-only properties (getters, no setters) and have your final class implement that interface and return its constant values. I'm also not a fan of your Log class. 

You've created a tuple of parameter values equal in length to the number of parameters specified in your query. 

Your code is well formatted and easy to read. Congratulations. With regards to SRP, I believe your code complies just fine. Each dependency: the cart, rentals, and loyalty points is retrieved with a single call. The mapping for those DTO are isolated in a small single purpose anonymous method. The single responsibility for the method matches its name . If your uncomfortable with the idea of anonymous methods being separate from the method where they are defined, consider creating private static named methods in this method's class and referencing them. The only SRP violation I'm concerned with is the invoice DTO. I would recommend using the raw cart id and letting your presentation code format the title. Here's an example of how I may clean it up: 

I will comment on the JavaScript only. Each of your change handlers are doing essentially the same thing: check if the field is null, a single space, or the empty string and add a message to a notification panel. The textbox text attribute will not return a null -- only empty string. I assume in checking for a single space you are invalidating whitespace values. As written however, a double space (" ") would validate. I'm not familiar with the YUI library, but given its prevalence would be quite surprised if it did not contain dim sort of utility method. The same notification area appears to be updated each time, but is looked up each time. Only the message is different. I would suggest the following factory method: 

First let me say up front that this code looks quite good compared to a lot of code I've been asked to maintain, so you have nothing to be ashamed of here. I'll make a few more suggestions beyond the ones wattson12 offered, but you should view these as ways to make your good code incrementally better. viewDidLoad First, a technical point. You should be aware that this code may not work the way you expect, especially if it needs to run on iOS 5. It's a common mistake to assume that viewDidLoad will only get called once. In fact, viewDidLoad can get called many times in the life of a view controller. If the view controller receives a memory warning when its view isn't visible, the default behavior up until iOS 6 was to unload its view hierarchy and set self.view to nil. The next time self.view gets accessed after that, it gets lazy-loaded from the NIB again, and viewDidLoad gets called again. This can lead to some tricky bugs if your code isn't designed to handle it. For example, your implementation of viewDidLoad re-adds your notification handlers. This will cause them to get called twice when their notifications are posted. Since iOS 6 the risk is greatly reduced because self.view isn't set to nil by default in response to memory warnings, but you may decide to do so manually at some point as an optimization, so I'd still consider designing your viewDidLoad to leave your object in a valid state if it gets called multiple times. If nothing else, you should be prepared to explain to an old-school iOS developer in an interview why your code should be safe in iOS 6. Review Resource Management in View Controllers in the View Controller Programming Guide. Now then, on to code smells. Comments The main code smell that jumps out at me here is, believe it or not, the comments. Whenever you feel the urge to add a comment, you should stop and ask yourself a couple of questions: 

Note that the method names are expressive enough that the comments are now redundant, so I can remove them: 

It doesn't matter if you adopt my convention, but choose some convention and apply it with discipline. A couple more random suggestions: 

It's already much easier to tell at a glance what this method is doing, but I'd personally continue refactoring to this: 

It's almost always possible to refactor your code into a form that documents itself expressively enough that your comments add no value and can therefore be removed. When you're done, your methods will almost read like pseudocode. BTW, you'll notice your classes filling up with lots of little private methods. Don't fret. That's generally preferable to a handful of large methods, but if all the little private methods start to feel overwhelming, that's a code smell of its own. It suggests that some of your methods may belong on other classes. Move each method its most appropriate class. Don't be afraid to invent new classes, but also consider using Objective-C categories as convenient home for your stateless methods. #pragma mark My next suggestion is to come up with some convention for your #pragma mark statements, and then apply it with consistency and discipline. It really helps to know exactly where to put each method, and where you can go to find it later. My personal convention is to put "Constructors" at the top and "Private" methods at the bottom for quick access. Above my private methods I have special sections for "Notification handlers", "Actions", "Dynamic properties", and "Public". Then above those I put all my protocol implementations and overridden methods in sections named after the place they were originally declared. So I would organize your file like this: 

This allows us to short-circuit the assignment of a value such as a name. Let's remove some of that duplicate code, and make a few more names clearer. 

A common quiz question is to check if a string is a palindrome without using in-built reverse functions. In Java, this can be done as follows: 

Your and variables are very bad design. Hoisting allows the variable to be in scope through es3 (to my recollection), but you should never try to take advantage of that. These functions should be rewritten to take the object they are operating on as a parameter. Additionally, unless there should be some third undefined state, the opposite of should be , not a different detection method. is a poor description for the method as well. Consider something describing what it does like . Consider the following: 

TheJSON schema and data class attributes are unlikely to change. Consider implementing the class to encapsulate the JSON hash, adapting it to the ruby idioms and whatever other custom operations you've added. This should greatly decrease the cost and complexity of deserialization. 

That still leaves a lot of duplicate code. We will want to clean that up. Finally The truthy nature of javascript allows us to do this as well: 

Something @mjolka corrected but didn't comment on was the unused parameters in your method signature. If method parameters are not used, don't add them. This is an example of the YAGNI principle. If you later implement the functionality you anticipate using the parameters for, you have locked yourself into an implementation which may not fit your future needs. You also risk breaking consumers expecting the current behavior. If unused parameters are needed to satisfy an interface definition, seriously consider if your object fits the intent of the interface. This is commonly considered design by contract. Otherwise, implement the method to satisfy the interface contract. As a last resort, document the discrepancy in XmlDoc comments if the the object satisfies the intent of the interface and a proper implementation is not reasonable. In your example, should be implemented. A consumer relying on proper behavior could have disastrous consequences. There doesn't seem to be any reasonable custom logic possible in this implementation -- indicate is ignored if it can't be removed entirely. 

I've created the following implementation of a trie in F# as an effort to learn the language. I would like to know what could be done to make it more idiomatic. Any other pointers are welcome as well. Of particular interest are: 

This can be further modified to support your use case: checking if removing a single character will make the string a palindrome. Instead of failing when a character doesn't mirror the opposite position in the string, look ahead and behind to see if the next character will match. If so, increment a counter and continue. If the counter is equal to the number of occurrences expected (1) then the result is true. 

Now that we can see that we're looping over all the rows for each , we can change to traversing once and pick up any along the way. This effectively flips the order of iteration (I'm assuming there's more rows than query strings). To get rid of the nested loops altogether, we'll switch to using to find any matches. We'll also drop the check on each iteration for a single call at the end. That should keep us from iterating multiple times. 

I'd advise that if you're looking for 100% compatibility with here, you'll probably want some extensive unit tests. Here's what I came up with that handles the edge-cases I threw at it, but I don't expect it's bullet proof either. Main changes are using the format specifier, and using to get the number of digits before the decimal place instead of . 

Customer and Item classes Well, to start with, isn't used and I don't see how it could ever be. So that should just go away. Your naming style is off for C#; you should be using PascalCase instead of camelCase for public methods (eg., AddItem). and don't add much value; they're OK as-is, and are actually a reasonable encapsulation - but they're kind of overkill here. (as an aside, your class doesn't include , but I inferred it from your ). This comment could really be directed to the whole structure, actually - since you really just need a to solve the problem. Not to say the structure can't be useful, but I would consider it overkill unless there's some future plans being made here. Program class Your class sets a private member, but never uses it outside of ; it's odd to have a class instantiate itself like this. In this case, you can just use the as a local. will take an object and call on it for you; no reason to use the format overload. 

Well, the calculator one at least could be simplified since you're always adding/subtracting the same: 

I think a plugin architecture would be a little overkill unless you're interested in versioning or deploying the sub-modules separately. You haven't shown the sub-modules (the actual solvers) but I'd probably define an interface for them and then use a instead of the statement. Really, it's pretty minor, but I see a couple of advantages of the : 

Ok - now we've got most of the pieces, we just need to put the actual program logic together. Let's move on to the method: 

That's not going to do a whole lot for performance (basically get rid of a rows iteration), but everything else I see is really context specific that may end up with worse performance assuming your data looks like I expect it does (< 10 , < 50 and thousands of rows). A couple of additional thoughts you can try, though, depending on your data: