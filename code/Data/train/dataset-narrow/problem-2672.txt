There is a big problem for the P2P: the NAT curse. Peer to peer is difficult because a lot of client are connected through NAT. If you are interested in lan play, broadcasting may be a solution (do not try to cheat by Faking a LAN throught a VPN...) A good alternative may be linjingle: a library developed by google to allow audio/video in XMPP sessions (you may know XMPP as Jabber Istant Messaging). In this case you have to setup a Jabber server and extend it to provide gaming functionalities, then write the client using jingle to allow them to exchange their data. 

you can multiply Δx by the velocity unit direction to get the actual displacement and add it to the initial position to get the position after t ms. Take into account that V reaches 0 when At = V i.e. after V/A milliseconds; if t > V/A then Δx remains to its final value: 

The term AI is misused here. Well you need no AI. Hey i don't want to be rude! This is just an optimization problem that generally can be solved using greedy strategy. Alas, greedy solution means boring game: as the player gains experience he will adopt the same optimum greedy solution and your game becomes simply an advanced tic-tac-toe. But don't worry! Let's talk about your problem and the possible strategies. Here the (greedy) solution is to build as much strong-superpower-invincible-lastlevel unit as possible, because this kind of units overwhelm the others in term of power. Normally those units are slow to build so your base is left undefended until they are ready so your opponent can build a single demolition-unit and "the white wins in a move". Then you start to think to build some "lower-level-but-faster-to-build" units before start to build the "final-weapon". This is still a greedy solution: you simply put a "defence" parameter in the objective function to minimize. In general you should model your objective function leaving room for such parameters and let the computer to choose among a pre-fixed set of parameters or to choose randomly. This gives to your otherwise booring optimum finder algoritm, a sort of character, a personality. Once those parameters are choosed you should simply apply your favorite optimization algorithm. 

If your framework does not support the quadratic easing you can emulate it using a cubic bezier transition with the following control points: P0 = (0,0); P1 = (0.33,0.66) P2 = (0.66,1) P3= (1,1) (generally p0 and p3 are implied) 

In between states are still states, more in general transient states should be modelled as states if their duration exeedes the frame duration; otherwise one should consider if appropriate on a case by case basis. 

Doing so you decouple things and factor common behaviours without explore each possibility in a single deep tree of nested ifs and fors. Comments are appreciated 

One of theese items has a rope that trigger a contraption that in turn fires a flame burning the bush... (you see, I can read your mind so I know the stuffs you like). You can use a script to describe this bush instead of a config file putting the relevant extra code in a hook you execute from your main program each time someone picks an item from a container. Now you have a lot of architecture choices: you can define behavioral tools as base classes using your code language or the scripting language (things such containers, door-like and so on). The purpose of theese things is to let you to describe the entities easely aggregating simple behaviours and configuring them using bindings on a scripting language. All the entities should be accessible to the script: you may associate an identifier to each entity and put them in a container that is exported in the extend of the scripting language script. Using scripting strategies let you to keep your configuration simple (no things like that you will use just once) while letting you to express odd beaviours(the fun ones) adding some line of code In few words: scripts as config file that can run code. 

The data that come from the analysis oft the spectral energy variation are enough to generate this kind of maps. Here the problem may be if there are too much data to process: not what kind of data are used, but how. After seeing some videos, I'm starting to believe that the data are moved further in the feature-domain (time-domain -> frequency-domain -> feature-domain). The software generates data by using the spectral energy changes and try to recognise known features, then it use the information about the features to setup the map. Recognition can be done by clusterization, maximum likelihood, neural networks, Genetic algorithm and so on. After completing the recognition, you have infomations like: where the feature if found in time and frequency, what type of featuature is found, the velocity the feature vector is moving and so on; you can use these data to feed a map generation algorimth, leaving room for improvements like making better recognition algorithms, recognize more family of features, extract more data, find new ways to "render" these data and so on. 

If I understood right, you need a "raster" background image to display and a gemetric shape that describes that background's silhouette for physical simulations issues. Looking at your example image I can see a bezier profile so you may store the parameters you used to generate it, along with your image; is up to you to store the rasterized version or use the bezier parameters to generate the displaying image (cpu vs storage trade-off). The interesting case comes if your background shape does not come from a bezier curve or from an equivalent parametrization: and hand-made artwork for example. I such cases you may find this paper useful. Here is shown how to get a bezier parametrization from an hand-drawn sketch. They basically illustrate the process with the following steps: 1 - apply a logarithmic transformation to make it easier to extract the edge. 2 - erosion - dilatation is used to smoth the image 3 - laplacian is applied to find out the edges once they get the edges, as set of points laying on the shape edge, they start to construct a set of (bezier) curves each of which produces a better edge approximation. 4 - the set of edge points are grouped and for each group a regression line segment is computed 5 - using the intersection of the line segments in the step 4 a set of bezier 2nd grade curves are computed 6 - a method to generate 5th degree Bezier Curve is given: the curve is derived from that obtained in the previous step by letting the derivate and curvature discontinuities be smoothed. All these steps are obviously computationally relevant and are not intended to be done at runtime. This should not be a problem since you do not do dynamic backgrounds, if you do so you should have some parametrization and the problem solved in (moved to) an earlier phase of the project. 

If you simply need to do an Object.onSomething() probably you need to write a reactor over a object data model. What I mean? Put every relevant objects into a container make this container available to everyone. This container will implement the method 

As you can see what is inside one of the two circles cant be reached directly. A body of mass m that is steering over a curve with radius of curvature r, experiences a radial apparent Centrifugal force caused by the inertial behavior of the body, equal to: 

As you can see there is a relatively intuitive way to map x,y rectangular coordinate system to the hexagonal one. We may talk about "rect" irregular hexagons ie hexagons inscribed in ellipses or hexagons obtained from regular hexagons scaled in both directions disproportionately (no rotations-shearings). A rect hexagon can be defined by the height and width of the circumscribing rectangle plus the width of the inscribing one. (W,w,h) 

The problem with the physic simulations lays on the integration step to solve equation of motion. What you should do is simply to set an error in integration you can accept (ε) then look to your integration algorithm to see for what step size it gives you that error (ε(Δt)); let say that this error is Tmin. Now if your elapsed time is less than Tmin a simple step may suffice; if is greater you have to split it in n substeps where each substep is less than Tmin (n = floor(elapsed / tmin); substep = elapsed / n). Now everything is related to your ε: greather ε means more integration error but less iterations; little ε assures you both a better precision and more iterations. Please keep in mind that integration errors sums up so your motion trajectory will diverge from the real one (more if the system is badly conditioned). 

Let's complicate your spiral: be in your case f(t) := t, in mine f(t) := 1 (so i pay back my complications with simplifications :) If you want to go at a certain speed in this degenerate spiral (a circle) you have to know how long is your spiral in a round so you can say how much rounds per second do to be sure that your point travels with the desired speed. Now we know that each complete round in a circle is 2·π·r long: 2·π·1 in our case; if ω is the revolution speed (in rounds per seconds) the speed V will be V = 2·π·1·ω or in a more general way: 

Even if you aren't a seasoned developer, I feel I can suggest you to think about HTML5-NodeJS-NOSQL(mongodb or couchdb) triptych. I told you this because the era of centralized server side computing is slowly fading in favour of a different way to think in a scalable way. Today a simple multiplayer game can be done in a single html page that does not refresh but its state is updated using async communications and DOM changes; libraries such as Socket.io would let you to push events into your clients when other clients perform some action in a Near-realtime fashion. This is the architecture that I would use right now if I were asked to do such a thing: Client Modelling the game internals using Backbone.js: This library implements the famous Model View Controller pattern, so Models are objects that hold the status of your game parts and are able to send Events when they changes. Using some library such as Crafty.js or similary to provide some higher level of abstraction over common task related to game development. Server Developing server that is a thin wrapper over a Document Based Database. It basically serves the static pages that contain the client-side logic; orchestrates the communication with clients (see later); compiles documents containing chunks of information related to state that is needed to be persistent and saves them into a Document Based Database. Client/Server communications The clients send async messages using Socket.io when they needs to notify the server about their internal state updates; they ask for resources asynchronously (images, animations, sound, interface chunks ect). You can write controllers that observe the state of models(by registering callbacks on model events) and react by sending messages to the server when needed. Conversely models can register callback to socket.io incoming messages so that they will simply update its state accordingly to the content of the received message. When the server receives Socket.io messages from a client and send it back to other clients in order to update their state if this is needed; when persistence is needed the information can be saved in JSON document to save into a couchdb database (for example). For example, if you want to save the state of the player, the server can simply update de player status json document on the databse and retrive it when the player logs back in. If tomorrow you want to add some features to your player profile - i.e. add information to store within its database record - you do not need to alter tables as you did in relational database, but simply store new information in the updated document; old version of your software may simply ignore the new infos while other can take advatage from them. Obviously the server has to validate the communications since the game logic resides into the client. In this architecture, the messages are the outcome of the game progession as computed into the clients, so the server need to check and certificate the validity of a message before send the conseguent messages to related client. 

"Typically" is a quite subjective word, in my experience there are different way to describe a plane in a 3D space that are more common because of the properties that such constructions show. About your question, there is away to use 4 real values to determine a plane in a 3D space. As you pointed out, a,b,c may be the components of a vector that is perpendicular to the desired plane. If N =(a,b,c) is our perpendicular vector, you may find a point in your plane that is P = d N for some d real and positive. Here you say that d is the distance from the origin in term of N; if N is a unit vector, then d is the distance between the origin and your plane in the way that the term "distance" is commonly meant. Surprisingly you can define any possible oriented plane bacause you can use a negative values of d; doing so you loose the direct meaning of d as distance until you put it in an absolute value (|d|).