I would go with vertical layout if you are using any sort of bird's eye perspective, as in the image above. Why? Because all walls will be visible. If you use horizontal layout, and you have walls that run along the vertical lines, you will not be able to make out details on them very well (such as doors or gates). Furthermore, if you are using the aforementioned perspective type, your hexes will look a lot better, because you will probably have to squash them half way. If you squash a horizontal hex halfway, it has very low slope on its points (roughly 1/8) vs a 1/2 slope for a squashed vertical hex. In other words, if you are simulating bird's eye perspective and/or using pixel art, vertical tiles will give you a better look. 

Personally I am a big fan of jMonkey Engine.Its a shader based & geared toward high end games productions. jGame & Slick2D are very good for 2d games. ligGDX might interest you. All of these are under very active development. There is no problem in choosing 3d engines for making 2d games. Just ignore that extra D, unless you have some serious issues with that one. So, I whole heartily suggest you to start with jMonkey Engine, cause its fun, easy to use, has a very active community and comes with an awesome jMonkey Platform which is build on top of Netbeans platform, where every update & features is just one click away. You might end up in using it with many other projects. There are other libraries too, but they lack community/development activity. 

First, rivers and roads are very different. Roads tend to follow isolines (same/similar elevation) - the reason being it is much easier to travel on roads that don't rise or fall much. Rivers, on the other hand, travel perpendicular to isolines/isoclines (downhill). Rivers form in basins (collections of mountains that all flow downwards to a given valley) and tend to form tree-like structures. Additionally, roads often travel perpendicular to rivers, in order to form logical bridges. Best idea is to first generate rivers, and then create logical roads (i.e. roads between cities). I don't have time to go into more detail unfortunately but hopefully this will get you on the right track. It might seem obvious, but look at Google maps at various types of terrain and roads; you will get a better sense of how they should look. 

You didn't really get astounding quality with Crazy Bump...hmm. don't know what exactly you are looking for. okey, here is another solution. Its called Insane Bump. Its functionality is similar to Crazy Bump. Try it out. There is an interesting comparison between this two bumpies. Oh did I mention. Its Free! 

For Metal Gear : Guns of The Patriots, Kojima used their own in-house engine. Its unavailable to general public. C++ is the de-facto of the console game industry. So, I believe it was in this case too. Recently they are developing a new engine which they have revealed E3 of this year, named Fox Engine. They say they will be using this multi-platform engine for their future titles. 

I don't know if this is the correct answer (as I know relatively little about blender's behavior), but are the bones long enough? It kind of seems like the deformation is not being applied properly because of the way the bones are weighted. I am used to seeing other skeleton systems where the end of one bone touches the beginning of the next - here they appear to not connect. 

I've done a fair bit of work in this area, although most of my demos are older: (flash 2010) $URL$ (click and drag mouse) $URL$ (directX 2006) $URL$ I highly encourage you to roll your own, if you are doing this for fun. You will almost certainly need to work with Quaternions. Understanding them is very hard, but you don't need to go too deep to use them. Think of a quaternion as a vector with an extra component: rotation. If you want your plants to twist and turn as they grow, they will need quaternions. Other things to learn: Lichtenberg Figures Laplacian Growth Voronoi Diagrams Nearest Neighbor algorithms (google them) I (personally) would discourage the use of L-Systems, other than to perhaps dictate a grammar for what grows where, i.e. [seed -> [root] / [trunk->branch->[flower/leaf]]. L systems are not good for responding to environmental stimuli like sunlight direction, gravity, obstacles, etc. As for speed concerns, a single tree can be generated in realtime. For memory purposes and performance though, you will likely only want to generate a small set of trees and instance them a bit if you are dealing with forests. Most existing tree generators are not that great (IMHO), besides the high-end ones used for Maya and such. I also highly, highly recommend using voxels to generate the tree (then skin with a mesh if needed). The advantage of voxels is that you can easily simulate growth algorithms using things like Laplacian growth and various automata (not Conway's game of life, but other rules produce interesting results). 

Pick OGRE if your not afraid of digging through large code base or just a rendering engine. I would also suggest jMonkeyEngine if Java is not a problem for you. Horde3d is pretty well known for its high profile code base. You can try to look that one too. ID Tech engines has been released open source, you can fork those too. I would stay away from those engines that has been abandoned by the developers, i.e. Irrlicht Most importantly, rather then looking into one and recreating/cloning one for yourself, its better to contribute to one of these open source project. I think that way you'll learn more and everybody will be happy. :) Also you might wanna go through DevMaster Game Engine list to check other engines. 

The harsh truth is that ideas are worthless. I am not trying to be condescending, as I myself was once protective of my ideas. If they were worth something, there would be a market for them. Have you ever heard of someone purchasing an idea before?* No matter how great you think your idea is, the human race is very large and very creative, and your idea has probably already been thought up 10 times, and if it is any good there are probably implementations of it in the works that you don't even know about yet. The best thing you can do is spread your idea as far as possible - this will test for traction, give you valuable feedback, and potentially gain you some support. Its very unlikely that anyone will try to steal your idea, because every person is more interested in their own "great" ideas. *(Note, intellectual property is an entirely different thing. IP is worth something because it has a mindshare, and previous implementations that have built up this mindshare). 

Mobile/handheld devices are less powerful. Because they have to optimize the hardware configuration withing a reasonable price range. But, Desktop is not like that. Its modular and doesn't come as a package that can't be upgraded. You can modify it based on your need. And you are paying for a certain hardware at a time so, you get more powerful machine biased to your demand. These things are not possible in mobile devices. In case of console, though they are under powered(when you look at the numerical figures) with respect to Desktop PC but, their architecture is different and those machine are fully dedicated for gaming. So, those hardware don't have the overhead to run a general purpose application. That's why they perform better comparing with the same configuration PC. But, recently handheld devices are getting more and more powerful, supporting many features. But, again you can't just put is stuff into a mobile just because you can. You have a power supply limit and you have to watch out for the price of it. That's why you can't just stuff in your Intel Core 2 duo processor in your iPhone just because its smaller then you phone. It demands power & cooling system. A handheld device is not physically capable of supporting that. EDIT : I haven't seen any mobile device supporting over OpenGL ES 2.0 but in PC you have OpenGL 4.1 features(with necessary hardware installed). For advance visual effects you need some features from the later versions of OpenGL. One of the most notable feature, Tessellation is only supported on OpenGL 4 supported hardware.(ES stands for Embedded device) And so far its not yet possible to create an hardware supporting OpenGL 4 in an optimized manner that can used with a handheld device. 

The "gluLookAt" function (as mentioned by Cong Xu, is definitely useful, but I find this to be even better: $URL$ It is really the same thing as a lookAt matrix, but gives you a deeper understanding of its functionality. Using tangent space vectors, you can easily rotate an object into a given position. It is actually really important to understand how this works (I think) if you want a firm understanding of 3D vector math, but you can just as well use it without digging too deep. 

I would generate a cloud of points inside areas where the terrain is solid - you can experiment with different densities. Then I would use an algorithm like a minimum spanning tree to connect all of the points - this will ensure that every area is reachable. Then simply draw big hollow (composed of air) areas from node to node (i.e. a thick line of voxels).