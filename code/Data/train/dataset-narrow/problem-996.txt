I tend to use enums as a thing to represent states (open/done) or constants (monday/tuesday/...). In my opinion, the calculation of a price should be in a separate type and represented by an interface, and not implemented or even delegated in the enum itself. If there's just one thing you have to consider for the calculation of the price, e.g. - maybe a stupid example - an exchange rate, you would have to call the method in the enum with an additional parameter and change all your code. If the calculation is represented in a seperate type, you just inject something like an into it, and the callers do not care. And: It's easier to test your code, since you can mock it and you won't test the calculation of the price implicitly (for those maybe hundreds of occurrences: that means, if something changes within the enum, potentiall all your test cases which call the enum, can fail). And: In mdfst13 example: The Side does know about Order, while the Order holds a state of Side, that's a bi directional dependency and is very tightly coupled... that's okayish, but imo should be avoided. 

naming Always try to be as specific as possible. For instance stack and map: I actually have to read code to understand, what you want to put into them. So maybe call the map , and the stack maybe abstraction I don't see any need for an abstract class, an interface should be enough. circular dependencies The method actually takes an parameter, at the same time has a dependency to the type. This is called a circular dependency and must be avoided. One reason why it's bad, is the tight coupling of two components. So you can not reuse your classes without . You either pass the values which have to be calculated, return the result and push them back within , or, your "Layer" provides an interface with and methods, which then will be implemented by the which you then will pass. So in any other calculator, your operators can be reused. your question Do I need to write getters for fields that I didn't use? such as public String getInput(). I didn't write any setters for the non-static variables. do I need them? In most of the time, you shouldn't do that, because it's dead code. Generated code is the exception. Maybe there's others, but I can't think of any. Hope this helps. 

Liar. The setup() method does the cleanup. At least the cleanup of the agents. agentGoals() Use try-with-resource block. 

instead. Make use of move assignments Currently you have to copy values into your optional. But what, if you just want to move something big that you want to return from a function? You need to add constructors for rvalue-s. 

You will see that implementing is very simple and beautiful in comparison to a direct . Edit: What I call here "upper_bound"-like search is implemented in the STL as not to confuse with . 

A note on performance As for the performance. I can not imagine that this is a particular fast implementation. You use a lot (which means a lot of scattered allocation) your memory access patterns are not very cache friendly and so on. But this is a VERY hard problem to solve generally for all graphs since it is so dependent on its details. solves this with a lot of trait classes and a Visitor concept and is IMO quite hard to use too... and these guys have a lot more experience than both of us. A cheap trick one can do to boost its performance is to supply an allocator-overload to your function. This way you could preallocate a memory arena or even use the stack. 

2.) Don't use abstract base classes for function objects 2.1) Use instead of abstract base class 2.2) Use instead of abstract base class [ Note: Or just take these as template parameters only. ] The rationale is that the way you do it is intrusive and a client has to define adapter classes to use your library. Since your abstract base classes only require virtual you are better of with which is just such a wrapper around any function-like type. Defining abstract base classes here might also introduce a lot of subtle misuses and errors. For example: you do not define a virtual destructor! Since you do not store your function objects polymorphically it seems to be okay in this case (and might leak otherwise), but on the other hand you take pointers to such objects without -checks... and your classes invite users to misuse them by letting the pointers dangle. I have no experience with fluent interfaces but I do not like this particular example. You gain pretty much nothing but a code bloat -- one selector-class for each parameter plus it seems to be easy to misuse. Maybe one can generate selector classes and avoid code repetition with Herb Sutter's announced metaclasses. IDK. 3.) Don't use an abstract base class to require a ForwardIterator Just rely on substitution errors or constrain your Node type with Concepts / + . This adds again unnecessary coupling for the client to your library. 4.) Issues in A*- 4.1) is not a good name. I suggest something that indicate what you search for (an element? a path!) Suggestions: 

First of all, it's very well written and I can easily understand what's going on. I also want to point out to another post which is similar to yours with a lot of good code, answers and comments: Object Oriented Design of Card Deck However ... What 'hurts' the most is the very long main method. A lot of things in the main method can be moved to separate types/methods, for instance, the loading of the Deck: Consider writing something like . It's still quite clear what you should happen, but it's written / summarized in one line. As others have mentioned, it's better to move the 'game itself' to its separate type. Why? Assume you want to provide a GUI for your game - what do you have to change? Yeah, a lot, because a lot of the code is not reusable. I think, with that in mind, you will have a total different approach of writing the game, its classes and methods and the control flows. And by how your posted code looks, and how you are already "thinking in objects", I think you can do that without me pointing out every single tiny thing I see - so I won't go into detail about what part of code you should refactor to where and why - which would really take a lot of time. Now, some smaller thingies: 

getType() Why on earth it's the 's job to handle the car type anyway? And why is the car type stored in a . findNewAStarPath() 

There's different implementations (I can't see which one you are using) which of course do perform differently, too. Memory / GC I won't go into much detail, but if the concern is performance, you should look into garbage collection. There's a few common rules to follow, as using fixed heap sizes, or in your case, using a througput collector instead of a low latency collector. Hope this helps, slowy 

This is just useless. It's not only useless, I have no idea what I have to do with that information. And it's wrong. The first line after that comment is the serialVersionUID. And it's not parameters. Just get rid of all those comments, it's just clutter and misleading. serialVersionUID Disable the eclipse warning for the serialVersionUID. And delete all of those uids. When I'm pair programming with my apprentices, I forbid them to use quick fix. Because they don't know what the error/warning is, and what the quick fix does. public variables Don't explose implementation detail: public GeomVectorField roads = new GeomVectorField(); See information hiding another comment Okay, I withdraw my previous statement, THIS is the worst: 

4.3) Don't use new and delete but if you must... (you have memory leaks) [ Note: You do not have to use any heap allocation in your case. ] Because of improper use of you have at least two leaks (checkable with valgrind) Valgrind output 

Prefer value type semantic Try to make classes default constructible and equality comparable whenever this makes sense. Currently your class doesn't fulfil neither. The following code will not compile 

If you want to initialise your data from any range use templates and constrain its type to guard for errors at compile time. Prefer regular functions for computations This means, that an implemented function is also a function in the mathematical sense. Same input data produces same output data. I found that this almost always leads to evaluations which do not change an inner state. Thus it smells to me that 

is an additional comparison in each step. Imagine your are not looking for s but in a vector of large s. Just make an -like search and test this bound. Schematically: 

Here is an example of how to use to use uninitialised memory. I think this could help you as well. Do not return by value if you can The line 

Note that copying is very cheap since its only a (pointer, integer)-pair and doesn't have any ownership associated with. 

If I read I do expect to search for a node. But take this as a weak complain only. Naming is hard. 4.2) Nodes should be passed by const-reference or (if you really need to modify s when accessing its children) The way you declare your search method makes it impossible to search in read-only graphs. I suggest something like 

and after the while loop you should replace with (since is empty...). Hopefully you see how erroneous this manual memory management gets. Thats why smart pointers got invented. In fact, you do not need any dynamic memory at all here. You can just copy node_holder by value, I think. Just define your queue as 

always copies the arrays , deeply can be misused by passing and trusts the user that is chosen correctly. 

This data structure maps values from intervals of some type which satisfies to values of some type . I remembered this kind of data structure from an interview question. My current use case is a distributed vector where I want to keep track which MPI rank owns which parts of some global index space. I am not sure about the . Explanation I use a where empty optionals are my sentinel for intervals, i.e. marking their end. So when mapping some interval to some value I do this by inserting 

Be more clear about what you read. And if you read something into something, make the method name clear. And why does the start() method read data? Is it because the comment (Model Initialisation) is more correct than the method name? 

Philosophy lessons with slowy a priori: OP and me talked about the the solution in the initial question, let me explain why he came up with this solution. a prior II: I call it philosophy lesson, because it's less of a programming lesson ;) I must highly disagree with the "over-engineered" statement of Tamoghna Chowdhury. Of course, it depends, but since it is a learning excercise, it's the best opportunity to apply object oriented principles, right? If not applied to an easy problem, I doubt, OP will have it easy, applied to a more complex problem. I agree, make the solution, as easy as possible, but not easier. I draw the line between easy and easier earlier, it seems. And my philosphy - and the philosophy of most of the developers I talk to, which are developing large enterprise applications - is: Good code runs its test. Good code has a decent code coverage. That's how I made OP do this solution. I highly disagree with the statement "reducing maintainability" / "adding complexity", I state the opposite - of course, always with unit testing in mind: Having unit tests not only verifies, it also - and that's imo more important - enforces good design - Because of one reason: If you can't test it, you have a design problem. Now, if you have code, which is not tested and you have to refactor it, you do not know if it still works. Having a set of unit tests, which can be executed after every step of the refactoring, will always help and give you confidence. Unit tests also are a very good documentation. My experience has been: Code with decent test cases, which may seem "a bit over engineered" are easier to maintain, than code without tests - and therefore more classes/abstraction/etc. The single responsibility principle's goal - which we tried to apply here - is to reduce complexity: A class should only have one reason to change. I have catched myself too often, facing routines, which started easy as this one, but "historically grew", without having test cases and putting new requirements without thinking too much about future self. It often ends up in reverse engineering, trying to test it, introducing bugs and also - the worst - staying late friday night. In my opinion and my experience, the initial investment will pay off, sooner or later, when on the other hand, not applying the principles, will be expensive. code review Since I'm whining about test cases, I'm gonna start with that one. I applied the tdd approach as best as I could. I didn't care too much about naming (otherwise, I'd sit here all night) or exception handling, I try to explain my "ranting" from above. I used JUnit4 and mockito 2.7.22.