Algorithmic comments Your implementation is good, and should do what it is supposed, with correction of bug, and does so in a recursive manner. You can't do it entirely iterative as retrieving the values of a tree is not an iterative procedure. However, you do have the option of creating/returning/yielding something which you can use in an iterative manner. Either iterating over your returned list from , or by implementing an iterative version of the traversal, as I've done in my answer for . If having some you can iterate over you could do either of the following variants: 

Possibly without the parentheses around . No need to do an , and then repeat the output of the condition in the statement. And in the calculation of couldn't it be just: ? Is Lua very fond of globals? In your function you initialize the , , and so on. All of these seem to be global variables, so I'm guessing Lua is rather fond of globals. To help this look a little tidier, though, I would consider adding , , and so on methods, to help keep the base function simpler and more understandable. Simplify your statements You have quite a few statements testing for plus 0 through 7 (or similar). This can be checked either using loops like suggested by pkisztelinski in his answer. Or since it seems like you're mostly comparing towards an 8 bit (or pixel) values, you could divide your coordinates by 8, and see if the thingy you compare towards is equal. Another option is to check the absolute distance towards the target. Instead of testing all variants of vs . Check the (absolute?) value of . If less than a given limit, they are too close... If you still need multiple conditions, group them This looks ugly and is confusing, even though Lua has proper precedence of and which seemingly makes it work: 

Here are some comments from a somewhat rusty Java programmer, which from the get go would like to state that your code does look clean and good. Somewhat repetitive at times, but that is possibly hard to avoid given your base classes. 

I haven't installed Pythonista, yet, so I'm not able to test this code, but hopefully it should work nicely. 

Your implementation misses a few things when coming to good coding practices, but let us first restate your goal: Calculate a degree based on line coordinates. Return a cardinal number evenly dividing the circle, and/or return a text related to the cardinal number. Code review 

You've gotten some good answers regarding how to simplify your code with respect to the overall logic and the use of operations. I would just like to focus a little on printing. First of all, the recommended version for string interpolation is the following: 

PS! I would strongly suggest that you refactor your code with better names, and then post it as a new question. Then you could make an edit to this question, and state that it has been replaced by the new question. Do not edit the code of this question. 

It shows that you've written code before, so style wise there is not much to comment upon. What I would like to comment upon is a few points on code structure: 

I normally don't do C++ reviews, so I might be off on a few accounts, but here are some style and code review points. Style and Code Review 

My main question when reading your code is: Why do you count the number of spaces? You don't need the number of spaces, only to know whether the previous character was whitespace and if the current character is whitespace. In addition there are some style issues in your code: 

This doesn't require any memory besides the original text, loops through the entire text in one go, and calculates the points for word counts starting with either a vowel or consonant. Feel free to test this one with text length of 1000 or more. Tested it with a text of length 1.5m, and it completed within 0.35 seconds. 

I've renamed some of the variables, combined the log output, and introduced a to tidy it a little more. But more or less this code is as is, and could most likely benefit a lot from reducing number of steps and what gets stored in the arrays. I skipped updating of the position of earth, as that is the base of your system. In total I've reduced the number of lines in your code, even though I've added a lot of blank lines here and there to enhance readability. Performance comparision Your original code when I ran it on my computer gave this output: 

As you've taken most of our advice to heart, there isn't much to complain on stylewise, but a few pointers from my personal opinion: 

Algorithmic review with proposed solution Often challenges like these present all needed information related to solving the challenge. On top of the information given, which includes a very specific remove element from middle of stack and leave at top, you've chosen to implement a tree structure, re-implement a stack/enqueue, and also using dicts for remembering touched values (or similar). This kind is kind of like shooting sparrows with cannons. There is actually no need to use such big guns here, let's review parts of the challenge: 

All the branches here ends up in either: , or . And these vary by only one thing and that is if they check whether or or all is present in the current element. If present they all call the same which ends up doing the , and if this is found you do the . This should be possible to restructure into a nicer and possibly faster structure: 

Conclusion Using the construct it is possible to simplify the function quite drastically. And then it is up to you if and how you want to decorate your functions, but you can rather easily move the burden of argument checking into the functions as demonstrated into the various versions of , whilst still allowing for variable arguments to be used. Personally I think I would opt for as it allows for precise error messages to be given when something is missing, but your mileage may vary. 

Even without any comments, I think this code reads a lot clearer. The first double loop reads as swap an element at with an element at . Repeat this for the entire x-column range, and half the height range. With top left as , this reads as swap an element from top left with an element at bottom right. Move to the right for the first element, and to the left for the second element. Repeat until row is swapped, and then repeat for the second (and second to last row). Finally, if there is an odd number of rows, swap the far left element of the middle row with the far right element on the same row. Increase and repeat until row is swapped. Changing dimensions This code actually handles various dimensions, whereas your original code gets whenever the second dimension is larger than the first. And it produces strange examples if the second dimension is less than the first. Here is the output from a run (the first line is the output): 

The answer by Joe Wallis got me thinking about an option of just popping the last values of a list which would make for something like: 

More could be said, but this should get you going on implementing a much nicer and cleaner version of your code in a lot less lines. 

It's been a while since I dabbled in Java, but if you don't care that much on memory efficiency you could use the first half of this code, and if you need for the returned array to be of exact size use also the second part to return only an array of given size: 

Compare the code above, with your code example with , and consider which one is easier to maintain as a simulation, and which one is easier to understand related to the actual simulations you'll want to run. In my mockup, I've , and to indicate the different parts of the simulation. The class would then be in charge of gathering all the commands, which could be done through using ( or) to actually build the commands, making the overall logic of the simulation class simpler and it can focus on stuff related to actually running the simulation in the unix shell. General comments on code Here are some comments on your coding style: 

Alternate solution You're asking for a faster solution, so let us analyze what is happening in your code currently: 

And then I find just to find that this is called before the other, and does much of the same stuff... Strange... You should aim for one major parser, and let is select which tokens you find along the way, and then afterwards parse the token list into something sensible. To get a proper token list you need to separate your string on any split between elements, which might be as simple as spaces and the delimiter list. Whenever you find either a delimiter or something else, add a token to the list. Afterwards, you can parse the token list, and consume tokens depending on the context you are in. For example if you have a , you consume all tokens until the matching , similar for and other tokens. The main point is that after you've built a proper token list (not a string), it is rather easy to define your language as a sequence of given . A final point on your main program is that you read the entire file into memory, whilst it could be better to read and parse it line by line when translating into tokens. You'll surely not get that large test files, but it is a better way to handle files normally. 

Code smells In addition to the smaller style issues, there are some bigger code smells in your code which I would like to address: 

According to the comment made by Mauricio Scheffer, this has been around for quite some time, see $URL$ . That code however seems to handle different versions of F# which yours doesn't. Regarding a pure code review of your code, it does seem clean enough, and if it serves your purposes, then who are we to say otherwise. It does seem like a neat trick given a suitable use case. My guess is however that in most cases people don't need a new function to be generic, unless they have a specific use case regarding generics. And that means that in most cases, you already know the type of your literal. 

Add two newlines before any function, method or class Add newline within functions before logical groups of code, i.e. initialising local variables, blocks, or loops 

This will result in a reduced memory print, which always is good. And you process the line only when traversing the line and not both there and in the output printing. The latter is a lot easier to do as you only traverse a prefilled array. Disclaimer: I'm not sure how this is done using multiple processes, but you seem to have figured out that part already. If you're having issues with that, you could try this algorithm without the multiprocessing part. PS! Are all of the processes writing to the same file in turns? It could(!) be better to allow each split to write to its own file, and join them afterwards... 

I'll cover all of these with a little more detail in this answer. Plain In most test cases related to Code Review answers I start of with the original code, review it and write some refactored code. In some cases other answers suggests other implementations, and then I copy them into the same file. To keep the solutions apart I've adapted a procedure of creating , (or ) for my solution, and then for other solution where the xxxx is the username of the answererer. This allows me to have the same interface to all of the main testing method of each variation, and I've typically made them with two versions: One with output for verification of correctness, and one version without output for execution timing. When these are made I typical have code like the following: 

See UNION (Transact-SQL) for more information on union. A similar approach should be possibly for the other update, if I'm not mistaken and misunderstand your request. Doing this would remove the need to update the same row more than once (or possibly twice for the games won as separate query) instead of five (or ten) which you do today. The 's will be almost the same, but 'ised. Since 's are cheaper than 's, this should result in a performance gain. If you opt to, you should be able to extend this pattern using loops like indicated in the other answer by Alexei. 

As I didn't have any available, I've commented out that segment, and use a random generator instead. This in combination a lot of print statements should show that in most cases it would continue with next sentence in a lot of the cases, and hopefully not fall through to the dictionary test or "Couldn't decide" very often. When deployed to production all of the statements should be removed. Do also note that this code is written in Python 2.7, so no parentheses are needed for the statements, and some strings needs to be declared as unicode strings. But you didn't state which python version you are using, so I made this in the older variant. Hope this helps you along the way. Alternate trigger word list tests At the cost of looping twice through the list, one could remove the inner loop, and all other code related to : 

If all tests pass, you'll see nothing, and it they fail, you'll see why the fail and both the expected and actual results. Properties If you want to use , and as aliases into you could use properties which changes like the following: 

Whilst I was writing this answer, the answer with using the concept came in, so I included that in some basic timeit tests to check for running times, and the result surprised me a little: 

First of all, I'm not proficient in any way with Lua, but I do know programming in general, so this review is based upon that knowledge. I'm sorry if I say something which is dead wrong when it comes to Lua. Use spaces and indentation to your advantage Readability of code is crucial in any language. Even if the language it self doesn't require a fixed indentation (or braces), using indentation will help readability which in turn helps understanding and maintaining the code. So instead of: 

In your other post you state that you've already split the main key file, of 62 million entries, into multiple (20 or so) key file, and the code presented here is the one processing each of these files. But as the keys from the key file is unique, you can avoid building the dictionary and instead change the into storing only the information you need. Going light on the current code Regarding current code, you do use a lot of globals, which is not recommended, and you do use string concatenation with '+' which also is somewhat discussable. And some similar issues exists, but I'm going to leave them for now as you have a major performance issue to solve. Suggestion for refactoring 

I profiled version 4, and found that finding the common start was the slowest part of my code. Then it hit me, why don't we skip comparing byte for byte, and instead do a string compare on current instead? This leads to version 5, where the code around has been replaced with the following: