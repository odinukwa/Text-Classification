There's several things with leds and their brightness. 1) The resistor you use in series with the led determine the current that flows through them. leds with different colors can have different voltages that fall over them, so you might need to adjust the resistor depending on the color. 2) Not all leds are created equally. There are high power leds and low power "signal leds". Some are more efficient than others 3) the human eye sees green and yellow light brighter... So even if some leds burn at the same light intensity, the human eye will still see a difference. If you're after balancing the leds out for the human eye, you have to look up their datasheets and figure out resistor values. And even then... Usually you'd use a variable resistor to tune the colors. 

I have a serial device connected to pi´s USB slot. The device is connected to the USB port though internally the USB interface is connected to a USB-to-UART bridge.For programming purposes this means that the interface appears as (virtual) serial interface (RS232). The driver is CP210x. In the pi, I used modprobe cp210x to load the driver. lsmod lists cp210x The name of the device is Rotor Gene. In windows system it is detected in port COM5. After I connect to the device, dmesg gives: 

With the device plugged and not plugged, ls /dev/tty* lists the same ports. There is no ttyUSB nor ttyS in the list. Why the device is not attached to a port in my pi. 

However, this clearly doesn't use the HTML5 tag. I then tried the WebRTC example page, and this does appear to run in the browser, but it's heavily Javascript based, so I can't tell exactly how it's implemented or if I can reuse it in my own application. 

Why is it rebooting even though I'm using the option? What am I doing wrong? Edit: I found that I could save the console output by instead running: 

How do you detect when the Pi is slowing down its clockspeed due to overheating? I know I can find the "current" CPU speed by running: 

I bought this Pi hat for integrating an Arduino with the Pi and exposing all the GPIO pins through nice GVS headers, and overall I'm very happy with it. However, I'm noticing a weird problem. Without the hat, I wired a BN005 9DOF IMU directly to the Pi, and was able to poll the motion data from the Pi perfectly using this Python code. Yet when I attach the hat and wire the sensor through the I2C 5-pin header, I get the error: 

74HCT241... Or 74HCT541 may be simpler (more efficient pin layout). These chips carry 8 buffers/line drivers instead of 4, and are a bit bigger (I think 20 pins) but I'm guessing they'll be much easier to find. Just make sure to pull the /OE1 and /OE2 lines low if you want the outputs to send one's and zero's (otherwise they'll stay high Z). Ow - You can only get these buffers out of high Z per 4 drivers (but I think that won't be an issue as you're probably fixing all /OE lines to ground anyway) 

Sorry, but that will not work. Even if you tune the OS into the extremity, the servo will always wiggle about. I've done a lot of servo controlling myself, but using Atmel AVR microcontrollers (the ones used in Arduino's). You're way better off using a simple Arduino to control the servo('s). I usually created an interrupt off a timer that would time 8 servo channels in a single go. The 1-2ms pulses would leave the pins one-by-one, but as long as the repeating frequency is 20ms you're fine (btw that is why I control 8 servo's - 8x2ms = 16ms which falls within the 20ms repeating frequency). Maybe add a Pi to do any high-level stuff and telling the Arduino how to position the servos... If needed at all...?!? 

How do you run the Ubuntu ARM image in Virtualbox (ultimately managed through Vagrant) for testing a Raspberry Pi configuration? I can find a ton of guides for running various pre-built Raspberry Pi images in Virtualbox, but they all use Raspbian or Windows images and don't explain where those "ova" files came from, much less how they were created. 

This eventually resolved itself. I installed Ubuntu 16.04, upgraded the firmware using the standard rpi_update tool, and then did a hard power-down reboot, and wireless worked. 

After reading through the several Launchpad bugs associated with the ARM image, it's clear the Raspberry Pi 3 cannot reliably run the Ubuntu kernel at this time. I've decided to abandon Ubuntu and use the default Raspbian image instead. Edit: I eventually found this image (ubuntu-minimal-16.04-server-armhf-raspberry-pi.img.xz) which runs reliably on both the Pi2 and Pi3. 

As cool as this project sounds... What exactly would the Pi be doing in this setup? It would appear that a few smart switches would accomplish the same thing? The reason I say this is not to just be negative on the project so far because I think it is awesome to work on something like that!!! But the Pi will draw quite some power and it would seem preserving power is your first and major concern..?? 

Not sure how long it will last, I'm guessing it will have a VERY short life span... If you want to get the most out of it, you should be looking into a DC-DC / buck converter. You can buy them from ebay for a dollar or so. These converters will actually convert the 9V to alternating current, transform them down then make them DC again. Efficiency is usually north of 90%. If you use something like a LM7805 it will work, but the 7805 will basically "dissipate all extra volts into heat" which you do not want. I'd also look into underclocking the Pi to save power. 

I have to communicate to a device which uses serial interface through the USB port. I disabled the Serial Port Login and disabled the Bootup Info. When I list the devices using lsusb, the device is detected. ls /dev/tty* lists a number of tty , but no ttyUSB is listed. There is no change in the list before and after I connect to the device. ttyAMA0 is listed before and after the device is connected. In the window PC the device is detected in COM5. How do I know the port to which it is connected. I have a java application that sends and receive data to the device. dmesg | grep usb gives [ 3732.485108] usb 1-1.5: Product: ROTOR-GENE [ 3732.485126] usb 1-1.5: Manufacturer: Silicon Labs [ 3732.485142] usb 1-1.5: SerialNumber: 120876 The device link is qiagen.com/us/shop/automated-solutions/sample-prep/rotor-gene-q The device is connected to the USB port though internally the USB interface is connected to a USB-to-UART bridge.For programming purposes this means that the interface appears as (virtual) serial interface (RS232). 

How do you allow non-root users to access I2C on the Raspberry Pi 2? I've compiled this code for accessing an MPU6050 sensor via I2C, and it works perfectly, but only when I call it via sudo. I tried adding the pi user to the spi and i2c groups, and adding udev rules as explained here and here, but even after rebooting, those had little effect. I can run as a non-root user, but the C code still crashes if run without sudo. This is documented in the underlying bcm2835 library: 

Is there any workaround for this? Even if I add the pi user to the root group, it still silently crashes. 

I ensured that the USB dongle is detected by pi using lsusb.On the Current Status tab of wpa_gui. Then Scan and waited for the results . I selected my wireless network and then clicked Connect. The wpa_gui just sits there with Status: Scanning. I have a hidden and open wifi and hence no SSID is displayed. I choose the BSSID from the list which i already know from netsh in command prompt in my windows pc. Network type:Infrastructure Authentication:Open Encryption:None My lsmod lists 8192cu.ko module What can be wrong? Using the command line 

I have a serial device connected to pi´s USB slot. The device is detected in ttyUSB0. Aten uc232a usb to serial adapter is used between the serial device and pi. I have to run a read and write operation to the serial device. I used rxtx library for this. The java application is inspired from the following link. $URL$ The machine has baud rate 38400. The application runs with incorrect output when baud rate is set to 19200. With baud rate set to 38400 the application gives error gnu.io.unsupportedcommoperationexception:Invalid Parameter at RXTXPort.setSerialPortParams