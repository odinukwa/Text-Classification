Also, if possible, you can typically gain a performance improvement by moving the sort into the application layer. 

It seems likely that the subquery in the SELECT is causing a row-by-row lookup. Try moving into a LEFT JOIN to get the set-based performance we're looking for: 

As mentioned in the comments, there are benefits to casting/storing that unique key in the table during the ETL process, especially if it's going to be used in other places than just this query. Most likely, the performance hit is coming from using IN (typically results in a row by row lookup) and from de-duping with the casted key. You could get a performance gain from JOINing the subequery instead of using IN. You could also use ROW_NUMBER which, in my experience, is typically more performant than the GROUP BY with HAVING clause. Here's my example using ROW_NUMBER and CTE's for easier reading: 

This makes testing easier; I can pass in whatever I want without having to build any context, and I can check the return value. Using return values also lets you use doctests, which are one of the cool features of Python that no other language I know of has. 

Or, if you're uncomfortable with the shortcut syntax for anonymous functions (it can get pretty hairy), like this: 

and instead of a sequence of vectors, we'd get back a sequence of maps with keys , , and . This usage is totally unrelated to your original intention for this code, but it shows how generally useful the function isâ€”so why make it private and hide it where no one can access it? Let it out and see what uses people can find for it. Finally, for such a small program it probably doesn't matter, but one of my favorite features of Clojure is docstrings. I would write one for any function I was publicly exposing: 

I'm mostly interested in the design of and the efficiency of the algorithm and the returned result. If you find any bugs, please point them out. Any comments on code style and readability are appreciated. 

I have not seen the other answers talk enough about how you manage vector sizes. Design Issue You are declaring but at least you are using consistently. This would normally be using . (see Ben Steffan's answer point 2) Implementation bug has a bug. Specifically, if , you are overflowing which leads to undefined behaviour for and overflow for . The standard implementation of offers a method that returns the largest implementation defined capacity. Reserving or increasing the vector beyond that size throws a . Similarly, in you might overflow . Naming should be called . is . is . is called in C++. This leads me to my last point. Adhere to the container concept If you want your vector to be reusable in other contexts, you should adhere to the container concept. This would allow other libraries, e.g. to use your container. Part of this would be to change (note also that you should be taking this argument by const reference) to aswell as implementing an for your container. 

I would prefer not to catch the here. Letting an exception go uncaught will just stop the whole program, which seems to be what you wanted. Some other languages force you to catch or declare every exception, but Python will just bring down the whole program around you. That's not what you want for production code, but that is absolutely what you want for development: anything anomalous will make the program crash and die right away, with a reference to the line number where the crashing and dying occurred. As a bonus, it's quicker and easier to write the code that way, because you don't have to add blocks around everything. If you can do something about the invalid input, then definitely catch the exception and do something. But if all you can do is say "You screwed up, fix it", then why not just let the exception be thrown? This piece of code from could be a lot shorter and cleaner: 

I have been writing a small compiler generator for which I need to solve the strongly connected component problem. As the Guava library contains, to my knowledge, no implementation for that problem, I have decided to write my own based on Kosaraju's algorithm. For this, I have created a class and a to iterate over the graph. 

Don't explicitly check for files If not explicitly stated by your professor, I wouldn't log anything to . If you can't read from the input/can't write to the output file, this is a problem for the caller, not something you can deal with. A rule of thump is that problems related solemly to the arguments are to be dealt with by the caller because he has to decide how to deal with his illegal arguments. As we can not simply rethrow the because of the method declaration in (given be the prof, I assume), we catch them and throw an with the as its cause. If you are allowed to change the declaration in you should add an and simply delete the -clause. Using java's try-with-resource statement Another improvement is to replace the with a clause. The way it internally works is that you can declare multiple resources after which are automatically closed when you exit the -block by calling their method. This way, you don't have to deal with closing or manually, any longer, and they are always closed so you can't even implement the close errornously. Using #codifica(int) Generally you should avoid copying source. As the implementation of is alread given in the base class, you should just call that method directly. This also allows child-classes to override the transformation. 

Overall, your code is good, but there are a couple of performance improvements that were pointed out above. Here is a more explicit answer on how to improve the performance of the code provided. Improvement 1: Eliminate subqueries in SELECT Subqueries in the select statement referencing an external table will take a major hit in performance (row by row look vs set based join). In this case, we can avoid that by joining the Users table. We're assuming Id is the primary key in Users, so no duplicates to worry about. We are doing an inclusive join, which assumes all UserIds have a corresponding record in the Users table (typical foreign key constraint). Improvement 2: Eliminate redundant external references We reference the Posts table twice in the original query, once to limit to closed posts and another time to sort by the ClosedDate column. Instead, we can do an inclusive join to Posts, set our criteria either in the WHERE clause or in the JOIN, and do the sort, so that it is all done in one pass. We again assume that Id in Posts is a primary key, so no duplicates to worry about. 

Your original code contains an apparently correct implementation of Euclid's Algorithm, as do some of the other answers, but it seems you weren't sure if the algorithm was correct, so I'll spend some time to explain it a little. (aush gives a very terse C# implementation of the algorithm in his answer as the private method , which is great for writing the program, but not so good for understanding the algorithm.) I don't know C#, but I took number theory at university, the first half of which was more like "Applied Euclid's Algorithm", so I'll summarize the idea behind it a little. The idea is that, when you reduce a fraction into lowest terms, you're dividing out the greatest common divisor of the numerator and denominator. In your example, \$ \frac{3}{4} \times \frac{8}{15} = \frac{24}{60} = \frac{2\times12}{5\times12}\$. Euclid's Algorithm can find the GCD of the numerator and denominator. Think of writing out the numerator and denominator as prime factorizations: \$\frac{24}{60} = \frac{2\times2\times2\times3}{2\times2\times3\times5}\$. Euclid's Algorithm finds the number whose prime factorization contains all the prime factors shared between the numerator and denominator, in this case \$12 = 2\times2\times3\$. When you divide out the GCD, you're dividing out all the shared prime factors: $$\frac{\frac{24}{12}}{\frac{60}{12}} = \frac{\frac{2\times2\times2\times3}{2\times2\times3}}{\frac{2\times2\times3\times5}{2\times2\times3}} = \frac{2}{5}$$. There are no more shared prime factors, so the fraction can't be reduced any more. In this case, the numerator and denominator are both prime and are unequal, so it's obvious there are no more shared factors. Other times, you might have two composite numbers that share no prime factors, e.g. \$\frac{8}{15} = \frac{2\times2\times2}{3\times5}\$. The idea behind Euclid's algorithm is this: if we have some numbers \$a\$ and \$b\$, both integers, and \$a > b\$, we can divide \$a\$ by \$b\$ and get two numbers, a quotient \$q\$ and a remainder \$r\$ (remember back in grade school when \$23 / 11\$ was something like \$2 \ \mathrm{remainder} \ 1\$?). In other words, \$a = bq + r\$. There's a theorem that if some number \$d\$ is the greatest common divisor of \$a\$ and \$b\$, then \$d\$ is also the greatest common divisor of \$b\$ and \$r\$. So we calculate \$r\$, and then we feed it back into the algorithm as the new \$b\$, with the old \$b\$ as the new \$a\$. Eventually, we'll get a remainder of \$0\$. The value of \$a\$ on this final iteration is the GCD of the original \$a\$ and \$b\$ that we started with. (All of this can be proven, but I won't do that here. Here's a page that both describes the algorithm in more detail and gives a proof for it.) I hope this answer and the pages I linked can help you understand that the GCD method does work, and why. Here's a link to another page that also explains it in terms of code. The code is in C, but shouldn't be too hard to understand if you know C#. If you're interested, you can also use Euclid's algorithm to compute the least common multiple of two numbers, which could be useful in the addition and subtraction methods. From Wikipedia: $$\mathrm{lcm}(a, b) = \frac{\vert ab \vert}{\gcd(ab)}$$ So you could also write your addition method something like this (this is the first C# I've ever written, so there might be some errors):