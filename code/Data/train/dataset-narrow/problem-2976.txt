The big disadvantage seems to be that you're re-enforcing their (or maybe your own) preconceptions about barriers to entry, and taking them further from the 'normal' programming environment. Yes, you can twist a spreadsheet to demonstrate some topics, but the biggest misconception you will teach by starting like this is 'everything executes in parallel'. Having moved from coding software to verilog (hardware) I can vouch for this being a major mindset change. You're also teaching a non-flat code layout, have zero scope for sensible comments, and an unusual syntax. A better approach is probably to find an online simulator (i.e. a web browser, which everyone has or can access in many countries). These will handle the code storage (in the browser or in the cloud) and avoids any assumptions about how familiar they are with specific types of software. I really think you're better identifying this as a new journey, and not expecting your cohort to have anything installed on their machines. Having supported a public drop-in class, I'd also opt for an environment which allows both 'block' coding or text based views like the micro:bit javascript blocks editor. This removes the barrier of needing to remember syntax and seems just as relevant with older introductory level students as very young ones. Once you have introduced the fundamentals (keeping the first contact easy and low stress), you can move to using text based entry. Returning to the micro:bit example, I think having a physical device is less important with an older cohort (particularly if they are in your class by choice). It gives you scope to use a demo, and show some context about how close to invisible/trivial computers are (something else that your spreadsheet doesn't expose). To summarise my objections to the proposed approach: 

Maybe (given the opportunity) the best way to address this question is to have your students talk to someone actually working in the field right now. You probably don't want to give the message to your students that it's been a while since you were working on what they regard as real projects (and I venture that many teachers don't have time to work on projects in their spare time). So maybe you don't think you have any particularly interesting personal examples to share. In that case ask them about what tech they find cool and exciting, then explore what that might lead to. There are two threads that I refer to when I'm talking about careers: Technology changes This is a complex thing, meaning that there are both new things to learn (smartphones now outperform the supercomputers of my youth), and that there will always be new technology along in a few years. The hook can either be 'how does it work', or 'what can we do with this', and the appeal will be different for everyone. There is a lot of detail Despite the apparent rapid changes, this isn't necessarily a field where skills become obsolete (assuming you view languages as a tool). There are also many different levels to work at in even a niche of the field. If you consider products, look at the whole supply chain. If you consider applications, look at science/industry/entertainment/health. Then don't forget development/support/training/marketing - technical skills are relevant to all of these roles. If you want a modern example to break down into it's components, look at today's high-end VR. GPU hardware, High-bandwidth data to displays, 3d-rendering, position aware audio, sub-mm resolution position tracking, nausea avoidance, let alone all of the actual applications of the technology and generating content. Something that a few years ago, not many people though would be possible. 

Because debugging can be learned very easily through experiance, I'd try and help the students self-correct when they make mistakes. When correcting mistakes, ask the students to type the corrections themselves, so that the corrections will be better ingrained in their minds. Also try to correct them by leading them through the debugging process. You can lead them through by asking questions, like "What line does the error message refer to?" "What is that line supposed to do?" etc. Eventually, they will start following the steps themselves, and will learn to do it without your help. 

In my APCSP class (using app lab, which is javascript based), I noticed that there are many students who struggle with the difference between a string () and a variable (). I've explained that strings are surrounded by quotes while variables are not, but this is still one of the most common mistakes I see. For example, a programming task could be: 

I believe that the reason why students tend to come out opposed to using TDD/BDD (testing) is because they've been assigned to use it when it isn't necessary. Testing a "Hello World" program is 100% a waste of time. Tests only become useful when you have a reasonably complex program. The way that you can avoid students disliking testing is by not assigning it on projects when it isn't needed. A specific way in which you could do this would be by combining all the project you would assign over the year into one larger cumulative project. Eventually, as they're writing code, you can be fairly certain that they'll induce bugs or begin to find manual testing to be a pain. Once that starts happening, you can introduce automated testing to relieve that pain. That way, they'll see testing as a way to save work rather than create more of it. In addition, I think the issue may be with this part: 

I'd recommend using an RDS like SQLite. SQLite is an RDS that stores the database in a binary file, and has a SQL command line interface. I find it fairly simple to use, and a good introduction to how relational databases work and how to interact with them. It has GUIs, such as SQLite Studio (which I've never used, but looks useful) and is fully cross platform. It also provides a good stepping stone to more typical production databases such as PostgreSQL, MySQL, MS SQL Server, etc. It is also open source and in the public domain. If you choose to teach from the command line interface, that'd easily eliminate the GUI related issues you mention in the question, and would also force the students to interact with the database using SQL (which is a good and bad thing). 

The question kind of says it all. Imagine that for an assignment you receive two or more similar submissions (e.g. programs). What will you do? Annul all the works? What if you know for certain who was the original author? Probably this is already in your schools’ code of conduct. In my school it is not and I sometimes don’t really now what to do. 

There is this research paper "Learning edge momentum: A new account of outcomes in CS1" by Anthony Robins that is much focused on that subject... From the abstract: 

What if an agile methodology like XP or SCRUM is used? Every year we have the same problem, as some teachers say it should be done one way, while others say the exact opposite. Any ideas? 

It is not clear for me what "computer science" means for you. Is it at High School level? If that is the case, you could try to introduce some of the mechanics behind "digital music". How it is processed from analog to digital. How it is compressed, how it is reproduced, ... What does it mean to be 8bit or 16bit, the bit-rate, the sampling frequency... If the students are more into drawing/painting, you could do the same with image formats. 

I suppose that a traffic light is a very good example and easy to understand by your target audience. 

In the final report of their internship, the students of our school must have one chapter where they "document" the developed work. When using the “waterfall” methodology, they usually have one sub-section for each stage: 

I am not sure if this is really what you are looking for, but there is also Blocky from Google which is kind of similar to Scratch, and lets you see the source code produced by the block in different programming languages (JavScript, Python, PHP, Dart, Lua). Blocky is used in several projects like code.org. If Java is OK for you, than you can consider the BlueJ IDE which is: 

I would recommend that you let them figure it out themselves, then explain how to improve upon it. That way some students are certain to have the wrong implementation or a non-optimal one, and that gives you a way to begin talking about why student X's algorithm is wrong, and from there you can move into the theory. Also, this allows students to learn from their mistakes and learn from each others mistakes, which is almost always beneficial. You could also give them a completed application with only the priority queue implementation removed and ask them to replace it. 

It will repeat these steps every time a character is typed. When writing code, it's clearly easier to write: 

I'll then explain that the browser sees that as the "content" of the element, and draws a box around it, so I draw a box around it: 

I find that there is no real way to explain it without drawing it out. Usually, when I teach this, I've already covered basic HTML and CSS syntax, including a few properties (e.g. ). I like to give the example of creating a span with some text inside, so I draw on the board: 

Certainly mention the vocabulary, but I wouldn't make it mandatory to learn the words or use them correctly in class. What matters is that the students understand the concepts that go with the words, not that the know the dictionary definitions. Introduce all the vocabulary when it comes up in class, but don't be a stickler, especially early on. Let the students get a feel for the different types, so that they have concepts to associate the words with, rather than associating the words with (possibly incorrect) ideas. I'd also make sure to draw the distinctions when talking about the different types, so that the students mentally understand the different types conceptually before actually assigning vocab to the concepts. 

In a pass by value language, I'd have to duplicate the document and give you a copy. You'd then make your changes and give your copy to me. I'd then have to use your document rather than mine, because your copy would have the changes. In this case, there would two copies of the document. They would have been then same when I gave a copy of my document to you. You'd have to give a different document back to me with your changes. Importantly, we end up with two different documents. In pusdo-code: 

Since you mentioned that ideally you were looking for a video, a few years ago I used to show a video to my students: The Good Warriors of the Net - IP for Peace . It is a bit old, but the main concepts are there. Another that I used to show my students was: How the Internet Works in 5 Minutes Grab the popcorns! :) 

As probably we all experience, plagiarism is very common in CS. I know that there are several types of plagiarism ranging from simply submitting a copy of the colleagues’ code to other highly sophisticated mechanisms. In my experience, the most common is indeed the simplest one. The student just grabs the code from another colleague and eventually change the names of the variable, and submits the solution (some students don’t even do that!). While there are several systems that are easily capable of detecting this type of plagiarism, they do it mainly when the student submits the final version of the code. Some other tools, are capable of detect plagiarism and notify the student about that (as if they didn’t already know that!). In most cases the use of an anti-plagiarism tool will act mainly to support punitive measures. Although it is not the main focus, as part of my PhD work, I am working in a tool that analyses the source code as it is being written and is able to detect plagiarism in “real-time”. This way, the teacher can be notified about students that are performing plagiarism even before their final solution is submitted, giving the teacher time to act and avoid the punitive measures. My biggest question is: What should the teacher do with that information? Will this be efficient? 

I think that to understand the SELECT queries, the Who is Who? / Guess Who? game could serve as a nice metaphor. 

The idea of the game is: you have a group of pictures of persons with different facial features. One gamer selects one of them and the other gamer has to make questions to try to eliminate the ones that are not relevant and try to guess which one the other gamer has chosen. It is kind of like what you do in the WHERE part of the SELECT... 

In that case, public methods can change levels of the tree in either direction, and private methods cannot exit their level (or move to a different class in their level. This part is clearer with boxes). 

To give another perspective, when teaching an intro to web development course it's very useful to teach things in a way similar to how they were discovered and contextualize the different concepts in history. It's easy to understand why HTML is a markup language rather than a full fledged language when you consider the time: The Web was used for serving plain text pages, and they wanted a little markup to make it nicer. HTML was born. When styling become larger than HTML could encompass, CSS was born. When interactions wanted to be built in, JS was born, etc. Otherwise you can get into extended discussions about why the front-end environment is the way it is. In cryptography it's the same way. By following the history you can see the mistakes of those before you, and thus avoid those mistakes. Crypto is all about the cycle of making a new algorithm then having it broken, and the arms race that it causes. History illustrates common pieces of advise, like to avoid security by obscurity, and history also shows why perfect forward secrecy is needed. It shows the need for key exchange, and shows the relationship between unsolved math problems and crypto. All of these are great reasons to teach crypto in chronological order, from the oldest discoveries to the newest. I would guess that this sense of parallels between the order in which things are invented and the order in which things are taught exists in other fields as well, and so teaching history along with the normal coursework could be very useful. 

A good way to talk about algorithms is as a series of simple steps that can be repeated. It's similar to the role of a function or routine. Here, everyday examples can be helpful, for example something like autocorrect. Autocorrect is a series of steps repeated over and over.