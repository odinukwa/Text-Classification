You should now have enough knowledge to create an Option 2 style walk, if you think hard enough. This is why we seal algebraic data types so they cannot be extended. My size function knows that the answer will always be 0 or more, because there are only two CrockPotTree types and they both return a proper value. If some idiot added an new case class which returned something else (null, for example), things could explode. 

Minor point - don't use an old c-style for loop to iterate through an array unless you absolutely have to (and you don't have to here). Please, this is 2013 not 2003 - generics have been here for a decade. You can use foreach: 

You might consider adding classes. You have many broadly similar elements on that page; adding classes to them would give you more flexibility in your CSS. As things stand, you can only apply style to elements based on their id, their parent elements or their type (and hey, they're all DIVs). I would use an identifier other than body, for clarity and to avoid any possibility of error/confusion. 

Take the smaller of the input lists and create a map of values and their number in the list, as in your code or mine. Filter the larger list to remove any items which are not keys in the map generated in step 1. Create a map from the larger list. Iterate through one map comparing its counts with those in the other map Proceed from here... 

Of course, what we both really want is a way to minimise traversal. Scala just doesn't make that as easy as I'd like. But does mean only 1 traversal, with no new build, both if the value isn't found or if it is already at the front. It also means equality tests are only done on one traversal, not two. After a little more thought, I came up with a variant of the above solution which really only iterates just once. But it may not be future-proof. 

If an Option contains a value, map unpacks it, applies the function and wraps the result in Some. If it contains None, it simply returns None. I don't think I need to explain getOrElse ;) Using fold 

Using higher kinds makes the upper bound go away while leaving the messy details of building to Here's one way to do that using Iterators for efficient space usage and gc and for their laziness. 

then will return . However, will not work, because has no method which takes a parameter. This can be fixed by creating an Int-wrapping class which does have such a method and creating an implicit conversion which can turn an into such a class. To make this magic optional rather than an unexpected surprise, put them into a companion object, thus: 

Using the iterator this way means only one traversal of the collection. It works because, when forced by the assignment to the builder, has to examine the first element which does equal . And any Iterator operation which fetches the next element discards it after use. So this does work with the absolute minimum of traversal and good economy of space. I just have a feeling this may rely on an implementation detail that might change. I will ask around. EDIT: Using anything other than and on an iterator is considered not safe as the state of the iterator after any other operation is considered an implementation detail. But hey, here's an even simpler version: 

Your code is structured only around months, so has to use conditional logic to create your rows. My code is structured around rows (and within that around months), so needs no conditionals. My code also only has the value for the number of months in one place, which is less error prone and makes it easier to change the number of months in a row. You don't have to use a list comprehension, though. The important thing is simply to slice the list up into groups of 3 (or , where is the number of months you want in each row) and iterate over those. 

Improvements The first point can easily be addressed with iterators, since you only need to traverse each range once. As to the others... You could look for a way to start at the top of the range and work down, in such a way that each iteration tests the next lowest product of two 3-digitnumbers. If you could think of a way to do that recursively, you could safely return as soon as you found a palindromic number. But consider this: 

How would I add a value to a node where left and right are empty? How would I add a value to a node where right is empty? If neither left nor right is empty, on which of those do I call the add method? 

The name of the CreateDefaultParameters becomes entirely honest. (Although SetDefaultParameters may be a better name). The code in that method becomes clearer Separation of higher level abstraction from lower. Clarity and simplicity at the higher level. Adds flexibility extensibility. 

Then our function returns an output which allows folds, recursion and other iteration over the list without having to remember our position in the list but still allows us to know whether the elements passed or failed (without having to reapply the predicate or even remember what it was). It also allows higher order functions (filter, map etc.) to be applied either selectively or to all iterables in the list. 

I may not have understood how the count is supposed to work, but I think the general idea is clear. Note how I split your final case statement into two by turning the condition into a guard - it's tidier, I think. Note also that if an entire function is one big pattern match, you don't have to wrap the match in braces. To be fair, nothing about 

janos's answer is entirely correct and I can add nothing to his reasoning about which method is superior. I was intrigued as to why you would want to try the second one at all. I suspect you want more concise code and to avoid the if control block. A more concise version of your first method can be done without the drawbacks of the second: 

I'm going to concentrate on the Scala rather than the maths side, because that's my area. The internal helper function doesn't need two parameters, since the value of x never changes; pushing x repeatedly onto the stack is a waste of time. Also, better to use a case statement than a chain of - much less error prone. 

This is the benefit of the functional approach. I have no code duplication at all. I just apply one function to the output of another, in sequence. This makes it