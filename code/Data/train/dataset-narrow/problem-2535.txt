hqx is also a popular choice as code is very easy to find for it these days, and it's fairly high quality. The state of the art includes xbr and Kopf-Lischinski. These scalers are commonly found in console emulators, some of which are open source so you can easily take a look at how it's done. 

To do server reconciliation, you not only need to know what the client inputs are, but when they were made. That means when the player sends "pressed space", you need to know when that input was actually made. An easy way to do that would be for the client to send it, i.e. "pressed space on step 3". You could also guess on the server side, "the client is approximately 2 steps behind, so when I receive a press space on step 5, it actually happened on step 3". Each method has its merits but the important part is that you figure out when the commands happened. Once you have that, the server needs to be able to apply commands that happened in the past. When this happens, movement will become discontinuous for the server and other clients, but at least the positions will be synchronised most of the time. When you have multiple clients, you also need to deal with the possibility of paradoxes, i.e. if two clients both want to travel to the same position, but due to the effects of latency, none of them think they are running into each other. As the server you'll need to decide what happens, one way or the other, and tell the client(s) "nope, due to a collision in the past, your current position is actually here". But without going too deep (and it goes pretty deep), here's what things would look like, in a table: 

Here's something to get you started; for organic structures such as caves I've found that random walk works fine, and it's great because it's dead simple. This sample code does the following: 

This task can be surprisingly difficult in general; it is a variant of the Art gallery problem, and just like that problem, it is made dramatically harder with even slight complexities in the geometry. But if you're willing to accept a flawed, "good enough" solution, here's one: leave a "vision trail", and assess whether there is only one exit that is not next to the "vision trail". 

In most games, bullets are removed from the game once they hit something, so they don't have this problem. There are two situations where this problem crops up: 

Many sound effects have a dominant frequency, especially for artificial sounds (UI, "powerups") and short effects that get repeated (machine guns). Whether by design or accident, these sound effects could be in tune with each other, or with the music. My questions are, does this matter at all (in games), and if it does, what effects does this produce? When would one purposefully create harmonies, disonnances, or avoid such effects altogether? In music theory, the effects of consonance/dissonance is well known, one of which is that notes in tune with each other are pleasant, and those that are not are unpleasant. But what about in games, does it matter that, for example, the laser gun you are shooting is in tune with the music? At least a few well known games have harmonic sound effects, and although it may be deliberate, I'm not sure if it's a purely subjective/artistic choice, or whether it was designed to evoke specific feelings from the player. One notable example is Candy Crush Saga, whose match effects are all part of the same major key as the music: $URL$ Another example is Super Mario Bros, in particular the 1-up sound effect: $URL$ although other powerup effects like the coin sound are not in the same key, for whatever reason. At least one sound designer seems to think this is important: 

How can I convince people that PVP permadeath is good? You can start by pointing to examples of very successful games that have them. Keep in mind that they're not everyone's cup of tea, and different people have different thresholds for what they deem fair or acceptable. The Bartle Test is one way of looking at this: PVP permadeath greatly favours the Killers, which is necessarily at the expense of others (mostly Achievers), and different people like different things - not everyone is a Killer. A lot of people also won't find permadeath from other players acceptable or fair, but that's simply because people have different thresholds for fairness. One player's "unfair" is another's "that's just part of the game", whether that's an inconveniently-placed obstacle, a ruthless RNG, or player killing. How can I find some other way to make death and violence matter as much as it does in real life (without permadeath)? There's a range of punishments you can mete out, up to and including permadeath. Any kind of loss (XP, property or time) can be drastic and hence meaningful. Unfortunately the "death matters" that you want requires punishing the player, since only the fear of death (or great loss) can produce that kind of trepidation in normal gameplay, and the power-tripping satisfaction of having caused loss to another player characteristic of Killer types. Simply rewarding killers without punishing the killed won't produce these results. In the same sense, I don't see how punishing killers can be productive, since it removes the utilitarian motivation for killing and only leaves the purely sadistic. Finally I want to point out the futility in making a game "like real life". Real life has permadeath, but it also has no restarting. That is what really makes life and death matter in real life. 

This indeed should be very simple, so I suspect you may have gotten some details wrong. The overall goal is to match up the center of the camera with the midpoint of the players. As you've found though, those values aren't immediately available to you, so you need to work them out. What you might have are (leaving out the Y axis stuff since we don't need them): 

When and how can I use the likeness of real people in my game? What are the legal restrictions involved? Real people are rarely found in games because it's hard to present them tastefully, but they have sometimes appeared when the setting was suitable. Games have featured the likenesses of historical figures such as McNamara, Hitler, Kim Jong Il to take a few examples. What factors affect how I can use these real people? Whether they are living? Whether the depiction is entirely factual? Do any disclaimers need to be used? Does it differ significantly across jurisdictions? 

Again, simple is probably best here, and most games solve this problem in simple ways. Nevertheless, here's some examples of (very elaborate) schemes for you to think about, not only what they did but why they did it: 

Yes, this is not only possible, but available now: hook up your game PC/console to a TV that uses motion interpolation. Opinions vary, and this is less suitable for twitch games like FPS due to the interpolation lag, but for upscaling frame rates from 60 to 120Hz it works fine. As for whether this can be done in the game itself, there's not enough impetus yet, in that most monitors can't output those high frame rates. 120+Hz monitors for computers are less common, although judging from how TVs are going, this may happen soon. Having a high refresh rate monitor has advantages even if the game can't reach those frame rates: besides the aforementioned TV-based motion interpolation, it can offer smoother frames if the game is allowed to output frames as they are ready, instead of synced up ala v-sync. Once 120+Hz monitors are commonplace, I expect game developers to catch up and start using more tricks, including motion interpolation, to reach those high frame rates. 

This is intentional, because making levels important is not the goal. Usually for RPGs there are two conflicting design goals: to give players freedom in how they play (and therefore how much grinding/side-quests to do, and hence their XP), and to make sure the difficulty of the game scales predictably for the length of the game. You don't want to make the game too easy for those that complete all the side-quests and earn as much XP as possible, but you also don't want the end of the game to be impossibly hard for those that are rushing through. A common method is to make the XP between levels to grow, so for example 100 XP missed may matter a lot at lower levels, but at higher levels it makes no difference. What you're describing is simply another method of achieving the same aim; by making stat growth diminish in percentage terms, the difference between levels also diminishes. Compared to the former, the latter has the advantage of still giving the player regular level ups (which players tend to enjoy) whilst maintaining the difficulties of later stages of the game. Usually RPGs use a bit of both techniques. This is in contrast to, say, MMOs, which have a number of reasons to use more of the former than the latter, such as: 

I think your code has two problems: incorrect X-coordinate bounces, and tunneling. First the X-coordinate bounces. This code: 

is trying to reflect the ball in the opposite X-direction (I think), but all it's going to do is rotate the velocity by a fixed angle. You could fix that by doing the proper arithmetic, but I encourage you to try reimplementing this using vector math instead of using angles. This makes axis-aligned bounces much simpler. Bouncing: 

This is a very low level implementation detail, given there are very loose requirements for this kind of stuff (loaded once during game startup, only the game needs to parse it, it's plaintext so very little data). The default answer for this is whatever you / your team are most comfortable with. Having said that, I'd consider JSON a little bit better: 

Usually levels are used for many of the above reasons, but you may have noticed a common thread: levels encompass a unit of content, a self-packaged experience meant to be consumed as a whole. That isn't to say you must consume one unit of content at a time, but usually you (are encouraged or compelled to) finish playing after the end of a unit. Units of content occur in many places, outside video games too, and there are many ways artists/authors encourage audiences to consume these in units. Books have chapters, and readers often - if they have a choice - stop and start reading between chapters. TV series have episodes, where each episode covers a self-contained story, sometimes within a greater story arc. Some media have only one unit of content, for instance movies are best enjoyed in a single sitting. So it is with games; some have lots of small units of content, e.g. Angry Birds. Some have a single large unit of content, e.g. Civilization, where you are never encouraged to take a break until you've finally conquered the world, some 20-30 hours later. (Some days I think Sid Meier isn't aware that his players need to sleep.) I believe the question "how many levels should I make" is better answered if you split it into two: 

Although this is just one opinion; I'd like to hear from those who have experience with professional game sound design to weigh in, is it something that sound designers generally worry about, and if so, when would one want to have sounds that are in tune, out of tune, and what the effects are. 

No slopes (the Mu answer) When it comes to gameplay, I'm a fan of minimalist design - as the saying goes, "perfection is finally attained not when there is no longer anything to add, but when there is no longer anything to take away". Do slopes serve a useful gameplay purpose, or do they just look good - i.e. are they fun? After all, it's perfectly fine to have a runner with no slopes at all. 

Arcade physics, unlike P2 and most other physics engines, is a very simple and simplistic system. The former will use a lot of lay terms whereas P2 will use terms plucked straight from a physics text book. Switching between the two is not trivial; you'll need to relearn a lot of stuff. I highly recommend the P2 examples page to get a grasp of what P2's features are and how to use them. To answer your questions: 

Good luck with P2, take it a step at a time because it (like most physics engines) have a bit of a learning curve. 

You say that you have problems with 1x1 tiles. Why not simply remove them, say by turning them into the same tile as one of its four immediate neighbours? 

Then the choice is not always so obvious, as you need to formulate an effective strategy to pick the best move. For example, in the above example, the choice is not obvious: A may choose A2 since it maximises the minimum expected payoff (-1, when B1 is played), but knowing that A will play A2, B may play B1 to realise the -1 payoff, but knowing that B will play B1, A may play A1 to get the +3 payoff and so on. 

From your description, it sounds like the function will suit. Its output accelerates from start to end, but then bounces three times. 

The solution is simple: draw all the tiles (and anything inside them, such as players) in top-down row order. You could of course do the same using z-index - anything on tile row X will have z-index greater than tile row X - 1. I believe your conundrum is due to drawing all tiles first, then all players. I suspect you also simply use the Y coordinate as the z-index. This is reasonable if there is no elevation in your game, but as you've found, it causes issues when you have elevated tiles. Instead, you should draw tiles and their contents together, in top-down order or by doing the same using z-index. 

This is going to depend on your game and what you're going for. Until you can answer that in detail, it's best to keep it simple, and tweak once you see issues. The only thing I'd pre-empt is that with user-generated content, you want to curate it. You might maintain a collection of pre-approved maps that are allowed in random match-ups, unless the participants opt out. You might allow users to specify their own blacklist of maps. When picking a map, fairness is not the only concern! Here are some things to consider: 

What you are looking for is Rooted Tree Isomorphism, which is a specialised version of the Graph Isomorphism, except for trees and the root node is fixed. The explanation given in this assignment uses two properties: 

Unfortunately, classic force-directed graph layout algos don't resolve edge overlaps well. Fortunately due to its dynamic nature, it's sensitive to initial conditions, so you can run the algorithm repeatedly until you get a nice result. 

AFAIK standard procedure is to have resources stored in a map-like structure with strings as keys, since it's extensible as you've seen. However, for the core game elements (especially the performance-critical ones), the resources will be explicitly linked instead of involving a key-lookup, thus skipping the lookup overhead. For example, you might have a that you render by drawing a . Initially you might lookup the sprite by using the string then rendering it, every frame, but to make this more efficient, your pony will hold a reference to the sprite directly. Your pony might look something like this then: