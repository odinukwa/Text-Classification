As shown from your , InnoDB is present. XtraDB is also present. If you want to be sure, you must run . That will show what storage engine is the default. The fact that the XtraDB plugins are active shows that XtraDB must be in use. 

No, it does not export indexes. Indexes are rebuilt upon loading the mysqldump back into mysql. The options you found "--disable-keys" cause the the mysqldump to write something like this before the table's load via INSERTs: 

I have a working theory (LaForge would say to Capt Picard)... Since you are using MySQL 5.1, you have access to the table INFORMATION_SCHEMA.PROCESSLIST. You also have access to the ID of the current process the trigger is running on. The function to get that process ID is CONNECTION_ID. You could try to fish out the query like this: 

There is still an active bug report for MySQL 5.6.20, 5.6.22, 5.7.6 on this. The performance schema is enabled by default in MySQL 5.6. Therefore, the only solution, at this time, would be to disable the performance schema. You would have look for future releases to see if this has been resolved. Personally, I would not worry about this. It seems to behave like MySQL Replication's I/O and SQL threads. Those threads poll indefinitely. Log recovery of this nature would happen during MySQL startup and should not be polling after MySQL Startup and InnoDB Crash Recovery have completed. If the bug simply left the state unchanged and nothing is going on, you could go on using MySQL as usual. To verify this, please do the following: STEP 01 : Look in the error log and make sure 

Just from the name of the parameter alone, , it is a query that resets the server in some way. From the definitions and examples I have seen in google, yahoo and postgresql.org, it seems to be a directive that issues one or more queries for recycling connections and associated resources. IMHO there does not seem to be a lot of explanation behind this directive except to see examples of its usage. Such examples include: 

ANSWER TO QUESTION #4 You may have to shift character sets with the DB Session. Here are the settings that can be changed at the session level: 

If you do not have this, add it and restart mysql Question 2 Would the resulting bin-log in db2 be exactly the same with the bin-log of db1, to the letter? Answer to Question 2 Yes. Make sure the clocks on both DB servers are synchronized Question 3 What happens to the entries in db2 relay-log once they are committed to the database during the replication process, are they discarded? What role does the relay-log info log has in this? Answer to Question 3 In MySQL Replication, the IO Thread of a Slave will read its Master's bin-log entries and store them in a FIFO queue. For each relay log in a slave, when every entry in the currently processed relay is executed it is rotated out and discarded. If relay logs are piling up, this quickly indicates that the SQL thread died because of any SQL error. Just do to find out what stopped the SQL thread. The IO Thread would conitnue collecting completed SQL statements from its Master. Question 4 How does db1 know where in the bin-log of db2 (somehow dependent on the answer of Question 2), it will start the replication process? Answer to Question 4 When you do , look for the following lines: 

EPILOGUE While running , new rows of data have been added to your table. When you run , it gets those extra rows, adds them, and swaps them. Your downtime should be like 5-10 seconds. When done, your new table will be live. The old table will be called . When your app is writing data cleanly to the new devicelog table for a couple of days, you can run GIVE IT A TRY !!! NOTE: You will need an event to auto rotate old partitions every day 

For the sake of simplicity, I recommend MySQL Circular Replication only. Here is why: There are many technologies and topologies that are far superior to MySQL Circular Replication. My favorite, hands down, is DRBD (Distributed Replicated Block Device). However, DRBD works great when the Server Pair is in the same bulding, data center, and rack. It's even better when using a crossover cable in the 192.168.x.x. subnet between the DRBD Primary and DRBD Secondary. Unfortunately, DRBD has horrible performance over a distance between two locations, although DRBD can still work. There are no network topologies around to give you the satisfactory DRBD performance needed between two datacenters. Once you setup MySQL Circular Replication between the two DB servers in two different data centers, the only tuning needed is for the network. In essence, the replication performance is a function of network settings (speed/latency of binary log transmission in MySQL Replication Setup) and disk I/O (DRBD). An alternative you may want for better redundancy is the following for the sake of example: Setup a DRBD Pair in both locations DRBD Pair in Site #1 with VIP 111.111.111.111 DRBD Pair in Site #2 with VIP 222.222.222.222 Setup MySQL Circular Replication between the DRBD Primary Servers under these conditions: For site #1, use 222.222.222.222 as the Master_Host in MySQL For site #2, use 111.111.111.111 as the Master_Host in MySQL Although introducing a level of complexity, now you have two levels of redundancy: DRBD within each site and MySQL Circular Replication between sites. You have the additional benefits of running backups via mysqldump on the DRBD Primary of the hot standby server. As for failover, DRBD provides automatic failover at any one site. Only in the event that a datacenter is totally unavailble would you using the DB VIP at the hot standby site. UPDATE I just did a double take and noticed that you are using Drupal6. I am glad you will be converting all the drupal tables to InnoDB. This will remove any chance of MyISAM table updates causing table locks to freeze DB Connections that are simply reading MyISAM tables. Any DML update (INSERTs, UPDATEs, DELETEs) against a MyISAM table WILL ALWAYS DO A FULL TABLE LOCK !!! Using InnoDB will introduce row-level locking, which eliminates full table locks. In addition, DRBD becomes your friend when everything is InnoDB because crash recovery will be consistent between the DRBD Pair. Contrawise, DRBD with MyISAM buys you nothing because a crashed MyISAM table on the DRBD Primary is simply duplicated to the DRBD Secondary as, you guessed it, a crashed MyISAM table. UPDATE #2 You should use two levels of redundancy Level 1 : At each database center, use DRBD. $URL$ Set up a pair of DB Servers Startup DRBD Startup MySQL on the DRBD Primary This creates redundant data at the disk level. Level 2 : You should setup MySQL Circular Replication between the DRBD Primary of DataCenter#1 and the DRBD Primary of DataCenter#2 Each DRBD Primary will be running MySQL and will act as both Master and Slave to Each Other I have setup for clients topologies like this and I consider it quite stable. 

What I am about to say would be rather crazy but entirely possible. Here it goes... CRAZY SUGGESTION #1 

Sounds like an issue with MySQL Workbench. MySQL 5.5 has a default storage engine of InnoDB. In fact, the option default_storage_engine is predefined as follows: 

Log out and login to MySQL and you should notice the difference NOTES If you are logged out, you have to come back in an hour and try again. If you can't wait one hour and you can restart mysql, you could enable 

Give it a Try !!! UPDATE 2014-11-03 16:05 EST If the ping_results table has an column, you could probably redo the query using JOIN 

CAVEAT Make sure you build an index that involves the columns deleted, visible, and date_created as follows: 

That's all I can suggest. Since routines and triggers are preloaded, this suggestion may not yield any additional performance. You can try anyway and please with your findings. 

From the question, it looks like what you have written quasi-resembles what Oracle calls an anonymous code block. MySQL does not facilitate such a mechanism. With regard to what you want to accomplish, you do not need a stored procedure. Try assembling the SQL statement like this: 

YOU HAVE NO DISK SPACE !!! Get more diskspace freed up or have increase diskspace. According to MySQL 5.0 Certification Study Guide 

Some online DDL may still lock and copy because of an index's interaction. Don't forget that each BTREE entry in a secondary index has a hook back to the primary key. Adding a new secondary index may induce row level locks and index locks. REASON #2 According the limitations page : I am sure there are other reasons that can be researched an discussed along these lines. 

As for scaling out to data centers, you have the option to create read replicas. Since the default storage engine is InnoDB, making a read replica becomes seamless because data can be sync'd to Slaves without interrupting the Master. Higher Server Models means you can have more Memory, more IOPs. Don't forget the cliche I mentioned because when it comes to Amazon RDS, with GREAT POWER COMES GREAT MONEY. 

You will then just restar mysql. To put this new setting in place without restarting, just run this command in the mysql client: 

That way, the scan will be from index, starting from the last time an was inserted. GIVE IT A TRY !!! 

It will simply say . That means you can connect, AND NOTHING ELSE !!! When you login as , you must now explicitly tell mysqld to give grant privileges at various levels. EXAMPLES This will let jeffrey do everything except give away his privileges 

Give it a Try !!! UPDATE 2011-10-26 12:43 EDT Perhaps you may want to try masking the domain as follows: 

I think you mean Arbitrator (See the subheading ). It is a mechanism that helps decide who plays the role of donor and who play the role of the cluster when introducing node back into a Cluster. It helps with mitigating split-brain scenarios More can be found in the Galera Documentation. 

Stop replication to the RDS Slave As root@localhost run this on EC2 : Start replication to the RDS Slave 

It needs a content context (if that makes any sense). Anyway, when you tried to evaluate , that gets processed internally as evaluating , which of course, is with the row coming into existence, followed by making a comparison with a non-NULL value of . Since the expression must evaluate as , you essentially did this: 

You cannot make that kind of approximation work if the InnoDB table experiences DELETE and UPDATEs. With innodb_file_per_table enabled and a table called , this is what you get 

Instead of lots of INSERTs into your table, try putting all your new data into a CSV file and use LOAD DATA INFILE to mass populate your production table. You should disable keys before loading and enable keys after the new data is loaded. There is no need to optimize table doing these things. You may want to run analyze table instead. That will update the index statistics on the MyISAM table. I hope these suggestions help !!!