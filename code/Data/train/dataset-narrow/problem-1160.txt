"Input" represents the source of information. In your case it is the keyboard input "Output" represents where any information or result will be published "Calculator" represents... what should I say... the "main"-method puts it all together in a sequence 

Your UI should implement this interface and register itself as a callback in your "business logic" (thats not really true as it is the use case layer). Then you UI gets notified and you can process the proper UI modifications: 

Your original code is the best to start with. There is only one little issue. I would not expect to have the logging before the throw clause. And that is because you may introduce unneccessary redundant logging in the code that will catch the exception. So the right point to log is when the exception is caught. 

A very clear answer in THIS case of LAZY INITIALIZATION: No. It may be a case of preemptive optimization. But that is not the reason I would prefer it. The reason why I would do so is: If you only use lazy getter-methods within or from outside your object/class you make yourself independent of the order of object creation. You use the getter and you get an object, doesn't matter if it was created before or it was created right now. This is especially useful in component trees. You often play around with the position of an ui element in the ui component tree. A lazy getter saves your ass and time. After all ui components often are heavy and even if they are not you get the optimization for free. 

Is this a correct implementation of the data-structure, or do you see any flaws? Is there a way to make the implementation more optimal? (E.g. is there an elegant way in to jump out of the if we encounter a bit not equal to ?) Related to the above: is there a way to make this code more idiomatic? (I.e., conforming to Clojure best practices.) Can you think of any missing tests? Or some other edge-cases which are not covered? 

I especially like the point of @Mike, namely that you should generalize your code. I would suggest taking this idea one step further, by having the situations and the choices in some data structure (e.g. JSON) and having only a single div, where to render the text and the corresponding choices (as opposed to one div per situation). To be more concrete, I am thinking about something like this: HTML: 

Discussion: first of all, please note that the above code is rather a proof of concept and not a full solution. Besides the missing effects (which you can add if you choose to extend this example ;) ), it can be improved in many ways (e.g. not putting game state and functions into the global namespace, but rather enclose them in an object). That said, let me point out the advantages of this solution: 

Alternative While the recursive approach is elegant and easily understandable, it might be less convenient for very long inputs. I suggest another solution, based on the idea, that if you want all permutations, then each character can either be part, or not be part of a permutation. This gives us 2^N possible permutations, where N is the length of the input. So, you can just generate this number (2^N), and then iterate from 0 to 2^N-1, and calculate the corresponding perm. for each number. So, if the number is represented as binary digits, then 1 means that the character at the corresponding position should be part of the permutation, 0 that it should not. (If you do not need the empty perm., just start the iteration from 1, instead of 0.) With your example, 'AA2', this would work as follows: N=3, so iterate from 0 to 7 (=2^3 - 1). 0 corresponds to the empty set. 1 = 001b, so '2' is part of the permutation. 2 = 010b, so only (the second) 'A' is part of the permutation. 3 = 011b, so the perm. is A2, etc. Remarks: 

This is easy to answer: The Exception does not belong to your problem domain. It is not "your" exception. So its use is not appropriate. Another point to mention is: MissingResourceException is used when the code would expect a static resource provided by a deployment or packaging. Resource-files may be somthing like images or i18n-files. Furthermore configuration-files and everything that is expected to be available in a static way. So your use case does not match the proper usage either. My suggestion is not to reuse java exceptions that have special usages within the java language unless you are working on the same "abstraction level". You should inherit your own exceptions from "Exception" or far better "RuntimeException" (not signature relevant) and match the exceptions to YOUR problem domain. Everything else is misleading and you have a hard time to identify the proper exception for YOUR context. I do not think that it even exists because of the different abstraction levels. JAVA Exceptions deal with the JAVA language semantics. Everything you do as a developer is nearly always on a higher abstraction level. JAVA Documentation: $URL$ $URL$ 

The Jackson way is "mapping by name"-convention. Your keys must be named like the attributes of your JAVA Object that should follow the bean convention. The central clas is the ObjectMapper you have to instantiate: 

Value objects Value objects are creating their identity through ALL values they own. If they differ in only one value they can be considered as different. Value object should also be immutable. Business objects Business objects do have an identifier and a type to recognize in equals. In hashcode you should at least recognize the identifier. The type is optional. The identifier is used to identify the object uniquely. The type preserves the knowledge of the object's behavior. Business objects preserve identity and behaviour but allow little mutability that is encapsulated (object orientation). You may ask if two business objects are equal even if they differ in other attributes than identifier and type? Yes they are. Think about yourself: Even if YOU change your name, you remain the same as before. Your identity is different from your attributes. General Both object types have one thing in common: They are globally unique independent of the system border and they preserve their identity under every circumstances (the identity is immutable). And that is one purpose to override equals and hashcode. These two object types also related to each other: business objects communicate with each other through value objects (messages). Here it doesn't matter if business objects communicate system internally or beyond the system border. Thats the second and the last purpose. Other objects If you have other objects that should not exit the system border (the JVM) then there is no necessity to override equals and hashcode. And no neccessity means you shouldn't do it. Furthermore you can consider it as a broken design if you need to implement equals and hashcode within the system borders as the JVM provides object identity from scratch. That would mean that you may instantiate the "same" object at independent locations in your source code. That at least violates the single responsibility principle. So if you think about implementing hashcode and equals on other objects than business objects or value objects you are nearly sure to be on the wrong path. You DEFINITELY exit the path of object orientation. You can do so but you will end up with a different programming paradigm (functional programming, only values and functions) in the best case. If you do this not strictly then you get an hybrid that will own the advantages of both paradigms but the disadvantages as well. The problem is that the assertions of on paradigm are the harm of the other paradigm and vice versa. You inherit missing encapsulation from functional programming and you inherit mutability from object orientation. So effectively you only get disadvantages. So you see: Your decision has deep consequences if you do not follow it consequently. If you implement equals on every object, the attributes on which these methods base on mustn't change as hash-related collections are working with it (HashSet, HashMap). If they change after adding them to such a collection the objects are not predictable accesssable anymore. If you implement hashcode and equals on all objects you you win immutability on all objects and functional programming in the whole. Conclusion Be carefull with this decision. Think about what kind of programming paradigm you want to follow. At least for ONE module you should decide between OO or functional programming as one paradigm will eliminate the advantages of the other paradigm. 

N.B.: I am not familiar with Processing in detail, but since from the question I understand that 'drawDigit' is an own method (i.e. not built in to Processing), I assume, that it is possible to introduce other own methods in a similar way as in Java. Functionality I do not understand, how the seconds will be rendered correctly. As far as I see, this is the only part that depends on the seconds: 

But as I understand, this code does not show any digits, just fills a space with a colour. Is this the intended behaviour? If so, then I suggest documenting why is it like that (in a comment), otherwise, I propose to extend the functionality so that seconds are rendered as well. On a side note, I recommend to use always the block-form of if-else statement (and any other statements), even if it has just one instruction per branch. In other words, I suggest rewriting it as follows: 

Leave it as it is: all output is shown, some of it might be on the wrong place. Overwrite the the end of the first string with the second one (i.e. ). Overwrite the beginning of the second string with the first one (in this case: ). Throw an exception. 

For the refactoring, I suggest that you should wrap the logic of the for-loop into a do-while loop. Something like this: 

So, I am asking if there is a better way, to compare two sets, providing a custom function for equality checking (in this particular case, this custom function would be ). I am thinking of something like this (pseudo-code only): 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

I think if you continue this path you violate the "interface seggregation principle". Try to separate the interfaces. Going with your semantics I expect interfaces like ParameterAware or Storable. Then you won't get into such a semantical trouble. As you have less semantical problems with your interfaces you will face other challenges that have to do with the implementing classes and your algorithms using and working with these seggregated interfaces. But you cannot escape it and the effort and it is justified. 

According to Wiki "a god object is an object that knows too much or does too much". The general problem I have with this is: What means "too much"? Your question is about searching an absolute statement as we already know we can only find absolute statements within very restricted areas (and that's what they all have in common) that are not related to reality. As soon as we deal with real world applications we have to deal with uncertainty. That is because we derive OO models from reality as we perceive it. And this can be error prone. To escape this dilemma in computer science some principles are discovered that lead to a step by step improvement of source code. They are called S.O.L.I.D. principles. If you violate a principle your source code becomes worse. So the target is to violate the principles as less as possible. So easy as I say it: The violation of these principles is an identification problem that sometimes becomes very very difficult. In the case of the so called "God class" the "S" of these principles is addressed: The single responsibility principle (SRP). It says that one code fragment (module, class, method) should only have one responsibility. BTW this is applicable to other programming paradigms as well. A "God class" seems to have at least more than one responsibility. That can be said for sure. Anything else is popular speech if someone says "God class". So working with SRP your code will improved step by step by identifying violations of this principle and eliminate them. That is by consolidating redundant responsibility and vice versa by separating different responsibilities. But the whole thing only works if you identify the violation. And that's the core. To identify a violation you look for indicators: 

Note that by having the constructor throwing an exception if the file name is invalid, we prevent the object from being used in an invalid state. The reason is, that (in our example above), we cannot use the object after this line: 

For the second part, I suggest factoring out the mapping logic from inputting the date (or at least, the date should also be read in the function itself -- but receiving it as a parameter, and then reading it again is very messy IMHO). So this would look something like the following: 

Objectives of this review While any suggestions/remarks are always welcome, below are the points which I'm mostly interested in. Implementation 

Background Linked lists are a well-known data structure, so I won't waste too much detail on them. Suffice to say that a linked list consists of "cells". Each cell contains some kind of value and a reference to the next cell (except the last one, which contains an empty reference). I implemented a linked list in Clojure as an exercise. The code 

This will return . However, is misplaced here, because it should be at position , and it is, instead, at position . To be honest, I don't really know what would be the best solution here. I can imagine the following: 

Further remarks: Robustness I recommend some extra checks to your program, to make sure that it is robust to potential wrong input: 

As I said above, I'm not saying that this suggested change is necessarily better than the code you have now (in fact it is a bit more over-engineered). It is rather a way of exploring how to further OOP-fy your code. Test Code Let me first say, that I find it a really positive thing that you write your code with testing in mind, and add unit tests to cover (almost) all the cases. That said, some remarks: 

I do not recommend this. Any pending or working thread will be aborted. If this is your intention then you have no well-defined shutdown as the threads may be in an arbitrary state (writing to harddisk, communicating with remote services etc.). You will also hide programming errors if some threads have corrupt shutdown mechanisms. So make sure to notify running threads to shutdown if you want to exit the program. The following Swing configuration for a frame will disassamble the UI and exits the JVM if no other frame exists: 

map the Exception to an exception of YOUR domain make the Exception signature irrelevant (RuntimeException) 

Naming I think "DogMapper" is quite good with the name. What your are doing is you are transforming a relational representation of a Dog to an object in the sense of php. In Java this is called Object-Relational-Mapping. Getter and setter Getter and setter introduce an indirection that allow you to perform additional actions. But doing this the things are getting complicated. Mostly you will violate the Single Responsibility Principle because your getters and setters should only do what they are telling. It depends on the type of object. In Java we call "objects" that have setters and getters for all their attribute "Beans". They have little assertions to consistency. As setters may put your Beans into an inconsistent state you should think about it if you want to allow this. If you do not want to allow this your Dog-Class seems to be a "Business-Object" or a "Domain-Object" that holds its internal state consistent. Setters in Business-Object will evaluate the input. And Getters of Business-Objects may do more than simply returning a the value of an attribute. They can do calculations or load data. Mapping You DogMapper-class seems to me like a DAO. A DAO will access the underlying datastore and pass an object with a proper representation to the upper layer. Semantic The question is: Should your Dog-Class be a "Bean-Object" or a "Domain-Object"? My personal opinion is: Separate the concerns of the Object-Relational-Mapping and the business logic and do not put all the burden on one object. So you have three responsibilities: 

With the current implementation, this will return an empty result: . Now, with the semantics that the name of the parameter implies, this should be correct (maybe an exception could be thrown, but that is only detail). However, wouldn't it be nice, if the signum of could control the direction, in which the first coordinate grows? Something like this: 

OOP changes Since you are exercising OOP (and don't mind some over-engineering ;)) , you could consider adding another , for dealing with the case that no prime factor matches (e.g. ). This would require the following modifications 

I implemented a Trie data structure in Java, to test my understanding of the concept. I tried (pun intended :) ) to follow TDD steps along the way (i.e., add first a failing test case, and implement functionality after ensuring that it really fails). I'm posting here the end result. Besides the implementation itself, I'm also interested in the quality of the tests. I'm mostly interested in the following aspects: 

In this way, the result of the above example will be: . Of course, it might be worth considering to rename the parameter, e.g. to or something similar. P.S.: I setup a github repo for the above mentioned changes, and their corresponding test cases (along other tests): 

If I understand correctly, the program counts the occurrences of some words in a file. I have the following observations: Error handling I would recommend throwing exceptions instead of/additionally to writing to cout and cerr (btw., I think if you do write to these streams, you should stick to one of them, most probably cerr). EDIT: Note, that as the constructor is written currently, we can end up having an object in an invalid state after calling it. This would be prevented by throwing an exception. Encapsulation, state of the class I suggest making setWord private, or at least protected. As it is now, one could call: