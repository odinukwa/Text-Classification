You can run your IO on background threads that just waits for a full wellformed packet to come in, and then puts the data in the packet into a queue for the main processing thread to process. The main thread can run in a small while loop like: 

Write a ring 0 driver that hooks SSDT and logs / blocks when ReadProcessMemory / WriteProcessMemory is called on your application. It'd be better to just log so you can slowly change their game behavior over time rather than just crash. 

The reason is without custom hardware there is no way to be absolutely sure that the function is called at the exact same interval each time. If it's a PC game, what happens if someone has a slower computer than you expected? Or a faster computer than you expected? Or just Alt-tabbed? If it's a phone game, what happens when a new version of the OS comes out? etc... Instead you follow the guidelines there, determine a target frame rate, if you've fallen behind update now, if you're ahead, sleep until the targeted frame rate is reached. The update functions take a delta time so that you can interpolate between the desired time and the actual time. 

Unless for some reason the possible content changes at Runtime, choose whatever format you want for content creation (And since you already have XML up and running, stick with that.) then as part of the game build step pack it down to a binary format that your game can understand. This reduces the time and memory footprint needed to handle text processing, while you can still keep the content mergable in your source code control provider. And of course share the code between the tool writing the binary format and the game reading the binary content if at all possible! 

You make them deterministic. For a great example, see Dungeon Siege GDC Presentation as to how they made the locations in the world networkable. Also remember that determinism applies to 'random' events as well! 

Read up on standard database design. Specifically normalized forms. An approach would be to have 3 tables: character having a character_id and other data items having an item_id and other data (names, weight etc...) inventory having character_id, item_id, quantity. A player's inventory could be expressed as "SELECT items.name FROM items, inventory WHERE inventory.character_id = 'THECHARSID'" Of course based on your other questions I'd much more likely suggest using an ORM that handles this for you. Look at Relationships, and backrefs in something like SQLAlchemy. If you need the concept of inventory 'slots' then that's another column in the inventory table. (IE: Character 32423 has an item of type 832 in slot 0 (The head slot)) If each item has unique stats (Durability/upgrades) Then you can do something like the item table contains the item specific data, and has a link to an item_base column that defines the base stats that all items of that type have in common. 

There's too many undefined or barely defined terms there. MMO is such a loaded term. Without knowing how much CPU processing a user needs, how much backend storage a user needs, etc... It's impossible to say. I mean just at a bare minimum assuming the hardware can support it, you would need 8 front end servers just to support 500,000 connections. (TCP max of 65,536 ports per VPS rounded down to 65k.) I assume you've read about the C10k problem (The difficulty in scaling a single server to 10,000 connections, and 8 front end servers assumes you're at 6 times that rate.) If not take a look at $URL$ However, the metric I've used when it comes to MMO buildout was to assume 1 'CPU' per 100 connected users. This worked out to be a good average from 2001-2005 but I haven't developed an MMO since. This 1 CPU basically just encapsulates the cost of gameplay servers, front end servers, database servers, content distribution servers etc... It worked whether it was a blade server with 10 CPUs or old dual Pentium Pros. Of course as an added example those build-outs usually assumed one full time Network Operations person per 5,000 connected users. (Both obviously scaling with the peak-tie ratio.) I'd advise getting to your scalability tests sooner than later because I think it's going to wake you up to some problems in your design. Get 50,000 people on 1/10th the hardware you expect to run in production and see where the seems come apart. (Ideally do that 12-18 months before you expect to ship.) 

To answer your first question, yes it's quite possible to load an ETC2 texture on any OpenGL ES 3.0 device. In fact, it's required by the standard. In order to do so, you replace the function call with . For more details, read the documentation. Currently there aren't that many texture compression tools that support ETC2. Off the top of my head I can only think of one. That compressor uses the stock ETC2 compressor that Ericsson released a while back. I believe that the tool can output textures in a KTX file that comes with a codec implementation. If you want to do compression online in the app, you may be out of luck. A preliminary search on the internet shows that ports of etcpack exist but I've never tried them. In any case you should be able to expect a decent quality compression of a 1024x1024 sized bitmap within 60 seconds of any codec worth it's salt. 

If you're looking to have not a lot of water move over a terrain, then your best bet will likely be some form of Smoothed Particle Hydrodynamics (or SPH). In this formulation, you simulate a set of particles as they adhere to the laws of hydrodynamics (namely, the Navier-Stokes equations). There is a great series of articles written about this from Intel: $URL$ Rendering your particles as fluid will likely be done using some sort of metaball formulation. You can get a good intuition from this article. The basic technique is described here, and what you can expect it to look like is something like this although it will depend how you write your shaders. For larger bodies of water, I suggest looking at this tutorial which outlines some of the techniques used to generate a large body of water. You can combine this with the previous method to have fluid that flows into large bodies of water too. 

In ramp shading, the idea is to modulate the diffuse coefficient by a 1D lookup texture. Depending on what you put in this texture you can generate different effects. Hence, our shader function to compute the diffuse coefficient becomes: 

What you're looking for is something called "seamless" textures. Here are some tutorials for popular image editing programs: 

My advice is to use sprite animation for anything that isn't an overly complicated object. Things like power-ups, and simple monsters are great for sprite animation. If you have a very complex main character that can do a lot of different things, these are triggers that should say, "Oh, I should probably use skeletal animation for this guy". 

For each agent, assuming that it is stationary, calculate all of the velocities that would cause it to collide at any point in the future with any of the other moving agents. This can be represented in "velocity space" as a set of of intersecting half-planes (also known as a velocity obstacle). Determine the point in this space closest to , this is the new velocity of the unit. 

In general you do not translate transforms. You translate points which are usually represented by vectors. If you're wondering how to generate a transformation that produces a translation relative to the world axis, then you should look into homogeneous coordinates. 

The phrase that you're looking for is relevancy sets. Each player has their own list of objects that they care about (That are relevant to them.) As objects are removed from this list, a message is sent down to remove it from the client. As objects get added to this list, a creation message is sent down to the object. During the course of game play as an object state changes, messages are created to update that state on all clients that consider it relevant to them. This is a bit of a simplification as some systems use multiple messages for create. (IE: Block out a model here, details will be coming, or here's the model and textures but no RPG mechanics are sent yet.) I probably linked it a few times before, but a paper that discusses this is Distributed Object Views and was used on an MMO I worked on awhile ago. Rereading what you asked, one thing to note is that commonly a cell can be subdivided per client. IE: The cell may be the entire portion of the world that the process owns, but for cheat-prevention and bandwidth issues the cell may only consider objects that are within 20-40 meters to be relevant to the player. The real tricky part is what happens when the player is within 20-40 meters of a cell boundary? At that point they are seeing objects from multiple cells that are relevant to them and those other cells need to proxy their data through the cell the player is in. 

Basically think of different subsystems and think, "Would it be bad if this system was one to two frames out of sync with this other system." If it isn't then they could be off-loaded. And for some of the answers above, Multi-threaded rendering doesn't mean rendering from multiple threads usually, but rather moving the rendering from the main game thread so that you are not locking the FPS of the renderer to the FPS of other parts of the system. 

Basically you want at least 3 types of data structures: Counters: This happened. A gun was fired. An enemy was killed. This polygon was touched. Conditions: If Counter X > 500. If Counter Y = 0. Trophy: If condition A is met, this condition is visible. If condition Y is met, this condition is invisible. In your game code you sprinkle counters firing where appropriate and forget about it. Some other class either in response to an event of the counter firing or periodically will check the list of conditions and see if they've been met. After, again either in response to an event or periodically trophy's will check if all their conditions are met. If so it gets rewarded. Your UI can iterate all trophies and display the visible conditions. If no conditions are visible, then the trophy is hidden. Everything is separate and during the update loop all you need to do is increase a number and maybe flag the data as changed, anything else can be deferred to when there's more time / even a separate thread. 

Now, both and should be between and . We call the parametric representation of the point in the space of the rectangle, or unprojected soccer field, in this case. We know exactly where any point is by using two coordinates between and . I still haven't mentioned how to go to the projected space. Once you have your parameterization, going to any shape that has four corners is easy. You have to map the four corners of your new shape to the four corners of your old shape. In this case, you have the parameterization for your old shape, so you simply need to remap it to the new projected trapezoid. Let's say that your trapezoid has corners labeled: 

Development: You need a separate skill set to properly implement animated skeletal models. This is something that is sometimes hard for people that are used to sprite animation to handle, but with enough practice everything works out. Implementation: Although Unity will handle most of the heavy lifting for you, if you want to implement skeletal animation, you have to figure out how to specify which animations will blend with which other animations and integrate that into your game and event system. This isn't a trivial programming task, but again, Unity should take care of that. 

You can use your texture coordinates, and set a uniform that tells you the aspect ratio of your rect, and the desired width of your border. Then, you can just check to see if your pixel falls within the bounds of your rectangle. 

Ok, once we've figured out our vector we can write them in the coordinate space of the rectangle itself. In other words imagine that BL is at the origin , and TR is at the point , then both t.x and t.y are somewhere in that square and belong to the interval [0, 1]. We can use a simple trick to transform our coordinates into this space: 

The key takeaways from this are: Your serialization code should always write the most up to date version of your game state, regardless of what that is. However, it must also write what the most up to date version is so that future (and current) versions of the game are able to know how to read the file. The deserialization code gets a little bit messy with this technique. It takes a very defensive approach to reading save game files. There are security reasons (i.e. buffer overflow) for why this is a good idea. It also reduces the risk of reading a corrupt save game file and loading bad data and crashing (or worse, not crashing). For debugging purposes, however, you should make sure to be as verbose as possible for why a saved game could not be read. This will save you many headaches in future versions where you thought a thing should be a certain way but it isn't. This system proved to not only be very effective, but I had a very easy time maintaining it. 

First, if you've set freeze position on the rail tracks, why do you have them set to react to gravity? Second, make sure that your train and tracks are not positioned so that they are initially colliding. The way you can do this is to keep moving the train up until it simply falls to the tracks. Third, I'm not sure that metal is the material that you want here. I would suggest making your own physics material and experimenting with the properties. In general, your objects should have a very high coefficient of static friction, and a not so high coefficient of dynamic friction. Play around with the settings to see what feels right.