Side note: The only method you have that is actually useful is . Otherwise it would be easier to just use or . However, I understand that this is just an exercise in which case it's fine. 

I am not completely aware of the best practices in JavaScript, but I would personally prefer one variable declaration per line, which would be: 

I see a very big advantage of your current approach rather than moving the implementation of to the class (May I suggest changing the name to ?) 

Now let me ask you: Did you copy-paste any code while writing this? You did, didn't you? I don't see a reason for why you need 8 (one for each BF instruction) different classes. How about 8 different objects instead? Or 8 different factory methods possibly. You are not using any OOP aspects for these token classes. So.... do they really deserve to be classes? Forgive my Java, but may I suggest something like this instead? 

There are several things that can be improved in your code, I will point out some of them here. Polymorphism Your Addition/Subtraction/Multiplication/Division classes has a lot in common. You should use polymorphism and inheritance to use them better. You can make an abstract class for them. Also, you should make your unchangeable fields final. Also, the method should be named to comply with the Java coding conventions. This would also apply to methods such as . All methods should start with lower-case letter. The same goes for and in your class. As your method was only called from the calculation classes, I put that code in this method instead. 

You have several different options for this: Guava Google's Guava Library introduces the idea of a Multiset which is capable of counting the occurrences, and also provides a couple of other features. Java 8 If you are using Java 8 (which I highly recommend if you have the ability to do so), your method can simply be this: 

Instead of doing a whole lot of if-else over the supported constructor classes, you could use Reflection to accomplish the construction of objects. or to retrieve the constructor you want to invoke. to create the constructor. Sample code that might work: 

I would however recommend that you do it the old-fashioned way, so that you better understand what your code is doing. I just wanted to provide this approach so that you know what you have to look forward to :) 

You haven't declared the with generics, only instantiated it with Generics. In fact, you get a compiler warning on the line saying 

You could make be a function on the that modifies the value and , then you could do . (Then again, you just move the two lines from one place to another). Other than that, there it is not possible to my knowledge. You can't change a property on the object and return the object at the same line. 

And so we see that we have a path from to ! You should be able to find out which path that is from the matrices that you have calculated above. (I cannot remember myself exactly at the moment). I believe this method which I have partially described here is the Floyd-Warshall algorithm that Emily L. has also mentioned in her answer. 

These two conditions makes it a perfect for This will eliminate the need for a on a . means that it is a mine Once upon a time, I also used a special value to indicate that a cell was a mine. Later I realized my mistake. It is really much better to use an additional for the property of whether or not it is a mine. And you should definitely include a function. Not only does this make the code cleaner, it also allows a future mode where a can be both a number and a mine at the same time. (Trust me, the possibilities are endless!) 

UGH! Considering that usually you don't have the user id and only a user name, you would have to make two joins here to join with the player table. Better would be to have a many to many relationship between game and players. One player can play in many games, and one game can contain many players. The fact that one game only contains two players (at least for now) is irrelevant. Either it is one, or it is many. So create a games_players table for this relationship. It can contain: game_id, player_id, result. can be an integer to support up to any number of players in the future. result = 1 for the winner, result = 2 for second place, result = 8 for the "biggest loser" (no offense if you would end up here) in an 8-player game, etc. Now let's make this query again: 

Usefulness Overall, I think this code will be extremely useful, especially when I can use it without having to modify it's source! 

That is, return a copy of the data, then I can manipulate it all I want - I won't break anything! I wouldn't use a at all though and just do a directly. If you want to make sure that all variable names are unique though, even if they are of different classes, then go ahead and keep this variable. 

A big problem with your current function is that to output several HTML tags, you'd have to write things that actually belongs together very far apart. For example: 

Overall I don't recommend using Strings for this kind of data, you have no guarantee that your will only have one of the four possible values. What if the String suddenly says "ACCPT_SMTHNG"? An is much more preferable in this way. 

Also, your interface specification does not need to mark methods as , all interface methods are public already. So can be just 

A side suggestion: I assume that doesn't need to be run on the UI-thread, so you can change your class to extend and make the conversion to map in (or return null if returns null). Also, you don't need to create a new empty HashMap before parsing the JsonArray, simply will do. The only disadvantage I see with your current implementation is that you get an extra interface. But I really don't think that's so bad compared to having decoupled code. 

Then you can check if returns something other than -1. If it does, use the index returned to do what you need to do. Additionally, you should really look over your indentation. And is a bad name for a loop variable as count means the same thing as . Use or as a loop variable instead. 

Use the modulo operator. At the moment you will likely end up doing repeated subtractions from the same number (e.g. 1.6248e42 and 1.234e4) until the other one is smaller. Instead, always change the bigger number into and add to (which I greatly doubt needs to be a , a should suffice. Use or or 

I totally agree that it is better to have a Fragment in it's own class rather than as a static inner class. I don't think I've seen any cases where it's been a static inner class, but perhaps I'm just lucky (or have a bad memory). Overall your code is very clean. And I really mean very clean. Probably the cleanest code I've read today (that includes my own code). If this is meant to be a tutorial kind of example code though, there's a few things I'd like to say. First of all, your braces are using the C# convention. The Java convention is to use: 

Your class is not required at all in fact, it is only a wrapper for a using the delegation pattern, that can be replaced with: 

After all digits has been processed, print them in the order they should appear (higher valued digits are put later in the tape, so loop the tape backwards and print the digits). Code: 

As it currently stands, you are not doing that and have no real ability of doing so in that method. This fact is an indication that you should not use and instead use a , and therefore using composition over inheritance. Concurrency If two threads would call at the same time, there is a concurrency issue on . You need to synchronize on something there, for minimal blocking I suggest you do something like this: 

This one can be cleaned up significantly. You don't need the here. In fact, you don't need the either. It doesn't matter what kind of iterable it is so you can use . As you're not defining a variable of type anywhere in your method, nor is using that type in another obscure way, all you're really interested in is that it is an . So: 

The String-contains approach is an easy approach to take on this issue, but it can also lead to false positives: 

Yes, there's room for a lot of improvement here! First of all, you can "break early" to avoid excessive indentation. Since terminates the script, you can check if the file is not valid. Secondly, instead of ing first and later, you can call with a parameter. This code works in the same way, but is cleaner: 

You might consider this as "outside the core part of the code" but it's really not. And it is a very important change to make, class-design wise and best-practices wise. You could then use a class where you could have methods (static or non-static, as you prefer), for (your current dictionary), , , etc... 

A tiny extra thing that is often forgotten is to pass an argument to the , by default it is initialized with a capacity of 16 characters. If we look at a little example, we see that that's 20 characters. So the internal array in will need to be resized once. We could create the StringBuilder with a capacity of 24 to reduce the need for the resize. 

Again, method extraction will make this code more self-explanatory, and make the buttons better be responsible for what they should be responsible for. 

I am not sure how it all works out when running it, but it is a bit suspicious to me. Perhaps you would want to parse the text as a double (set it to if it's not a number), check the value, and compare using the value instead of the text. Just an idea though. 

Extract Method Your main method is doing way too many things right now. Extract parts of your code to different methods: For example, your entire loop can be extracted to a method. 

I think your method is doing too much right now, I would use a couple of different methods, such as: 

I know I could have created a more user-friendly menu and such, instead of switching the commented line or changing file name. This code is not really meant to be user-friendly, but I hope it is programmer-friendly. 

Actually, would say even more if you would override the method in . If you are writing these classes to be used as a library by many other people, then it could be good practice to explain that the activity must implement some interface. Otherwise, I don't see the point of it. But either way, there's no need to create an entire class for this. Summary: Get rid of your additional class, just cast your to and don't catch the exception to throw your own. So in the end, all that remains is this one line: 

I've only come up with this horribly if-else nesting way of doing it. There's gotta be a better (more extensible and more clean) way but I can't come up with how... Here is the code, it is currently only containing two regular expressions to search for and it's getting nasty already: 

I don't see any need to use input-validation when you're using on the . Perhaps you'd want to avoid a negative size, and either throw an exception or show an error message to the user, but that's probably it. 

When dealing with sorting algorithms, it can be useful to add some more detailed logging so that you can see what is going on. I created a JSFiddle where I added some logging so that we can see what exactly is going on. The results of these loggings indicates a problem with your code: You are accessing index and index at times, which only contains data. Your for-loop loops over one element too many, it should be 

(I do however agree about @Jeroen's answer about putting the denominator check first) Returning something useful 

This is inefficient as you are reversing twice. A better option would be to first separate the words, and then reverse the words, not the content of the words. 

I would expect the node for 11 to get the value . I don't see 119 anywhere in your expected or actual result though... Verifying a Binary Search Tree As your question contains an incorrect tree and one of your comments below has an incorrect tree, I'd like to provide you with a method to verify a correct tree: 

Are you sure you really should use here? I think that you just need to use . Because another rect can collide with both bottom, bottom-left, and bottom-right at the same time. 

Here's some things I've found by skimming through your code a bit. There is more things that can be said, but this should get you started: 

These are clearly related. 1 kilogram = 1000 gram = 1 000 000 milligram = 1 000 000 000 microgram. So instead of using multiple maps for , , etc. Just use one base unit: Gram. 

I would recommend moving the to your method, and letting your method call a method on your object whenever it wants to send a message. The can then call a method on to perform the sending. 

That is, 10 * 4, 10 * 7 and 10 * 10. So now we can use these values to write our string. The values we have are 40, 70 and 100, so we will go to the different cells and change their values slightly up and down to get and print the numbers we want. 

The only way to do what you are trying to do, and remove the duplication, is really to cast. What I would do is to use this kind of map: 

Again, if using a 2D-array, you should be able to loop through all the tiles here and check the put for each position. Or better yet, as the tells you exactly what index to change, you should only change the value on that specific index. Study up on arrays in Haskell and you should be able to make it better by only changing one index in the array. checkWinner First of all, this contains duplicated logic. Once for and once for , that part can be extracted. Additionally, there's a little trick that can be used when checking for winners in Tic-Tac-Toe. The idea is to start at a certain position, and then loop and change the row and column indices by 1 and check the next position, repeatedly until you go outside of the board range. checkFull Again, use a for-loop. getTile Again, use an array and grab a specific index. The last part of your code That's a lot of indentation! A looooot of indentation! Try to find a way to reduce that. Put more if-statements on the same indentation level? Switch if's with else's? Sorry I can't provide detailed help here. All I can say is: Yes, that is a code smell. 

(To make things easier for you, you can also add your as a muppet and override the method to return a custom string if , this would also remove the need for adding one in , and would greatly simplify adding the items to the adapter) Then I would use the as , so that you can get the selected item like this: 

Don't throw , use instead. is a and therefore does not need to be caught (or declared in the declaration), but you are still free to do so if you would like. (Although I would not recommend it) 

Here you have a multi-line , but as you're not using any -specific features (variable interpolation for example), you can replace the with 

Swing comments Instead of using Swing, consider learning JavaFX. JavaFX makes a better separation of your code and the design of your form. Technically, it is not recommended to in Swing, it is preferred to use composition over inheritance. This is unfortunately something that is quite common in Swing. In JavaFX though, it is much easier to avoid that.