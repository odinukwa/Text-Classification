I've never experienced the problem you're describing with any custom actor types. You shouldn't need to do anything explicitly, or implement any methods, yourself. The "focus" command is handled in EditorServer.cpp (the link requires access to Epic's private Unreal Engine GitHub, which can be obtained by registering an account with Epic); specifically . This method computes a bounding box for the viewable region based on the bounding boxes of the individual selected actors and their components. Based on your problem description, it is likely that your actor, or one of its components, has an improperly initialized or overly-large bounding box assigned. The other possibility would be that your actor has no components, and is configured such that all other code paths computing the bounding box are skipped (certain types of actors, et cetera), resulting in a zero box. However the subsequent call that actually focuses the viewport on a box will early-out if given a zero box, so it's quite likely the case is the first one: one of your actor's components has an overly-large or malformed non-zero bounding box. 

Multiplayer contexts make it harder to build these kinds of systems (especially the first one). However, you can simply make the decision that players cannot directly engage in combat with others, if you want. This solves a large class of player-versus-player permadeath problems related to griefing (high-skill, high-level characters preying on the weak neophytes). If you want to allow player-versus-player direct combat, make sure there is a significant cost and consequence to killing another player. The balance here should generally be weighted heavily towards the player who doesn't want to go around killing other players, so any player who does so is significantly disadvantaged. (Generally, I feel like the idea of combining permadeath and player-versus-player combat is usually just a recipe for disaster, since it only enables "fun" for the griefers; co-operative play tends to be much more rewarding in my experience -- especially with permanent death. But that's just my opinion.) 

The class's method has an overload that allows you to specify a scale factor. Thus, to render a sprite in a stretched frame, do something like: 

What you want to do is homogenize the interface to that information, so that the debug menu itself need only deal with a single concrete API to get information concerning what it needs to display. Your first step, thus, is to ask yourself "what information do I need?" At a bare minimum, I would expect a debug menu to display key-value pairs: the name of a property or field and it's corresponding value. Both can be represented as strings, because you're so far only talking about displaying that data. Additionally, you probably want each collection of key-value pairs for a particular object instance to be grouped with the rest of the fields for that object, so you'd want an overall container to represent the key-value pairs for a specific object. Perhaps 

You can see from the source code that returns a null pointer in only a few circumstances (as of this writing). 

No, there is no public API available to set the wallpaper or lock screen images of an iOS device(*). You can save the picture to the user's camera roll and provide instructions for them to manually change the wallpaper, but you can't actually do it all yourself. (*) It seems like it should be possible to do this on a jailbroken device, however (some cursory searching suggests by writing to for example). But unless you're targeting jailbroken devices you're out of luck. 

This is not legal advice because I am not a lawyer, you should consider talking to a real lawyer if you want a proper answer to any law-related topic. You can't use the assets that ship with Minecraft. You can, however, create your own box-man avatar, and that would probably be a much better idea for a variety of reasons even disregarding the legal or ethical issues involved. For example, it would be built for your technology instead of somebody else's, you have more control over it and can be more creative, et cetera. 

In C++, member functions (such as constructors) do not take up space in the memory layout of an instance of a structure type. In your example, is going to be , so it will map correctly to the structure in HLSL. So you don't need to worry about this. Most of the time. 

This creates tile sprite objects, which you can then initialize accordingly to fill up your map (e.g., and so on, or whatever is appropriate). Even though the above is a linear array of tiles you can conceptualize it as a grid. If width and height are both 4, for example, the array ( represents a sprite in the array) looks like this 

If you use a textured quad, you have some additional flexibility over the geometry that you wouldn't have with a . This will allow you to implement the skewing you're after. You can then implement the skew: 

It's not necessary, in the sense that you can make it work. But your approach is somewhat... awkward. In your approach, the pre-render and post-render work (such as clearing the appropriate render targets, and then presenting the final frame the screen) has to be done before and after : 

In general, you'd want to find a tool that can extract the sprite data and patch it back in to a ROM. You are more likely to find them for more popular games (such as Final Fantasy 6). Shaq Fu is, unfortunately for you, apparently not popular enough to warrant such things. Your next step would be to look for a generic SNES sprite extractor or editing tool. The SNES used a specific tile graphics format for drawing sprite tiles, and many games would have simply stored their graphics directly in that required format in the ROM for simplicity. These generic tools can sometimes find and edit those. Search for "SNES sprite editor" or whatnot and you may find some examples. If that doesn't work, because your game is one of the ones that opted for some unusual storage format or compression, you'll have to do things the hard way. The sprite data is still in the ROM somewhere, and will probably still be rendered normally once decoded. You can still dig through the game's assembly and find where the rendering is being set up (look for preparation of the appropriate OAM registers, et cetera) and hopefully work backwards from there. 

The key to a good permadeath system is to make the player feel in control, and not feel complete sense of loss when permadeath occurs. Consider the analogy of a well-designed platformer. A well-designed platformer should not be trivial to complete: there should be some tricky jumps that require some skill in there, to get the player's adrenaline going. But when you fail a tricky jump, you should not feel like the game was unfair, you should feel like the fault was yours and be able to see it. And a well-designed platformer starts you over on your next life far enough away from the failure point that you need to work to get back there, but not so far that you have to repeat everything up to that point. Preserving those sensibilities can scale to permanent death as well. Tuning this is pretty difficult, of course (especially when you start to have other players involved, and those other players can potentially contribute to the death of any other player characters). Generally, this means: 

tldr: Learn D3D11. The difference between 10 and 11 is pretty small, in terms of the shape of the API. D3D11 allows you to use down-leveling to write code against the D3D11 API that will run all the way back to D3D9 class hardware (note that you will still require Vista or better however). So you may as well learn the newer API, which I feel is cleaner and more uniform anyhow. However, if you don't have Vista or better, or you eventually want your own code to run on XP (to for example distribute your game to XP users), you're going to have to use D3D9. The XP market is probably shrinking, though, so I'd say go for 11 if you can. 

Does your application actually fail to run, or does it just print that message to the output window and continue (there's no timestamps in the output window, alas, so I can't tell how much time elapsed between the first-chance message and the program-is-exiting message)? First-chance exception messages like that aren't always indicative of a problem that needs to be solved, especially if they occur in code that isn't yours (unfortunately). If you are crashing, I've seen this issue (and a fix for it) regarding WP7 development tools and another external assembly (not the Advertising SDK directly, but perhaps it's a related problem that could be solved with the same steps). Other things you might try include turning on "break on throw" for all managed exceptions and disabling "Just my code" in the Options section of Visual Studio to see if you can break into the debugger when the exception is thrown -- this will let you examine the exception's FileName property and determine exactly which assembly isn't loaded -- this exception is thrown generally when the CLR finds an assembly but can't get it to load for whatever reason. It's possible you won't be able to trap the exception if if occurs too deeply in code that belongs to the CLR loader, in which case you may need to use WinDbg or load the SOS.dll directly into VS to trap and print the exception (look into in WinDbg and from SOS). 

Both options will potentially have slightly different results in terms of the appearance of the texture mapped to the quad, and both approaches are more appropriate for certain kinds of existing rendering pipelines (primarily based around the projection matrix you are currently using). You'll have to pick the one that best fits your code and your desired visual style. Note that abandoning means you lose some of the batching optimizations it makes for you, which you may need to re-implement depending on the overall performance (and performance bar) of your game. (Also note that a third option would be to just author the sprite textures with the desired perspective distortion built-in, which means you can simply continue to use , but adjusting the perspective would be difficult as it would require re-authoring your sprites.)