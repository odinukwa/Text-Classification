is inefficient. If but it will start to constantly re-sort while it is waiting for the next chunk, eating up single CPU core. Instead your working thread should be in waiting state until the next arrives. 

So in which order should I call those to get things running? Should I call and then ? Should I await ? You should expose a single method, say, , so I can call it to connect to the server and be done with it. Straightforward and simple. Everyting else should be an implementation detail. If reads a single message, then you should change it's signature to . 

Can I extract the section of the code I want to comment on to the separate method with descriptive name? Is my algorithm too complex to understand and maintain and can it be simplified? Does my class do too much work and can I break it down to smaller classes dividing the work and responsibilities between them? 

I don't see the benefits of having both static and non-static API: and . It does not bring any new possibilities, but it does cause inconsistencies in usage (personally I hate it when there are multiple ways of doing exactly the same thing) and additional unit testing. I would remove static version completely and keep only non-static one. However I think that creating an external static class, similar to , and moving any complex math there from class - is a good strategy too. 

It depends on your design entirely. If classes (2) and (3) can not operate on their own, should not be instanciated and are there to serve as base classes only, then you are justified to make them abstract, and i think you should. Also, you should probably reflect your intent in class names by adding suffix to (2) and (3) (or prefix, but i think it is less common). Edit Objects with protected constructor can still be instanciated. For example, you can create them from some method in derived class. It is not a realistic use-case in most cases, but you should not leave such holes nonetheless. If you want to forbid instanciation completely, the only way to do it is to mark the class abstract. 

Only your viewmodel should implement . That's kind of the whole point of mvvm. Normally, your viewmodel properties wrap your model properties. Also, it is your model, that should contain all the business logic. Viewmodel should know nothing about or any other details of implementation. Viewmodel should only manage interactions with UI. Being said, you should have something like: 

I don't think there is a way to do this faster. You might want to experiment with unsafe shenanigans, but I doubt you'll get a significant performance improvement if any. Since your strings have varying size direct mapping is extremely unsafe: 

Your unit tests look fine to me (except you should move them to different file), tho i'm not too experienced with them. 

It would be nice to also have a method that would call internally. It will make probably the most common use case more accessible. 

I think there is nothing wrong with using whenever a class requires some sort of clean-up. It might have been originally designed to release unmanaged resources, but it is definitely no longer the case. Nowadays people use to do all sort of things: unsubscribe from events, release pooled objects, flush buffers... this list goes on and on. 

This allows you to do all sorts of neat stuff later on. For example, to calculate total resistances of a player, you can call for every equipped item and sum the result. 

I feel like too many things are missing from your implementation API-wise to consider this code useful in general case (as public part of a framework that other people will use). Pieter already made a nice list of what is wrong. I can only add that: 1) There is no method. If I register a disposable object, how can I safely dispose it, if a reference to it is kept for a lifetime of ? 2) There is a lot of code duplication. For example this code: 

Check synchronously first. If it already exist then you can return early, and there is no reason to await anything. (Note eurotrash's point about thread safety). If value is never set, never returns. Instead of waiting for separately, you should check the timeout inside 's body and return once timeout is exceeded. 

I would implement those interfaces in separate classes. I see no interaction between the two implementations in your class, and they seem like two separate entities with different purpose. So there should be no reason to mix them into a single class. Have you considered using interfaces instead of s? Something like: 

I realize this isn't necessarily faster, but it will be much easier to maintain, and at least one example ought to be posted using LINQ. So here's that example, using LINQ and the Combinatorics library to do it in a single statement, and in a more object-oriented manner*: 

You'll still need to code each calculation function, but you don't need to manually attach each calculation to a specific crop or trait. You can just have a database table which tells the code "Crop + Trait = Enum value" 

This will kick off a new solver run each time the prior one displays, up to the limits of what your computer can handle. 

I'm not entirely sure how your second example fails to match, because the string contains all of "AU", "A3", and "2.0". That being said, here's an attempt at a cleaner rewrite: 

I find this much more readable than trying to do conversions to an Enum, and more straightforward than a decision grid. That being said, it doesn't scale as well as either option. 

By doing it this way, you separate the formula (which is basically just Ingredient/Percentage pairs) from each application of it. You can use the same object to calculate the weights for 10000g of dough or 50000g of dough - simply call with a different value. Notice how many fewer properties you need on each class, and the question of "late setting" of some of them is entirely irrelevant. Effectively, weight is not an intrinsic property of an ingredient, because it varies based on the total weight, so shouldn't be a property of . 

If is your slowdown, you're not going to be able to get a huge improvement, but you can get some by parallelizing all the calls to it. Replace your loops with this version: 

Another possibility would be to store the words in a dictionary of nested dictionaries. The key would be a letter, and the value is another dictionary of every letter that can follow that. Repeat until you've reached the maximum depth. For the sample case, this would look like 

Everything that's the same gets put into . Everything which could vary is defined as an method or property, and then the subclasses implement just those things which make it different. 

Everyone has had good ideas, but since you're asking about OOP, I'd suggest refactoring it altogether. 

Just to build on what @svick said, this is definitely not a good way to handle things. If you want to catch all exceptions, simply . If you don't want to catch everything, then only catch the specific types you want. There's also the block which you can use to do any cleanup which is necessary, regardless of whether or not you've handled the exception. 

Edit: Stole the idea from Jesse C. Slicer's answer, but didn't modify the function signature. You can also return if that is more useful to you, or you can go with his idea of returning , in which case you don't need that at all. 

This removes the need to worry about casing, lets IntelliSense prompt you for valid values, and throwing an exception on an unexpected value ensures that you catch it during testing the moment it occurs, instead of the subtle "hey, this just keeps failing to validate" of always returning . 

The first method is an all-purpose "Add"-type method which will either add it or update it depending on whether or not it exists. The second is specifically for dictionaries where the value is a . It'll let you add an element to the , creating the key if neccesary. 

You're right that all the casting is a sign that there's better way. Rather than using the value of an as the index to an array, you should use a structure that's designed to store two values in the first place. There's a couple of alternatives here. My first instinct is to use a . That most explicitly matches the concept of what you're trying to do (each has a value ), but it's not actually the best option. You're not going to be looking up the value based on the key, the order of the keys may change which could lead to hard-to-reproduce bugs, and it's less memory-efficient. Instead, I'd use a , , or (in C# 7) . They're all effectively the same thing in this case, and best convey the concept "here is a pair of related values" without implying the A->B relationship of the Dictionary. (Note that you can also use arrays instead of , like I do below). To make handle this, you would need to make it generic, so that you can pass any arbitrary type in and get that same type out. Here's what the code would look like using C# 7's ValueTuples: 

Start from the end and work your way back, that way once you've found one palindrome you're done! You only have to check half of the digits for equality. We can shave off some time by avoiding / 

However, it's not clear that you need to be creating the in the first place. You can just use Linq to generate your from scratch: 

I need to get the nested type name of without the namespace, i.e. in a generic method. Unfortunately, will just return and will give me the namespace as well. Right now I'm using this: 

If you want to reduce the lines of code (with a slight negative impact to performance if this function gets called a lot), you could do this: 

You should probably get into the habit of using format strings rather than string concatenation. It's generally better practice. This next bit is more a matter of style, but if you don't need to keep as a state variable, I wouldn't keep it as a class member. You can define it as a variable within the method and pass it in to instead, like this: 

You really need to use arrays for this. and are identical so I don't see any need for the condition. Use methods instead of , as they've been deprecated. Use prepared statements to guard against sql injection. 

But this just looks ugly. Is there a more standard method for getting just in this situation? To clarify what's going on inside this method, this is part of a unit test for an XML serialization class. will load an XML file, wrap it in a little more XML to create an 'envelope', attempt to parse it, and return the result if it succeeds. The problem is that the 'envelope' that the XML serialization class expects the XML to specify the type name in a particular format. For example: 

NOTE: as far as I can tell, there's nothing limiting (or ) to be the same in all grouped dramas; each drama could have a different . Here's an alternative that includes the teacher in the grouping: 

Once you've gotten your code into a you can just call property (which in C# is called with ) to get all values with a given key. So the can be entirely replaced by using the like this: 

1: Of course, in these examples, the values are still hard coded in one place, but precisely how you generate the list is unimportant. 

The one thing that really stands out to me: you don't need to convert the boolean result of to a human-readable string, then test the string. Just test the result directly, then convert it to a human-readable string. 

For something this simple, I think using the is fine, however, if you need to use the list of acceptable integers more generally or avoid hard-coding the set in a single expression1, you can use something like this: 

This is exactly how I would write it if I had to use C# (with the exception of the in-line if / else), but after I wrote it F#, it seems clumsy and a little messy. I suspect there is a much more elegant, idiomatic way of writing this in F#. Perhaps using a match expression? 

Well there's not much code to review here, but for what's here, I'd say it looks okay. I would only make one suggestion. If all you're going to do in your controller action is return single string wrapped up in a JSON object, why not dispose of the JSON and just return the HTML as content? Ajax call: 

Both of these look better than my original code, though I'm not sure that the match has added any expressiveness to the code, so for now I'm keeping the plain old / statement. This is mostly just taking advantage of the built-in behavior of dictionaries in .NET ( returns the default value if the key is not found, and the property's setter will perform an insert if necessary), but I'm still open to any suggestions on improving this more. 

My PowerShell scripting skills are pretty poor, but I've managed to hobble together got this script: 

Any other exceptions it throws indicate a invalid parameter or bad program state. You probably don't want to just ignore these errors and move on as though nothing has happened. I recommend you just do this: 

If you want to verify that either value is in the , may not be the best option. It will continue to test for collisions even after it finds a match. For two search strings you can just do: 

I honestly don't see anything particularly wrong with that Linq query, but there are a number of other things you should consider: