This provides a simple demonstration of the benefits of pointers and will help them understand why primitives (not counting pointers) are passed by value, while everything else appears to be passed by reference. 

When teaching Intro CS in Java, I sometimes tell students things that are not entirely true, such as that, unlike abstract classes, interfaces cannot contain any code. (For those of you unfamiliar with Java, that was true until functional interfaces were added with Java 1.8 in 2014.) I realize I could put an asterisk on the slide, or visibly cross my fingers, and let students know I'm not telling the full story, but, when I witness other instructors allude to irrelevant advanced material, I view them as pedantic and fear that students find the additional information distracting or confusing. I don't mean to open a debate on the importance of functional interfaces in Java -- they're just an example. What I'd like to know is if it's considered better to gloss over details in an introductory class or to always speak the whole truth. 

I teach the "standard" conventions for the language, where they exist. For Java, I use the original Sun naming conventions and Google Java Style Guide. More important that standard capitalization (which I require) are: 

Another fun exercise is implementing and using only gates (or gates). This proves that is universal. You can demonstrate that is universal then ask them to show that is (or vice versa). 

One reason infinite loops are used could be so the problem can't be solved by letting one thread complete the code before the other thread starts it. With infinite loops, no thread ever completes the code. Of course, using a bounded buffer has the same effect. 

I spend up to many hours on each student. (Subsequent letters for the same student require only minor modification.) Mine range from a few paragraphs for students I don't know well to 2 pages for a student who has greatly impressed me and is being considered for something very important. (This is not too onerous, since I teach at a small liberal arts college.) If a student is applying for a job (or scholarship) at a company that has employed our graduates, I will explicitly compare the candidate to those graduates. In the programming project course, I ask students to do peer evaluations, and I quote these in letters of recommendation. As someone who reads letters of recommendation (for graduate admission), I like letters that contain details, such as "2nd highest score in a class of 40" or "strongest major in 2 years" or "created a website for the computer club using X, Y, and Z". Something that eases writing letters of recommendation is having a student bring in their resume, transcript, and any other information that will help me write a strong letter. If a student's grades are not good, I ask if there were any extenuating factors and what I can say about them. For example, I might say that a student's grades were low one semester because of health problems (or personal problems) that have since been dealt with. I believe mitigating circumstances sound better when coming from a recommender than from the student. Some things to keep in mind when writing a letter of recommendation (that nobody warned me about): 

Note, this evaluation was not performed according to any formal evaluation model (see substitution model or environment model); it was merely to help build intuition for how evaluation could be done. Extra (tail-recursion): I mentioned earlier about how recursion does not necessarily have these pending function calls that much be recursed back to once they finally have the result of the recursive call. Consider a recursive function to find the sum of a list (ignoring the python built-in sum()): 

and you have a variable r storing the root. If you call max_depth(r), it will try to evaluate the else clause; it will evaluate max(max_depth(r.left), ...) and then add 1 to that result. To the r.left recursive call, the input looks like this 

How to use recursion Let's look at an example: maximum depth of a binary tree (where a tree with a single node is depth 1). A recursive solution in python might look like this: 

You don't need to think about how this is actually evaluated; you just define it how you would mathematically. If I somehow know that the maximum depth of the left branch is $x$ and the maximum depth of the right branch is $y$ and that $x > y$ (without loss of generality), then I know that the maximum depth of the entire tree is $1 + x$. This way of thinking about problems is one way you can use recursion. Of course, you need to make sure that the inputs to the recursive calls are in some way smaller than the input to the function that makes the recursive call, which segues into how recursion is evaluated. How recursion is evaluated To think about how recursion is evaluated, we can use the same example. In the example above, there are pending recursive calls, waiting to return (note that recursion does not necessarily have this, see tail call). To see this, suppose our tree looks like this 

This indeed would have pending recursive calls, as it waits to add lst[0] to the result of the recursive calls. We can make this tail-recursive by accumulating the sum of the list in an argument that is simply returned unmodified at the end: 

How do you encourage students to benefit from code reviews you give them, rather than being discouraged or responding defensively? 

I teach at Mills, a women's college near Silicon Valley with a high number of students of color. We do a great job of preparing students technically -- they do very well on the job market and then in their jobs. What I am unsure of is how to prepare students for the transition from a nurturing, feminist liberal arts environment to industry, which is not only more rough-and-tumble for everyone but can include bias based on sex, race, age, etc., which may cause them to leave the tech industry. How can I prepare my students to not have their careers derailed by mistreatment in industry? I don't want to just scare them out of the major or make them fearful by mentioning discrimination without providing a solution. 

One way is to have an industry advisory committee consisting of alumni or friends of your institution. (I was on such a committee for a community college when I worked in industry.) Once a year, the committee meets with faculty to learn about the current curriculum and suggest changes based on their active professional knowledge of the field. Another way is for faculty members to spend sabbatical years in industry. I learned more about software engineering from a year at Google than from my entire formal education. 

I'd like to create a college-level AI course based on the famous AI MOOC created by Peter Norvig and Sebastian Thrun. My reasoning is that I wouldn't be able to create lectures as good as theirs, especially because I'm not particularly knowledgeable about AI. (The last AI course I took was in the early 90s.) I would teach a "flipped" course in which the students watched lectures on their own, and we used class time to: 

When I had grant money or worked in industry, I was a member of the Association for Computing Machine (ACM) and the Special Interest Group on Computer Science Education (SIGCSE), which holds several annual conferences and publishes ACM Inroads. Now that I'm no longer publishing in CS education, am focused on teaching, and would have to pay for membership out of my own pocket, I'm wondering if membership is worthwhile. What do SIGCSE members or non-members in situations similar to mine think? 

first and foremost: they just look at it as an other subject to learn and have grades from. They are simply not interested in it even if that's what they'll be working as. They need will to learn it. Then there is of course the power of a good teacher. My current teacher came into this school 4 years ago and well knows nothing and is really boring. Many times we have to correct his code. The teacher should try to make the classes interesting for everyone also maybe she needs some special methods. Like as OP said some extra sheets to test on and experience. Maybe she doesn't have time to learn or thinks it's not as important as other subjects because it takes more work and time to learn and understand. (for example here we (those who know some more) usually correct other people in the class and explain why that code was wrong.) 

And to end this I want to say the same as what that other teachers told me about it: They just don't care about it, they are not interested in it anymore. It's plain boring for them to look at a black console with white letters. 

Well I'm not a teacher myself but I can tell about what happens in our programming classes. My class has 32 people in it and we all have to learn coding in C#, a language that basically everyone of us hates. Last year we had the best teacher in the school but he had to go away and we've got one of the worst one. The class is divided into 2 groups with each having 16 people in it. Well truth be told none of us actually wanted to be a professional code but he have to learn it as it's part of the curriculum. So from all 2 groups there are only 4-5 people who is actually interested in it for many reasons. (one wants to make games, other android apps, and the others, including me, as a hobby). Well from what I see in my group (and hear in the other) most kids are not interested in learning coding. Even though they'll need it in their finals they just don't care. When I look around at class I always see around 5-6 people using their phones or sleeping in classes. Well probably because the teacher is not good now all they know is last years things (partially, very partially) and when ti comes to writing anything complex: they just look at each other. And when you ask them why don't you learn if you are concerned about your grades? They would say "because I won't ever use it after school". Well it's true that my class doesn't really have anything to do with coding, but the system we're in makes us learn them. I sometimes speak with other teachers who teach the kids who are in the ACTUAL class that learn coding and will work as software developers and he says that they aren't interested either. So in my school the kids, who will work as devs, are not interested in it? (that's a 32 people class too) of course there are always a few who wants to learn but in general here it's quite low. So from what I'd seen and heard you need: 

The main attraction of block-based programming languages is that they expose users to the fun aspects of programming (creativity and design) without requiring them to deal with the less fun aspects (such as syntax and obscure errors). This enables students who might have dropped out of an introductory C++ course to get a taste of programming, both to expand their understanding of the world around them (since they use programs every day) and to motivate some of them to learn text-based languages when they hit the limits of block-based languages. Some disadvantages of block-based languages: 

Beyond these general principles, I have no idea how to teach a flipped course. Can anyone offer guidance or resources, both in general or for this specific course? 

Don't assume that students who have seen other programming languages will be bored. Creating phone apps is hard, so the ability to do that may be of interest to them. If they are extremely advanced, you can encourage them to contribute to App Inventor, which is open source. Disclaimer: I was part of the App Inventor team and am co-author of a book about App Inventor. I have taught App Inventor at the college-level (to non-majors). 

I was born in 1968 and used dial-up to mainframes back before PCs were available. We got an Apple ][+ when they came out and thought 48K was a lot of memory. I live in constant wonder at the world we are now in, which seems like science fiction to my childhood self. How can I convey to students born around the turn of the millennium how amazing this growth has been? I tell them about Moore's Law, of course, and that, when I was young, we paid 25 cents to play Asteroids, back when 25 cents was a lot of money, but I know I sound like Grampa Simpson. I share that a single Google search uses more compute power than all of the Apollo missions, but even I can't wrap my head around that. How do you convey to students some of the wonder that you feel (as part of motivating them to appreciate and learn computer science)? 

The r.left recursive call evaluates else clause, which means it tries to evaluate the max depth of the left and right subtrees, and add 1 to whichever is greater. The r.right recursive call also evaluates the else clause. So at this point you think of the return value of the original call to max_depth looking like this: 

All recursive paths from the right branch already reached the base-case, and now on this recursive call, all children of the left branch will as well, which means the return value of the original function is now 

First, note the difference between NP and NP-hard. NP simply means verifiable easily. NP-hard means verifiable easily, but also means that the problem is as hard to solve as the hardest problems in NP, which are not known to be easily solvable (see P = NP). For describing what it means for a problem to be NP-hard, I have had success by referring to the canonical Traveling Salesman Problem. I might introduce the problem like this: Given a list of cities, the distances between each pair of cities, and a number $k$, is there a path of length ≤ $k$ that visits each city and returns to the start city? And then I would say something like: If someone tells you a path to take i.e. an ordered list of cities, you can quite easily check to see if it includes every city, starts and ends at the same city, and is of length ≤ $k$. However, trying to come up with that path in the first place is more difficult. You could imagine trying every possibility exhaustively, checking if the conditions hold for each one. While there are algorithms better than this brute-force approach, which has runtime that is exponential in the number of cities, none have been shown to be polynomial in the number of cities. 

Once this evaluation reaches the base-case, it has the the result of the original call to sum_list(), and it does not need to be added to, or modified in any way as you recurse back up.