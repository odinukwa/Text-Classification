That way "Id" is just a row surrogate key, but CustomerNumber would be assigned once and would be a datum included in the versions of the data you are tracking. I suppose that the CustomerNumber could be the first Id assigned to this Customer, but I would suggest an independent numbering scheme, perhaps check-digited for a degree of protection from entry errors, should that ever be needed publicly. 

That is not part of the definition of permissions. The login being an owner of database "test" does not influence how SQL Agent jobs are managed. Being a of the database means that a job with that owner can take almost any action within the "test" database, but it says little about operating the SQL Agent job itself The permissions are describe in the following link. $URL$ Look for the topic: The following table summarizes SQLAgentOperatorRole permissions on SQL Server Agent objects. This clearly shows that the will allow the login to create/delete/modify SQL Agent jobs that are owned by the user's login. However, the login can be used to issue commands to enable/disable other SQL Agent jobs and job schedules. 

Seems to work fine. If you are on a different SQL Server it might have different behavior. Or fluentMigrator may have a problem. 

For what it is worth, connections are usually representing a Client that has left a connection active, but is not doing anything. Therefore, the connection is . Usually pretty harmless. But a connection that is holding an OPEN transaction can (but not necessarily) lead to problems with other transactions or with the transaction log. Add to your list of problems: Network, Routing, and similar problems. 

Yes, it is necessary to drop and recreate the linked server. This takes just moments, so the hit is very small. Likewise, there is no reason to believe that SQL Server would try to read the internal contents of a different relational database. 

You can then make the logins on your domain members of that group. All the logins will inherit the permissions granted to the group that gives them access. (You could include in the group if you truly wanted everyone in the domain to have access.) Of course, you need to grant the needed rights to the user so that everybody in the group gets the same rights. If you need some users to have additional rights, those can be individually granted. Or you can create another Group that would include only the users with the extra rights. The users will get the aggregate of all rights from all groups for that login. 

If your changes are not frequent and your parent table does not have a lot of data, then you could just update your schema on that table. However, potential downsides are changes in the schema could propagate to changes in stored procedures and views. This could be because of adding columns or removing columns. (Of course, any change made in a database schema, will have some ripple effects that must be coped with.) I like the parent table to be as stabile as possible. Having a related table or tables to provide new requirements is a good general rule according to how I look at schemas. But it is definitely an opinion-based choice that will depend on what you are most comfortable with doing. 

Assuming that each login can have a 'current record' you might have a table something in the form of: 

You do not mention whether you are using SQL Server 2012 or 2014, however the documentation on CDC and Change Tracking do not show much difference. Both make the following statement: "CDC configuration is always performed on the current or intended primary replica." $URL$ The above link is for SQL Server 2014 and offers many more details. 

The comment: "To see non-NULL values on a mirror database, you must be a member of the sysadmin fixed server role" is found in the discussion of sys.database_mirroring dynamic management view at: $URL$ Try running the following statement: 

Since 'NUL' just throws away the data, this can help you test your tuning more quickly. NOTE: If you are using Ola Hallengren's backup solution, these parameters are also supported 

This is definitely a design and usage issue for you to decide on since the CountryLocality table adds some overhead. It depends on how strong the Country-Locality connection should be and whether this extra step is worth it for your application. 

Perhaps if your old install was deleted prior to the new install, this may give you a window into resolving the problem. 

You say that by using RDP directly for logging onto and managing that server you obviously have enough rights to manage the server. What is different is that you are now no longer using a direct connection? 

As Sean Lange mentioned, MS Access cannot use a linked server which is only accessible from within the SQL Server. But MS Access is external to SQL Server. If you think of MS Access as the Client in a 2-tier Client/Server project, then it should be clear that you can use the 3-part naming convention (ServerName.Schema.Object) to access the SQL Server. If you have sufficient rights, you can update data in SQL Server from MS Access through the common use of T-SQL to manipulate SQL Server data. If you want the SQL Server itself to fetch data from a MS Access database, then you could create a Linked Server in SQL Server that would reach out through a provider to get data from the MS Access. $URL$ gives a sample provide setup from the Northwind database. 

RESULTS: Default This specifically queries for each of the states that you care about. Since there are two requirements, then the UNION will produce two rows when both selects are find a row. 

Here is a link on SQL Server 2014 for you to Grant Permissions to Integration Services Service $URL$ The first step is: Run Dcomcnfg.exe. Dcomcnfg.exe provides a user interface for modifying certain settings in the registry. The following link for DCOM settings were last reviewed in 2006, but the options look unchanged. $URL$ This describes Default Authentication Level (Packet Level) which is the screenshot that you posted. Other subheadings describe several other facets of the DCOM setup. 

In the simple view, this pretty much looks like Transactional Replication from {Publisher1, Publisher2, Publisher3} to Subscriber. I assume that Subscriber includes the . Therefore, as the is updated it can, in turn, become a publisher using Transactional Replication to {Subscriber1, ..., Subscriber5}. Of course, depending on the way data is maintained, you might need to use Merge Replication instead. Paul Ibison has a brief article that discussed the differences in republishing with Transactional or Merge Replication at: $URL$ The big issue is being sure that you clearly understand which sources of data are authoritative, how the data flows (and what happens to it in the ), et cetera. 

The sys.server_principals owning_principal_id is NULL except for Server Roles. Fixed Server Roles are owned by 'sa' (the server principal_id = 1) and cannot have ownership changed. You can create a new Server Role and set an owning principal using: 

That looks like serious damage to your installation. Have you considered uninstalling all SQL Server and Visual Studio (especially VS2010) software? If you have database files, you can probably leave them in place (but I would prefer to also make copies elsewhere). Then delete the folders that may still have some SQL Server components from previous installs so as to have a 'clean' slate to work from. Then Install from the installation media for a brand new install. Attach or restore the files and see if that resolves your problem. 

For Microsoft SQL Server, MySQL, PostgreSQL, etc the wildcard is not * but is %. If you search for "wildcards" in your SQL documentation you should find your particular server's supported wildcards. EDIT: Post comment: Sorry, I have never written MS Access queries. 

Regarding when a log backup can start: $URL$ This says: "A new log chain starts either with the first full database backup following database creation or after switching from the simple recovery model to the full or bulk-logged recovery model." So, I still believe that this will work as outlined. (Not identical, but I have used a differential backup to cover a gap when log files were lost, so as to establish a new origin for the log backups.) (Remember my disclaimer, of course.) 

This shows running a stored procedure with no parameters, which might suit your daily restore plan. If you search for "auto generate sql server database restore scripts" you will find many scripts. An example from Paul Brewer is that you might use as is or as a basis to create your own stored procedure. $URL$ Here are the parameters supported by sp_restoregene: 

Have you looked into using SQL Server's support for Indexed Views? (Generically this is called a materialized view.) If your code really needs an assist in getting the answers this is a option, though not without its own difficulties. An Indexed View is a duplicate set of data taken from the main tables and stored within the Indexed View. There are rules and limitations, but it basically creates a specialized "table" that should be index-tuned to suite your purpose for using it. This MSDN topic points you to the details that you need: $URL$ The definition of an indexed view must be deterministic, needs certain settings to be adjusted, and there are actions such as OUTER JOIN and ORDER BY that are forbidden. EDIT: You should also use the NOEXPAND hint, as explained by Aaron Bertrand, to "ensure the uniqueness guarantee provided by the view indexes is used by the optimizer." See: $URL$ 

You dropped the user which is not needed, since you are making it the dbo. Once that is out of the way, then your login can be made the owner of the database. EDIT: You can also use SSMS to delete the James user from ABC database. Then you could return to the Database properties File tab to set the database owner. (Sorry, I tend to think scripts.)