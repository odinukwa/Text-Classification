Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: 

I think everything looks quite nice here. It runs well, and you run the necessary checks to make sure that everything is safe. I did notice that you went to great extent to implement a bunch of operators for your structure. But you forgot to implement the common prefix and postfix operators. Say I want to do this to your structure: 

Final Code Please note that this code leaks memory and doesn't contain a unique ID generation method. 

Over-fitting It could be possible that you fit your data too well, to the point where we don't generalize well enough. An example of this is given in the picture: 

I've recently wanted to make a "Loading..." display in C where the dots print one at a time in order and then reset: 

For an assignment I had to create a client and a server that communicate over a well known FIFO. The server is required to use three threads to serve the client, managed by a semaphore. The code was pretty hastily written due to my busy schedule, but works as intended from what testing I've done. Feel free to rip it apart. 

Also, you're using some nice concise bit-shifting, and you'll have noticed that VBA doesn't have any shifting operators, but you might consider using some bit-shifting functions to make the code slightly clearer (and you can re-use them everywhere else that you need to shift bits. And finally, unless you're certain that will always be a single celled reference, the color will default to if there are more than 2 cells in the range and they have different colors. 

If sorting the data doesn't help move the blanks to the end of the data range, and deleting the rows is a better solution, given your data, then you can try this approach. If you know a column will always have data (and never be blank) for a valid row, then you can achieve the deletions without a loop. 

IMO, you're better off with a function that either returns a boolean that confirms the sheet is present (before you try to do something with it), or returns a reference to the sheet or otherwise Nothing. That way you can keep you error handling concise, and avoid the need for labels. Here's an example of the reference approach: 

You could use , and then if there is a group greater than 1 output . However, it's in a module, which you don't want . If you look at the link, it shows how the method is implemented (though I see no reason to reinvent the wheel). 

This is the file for Khronos, a personal project of mine. This is basically where the whole program is setup, run and then quit. I'll post the short summery of what this file does from the : 

Algorithm: There are a few fallacies that you assume in your approach. Nothing wrong, but things that could be improved: 

The Sigmoid Neuron is defined as: $$ \sigma(z) = \dfrac{1}{1 + e^{-z}} $$ Torch implements this neuron type here. (1) Excerpt with minor edits from Neural Networks and Deep learning 

Please feel free to rip the code apart! In my opinion, I think the in could be DRYed up a bit, but I wasn't sure how. 

That can be confusing to read, and difficult to debug. Consider using independent variables Magic error numbers You've done half the work of creating custom error numbers: 

Hex to String - Preserving the leading 0 Hmm, I think I can use a bit trick to make the Hex conversion more efficient. 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

Final Code I've rewritten your code so that it is bug free, and so that it is a bit more dynamic. I also rewrote some bits so you could see what was going on, and so the program was more transparent. 

Reusability - is this Makefile easy to use for multiple separate projects with minimal modification? Organization - is this Makefile organized in a logical and readable way? Dynamics - are there Make features (or compiler options/warnings) that I am not taking advantage of that could make my Makefile more powerful? Miscellaneous - what other things could I improve? 

The output given is seen in the above. I know this can be done better. Any suggestions for improvement? 

I thought the function would be optimal for this, and I believe it makes my application pretty robust and fast. On my Mac (ommiting 196 lines of filename output each): 

Hijacking the predeclared instance's fields In the factory method , I temporarily set the state and X/Y fields of the default instance, and then in the event of the new instance, I read those fields though the default instance's getters. As such, I've relaxed the conditions around being able to access the default instance's getters, but this could easily be re-added. The default will always have X and Y's getters return 0, in much the same way that the default will always have default value 0. 

Collect all the Widgets Then we need a class to hold all of the widgets. The all important method for enumerating the collection is which has a special attribute set. The class also has a factory method for creating a Widget (Without actually adding it to the collection). 

I've sacrificed a few features of Collection (like being able to add a Widget before or after an existing collection key), and I haven't honored the CompareMethod of a Dictionary, but these are easily added. Have I missed anything? Am I missing some performance tweaks? 

So I built a system of classes to handle all of this, these two here are the base two. How can I improve this code? Any new Java 8 features I'm not taking advantage of? Position.java: 

@Filipe hit the main point I wanted to cover. But there are some minor improvements that can be made. 

If it were true that a small change in a weight (or bias) causes only a small change in output, then we could use this fact to modify the weights and biases to get our network to behave more in the manner we want. For example, suppose the network was mistakenly classifying an image as an "c" when it should be a "o". We could figure out how to make a small change in the weights and biases so the network gets a little closer to classifying the image as a "o". And then we'd repeat this, changing the weights and biases over and over to produce better and better output. The network would be learning. The problem is that this isn't what happens when our network contains perceptrons. In fact, a small change in the weights or bias of any single perceptron in the network can sometimes cause the output of that perceptron to completely flip, say from 0 to 1. That flip may then cause the behavior of the rest of the network to completely change in some very complicated way. So while your "o" might now be classified correctly, the behavior of the network on all the other images is likely to have completely changed in some hard-to-control way. That makes it difficult to see how to gradually modify the weights and biases so that the network gets closer to the desired behavior. Perhaps there's some clever way of getting around this problem. But it's not immediately obvious how we can get a network of perceptrons to learn. We can overcome this problem by introducing a new type of artificial neuron called a sigmoid neuron. Sigmoid neurons are similar to perceptrons, but modified so that small changes in their weights and bias cause only a small change in their output. That's the crucial fact which will allow a network of sigmoid neurons to learn. Just like a perceptron, the sigmoid neuron has inputs, \$ x1 \$, \$ x2 \$, ... But instead of being just 0 or 1, these inputs can also take on any values between 0 and 1. So, for instance, 0.638 is a valid input for a sigmoid neuron. 

And, I'll use an Enum for setting the state of the predeclareed instance. It's either ready, or it's Initializing a new Point. Note the use of a leading to make the non-default enum member hidden, and the use of square-brackets to make the syntax valid. 

Render the Frames Define a sprite of random numbers between 1 and 3, and a sprite the same size of all zeros. 

And why not throw in a factory method too, although some might argue it's a return to the year 2000. In order to get the enumerable features of a Collection, I'll have to use a Collection behind the scenes, but I'll augment that with a Dictionary that keeps track of the keys used in the Collection. Then, when I want to test the method, I can check the Dictionary (and get all of it's hash-tabled goodness) instead of enumerating the Collection or suppressing a potential error by checking the index/key directly. I also want to make the Collection configurable so that it can be 0 or 1 based according to preference. I've made this setting private to the Collection, so it's up to the developer to adjust for the purpose at hand, but it could easily be exposed as property or set in a factory method. Pass the Widget First, we need a class for the objects that we'll put into our custom collection. A will do nicely. Nothing special here - just a class with a few encapsulated fields, and a bonus read-only property for returning an instance of itself.