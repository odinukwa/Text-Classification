Again, you should prove your suspicions with a profiler before taking any action. Don't waste any time optimizing that you could be using to finish your game. I've used VisualVM before, and found it useful. 

Get the objects that will be moving this frame. Get their bounding boxes, before they move. Call this list of boxes . For each box in , check if is intersecting bounding boxes of objects that aren't moving. If it is, union those the boxes (including ) and replace with this new rectangle. Redraw all the portions of the background defined by the rectangles in , as well as all the entities to which those rectangles belong. 

I can see one big problem with dropping the game loop: things won't be able to happen without events firing. This is important for things like physics and AI, which must act independently of player input. Of course, you could just make a timer that fires every 60th of a second to update those systems - but that's basically just re-implementing the game loop. Barring those issues, I think it is possible (although, perhaps, difficult) to implement the server the way you are planning. 

I'd suggest renaming to - not only is that what it is called canonically, but also doesn't just contain the direction of movement, it's also got the magnitude of that movement. 

This extension is generally only listed if you query the extension string while you are running in a debug context. 

Yes. FBO, shader (changing the currently active program, not necessarily shader state itself) and texture state changes tend to be the most expensive. Conversely, vertex pointers and uniforms tend to be the cheapest states to change. It is almost impossible to actually calculate the expense of any one state change in modern GL implementations; you might pay a small validation cost up-front while the driver defers the heavy lifting until your next draw call or does certain tasks (e.g. pixel transfer data conversion) in parallel when possible. Rather than trying to profile down to the state change level, have you considered using OpenGL timer queries and partitioning your frame draw into a series of timed tasks? Timer queries will give you a much better picture of how much time is spent actually doing work in the render pipeline. If you compare the time taken to finish a frame using CPU timers versus the sum of times taken for all pipeline tasks, that will give you some information about non-GPU related overhead. For example, if your entire frame finishes in 5 ms but the CPU blocks for VSYNC (let us assume 60 Hz), you will have a difference of 11 ms between the two numbers. That means there is 11 ms worth of idle GPU time per-frame (in this case because VSYNC is blocking). If you did not know how VSYNC works, that number would be very troubling ;) In my own work, I calculate the time taken to build shadow maps, fill G-Buffers, composite lights, stream texture/mesh data, HDR post-process, apply anti-aliasing, etc. I can honestly say that knowing which state is the most expensive never delivers worthwhile optimization results but knowing which render task is bottlenecking, on the other hand, is an effective use of your time. You will probably figure out the former by solving the latter. 

If I understand you correctly, you don't want to have to redraw the entire screen when a single object changes position. You've basically hit upon the solution; only redraw the portion of the screen that you need to. One method to do this is dirty rectangles. Roughly, the algorithm is: 

In the above code, finds the point where a line and a segment intersect, returns the sign of a scalar, and returns the magnitude of a vector. The part where you intersect the movement vector with every wall can be optimized with a broad-phase approach, but doing it for every edge is often fast enough (it was for me). The harder part with this method is figuring out how to define the edges themselves. It's kind of ungainly to have to define these edges for every level (road) you create, but it's often the easiest solution. If you already have the road data stored in some way, you could probably construct the edges from the angles and widths of the roads. This method will also work with shapes other than straight lines. You can abstract the method to support, for example, arcs, and store generic shapes in the data structure. 

Here's one approach to solving the problem using basic algebra. If you don't care about the steps, skip to the bottom. An easy thing to come up with is, given a level , the total experience needed to obtain that level: 

Tells OpenGL that when you fetch something from this texture, rather than returning the actual value, what it is supposed to do is fetch a value and then perform a comparison against the coordinate in your texture coordinates. What coordinate, you ask? Precisely! Using with a texture that performs comparison produces undefined results because you sample a with 2D texture coordinates. There is no 3rd coordinate to perform any comparison using. 

Here is an illustration of the relation between projection and viewport discussed above:    For more details see the following article. 

Last but not least, here is how a packed texture atlas would be built that would replicate behavior in the presence of a texture filter: (Subtract 1 from X and Y in the black coordinates, I did not proof read the image before posting.)    Due to border storage, storing 4 256x256 textures in this atlas requires a texture with dimensions 516x516. The borders are color coded based on how you would fill them with texel data during atlas creation: 

Because the variable is the only variable in the fragment shader stage that contributes to an output, it is the only active code path. This means the uniform is part of an active code path and will be assigned a uniform location. , on the other hand, is used to compute something in the fragment shader, but that something is never output. This variable effectively dies inside the fragment shader. If you trace its path back to the vertex shader, you will see that was used to set this value, but does not belong to an active code path. Thus, that uniform is not active and is not assigned a uniform location. 

I'm not sure if you are asking about the implementation or the usage of an event based system, so I'll touch on both. The implementation of event systems can be complex, and varies greatly depending on the language, but it is generally doable. The link above to the (excellent) Game Programming Patterns' article on the Event Queue is one hint to an implementation. The Observer (Delegate) pattern is also related; instead of binding to events passed by a mediator object, you bind directly to events fired by your objects. After you have some building blocks, the game logic part is just that - logic. In your specific time-based example, here's what I'd do: 

The usual way to process most input is to set up your game loop to poll for events. For your specific case: set a flag on the event for the key you want to listen to. When you want to process the input, check if the flag is set and if it is, do your action and unset the flag. Example: 

If you make a public array class member in Unity, you can individually assign objects to the array in the inspector menu. It looks like this: 

Before anything, I'd look for a heap profiler and make sure it's the GC that's causing problems. However, if you find that it is indeed the number of objects you have in memory, you've already come up with the basic solution; page your chunks out to disk once in a while and only keep nearby ones in memory. But, as you've seen, there are problems with the approach, namely slowness. My first recommendation here is the same as above; use a profiler and check what's actually taking so long. A few general tips: 

You are missing a call. You need to establish that color attachment 0 is the first buffer your fragment shader is going to output. This should fix your problem: 

The entire array size needs to be padded out to a multiple of the base-alignment for . Your base-alignment in this case is (4N). So that means to satisfy this alignment you need to add a to the end. GLSL will do this for you automatically, and this element is something you need to take care of when you declare this structure in code outside of the shader. 

These are analogous to compiling and linking in a language like C, except some implementations of GLSL (e.g. NVIDIA) actually "compile" your shader in both phases. The most important thing that happens in the Compile phase is that general parse / syntax errors are caught, and inputs and outputs are determined. After the compile phase determines the set of inputs and outputs for each stage of the GLSL program, the Link phase then assigns data locations to things like generic vertex attribute locations, fragment bindings, uniform locations, etc. But there is a catch, it only assigns locations to uniforms that actively contribute to pipeline output. 

Hardware has not always supported floating-point texture formats. In fact, D3D has not always supported depth textures. When you see this sort of thing, it is usually because the application is trying to support an older API or older hardware. To store depth on these systems, they must be converted to fixed-point and packed into 4 channels of a traditional unsigned normalized (UNORM) texture. I do not know how is implemented, but it is probably a dot product and a few divisions by numbers like 255.0 and 65535.0. 

I don't see any real problems with your implementation here, but I suspect your problem is buried in . I couldn't find any mention of it in the documentation, so I assume it's something you've implemented yourself. Make sure you're using or equivalent, not just . However, it'd be easier not to use any trigonometry at all: 

Create a class. It fires a single event: , when some given interval of time has elapsed after the timer is started. Create a object in the class. In , initialize the timer with a time of 6 seconds and bind to its event. In , unbind from the event (since that can't occur anymore) and explode the bomb. Additionally, reset the timer, but don't start it again. In , unbind from the timer's event and reset the timer. Now, the timer won't fire. 

The term stands for the increase in XP needed per level - 50, in the example. We can solve the above using the formula for arithmetic sequences (sum identity): 

However, clearing the screen and redrawing everything should be fast enough nowadays. If you have already tried redrawing everything every frame and it is slow, you may want to ensure there's not something else suspicious going on. 

However, we want the opposite formula - the player's level given their total experience. What we really want to do is solve for the level, . First, let's group the terms: 

To illustrate what I mean by using a border around the edge of each texture, consider the various wrap modes available in OpenGL. Pay special attention to .    Despite there being a mode called "Clamp to Border", that is actually not what we are interested in. That mode lets you define a single color to use as a border around your texture for any texture coordinates that fall outside of the normalized [0.0-1.0] range. What we want is to replicate the behavior of , where any texture coordinate outside the proper range for the (sub-)texture receives the value of the last texel center in the direction it was out of bounds in. Since you have almost complete control over the texture coordinates in an atlas system, the only scenario in which (effective) texture coordinates might refer to a location outside of your texture are during the weighted average step of texture filtering. We know that will sample the 4 nearest neighbors as seen in the diagram above, so we only need a 1-texel border. You may need a wider texel border if you use anisotropic filtering, because it increases the sample neighborhood size under certain conditions. Here's an example of a texture that illustrates the border more clearly, though for your purposes you can make the border 1 texel or 2 texels wide.   $URL$ (NOTE: The border I am referring to is not the black around all four edges of the image, but the area where the checkerboard pattern stops repeating regularly) In case you were wondering, here is why I keep bringing up anisotropic filtering. It changes the shape of the sample neighborhood based on angle and can cause more than 4 texels to be used for filtering:   $URL$ The larger the degree of anisotropy you use, the more likely you will have to deal with sample neighborhoods containing more than 4 texels. A 2 texel border should be adequate for most anisotropic filtering situations. 

It looks like you're incorrectly assuming that the item is removed from the ground immediately upon picking it up. However, it isn't, and the player keeps intersecting with the same item, picking it up multiple times. Before pickup, you should check if the item has already been put in an inventory slot: 

Treat the tilemap as purely graphical data, and use some other structure to resolve collisions. In your case, you can define the boundaries of your roads using edges (segments). You have a vector (line) representing the player's movement, and you want to know if this line will intersect some wall during this timestep. Since these walls are represented by edges, the problem breaks down into line-segment intersection. Pseudocode: 

I couldn't find a great tutorial for this for SDL2, but I don't think the API for this has changed much since SDL 1.2, so you can most likely take a look at some tutorial on events for 1.2 and still follow along. Here's the documentation on SDL_PollEvent. 

The above should fix the problem, but I wouldn't keep going this route. I agree with the comments & answers that the original code is structured a little strangely, in a way that is hard to articulate. It goes something like this: the items on the ground have no relationship to the number of slots you have in your inventory, so they should not be tied together. A cleaner method would be to go through the list of items the player is intersecting with - just once, not for every inventory slot. Every time you find an item the player is intersecting with, find the first empty inventory slot. Put the item in that slot. 

I feel obligated to point out that there are too many things the rasterizer needs to know the facing of the polygon it is drawing for your use or non-use of in the fragment shader to have any affect on the operation of the pipeline. I highly suggest you take a look at the PDF diagram here, which shows all of the stages and inputs/outputs for the OpenGL graphics pipeline. If you look carefully at the rasterizer part of the diagram, you will see that polygons must always first go through facing determination. This is used for polygon mode, culling, stencil testing, and in older versions of GL, lighting. Keep in mind no cross-product is necessary to determine whether a polygon is front or back-facing (GL does not compute or use a triangle normal for this process). OpenGL actually uses the polygon's winding (after projection) and compares it with the front-face you established (Clockwise or Counter-Clockwise). This is a far simpler process than you expected, and it only has to be done once per-primitive, since all polygons in OpenGL are planar. 

Since there was a little bit of confusion in the comments regarding what is required for a uniform to be active, I will try to explain it here. The first thing you need to understand is that in OpenGL, GLSL programs are built in two phases: 

You can spread out the disk writes over multiple update steps, or compress the data before writing it (although, that might be slower than the alternative, depending on your CPU/disk). You may also check to make sure the format (XML, json) you're writing to isn't introducing unnecessary overhead. I haven't done serialization in a while, but from brief research outputs to a binary format which might be faster than human-readable. The exact format of the data is difficult to recommend without knowing what tile data you need. Here is a reference for Minecraft's chunk format. The GC may be trying to cleanup all your unloaded chunks. This is where Byte56's comment comes in. If you use an object pool to manage all your tile objects, then instead of leaving all those orphans for the GC to destroy, you'll reuse them in other chunks that get paged in later. 

However, this is cumbersome if you you want to assign the same array to many objects. It's easy to do this programatically, but I'd rather not hard-define the array in code - it makes moving/renaming the objects harder. If I want to pass the same array to multiple game objects, how can I do it more efficiently than dragging each individual element into the inspector?