To lookup a host (your raspberry pi is a host) by name, you need a lookup table which lists hosts and their ip addresses. In real world the lookup table can be present in several places including two below: 

To diagnose it further, you can use iostat to find what process is waiting for disk I/O. This post may be helpful in checking your SD card. 

You can start tightvncserver at startup by adding the line into /etc/rc.local. rc.local starts after all the services are up after the OS start. Here is rc.local from Raspberry pi documentation. 

You can see a large slot on the PCB (below text L-4765) that provides electrical and physical isolation between the primary and secondary sides of the power supply. No tracks or electrical connections are routed across the slot. New cheap manufacturers can cut corners and don't adhere to standards and hence may not isolate the primary and secondary sides properly. The primary side is connected to Live AC voltages. Here is an article that has more details. Wikipedia article on SMPS - Search for "shock" Power supply isolation article by Sunpower 

If there is a lot of load connected to your Raspberry Pi there is a chance that polyfuse F1 will trip. Usually a polyfuse resets within minutes after disconnecting power and load. It depends on the temperature not time. If it cools down fast, it will reset fast. A bad power adapter will mess-up things as well so make sure you have a good quality power adapter and no load (no USB peripherals or any GPIO load connected) when testing you Pi. 

On the other hand, you need to write software for Raspberry Pi to accept the data from SPI port and process the data as you wish. 

Here is a project regarding connecting a tilt switch to raspberry pi. It includes a YouTube video demonstrating how to interface with tilt switch. 

Referencing the star topology diagram above, your blue spheres can be Arduino boards, red disc in the middle can be Raspberry Pi and yellow segments will be your WiFi link to Raspberry Pi. 

Your source host. This is taken care by host files as droo5ki mentioned. On your network where it provides lookup service to devices on your network. 

You cannot convert any IO pin to a PWM pin. You can definitely use another Integrated Circuit to get 16 PWM channels. Take a look at NXP PCA9685 16-channel, 12-bit PWM Fm+ I2C-bus LED controller. From the description: "The PCA9685 is an IÂ²C-bus controlled 16-channel LED controller optimized for LCD Red/Green/Blue/Amber (RGBA) color backlighting applications. Each LED output has its own 12-bit resolution (4096 steps) fixed frequency individual PWM controller that operates at a programmable frequency from a typical of 40 Hz to 1000 Hz with a duty cycle that is adjustable from 0 % to 100 % to allow the LED to be set to a specific brightness value. All outputs are set to the same PWM frequency." 

As per the map you have connected the LED to 5V and GND via a resistor. GPIO Pin4 (as mentioned in your code) is actually pin 7 on the GPIO connector. You need to connect the LED to right GPIO pin in order to control it from software. 

Large IO queue - Server not managing disk writes quick enough Low memory situations where memory can't be allocated to processes. Sometimes this is caused by memory leaks. SD card driver failure, causing EXT3 journals to be aborted 

At the moment it is unclear what kind of connector is there on your e-ink display. Assuming that you have a similar kind of connector, you can use DuPont cables to wire up your display. DuPont cables are pretty cheap and abundant on eBay. A picture of DuPont wires is below: 

These come is SPI and I2C flavors. You can then connect the module to your Pi and enable I2C or SPI depending on your module on Raspberry Pi. You would have to write your own code to initialize and use the OLED module. It is not that difficult as I have used them with PIC microcontroller. 

If you still are too desperate and want to use one USB power port to power you Pi and your through hole board, you can also use a power splitter cable like below; there won't be any need to modify anything, just add a micro USB connected to your through hole board: 

You have a better option to use a MOSFET BJT in this case is less suitable because you are driving LEDs in Digital mode. LED brightness is of no concern; only on or off condition is needed. @SRD is correct that the "Accepted" answer has the transistor in wrong orientation. 

You can use Node-Red to collect MQTT data into a database. You can use Peter Scargill's script to install Node-Red, mosquitto, webserver and other software on your Pi. Here is a tutorial on how to use node red with a database. You may be able to see the data in Node-Red UI table and later export the data from the DB into CSV and read in a spreadsheet. 

Instead of building your own controller using tactile switches, you can cheaply buy a USB SNES controller. That's what I have done for my retro-pi setup. You can buy a kit that comes with controller PCB and case. As you can see below, the buttons are rubber contact based and not tactile. 

Raspberry Pi B+ has under-voltage indicator. Here is a helpful post. EDIT (as explained to Chris): All power supplies (including linear and swithers) have an output capacitor(s). This capacitor tries to store energy in case the there is a transient demand in output current. The cap charges to its full capacity after some time at power up. Upon usage, the power draw may increase marginally (fraction) than what the power supply can deliver. Therefore the energy in the output capacitor gradually decreases with time. The depletion is dependent on factors like: 

You cannot use PGP/GPG keys with ssh directly. Generally, PGP/GPG keys are used for signing, encrypting, and decrypting texts, e-mails, files, directories, and whole disk partitions and to increase the security of e-mail communications. You need to use ssh keys to use with OpenSSH. You can use Puttykeygen (windows) or ssh-keygen (Linux) to generate ssh specific keys. You can put the public key on the target ssh server host and keep the private key on the ssh client host. 

Please do elaborate your question so that this answer can be more precise to your question. EDIT: From your addition it looks like that your display uses FPC cable. One option you have is to manually solder SPI wires to the FPC cable if you possess soldering finesse. Otherwise, you would have to design a PCB that incorporates a FPC connector and header pins. Check with the manufacturer if they offer any conversion options (see below picture): 

If you would like to use graphical applications in raspbian, you can install Xserver on your laptop and use X11 forwarding with ssh. 

The quality (subjective), gauge, material and length of the wire determines the voltage drop from source to the target. as a rule of thumb, worst the quality (in modern terms, cheaper the wire, cheaper the metal), higher the loss. To get more details about the resistance in copper wire, this a good read. In a nutshell, longer the wire, higher the resistance in the wire. Higher the resistance, greater the voltage drop the wire induces. Further reading: Ohms Law 

Using the setup above, all works fine. I don't want to use DHCP. Question: I would like to know if there is some way to configure my USB Ethernet adapter from /boot (FAT partition) --> before booting <-- and logging into the system. I have tried to use ip=xx.xx.xx.xx in cmdline.txt but it doesn't work for me. I also have to setup a MAC address for my Ethernet adapter. 

An improperly isolated power adapter driving Raspberry Pi can cause electrical shock. Usually most power adapter usually used to drive Pi are SMPS. Below is a picture of proper SMPS isolation: 

As you have indicated in your comments you are inclined to use Raspbian. If you want to use raspbian, Follow this: 

To answer you question about performance, SDIO will get you better performance over SPI. Reference: $URL$ 

You can stream video from raspberry Pi V1 to a Pi V2. I have a Raspberry PI B model (host A) and has following services enabled: SAMBA (file share), transmission, etc. Whatever video I have on raspberry PI host name "A", I have exported via NFS and CIFS on the same network. My second Raspberry Pi (host-name B) B+ running OSMC can find that share and stream the video. 

The MOSFET in the schematic above is a general purpose one. You will have to choose a Logic Level MOSFET that will work with 3.3V on the gate. You can add isolation using an optocoupler as well if you want higher isolation between the power rails. 

1. Hosts Files: The first option of host file is viable where there are only a few hosts on the network. This method is manual but not very scaleable. The hoist file is local to one computer only and on a small network, you need to replicate this file to other hosts if they need to do a lookup. This solution is manual and simple. In Linux you can simply edit /etc/hosts file. Use this tutorial for Linux. For example, in windows 7 the host file is located at %systemroot%\system32\drivers\etc\ Here is an example to edit your hosts file. 2. Lookup services on your network: There are several services that you can deploy on your network to provide you a name lookup. These services can be DNS (most popular), NIS, NIS+, LDAP, etc. For simplicity reasons I will only discuss DNS service here. DNS service is meant for a larger scale network. It is scalable and can provide several services apart from just name lookup. Here is how DNS works. This solution is automatic and deployment is a bit complex (relative) than #1 solution above. To answer your question, you need to deploy one of the above solutions on your host and/or your network. Deploying DNS services is beyond the scope of this forum. Your best option will be to use hosts file if your network is small. In order to lookup your host from host itself, you need to add its' own entry in its' hosts file. 

I believe that your PI crashed due to deprivation of power. I believe that your hard drive "sustained read" needed more power that your power supply could provide. The constant power depleted power in the output capacitors of the power supply. This doesn't happen in occasional reads where the output caps get time to replenish their charge. You can test this using a USB power meter (picture below). When Raspberry Pi current draw increases, the cheap power adapter starts to dip voltage below 5V and then the Pi starts to stop working. 

I would say that don't mess with the pi board or alter it in any way. It could induce more problems. You are correct that Raspberry Pi Zero takes under 1A but if your other gadget (throughhole board) draws more power, the output voltage of the adapter will drop and your pi will either become unresponsive or may restart due to under volt condition. There is also a chance that if your other gadget has inductive load, it can cause spikes on the Raspberry Pi power line. It is recommended to keep the power separate. Unless you have an adapter that provides two USB sockets like one below. These power adapters are cheap. Also would like to add that not all adapters deliver the power as marked. 

Although you can use other transistor based solutions but an opto-isolated board with keep your Raspberry Pi safe as the power rails will be kept isolated. 

PTC "F1" will trigger (or temporarily blow) if the Raspberry Pi consumes more than 2.5A. This means it would only blow if you overload you Pi with multiple USB loads that are >= 2A (some power is consumed by Pi too). Also as per the datasheet of F1 (MF-MSMF250/X), it has following threshold levels. The fuse holds at 2.5A and trips at 5A. 

Overall, tactile switches are not used in mainstream controllers from PS4, Xbox, SNES, NES, any Nintendo, etc. These mainstream controllers use soft switches / buttons with rubber pads. If you are too inclined to build your own controller, then try to find some non-tactile switches. I'll try to improve this answer if I can find some good switches. 

In order to track unique mac addresses on your Raspberry Pi, you need a tool (rather service) called arpwatch. I have used arpwatch on BSD extensively and it logs all arp and rarp requests into syslog. From Syslog you can parse dates and times and mac addresses. ARP works and table exists only on the physical network (technical word: collision domain). When a packet leaves for another network, the source mac address is replaced by router's mac address. Running command on Raspberry Pi will only list mac + IP addresses of hosts who have transacted (IP communication) with the host on which the command is run (Raspberry Pi). It will not list mac addresses of other hosts on the network. Another advanced way would be to use nmap on your Raspberry Pi to do a host discovery. You can use to ping all hosts on the network. It will tell you IP addresses of all active hosts on your network. Then you can run arp command to find out mac of who is active. 

Safely unmount the SD card and insert into the Pi Connect ethernet cable to your pi and power it up ssh into the Pi using your laptop 

To answer your question, yes, you can connect PIC16F1519 to your Raspberry pi. You can use SPI (low latency) to interface with the microcontroller. The project won't be easy if you don't know anything about EE. Some EE and programming knowledge is required. You need to program your PIC in C or Assembly to scan the ADC channels and output channel data to SPI. Your PIC microcontroller will act as SPI master and Raspberry Pi will act as slave. You would need to install programming tool chain (MPLABX - free from Microchip) on a PC/Laptop and buy programming hardware to physically program the flash memory of PIC. In addition, you would need to design input filters for your ADC inputs as a single piezoelectric sensor could output more voltage that the ADC input can accept. Here is an article on piezoelectric sensors and design. A sample input stage schematic is below. The resistor values would have to be chosen as per your sensor spec (from datasheet).