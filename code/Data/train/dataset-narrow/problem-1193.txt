For the cross product I used this code snippet: $URL$ Slow as hell but seems to be fp with vanilla JS only: 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 6). You can only access the 2nd part if you type in the solution for the 1st part: or look at my solution for part 1. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the 4th problem from project euler: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code. $URL$ 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 3): $URL$ I'm doing the 2nd part of Day 3. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 3 (part 1) in Functional Programming (FP) 

The code above has got more operation than in the first part of this riddle. But it's way faster and shorter than the functional approach of the 1st problem (Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP)). My FP solution: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 5): $URL$ 

Other answers have handled specific issues, mine will handle larger design issues. Some of my later advice is highly opinionated, but it is motivated by real design problems; be sure to understand the problem before dismissing it. 

Instead of , use to avoid precalculating and storing the entire sequence in memory (and also spawning an unnecessary subprocess). Instead of , use to name the argument then use . Note that is an alias for , but it's idiomatic to use for assignments and for expressions. Beware of the possibility of failing! Using an chain as @glennjackman suggested will avoid this pitfall. It would also be possible to replace with but that's ugly IMO. 

That said, your short-circuit if the lengths mismatch is a good idea no matter which implementation you use. There are some style issues that jump out with your implementation: 

Any memory that you read/write from multiple processes (or threads) must be protected either by some sort of mutex or by atomic operations with an appropriate memory order. It would not be enough to . So the following line may be optimized to be an infinite loop: 

Note that it does not return indirect subclasses, only immediate ones. You might also consider what happens if some subclass of is itself abstract. Speaking of which, you should be using and . 

All of the above, except for the last two which are special, provide exactly the same public API (except ) and can be implicitly constructed from each other if it makes sense. 

By the way, \$O(2n)\$ is equivalent \$O(n)\$. However, the bound is actually tighter: \$O(n + m)\$, where is the number of distinct elements. This is, however, an average bound, because it relies on a . If the worst case hash collisions happen, you get \$O(m(n+m))\$ 

There are a lot of functions that aren't safe to call in a signal handler. For the few that are allowed, look at the Async-signal-safe functions section of the signal(7) man page. Your current signal handler is almost okay, but any variable that might be changed from a signal handler needs to be declared . Officially it must also be instead of , though I'm not sure how important that is on real-world platforms. You should be checking the return value of and . They will return (which is usually but could theoretically be any negative number) with set to if the signal has been delivered during the underlying system call. That said, there is nothing to prevent the signal from being delivered before or after the syscall itself (before is the nasty case, and doing the syscall yourself won't help unless the signal is blocked around the call). If you want to handle signals in any sort of sane way, you need to them, at least some of the time. Either then unblock them during "safe" runs of code and check the flag periodically or else leave them blocked call (which will not invoke the handler). 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? I have problem with the lookuptable . Everytime I "add" a new element to the scoreboard, I had to pass the new scoreboard along. There is probably no other way around this in FP since FP functions have to be self-contained, i.e. every new value that needs to be calculated have to passed along. But I still wonder whether there is a nice FP solution to that. Any other improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took the a problem from project euler: 

The FP solution is longer and slower. I couldn't solve it without recursion. After a while you hit the stack size. Thanks to Thanks to @Blindman67 he suggested a workaround with . Do you know an FP approach that is faster and shorter than the procedural one? 

As you can see, it is not consistent with the idea of FP. First I wanted to write it using recursion but I hit the stack limit. Therefore I used generators (and loops). That was the only solution I could come up with that resembles FP. Any suggestions how to write in FP without any additional FP-Library (i.e. in pure JS only) is much appreciated. 

Running this code with in normal mode will create a . I had to "cheat" by running this code in : (node 6 supports Tail Cail Optimization (TCO) when the flag is turned on). I also tried to cache the but this didn't help either. I got the feeling that big size Input is the limit for FP. 

I'm doing the 2nd part of Day 5. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code 2017 Day 5 (part 1) in Functional Programming (FP) First my procedural solution: 

Unused local variable. I would write instead of . Feels more natural. But in the end there should be no difference. You are making no check against exceeding maximal positive value for . Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

Instead of writing to use exceptions. There are also other means (like returning error code). But outputting to is of no use. (And seems more adequate anyway...) in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be go crazy (although it would not be infinite). Instead of that you could start with . In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. You could extract the loop fragment to separate () method which returns of given position. It would make code somewhat cleaner. And also you could reuse the method in other functions that I recommended to add (in comments above). You should first store in a local variable. Then set to . And only then the local variable. Current code uses of already deleted object and sooner or later will crash on that. I would write instead of . Feels more natural. But in the end there should be no difference. This method is badly implemented anyway. For example on a list constructed with the single element constructor calling will actually the node from but will never update member. Maybe changing the condition to (and next to ) would correct it. But since the idea of is likely wrong this method would change anyway. 

I wanted to practice functional programming (FP) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 1st part of Day 5): 

First I wanted to solve this using recursion. But I reached the stack size pretty quickly. Therefore I opted for generators. But I'm not satisfied with my solution especially because of the generator: 

Is there a better way to write it in FP with pure JavaScript, i.e. no additional FP library? Any improvement suggestions are welcomed. 

Is it possible to solve this problem yet still be consistent with fp, i.e. no mutations and no loops? And of course: Any other improvement suggestions are welcomed. 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Project Euler: 

Is there a way to write with less parameters and still be consistent with fp? Any other improvement suggestions are welcomed as well! 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code (the 2nd part of Day 2): $URL$ I'm doing the 2nd part of Day 2. You can only access the 2nd part once you solved the 1st part. To access the 2nd part type in this number or check out the solution here: Advent of Code Day 2 (1) in Functional programming (FP) 

Is there a better way to write it in FP (without any libraries and with vanilla JS only)? Also any improvement suggestions are welcomed! 

I wanted to practice functional programming (fp) without using any library but using vanilla JS only. So I took a problem from Advent of Code: $URL$ 

There is no good reason for you to make 4 separate calls. Most likely a single call for would be enough, but even if you have a pressing need for them to be on separate pages, you should still 4 pages in a single call. You don't need to open to get anonymous memory, just pass as the FD and add the flag. 

In my experience providing or on strings is a mistake. Instead, strings should be constructed via one of: 

You're matching the regexes in a loop, giving it \$O(n m)\$ performance instead of \$O(m)\$ where \$n\$ is the number of regexes and \$m\$ is the length of the text being matched. Any halfway decent regex engine can match an arbitrary number of regexes simultaneously and then tell you which one matched (a trivial extension to the way is matched; I've done this in C); I am not familiar enough with JavaScript to know if it has one. Possibly since these regexes are fairly simple, you could capture a fixed piece of text and then use that in a dict lookup? 

If you're using , you shouldn't have the shebang in the second script. If you're using the shebang, you shouldn't use . But rather than use directly, I would the script once at startup, and in it define a function that was called at the later times. You should use instead of to avoid forcing a separate subshell to spawn. I would provide a default instead of exiting if no argument is passed. Something like . Also, I always use named variables as early as possible. Note that if you were using a function (with or without ), you should use to avoid leakage. 

That way it can be run directly with (and possibly other harnesses, I know the standard requires wrapping them in a dummy class, but I haven't used any others).