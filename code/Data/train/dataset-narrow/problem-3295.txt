As a prototyping requirement you would not like to solder and de solder things constantly, you could use PCB headers. These should be 2.5mm single headers. Male or female whatever suits you best and use prototyping cables. Solder these on to the PCB and peripherals and then you can then plug things in and out as you require. 

As milliways has answered you will get a steep voltage drop on such a distance using 5volts. This is common problem in all long distance power transmission. The best solution is to use a 24 Volt power supply and use a 5 volt regulator on the Pi side. There are cheap modules available or you can easily make your own regulator using a capacitor and a voltage regulator 78xx. (Sparkufun) (Wikipedia) But it would be more efficient to use a switching regulator V78-1000 if you want to save power. 

You may have to start with a Wired network connection though as you would have to setup your WiFi via the WebGUI or PowerShell first. 

You can find out more about the Raspberry Pi on Wikipeda and searching the internet using your favourite search engine. 

So the Pi connected to your linuxbox and created a tunnel within that connection back to the Pi :) On the linux box you will connect to the Pi using. 

The first thing I would do is regenerate your SSH keys and change root password. Now a days it is not really good practice to release images with default passwords and SSH host keys. User should be setting root password and generating keys on their hardware on first boot. 

But you still need a PSTN Gateway- You can't (and please do not) connect PSTN directly to your Pi or any custom made device. A cheap and good one is Linksys PAP2T and lots on ebay. I would recommend SPA3102 and that is what I used at home. 

edit 1: I've taken a look at Install NTP on CentOS which turned up in a search for help trying to understand what "lithium.constan" meant, and I found the command: 

After disconnecting the WiFi, I captured a few responses. According to the page 22.13. Checking the Status of NTP the column labeled is "how long since last poll (in seconds)" and it increases with time as expected. But I don't understand why between 155 and 434 seconds that "jitter" changes, or between 434 and 687 seconds "delay" changes. Right now I'm classifying that as an inconsequential bug and ignoring it. To me, the value of "when" is most important 

Comments by @Joan (above) were extremely helpful! MCP3008 does indeed use , where I had it erroneously set to . The following works very nicely! 

My PiBox module, I've left the verbose print statements in to help explain what I believe each step is doing. It's certainly safe to ignore or delete them: 

edit 1: per @Joan's comment: pigs, the socket interface to pigpio also returns random bytes. The following are the pigs equivalents to bb_i2c_open, bb_i2c_zip, and bb_i2c_close. All bytes are non-repeating. 

appears when trying to kill it. So for almost a minute, the DAEMON is a zombie (so to speak). This means that the idea of quickly turning it off and then on again is a bad one. Instead, if the OP (me) really wants to do this with Python, the script has to honor this transient zombie status and not just start and stop it willy-nilly. 

I've turned the WiFi off about five minutes ago so that explains the watchdog timer being 372 seconds. Is the value for frequency what I'm looking for? Question 1: Is using the lowest value for "when" a reasonable way to gauge roughly how long it's been since the system time has been checked against internet servers? Question 2: Does the ntp daemon make an estimate of system clock drift rate available in any way? If it's say 10 ppm or 100 ppm, is this reported somehow? Question 3: What do the characters in the first column such as '+', '*', '-', or absence thereof indicate? System: using Raspbian GNU/Linux 8 (jessie) 

The proper way would be to create a function that returns a boolean on the while comparator. but this is how the shell logic should look like. 

The WS2801 is a 3 channel constant current LED driver. You need 1 of these for every LED. THere are other RGB drivers but the WS2801 are the easiest and most flexible to work with. The power source MUST be separate to the Pi. But that is easy as connecting a power pack to the Vcc and GND on the LED strip. 

You can use I2C SRAM modules, like the PCF8570P £1.50ish 256x8Bit SRAM. It operates between 2.5V and 6.0V, has a power saving mode that draws as little as 50nA and can be stacked to create more RAM if needed. Hook it up to I2C directly or to a Master for multiple I2C device. Only uses 2 GPIO, Power and Negative, with the option of MCU power off RAM retention using a small battery. 

If you just want it to have internet, Step 1 is enough. Steps 2 and 3 are required if you want to share that internet over LAN or WiFi. 

I have several of these modules. The problem with the slow ping is a bit strange? It should be less than 1 second, even more like 100ms. The other problem is this module only supports GPRS (115kbs) if your GSM supports dual band GPRS (or 2.5G). Most networks do not support this any more (or are deliberately switched off because it affects voice) so your speed is only going to be a max of (57.5kbps) and even that is optimistic. I would say you are getting about ~36.6kbs. Ping should be good at these speeds but browsing modern websites is fatal. It doesn't matter if you have 3G/4G or better in the area. The reason is that GPRS extends the GSM Circuit switch and the more people logged on within the area the slower things become. So what is this module for then? Well, at 8 bucks a piece its great for sending compressed JSON to servers for logging data. 

smbus works. When I convert these back from BCD to ints, I get a reasonable time object, with seconds increasing at 1 Hz. 

I'm using pigpio bit-banging script (download, GitHub) that interprets the pulse durations generated by the DH22 Temperature/Humidity sensor. It sets a 200 ms pigpio watchdog to the GPIO pin and attaches a callback, passing the tick count and new level. Here's a generic example: 

I am writing a data logging python script and I would like it to find out if the system clock has been synchronized via NTP recently, and if not, to attempt to cause it to happen before proceeding. Starting from this answer, I've found that for the status 

Question: What could cause to fail to start pigpiod successfully some of the time, but still always return and throw no exceptions? edit: RPi 3, Python 2.7, Raspian 8.0 jessie Failure looks like this: 

will display the results on the console, but I don't know how I can get the python script to see if ntp is active or not, since this call returns only . I could always just force a reset even if not needed using 

It turns out that this sluggishness in the pigpiod DAEMON's status is real. It's not a problem in the script. I saw this by accident while trying to stop and then restart pigpio while debugging a DHT22 script. Here's some text from the Pi's terminal. After the killall, pigpiod can not be started between and . The message: 

I'm trying to check on the status of the pigpiod process from within a python script. These two methods both appear to work so far. Are there any significant advantages or disadvantages of one over the other? Are these likely to be reliable ways to do this? 

You can also plug in a Bluetooth Adapter and use a Bluetooth Keyboard and mouse. But you need to configure Bluetooth in SSH (Or I think the latest XBMC has some kind of BLuetooth paring setting) 

No problemo... That is not a problem at all. I have a realtek WiFi dongle that gets really warm. It is slightly worrying but it is quite common for Wireless dongles. *some dongles get extremely hot! Why does it happen? I found a very generalised block diagram of a RN171 WiFi chip. This is a standalone unit that you can attach to other MCU like a Arduino. The highlighted part is the modules interface which is specific for these modules. As we can see there is a 32bit CPU and the Crypto Accelerator mentioned - Usually USB adapters will have some proprietary CPU and AES hardware. These will generate heat in different ways from different vendors. 

Using just basic HTML and jQuery you can achieve that. You can do debbugging the JS in Chrome or FireBug. All this is easy and free. Just a small learning curve, which in my opinion is worth learning. 

Another way is to create NFS shares, these should work well between Pi's if you are on the same network. 

It is one of those mini dongles and its plugged directly into the Pi's USB port. I have the Pi powered by GPIO 2A and I removed the USB fuses. The USB are powered directly by the 5V rail from the GPIO pins so it can't be power problem. This dongle does work in Winblows very well even at 30% 

The Pi was not designed with networking in mind. It can connect to the internet and download stuff but really it should not be used a a speed critical router. But saying that I think, the solution will be to use a USB3 Hub, with yourt Gigbit USB adatpers. 1 of which will be connected to the Pi so it works like a router. THis is really messy but its the only way I can see you increase performance. Because the Pi only need to route data to other places this might work. But I have never done this, and I never will- because its too expensive, too many problems. You should consider buying a mikrotik router or running or pfSense - On hardware desinged to do it. Here is a list of more OS designed for routing. I am sorry if that is not the answer you were looking for but I hope you find a new OS and hardware to do this, properly. 

What caught my eye is the "stability" measurement. I'll let it run for a while to see if it becomes non-zero, hoping it might address Question 2 below. edit 2: Looking at the question timed out, nothing received on ntpdc> loopinfo? I found the command 

This is a partial answer; I am going to try to understand further why this is so. If someone is able to explain further that would be wonderful. The behavior described by the OP (in this case, me) is: 

I started to try to read an MCP3008 ADC using SPI bit banging with pigpio. I wrote the unattractive little script below, starting from the example in the pigpio documentation and here is a screenshot of my output. I believe that this should read the lowest four channels of the ADC and print the output. Channels 0 to 3 are connected to +5V, GND, +5V, floating, so I expected to see values like 1023, 0, 1023, xxx where the last would be noise. Instead I see all 1023's. Have I done something terribly wrong? 

Today's announcement at raspberrypi.org: Raspberry Pi 3 Model B+ On Sale Now at $35 describes several improvements. In the linked YouTube video changes to the power supply are discussed between and , but I'm not quite sure which parts are historical review, and which are related to the most recent changes. Could someone point out which are the main points they make here about the new Pi 3B+ power supply? 

Questions are at the bottom. When adding a time stamp based on the Pi's system time to a data file, I'd like to include some information about how reliable that time is. For example, if the Pi has not yet made an internet connection since power up, the system time will be quite wrong by hours, days, or worse. If the last opportunity for synching to ntp servers was say 24 hours ago, it could potentially be off by many seconds, and if it were ten minutes ago, it's "good" as far as I'm concerned. I'm using the following python to capture all of the lines in the response so I can decide later how to interpret them, the suppresses the header of column labels 

I actually use a HDMI to VGA (with build in active chip) to use on older monitors. But I see now for roughly the same price of £10 they also have an audio out jack.(Remember to look for cables WITH the chip or external power. Not the cheap £1 cables. THey won't work) 

You can also try and find a universal power supply with a USB port. So the lead will supply 12volt and you can power a HUB with various things and the Pi. 

So the best choice here is the Model A for low power consumption. To further decrease power consumption. 

The worst part is plugging in the hard drive. The initial jolt of power needed to spin the internal discs can cause the Pi to reset. But if your is not then that is fine. When it is spinning the power consumption is stable and low, even when accessing the drive it does not go up that much. If you have a Rev2 board and a good 2Amp power supply you should be OK. But be careful of adding any thing else. For example adding Wifi or 3G modem might just go overboard and start to cause issues. 

A relay is an electro magnetic, mechanical switch. You should not power a relay directly from GPIO because relays use allot of power to pull and hold the switches, plus there is risk of feedback that can cause damage to the GPIO. You need to use Diodes to prevent this and have a reliable power source, which the Pi does not really have. It is easier to buy pre made Relay breakout boards, for use with Arduinos for example since they are built to be driven by GPIO and have all the protection built in while allow low power IO to activate the relays. You can also look at using high power transistor- but these come with their own pitfalls. They can generate high amounts of heat and they can burn out creating short circuits on your high power- causing more problems. But they are easier to use if you understand how to use the, 

I'm trying to learn how to safely and reliably start and stop the pigipod DEOMON process from within a python script. If pigpiod happens to be running already, then this script is always successful. It stops pigpiod and then starts it again. But if pigpiod is NOT running when I run this, then MOST of the time it fails, and the standard message block that starts with "Can't connect to pigpio at localhost(8888)" appears when I try to instantiate pi = This happens even though returns , there are no exceptions, and a was executed "just to make sure". 

but it seems like a bad idea to do that if it wasn't necessary. edit: using Raspbian GNU/Linux 8 (jessie) Question: How can I test the status and then conditionally force a synchronization only if needed? This answer suggests the package $URL$ but I'm not sure if this is advisable or not, so I thought I'd ask before installing and running it, and I'd still have to guess the status by comparing the results to the system clock and deciding if the agreement were good enough or not. I'd still like to know if ntp is active and that it believes the synchronization is close. 

For the next 1000 milliseconds, a transition in either direction on pin 22 will result in a call to , passing the new level and the tick number (microseconds). If I understand correctly, in pigpio one can set up one watchdog per GPIO pin, so there could in principle be many running at the same time. My question is what are these watchdogs? Are they CPU threads, or are they running in the GPIO electronics itself, or something else? Like real dogs, can they compete, conflict, or collide (say two watchdogged GPIO pins experience edges at exactly the same time), or do they get along nicely with each other? This is from and may be of some help: