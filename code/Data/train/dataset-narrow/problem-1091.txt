Ruby has several ways to conveniently print text. First there is string interpolation. You use double quotes on the string, and use inside the string. When ruby parses the string the code is executed and the results replace the code in the string. 

Marked up code Rather than extracting small lines of code and commenting on them, instead I've added many inline comments about your code. I've also modified it in several places, trying to keep your logic intact where possible, and I've added comments about the reasons for my changes. 

Break out of loops sooner This applies specifically to your spaceship and to a lesser extent to asteroids and torpedoes. Once the spaceship is destroyed, return. Any other collision checks are wasted processing time. For torpedoes and asteroids, once a torpedo has destroyed an asteroid, break out and move on to the next torpedo. This leaves a small edge case where a torpedo might perfectly hit two asteroids at once, so this decision is up to you. 

Dom2 was the fastest because it has the fewest number of operations by far. As a weak rule of thumb, when optimizing math, try to avoid BigNum and Float when feasible. Also try to avoid things like converting numbers to strings and then back to numbers. Conclusion Know that more often though, that your slowdown will usually come from lots of branching and flow control, and being inefficient (like calculating the same things over and over rather than caching them), and those are the places to optimize. If this problem were part of a larger, more complicated task, I can practically guarantee that your bottleneck would not be ANY of these functions, but something else entirely. 

They are syntactically equivalent, so choose whichever you prefer, however the second one is more idiomatic than the first. As Paparazzi mentioned, you should use lower case for the first letter on your variable; in idiomatic C#, only classes, property names, names of structs, and enums should start with an upper case letter. Updated: added additional notes on what should be capitalized 

Since you are doing the same operation over and over, you can put your strings in an array or list and use a mapping function. For example: 

Some style comments: First, you don't need to put in a class, you can simply declare it and use it directly. Additionally, the ruby preferred style is to use snake_case and if the function is a predicate (a function that takes a value and returns true/false) you should add a question mark to the end: 

already has a mechanism for passing and retrieving arguments. The has a property for a passed in method argument and a property for the DoWork result. The has a property for retrieving the result. No sub-classing is necessary, although you may need to make a custom container if you need to pass/return more than one object. 

Shorthand if/elseif syntax You can use the keyword in conjunction with and to cut down on the whitespace of your if-eslif chain. The syntax would look like: 

It looks as though you only operate on a single chunk of the array at a time, and once done you don't revisit an index. If that is the case, this is a good candidate for doing these operations in parallel with multiple threads. Also, if your consecutive IFs are mutually exclusive ( I can't tell ), then you could possibly convert them to a switch statement and/or use Boolean operators rather than logical operators. At a minimum you could use else-ifs. Finally, you could always re-write this in assembly, or perhaps fortran, if you are super concerned with performance. 

Set Unions Looking at your code, when you loop through the attrs, you are breaking after you find the first key that is in and in and in the passed . This is also known as the of the arrays. As such you can simplify the inner loop with: 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

be it a constant, or a collection computed in run-time, doesn't really matter. And then it gets as simple as that: 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

doesn't make sense to me. When your code is conditional, DRY (Don't Repeat Yourself) and try to extract whatever is common for all execution paths. Eg. 

It doesn't have to be static, although there are conflicting schools of thought here. On one hand, making a method static sort of stresses the fact that it's stateless - and for instance the popular code quality tool for C#, ReSharper, suggests this by default. On the other hand, making a method static has certain consequences, such as an inability to override the method. I don't think it's a big deal either way in this case, anyhow it's a little controversial whether statics should be used by default. As for other remarks: Overall design The class is called , but it knows some other tricks beyond notifying (by sending emails. By the way, I would consider renaming it to to resolve any possible ambiguity, since there are various types of notifications in this world, but I'm not hellbent on it). What it also does is that it searches personnel members by their ID - that doesn't qualify as "notifying" in my book? I would expect retrieving a manager by ID to be implemented on - let every object take care of itself (aka Law of Demeter). Naming 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

Code style Magic numbers In "DatabaseManager", I would convert "magic numbers" (connection life time being 5 minutes, command timeout set to 120 etc.) into constants. Fluff / noise 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

On a personal note, I wouldn't necessarily use inheritance as my go-to solution for this problem without a lot more knowledge and thought about the use-cases; I only followed your initial design. Temperatures themselves are fairly trivial, but perhaps for a more complicated scenario this implementation would have advantages. 

Don't Repeat Yourself (DRY) Your IsSimilar() function consists of the same code block, twice. Anytime you have duplicate code you should usually either break it into it's own function or find another way of eliminating the duplication. An example implementation removing duplicate code: 

Put the workers in a list of available threads. In the main thread, check if there is a free worker in the list. 

Similar to dankohn's comment, there are really only a handful of operations going on, just with different character sets. Here is my quick implementation. It only handles the base 10 digits, and dynamically swaps out character sets depending on the power of the number. 

The BackgroundWorker.RunWorkerAsync() and RunWorkerCompletedEventArgs only accept/return a single object and you need to pass two (the block index and the block itself). You will need to either use a tuple/struct/class or something else to hold both objects when passing back and forth. Finally, You may need special handling for the last block of the file. Some encryption algorithms (zero) pad a short block to the expected length (1K in this case). This means that your encrypted file may be slightly longer than your unencrypted file. If this is the case for your chosen algorithm, your allocated output file size may be slightly longer than the original input. Depending on the file contents, this may or may not be an problem, however you should be aware of it as a potential issue. 

If you can't do that, when you start the new thread, try setting the thread priority to low or tweaking other related settings. 

This is built assuming you want no duplicates in the results, since the goal is a little unclear. Quickly Finding Combinations The function you should be using is , which generates an enumerator that yields all combinations of size from the array. Once you have that it is a trivial matter to only select the combinations that sum to the target value. My function here finds all combinations of size 2 to size and then selects only the combinations with the correct sum. 

Additional Thoughts As janos mentioned, your program has several usability issues. While I've cleaned it up some a little and added better input validation, there is still a lot to be desired. Making the user enter coordinates, especially without adding row and column headers is hard on the user. It would be better to either add headers, or even better, add a guide with numbers and letters off to the side. For example: 

Reference Implementation Because there has been some interest in a fully compliant implementation, I have created one. This loops over each character once. There is no look ahead/behind (although I personally think that looking around fits within the spirit of the instructions) and instead I cache the 'a' character when checking for a 'c' on the next pass. This of course makes the code look a little ugly, as like fizzbuzz, the checks are not quite similar. This was written and tested in C. 

Update: What I mean by Block Index Let's say a file is 10K. The first block has index 0 and is 1K in length. The second block has index 1, the third index 2, etc. The file has 10 blocks with indexes 0-9. Now lets say that I queue things up and block index 4 finishes first. In my output file I seek to position , or 4000 and write the 1K bytes. Then let's say that block 2 finishes. I seek to position 2000 and write the 1K. My output file now looks like where '*' denotes valid data and '0' denotes empty/nothing written. For performance purposes, I'd probably let the UI thread open the output file at the beginning and only close it after the last block is written. You know the file is done when all of your workers are sitting in the list. (Workers also have a property to check their status :) Links