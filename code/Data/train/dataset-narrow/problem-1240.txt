This is the highest consecutive prime sum that results in a prime number that you can get with prime numbers starting from 2 (2+3+5+7+11+13+17+19+23+29+31+37+41+43 = 281). To start from the next prime, you simply drop the first prime, and so forth, e.g. 

Controllers I made controllers for logging in, logging out, and registration. These all return a response, which is then used by AngularJS. Basically, it creates an APIKey on succesful login and destroys all APIkeys related to the user on logout. 

I defined a data type for the ranking, which is something like high card or flush. A HandValue is the combination of the ranking and the values of the cards related to the ranking + the kickers from high to low. For instance: . Note that even though I have an ace, the values that are relevant (i.e. the two pairs) come first. This allows to compare two HandValues with the same ranking (i.e. ). The instance for HandValue looks at the ranking first, and looks only at the values if the rankings are the same. To actually rate a hand, the suits and the ranks are separated, then: 

These two checks give us the option to filter out StraightFlush, Flush and Straight. If it's neither a straight nor a flush, we need to look at grouping the ranks. Then we match the length of the list of similar ranks to find everything from to . The values are in this case the concatenation of the list of similar cards (e.g. rather than the ranks from high to low (e.g. ), to make sure the relevant values for the ranking (e.g. ) are compared first. A line is parsed by removing the spaces, then splitting (resulting in a tuple , which then mapped over by , and then the first value is compared to the second value, resulting in a boolean that is if player 1 wins the hand. This is then used as a filter to count the length of the list of hands in which player 1 wins. My implementation works perfectly and is very fast (100,000 lines in 10 sec in ghci, actual problem is instant), so I'm not necessarily looking for performance improvements; any kind of feedback is more than welcome. 

If the user is not logged in, they will be taken to a login window (this app is for logged-in users only), that posts the username and password as follows: 

I'm making an app with a Flask API backend using a Flask-Peewee ORM and an AngularJS frontend. The Flask-Peewee ORM doesn't support token based authentication, so I decided to try to implement this myself. This is quite a bit beyond what I usually do, and I have in fact no idea whether this is secure or not. It does work, but that's all I know. Any feedback, from pointing out obvious security flaws to advice on good practices, is more than welcome. This is my implementation: Models I made an extra model for the api-key: 

This is the highest consecutive prime sum that results in a prime number that you can get with prime numbers starting from 3. The rest is fairly obvious; it checks for each starting prime the greatest prime below 1,000,000, gets the length and the prime it adds up to, then gets the prime with the maximum length. Any advice is welcome, specifically on: 

looks for the last element in a list that satisfies a condition then returns that list up to that point (e.g. -> . (Note that it differs from , since will start at the beginning of the list and stops as soon as it encounters an element that does not satisfy the condition. My function starts at the end of the list and looks for the last element that satisfies the condition, regardless of whether there are elements before that that don't satisfy the condition, e.g. . This is useful to check a list of consecutive prime sums (e.g. ) and get the longest one that adds to a prime, for instance: 

I have never written any Lua code before, but a short view in a tutorial at $URL$ let me come up with this: Extract a method which returns 3 values: 

And so on until you have only short methods with speaking names. This makes the code easier to read and understand. 

You could extract the content of inner loops to methods with speaking names. E.g. You could introduce a method like 

to a method passing true or false as a parameter and reuse it instead of having nearly exactly the same code twice. 

Simplified tail-recursive code: end-recursive methods are likely to be detected by the interpreter and transformed to a loop. So this code might be faster and may nor waste memory. For more information see wikipedia Tail call 

to a method passing 1330 or -25 as a parameter and reuse it instead of having nearly exactly the same code twice. 2. You can extract 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

I think speed will only increase a bit, if at all, if you use arrays (The List implementation you use may already use an array). But you will reduce memory consumption if you switch to an array based implementation if you reduce the number of objects used this way. You should profile both implementations to compare speed and memory consumption. 

I think this method is not that long that you really need to refactor it, but you could do something like 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity. 

Why do you need a linear search [O(n)]? You can determine in which interval the value belongs by a binary search [O(log n)] (do not implement is with a recursion! use a loop or hard-code it))). Average number of comparisons for linear search is n/2. Binary search needs a constant number of comparisons of ceiling( ln(n) / ln(2) ). 

If shape and number of polygons do not change (or at least not often), I would add an extra step (the new first step) to your algorithm. Calculate the center and radius of the smallest surrounding circle for each polygon. This way you can calculate in a minimal and maximal distance of all vertices from the given position in one run without iterating through them. If the minimum distance for a polygon is greater than the maximum of an other polygon, no vertex of that polygon can be the nearest => we can ignore this polygon. Than proceed like you did before. 

How to compare the the Algorithms: Either determine the complexity of your algorithm and the complexity of the solution in the tutorial. If you want to avoid to determine the complexity based on the source code you can simply implement the tutorial solution and compare the runtime of your algorithm and the runtime of the of the tutorial-algorithm. To get a good idea of the complexity behavior of both algorithms you need inputs of different lengths to approximate the runtime related to the size of the input. How to improve yours If your approach is very different you might not be able to improve your algorithm by looking on the tutorial-algorithm because they are too different. If the Tutorial-algorithm is better at all, you can try to understand the steps it does and try to memorize the general idea of this steps for your next algorithms that address similar problems.