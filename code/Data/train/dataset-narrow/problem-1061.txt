I don't even begin to understand what this means, and what it has to do with the code it describes... not the second time either... Naming - give variables and methods names which imply their role in your code - what does this line do? 

Method comments vs. naming When the method and parameters are well names, in 9 out of 10 cases, the comment above the method is redundant. For example, - if you call and the comment above the method simply says the same thing as the method signature. Twice. Be consistent and precise , but as well... this is a very surprising result, and might result in inconsistent results. When you get to the case you throw an Exception which states that either or are illegal, although you know that is the illegal one, since you don't even check if is an operator. Magic Constants I find that is much more descriptive than . These kind of constants add unnecessary ambiguity to your code, as they force the reader to go and check their actual value. If you do decide to use a constant, I would suggest a single constant , which will result in these methods: 

What's in a name? Class names should be nouns, and although could be a noun, it looks like you chose the verb name. I think maybe 'Task' will be a better name for it? Your main method is called , what does it mean? All dates passed to the method are valid... valid for what? Give the method a name which gives the context of the instance which tests it. The documentation above the method says 

Member Names - don't use too short names, is better than ; what exactly is ? Method Names - method names should be verbs describing what the method does - is better than . Also use Java method conventions - CamelCase (no underscore in method names - , see below for more about this method) Class Names - follow Java Class naming conventions - they should start with a capital letter, and don't be lazy - write the whole word - . The name of the class should denote its part in the program - tells you nothing about the class, perhaps something more in the lines of ? Responsibilities - object oriented programming is all about division of responsibility - one object is responsible for interacting with the user, another represents an item in a list, etc. This means that a single class should be responsible for interacting with the user - getting input, printing out results. A single class should be responsible for managing the exercise - how many iterations there are, how you calculate score... In your code, for example, the number of iterations () appears both in the main class and the class - tomorrow you'll want to make it iterations - you are bound to forget to change it inside the class. Same goes for method names - remember ? The name that came out is awkward, because it tries to convey that the method does at least two things which are apparently unrelated - see if the answer is correct, and calculate the score (actually it does three - it also requests the answer from the user). You should split the method to its parts - (1) get the answer from the user; (2) check if it is correct; (3) calculate the new score; (4) notify the user. I'll leave it to you to decide which of those methods should go to which class. Comments - you said you added comments for our behalf, to show your intention, and sometimes comments are really needed (not too often though!), but these comments do not convey any information, they simply say where a block ends (). Indentation should do that. 

Edit - this is, of course, wrong (thanks @Matthew) - I got confused with java), the default access modifier for members in C# is private. I still stand by my recommendation to be explicit with , to be more readable, and compliant with coding conventions. Object Oriented For some reason has a property called which is... an ?? What did you intend this property to do? If you want it to hold a , its type should be : 

Your problem is that you load the whole file into memory, convert each byte to three characters (that's the file size times 6), going through and . To avoid holding all in memory, you should stream the data, converting and writing each chunk. This way, you'll only hold a fraction of the file at each time: 

Tail Recursion Erlang (and hence Elixir) pride in the tail recursion idioms they use. You've got one recursion in your code but it is not a tail recursion! This means that the recursive part is not the last thing in the function, and the tail recursion optimization cannot be used. Although your code's recursion is limited to up to 11 hits, it still misses the point of the Elixir idiom. A more idiomatic pattern is using an accumulator, and recursing on that: 

You don't need to define empty actions in your Controller. Your code should even if you delete all the empty actions, leaving you only with the views and routes: page_controller.rb: 

Let your code breathe Your code is very hard to read - lines are long and crowded together, containing multiple method nesting (). Reading code is like reading a book. If you don't give the reader some breathing room (a period, coma, paragraph) - your reader will get lost, and might abandon the book altogether. You should consider adding a few blank lines to make the structure of your methods more apparent, for example: 

returns an array of two arrays - one where the elements returned to the condition, and one that returned . So, a single liner for your need would be: 

Here you check if any of the numbers in the range are a divisor for , and break if there is any. A more ruby way of doing it will be: 

Watch your scope - in your class you keep your data in two places - local variables, and static members. I cannot see any thought behind choosing where to put them - you pass some around in your method signatures, but then you use the others in the same methods... The most acute case is in where you pass the static member as a parameter and use it inside the method, while totally ignoring (and overriding) the parameter... In the use-case above, in the name of encapsulation, I believe the correct way is to only keep the state as local variables, passing the needed data to the stateless helper methods, rather than keeping anything in the static state. Comments - I personally think that comments are a code smell. When the code is clean and readable - comments are superfluous. You've got a lot of comments, and some are more confusing than helpful, since you put them in the wrong location: 

Your code is very brittle and hard-coded. Code is supposed to be as generic and flexible as possible so you could re-use it. A new chapter, a different layout, anything would require you to change the whole code. Code is about doing work for you. Think generically - can this code be used for a different book? (I don't mean by you copying it, pasting it and changing it...) You need to abstract it - what do you have here? You have a , which is different than a . A has a . There are some chapters in a book. The TOC needs to be laid out using some logic... and are objects is your system, the layout logic is a method. For example - I pass to a method called a title, and a list of chapters, which (for simplicity) contain their name and their page number in an array. The method than lays out the TOC page according to the format in your code. Note that the data does not contain the words or - they are part of the layout, not the data: 

This kind of structure is very similar to how an test would be structured, having multiple layers of blocks for different scopes - class, method, feature... 

The first line selects all subdirectories matching the pattern. The second line selects only the ones which are empty. The third groups by the numeric suffix (non-numeric suffixes will be grouped under , so they will be last). The last line sorts by the numeric suffix of the directories, and returns the directory names. 

Is a URL suffix? Is the column in an ID? Neither option seems plausible, so it might be a naming problem - name the fields appropriately to what they hold: 

The use-case you came up with looks like a very clear candidate to be a . A implementation will eliminate your need to manage the serving process, and using its client-side API conventions will also simplify the client usage. Here is a sample implementation of a fizzbuzz: 

It might be longer, but it is meaningful... Don't break the flow Your use of the keyword inside the last block is easy to miss, and may confuse a code reader. When all the block does it , or using these keywords is fine (this is called guard conditions). But if the block contains a lot of code before changing the flow, the keyword is easily missed. Simply put the last line in 

How does your intersect with ? As far as I know, there is no such method on ... It is quite hard to calculate complexity of code, if we can't know how this intersection happens, especially since it happens within a polynomial iteration (*) in , and within a recursion in . Caching? If the complexity of is a constant, your complexity would be \$O(maxRays \cdot objects \cdot lights)\$ (I'm counting your operations' complexity as constant), this might not be ideal. I've got lost in all the recursion and iteration loop you have there, but might there be a way to cache some of the calculations? Would it help you to "remember" distances between your (which does not change during your calculations), and your s, and reuse them as you go along? This might lower your effective complexity, and make your code run a lot faster. 

Your code is very clever, perhaps a little too clever... It almost looks like you wrote the code first, and then asked yourself - what can this achieve? As @rolfl said - as it is currently written - the code is all but useless, because most of the time the result is unpredictable. Calling this method will return a value, which could either have more than half the length of occurrences, or... not? You could achieve at least as much information with the same complexity, by keeping more complete score. Here is an example, where you can save the count of each element, and keep the one with most occurrences: 

I believe you are using much too liberally. The feature for adding new formulas is debatable (personally it is more of a security issue than a value feature, since you make no validations on the code you are evaluating), but for parsing arguments, the use of is completely redundant. Why don't you simply use built-in parsers for numbers, like ? 

You could also use an automatic mapping library, but before you choose to do that, you might want to look at some O/R mapping library, like NHibernate for c#, which should replace the mapping in your code altogether. 

Using an array to hold your variables is hard to maintain and to read. You can assign the fields to real variable names: 

So, we could break it down to 4 classes (with inheritance) - , , , . contains the functionality that is relevant to both and (like having texture), and the is used to decide which shape to draw. 

Most of your code is duplicated, what I did is extract the logic to the first code block, and left only the placeholders in the HTML. 

But wait - you are still using hard-coded indexes! True, and are still there, which looks a little "hard-coded", but these indexes refer to the data structure, not the data itself. A more elaborate design would likely use a hash to hold chapter data (), or even a class having two properties, but for the example above it shows the concept of encapsulation - as long as two modules know the language (=API), they can independently change things in their domain (wither adding chapters to the book, or change the layout), without affecting other parts of the code. I also took the liberty of changing the structure of the input, as @Flambino remarked, but only because I assumed the choice of the structure of the input was not an outside constraint, but a design choice (it didn't make much sense otherwise). 

First, I'd like to say that your code is written very well, and is quite readable. As for your question - your code runs at least once per word in your text. Since a line should be (quite) longer than a single word, I think you can reduce the number of calls substantially. I can think of two strategies: 1. Binary search 

Indentation Be sure to indent your code properly. Indentation helps the reader understand where he is in the code (how deep). Some languages actually depend on correct indentation. Meaningful names You should give your variable names which will have meaning, and will help the reader of your code understand what each one is responsible for. Names like , , should not be used for any variable other than immediate throw-away variables like if . A variable name should never ever be used, since it is too easily confused with the digit , so in some fonts you will never know the difference between and ... Your code should tell a story Try to design your code in a way that a reader will be able to follow your logic. In your code, there is an endless loop, and in the first you check whether a mysterious is , and if it is you end the game... The story starts with the ending! A more pleasing option might be: