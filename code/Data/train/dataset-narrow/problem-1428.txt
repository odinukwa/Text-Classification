Worst Case Scenario: The will have a Length of 1,073,741,823 bits, which is 128 megabytes. This will yield 105,097,565 primes. If you want to store the primes to a , the code is quite easy: 

As of this writing you have a very good detailed answer, and you've already updated your code as answer as well. The new code looks a lot cleaner but both the old code and new code - particularly your build methods - require a server parameter. Just one example of the many: Old Code: 

It’s more DRY, that is adheres to principle of Don’t Repeat Yourself, than code to load each segment, which you had to do to flip between vertical and horizontal lists. It fixes the missing check for distance. But if you examine the next section, it doesn’t seem DRY after all. 

As you review both solutions, I’m sure you understand why working with an indexed list is preferred. Questions Being this is CR, there is always an implied question of “Do you have any constructive comments?” Are there better ways to address the challenge problem? 

Not Interested In This class uses a and . PERIOD. Don’t bother suggesting that I could perform parallel writes with a . I am not interested in that here. Yet I would be happy to read a new, original thread created by you where you use . Don’t bother suggesting that I could use larger integral types. I am not interested in that here. Yet I would be happy to read a new, original thread created by you where you use , , , or even . The cached counts is a feature that I refuse to remove but am open to improvements. It’s called on-demand, trades-off a small but acceptable amount of memory, and really boosts performance of . Concerns This was my first time to use a function delegate, as well as a custom enumerator. The function is declared in the class, and for the sake of DRY is referenced within the class. Since this was my first time to use either, I don’t know if it’s a proper use or not. is the yin to ‘s yang but since the enumerator doesn’t use it, I have its access as private. Should it stay private or should it be public like it twin ? Usage I tried to make the usage feel natural. Consider: 

The following will be suggestions that are purely optional for you to consider. There is no reason for your to be an array. It could work just as easily as or even . You have no logic to prevent the from occuring before the . Nor is there any concern for DateTimeKind. As shown, all DateTime objects use a Kind of Unspecified. This makes the code suspect during a DST transition. One option would be to not input an but rather input a along with . Assuming a positive time span is entered for , then the becomes a calculated read only property. If you were to call repeatedly, it would issue a sort repeatedly. If this is a concern, you may consider a class that would hold a sorted list for you. You may consider passing a date range into for additional filtering. You call it which vaguely suggests the night ends at midnight, but imagine a marathon from 6 PM to 3 AM crossing midnight. You would want to filter a movie list down to only those appearing within the desired date range before sorting, etc. And now imagine what would be needed if that date range occurred on a Spring Forward transition, where the day is 23 hours long, or a Fall Back transition where the day is 25 hours long. How would that change your code? 

Call the method that reads and validates inputs Call the method performing calculations based on the validated inputs Call the method performing outputs 

I can't answer your main concerns but I'm not thrilled about the blocks. All you seem to be doing in the is displaying the message and returning. This marries your class to the UI, which means you can't make these calls in the background should you want to do that in the future. My suggestion is just let your method throw but handled appropriately in the UI. I find the local copying of to be unneeded: 

Borrowing heavily from Heslacher's answer, can you perhaps parallelize the method? I took a stab at it using a range partitioner. I added these usings: 

You fail to address the first sentence of your homework: you do not have an application class named LetterDemo. I'm a strong believer in always specifying the access modifier. Therefore both your Letter and CertifiedLetter classes should be decorated with . The name of your properties should be Pascal-cased. Specifically they should begin with a capital letter, as in and . I would suggest that is too generic a name, and that you should rename it to . Why? One day you may modify to record a and having clearly named variables adds clarity to your code. The property should only record the actual name, and ditch the preface. You should omit forcing the user of your class to include "\nSender: ". Likewise should omit "\nDate: " and only record the actual date. Furthermore, the type for this property should be Date and not String. 

Your code looks more Java-ish than C#. Since you've tagged it with , I will focus my comments on that. However, I am not familiar with and don't know how it will like some syntax changes. Braces on a new line With C#, we prefer braces on their own line. The one exception would be a one-liner such as: 

Not exactly slimmed down but I do have some features added. I don't hard code getting the 4 previous quarters. Rather I have a method that allows you to get as many as you desire. 

But I am just guessing as to the private setters. Use what your app requires. Numeric Type Designators should be Uppercase Change the to . Really doesn't affect your code here but the reason for this guideline is you ever use where a lowercase could be confused as a numeric , but a capital would not. Always declare accessibility modifier Instead of simply use . When I see a missing, I assume a newbie coder has forgotten it, which leads me to wonder what else he or she has forgotten. Variable declaration and scoping As mentioned at the very top with , you should limit the scope of a variable to where you need it. In my example, was placed inside the block and declared immediately before the one place where it was referenced. Someone reading your code doesn't have to remember where it was defined, or worry about it afterwards. 

Avoid Too Many Threads As I’ve seen on SO and CR, parallel processing can easily be done wrong and take much longer than simple serial. Inside my loop, there are only a few, fast calculations. It would be a performance drag to create a thread for each (worst case is over 700 million). This normally is a great candidate for a range but I need more than a simple range. Consider a simplified example where the domain of is 1 to 100 inclusively, which is to say that is 101. I also want to generate no more than 10 threads in this example. I do NOT want ranges like: Range 0 is {1, 2, 3 , …, 8, 9, 10} Range 1 is {11, 12, 13 , …, 18, 19, 20} . . . Range 9 is {91, 92, 93 , …, 98, 99, 100} I want series like: Series 0 is {1, 11, 21, …, 71, 81, 91} Series 1 is {2, 12, 22, …, 72, 82, 92} . . . Series 9 is {10, 20, 30, …, 80, 90, 100} Square Root Corner Case There is a special corner case where returns the wrong value. This is not the fault of itself but just the nature of the (implicit) cast of to a since you have an integer value fully and exactly represented by 64 bits but you are squeezing them into a 64 bit floating point approximation. This corner case is easy to detect and just as easy to correct. The key is to be aware of it in the first place. Performance [Edit: I erroneously listed the 31 & 32 bit times as seconds. The correct unit is milliseconds.] On my 8-core laptop in serial only mode: Largest 31 bit prime takes 0.17 milliseconds. Largest 32 bit prime takes 0.23 milliseconds. Largest 63 bit prime takes over 13 seconds. Largest 64 bit prime takes over 18 seconds. In parallel mode: Largest 63 bit prime takes 6.6 seconds. Largest 64 bit prime takes 9.28 seconds. Questions Being this is CR, there is always an implied question of “Do you have any constructive comments?” While I have used many times before, this is my first implementation where I had to create a specifically arranged series rather than a simple range. Is this done correctly and/or could it be done better? Other than using Miller-Rabin techniques, can this be made faster? I’ve used more threads and less threads - or really what I call and assuming that each chunk gets its own thread - but on my laptop the fastest times consistently were when I used a chunk count equal to my processor count. 

I personally feel omitting braces on one-liners is acceptable, but never on a , , or any loop really. Switch ... The caused me the most heartburn. I think it was tougher to read than it needs to be. Instead of: 

You would then tie that back to your UI when the UI makes a call. Instead of the UI using a it would be more like: 

Except you should try to avoid the Turkish "ll" issue of surrogate pairs to be treated as single character. The way to avoid is to use upper case. Also the Splitter should just use the char[] and not convert ToList(). Then again, you don't need really Splitter. Those are all things to think about. Here's my take on it: 

The other things is when you break out of the loop thanks to not having an exception, the block still executes, which means you have to wait up to once more than needed. I would suggest this change: 

I see a few things I would do differently. For one, I would not use a . At best, it's providing you an order in which floor buttons were pressed. While the buttons may be pressed in any order, an elevator moves in sequential order be it up or down. I would keep a simple where denotes a floor to stop at. Once you stop at a floor, no need to . Instead just set the flag to . By keeping it simple, you won't have to jump through hoops if you are going up but someone presses buttons for 10, 5, 2, 9, 7. 

I've got a version that is slightly faster. I'd like to think the whole algorithm could be improved but it's too early in the morning for me to concentrate on that. What I would caution you is that sometimes casting can hurt performance, most notably if you are casting hundreds of millions of times. That said there are lots of implicit castings going on in your code. A couple of examples: 

I could elaborate more on the dummy segments but it would only be echoing the comments in code. Suffice to say that the initial loading of these specific zero length segments guarantees me that each and every real move will be checked with a -3 and -5 away move that is perpendicular to the latest segment. This is true starting with move 1 at . Doing this converts the corner cases into normal cases. Performance Using a spiral containing 1 million moves without crossings takes less than 250 milliseconds on my laptop (actually closer to 240 ms). A million moves requires at most 2 million checks for a possible collision. Ten million moves would require no more than 20 million checks. Thus, the problem space has been reduced and simplified. It requires very small amount of memory and it scales linearly. 

And sure I get add more memory to my laptop, but if I did that I would probably rewrite this for and hit its memory limits! 

What's missing here is the (now deleted) update to your original link. In that brief lived update there were 2 problems not known to others here. One was the stopwatch wasn't being started. The other was the OP wanted help understanding this line: 

could allow someone to replace the value with an item that fails the check. I wouldn't suggest adding extra checks in the setter. It really should be a readonly property. 

This very fast, simple sieve quickly finds 31 bit primes. It uses a memory efficient for odd numbers. How a 32 bit is a 31 bit prime Since a prime number must be > 1, the sign bit has no bearing, leaving 31 bits to store the positive numbers. This differs from which truly would be 32 bit primes. See this Microsoft link on Magic Numbers. If you find the value on that page you will see this text: 

The resulting method also looks cleaner. Someone looking at this understands more readily what the code is trying to achieve: 

Update: You can explore with whether the collection of triangle numbers should be an array, a list, SortedSet, Dictionary, etc. I don't think the collection should have a value for , or rather my code below would need to be changed. Still, a should not be included otherwise you risk accidentally counting the and backtick characters as triangle numbers, when they should not be. The aforementioned characters immediately precede and . Instead of Dictionary One option instead of the dictionary would be: 

One of the prevailing rules of C# code development is that your code should be readable by others. That means the intent of what you are doing should be easily determined by someone else reading your code. This is not the case with your post. I can't even begin to comment upon your algorithm without taking lots of time to figure out what you are doing. Therefore, my reply is about style and structure. Don't put everything in . Your app wants to do 3 overall things: 

I find it kind of silly that you receive as the first input and the second input in a -digit number. I'd think things could be simpler if you just received some input number where you can quickly determine its length to compute . But I'm guessing that the rules of the contest. One area of a small bit of inefficiency - as well as naming confusion - is regarding to . The truth is is not a number. It's a string composed of digits, which you trust is valid input since you don't validate it. That's fine as long as the rules are they absolutely will be passing you an integer as as string. You can perhaps improve readability and performance somewhat by converting the string of digits to an integer array once, and pass that to . This can be something simple like: 

Longer, Low Memory Solution If you don’t have sufficient memory to produce the largest possible list of primes, the solution is a lot longer and slower, as it requires two-passes over the enumerable collection. For the 2nd pass, you can exit early once the full answer is known. 

For a small array or list of a handful of items, this should be very fast. But is it efficient as you would scale out? No. Before getting on to a better way to achieve the it for a larger number of items, let's look at your current code. You have some checks that aren't needed. 

Consider how ugly and jumbled your big statement is inside of (no offense). Its very hard to follow. This logic can be simplified by moving the logic to your class. FORGIVE ME if I translated some of your logic incorrectly. Again it was difficult (as just a volunteer enthusiast to review your code) to follow your original. The important thing is for you to concentrate on the why's and how it's being changed. 

I intentionally only want the YearQuarter instance set publicly using the . method. To get the 4 previous quarters, you could use: 

But since Heslacher wanted me to make it my own answer, then by Grabthar's hammer, I will make it my own. I tweaked it even more by making it multi-threaded when creating the array. This reduced the time down to 0.4 seconds. Multithreaded Implementation: