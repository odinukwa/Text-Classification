You should be able to control where matchbox-keyboard shows using the argument. This page suggests that the appropriate call would be something like this: matchbox-keyboard --geometry HxW.y.x x and y are the on-screen coordinates of the top-left corner of the keyboard window (from the top left corner of the screen), and W and H are the width and height of the keyboard. There's an application called devilspie2 that lets you mess around with where windows go when the application is first launched if they don't support the --geometry command line argument (that's most applications). What you need to do is first install: 

It seems like a very cool project, but I don't think you actually want a browser in a browser. I think you want something like Coherent, which essentially lets you construct an HTML5 user interface. (In which you can embed a proper browser window as part of it's framework... I think.) The problem with this is that Coherent's not free, open-source, and probably doesn't support ARM or OpenGL ES. But I think it's the sort of thing you'd need to create the user experience your mock-ups suggest. You might be able to instead of using frames, as part of a UI toolkit have multiple browser instances, sort of like tiling windows in a window manager. I think Qt might let you do it. In that scenario something like a full screen application with a few browser instances inside of it. This is really quite speculative on my part. Overall thoughts: very cool project, probably doable, but very tricky. 

A quick and dirt hack would be to edit /etc/rc.local and add "mount /mnt/media". This will automatically be carried out on boot. The correct way, I think, would be to add the nfs-common init script to the default runlevel. This can be done by using the update-rc.d command. 

By default Rasbian doesn't use upstart, and instead uses the traditional Sys V init system. Try method 2 and edit . 

Generally the only solution is to reconnect the drive. If it's bus powered plug it in through a powered hub. I suspect that your drive, and by extension the USB bus is getting hammered by the checksum stage of BT. This is causing it to drop out. I'm not sure you can disable that with BT Sync though. It seems there's a setting though that you can set to that may help. Setting the to a value less than 5MB/s may help as well as this will also lower disk load. 

Apparently there's an entry in /boot/config.txt called start_x that needs to be set to 1 to enable the camera, There also needs to be at least 128 MB of memory for the gpu (gpu_mem). Double check seems to confirm it. 

By default the RaspberryPi framebuffer is only 16-bit. So at higher color depths in the software you're probably seeing the effects of some integer wrapping. You can set the framebuffer depth higher, but it may not work well. According to this, you can set the Pi to both 24 and 32 bit depths by changing framebuffer_depth in /boot/config.txt. At 24-bit there have apparently been corruption issues reported. 32-bit depth works better, but requires alpha to be disabled by setting framebuffer_ignore_alpha to 1 in config.txt. 

It may be that the image became corrupted while extracting or writing. Try verifying the file with and comparing the result to the checksum of ade48c874f8e4b694175de4c87d7357960961fbf. You might be able to recovery by simply doing a file system check, otherwise try re-writing with a freshly downloaded and extracted image. To do a check, run . The boot partition on the SD card has to be FAT. The external hard drive doesn't need its own boot partition, because it's on the SD card instead. The only reason you need it now is because you're copying the contents from it to the SD card as you've just written out the image. 

Have you just tried copying the file from the working card to the other? If that doesn't fix it it's probably a firmware issue. Copy , , and from the working card to the other one to test it out. (Making a backup before copying is recommended.) 

Check your ~/.xinitrc file. It sounds like something listed there to be launched at execution of the startx command isn't starting properly and is hanging, making it look like X hasn't started. (It probably has, it's just showing a black background. Misleading, I know!) 

First a special type of file called a FIFO, or first-in first-out file is created. Anything we write to the file comes out in the order it was put in when the file is read. The second command cats the output of this and pipes it into omxplayer. There's nothing in the file to start with though, so nothing happens. We wait 10 seconds. We then write "p" into the FIFO file with the echo command. Cat will then see this and pipe that to omxplayer, pausing the video. The last line just removes the FIFO file since we're done with it. If you're doing this lots though, you can just leave it there. 

In addition to @goldilocks answer, I would add that the ground pins have been strategically placed to make it easier to connect to specific functions with smaller connectors. For example, physical pins 17 and 25 are at opposite ends of the SPI0 bus pins. Check out the Raspberry Pi Pinout site for more information. It has a ton of information about the RPi pins as well as various hats, boards, and other accessories. 

I seriously doubt there is a way to simulate a physical break using software only. You will probably have to resort to disconnecting the physical cable or installing smell kind of physical switch in the cable. 

I recommend the Sense Hat. It has several sensors built in to include a magnetometer and IMU. It also has a very nice and we'll supported python library. The library gives you both high and low level access to the IMU data. The led array and buttons can come in useful for headless operations. 

It sounds like you have electrical power stability problems. Having a stable power source for your RPi is very important. The USB power converter (or charger) should be capable of providing 2 to 2.5 amps. The rating should be printed on the device. Many phone chargers and inexpensive USB chargers provide only 1 amp or less. If you have a good quality USB power converter and are still having problems, then you may have a problem with your main power source (i.e. wall outlets). That will require a professional electrician to fix. Not supplying sufficient and stable power to the RPI can cause unpredictable and potentially damaging behavior. The SD cards are especially sensitive to power issues and can easily get corrupted. When this happens, you could lose a lot of data. That's why it's always a good idea to have a backup. 

Dimming the back light of an LCD is not as straight forward as dimming simple LEDs. A lot depends upon the specific LCD you are using and the specific circuitry it is attached to. Without the specifics of the LCD you are using, it is not possible to give a specific answer. Some LCDs have a pin that can be used to adjust the back light brightness. Typically this is done using a variable resister to control the voltage level applied to the back light LED. However, it can also be done by PWM, but typically requires a transistor and resister. The RPi is then used to control the transistor which adjusts the current flow to the LCD back light pin. This all assumes the circuitry for the LCD isn't hardwired to a set brightness level. Doing a simple web search on "Raspbery PI LCD dimmer" and the name of your LCD (i.e. 1602) should get you detailed options for your specific LCD. 

Directly connecting motors to the RPi GPIO pins is not a good idea. They draw too much power and can cause electrical feedback that can fry your RPi. You should use a motor driver board and an external power source when working with motors and the RPi. 

I recommend using the gpiozero library. It is designed to make physical computing much easier. The documentation is great and has lots of good beginner examples. Using , your example becomes: 

Depending on your data sampling needs, you may want to consider an SPI bus solution. I2C is limited to 400 kHz, while SPI is only limited by the physical hardware and can get over 1 MHz. Yes there are commercially available boards that will do what you want. I recommend using the following search words: Raspberry, pi, analog to digital, hat. The keyword hat helps find boards that are "plug-n-play" ready for the RPi. 

Yes. You need to turn on the direct capture mode in the VNC server on the RPi. To turn this feature on, open the VNC Server dialog (on the RPi), navigate to Menu > Options > Troubleshooting, and select Enable experimental direct capture mode. The link above gives more details. 

I also recommend checking out the recipes section of the Gpiozero documentation. You will find many options that are easily adaptable to your situation. 

A simpler solution would be to use . Then function a only has to determine if function b executed by checking the button's property. 

Based on the information at the RPi pinout site, you connected a bunch of the GPIO pins to ground. The sense hat uses the I2C bus which was not connected correctly. It also uses a couple of the GPIO pins for interrupts and communicating with the Atmel chip(s). The potentially worst thing you did was to short the RPi's 5V pins to ground. So you are lucky you didn't ruin your RPi. Depending on what protection circuitry is in the sense hat, the board MAY be fine. I suspect you may have corrupted the EEPROM on the sense hat. The EEPROM is used to let the RPi know what board is attached and how to configure the hardware. The good news is you might be able to reprogram the EEPROM. Check out the Sense Hat documentation page for the details. 

The joy of electronics questions like this is one of the reasons I love the Pi. Unfortunately wall chargers pretty much everywhere in the world work on AC current, which they turn into DC current that powers the Pi. One letter difference how had can it be? Well, alternating vs. direct as it turns out matters somewhat. In alternating current, the electrons in the wire bump back and forth, back and forth in the same position. Each electron knocking its neighbour and vice-versa is what carries the power. The fact the electronics essentially never move is what makes it great for transmission over long distances, like from the power plant to your house. However, because the electrons go back and forth, trying to power a car with an AC engine would be like watching it go forwards and backwards repeatedly. (Not to say that you can't power a car with an AC engine, but I'm using it as a metaphor here.) In direct current, the electrons travel the full distance. This makes the car with that same motor move in one direction only. If we move the car metaphor, where powering of an AC motor is actually trivial, to most consumer electronics, powering them with AC is non-trivial. Hence DC. Why not use DC for everything? The fact that all the electrons are moving means the experience resistance (think friction) which causes them to heat up (hot wires) which further increases resistance (you slow down on a hot day) which means you have to put more power in. In room temperatures it's a loosing proposition. (In near absolute zero conditions it works amazingly well---that's where the super conductors of fabled sci-fi enter in.) Anyway, the difference between AC and DC is why using the wall wort from DC power won't work. They use clever bits of electronics (previously transformers, now switched mode regulators) to make the transition. But there are such things DC to DC convertors. Switched mode regulators do that too. The MoPi board has one, will take any input voltage from around 8 to 25 V (so basically as many AAs as you can find, or any whacky old laptop battery) and make it so that the Pi can use it. It will then also tell you when the battery is about dead. Nifty! 

OK. This will be a little bit hacky but it is possible to get to a point where you can edit /etc/inittab again. This assumes that you can edit at least the FAT32 partition of the SD card. Add init=/bin/sh to the end of the cmdline.txt file. This will dump you into a straight shell on boot. (You'll need to revert this change later.) Once it boots to the shell, you'll need to mount the root file system read-write so that you can make permanent changes to /etc/inittab. mount -o remount,rw / should work. After that, nano /etc/inittab, fix the syntax errors, halt 0, re-edit cmdline.txt and you should be good to go. Unfortunately I can't test these directions out as I don't have access to a Pi right this moment, but in general they should work. 

Anything in /etc/rc.local should keep running after boot indefinitely. If it is crashing, you can make it restart automatically by putting it in a while loop: 

OK. I read your question more carefully and I think I've worked out what's going on. Your bridge and everything is working fine. What's not working is that nothing on the bridge is talking to the internet. Which it can't do because it's not actually connected. On your Pi, two completely separate networks exist. The network, and the network to your router. The simple thing to do would be just to glue them together, by changing the interfaces file. 

Anything you redirect to gets dumped out an airlock. For example if you were to what's happened is effectively nothing. Of course, would normally just write to the terminal, which is also only a short-term memory cache on the screen. That never gets written to the SD either. There are generally only very specific instances you might want to write to for actual benefit. For example, doing first pass video encoding still prodcues an output file. This you can send to to save writes on the card. When you do the second pass of the encoding then you do the actual writing. 

Have you looked at the Atrix Lapdock? It's an add-on for a Motorola phone that turned it from phone to essentially a laptop. It has an internal rechargeable battery, 11" screen, HDMI, USB, mouse, keyboard. Sounds like exactly what you want. Powers the Pi for at least 6 hours. Several people have used them. They go for around 70 quid on eBay at the moment, but they're cheaper in the US I think. If you really want a bit of snazzy custom kit, check out the MoPi board. It takes pretty much any power input and converts it for the Pi. 8 to 10 hours on 8 AAs. With a screen and Wi-fi that time will go down, but should still be pretty respectable. What's pretty neat in this case is the ability to hot swap battery packs. Current batteries getting low? Replace the pack on the go! I loved it when my old Dell Inspiron 8100 did this, but with most laptops being much smaller and focussed on reducing weight, it's pretty much a dead feature. Oh well. The MoPi board also tells the Pi when the batteries are low so that it either shuts down nicely or prompts for new batteries.