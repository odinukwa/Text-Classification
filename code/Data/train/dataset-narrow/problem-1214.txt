etc... If you want an easy access to some parts of your data, you should implement additional methods on highest level. For example, to iterate through s, you can implement following extension method: 

Maybe would be a better name for the first method (since it is similar to ). 2) There are some magic numbers here and there, for example: 

Check out MSDN documentation for complete list of LINQ queries. Note, that you can also calculate average value itself, using method: 

The second version is definitely way shorter and in my opinion is just as good (if not better), in terms of readability. 

Your algorithm is pretty hard to follow, at least for me (I am no expert in graph theory). If you add some local variables with descriptive names - that might help. For example, instead of writing: 

Your hierarchy presumes that every descendant class will call setter. That's wishful thinking. :) You will get away with it in this small exercise, but you wont in more complex projects. You should make abstract. 

When implementing equality methods and operators, you should always try to reuse your implementation as much as possible. is the same as , is the same as , etc. For eaxmple, you can implement equality as: 

You rarely need to manually implement enumerators. In your case, you should probably just go with extension methods. For example: 

Native methods return error codes, so it is good practice to handle those codes somehow, not just ignore them. For example, if method reports, that there is no sound driver or no sound card or w/e, it makes sense to notify user somehow. Write warning in the status bar of your window or something. It is meaningless to initialize , since its value will be overriden anyway, wont it? And, if its your real code, you dont have to recieve current volume in order to set it to begin with. should be refactored to . More complex example: 

Well, using as a way to improve performance doesn't sit well with me, as it kind of violates the contract. I doubt the gains (if any) justify it. Micro-optimizations should probably begin with replacing recursion with a loop. Another thing to optimize is your partitioning logic: has an overload that takes start index and count. If you use it instead, you can avoid call and subsequent copying. If you do need a copy for some reason, then you should use Buffer.BlockCopy method. Element-by-element copying in loop is considerably slower for larger arrays. is a bit counter-intuitive as it apparently returns items. That's not what I would expect. There is also a little bit of copy-paste in loop's body, that can probably be avoided. You can use instead of and put results in correct order straight away using indexer: . No additional synchronization is needed as long as values are unique, which seems to be the case. Everything else looks alright to me. 

I think you do not fully understand the concept of members. Until you do, you should avoid using them. Keep it simple. You should avoid creating methods, thats what properties are for. In your case, you might want to use indexer instead of properties though. You should not re-create class if you want randomized results. Create it once and re-use it. 

As for performance - nothing in the code you've shown strikes me as potential performance bottleneck. You will probably have to run a profiler to pinpoint it. One thing in particular you might want to look at is what triggers the search and how often it is executed. For example, if I enter 10 chars in search box, do I search 1 or 10 times? While the filtering logic looks fairly lightweight, the performance implications of recreating 25 item templates in UI on every keystroke can be severe (depending on how complex the is). has some nice extensions that might help in throttling UI events. P.S. Whats the point of removing all meaningful characters in ? What characters are you interested in then? This is extremely unclear, you should document that portion of your code. 

Long story short - you will have to adopt WPF way of doing things, which is MVVM way. Frankly, your code is a mess and I can't see any minor refactoring that would change that. You will have to refactor the whole thing: 

Also, you don't have to use operator if you are using attribute. You can just call (without arguments). 

property is fishy. If it is actually a wpf control, than this is a major violation of MVVM. Your viewmodels should never have a direct access to view, thats what databinding is for. If it is not a UI control, then IMHO you should rename it, removing the word from both class name and property name. sounds good to me. 

It looks like you are wasting your efforts on premature optimization. Which also results in a quite ugly code. I think you should separate your grid-filling logic from csv export. There should be no memory streams, steam writers, etc. in your first method. Also notice that you have code duplication in it, so you might want to extract label creation logic to separate method. Ideally you'd want to remove this logic all together and use WPF (or ) with data-binding instead. As for your second method - you do not need any buffers. Just iterate through your data, create strings and write them directly to your . You might also want to encapsulate this logic in some separate class and perform it in the background thread so your UI does not freeze for large data. 

You can no longer return from since return value now is strongly typed. You can not set other types of metadata, such as . Not exactly a limitation, but I feel like current API adds a lot of boiler-plate code, which is a common problem with builder pattern. I think I would rather write 

1) Don't implement so-called unless you actually have some unmanaged resource that you have to finalize. It bloats your code and makes the life of garbage collector harder. is a managed class, you should not touch it in finalizer, it will finalize itself, if needed. 2) and is a weird pair of methods. Usually it is either or . But that's subjective, I guess. :) 3) IMHO, callback-based API is somewhat outdated. Usually methods result in cleaner code and are easier to use. 4) Message parser (the state machine part of your code) can probably be extracted into stand-alone component. 5) Have you intentionally picked TCP protocol over, say, UDP? Often when people write client-server games they want UDP, as it is generally faster and is a better fit for realtime message-based communication. There are cases where TCP can be better, but it is hard to tell, because you did not say, what type of game you are writing. So I am mentioning this just in case, to make sure you gave it some thought. 6) You should probably extract interface from this class and work with abstraction. Both for unit testing and in case you will switch to different protocol in the future. 7) Overall your implementation looks good. I don't see any obvious problems with synchronization, and I agree with you that abstract methods should probably be refactored into events. 

There is a lot of code repetition in method, which boils down to "check if this string is a token of type X and parse it, if it is". This sounds like an interface to me: 

This way you do not create any unnecessary collections. It forces you to use though, but in my opinion it is a good thing. 

Overall I think this implementation would be easier to understand/maintain if you were to "sanitize" during html construction, and not during rendering. Instead of having special rules on how to render non- objects, you should have special rules on how to convert those object to . This way you should be able to work with strongly typed instead of . 

Given that the logic is exactly the same (i did not do a line by line comparision), one of the possible solutions whould be: 

You can drop equality checks in since callback only triggers when dependency property actually changes. Your properties can use a better naming. doesn't tell me anything. I can already see that the property returns and I can see that it is an attached property. What I do not know is its purpose. Use property name to tell me that. Your class wont work if I set from code. This is counter-intuitive. Either make the setter private or make it work. You are leaking event handlers. Which might not be an issue for your current use case, but it can quickly become one, once stuff gets serious. Either use weak events or unsubscribe manually. is a really poor choice for a base class. There are two main approaches when it comes to controls, that host multiple children: 

Yes, you should omit and . Those only take space and do not provide any additional information. In C# you can't put anything but inside statement. The only time you might need to write is if .