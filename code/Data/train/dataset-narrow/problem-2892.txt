Instead of making full copies of every entity in the world, just save the entities and attributes that are relevant to what you want to lag compensate. For example, in a first person shooter, often the only thing to lag compensate are the bullet shots. To calculate whether a bullet hit, you only need to know, (a) the positions of other players and, (b) their hit boxes. That's all you should store in the history buffer. When you need to lag compensate, update the positions and hit boxes of the players, without touching anything else. Additionally, you can be intelligent about which entities you choose to lag compensate. If you know your skill has a maximum range of and players can move at a maximum speed of then don't bother lag compensating any entities farther than distance away, since you know that they won't be hit by the skill. P.S. I'm also working on an MMO that uses lag compensation. Just because it's not expected by MMO players doesn't mean we should deny them a good experience! WoW is over 7 years old now. 

I discovered my answer. If the origin is in region 1, then it is a termination condition. It means that the origin isn't inside the Minkowski Difference, and therefore the shapes are not colliding. We just return the single point so that the next loop will terminate, and we can keep our support code general, without any special casing for exiting early. 

One way that I've found helps alleviate this problem in platforming games is to prioritize which axis gets checked first in your SAT algorithm. For example, even though the x distance is shorter than the y distance, you can adjust your algorithm to always push on the y axis first. That way, even when your character is standing over the edge of a platform, he gets pushed upwards. Performing multiple collision tests between the start and end positions is a fine solution if you're not having any performance issues. You can optimize it somewhat by moving the maximum distance you can get away with instead of a single pixel at the time. For example if your shape is a circle with radius 40, then moving 20 pixels at a time would work (half the radius so you don't go through thin objects). If you want a more robust and faster solution, then you should use a continuous collision detection algorithm. Instead of intersecting with objects and then correcting, a continuous algorithm takes velocity into account and determines the time of impact, which you can then you to position the object where it needs to be. It's actually not too difficult to implement continuous collision detection using SAT (assuming no rotation). The algorithm that you're using probably has you moving the object, then checking for collisions on multiple axes by searching for overlapping ranges. To modify this to be continuous, don't move the object first. Instead, you can calculate collision time on multiple axes by finding the distance between the closest points on each axis and dividing by the speed that the object is moving (on that axis). The minimum time will be the time of impact for the object, and if it's less than zero, then the objects are already colliding. 

The Separating Axis Theorem (SAT) makes it simple to determine the Minimum Translation Vector, i.e., the shortest vector that can separate two colliding objects. However, what I need is the vector that separates the objects along the vector that the penetrating object is moving (i.e. the contact point). I drew a picture to help clarify. There is one box, moving from the before to the after position. In its after position, it intersects the grey polygon. SAT can easily return the MTV, which is the red vector. I am looking to calculate the blue vector. 

It sounds to me like you have to take your input, in gesture form, and convert it into simple 4-directional input. You're basically converting very complex input into something much simpler. You're going to want to take the starting position and the ending position of your gesture command and determine the angle of the vector between them. Recall your high school math - it's a simple formula. You're going to have to get comfortable using COS and SIN. With that angle, just determine which direction it most faces. You can break them up into 90 degree segments for each direction. 

Artificial Intelligence is, unfortunately, an entire subsection of Computer Science. It's truly huge - something you can take a couple of semesters of in college just to get you warmed up. There are a lot of common options - Decision Trees, Rules Engines, Neural Networks - the latter of which most people tend to find extremely interesting when they first hear about them (and invariably prove to be a horrible idea in the kind of scenario you're describing - look out for that). I recommend you look up some topics or books on basic AI development in general - it may not seem directly relevant to games specifically at first, but you'll appreciate understanding the fundamentals. 

As mentioned by others, it's likely you want an effect similar to a "snake". Effectively, you want to break down the "tongue" into individual pieces that form a trail, much like chain-links. The objects you'll want to create should work similar to a linked list - each node will point to potential nodes that can come before and after it. From there, you pick some relative positions near each end of each node where they will visually connect when drawn on the screen. You may want to have a maximum angle at which each node can bend relative to its prior node in order to make it look smooth. From there, you can simply make a node act special if it is "the end" node, i.e. the following node it points to is null. You can have it manipulate things in whatever manner you'd like at that point. 

Although this may seem like a bit of a cop-out, it is worthwhile to note that no one can make a provably accurate model of space-faring economics because we have no examples of it in real-life. All examples of space-oriented trading simulations make their own science fiction assumptions about how their universe works, and most of them take the Planet of Hats approach to alien worlds, in that, despite planets being huge and diverse things, the worlds are culturally very small and limited and possess only one real identity. With this kind of view on planets, it is consistent for them to have only a single, simplified economy for each of them - however, this is certainly a massive simplification of what might occur in real-life. In other words, if you want realism as your primary goal, then you should know that it is unlikely that there has ever been (at least that I'm aware of) an economic model that is even close to being both realistic and on the galactic scale. Although it may be useful to use real-world economic models as a starting point, there is no guarantee that it will be even close to accurate. There is a measure of fiction, imagination, and utter guesswork that is simply required to make this work. 

There are several ways to solve the problem of objects that are larger than your tiles. Perhaps the easiest way is just to add the entity to every tile that it intersects with. Essentially the entity is in a wide range of tiles at any time. The is simple to implement but doesn't scale well for performance if your entities vary greatly in size. A more flexible solution would be to use hierarchical tiles, where you have several tile sizes, and you place entities into the set of tiles that best fits their size. This works well if you have a fixed number of different entity sizes. The most flexible solution would be a quadtree, which starts with very large tiles and recursively splits them so that they always fit the smallest object. I drew a diagram of some simple cases to illustrate the ideas. The green boxes are the tiles that the gray object would be added to in that tile structure. 

The GJK algorithm depends upon a function in its loop that updates the simplex and search direction for the next iteration (which is often called something like or ). In order to find the next simplex, the algorithm divides the current simplex into regions, and determines which region contains the origin. Here is an example of the regions for a 1-simplex (i.e. a line). In this example, the simplex previously only contained point B, and then point A was added in the direction of the origin. 

If you decide to implement the networking code yourself, or if you're curious, you'll need to start learning about the best techniques. After lots of reading myself, I've found these guides to be a cut above the rest: 

Let's say you're creating a single-player game where you expect the player to go through 10 levels and get a new skill at the end of every level. In that case, you don't need a complicated system for managing skills. You could simply create a new class for each skill and hard code specific methods for each skill (e.g. , , ). On the other hand, let's say you're creating a multiplayer game with a release cycle of a new skill every week, and you expect to have hundreds of skills. In that case, you need an easy way to deliver new skill definitions to players, so XML or some binary format makes sense. Additionally, skills will likely share a lot of features, so a component-based entity system makes sense. The same logic applies for your question about the fireball skill and particle system. Is the fireball skill the only class that will be using particles? In that case, just hard code the relationship. If many skills will be using particles, then you may want to use a message passing system, so that any entity can request a particle to be created without needing a reference to the actual particle system object. You could use dependency injection if you expect to have multiple types of particle systems. There's no correct answer to code architecture, just a bunch of tradeoffs that you decide upon that best fits your game and development team. 

My current solution performs a binary search between the before and after positions until the length of the blue vector is known to a certain threshold. It works but it's a very expensive calculation since the collision between shapes needs to be recalculated every loop. Is there a simpler and/or more efficient way to find the contact point vector?