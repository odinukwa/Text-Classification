Yes, I see on your GitHub repo that all your direction fields have type of . But why? Let those fields be of type. 

method not only pauses a game but also resumes it. So either give another name to the method or split it to two ones like and . Also this code 

I suggest to not operate by "cool" words like SOLID and just improve existing code. I don't know what type constants like and of so I'll use enum for states. Your code can be simplified to (using C#7): 

I agree with all things said by @TopinFrassi and want to add some additional notes. If you have the same code repeated multiple times extract it to a method. Define method like this 

will be of the type and you don't need to repeat multiple times. Read about LINQ since it is one of the greatest features of C#. 

you have no thoughts to rewrite it by eliminating repeated calculations and name all those constants :) 

method has signature. You should avoid such methods and use instead. It is acceptable to mark event handlers with . is used only in event handler, so do the following changes: 

Also I recommend to extract all subconditions to methods with appropriate names. It will make your code much more easy to read and understand. 

But I'm mostly baffled by the convoluted logic WRT those s and the resulting and . Are you sure you didn't mean to construct something like this (pseudo-code): 

But if I were you I'd rethink this entire logic. A is ugly and unwieldy; IMHO the nested dictionary should be a custom class. I also feel this code is odd and possible buggy: data is retrieved for an yet this parameter is completely absent in . The that is passed is assumed to be present as a key in , same for the . 

But more importantly: all of your code is solving a problem that has already been solved by ORMs like NHibernate or Entity Framework. You have written a 60 line class that can do one single thing: update the field in the table . My advice: throw all of this away, implement a decent ORM and focus on the actual business logic. 

implements and should be used with a statement, which would probably eliminate most of that ugly code in and and . I hope that also implements , and if so it too should be used in combination with a statement. But I doubt there's any real point to that class (I cannot access that code since pastebin is blocked where I am now), other than providing ill-advised wrappers around certain methods. 

FindLadders In this method you have serious architectural problem in my opinion – you initialize here, then it is populated somewhere and return it. It is make your program flow unobvious and error-prone. You should completely remove field. The method should return those ladders. Also I suggest to change return type of the method to : 

Are you sure you need such "big" types for indexers parameters as and ? I would work with and only since it is more than enough. 

The advantage of this approach is you can forget about and other -methods. If you need to add another character in the game, you'll just put in one of the arrays. No additional actions required. Also use camelCase for local variables instead of PascalCase. I mean you should write in the code above instead of . Another one recommendation is using of keyword when the type is obvious (but I use it evrywhere :)). 

You have a lot of manipulations with view-model in code behind. It is not good. Try to move all your business logic to the view-model. 

Also all properties in C# should have PascalCased names according to naming guidelines. So the is a bad name and you should use as well as and . 

Even though this isn't that long (250 lines), I still feel that there's a lot of code in this class that belongs in a dedicated class, e.g. the update check, retrieval of the WoW directory,... Web Forms MVP is probably overkill for this kind of project (since I doubt there will be much functionality to be added in the future), but I'd still try to limit the code in this class to UI-related code, and move all other code to smaller dedicated classes. 

What if you need to add another, e.g. ? As Heslacher's answer shows: move this to a separate method, and consider moving etc. to a collection of "valid" WorkCenterNumbers, thus reducing the code to: 

There are more issues with your code, but I'd advice you to apply these recommendations and any others you might receive, and post the result as a new question. 

It's obvious doesn't contain the name, but instead an abbreviation, so the property is named incorrectly. Which you then "fix" by doing this: . And this sort is just... Why not have a numeric field -- e.g. -- and sort on that? 

Not going to review all that, just going to focus on one aspect: your table structure. Edit: ugh, now I read your comment (which was posted while I was doing this review) and most of my review is irrelevant. Still, my point remains: this is really bad database design. 

I would return from . It is more general approach. User will decide then what collection he want – array, or something else. You even don't need to check whether contains elements or not. 

If some arguments of a public method is invalid you should say about it to user. The native way in .NET to say about something is wrong is an exception. So instead of returning some "invalid" value throw an exception: 

You have one exception for different parameters and I believe it is wrong. You should separate validation of each argument and also use clear message instead of just "something is out of range". Also I recommend to use only for arguments that represent single value that is out of range. of an array argument is not an argument itself. Some invalid value inside the array is not an argument too. So define validation methods 

I should notice that it is not good to know about subclass of the inside the . So I would change type of the parameter to . Now you can implement this abstarct method in all your person classes instead of , , ... And all the methods can be replaced now with the one: 

In addition to @user1118321's review, I would also suggest to rethink your conditions. You seem to tend to do "negative" checks, you're even combining two in this case: . I'd much rather have this logic: . To me this second version is easier to understand: if the is null or its is null or empty, then execute this simple bit of code that doesn't need the , otherwise execute this more complicated bit of code that requires the . This is IMHO even more important when using ternary operators. Parsing requires me to think a lot more than if you'd written . 

I'm only thirty lines into your code, and already this review is starting to get long. Next I see another badly named variable (), and another one (). I notice strings like which are repeatedly used, so they should be . There's a block of code that starts with , yet at the top you've already made sure that can only be "1". I see the same similar lines repeated over and over again, which suggests they should be written as a single method with a couple of appropriate parameters: 

While there's definitely a lack of concrete numbers, the simple fact that you loop through several collections and do for each element is undoubtedly a major performance issue. You should do a single query and store the results in a , and then while looping fetch the necessary data from the dictionary (using ). If you'd started a SQL Server Profiler session you would have no doubt seen hundreds of queries; replacing those with a single one would already alleviate much of your server load. 

It's often better to use semantically named methods instead of mathematical expressions. For example, this code 

But if you can't check if the can be safely called before its execution then dealing with exceptions is a good way and I would stick with it. 

Also, can you say what purpose of ? :) You perform swapping of array elements many times and repeat the same code in all these places (loops commented as shuffle arrays). Define the method and use it: 

Please use conventional naming of properties. instead of for example. Also, why do you use instead of if you use index only to get an element of collection? Use and your code will be much clearer. First thing that should come into your mind when you encounter many and calls which need to determine if an element should be added into a collection is to use . Use for and . Main problem of your code is a lot of repeating loops and duplications like . Please learn programming basics and particularly C# basics. All your code can be rewritten like: 

You should release COM objects in block to ensure that references are released even if an exception is occured. For example: