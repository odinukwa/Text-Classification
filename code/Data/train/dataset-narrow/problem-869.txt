Notice that you can pass a value of type directly into . :-) I hope these comments are helpful. It is very nice to see such good effort from you; I am sure that you will keep getting better. :-) 

Firstly, as @Loki Astari pointed out, you can do just one iteration to both generate a random number and retrieve the character located at the index specified by the number. It means that you can get rid of the array entirely: 

Let's turn to the method . One of the first things I notice is that you have chosen the name for your display string. But why ? What does it stand for? Would it not be better to pick a more informative name so that it is immediately clear what the string is supposed to be? Personally, I would just call it , since it is supposed to be a display string. Make it a habit to choose clear, informative names -- it will be so much easier for yourself and others to read and maintain your code. But, on second thoughts, is it really necessary to initialize a string here? After all, you are not trying to build a string to be returned from the method -- is set to an empty string during each iteration of the loop. So I would rewrite the method as follows: 

There is no need to expose the user of your program to unnecessary details regarding how you intend to parse his input -- he just wants to play FizzBuzz; he doesn't care about how you design or implement your program. Now let's look at the method . It is already very evident from its name that the method runs Fizz Buzz using inputs provided by the user, so there is no need to include 'FB' in the variable names -- it is redundant, and does not convey additional information. So I would suggest that you instead rename 

But if (for whatever reason) you do want to keep a record of all the random indices, take note of @Loki Astari's suggestion that you should initialize a vector with size instead. The general idea, which is applicable regardless of the programming language you use, is this: In programming, as far as possible, avoid magic numbers (i.e., values with unexplained meaning) and hard-coded values. It will make refactoring far easier and less bug-prone. E.g., if you ever want to change the default value of to something other than 15, you will not have to dig inside the method itself to change the array size of . It is inconvenient when you remember to do so, and troublesome when you don't. You want to write your code in such a way that you are not required to read through the entire method whenever you want to change your input values. Second remark: Always favor using informative names over adding comments. E.g., why is the second parameter named ? Would it not be more reflective of the purpose of the method if it is named, say, instead? If I am a first-time caller of this method who has never read your code or comments, I would find the parameter name uninformative/misleading. But why should I have to read your code to understand what is going on? I just want to get a randomly generated string -- I don't care how you do it; I simply want to know what information I have to provide, and you should make things easier for me by choosing informative parameter names. Similarly, would be better named as , and so on. Choosing good names will significantly cut down your need for writing comments. As far as possible, try to make your code read like regular English. This is how I would write your code: 

Bit assignments, slicing, and iterating over bits are also supported. Disclaimer: I maintain gmpy2. The type was originally created to experiment with mutable numbers (in-place operations actually change the underlying integer without creating a new object). Support for in-place bit manipulation seemed to be a good idea at the time... 

Updates Without any changes, your code takes ~340ns on my computer. Changing the argument processing and how the return value is created decreases the running time to ~295ns. Replacing with multiplication didn't change the performance with my compiler (GCC 4.8.2). Changing the exponent to a non-integral value significantly increased the running time so I assume constant integer exponents are optimized by the compiler. Next, I simplified the conversion of the numpy arrays by checking that the objects passed are numpy arrays. This avoids creating new objects. I also assumed that the data type is a "float64". Extra checks could be added if needed. With these changes, the running time is ~220ns. Code is below: 

If I remove the call to , the running time is ~75ns. If I remove all the the argument parsing and just return the value 0.0, the running time is ~72ns. I did a few more tests to confirm running times and Python's overhead is consistently ~75ns and the function has running time of ~150ns. 

You may want to look at gmpy2. It provide an experimental integer type called that supports very fast bit indexing. It is about 3x faster than bitarray on my system. 

Disclaimer: I maintain the gmpy2 library which also provides arbitrary-precision arithmetic. includes fast integer arithmetic based on the GMP library. If is not installed, uses Python's native integer type(s) for computation. If is installed, uses the faster integer type. You didn't mention if you have (or , an older version) installed, so I ran one test with your original code, , and without . The running time was ~91 seconds. With installed, the running time was ~63 seconds. The rest of the examples assume is installed. Your code include superfluous calls to . Since is already an , the result of will also be an so the call is not needed. If I remove those calls, the running time drops to ~56 seconds. You import from both and . and replace the functions imported from . But you are still using . Numpy can be very fast but only when uses types it natively supports. If I remove and change to , the running time drops to ~48 seconds. Here is the code with all the changes listed from above: 

This post is specifically for the GUI, since this is my first time working with PyQT, so I am not sure if all is done properly. The file with the file with the classes Query and Universe and an example JSON file can be found on GitHub. 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

I have been trying my hand a bit at creating a big integer class in C++. This is a continuation of a homework assignment. The class stores a big integer in a double linked list. Each slot contains 8 digits of the number. It is possible to create an instance from an integer or char array. Negative numbers are supported with a bool sign indicator. I implemented addition, subtraction and multiplication, aswell as their operators. I didn't manage to come up with a good division algorithm though. The code: BigInt.h 

I have been refactoring this code myself as well in the meanwhile, so I thought I'd post some of the insights I have gained myself. Class inheritance Instead of passing a instance when creating a , by making a subclass of , I was able to reduce the amount of information that was stored in both classes. This makes accessing the attributes and methods of in 's methods shorter as well. does nothing 

I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them.