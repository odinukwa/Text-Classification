You could try some kind of simple distance function in the pixel shader. Perhaps something like barycentric coordinates (store different RGB at the vertices and the rasteriser will do most of the work for you). Then your pixel shader will have the information it needs about where on a polygon the current pixel is - near a vertex, near an edge, or in the middle... I suspect in practice it'd be easier to texture it though. 

Interpolating the matrices like that isn't going to give a useful result, especially for anything involving a rotation. Ideally you want to decompose your animation into some other format (quaternion for rotation, for example) and then interpolate in that form before building the matrix. 

I find it useful to build profiling in. Even if you're not actively optimising it's good to have an idea on what is limiting your performance at any given time. Many games have some kind of overlayable HUD which displays a simple graphical chart (usually just a coloured bar) showing how long various parts of the game loop are taking each frame. It would be a bad idea to leave performance analysis and optimisation to too late a late stage. If you've already built the game and you're 200% over your CPU budget and you can't find that through optimisation, you're screwed. You need to know what the budgets are for graphics, physics, etc., as you write. You can't do that if you have no idea what your performance is going to be, and you can't guess at that without know both what your performance is, and how much slack there might be. So build in some performance stats from day one. As to when to tackle stuff - again, probably best not to leave it too late, lest you have to refactor half your engine. On the other hand, don't get too wrapped up in optimising stuff to squeeze out every cycle if you think you might change the algorithm entirely tomorrow, or if you haven't put real game data through it. Pick off the low hanging fruit as you go along, tackle the big stuff periodically, and you should be fine. 

The technical part of publishing is described correctly in Luiz's answer, but publishing also involves licensing your game, usually. For that, I suggest you use the Mit license, if you plan to make it unprofitable and aopen-source. 

Let me explain what I mean by "standard way of delivering"... Think about Flash games sites. Flash games can be delivered as a single file, either hosted by the site, or, I guess, provided by someone else. HTML5 games, on the other hand, don't have something so standard. Usually, they have their own page, and portals just link to that page. I think that it greatly hinders the purpose of that portal, because, well, you want people to stay on your site and look for other games. Now, I think that a some kind of iframe way of delivering games would help solve this problem greatly. I saw some games doing that, and they were often included on tutorial sites to show a live example, which is obviously a great thing. So, is there a standard at all? Any suggestions? Can you create a game that just preloads itself in an iframe (I heard something about a "single document" or something)? 

The player is updated by some . The world handles movement and collision detection, applying proper physical changes and sending updates to objects. 

You should probably have worded the question like this: "What is/can be appealing in peaceful games?", and then used the answers as a general guide. Moving on, essentially, you're answering the question: "What interests/motivates/intrigues people in general, and isn't violent?" Here are some suggestions: 

It's easier to model because there's separation between the limbs and body, and the bits that need to stretch when animated are already stretched - so they get modelled and weighted correctly. Same reason you'd model a hand as open and fingers spread, rather than modelling it as a fist. Oh, and as far as programmers are concerned, we don't care. It'll still look like something from "The Thing" when we get the skinning code wrong at the first attempt. 

The texel co-ordinates, if you have bilinear filtering, are falling between the texels rather than being centered. You either need to to add half a texel to the UVs, or turn off filtering. 

The advantage to instancing is to allow multiple objects to be drawn in a single draw-call, reducing the overhead of calling the API. Typically as well as the geometry, you would also have a buffer containing multiple transforms, and perhaps other per-object data. This could be used in the shader to vary the appearance of each object by modifying its colour, or using a different texture (generally the texture variations would be achieved by using a texture atlas to pack multiple textures into a single texture). 

Something I've used, which works well even for irregular UV maps, is to turn the UV patch into a bitmap mask, and maintain a mask for the texture itself, searching for the first position the UV patch will fit into. I order the blocks according to some simple heuristic (height, width, size, whatever), and I allow rotations of the blocks to minimise or maximise the chosen heuristic. That gives a manageable search-space for brute force. If you can then iterate that trying several heuristics, and/or apply a random factor in choosing the ordering and iterate until some time limit runs out. With this scheme you'll get small UV islands packed into the gaps made by large ones, and even in holes left within single UV patches themselves. 

Your current design seems to go against the first principle of SOLID design. This first principle, called the "single responsibility principle", is generally a nice guideline to follow in order not to create monolithic, do-everything objects that will always hurt your design. To concretize, your object is responsible both for updating and holding the game state, and for drawing everything. What if your rendering code changes / has to change? Why should you have to update both of classes that actually don't have anything to do with rendering? As Liosan has already said, you should have a . 

True. But guess what: in 9+ years, we'll still be using assembly, C++ and C. I doubt that game developers will suddenly just decide that they have enough resources and stop pushing the limits of the machines. Of course, this is just a guess, but all of those languages are much older than myself, so I think I'm right. Besides, by learning C++ you'll make it easier for yourself to transition into a potential new mid-level language. 

Each loop, you should iterate through all of your particles, and then calculate a final force on that particle. Basically, the wall always gives them a positive force vector on the x axis, if they are colliding with it (particle.x - particle.r <=0). Then, each particle they are colliding with also gives them a force vector, depending on the angle between them. You collect these angles for all particles, calculate the average, and there you go! There are many optimization techniques you can use here, too, just look up some ball physics tutorial. You basically want to iterate through each pair of particles only once and calculate the force vector for both and store it in them. This will simulate gasses, basically, and if you give them a constant force, liquids too, I presume. As for creating and deleting particles, I implement a ParticleEmitter class, which has a position, direction and some other usefull stuff. Your example would be better off with an emitter that can create particles in a certain range, or even better, a rectangle. 

A cross product ought to be perfectly reliable for any planar polygon. If you've got problems with that, it's almost certainly just a bug in your code. As others have said, it would be useful to know why you think your normals are wrong. 

My generally feeling is always that learning to use something in the wrong context is not a valuable exercise. 

You've more or less answered your own question, I think. Divide the track up into segments, track which segment each car is in, and project the cars onto a line through the middle of the appropriate segment (mathematically it's a simple dot-product, so not complicated at all). Very simple to give each car a "distance" which you can sort for position. The segments give you some additional benefit - you can ensure that cars don't cut-corners (or general take short-cuts), go backwards, or other cheats. 

To convert a cursor position to a ray, you can back-project the 2D co-ordinates onto two planes parallel to the view plane. Typically you might use the near and far planes. Two points define a ray. This is simply a matter of doing the maths used to project a 3D point onto the screen, in reverse. Typically from world space you would multiply by a view and projection matrix to get into clip-space, divide by Z to do the actual projection, and then scale the resulting values into pixel-values. So in reverse you would scale the screen-coordinates into clip space, multiply by Z (taken from the plane you're interested in), and transform by the inverse of the view-projection matrix to get back into world space. However as you've noticed, most engines and libraries can do this for you... 

I've been looking all over the net, and I've found some voice synthesizers, but they either don't work, aren't free, or just have 5 or so voices to choose from... I need to get a synthesizer with which I'm able to edit the voice myself. This is needed for GLaDOS-like robotic character for my game. I did some searching here on GDSE, and it seems that questions like this often get closed as "not constructive". I believe that this is not the case, as this could help many other people who happen to be searching for the same thing. 

I'm not really a 3D person, and I've only used shaders a little in some Three.js examples, and so far I've got an impression that they are only being used for the graphical part of the equation. Although, the (quite cryptic) Wikipedia article and some other sources lead me to believe that they can be used for more than just graphical effects, ie, to program the GPU (Wikipedia). So, the GPU is still a processor, right? With a larger and a different instruction set for easier and faster vector manipulation, but still a processor. Can I use shaders to make regular programs (provided I've got access to the video memory, which is probable)? Edit: regular programs == "Applications", ie create windows/console programs, or at least have some way of drawing things on the screen, maybe even taking user input. 

Difficult to tell from the video exactly what you mean, but the simplest method of doing a sprite-based motion blur would just be to render the sprite several times, with some form of translucency. You could buffer the previous positions for use as the trail, or you could use a small time-step in the animation to render sub-frames. From the video in question I'd suggest a basic additive blend would work, which means you don't need alpha either in the texture or even in the vertex - just darken the sprite for the "trail". Over-writing the same pixels makes them brighter, for the glow. If you have even a very dark glow around the object in the original image, you'll get a glowing halo if you additively blend a bunch together. Alternatively you could use a basic HDR-like hack as a post-process. Take the image without any glow, threshold it so you only have very bright pixels, blur it a lot, and add it back in to the original. TBH I don't think that's necessary here. 

These things can always be useful. Whether or not it's the prettiest or safest solution is another matter, but I think game development involves a certain degree of pragmatism. 

Well as a simple hack on your current technique, you could choose between two up-vectors based on whether your view vector is tending towards parallel with one. It'd just be an abs, compare, and select in shader terms, so not much overhead - especially considering the sampling and blending... 

The last part is bothering me. At first, I wanted to have players gain experience points (XP) when destroying other mechs, but gaining two things at once (money and XP) seemed to be in conflict with my last point, which is simplicity. If I were to have a leveling system, that would require additional development. But, the biggest problem is that I simply couldn't fit it anywhere! Adding levels would require adding meaning to these levels, and most of the things that I hoped to achieve could already be achieved with the money mechanic I introduced. So I decided to drop leveling off completely. That, in turn, removed a fairly popular and robust mean of progression in games from my game (not that I would use it well anyway). Is there another way of progression in games, aside from leveling and XP points, that wouldn't get rendered redundant by my money mechanic, would be somehow meaningful (even on a symbolic level), and wouldn't be in conflict with my last point, which is simplicity? 

I'd never expect shortcuts to be in my language. Pretty much everyone who plays games knows English, it became a standard, and it's always a good idea to keep up to the standard. So stick with English. 

I'm making an MMO game and I just got to a point where I need to implement achievements... How do I do that? The most straight forward thing to do would be to run this once every 100ms,: 

You could search in both directions - from the current tile to the nearest neighbour, but also looking to see if another tile has the current one as nearest in the opposite direction. Move to the closest of those two if different. 

Ultimately you can only rule out impossibly high scores, because the rest are (by definition) merely implausible, and thus might be a legitimate (and awesome) player. Otherwise you have to rely on obfuscation techniques (such as encryption, and sending other stats beyond just score). You could also send the score periodically as the game is being played, which would add another level of complexity to cheating - i.e. the server can decide if the game has been played long enough to warrant a particular score, and also ensure that enough intermediate reports were received during the play-time (just don't make it 100% or the train going into a tunnel on my way home will result in my throwing the phone out the window). Ultimately someone will find a way to break it though, so don't kill yourself trying to stop them. 

You don't need collision detection, but you will need to give your enemies a bit of intelligence, and have them avoid running in to each other. Collision detection without that will just make your enemies look stupid anyway - people avoid each other, they don't generally collide. Look up "flocking" for some simple behaviours. The basic idea is that things should head towards the player, but away from a close obstacle (each other, walls, that kind of thing). 

Now, when you're adding an entity just do . Most of the problems raised in that AltDevBlog article Darcy posted don't really apply here: we're not letting anyone name entities, strings are just numbers here. If you're using C++ you might not need strings at all, as integers work as keys too. 

With which approach should I go and why? Is there a better alternative? Also, in case the second approach is the best, how frequently should I perform the tasks? 

First of all, I know that there are alternatives to both HTML5 and Javascript, but I worded the question so generally ("browser-based") because if I had said "HTML5" or "Javascript" games that would already imply an answer to the question. When writing wiki posts or discussing, I usually call these games "HTML5/Javascript" games. They are written in Javascript, using the new HTML5 technology. What is the proper way to call them: HTML5 or Javascript games? I see that most people opt for HTML5, why? 

Now, gives you a random number between 0 and 1. 0.73, for example. If you multiply that by 100 000, the said width of levels, you get a random x position in that level (73 000, for example). When you do , you get a whole number between 0 and x, including x. For example: could give you 0, 10, 4, 7, and so on. If you have any questions, or if you guys notice I'm wrong about something, notify me in the comments!