You should add two more steps to this so that the node that has just been popped isn't connected to anything else and can be garbage collected: 

Method 4: - this might be unnecessary but because all other formattings are method let's make this consistant. 

Don't create the context like this. It needs to be disposed as soon as possible. You queries should create the context for themselfes: 

I would count your solution as hacking the and the biggest issue I see there is that you don't dispose the . Your strategy seems to be mostly ok and I can't complain much about it. One thing that I don't like about is the lengthy condition inside the method. A helper variable for this condition would be nice. 

Notice that the method's name is now because by convention we add the suffix to methods. This is not a bullet-proof solution if you want to access the properties manually because it will throw if a key does not exist. You might want to use if you need to but it'll do for the current scenario otherwise you should implement the getters this way: 

Your code mixes a factory and a builder by not using a consistent vocabulary which makes it confusing because one is not sure what it actually is. The main class is called but instead of having such methods as it uses . As a matter of fact it should be a because it creates s and not s. is a template so call it . Naming might look like a minor issue but it's one of the most important things. Using the right names makes the code self-documenting and you don't have write lenghty explanations. It also influences how you think about the class and lets you better focus on its actuall purpose. When we take a look at its methods, we see that each of its methods requires a . To me it looks like it should be specified only once via the constructor and be one of the dependencies. Of the four methods only two of them use the generic argument. The other two work with a pure . It doesn't look like a good idea. Why would one create a concrete factory with an exact generic argument and then allow other types anyway without even checking if they are of the requried type? Another thing that I find very confusing is that the is a dependency of the and vice versa because the depends on it here where it creates the . 

although this is not yet exactly what you have because this will yield only exact matches. If you want deparment-name to be null then you need a left join and I think this should work: 

The last question about sequence generators Growing potatoes in delayed sequences was only about potatoes. I thougt why not make it work with apples and oranges too so I made it generic. 

Just create a helper method for executing a query where you wrap the entire error handling and pass the query via a lambda expression: 

To me there can only be two such numbers in the first set an they can be selected with these two queries: 

It's very hard to tell you what needs to be improved. This method does a lot and you'll need to norrow down the performance bottleneck to something more specific. In order to do this you have the following options: 

There is more that can be improved like the that uses the keyword (I'm pretty sure there is neater solution) but for this I need to find out how it works first ;-) 

What do you think of this client? Is it intuitive and easy to use? Is it easy to extend? I deliberately did not any null-checks yet. 

It's supported by two other utilities. a - its job is to create the context that must have a constructor accepting a connection string name. 

You're right, I cannot simplify it anymore ;-) Most reviews are about commenting bad code/habits and making suggestions how to improve it. But you're lucky, to me, there is nothing bad to say about your snippet so this will be a short review (and probably a reason why there are no anwers yet). You use clear names for the properties and variables where you use the first letter of the collection name or something derived (like type). You also use meaningfull names for the properties of the anonymous objects. If the rest of your code looks as clean as this small sample you should be happy ;-) 

This doesn't look right. Does an empty file name really makes sense? I think you should prevent it from being null-or-empty or add another constructor that doesn't require it and the one that does, should not allow a null. 

I find this a nice idea but not useful at all, sorry ;-) You might as well create a decorator cache that stores the results. A real cache should be able to cache expressions like: 

Now let's try to reorganize the configuration and get rid of the magic strings that the user needs to use. You can achieve this with interfaces. Create one for the database configuration: 

This type actually stores s but internaly it depends on a hard-coded . This isn't good. If you want to have a collection of file-data-sources then this should be the type of the collection. Also in this case a would be enough and the should have a factory method . The shouldn't know how to create a or even how to check any wildcards. It's the responsibility of the . 

This should be called as this is what it does. It does not search for instances of the subclasses but it creates them. 

Start by initializing this to an empty collection. You'll save a lot of null checks. Consider this old method: 

object vs strongly typed I have one more advice. Try to make everything strongly typed. This means try to get rid of anything of type . Currently the has this field/property . This being of type has huge implications on the rest of the code. You have to check the parameter types and counts everywhere. Here are a few examples: 

We need also an enum for the directions. You already have one but let's fix the naming that should be PascalCase for public APIs: 

Notice that I've also removed all the s and replaced them with a dictionary of s that get the property to be comapared. Now when you use it with a color there is no doubt what is going on here: 

if not then add a private setter and initialize it in the constructor. Be aware of the fact that the array is not immutable and can be manipulated elsewhere. 

Using reflection is rather a last resort solution. Here you can avoid it by removing the method from the . It does not belong to this class. It should be only a responsibility of the builder. On the other hand it's called but it builds some random which is very confusing. Instead you can add a static property to the that will return a new builder and already pass it the . 

Why would you need two methods doing the same thing but under different names? The interesting thing about them is that if you override the and it calls the then you'll have an infinite loop and the will be thrown. 

the index should never be less then zero. If it is, then there is an error. Its an enum and the property isn't nullable so I think the protection isn't necessary. After getting ther order from the dictionary you should be able to immediately call this 

To be able to apply various colors to the console I created a . It's really simple. It just takes an XML and renders it to the console with the colors specified. The element names are actually optional and can be any names. They are only required to parse the XML. What matters are the attribute and color names. I didn't know how to solve it with less effort without inventing a new markup. 

Whether you use or reflection internally to access those properties is another question. If you however can change one of those external dlls then an abstraction would be the obvious way to solve this: 

If they are, then this is a pure coincidence. You'll be safe if you use the SortedDictionary instead which: 

I think would be a better name. Secondly you might consider it to return instead of just as this method can take some time. With this you could for the result. If you chose to do this, then you also might consider another argument, the in case you decide to no longer wait. 

This would select all users with a picture in their user-info. I assumed the table has a foreign-key that you can use for joining both tables. 

If you make the property virtual you can override it in a derived class if the name of the filter cannot be derived from its type name: 

But wait a minute! Let's take a look at what actually does... to my (not) surprise it does not calculate anything but instead it checks products against a customer!!! How confusing is that? 

It receives the values from the code-behind property (you of course would read the descriptions here with your reflection helpers): 

Don't name classes dictionary if they aren't one (implementing the interface). It's confusing. You can derive a type from the dictionary instead of implementing only parts of it and inventing new vocabulary for it. Don't come up with new generic parameters names. The conventions is to start the names with the uppercase letter . You could simply define it as: 

If you've found and obvious flaws in this solution or think that anything can be improved, I'd be happy to read about it. 

Now you only need a task to process a collection of them. You can create it in many different ways so here is just one of them. I created an observable from an array of persons that I into a single observable that I want to watch. I'd like this to be processed either every ten items or every two seconds (there are also other options). Then each batch is processed with the loop. 

This interface is named but it contains a method. There is nothing about any conditions. The name would be much better I think. 

There are so many different solutions already that I won't post another. But there is something else that bothers me, the names of the extensions. I find they are too confusing. Expecially and . They are not very technical (at leat in this context). I think they should be called the same way we call the conditions they are based on and that are (or should be) familiar to all developers. This means: Two of them already folow that pattern: 

This will pass the property name to the method that now can search for the setting. You can easily cache it if you like. 

You should know that the class also has issues but I currently haven't any ideas how to improve it... in fact I didn't really tried hard enough ;-) 

Putting this in that method is a very bad idea. I'd be really surprised if my application exited when I called this API. If you still want to keep it there then consider naming the method which would prevent such surprises. 

My previous wasn't disposing a lot of resources. I've fixed it (hopefully without introducing new issues) and because a few new patterns emerged I did a lot of refactoring and simplified a few things - in fact I was able to remove more then a hundered lines of code. It looks like there is a lot of code left but the only complex part is the . Other classes are only data or contain mostly one-liner convenience extensions. 

So is your code maintainable? Well, even though the score is not so bad I don't think it's. Why? Because it does two things that it shouldn't which are: 

This means I'd like to create the downloader first and then tell it what to download and where to save it. I don't want to create a new downloader for each url or each download directory so the actual interface should be simply: 

Yes, because it seems that you think that you must use a builder because it's some kind of a cool pattern for everything. No it isn't. Strategy Pattern is cool. Builder makes things simpler. 

This would be all you need. If you want to have a more convenient fluent API then you should write a that will allow you to construct the parameters and call the method eventually: 

With a private constructor. With read-only properties and with a factory method which can take a various number of data parameters so that you don't need multiple overloads. 

It takes 0.040sec to enumerate a directory with 10.600 files and 1.400 folders yealding 417 results with the above ignore list on my notebook's SSD. 

You shouldn't check the for . You should prevent it to be a at all and check the parameter passed to the constructor. If you however still want to do it then consider this: 

You can rewrite the nested s and loops with a nice and short LINQ query that will give you all the items first: 

This of course is creating a lot of objects. You could speed this a little bit up by making a struct but still, it'll be slower then the normal check. Convenience comes often with some kind of a performance hit. 

I suggest making the code more expressive by encapsulating the conditions as lambdas before the loop. You should avoid magic numbers and for the create constants or an enum. In the following example the stand for a block and for an attribute. 

Don't return a complete list of words if this isn't necessary. Use an iterator instead - by using LINQ or the . What if you wanted just the first three words? You would need to calculate them all anyway. With deferred execution you can stop whereever you want to. Example You can now easily find all pyramid words with linq: 

processes the data in order to build the string. It's quite fast but in this particular situation the minimal overhead is noticable. Generally the is the fastet way to build strings so using it is definitely the right choice. 

Alternative: Rx Creating your own producer/consumer solution is not always easy and is one option but you could also use the tools that are already there. One such tool are the Reactive Extensions (NuGet-Package: ). It can be very helpful in your scenario. I requires two parties 

If you are applying for a position of a junior developer I'd forgive you some of your beginner mistakes that are: 

I've been working on another timesaver because I really really don't like to type all those validation s and exceptions over an over again. What I came up with this time is a set of validation extensions that make use of expression trees even if very simple ones. 

looks like an open set. values might be a better solution in this case. You won't have to convert anything and you can use any names for the values. 

This means that the looses it's execution time and you move it into the new type which should contain both values. Should you want to create other benchmarks then you can extend the with other algorithms but no longer need to modify the problems themselves. They should just solve the problem and don't do anything else.