use the buffer as ringbuffer, locking and updating only a part equal to current "pointer" + required size. Moving round the buffer using modulus. use technique called buffer orphaning, where you just discard the buffers from your point of view and rely on the drivers do the optimization 

For very simple and limited(in numbers) you could give each of your items tag. Alternatively, you can take advantage of the method signature - the one of the colliding object will be (.gameObject) and the other one is . This way you can access attached components directly, including all scripts. So assuming you have something like script on player and collider script on the item you could do something like: 

It is very similar to your code - you were on the right track. Code explanation: first we find between which keys the time lies, then we find the interval length, after that we subtract left value from time to get "local time on interval". And lastly we find "how much close" it is to right boundary by dividing local time by interval length. We multiply right value by the result and finally we multiply the left value by complement and sum it for desired result. If you wanted more smooth values you could for example interpolate by cubic spline solving system of linear equations (not hard to find, you will be likely looking for chord parameterization and natural spline bounding conditions). 

I would not define minDamage and maxDamage when generating the item at all. Your goal is to find minD and maxD, but it is important to realize that there is single damage number(in your case, as you said its linear scaling with level). You know the damage is linear: . For example scaling factor of sword might be 2, for dagger 1.5 and for two-handed axe it is 3. Also note I used , if you want to have different quality items it might be a good idea to separate required level and item level(but you probably do that already). The level 50 sword now has 100 damage, to introduce minD and maxD you should also define "randomness", lets call it and set it for all swords to 0.15 (=15%). Now you can get minD and maxD very easily: 

After looking into this for a while, it seemed that zlib wasn't going to satisfy my needs. It seems to be focused on compressing and decompressing individual files. I need something that is able to handle archives. One potential solution I've found would be to use libarchive, which is an archiving library that will handle extracting files from an archive such as a ZIP file. It even allows you to assign the extracted file to a standard FILE pointer, which would make interfacing with any other libraries (PNG, my model loader) potentially more straightforward. 

I have a DX10 game that is fillrate bound. One of the things I've been realizing may be contributing to this is that I compute depth in the pixel shader (the game uses a logarithmic depth buffer to get extreme precision from 1cm to millions of meters away). It occurred to me that writing the depth in the pixel shader is ruining the ability to to Early Z testing. Can this be fixed by outputting this computed depth value in the vertex shader instead? 

I am currently using the DirectX June 2010 SDK. Everything was working fine with my installation until recently. Unfortunately I'm not sure what changed or when, but now when I create a device with D3D10CreateDevice1(), it always crashes with a memory error if the device is created with the D3D10_CREATE_DEVICE_DEBUG flag. Even reverting to old code which used to work causes this error. Additionally, PIX always crashes every time I use it with my game. I did some searching and found a lead that I may need to update my SDK installation. This page also indicates that I need to "install the updated SDK Debug Layers". How do I do this? I have no idea how to install the "Debug Layers"... Additionally, is it a mistake for me to be using the June 2010 SDK? Apparently DirectX is now included with the Windows 8 SDK, which I haven't been using because I've no interest in Windows 8 development. Is this foolish? Is there any downside to me using the Windows 8 SDK just for Windows 7 DirectX development using Visual Studio 2010? 

(Sorry about the bad title, it's the best I could come up with) I've been planning a gladiator manager game for a while now. Something similar to Blood Bowl (or Football Manager, only with fighting rather than kicking a ball), only with a much larger focus on the actual managerial aspects of running a team. I'm still fairly new to game development, and have only created games with a very narrow focus (i.e. simple first person shooters), so taking on a project with a larger scope is very interesting, but also problematic since I really don't have a grip on how exactly to make the damn thing work. Basically my two major hurdles are the interface and database. Obviously the interface is incredibly important since the player will spend most of his/her time doing managerial tasks. The game will be team-based, with various leagues in which those teams fight in, so it all relies on a database. I have never done any real work with databases, so this in particular has me stumped. At this point, my idea is to use XNA in a WPF application, with an XML database. This just seems like a combination that would work well together, and as I have a C#/XNA background, I wouldn't need to learn a new language or graphics framework to work in. Does that seem like a sensible combination, and if not, why? I have never done anything with WPF, so all of my information on it's uses comes from Google, and that may or may not be a good thing. Would XML be a smart choice? There will likely be a fairly low (think 20-30) number of teams, all of which will have a dozen or so fighters, so it's not a monstrously large set of data. Thanks in advance, I know I didn't write the most intelligent post ever, but I had to get my ramblings out somehow. ;) 

The title is fairly self-explanatory. I have a 2D racing game that utilizes per-pixel collision detection (the track is essentially two bitmaps, one for the graphics, one for collision data). The problem I'm running into is that I can't figure out how to implement the collision response. I can figure this out for situations where I have a box colliding with another box, but the fact that my objects can essentially be any shape has me stumped. The one approach that I've had some success with is to just sample a couple of pixels near the pixels that collide, build vectors out of those and then take the cross product of that, but it fails in many scenarios. Plus, it just seems like overengineering. In fact, I'm about 103% sure that I'm just overthinking the whole problem. Has anyone tackled this problem? 

I'm implementing Lua scripting in my game using LuaBind, and one of the things I'm not clear on is the logistics of reloading the scripts live ingame. Currently, using the LuaBind C++ class , I save references to Lua callbacks directly in the classes that use them. Then I can use using that object in order to call the Lua code from the C++ code. I haven't tested this yet, but my assumption is that if I reload the scripts, then all the functions will be redefined, BUT the references to the OLD functions will still exist in the form of the held by the C++ code. I would like to be able to swap out the old for the new without manually having to manage this for every script hook in the game. How best to change this so the process works? My first thought is to not save a reference to the function directly, but maybe save the function name instead, and grab the function by name every time we want to call it. I'm looking for better ideas! 

Note- this happens when I call CreateTexture2D(). However, if I take the hint and try a BindFlag with my created texture (D3D10_BIND_RENDER_TARGET for example) I get the exact same error message when D3DX10SaveTextureToFile() is called. Here is the code: 

I'm making a game in Direct3D10. For several of my rendering passes, I need to change the behavior of the pass depending on what is already rendered on the back buffer. (For example, I'd like to do some custom blending- when the destination color is dark, do one thing; when it is light, do another). It looks like I'll need to create multiple render targets and render back and forth between them. What's the best way to do this? 

I have some screenshot code (pasted below) which was working fine until I enabled MSAA. The first time I tried to use this code, it complained that the texture I'm creating needed to match the sample count of the source texture. Fine- my MSAA value is 8 currently, so I set the screenshot texture to a sample count of 8 also. Now when I try to use the code, it complains: