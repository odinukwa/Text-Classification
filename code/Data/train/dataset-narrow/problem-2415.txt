This problem is NP-complete. A proof based on reduction from 3-SAT is as follows: Consider an instance of 3-SAT with $n$ variables and $m$ clauses. We will construct $2n + 2m$ bit vectors ("rows") of length $2n + \lceil \log_2(n + m) \rceil$, such that the smallest number of discriminating bits is $n + \lceil \log_2(n + m) \rceil$ iff the original 3-SAT instance is satisfiable. The first $2n$ bits will correspond to the literals $\left\{ x_1, \neg x_1, x_2, \neg x_2, ..., x_n, \neg x_n \right\}$. With respect to these bits, the first $2m$ rows will come in pairs, the first of which will have a $1$ for each literal included in the corresponding clause, and the second of which will consist entirely of $0$'s. The remaining $2n$ rows will also come in pairs, the first of which will have $1$'s for the corresponding literal and its negation, and the second of which will consist entirely of $0$'s. Finally, the last $\lceil \log_2(n + m) \rceil$ bits will be used to "sign" each pair of rows with its index, from $0$ to $n+m-1$, written in binary. In order to distinguish each "literal" row from its successor, either the bit corresponding to that literal or the bit corresponding to its negation must be retained. Also, in order to discriminate among the $n+m$ "zero + index" rows, all $\lceil \log_2(n + m) \rceil$ index bits must be retained. The minimum possible number of discriminating bits is therefore $n + \lceil \log_2(n + m) \rceil$. Finally, in order to distinguish each "clause" row from its successor, at least one of the three bits corresponding to literals included in that clause must be retained. If the 3-SAT instance is satisfiable, this last condition will not require any extra bits (in particular, we do not need to retain the bits corresponding to both $x_i$ and $\neg x_i$ for any $i$); and conversely, if there are $n + \lceil \log_2(n + m) \rceil$ bits that discriminate among all $2n+2m$ bit vectors, they must contain exactly one of $x_i$ and $\neg x_i$ for each $i$, and hence correspond to a satisfying assignment of truth values to the $n$ variables. 

We see that the two problems are equally difficult, at least in this sense. This result is somewhat surprising, because one might expect the $XY$-shuffle problem to be easier. In particular, the entropic argument shows that $\lvert{B_{2n}}\rvert$ is $\Omega(n)$, but gives the stronger result that $\lvert{C_{2n}}\rvert$ is $\Omega(n \log n)$. 

This is not a solution, but a reformulation that avoids explicit mention of the swapping and sorting operations. Start by sorting the entire combined list of filenames and their swapped versions, and identify each filename with its index in that list. Then two files are neighbors if all the old filenames between them have already been destroyed, and if none of the new filenames between them have been created yet. The reformulated problem is the following: Given a set of $n$ disjoint directed edges $(a, b)$ with $a, b \in \{1,2,…,2n\}$, is there an ordering $(a_1, b_1), (a_2, b_2),...,(a_n, b_n)$ of these edges such that 

The graph $G_{\pi}$ corresponding to a particular initial permutation $\pi\in S_n$ contains just those edges $(i,j)$ for which $i-j$ and $\pi(i)-\pi(j)$ have opposite signs. That is, each pair of numbers in the wrong order in the permutation is associated with an edge. Clearly the allowed moves are isomorphic to those in the permutation game (remove a number = remove a node), and the winning conditions are isomorphic as well (no pairs in descending order = no edges remaining). A complementary view is obtained by considering playing a "dual" game on the graph complement $G^{c}_\pi = G_{R(\pi)}$, which contains those edges $(i,j)$ for which $i$ and $j$ are in the correct order in the permutation. The dual game to Disconnect is: 

A little thought shows that these two different games on heaps (we can call them 1-Heaps and One-Heap, at some risk of confusion) are, in fact, themselves isomorphic. Both can be represented by a game on a Young diagram (as initially proposed by @domotorp) in which players alternate removing a lower-right square until only a single row is left. This is obviously the same game as 1-Heaps when columns correspond to heaps, and the same game as One-Heap when rows correspond to heaps. A key element of this game, which extends to Disconnect and Reconnect, is that the duration is related to the final game state in a simple way. When it is your turn, you will win if the game has an odd number of moves remaining, including the one you're about to make. Since a single square is removed each move, this means you want the number of squares remaining at the end of the game to have the opposite parity that it has now. Moreover, the number of squares will have the same parity on all of your turns; so you know from the outset what parity you want the final count to have. We can call the two players Eve and Otto, according to whether the final count must be even or odd for them to win. Eve always moves in states with odd parity and produces states with even parity, and Otto is the opposite. In his answer, @PeterShor gives a complete analysis of One-Heap. Without repeating the proof, the upshot is the following: 

This seems to depend heavily on the form of $f$. If $f$ has a small number of distinct features (say, a handful of well-separated sharp peaks), then you can attempt to identify those features in the point cloud and then use SVD to find the Euclidean transformation that best takes the observed features back to their original locations. If $f$ is spread out and has no obvious landmarks (e.g., $f(x,y)\propto e^{-\beta(x^2+y^2)}\left(1+\varepsilon\sin^2(x+y)\right)$, where $\beta$ and $\varepsilon$ are small), then there will be no way to find the maximum-likelihood transformation without trying a large number of possibilities. In general it becomes an optimization problem that could have many, many local optima. 

Depending on the particular permutation, one of these games may seem simpler than the other to analyze. The advantage of graph representation is that it is clear that disconnected components of the graph are separate games, and so one hopes for some reduction in complexity. It also makes the symmetries of the position more apparent. Unfortunately, the winning conditions are non-standard... the permutation game will always end before all moves are used up, giving it something of a misère character. In particular, the nim-value cannot be calculated as the nim-sum (binary XOR) of the nim-values of the disconnected components. 

Here's an extremely heuristic argument that suggests where local maxima may be found. Let $N_d$ be the number of positions that require exactly $d$ moves to solve. Each move from such a position takes the cube to distance $d-1$, $d$, or $d+1$; so there are a total of $N_{d-1} + N_d + N_{d+1}$ positions that are accessible. There are $M$ moves from each position, leading to $M$ new positions; a position at distance $d$ is a local maximum when none of these $M$ positions are at distance $d+1$. If we take these positions to be drawn uniformly at random from the accessible positions (which, of course, they aren't; this is the heuristic part), we have: $$ \begin{eqnarray} X_d &=& P\left[\text{ a given position at }d\text{ is a local max }\right] \\ &=& \left(\frac{N_{d-1} + N_d}{N_{d-1} + N_d + N_{d+1}}\right)^M \\ &=& \left(1 + \frac{N_{d+1}}{N_{d-1} + N_d}\right)^{-M}. \end{eqnarray} $$ The expected number of local maxima at distance $d$ is $N_d X_d$. For the $3 \times 3 \times 3$ cube, the number of moves from a given position is $M=18$, and estimates for $N_d$ are provided at God's Number is 20. Using these values, we find the expected number of local maxima to be $N_{16} X_{16} = 0.2$, $N_{17} X_{17} = 9 \times 10^9$, and $N_{18} X_{18} = 1.5 \times 10^{19}$. So there are unlikely to be any local maxima for $d \le 16$. At $d=17$, the total number of positions is estimated to be $12 \times 10^{18}$, so one might expect to test a billion positions before finding a local maximum. Finally, at $d=18$, one expects a local maximum in every twenty positions.