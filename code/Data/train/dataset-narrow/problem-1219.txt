Hmm, so it wasn’t any harder after all; just replace the +1 with the proper length of the separator. That’s a good sign that the algorithm was structured well to match the way iterators and the standard algorithms work. 

A random-initialized location might be handy for this specific program, but it’s sufficiently bizzare that it hinders the understanding of the code. Make a function to return a random location instead! 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. 

Another thing to note: The sum gives me an integer, so I have to explicitly convert one of the arguments in the division to or I’ll get integer division. Adding the s will be faster than converting each to a and adding those, the way you have it. 

There is some good, a few things wrong. I see you are nesting inside the class, which is good. Most people start by making it a separate top-level item. It is a problem though that the type is private, yet , a public member, returns that! 

Calling on every element to copy the results — Copy the elements in the order in which they appear in the row, and use an iterator to place them efficiently. 

Good that you use an initialization list! You are, however, using ye olde syntax. Use curlys, not parens, for initialization. Since you only have the one constructor, “all” of them use the same values for most of the members. Put them in the class definition as direct initializers on the members, instead. 

The version took 17 seconds over 10,000 calls. The version clocked in at 28 minutes. Moral of the story is that Excel allows you to open XML files merely as a convenience - it is not intended to be an efficient way of retrieving values from them. Always best to use the right tools for the job. 

Unless you are adding values to column (j), why are you comparing in both directions? If a value is duplicated between the two columns, it obviously is going to be in A after you add it in (j)... I'd try something like this (pseudo-code): 

If that's your , change it. and are both VBA keywords. If it isn't your , fully qualify the members both to make it easier for the reader to see what you mean and to avoid any potential that they would inadvertently conflict with the keywords: 

Note that this does a couple things - it avoids the need to add one to the - calculation and then just subtract it again. If you're testing to see if an array has at least 2 elements, > is sufficient (and protects from cases where and\or is negative). It also explicitly protects against the case of , which returns -1. This leads me to... 8 - Your guard clauses have a very subtle bug. Before you process the cell, you use this test: 

Use a array - This is probably going to be the biggest performance gain if you're able to hold the entire working on in memory at once. If not, you could probably "page" it by processing in chunks of 10000 rows or something like that. The implementation details are probably out of scope for my review (although another reviewer might cover it), but take a look at the procedure above - it pulls the column into an array and works with that. I'd probably start by tackling to lower hanging fruit above, then switch to array processing if you're still not in the performance neighbourhood you need to be in. Good luck! 

It seems to me that the function should be generated from the BinaryOp. So that makes it the same in all your specializations, and the only thing you need is the matching . I think you should have a fully generic template that figures out and from the template arguments, and looks up the proper unit value for that operation using a smaller specialized metafunction. 

Note that I made a normal-named function and then defined to call it. That will be much better for people who read your code later, since carries certain expectations. 

I don’t see why. The normal template class takes a list of types will be found in arrays (or other contiguous sequences). Why would you ever use as one of them? You are only handling in the first position, anyway. would have problems working, too. 

Don’t write an empty destructor. Leave it off completely, or use to emphasize that it exists. You’ve made your class to not be trivally destructable because of this, which means the compiler can’t do certain optimizations (that's an over simplification). 

Don’t use for normal member access. In this function, you could just write . See CPPreference — you mentioned needing to get to know the libraries better; this is a good resource to keep at hand. 

Also, use . And pick a name for the symbol here that you know will never clash with anything else in the project including other third-party libraries. That is, use a UUID. 

You always cache the and regardless of whether it is necessary or not. I would guess that roughly 1% of all the code I've written requires this. Same thing with . Same thing with . Do I write another if I need that turned on? Or maybe ? None of this work is free, and it seems like a jumbled collection of "this will make your code go faster anecdotes" collected from SO comments. The cargo cult has found thier messiah in this wrapper. 

So if the intention is to enforce type safety, the better meta solutions would be to not use Variant types if they can be avoided or to use an IDE plug-in to make sure your assignments are type safe. If the intention is to simply replicate the functionality of the .NET List object, this is an entirely different matter (and one that is both useful and well executed, BTW). Nit-picking aside, let's get down to the "better /more efficient" side of things. Given that the object in VB6 isn't much more than a glorified array (4 methods - seriously?), I would just skip it entirely and just wrap an array directly. The vast majority of the class just uses the for storage space, and the fact that the intention is to ensure strong typing makes the memory management a lot easier. Note that I am not recommending an array of Variants, and am at risk of getting into StackOverflow territory. VB6 is based on Window COM, and uses a SAFEARRAY structure to store all of its arrays internally. This (vastly simplified) defines the size of each array element, tracks the number of elements in each dimension, stores a couple COM flags, and holds a pointer to the array data. Since VB6 is COM based, it also has a couple of undocumented functions like for pointer resolution and manipulation and can directly access the Windows API. This gives you the ability to do inserts and deletes into the middle of arrays with memory copy operations instead of iterating over the array or the a . You can get the underlying data structure like this: 

The memcpy/memset use of makes me want to look closer at that. Could it be done in a properly typed manner? And since it’s a , you could use instead of memset. 

Look at Boost.Range. Your first point drives most of the rest of the concerns. Write your template function to take a Range. You can pass it a C string literal, a std::string, an array, vector, or anything —— even a pair of iterators if that’s what you need after all. Not limited to char? No problem: make it a Range of T, with a default of char. This takes the place of your initial idiomatic approach. Use ranges rather than iterators, and you don’t need to wrap it for convenience. Boost.Range does all that for you. The output can remain an output iterator, but I like to make it a range adaptor. With that, you can do things like: 

The top part of the function uses a lot. In fact, that is the only value of the board that is used at all. So you should write this as a range- loop and forget about working with , , and loop bounds manually! 

I appreciate that this is one use where a plain old primitive C-string is just fine, even preferential — you want it to be non-throwing, so don’t want to involve the class. Now, back to the . I agree that the “old fashioned” type is fitting and proper here, but you can still express it better using up-to-date idioms. See ⧺F.25 (and look over the Standard Guidelines in general!) So write 

Getting back to , your code isn't equivalent at all. The original function is actually pretty efficient at what it does - it calculates what it needs to copy, then does that in a single operation. Your code doesn't perform a calculation at all - it counts row by row with this code (line continuations added for clarity): 

Make sure the right workbooks are open. Add worksheets. Move data. Sort data. Copy data. Add headers. Delete rows with "template" in them. 

The other posts cover the main issues very well, so I won't belabour them and get right down to your performance issue. Your code is unbearably slow because using Excel to retrieve values from XML documents is using the bluntest of instruments available for the job. Kind of like chopping down a tree with a noodle. The network retrieval is not your issue at all - the bottleneck is how long it takes Excel to open a new Workbook. Just for a quick test, open an XML document in Excel, then open the same one in Notepad. Now imagine doing that 15,000 times. This is exactly what your code is doing, and is exactly why it is running slow. Luckily, there are XML handling tools available in VBA - just add a reference to Microsoft XML and use them instead. I ran some tests to compare the 2 access methods, opening this file, retrieving a value, and writing it to a cell in the current Worksheet. XML Method: 

Don’t use C-style casts. Any appearance of such a cast is a flag for code review; casts that are actually needed should be function style, specialized, or use clearly named helper functions. You supplied an implicit conversion, so you don’t need this cast at all. 

For the third point — CreatePacket takes PacketData Certainly. I think you fell into a trap in making the factory take the ID of the kind of packet to create. As mentioned in First Point, you used that instead of creating normally when you already knew the type you wanted, on the sending side. So yes, have a static factory include the logic to figure out what kind of packet it is, hiding that detail from the users of the class. Then, since the factory has the data, why not have it do the deserialize too? You are already dispatching to a function that’s written separately for each class. So pass the data through to that! 

First of all, why are you passing them by value? Do you really need to copy them into the function? I don’t think so. Since you use that type a few times, make a handy name for it. 

You should put the initializer right on the variable, rather than having to call the function. It could be a constructor for . I take it that the stuff in the headers is C, not C++, and is used for C programs too. But you can derive a class from a C struct, adding member functions. This is a very handy technique. 

While the intent may have been to group aliased members, you can make this explicit by just assigning aliases within the declaration itself: 

The code above sidesteps the next huge performance hit in your loop, but you should be caching values for procedure calls that will always return the same result. In the quoted statement at the start of the answer, you call 3 times and 3 times. They'll always return the same thing, so put them in a local variable to avoid the repeated calls (note that in this case, Raystafarian's solution is doing the same thing, but on a much more "global" scale - it reduces all the calls to just one). 

Variant Use This is a data type that invariably leads to problems down the road. In generally, you should type everything as strongly as you can. You're basically giving the compiler and run-time license to treat whatever the variable is as loosely typed, which can lead to unintuitive behavior or bugs. This declaration in particular is a head-scratcher: 

@Mat'sMug covers the procedure as written very well, although I'd add that using the function to determine whether a cell has something in it is problematic. The function is actually not testing whether a cell is "empty" - it is testing whether the passed is equal to : 

I would personally change the name to something like (Pascal case for namespace identifiers) and the two options to and . This will be much less likely to create collisions. Note that and are also really common local loop counter variables. If they're public enumeration member, they pollute the global namespace and can create bizarre\misleading compile errors: