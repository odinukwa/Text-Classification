I recommend an approach where top level buttons, sub-buttons and content are all grouped separately. This way, these grouping wrappers can be used to scope selectors and grab all the top-level buttons into one variable b) all sub-buttons into one variable and c) all content into one variable. These grouping variables can be used to toggle off visibility for all items in that group and then the attributes can be used to toggle on specific items. Also, I've changed it so the content (lines of text) have unique selectors and the on the sub-buttons has complete selectors for their target content. This way, each sub-button doesn't have to know anything about the top-level button that toggled it. To keep track of when something is supposed to be turned off and nothing is supposed to be turned on (ie if you click the "Toggle a" button twice in a row), there are state variables for the last chosen top button and last chosen sub-button. Since this is not in a form, you might want to stick with tags. Generally, where possible, it's best to save your DOM queries. Hope this helps. 

If, and if not Additionally, there's no need to add in a comparison. The Python way of is to do Conditional ternary operator 

Database vs. Application I feel that is OK to let the database deal with this. There is a positive aspect of letting it be handled in the application: If the application deals with it, then you can reorder the elements without querying the database. However, 

Your usage of enums You are misusing your enums. I would get rid of the and methods. The enum itself is a state. I would change code that looks like this: 

An important thing here is that once is true, it will never be set to false again thanks to the short-circuiting operator. 

Note that I have gotten rid of your entire method here as I think that when you use EnumSet like this, you don't need the method. But of course you can put the relevant parts of the above code into a method. 

A few observations. Visibility Is there any special plan in declaring a public member type? It's not used in any other part of the interface. Currently its possible use is hardly anything more than for a user to maybe tell which clock is used for the chronoinitialization via std::is_same. In the meantime, is left as is, being a template argument, and it's not even typedefed anywhere inside the class. So, users cannot type something like 

You don't need to maintain separately, it is always , so can be simply declared inside the loop's body. Your boundaries check inside the loop body is redundant, loop condition alone is enough. You're probably performing too many int-to-Integer and back conversions. Even more, the question deals with arrays, you don't need to pre-convert the argument into a list. Accept, process and return an array of plain ints. 

they should remember, what the to was originally, or use . Initialization Splitting object construction and initialization in two phases is generally an antipattern (yes). In your implementation, and both provide unique ways to initialize an engine. It would make sense to add seeding-related capabilities to the constructor; and to allow for default seed value in . Overloading in its current form is too complex. A procedure whose only statement is a is likely a candidate for splitting into several overloads. Moreover, it does not allow for all the possible ways to initialize an engine. Return values Putting aside, returning...? It is ok to store the generated value for a later repeat, but to require that the user do two calls for the price of one? Really seems more helpful. People often want random values; it is much less common that they simply want to order to produce a value, and don't care for what it finally turned out to be. Too many copies For instance, is passed by-value to the constructor and then copied again into . 

The easiest, and what I also believe is the best as well, way to reduce cyclomatic complexity is to extract methods. Your method suffers from one particular code smell 

Overall, your code looks perfectly fine. A minor minor minor nitpick is that you're writing one space more than necessary here: 

Not only is it bad practice, I'd say it's horrible practice. Save yourself, or others which will be dealing with your code, some future headache and use as few static variables as possible, preferably none! (The reason why I say this is horrible could have something to do with the code I have to deal with at work, anyways, it is still not good practice...) I'd say that not using the default constructor is perfectly fine, if all your objects needs a then it's good to pass it in the constructor. Also, if this value shouldn't change then you can make it . If by disposing you mean "clearing it's state" or something, then no you don't need to. Garbage collector will take care of that. However, if you keep using the static variables then you might run into problems if you want to create another one. 

Your is very suboptimal in few aspects. I. There is no sense to check for prime factors of a number ABOVE the integral part of that number's square root. II. Aside from 2, all other prime factors of a number are odd (if any), so you only need to check at most sqrt(n)/2 numbers. III. And your recursion does not look tail-optimizable, so you'll need to either reshape it so that you get a single tail-call (if your CL implementation is aware of tail optimizations), or transform it into an iterative construct (which, I believe, are highly available in CL, much more than in Scheme). After all, you don't need to obtain a list of ALL prime factors of a number to say it's composite; and even less do you need to keep a stack frame per EACH number less that it. is less sensitive (all the recursive calls are either in a tail context, or in a tail modulo cons-one), but still you don't need to check every number less than x (remember, only up to sqrt(x) and only half of them). Additionally, concerning , doesn't CL standard library feature a primitive predicate to compare against zero, like in Scheme? 

Card class Your does not change after being set once. This makes it perfect for being set inside a constructor. This will also allow you to make it . It is a good practice to use fields whenever possible. Instead of: 

OperationClick About half of the code in this class is commented out. Why? It looks a bit like you did it one way first, and then decided to do it another way. But some of the disabled code is required by the non-disabled code. This is quite confusing. ExpressionState This is basically only boilerplate code, a wrapper for a mathematical expression. (The boilerplate part here is not necessarily your fault, Java is a very verbose language) MainActivity Again with the disabled code. This makes things very confusing for me as a reviewer. Here you are creating a object just to make it available for the garbage collector afterwards: 

You have already checked for . The string will only be null when the object's method makes it so. And instead of you can use directly. (Although that is implemented as string length