If I'm understanding your problem correctly then the problem is because your rows are not being used as records. This means that you cannot sort on them. If you want to fix this then you need to change your layout a little. Consider using this layout: 

HTML doesn't perform any number conversions like that so Im going to guess that you are opening the CSV in Excel. If this is what you are doing then you need to quote the text CSV fields (which is how you want this field to be interpreted). 

I believe that what you want to do is modify\create the CLASSPATH environment variable. This works like PATH but for Java classes and jar files. BTW, the system only looks for EXE\COM\BAT files in PATH; it won't ever find a .jar file. Full description here: $URL$ 

If you want maximum computing speed while at your competition then I'd say that it'd be worth it to create a ghost image of your system drive and put a fresh image on for the event. After, you can just restore your image and be back like nothing happened without worrying about any of it at the event. If you want the absolute fastest VM then I'd have to give that to VMware. I don't usually endorse paid apps but it is much faster (in my personal experience) than anything else. You also might want to use VMware to setup a little virtual network before the event so that you can test networking and cross platform apps quickly. Meaning that you'll want to create another image for your events and just swap them out as needed. Keep a separate partition for your projects (and any other documents you may have) so that they don't get lost. 

The simple answer is to extract each archive to a separate directory thereby giving each archive a unique namespace (eg. 1/test.log, 1/test1.log, 2/test2.log, 2/test1.log). If they must end up in the same place then you could instead prepend the archive name to each file name instead (eg. 1__test.log, 1__test1.log, 2__test2.log, 2__test1.log). This is definitely more effort though and there is still a very small chance that a name collision could occur if an archive name contains the separator character sequence (the part in my examples) which you've used. 

The trick to getting this right is to stop using the formatting controls and start using only styles. Use the formatting controls only when you are creating a new style or editing a style. Also, for the sake of productivity, it is better to just type out your content and only work with the styles at the end; all at once. It'll save you a lot of time in the end because you'll know that you did them all the same. BTW, if these documents might ever need to be converted to HTML it is especially important to get this right. Inline styles are handled ridiculously bad in Word. 

In order to keep this simple, I'd just setup a webserver anywhere the Pi can access. Then setup the Pi to run a browser full screen on start up pointing to that location. It should be very simple. The fact that on the other end you have a full featured webserver makes maintenance a breeze. Throw SSH on the Pi for sure. Also, if you are a GUI user, throw on VPN or rdesktop: 

Replace input and output with your actual IO files. I wrote a small script which can be used to test this as well: 

No, I'm sorry but if you knew the underlying arch then you wouldn't be asking this question in the first place because I've really just scratched the surface of why this will NEVER work. Do you plan to write a program which will sync the registers? The l2\l3 caches? How about one that'll ensure that each chip on your mobo is configured the same? Do you have any plan to ensure that the IRQ channels are being used identically? Or maybe you have a plan which is going to add physical components which are different between the two systems in real time? Is it going to automatically rewrite the driver software so that the same driver in memory is going to work on both machines? I'm sorry but you can't sit there and convince me that you are an expert when you haven't demonstrated that you have any awareness of (more less a way to overcome) any of these problems. I'm sure at least one of you has used a hot swap drive before? If you have then you'd know that, in addition to what I've already mentioned, the whole process of disconnecting a drive and reconnecting it somewhere else is not even close to instantaneous. My PC boots in less than 15 seconds. That's about the same amount of time it'll take to get 8GB RAM transferred to another drive; then you're going to need to add another 7-8 seconds for the actual drive swap and finally you're going to need to read all that data back into RAM on the other PC. I really think a group of IT pros should understand this stuff right away. OTOH, if you began looking at this from a perspective of solving a problem instead of inventing a new system you'd see that by using the network and changing the requirements to focus more on an actual problem you'd be able to get rid of practically ALL of the hardware issues (because others have already figured it out) and at the same time remove most of the data transfer lag (by not transferring any more data than is absolutely needed). What I'm suggesting that you do is to not try to couple the machines together like you are wanting to do because it is never going to work. That isn't because I don't have the imagination to see it; it is because it really is not possible in the slightest. Instead, you should use your network because it is designed to do exactly what you need. You only need a way to get program inputs from one machine to the other and then transfer the output back when it finishes. As long as the problem can be broken down into discreet tasks this will work very well (which are the same limitations that CUDA has in the first place so nothing has changed here). I think you don't like this plan because it is too simple and you are like me and prefer a challenge. The problem is that what you are wanting to do is beyond challenging, it is impossible to do with the equipment you have. If you really just want to make a system which works like this then it can be done. Just not with the hardware you are using. Go out and grab some commodity processors (such as those sold by Atmel or even ARM CPUs [the Raspberry Pi could work well for this]) and then design an arch from the ground up which is made to work like this. Also, when you do this, you're going to want to use RAM chips (not eeprom as is used in SSDs) because they are much faster (although, if you want it to be persistent you'd have to invent your own hybernation system which could very well use eeprom). Then you can physically wire all the CPUs to the same memory modules (meaning you'd get rid of the extra copy ops). Then it would be possible (if you can work out a good mechanism for giving each CPU it's own timeslice on the memory) but that is because you will not be trying to build it on top of another system which doesn't work this way at all. -PEACE and GL 

1890-1950 - Operation inherent to the system The very earliest computers had the equivalent of what an OS does now built into them. You (the operator) were also part of the operating system as well. You flipped the register switches (or used a punch card) and physically swapped bus wires (think of the old fashion telephone operator station) and memory was linked (via physical wires) directly with light bulb (the monitor of the day) and printers (the long term storage) in such a way that the program output would light up and print directly to the device as it was being placed into the output memory buffer. There was no driver needed for these things because (due to the way those physical wires were ran) they 'just worked' (there was also no such thing as a monitor in these days. In fact it was still going to be a few decades into this era until a digital numeric display would be invented so that you could actually see the numbers you'd already entered into the register and the output as decimal numbers; printers ruled this entire era until monitors . They were wired exactly as they needed to be to work correctly. None of this part really changed much with the switch from mechanical (1890s) to electric analogue (1910s) to digital (1930s). This 'Plug N play' architecture was replaced with the interrupt system during this time and would not resurface again until the late nineties; of course by then there'd be a lot less plugging. With interrupts, devices were allowed to take CPU time which allowed architectures which weren't directly tied to hardware but it took several generations for this to really be the streamlined process we see in x86 arch (and newer); early systems often ran into horrible race conditions, hardware compatibility\delay problems, and other odd behaviours where interrupts are concerned. Because each machine used radically different (an experimental) architectures in this period; nearly all devices were custom made for the machine they worked on. 1950-1973 - Operation within a system This era saw the advent of most of the features we think of when we talk about a true operating system. Debugging, programming languages, multi users, multi tasking, terminals, disk type drives, networking, standardization of components, etc were all introduced in this era. This time saw a giant leap towards standardization of much of this which meant that we had more standardized devices but still each OS was hand crafted for each machine which meant that OS functionality was severely limited by whatever the engineers who designed that particular system decided they needed. During this time, there was a substantial grey area in what an operating system was because the different architectures handle thing much differently and a more general purpose machine will need a lot more OS than a machine which includes hardware to handle the same jobs. The fact is that hardware is always going to be faster than software and practically anything done in software can theoretically be done in hardware (it is cost\flexibility\size\time\etc which limits us from making almost pure hardware versions of everything to this day). An OS was made for a particular computer or type of computer; it would not work elsewhere. Each new computer design needed all low level OS software to be rewritten from scratch to work with a particular machine model. Near the end of this time a new OS emerged which would soon change this paradigm, UNIX written at Bell Labs by Ken Thompson and Dennis Ritchie. 1973 - Operation between systems A single program changed all of this but it wasn't UNIX. It was the C compiler (which was famously made in a garage by Ken Thompson and Dennis Ritchie after Bell Labs cut it). Until this point, any time you wrote code it was either machine code (code that the machine directly understands but is not portable) or it was written in a language which compiled your code to byte code (code which is interpreted by another program as it runs). The huge difference for OSes that C brought with it was the ability to do what is known as cross compiling into machine code. This meant that code could be written once and compiled to run across many different machine types natively as long as a compiler had been written for that machine. Operating systems must be written in machine code because machine code is literally the only code that the machine knows. I would say that it wasn't until Ken and Dennis first compiled the UNIX kernel using a C compiler that a true OS in the modern sense was born. Before that, an OS was either a physical object or simply a pre initialized chunk of memory space designed specifically for a particular machine. Adding new devices to the system literally required that 'kernel' code to be rewritten. Now, the UNIX OS that they had designed for a particular machine could be recompiled and ran on other machines without rewriting EVERYTHING (as long as that machine was able to compile a C compiler from a bootstrap environment the rest of the OS could be written in the relatively high level C code). 

Use the Format Painter to quickly copy formatting from one thing in a document to another. Select the thing you like the look of, click Format Painter, and then click the thing you want to change to look the same. If you want to copy the formatting to more than one thing, double-click instead of single-clicking Format Painter. To exit the Format Painter, press Esc. Format Painter picks up all the formatting from your first thing, whether it’s a shape, cell, picture border, or piece of text, and applies it to the second. This way, you can spend your time getting the first thing right, and apply the same formatting wherever you want in your document with a couple of clicks. Excel