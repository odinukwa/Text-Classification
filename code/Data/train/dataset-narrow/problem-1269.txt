Instead of writing to use exceptions. There are also other means (like returning error code). But outputting to is of no use. (And seems more adequate anyway...) in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be go crazy (although it would not be infinite). Instead of that you could start with . In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. You could extract the loop fragment to separate () method which returns of given position. It would make code somewhat cleaner. And also you could reuse the method in other functions that I recommended to add (in comments above). You should first store in a local variable. Then set to . And only then the local variable. Current code uses of already deleted object and sooner or later will crash on that. I would write instead of . Feels more natural. But in the end there should be no difference. This method is badly implemented anyway. For example on a list constructed with the single element constructor calling will actually the node from but will never update member. Maybe changing the condition to (and next to ) would correct it. But since the idea of is likely wrong this method would change anyway. 

Consider having also a which uses and returns from . This would allow to iterate over object. With some template magic this could be done with single implementation. 

in loop condition is risky. Once you change to () (as commented above) for would wrap around and result in maximal positive value. The loop would be infinite. On the other hand note that alternative results in infinite loop for being already maximal positive value. (Which however seems less likely than being .) In loop use rather than . On modern compilers with integers it doesn't matter really. But it is cleaner to write so. And could make a difference if would be an iterator rather than integer. So it is better to have good habits. 

Use member initializer list instead of assigning to members in constructor's body. It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

From implementation it seems to be a cyclic list. Was this intended? I don't follow the idea behind node. I think that it is not needed. Not to mention that it's value could be undefined while it will show up during iteration. The class would be a bit more usable if you could add element at arbitrary position. Given by integer (to make your design consistent) or iterator (to be consistent with previous comment). The class would be a bit more usable if you could remove element based on iterator. Or else allow the iterator to return it's position as integer. But remove by iterator is more in line with C++ (STL) style. The class would be a bit more usable if it allowed also iteration. So should have a overload returning iterator (as commneted above). Size in C++ is usually expressed using type. So should be also positions in your case. There should be a default constructor making an empty list. 

Consider making it so that it cannot be used for conversion. Add also second argument being count of initial elements. And default it to . It would make the constructor a bit more flexible and little cost. (And also it will match typical STL container constructors.) Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. Use member initializer list instead of assigning to members in constructor's body. 

As you noted yourself your iterator differs significantly from what C++ considers and iterator. This means in particular that it will not be usable with any STL function. Or other libraries that use "normal iterators". As a side note I will mention that makes it much easier to write proper iterator. But it requires use of Boost. With your current design as it is how will you know that the iteration ended? There is no method in that says that. With your current implementation (of cyclic list - see comments in ) any iteration would be infinite unless you would count elements yourself during iteration and stop at . 

It would be cleaner if would be set to (if in C++11 or above) or / (otherwise). There should be no use for default constructor anyway. (See below notes on .) In fact use of this constructor requires type to be DefaultConstructible while there is no need to require that. 

There is no need to make public. and need it but client of your library doesn't. So consider hiding it from him. For example by defining within the class. 

Unused local variable. I would write instead of . Feels more natural. But in the end there should be no difference. You are making no check against exceeding maximal positive value for . Change argument to if you are pre-C++11. Otherwise use move semantics when constructing from . And also possibly add overload anyway. 

You should properly define copy constructor and assignment operator. Or at least forbid them (as already mentioned for ). Consider adding other constructors. For example from a range of elements of other list (by positions or by iterators). 

There are also other possible extensions. For example you could add allocator support. Or allow in-place construction of elements. But those are more advanced topics. Maybe save them for later. 

Implementation incorrectly returns value from . It seems that instead it should return value from . Return instead of as it would not require copying of the object. (But to do that you have to do the same for as commented above.) 

It could be useful to forbid copying of objects as it seems there is no use in that. To do that use if you have Boost. If you don't then either explicitly "delete" copy constructor and assignment operator (if in C++11 or above) or make them without defining them. 

Once again, very abbreviated here. I am aware of auto-implemented properties in C#, I just chose to manually implement them. Upon Object instantiation, I set everything to null. It is easier to check for null than to check for "empty" or "zero" values, in my opinion. This way when it comes time to validate an object before saving it to a database, it's very black and white --- if any field that does not allow nulls in the database is found to be null, throw an error, else continue on to save. Next up, here's what a Manager (Logic) class looks like: 

What I want to improve: Basically, everything. This whole thing feels like a really makeshift house of cards. In particular, I don't like that the page has to update once per second, particularly because the Windows mouse icon changes to loading and not loading cursors very fast. If the user knows the system and knows what's going on, then yeah big deal I guess, we can just deal with it because we know what's going on. But I think to the average user, the behavior is jarring, it feels like something might be wrong or something. Hopefully I've made it clear what I'm trying to achieve overall, so I'm open to other ideas about how to go about it. 

First off, let me say that this article pretty much changed how I program, for the better. Until I read this article, I was a spaghetti programming master --- if there were awards for crappiest, least organized, and impossible to read programming, I would have been world champion. But that article taught me to utilize classes (mind-blowing, I know), rather than just copy/paste the same logic around to the necessary pages. With that in mind, I modeled my application (described below) on the examples found in that article. I highly recommend that article for anyone else who's looking to make the jump from newb coding via facerolling on the keyboard to newb coding with some thought behind it. I've been simultaneously building upon and maintaining this web application for a year now, and I feel that while the layered approach has helped me to stay more organized, I'm not utilizing very much (if any) extra power from having layers. In my web application Project, I have a folder I created called Classes. The structure looks like this: 

The above is extremely abbreviated (for example, ClientManagement actually has about 20 Objects, 20 Managers, and 20 DBs), and there are other base folders like EmployeeManagement, InventoryManagement, etc. Each "Management" base folder corresponds to a schema in the database, so that for example, in my SQL Server database, I have [myDatabase].[ClientManagement].[Clients]. Each class in the Objects folder looks something like: 

As you can see, my web application is broken up into different layers which makes organization a breeze. But, I feel that currently I'm not utilizing the power of layers --- the logic layer does nothing at all but just forward the calls to the DB layer. I think part of my problem is that I simply don't know what I CAN do that is useful. Currently my system works and my goals are achieved. Some people might say, "then what's the problem?" And while that makes me happy (it means I've done my job with some degree of success, horray), I want to know more advanced techniques. In the article I originally linked to above, it uses the example of checking roles in the logic layer. In my case, I don't need to do that. We're checking roles pretty much on every action the user takes at the page level. If I can't figure out something else useful to do at the logic layer, I am thinking about cutting out the logic layer all together, since all it does is forward calls anyway. This would eliminate some .cs files and make it even easier to navigate/maintain. Ideas, thoughts? What can I do better? What has worked for you? Are there any things related to layered web applications that you know now that you wish you knew when you first started? 

As you can see, most of the calls to the manager/logic class are simply forwarded to the DB class. This is where I feel I could use improvement by actually doing something useful in the Manager class, I just don't know what. The Validate() method is a last resort check. There is already validation checking in each page's code behind. There really is no apparent way that you could ever reach the Validate() method in the Manager class, but it's there anyway because you never know. I've purposely chosen to have it throw a hard exception, because if somehow the user reaches that point, something is seriously wrong somewhere and needs to be addressed immediately. A DB/DataAccess class looks like this: 

Now this is something I've looked into, and while I have a "working" solution, I don't like it. Background: Through our intranet website, we want to run a process that copies a file from another machine, unzips it, and then analyzes the content. As the file is large, this takes some time (usually around 5-6 minutes). Rather than have the user just hit a Button and pray that they get a success message in 5-6 minutes, we want to show the progress via updates to a TextBox. What I've learned so far: This isn't as simple as putting everything into an UpdatePanel and updating it at various steps in the process. Seems like it would be, but it's not. I looked into threading as well, but I couldn't get it working. That is to say, I got the process to run on a separate thread, but while it was running, the interface wouldn't update. It would queue up everything, and then display it all at once, once the process finished. As I'm still relatively new, the possibility that I was just doing something wrong is high. What I have (which works, I guess...): Two .aspx pages, DatabaseChecker.aspx and Processing.aspx DatabaseChecker.aspx: 

The .aspx portion is very simple. DatabaseChecker.aspx simply has a button to begin the process, and it has Processing embedded as an iframe. The result looks like this: 

The TextBox1 in Processing.aspx is where the progress update goes. Now let me just point out the dirty trick and the part I don't like right now. In Processing.aspx, there is a meta tag to refresh the page once per second. How it works (summary): When the process starts, a Session variable called ["Running"] is set to true. When the process ends, Session["Running"] is set to false. And since Processing.aspx refreshes once per second, what happens is it saves the current contents of TextBox1.Text to another Session variable called ["TextBoxContent"]. And then the Page_Load method for Processing.aspx fills the TextBox back up with the previous content, and adds a period. So the output will begin simply looking like "Process Starting", but after 10 seconds it will look like "Process Starting.........." (one period per second). How it works (details): The process begins in DatabaseChecker.aspx's Execute button: