See here for the example I'm gonna discuss now and for more details. I'm wondering about point 3. If the packet's destination in the outer IP header set by the tunnel on R1 is , why doesn't R3 immediately get rid of the extra IP and GRE headers? Instead, R3 checks its configured tunnels to find one with source tunnel address and passes the packet there. It means that the destination tunnel address on R1 needs to match the source address on R3, and vice versa (proof by example). If they don't, R1 won't be able ping . What is a logical explanation for this requirement? Maybe I'd like the packets to take different physical paths over the tunnel, depending on the direction they are travelling (R1 to R3 or R3 to R1)? 

Pinging 172.16.0.2 from R1 probably wouldn't work, because now I have two tunnels on R1 using the same subnet (R1-R2 and R1-R3). R1 has no idea which tunnel I mean here and therefore it doesn't know the tunnel destination. 

$URL$ Let's say I have a bunch of hosts connected to a typical router (which is in fact a switch + router) that has a public global IP assigned by my ISP. The hosts use private IPs that are non-routable addresses, and need to be translated using NAT to the public one so that it can talk with the rest of Internet. Now, my router is connected to a network of my ISP. It has some IP address in that network, but that address is different than what my public IP address is, right? - it follows from the article linked above: by this command: 

Why is it necessary to configure tunnel source IP? Isn't it something R1 can figure out on its own? When pinging 172.16.0.2, it adds IP and GRE headers, and sets dst IP to - it knows it based based on the configuration above. Can't R1 simply figure the source IP on its own? R1 just checks its routing table to find out the next hop for and chooses the interface with the longest prefix match. There's no ambiguity regarding which interface it should send that packet from. 

Outbound connections are per definitions those that start with a SYN packet (or an initial UDP punch in the case of UDP) appearing at the LAN interface. Calling them "connection" in the case of NAT is a bit much; they end up simply as a temporary entry in a NAT translation table (plus whatever security/performance additions the individual NAT router might employ as well). Inbound connections do not exist in the scenario I used in the answer so far. There are of course variants of NAT that do this; for example you can statically identify a port on the WAN interface of the router with a specific IP:PORT on the LAN interface, which makes it possible to run a server inside your NATted LAN. This is also often supported by cheap consumer DSL/WLAN routers. And with "real" routers, you are obviously able to configure them in whichever form or fashion you like. Further inbound/outbound IP packets are not different from the ones given in the example. Once the initial SYN handshake has been done and the router has the entry in its translation table, it will pass through (with the same translation as explained in the example) all further packets in both directions. If, in the context of a thus established TCP connection, the server wants to send data to the client (which it is perfectly possible - TCP is bidirectional), these are just further IP packets, as far as the NAT router is concerned. It will not really care that much about the contents of those packets (i.e., whether they contain certain payloads, or are just "management" packets of TCP or whatever). At no point does the router somehow "close the tube" as you put it. Obviously, the router will have some notion of when it can clear out the entry from the translation table (probably when it notices a FIN handshake which ends the connection, or by some timeout or some error state), but from start to finish it is one continuous affair. 

In short, TCP uses up one very finite ressource, which is the number of ports on the client (which is limited by the size of the port field in the TCP header, 16 bits). So, TCP is able to run out of ports, if a client opens up a lot of TCP connections in parallel without closing them. The problem only occurs client-side, and it does not matter if the connections are with the same or different server IP addresses or server ports. In your setting, you seem to have one application which takes in many client requests (these could be individual TCP requests, as maybe your clients use this to log some events to your application and don't hold the TCP channel open inbetween), and create a new internal request to your Kafka broker (which very easily could be individual TCP connections if you chose to implement them like this). In this case, the bottleneck (in terms of ressources, not performance) would be if you manage to get huge numbers of requests at the same time from your clients (no problem for you, as on the server side you only need one port for all of them), and you open up a huge number of forward requests to your Kafka, and Kafka is not able to process them fast enough, ending up with you having more than 16bits worth of connections open concurrently. You are the own judge here; check your application and try to find out if you are connecting to Kafka with a separate request each time (maybe through some REST API proxy). If you do so, and you have huge numbers of clients, then you are certainly in danger. If you only have a handful of clients, less than 65k-ish, and/or you keep a single connection to your Kafka browser, then you'll be fine. 

It then puts the IPv6 packet inside an IPv4 packet and sets the IPv4 destination address to 10.0.2.1 - it extracts the destination address from the second address in this line, which created an entry in the routing table: . So if we didn't set the IPv6 tunnel address on R2 (), I guess it wouldn't change anything, because the packet would arrive to R2 anyway. Then why should we do it? By the way, 10.0.2.1 is a private IP address, so it shouldn't be used in a 6to4 address (only public IPs are allowed) - I think the article is wrong in this aspect. 

is not used by R2 at any point, I believe - R2 doesn't need that information. When an IPv6 host behind R1 sends a packet to an IPv6 host behind R2, the first thing that happens is R1 checks its routing table. We configured R1 in the following way: 

Does anyone know why on earth should I specify the Ipv6 address of the tunnel (last command)? The fact that I've written: 

TLDR Does it mean we need a different subnet for each tunnel? If so, shouldn't all tunnel subnets be /30? We only need two IPs for a tunnel - source and destination. 

When a packet with dst IP address arrives to R1, how does R1 know where to send it? It checks its routing table and knows that is directly connected? Anyway, it adds new IP header (dst IP set to -tunnel destination) and GRE header to that packet. When R2 receives the packet, it knows the packet was addressed to its interface and it matches the tunnel source IP address that was set up on R2. So it removes the outer IP and GRE header, leaving the packet with dst IP and routes it forward (not in this case of course, but it would if the dst IP was different). Suppose there was another router - R3. Is it possible to set up a tunnel between R1 and R3 using the same network - ? When R1 pings the tunnel interface of R2 - , how does it know how to send it there? It probably checks his own Tunnel0 configuration: oh, I should send it to , which is in the same subnet as my Tunnel0 interface . Then it checks address to learn it's . In other words, it can't directly ARP because it's not a physical connection. Let's say I add R3 with Tunnel1 interface whose public IP is . Next I configure Tunnel1 on R1: 

The basis for the decision (for any decision in a router) is a set of rules in some form or fashion. In this case, for each of the interfaces involved (i.e., the internal LAN interface vs. the external WAN/uplink interface), the administrator will have implemented rules. Those rules are quite different, i.e. the rules for a LAN interface look wildly different from those of a WAN interface. Knowing where a packet comes from and where it goes to is the bread and butter of what a router does. Let me start with an Example Wikipedia's NAT page has a lot of text on this issue, but a simple case (a simple company LAN vs. a single DSL uplink) this is what happens: 

Yes, Ethernet frames in a strict sense are only transmitted in a LAN. In a WAN, you will have other formats. 

The PC receives the packet and does not see anything about the NAT procedure. The packet looks just like if 198.51.100.20 had sent it, as if the NAT router was not there at all. 

At no point at all does the topic of a "connection" appear. The NAT router (in its simplest form) does not need to care about the content of the messages. It cares about the IP addresses and the ports of the sender and receiver, but nothing else. (Granted: this is likely skipping over all kind of security- and performance-related issues; but this is about the very basic principle like the one at hand in this question.) So how does the router know? The router does not need to know about "connections" at all. In fact, similar procedures like described for TCP exist for the connectionless UDP protocol (UDP hole punching), or could, really, be implemented for any protocol that has something like port numbers in the transport layer. The reason why the router needs to know the transport-level protocol (TCP, UDP, ...) in regards to NAT is mainly that the ports themselves are not part of IP; and ports are what makes the "hack" that (this kind of) NAT is, easily possible. So, to your question: 

When I write of "usual" here, I am thinking of your average consumer WLAN-NAT router with a sane configuration, or some simple Linux networking with default settings. As usual, this can be made as complex or complicated as necessary. As the question is very basic, this seems to make most sense to me instead of going straight for any more complicated enterprise-level NAT solutions. You have already accepted an answer, but let me try to directly address the question you asked: 

The first three VLANs allow the switch to perform routing for these three VLANs. The fourth VLAN is used for routing between the switch and the router. Through this VLAN you will need to configure a default route on the switch witch points to the router's IP address as the next hop address. Note that instead of using VLAN 100 you could issue the "no switchport" command on the switch's gi0/1 interface and use it as a layer 3 interface instead. 

In regards to graphing the information every 5 or 10 seconds, you could use monitoring software like Cacti to achieve this. References: 

If you've got access to devices like routers and switches, or a host on the same subnet as the mystery device you can easily identify it regardless of whether it has a firewall or not. Using the above mentioned devices you could monitor the VLAN's traffic and therefore identify all of the hosts on it without having to probe any of them with tools like nmap. The reason being that the mystery host would eventually send data and would therefore reveal its MAC & IP address in the process so you now know it exists even though it didn't respond to your earlier probes. Further to this, during your monitoring you would be able to keep tabs on what the mystery user is doing by viewing the contents of their network traffic (provided that it's not encrypted). This could then assist you in identifying who the user is. For example, if they use telnet you could get their username (and password, though passwords are best left alone). If the traffic was encrypted, you would still be able to view the destination IP address(es) of the sites they're visiting which you could then look up. Finally, you could also see what protocols they're using by viewing the captured traffic as well (provided that the software you're using to view the capture e.g Wireshark, has a decoder for the protocol(s) used). This shouldn't be a problem unless the mystery user has custom written the protocol. 

The last command depends on what version of IOS you're using. If you need additional information I have just published a blog post describing how to achieve what you're asking - $URL$ By the way, what exactly does the event/log say? It should really give you all the information you need. e.g if it were a MAC flap, it should tell you the ports its flapping between. If it is a physical port flap, it should tell you the exact port number. 

I like the excellent wikipedia page on TCP. It clearly shows what happens with the port number. It, by chance, also contains a helpful chapter on ressource usage: 

198.51.100.20 eventually receives the packet, notices that it is a SYN ("establish new connection") and sends a SYN-ACK message back to the sender. From its point of view, this is the IP address 203.0.113.10, with the TCP destination port of 12345. The router receives this packet on its WAN interface. The WAN interface has been configured to resolve NATted addresses like this. The router then... 

Yes. The yellow line as many switches, which, as related to the packages between the two hosts, do not have IP addresses. Modern switches can obviously have IP address of their own for their own configuration (i.e., if they offer a management web GUI). But simple household switches, even if they are rather intelligent (i.e. if they do not broadcast any and all ethernet packages on all ports, like they did in the stone age of networking), need to have no IP address at all. Remark regarding comments: this is equivalent to saying that all the switches between those hosts are part of one subnet (i.e., one IP netmask). This is, admittedly, to some extent an assumption, as these days there can be very complicated switches, and some people may even call routers switches. But still; per default I would assume that a chart labeled with switches contains switches. They may (in fact, they most certainly will) look at the IP address to make the decision on which port to send a package. But they do not introduce new IP addresses as part of the path the packet takes. 

The client PC tries to initiate a HTTP connection to an internet-based server, for example 198.51.100.20. The PC itself has a non-routed address like 192.0.2.2. The cheap DSL router has two interfaces, one internal (192.0.2.1) and an external (203.0.113.10, very likely changing often and provided through some local link protocol by the DLS provider). So the PC sends a SYN packet to 198.51.100.20:80 via its default gateway, which is 192.0.2.1. The router picks up the packet at its interface 192.0.2.1, like it also would do if there were no NAT involved at all. It has been configured to do NAT on this interface, so it proceeds to do these things: