As Josh Petrie suggested, structuring your code to use data instead of just hard coding everything is always a win. I wasn't suggesting otherwise. I was pointing out that pushing everything on the designer is not a good idea. The term "data driven design" means different things to different people, so I probably should have been more specific when I wrote the original article. At every place I've worked, we create data structures that are tweakable in engine. To make a change, we don't have to recompile the game. We can change the number dynamically at runtime. The data structures are often stored in code, but depending on who is changing them, they can easily be loaded from a "data file". Most development environments support some form of edit and continue or module reload for C/C++. Most game development studios have gameplay programmers. Their jobs is often to work with the designer in creating a fun experience. Their main concern is not technical challenges but rather crafting fun from code. I have worked as a gameplay programmer for many years, and I find this more interesting than just trying to solve technical challenges. My responsibilities have varied, but I have found my work most fulfilling when I am in charge of the implementation and I work with the designers on crafting something cool. The problem with designers coding or scripting is that programmers often have to sort out the bugs, which is one of the least fun things you can do as a programmer. What works best for a studio depends on the game. If you have a long time to make a game, and you want to give your game legs for the mod community and create something huge in scope, then making a game that is completely data driven makes sense. A lot of games don't have that goal. They have to churn out a new game in two years, and unless they have a hit franchise, it is probably a different type of game than their previous work What a "designer" does can vary from studio to studio. I've heard of a development studio that hires gameplay programmers from other studios, calls them designers, and has them script the game behavior. This sidesteps the problem of having people who aren't trained in programming coding/scripting. There should always be a delineation between game logic code and engine code. As well, you normally want to have some sort of visual editor for object placement. I've never worked at a studio where enemy locations are hard coded. They are placed in an editor. Let me propose an example of what I'm talking about. Let's say the designer thinks up an enemy. Does the designer than script the behavior of this new enemy type? That is what I consider data driven design (in terms of what Tim Moss wrote about it). In the way I am proposing, the programmer works with the designer, they make a fun enemy together perhaps with tweakable parameters, and then they are placed in the level. Native code written by a programmer is going to execute faster at runtime than a script written by a programmer, which will execute faster than a script written by someone with less technical savvy. This performance may or may not be important depending on what type of game you are making and what you are doing, but it is something to consider. You can share game code between games regardless of what method you choose. I'm not really sure what you are getting at with this point. Even if you aren't using a scripting language or visual tool to define some behaviors, you should be architecting your gameplay code into reusable components as much as you can. There will always be stuff that isn't applicable to your next game, but every place I've ever worked at, when we start the next game, we start with the codebase from the previous - even if it isn't a sequel. We then keep the stuff that makes sense and remove the game specific stuff. 

What I think you need is to create a object that will allow you to set up players position and orientation. Next, connect a object as a child of so it moves and rotates with your main object. Then connect a as the child of so it moves with , but can rotate in its own local space, so you can rotate a head. At the end connect a as a child of the and move it backward by some amount. This way a will be always at some distance from the , looking at it, regardless of the orientation. 

I'd consider a grid as a "base" type of tiles in any game. Such grid is simple to imagine and moves over this grid are simple to understand. It's also very simple to implement "under the hood". Those are few reasons why even the Chess game uses it :). Additionally, this grid helps you make "regular" levels, because and are natural directions here. So if you make, let's say a SimCity clone it's very easy to have perpendicular roads. The biggest disadvantage of grids is that they doesn't keep distances very well, because when you move by one tile in directions you basically move by one tile size, but when you move in directions like then you'll move by . It's not so big problem in computer games but it was a big flaw in board games. Because of this problem people tried to find some other way to divide 2D space, so the movements between tiles would be more similar to the real movement. It happens that the only possible way, better than squares is to use . grids are much better for strategy-like games because movements are more natural, but they are much harder to implement. They have also 3 main directions, where one of them may be OR but not both! So try to imagine a city with perpendicular roads built on a such grid... Personally, for a game like I wouldn't think much and used . In fact, I'd use squares in every game that is not a turn-based tactical game. But depending on your taste you need to choose your own. Maybe you'll want to make a one-of-its-kind, clone :) ? 

I want to make a separate landscape layout for each size of my original layout I have . I have adapted it to be able to fit multiple screen sizes: 

I am new to animations in android. I was wondering, is there a way to keep a button moving around the screen, bouncing off the walls, until it gets clicked? I was thinking to do something like this: 

And because this covers all of the 's, I don't get the option to 'Create Landscape Variationactivity_main`. So, how do I get separate landscape layouts for each already made variation of ? Thanks so much, Ruchir 

This is pretty pathetic. I have tried everything. I even tried to go into my computers bios and disable Intel xHCI. I remember when I first started android, I had this same problem, and the solution was to do something in the computer's bios, but the problem still persists. By the way, I have done lots of research on this topic, and this is a code 28, which means it doesn't have the correct drivers: 

I have been on this for 3 hours now (3 HOURS!) and would really appreciate any help. How can I get my phone recognized on my windows 8 laptop? I have done it before, so I know my phone is compatible. Is there something I need to do in the bios? Virtualization is already enabled in bios. I would really appreciate any help, and you all have my upvote. Thanks so much, Ruchir 

I think the simplest way is to divide your terrain into grid and manage which grid tiles to load/unload. Let's assume you want to have 3x3 grid all the time, with one center tile under your player, and one additional tile in each direction. Now, during every frame you check if your player has moved to another tile and if so, you load new tiles in the direction of movement and unload the tiles that are too far away. After this load/unload phase you'll still have a 3x3 grid centered over your player. I can't make you a fine picture of it now but here's some sketch: link This way you can manage quite big terrains but there're some problems you should know: Tiles connection You need to make sure that the shape of some tile at its edge is the same as the shape of its neighbor (the second tile that shares this edge) or you'll get holes in your terrain. It's quite easy if you use procedural data, like Perlin noise but it's very hard to model such meshes in 3D modelling application. Grid size and scale You can split your grid into 3x3 or even 10x10 tiles. Every tile can be few meters in size or i.e. 1km - all this depends on your specific needs. If you manage many small tiles your load/unload times will be smaller but you'll do it more often. Additionally, when you make game like a flight simulator you'll need different setup than for FPS. Deferred loading It's not a 'problem' but I've seen some interesting optimisation that I could share. It was in the Terrain Manager for the Ogre engine. It was also grid-based but much more complicated, with Quad-Trees, LOD, tile stitching, etc. The trick was done during load/unload phase, where instead of checking they checked then the Manager loaded only this one tile and returned control to the engine. In the next frame Manager did the same check and loaded 1 another tile. In this simple way you can split your loading into multiple frames, which lowers your FPS variations. 

In order to test out my game, I need to use my real life device. The problem is, android studio isn't recognizing my device plugged in: The problem: My device isn't getting detected in android studio The solution: Install the correct usb drivers The problem that arises to the solution: I am not able to...and here are the details: I have recently system wiped my computer due to slowness. This brings me back to the tedious task of setting up my computer for android studio. I have tried everything to get the usb drivers to work in android studio, but for some reason, I can't update my usb driver: 

Now, I want to create a landscape layout for each different screen size. The android docs and many (Many!) stack overflow pages suggest to do something like this to create a new landscape layout: 

But after doing this, I create a landscape layout for all of the activity_main.xml's I need a separate landscape for the large , the small , the xlarge , and the normal . By doing the method described everywhere, I end up with this: