I think you have created an unuseful abstraction. Mostly your methods only calling the underlaying MemoryCache instance and you have created something weird: IDisposable wrapper over a static instance. Of yourse the MemoryCache can be disposed but not this way. You have a service with InstanceContextMode.Single then you should only call dispose or provide oppurtunity to call the Dispose method when your service stops. Insted of your wrapper i would create some extension method for the typed get/remove logic wrappings: 

Model classes Model classes should not have any hard dependency in their constructors especially not a PDO or similar stuff. Model can not have any business rule they are containing only data and that's all. Ofcourse if you have some mapping between model classes (Author <--> Books) then some of the relation informations have to be in the model (Mediator!) classes but that's all. Model classes should not have any knowledge about their storage type. It can be anything not just az SQL database handled with PDO. They can not have self managed CRUD methods (if they does then they become Active Record(s) which is a really bad thing (~God object), antipattern) (maybe factory methods are okay but these methods also can not have anything heavy (query database through a horrible static global accessible thing) inside). CRUD Mapped entities should have some kind of top level storage (like in .NET an ObjectContext) which is dealing the storage problem; handling SQL connections and providing transaction capabilities with an Unit of Work (Commit, Rollback) solution. The top level storage can have for example mapped SQL tables for querying from the underlaying storage, inserting into it, deleting from it. Other thing is that this top level storage is the responsible to track the changes in the entities. Of course we have to put some stuff in every model in the system (Mediator #2!) to handle this session but the main logic still in a state manager not in the models. Repository Repositories are tricky. With powerful ORM systems we can forget them if the business logic doesn't require another application level. What should a repository contain? Add, Delete, Query methods but no Save() or anything else (not even named query methods like: GetUserByEmailAddress($email)). You can use DAO classes for named queries which are operating one or more repository or on the entire object tree. Do not forget: not every entity has a repository! Only aggregate roots can have repository, for example: an Order model can have a repo but an OrderDetail can not becouse it belongs to an Order model and can not exists whithout it. Static In your example your are using in static context object which are containing state (your repository stuff) information which is bad. You will introduce a global state whith them which will bring more harm to your code then good (global hyperspace is inreliable, anyone can modify it). 

need a collection of rules, call RouteTable (will store Route instances) rule: how to translate an url to a usefull address in the framwork (how to get named parameters like controller or action and so on) the Router it self which is containing the logic 

Dependency injection $objShowPDO = new mShowPDO(); is bad a mShowPDO instance should by injected via method or constructor argument see dependency injection topics 

If the correct route has been found my routing engine returns it to the other parts of the framework but not just the pure route but mapped all the values came from the request. If nothing has found i face with an exception. The way i see the router above does nearly nothing compared to a real router but do things what should not be done by it. Beside this it's unflexible (fixed array indexes, has a hard dependency on a Config class and a default controller (why?)). 

ordering the available routes: by the static parts (fix parameters not pattern elements ({})) and by the constraints (in a route i can set up constraint like the id onyle can be in the range of 0-5) [static length descending, constraints' numbers descending] iterating through the ordered rules collection and trying to find out which one will be the first mach by using regular expression (the Route contains it's pattern translated into regular expression), if a match found i try to fill the pattern with data; if everything is in place i've founded otherwise continuing the search. 

Your code In your code you are hard coding things when you are using the new operator in your classes, to avoid this use dependency injection as i did. Your SoapGet class has 3 responsibilities: checking credentials, connecting and executing calls, do this is separate classes: one class for validating the credentials, injecting the SoapClient instance and then SoapGet can execute the requests. Hard coding Never fix parameters like connection data, parameter names in "generic" classes! Exception handling 

This is a cleaner version of your code with less query (the first was unneccesary) and inside the loop you are making a lot of small query which can be really bad but first you have to modify your code to not work directly with the context in you page code but through an interface (first iterate through the rows and get all data then pass them to the worker (which can work with the context) and return the result & update the UI). 

Hard coding The checklists are really hard coded (long if with OR relations), try use some container for them (an array and use in_array() for example). 

And you don't have to check for collisons becouse it has a really small chance to have two identical Guid generated with openssl_random_pseudo_bytes(). The only thing you have to have is a PHP installation with version 5.3.0 or higher but it's recommended anyway to have the most recent PHP version (now 5.5.7). 

I would create at least a simple Event class to keep clean the code. The example above is a very simple one but if you have 5 more minutes for this you can create a DatabaseEvent class which have a Subscribe method what is expecting an IDatabaseEventHandler "interface instance" as parameter (public function Subscribe(IDatabaseEventHandler $handler)) which has a few or a lot of methods: LogConnectionError($arg), LogQueryError(QueryErrorArgument $arg) and so on. Whith this approach you will need an adapter class as a default interface implementation of the IDatabaseEventHandler for easier usage (for example when you are writing your unit tests). Of course the DatabaseEvent class have to have a lot of named log methods to call the subscribed handlers when it's neccessary. 

Yes Yes it belong s to the controller. If you are interacting with HTTP... stuff then you should do it in your MVC tier in your N-tier application stack. If you would put this thing in the model then it would be in your business logic and then you would have a hard dependency on the HttpContext which is bad becouse what would happen if you would create a WCF service endpoint for your business logic? MVC tier is just an public service interface which is communication with the users on HTTP channel nothing more. If you don't have an N-tier design in your app then you should get start to clean up your solution and put things were they belong. 

This is from my library it's similar to the other solutions but it's using a little hack: the array_key_exists() is a slow function so i execute first an isset() 'function' and if it's says "yes, it exists" then i don't have to execute the array_key_exists() function. The reason why isset() is not enough is the isset() will return FALSE if the key exists but the value is NULL. 

Wellcome in C# land! You are trying to implement a dynamic array or something like that so why not to a List or another collection like Collection. These are dynamic sizeable no need to worry about size/space handling. In C# do not be an array-oriented coder feel free to use other powerfull collections. 

You can't find the correct answer until your code is just a bunch simple PHP scripts. The ultimate solution would be is to use a dependency injection container and resolver where sou can say for example a PDO instance to keep in use until the request ends (in PHP this would be a singleton behavior). If you can't rewrite your whole system to have an object oriented design to have the ability to use a DI container then the only thing you could do is to create a class loader in your bootstrap section to load a factory. A Factory is a simple class which can build object instances like a DatabaseFactory::CreateNewConnection would return a new PDO instance. You can create a static factory but that would be as flexible as the pig-iron. A recommend you to have a static DatabaseBuilder class there you can register a DatabaseFactory class instance as the default database factory and your factory can hold a database class instance until the request ends. Here is the skeleton: 

After this you only have to iterate throught the $data array and execute paramtrized INSERT SQL commands. 

Refactoring to class With object oriented view we can build a class to solve this problem what kind of problems we have to deal with: 

In this way you have no string dependency to a SQL database to query user you can have for example an in memory store for users if you want to test the Auth class. Echo or return? Neither Currently you are echoing text from a business logic layer which is bad really bad. Only in the presentation layer should be print out stuff to the end user. The return would not be the solution for this becouse you can't tell what was the Auth process result (only from the message) so create a result class: 

Question #1 No. You do not need to ref the connection object in your methods' parameters - think object oriented way not class oriented. Question #2 The only way is to make this as a non static class. Avoid always statics when the current problem contains some kind of state management like a MySQL connection. Question #3 No you don't but you should implement the IDisposable interface and apply the correct disposable pattern. 

Ofcourse as you can se you have to create a decent way to set the connection properties for your database. 

Stored procedure The query above is enough big to move it from the application layer to the database in the form of a stored procedure. It will be clearer and faster, the only disadvantage is that an SP has a hard dependency on the database type (MySQL, MSSQL, other). Return value(s) You are returning 3 types in your method: null, integer and boolean. Keep your logic clean, and return always one type if you can (yes, PHP has it's type juggling "issue" but still, clean code talks). 

From the IP validation point of view null or empty IP addresses are exceptional actions so you can not say that two null or empty strings are the same IP addresses becouse they aren't IP addresses and sometimes not even strings. And you don't have to sorrund the logic with try-catch block becouse it will eat usefull information when things will get ugly. If you don't want to deal with parsing exception then use IPAddress.TryParse it will be faster becouse throwing an exception is always a heavy weight stuff (check it with profiler). 

Then you have to clear your SQL statements becouse you are running to much query against the database while you can fatch all data with only 2 query. SQL First the companions: 

Multiple problems Why is static? Why is the database hardcoded in the class? Echo or return? Neither Exit? Direct $_SESSION write (super global) HTTP stuff in an Auth class? Why is static? You are using stuffs in static where you should not have. Handling database through a static proxy? Untestable, unreadable and what happens if some forget initialize it? Same thing applies to your class which is handling the authentacation. Why is it static? If you wan't to access it whereever you want then create a static facade class and keep the main logic in a separated non-static class. Why is the database hardcoded in the class? What happens if you don't want to use anymore a standard SQL database to store your users? You will rewrite the whole class to achive that? If you create a new class as i described above leave out this hardcoding use constructor injection instead: 

DO NOT LOCK ON EMPTY STRING In .NET every string is stored only once in the AppDomain so if you are locking on empty string everything will stop until you release the lock. The correct syncroot can be: 

And yes you should use double check locking. The other thing is thati would use a ConcurrentQueue instead of SynchronizedCollection.