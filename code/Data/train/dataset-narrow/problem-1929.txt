Here, since Anonymous was in the BCC, the message sent to Jane Doe did not include the BCC recipient list. Because of the BCC convention, the email envelope may not include recipients that actually received the message, and it may also include recipients that do not appear in the message headers. As mentioned by @JonasWielicki, which I also meant to include, is that the MUA (Mail User Agent) is typically responsible for sending the multiple emails that are required to implement BCC. Email servers do not know anything about BCC, and so the MUA must implement BCC by sending multiple emails with different email routes specified in the envelope headers. For this reason, BCCs typically take longer to send than normal emails, because different message bodies must be constructed and sent out individually. This also helps with some email compliance rules. For example, a mail server may have rules configured to automatically BCC an archive email server (all emails sent to it are also archived), in which case the mail server might not even be a real recipient. 

The answer is... Maybe. In the old days, you almost certainly had to set up such a configuration yourself. Modern, off-the-shelf Wi-Fi modems can do all of this in one unit. Independent guest zone with AP isolation, for example, practically fits all your requirements, and you can buy it for less than $200. My Linksys offers this, and ran me about $120, if memory serves. Of course, if you're using older hardware, or just want a challenge, as I often do, I'd say go for it, have fun. Your NAS can be on the private AP node, shaped across trusted devices, with guests unable to see it, but use the Internet. Only one modern router is necessary, and will probably reduce contention over using multiple devices. 

Every program runs in its' own virtual memory space. These are allocated in 1MB chunks as the program requests memory from the OS. The programs see this memory as one large, contiguous block of memory (the so-called "flat memory model."). This was different than the older 16-bit model "segmented memory" model, where two registers would combine into a single 20- or 32-bit memory address, depending on the memory controller's current operating mode. Each 32-bit program will be limited to 2GB of total usable memory; the memory area starting at 0x20000000 is used for DLLs in 32-bit applications. It is true that a single individual 32-bit app will not be able to access all 16GB of memory, because it's not all addressable. However, each program starts near the bottom of its virtual memory block (close to 0x00000000), and those are offset by the virtual memory manager to the actual physical location in RAM, so in that sense, the 32-bit program can reside anywhere in physical memory. Conceptually, this means that you could fill all 16GB of RAM with nothing but 32-bit programs. Both 32- and 64-bit apps can run side by side, and be located anywhere in RAM. Note that paging happens before memory is exhausted, so it is still unlikely you could run 16 1GB RAM apps without paging happening. The system tries to keep some physical memory free, and also uses that as a cache for disk reads and writes. Note that even 32-bit OSs can access more than 4GB of memory, although each individual app is still limited to 4GB. This is because of a relatively old technology known as PAE (Physical Address Extension). 32-bit Windows doesn't let you access memory above 2GB/4GB as a matter of licensing, but 32-bit versions of Linux would happily run on a 16GB system with full access to the memory installed. Some 32-bit versions of Windows Server could also access more than 4GB of memory: "Windows Server 2008 Datacenter" could use up to 64GB of RAM on a 32-bit processor. 

Now, in this case, Anonymous was sent a message about this meeting. However, this version of the mail was not routed to Jane Doe; she knows nothing about Anonymous being notified. In contrast, Jane Doe will be sent the message with a different body and header: 

Drives are organized into clusters. Each cluster is some multiple of a hard drive sector (512 bytes). Initially, a directory is one cluster size big (e.g. 4,096 bytes). Even if there's just one file in the directory, the directory will show up as 4,096 bytes. Larger directories, containing many files, might be 8,192 bytes, 16,384 bytes, etc. Linux, like every other system out there, can only allocate in cluster sizes. This is an efficiency that allows smaller inode tables at the expense of some loss of usable space. For example, a text file with the letter "a" in it also takes up 4,096 bytes on the drive. An inode is basically an alias for a cluster. 

Yes, from Windows 7 and onward, you'll find that most (if not all) OEM installs of Windows have the Product Key burned in to the motherboard, which will be automatically read by Windows during installation and activation. However, you'll still need to get as far as installing a fresh copy of Windows 7. One easy way to do this is to contact your manufacturer. Go to their website and contact their support team. They will typically be able to provide a link to an installer that typically includes any custom drivers you'll need, or you can purchase a CD/DVD disc from them. Microsoft allows you to reinstall Windows 7 using the Download Windows 7 Disc Images page, but you'll need your product key first. You should be able to use NirSoft's Produkey to recover your key, then download the ISO from the Microsoft site, then nuke your hard drive and reinstall from a USB stick or disc. A simple search on your favorite search engine should also yield results for recovering the key using a PowerShell script or something similar. As a last resort, you might borrow a Windows installer disc from a friend, if anyone has one laying around. The installer is only concerned about your key being valid, which should be the case if it's pre-installed on your laptop. I would recommend not doing this if you can get a disc from the manufacturer or directly from Microsoft, if only because the disc you borrow might not be compatible. If you go through the installation process and you're asked for a product key, you've installed the wrong version. Finally, instead of doing a full nuke, try pressing F5 or F8 when the computer initially boots up, and in the boot menu, choose the Recovery partition. This is typically an area provided by OEM installs that contains a copy of the Windows installer you can use to reinstall Windows, without needing to nuke the system. You can delete the primary partition during the reinstall process if you'd like. Nuking is rarely necessary from Windows 7 onward. 

Basically, no. Using your Google login on both devices will have them sync, such as sharing tabs, etc. Use a different login for each, or simply choose not to sync. 

tl;dr at bottom. The SMTP protocol doesn't have the notion of CC or BCC recipients; this is a convention held by mail clients. The SMTP server only typically cares about routing information and data. This is an important distinction, because without this capability, BCC could not exist. As a legitimate BCC communication consider the following client transcript: 

When hardware is failing, it can cause a number of symptoms. The most likely is a Blue Screen of Death, but lesser symptoms can just as easily appear. To get a better idea of how apparently unrelated programs can be affected by hardware, consider the operating system model: User Software > Kernel > Hardware Abstraction Layer > Hardware Any program that wants to interact with literally any resource, even the CPU or RAM, has to cooperate with the kernel, which in turn depends on the HAL to translate the various physical signals to and from the hardware into logical signals to and from the kernel. The kernel has certain restrictions in place to "guarantee" stability, such as the limited ability to be re-entrant, thread safety, resource limitations, and so on. Particularly, most hardware does not have the concept of being shared; this is abstracted at a higher level through the HAL or kernel drivers. If you remember from the days of modems, only one program at a time could use the modem, such as dialer. The Internet got around this by producing a common stack-- all programs wanting to access the Internet did so through a common stack, and that one stack had exclusive control of the hardware. The stack produced multiplexing to share this one resource. Even today, sound cards, disk drives, video cards, and so on can't be shared physically. The signals would get confused, and chaos would ensue. The HAL does a pretty good job of tricking users into thinking there's actually more than one thing going on at a time. There's still a physical bottleneck that is place, but we typically don't notice it when hardware is working the way its intended to. But, to get to the core of the problem, if the HAL has a problem communicating with a device, it can become blocked while it attempts to resend or reread the data over and over again. The HAL is also typically not multithreaded, so it can only handle one request at a time (per driver chain). If the disk driver is locked up try to read a bad drive, for example, any other program that tries to make a similar API call will be in the queue behind the blocked call, resulting in that program potentially hanging. Multi-threaded programs wouldn't have this problem, because the UI could remain responsive while the drive was locked up. Unfortunately, most programs are not multithreaded. Many programs in Windows basically go into a loop, like this: 

Yes, you can do this in a normal batch file (note: you might need elevated privileges to run the script). The basic process might look like this: 

At this point, the GPT or UEFI structures at the beginning of the drive will be zeroed out, and the computer will not be able boot at all, as if the hard drive were brand new (though there will be bits and pieces of the OS scattered throughout the rest of the drive). It's important to note that the OS is not installed on the computer, it's installed on the hard drive. You can move the hard drive from one computer to another and the OS may run on the new hardware. Note that using the command above will render the drive unusable in any computer until it is formatted. NOTE: Make sure you check the location of the hard drive before using the command. Not all Linux systems will map the hard drive to /dev/sda. You can use the lsblk command to verify the device that the hard drive is mapped to. (Thanks to @HSchmale for the comment). 

Here, the recipient is another party that is completely undisclosed to any of the recipients or even the sender. This is a feature of the protocol, typically used in relaying or archiving messages. What this spam message did is take advantage of that behavior. It's a standard loophole that technically should work with any compliant mail server. Of course, many updated servers use "extensions" like DKIM to verify that such an email is authentic, but there are still many old mail servers out there that don't care, simply because it's tempting to not fix things that are not broken. Also note how I've specified a Date header. This can be any arbitrary (but well-formatted) value; many clients will happily display any legal date range from the distant past to the far future. I have personally sent an email to myself years ago that will remain at the top of my mail box long after my life expectancy, as well as an email that predates my email account and my own birth. tl;dr So, in summary, the sender spoofed an email, the originating mail server accepted/relayed it, your email server accepted it and stored it in your inbox, and your client faithfully displayed the data that was in your inbox to you, all without circumventing any security. "Sending" security is often much less restricted than "receiving" security in that perspective, since POP3 almost always requires a username and password before you can access a mail box (you could theoretically circumvent this, but I don't know of any legitimate mail services that do). 

If you were interested in trying your hand at writing your own code, however, you're free to do so. This is a benefit of using Linux. The keyboard uses a microprocessor that can be programmed via the CPU. On really old systems, the BIOS does this, and on newer systems, the OS does this, but either way, with a bit of work, you can write code that does this, too. The general theory is that you'd want to watch for HDD activity and modify the keyboard status bits as appropriate. In that sense, if you're so inclined, it would certainly be "possible" to use the keyboard status lights as an HDD status light--if you're willing to put forth the effort needed to learn systems programming. 

I would have to guess that the file's name is probably encoded in a way that might be challenging to find, possibly using a binary value instead of a string value. I would personally recommend CCleaner's registry cleaner feature, which finds invalid registry entries, and cleans them up for you. There are other tools out there that do this as well, but since I usually look for the least expensive solution, which in this case, is free, CCleaner is usually the first tool I turn to when I need to fix registry errors involving missing DLL files, etc. (Disclaimer: I am not, nor have ever, been employed or affiliated with piriform, I just like their software.) (Note: This assumes you have successfully removed the malware. Make sure you've used a malware scanner first, because CCleaner doesn't do that.) 

As you might guess, there's only one thread. Once it tries to read from a drive that's hung, it can't recover until the drive eventually times out. If it doesn't, that program is at the mercy of the OS's API. Even if it were multi-threaded, though, the drive-reading thread would become locked, although the UI thread would be able to detect this and recover/abort. To compound the issue, many API calls, such as those that allocate memory, open drives or files, etc, are all blocking calls. They cause the current thread to wait indefinitely (unless it requests a specific timeout value) until the OS can complete the request or aborts it due to a timeout. Most programs don't assume that the OS will take very long, and so never specify a timeout. Those programs will never recover if the drive doesn't respond. For a program that "never accesses the failing drive," it doesn't necessarily have to. All it needs to do is call a function that's currently blocked by the bad drive. For example, if OpenFile was called on the bad DVD drive, then other file requests might become hung until the DVD drive times out, even if they were only reading from the system drive. Maybe the program calls GetOpenFileName, which shows an OS-rendered dialog that assumes control of the thread until it returns. That window lists all drives on the system by enumerating the list of drives. If the API is hung on a bad drive, the end result is the same: the dialog box is frozen, freezing the entire application, waiting for this drive to become available/free.