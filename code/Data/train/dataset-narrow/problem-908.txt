One thing you could consider doing is following the approach set out by @Flambino with different objects. You could start with a object that you can decorate with additional methods or even override existing methods with new definitions (see Javascript Decorator pattern at: $URL$ Here's a really crude/untested example of what I'm getting at: 

I have a similar session manager class in my MVC framework, and while I have absolutely nothing against Singletons (I apply the pattern where it makes sense, e.g. factories); I never felt that it made sense to use the pattern with my class. If your goal was to prevent the object instance from being copied/cloned (by design or accidentally) you could opt for a regular ole' class and use to prevent the object instance from being cloned. Using was more legible (for me) than using or especially where referencing/calling class members/methods was concerned. 

As for your actual widgets, I think you might need to spend a little more time looking at implementations of the JS Design patterns you're using--and not because what you have is wrong, but I found it really cumbersome to follow. Here's a couple sources that really helped me when I was developing my own system: 

I'd also suggest removing fields at all from the test class and create instances of only in the methods that need to use this object. Calls like should be avoided, because they lack explicitness when there are test failures. It is more expressive when reformulated as , or even with an explanation/details message. If there is no way to avoid , like in , there should be an explanation message, for example: 

vs The call in the block of look really heavy, especially with a single-case matcher. As per Scaladoc, is the same as . In general, is used hugely and easier to read: 

is suspicious. Not only it returns a tuple containing another tuple, but also it looks like the purpose of the is to show if the return object contains data or marks a missing value, according to : . Scala has a dedicated type for that: 

For the current condition, this means that 0.5 < h < 1.0 and 0 <= t <= 0.5. 0.5 is not included in the lower bound for generation of values, which favors very slightly. The condition for equal distribution should be . 

I was reading about opaque pointers and decided to try it with queues. Please review my code and let me know if there are any errors and how to improve code quality and performance. It uses lines to enqueue and dequeue. All lines have fixed sizes and dequeue/enqueue never share a line. New lines are added only when all lines are full, not counting the dequeue line. The lines are stored in a linked list. queue.h 

I found myself writing code to run at a specified frequency more than once, so I decided to make this simple timer. My main concern is that this is not the most efficient way of doing this since with I would just ask for the time in ms and sleep in ms. I'm storing the current time in to avoid the possibility of it becoming greater than the final time and generating a huge pause since it's unsigned. Usage is pretty simple, is called once before the loop and is called once at the end of every iteration. timer.h 

Bug or Feature? is created with a , which makes the pane almost identical with . However, the aim of is to receive only 'Yes' or 'No' from the user and the text input field will disturb its user. How could it appear there? It looks like there was some copy-pasting! Duplicate Code Many, many items are present in more than one class: most of constants, and and objects initialization. Since they are common for the three classes, they may be easily extracted into something like . The constants will be moved there directly. instances may be created with its dedicated method: 

The strings redundantly repeat the literals. or will produce the same, so there is no need to add field. Now, after all the refactoring applied since the initial question, let's try to approach the design a bit differently, with the aim of simplifying the thing. In the reviewed solution there is an array to store symbols as strings () and enums per each chemical element (, ...), each wrapping data for nuclides. However, the core notion of this system is the chemical element, with a few constant values for different nuclides (symbol, atomic number) and with other fields varying. So why not creating a single that holds constant properties for each chemical element, used as prototype to initialize a for any of them? This could look like follows: 

I just wrote this pool to avoid calling and when I have some code that frequently allocates and deallocates chunks of same-sized memory. I would like to know if there are any bugs I didn't notice and what would be the best solution to achieve this goal. I'm using some small functions that aren't really required because I find the abstraction nice when using the code later and because I noticed the compiler will optimize them away when link-time optimization is turned on. I'm using about the same code I posted before for the stack. 

I'm using these 2 functions to handle file input/output and would like to know if there's anything that should be changed. For content retrieval, enough space is allocated and the file content is copied. To make sure saving a file either saves all or nothing, I'm writing to a buffer then renaming it after all content is successfully written. I'm particularly interested in knowing whether these functions are safe or not since is considered dangerous. I read the main risk is a file with the name returned by being created before we are able to do it, so I'm using to make sure it doesn't happen. Is this enough or there are other security concerns that I'm not aware of? files.h 

@naikus, Bill Barry's point is rather accurate -- chainable methods are for convenience rather than convention. You can structure your method calls either way, though the chaining helps with expressiveness in your code (readability is up to the developer.) So, no--I wouldn't do away with chaining unless you absolutely want or need to for some reason. As for your second question, I'd be in favour of your first approach for a couple reasons: 

Personally, I'd refactor this and wrap it into a module or plugin (same thing in jQuery land.) This approach let's you take advantage of jQuery's event bindings while providing you with the ability to consistently apply different types of validators to the types of elements/data you want to validate. You may still want to map fields to validators types, or use the data-attribute, e.g. to specify which validator gets applied (this can be done in a single validate() method or you can handle it during serialization of your data if you're using AJAX... or hook the submit event on your form.) 

BUT! Indeed, there is no need to keep the function. The calls between it and introduce too much of complexity. The problem here are the parenthesis for and it can be solved by making a distinction between the root level of the expression (where they are not necessary) and all levels below it (where they are to insert). So an ordinary recursion and an additional boolean parameter to check for the root level will do the job: 

Of course, this block can be shortened to two lines only, but it will be less readable. Since it is not clear how to process lists that do not start with '1', a generic matcher with an explicit exception can be added: 

Here are some formal remarks that do not concern the design choices made in the code. Unnecessary Code All the repeated functions like 

The number may also be extracted into a vairable. Draw a Rectangle If I'm not mistaken, with you are trying to draw a rectangle. It may be replaced with the respective method call, thus reducing the stuff to a single line: 

Legibility -- far easier to read, and honestly, far more flexible. Maintainability -- the pattern can be extended to make use of a factory if you want, and still have the benefits of being legible and maintainable. 

This base module is my starting point for my plugins. is a reference to a parent object, e.g. to keep things as self contained as possible. The example module illustrates dependency injection ( and the objects), which I fall back to when dependencies like are already a mainstay in the project; however, you could limit this to simply, . I also make use of an module (observer pattern) to deal global state handling, but bubbling up events through callbacks etc, is still possible. It's easy enough to create a method or object similar to jQuery UI's widget factory, or to go the common plugin route and extend. All this to say, I would favour a simpler approach to encapsulation and extendability. 

jQuery's plugin system is quite flexible. It's use of a module pattern gives developers the ability to declare public and private members/methods. My own module system is heavily inspired by it: