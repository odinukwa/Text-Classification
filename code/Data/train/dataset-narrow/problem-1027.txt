I would also change to a normal class without title and a lazy field. About the and the , they seem to be the very related. It seems you can construct an instance from an , this would make the an ideal candidate for the factory of . Such a factory is commonly at the companion object. Note that I would personally introduce a case class for document. 

Note that for the implementation of the implementation of (without title) makes things a bit tricky. For that reason I would add a relation in the document space, either with a or a pair. This would result in to be a map . As a result it would remove the call in which could then be renamed to allowing you to remove the comment. The two most common errors by Scala developers are the usage of on options and on futures. The only place these methods are allowed to be used is in test code. If have (to date) not found a valid usecase for either one in production code. There is a small problem in your method: is an integer and thus could result in . In the (and to some extend in the ) you have mixed statements in your code. As a separation of concerns those should be moved out of the code performing the operations. The functional programming paradigm is really strict in this sense and some of their patterns can help you to do that. The book Functional programming in Scala contains a section about this exact problem. Note that I would personally keep the statements in the app constructor and only remove the ones from the document loader (which I would place in a different class). As with all things, always search for a balance between effort and 'ideal world perfection'. 

For the line and the line are connected. will throw an exception if it is not guarded by . This is a simple example. In more complex cases the maintainer of your code might move some pieces around accidentally breaking the code. If we apply that to splitting the documents into the two datastructures it would look like this: 

Yes this doesn't do all the type checks that you do above but why do you need them? Now let me be clear It is possible to expose an XSS vulnerability for your users here Specifically if you allow users to enter values which are posted back, persisted on the server, downloaded by other users, and then used with this function on their computers. Suppose you are doing binding to objects which users can customize. These can be arbitrarily nested so you use this pattern. You also have summary screens in which users can view other users' customizations. All an attacker has to do is create a property named and it will be eval'ed and run on the machines of other users of the system. That's the danger. If you're aware of it and make sure that condition never happens, feel free to use the with-eval. 

where your clicker span gets a class of and your gets the class of . You could just use directly, but I find to be somewhat more descriptive. 

Usually I see tuples in js implemented with arrays though of course an object - while annoying to write would be just as valid: . So for this sort of use-case (creation and light usage of a bunch of temporary objects) I'm curious if there's a significant performance difference so I set up this jsperf. Object tuple test: 

I'm getting more and more into programming js in a functional manner which makes heavy use of multiple returns via tuples (especially useful with recursion). Also, a pattern that I use often is creating simple temporary values for projections 

It's not really a problem, and I like to gently prod newcomers into learning features like lambdas. That being said, I don't think that your url duplication int the first case is anti-dry, its a perfectly acceptable method extraction and it's private. Within the scope of private methods you can do pretty much whatever you like and it's not going to offend anyone too much. Another possibility that you might consider (though it would be a greater scope) would be to extension method the url so you can do url.ConfigureUriVariable("foo", "bar"). The above would be a bit clearer if instead of a string you used a dedicated Url class. I recommend the built in Uri or make your own. But really, I think you're all good. BTW - the lambda is still compiled to a delegate so the generated CL is pretty similar using either of your techniques. 

The type is now modelled as a tuple. I would recommend a case class for it. That allows you have the code in search be more readable. 

I recommend the same structure for classes: public (and most important) members at the top. Then (in usage order) the other members. This is ofcourse personal preference. In some cases it's not needed to specify a type. For public facing members it's good practice to write down the full type. For private (and function local) members it's not needed and might actually introduce noise that harms readability. I noticed you are using and a lot. I try to not use them as they require the reader to backtrack to find the type of the tuple that contains them. There are a few techniques you can use to avoid their usage. 

With a case class you say: this class is defined by it's values. With a Traversable you say: this class is defined by it's contents. To me that is a bit confusing, is it about the parameters passed in, or about the contents? 

To me it's unclear why the method contains the code it does. It seems the code could also be in the class. Or, the other way around, the code for analysis could be in the factory (or another class). I would not use mutable structures to split the document space and documents containing a word, this is more sensitive to programming mistakes. On top of that it disconnects two pieces of code that are connected, forcing our brains to do more work. A simplified example using option: 

You don't bother users of your class (yourself) with the internal details It allows you to easily identify which members can be safely refactored 

It seems there is a clear relation between a and a , it seems reasonable to expect a factory method. 

A few general notes I recommend you to reverse the general order of your code. Most important (or less detailed stuff) at the top. It's easier for readers to zoom in and see the important (public facing) bits. So if you have a program in a single file, put the App on top. Within the app, put the stuff that actually does something at the top of the file. I now have to scroll down and skip a lot of noise before I get to the actual stuff that is being done. 

Ok, so I just recently arrived at a way of doing this sort of thing that I actually like so let me share. In my opinion, the if statements aren't really the problem, its more that they are not really pertinent to controller code. Actions should strive to contain code only about major decisions of what code path will be executed. Solution: You take advantage of the fact that a Linq query returns an IQueryable to store the query logic along with the model and an extension method to give it a nice DSL like interface. Similar to the pipes and filters pattern. This is what the action is going to look like: 

While this is the simplest and is certainly acceptable architecture it is always a good idea to also consider Composition over Inheritance So instead you might do something like 

I realize that a service and some sort of inter-process communication (whether windows inter-process communication, HTTP, or something else) is more standard and reliable but I have a frequently changing team and don't want to add another step that is necessary to run the app. This seems to work but I've only launched it in a dev scenario. Am I missing anything that would cause problems in production? That's a System.Threading.Timer by the way. 

Since this is a public method I added some checks and downcast List to IEnumerable, which is a looser contract and all you really need here. By the way, .Net naming conventions are pascalCase for private and local variables CamelCase for public and protected. It's rare to use underscores. 

In other words, this methodology is good for idempotent, non-mandatory tasks such as "clean up the temp directory" or "remove any unused profile images from the file system" 

A few limitations that I've discovered since then. This will work. However, it is subject to all the Asp.Net (currently 4.5) limitations. 

Or for the totally and absolute 1337 (meaning you shouldn't do it for something this simple but it demonstrates some useful techniques)