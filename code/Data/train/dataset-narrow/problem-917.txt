Some notes on regular expressions Note also that your original regexp where somewhat flaky, that is when you test against which you used for and , this matches a string starting with , but it can continue with whatever, so both and would match it! In the new variant I've used to match any combination of digits, 'a-f' and period , which is a loose translation of an ip-address. I further used to name the groups, which isn't strictly neccessary, but can be useful sometimes. I've also added a near the end to pick up the address when matching the 'icmp' lines. A neat tool to test regexp's is found at $URL$ and your regexp is found here. This site also explains the regexp to some extent. I've played a little more with this regex, so try out the different version in the drop down menu near the top. Added version handling icmp info Here is the currently latest version of the regexp, where I also have added some explanation: 

Most of the solutions provided so far is hard to read, and you need to really think before you understand what is happening, so I would like to propose an alternative approach as a response to a more straightforward algorithm: 

Style reviews I would suggest to read up on PEP8, as it quite common to follow this when programming in Python I've understood. Here are some comments to your coding style based on these guidelines: 

Of course, this does return mostly the same as your function returns, but it does return some of the basic cases like "0π/1" or "1π/3". These could be handled using some ternary operations, which leads us back to code similar to your original code (but without exposing the calculations, and with compression (not reduction) of test cases): 

Alternative logic If I've understood your request properly you are getting a whole lot of sentences, and want to return all the English sentences (and loose the French sentences?). You go about this task by removing everything which isn't , splitting into words and checking against a dictionary, and if the English word frequency is above 0.75 you'll return that sentence (without punctuation). Doing it that way eliminates on a good indicator of French sentences. French sentences uses loads of accented characters. English doesn't. That is a very good indicator (if the Facebook guys care to write those characters), which you are missing out on. Your solution also checks against an entire dictionary, which is kind of expensive. A simpler solution would be to keep two smaller list of typical English words and French words, and make sure to remove non-French or non-English words from these lists. I know very little French, but here is an attempt at some trigger word lists: 

Here we let the Formatter handle the formatting issue, and it does indeed look nicer! And we don't need to make sure the random number is above the legal range, as the formatter handles it. 

This way the code is concise and precise. The error handling is close to the actual input, and the "business logic" is tightly coupled in the switch, before a final presentation statement at the end. 

So in general, always try reducing the number of subprocesses started, as they are quite expensive. And calls usually triggers subprocesses as well as the . 

And here is a slightly extended example displaying some of the more esoteric options available using this class. It also shows how neat the output can be, and gives a clear separation of presentation versus the logic to print the table. 

And finally, the nested for loop It seems like one trick to be able to loop over the variables , and in one go, is to add references to this into another table, and then use . Since we don't really care about the index part of this we can write something like the following: 

This program is useful in a very narrow context of someone using as their command shell, and using for terminal windows. And as suggested in comments I would rather have programmed this a bash function or similar shell script to improve a little on portability and usage options. With that out of the question, the main issue I'm having with your code is that you wrap series of commands and blatantly ignore any error codes returned from anything. Any or all of the subcommands can fail, and you ignore it. Not good. And you finalize your code returning 0 (which by the way is unnecessary as it is the default) indicating everything is OK. A secondary minor issue is that you've duplicated the command in the two cases, and if you at some point in time decide to change it, there is a certain possibility that you'll change one of the two, and forget about the other. I would rather have used some variant with on the second case, referencing the command from a constant string. 

This allowed me to have a slightly simpler structure to work with, and I can display the matrix whenever I feel like it. On a square image of 3x3 I got the following output: 

And you should add docstrings on how to use your code, and you can surely enhance on my variable names and docstrings. Major weakness to this implementation is that any string matching your values would actually match the enum. So that if you create two identical enum's they would also match each other. If that is a problem, or an advantage depends on your usage situation. Could possibly be propagated by changing the type of your class members, and then enforced by defining an equality operator on the new type. 

Added: My little rant on Usually one sees this construct in stuff like or , and I know the syntactic meaning. These reads as Increment index before getting array element at the new index position and Read array element at index, and then increment the index. It has it usages, but can also be rewritten in most cases to something even more readable. The two usages which I don't get used to seeing are: 

With the danger of not understanding your question entirely as it stands now, you have with a field. Why don't you use to trigger a CSS class for the entire entity which disables that entity? Why do you reiterate over the attributes, and create loads of helpers which I don't understand why you need. I'm not entirely sure about the syntax just now, but wouldn't something like the following do the trick: 

Your code is lacking in the regards that you do floating arithmetic when you don't need to, and this potentially introduces smaller errors as you multiply back the different intervals. With that being said your code looks clean enough, well spaced and good variable names. Only thing missing as such would be a docstring to document the functions return value as the name is somewhat ambiguous. To avoid the floating arithmetic, and ease the calculation I would flip the order of doing divmod operations, and then we end up with the following code: 

This would make for your code to handle extra tasks better, it would clear up the confusion on which tasks actually gets executed, and finally all tasks can be executed in parallell however the compiler feels like doing that. 

This assumes that the is available as an within the Node class, but you'll get the gist of the idea and can surely complete it. 

This should do the trick rather efficiently as well as elegantly. Will possibly code it later on, but just now I'm a little busy. But just thought I would give you something to think about regarding how to improve it. Update: No need to reinvent the wheel, so please do use (and/or accept) code example provided by Barry. Will maybe code it just for the exercise, but most likely using heapq.merge, or some union-variant, will be a better implementation. 

Addendum: Locate erroneous input line In comments OP said their was a problem in the line, and to detect this these lines: 

Unfortunate connection between and In a you might add , and each district has links to the id of the cities, making a complete circle. This could be unfortunate, and possibly dangerous. Still you don't have a circular reference as you store only the city id, and not a complete reference to the object. But I fail to see the good usage of these classes, as they seem to miss any useful methods. Like you can't look up a district and find the corresponding city. Neither can you do anything besides creating or deleting the cities and districts. A good object design would make the object have all needed variables and methods for handling related functions. Lastly regarding the function, I think I would find it natural to allow the class to fully create districts. That is to have within class, and then let it create the object. 

I do believe you need to extend your test regime a bit, as there are quite a few cases you don't cover. Here are some test cases you should consider: 

Even though not needed I would consider using parentheses, or at least space the condition out so that it is possible to see the connection. Possibly something like this: 

One could/should also add in some error checks to verify that the encryption doesn't try to encrypt letters outside of 'A'–'P', or lower case character, but that is left as an exercise for the reader. 

Introducing functions also allows for removal of magic numbers like the or or . They could also have been handled as constants at top of your code. * Reduce code at top level – All of your code are at the top level, which makes it hard to reuse the code, and when it gets bigger it increases the difficulty of understanding your code. I've introduced the line, which calls the function. This is a common sight, and would allow for easy understanding of what your code does. This also allows for another script/program to import your module/script, and use the function directly as part of something larger. 

In the table below I've listed the length of text with corresponding number of points/words, and how many characters are needed to store these words. As can be seen these number increase quite fast. The last line is memory usage in megabytes when using memory_profiler on the original code. 

My main complaint about your code is that you rebuild the table used for translation for each and every character you are encoding or decoding. This is a major waste of computational power. In addition I've got some other minor comments: 

Manual handling – You can always call manually. Drawback of this is to remember doing it, and correctly do it when handling exceptions and other error situations Trigger at exit – Using at_exit will ensure that it is always called, unless abnormal termination of your script. Does however need a little tweaking if you by design want to leave pins in the high state. Using context managers – Allowing you to do as a wrapper, like in OP code, before ending by doing the needed cleanup. For more on this see With Statements Context Managers Using decorators – The goal of cleaning up can also be met using decorators, also examplified by OP, where one can ensure the cleanup after the function finishes. See Decorators for Functions and methods (also see functools.wraps). I also found a non-official article, "Python Decorators II: Decorator Arguments", related to decorators with or without arguements, both class versions and functions versions. Through encapsulation and class destructors – When a class instantation is freed, there is a certain possibilty that the function is called. There are some caveats related to destructores, see "Safely using destructors in Python", related to circular reference counting and exception in constructors.