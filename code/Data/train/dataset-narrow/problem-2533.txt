What I need is an algorithm that can create discrete physical groups from a larger set of units like in the image above. I'm at a loss as to where to start with this. I had thought of maybe using some sort of brushfire algorithm, adding units to the group as they're discovered and stopping at walls or too much empty space. I'd rather not reinvent the wheel though and would appreciate any help anyone can give me. 

There is no 'best' solution to this problem. Ultimately you're going to have to find by trial and error something that gives the best tradeoff between performance and believable intelligence. However if you want to use any sort of path finding algorithm you're going to need to subdivide your world in some way. Whether you go with tiles, polygonal zoning or way-point nodes, your path finding algorithm needs some sort of graph to traverse. Using simple steering behaviours without any path finding will result in your AI getting stuck behind obstacles. For seeking targets over large distances I use Jump Point Search which is considerably faster than A*, especially if your map has open areas. For localized searching, such as aggro detection I use a simple Dijkstra algorithm. Unlike A*, with Dijkstra you don't ask it to search for a specific end point, you instead describe the type of end point and it will find the closest for which there is a valid path. For example, you might have a soldier class within your game and you want it to attack any enemies that come within a certain radius of the soldier. You can simply feed the Dijkstra algorithm only the tiles that are within the radius. You then tell it that the only valid end points are tiles which contain an enemy. This will cause the soldier to always move towards an enemy if it is within aggro range. You can couple the above approach with Steering Behaviours / Boids. Do the Dijkstra scan as described, then once an enemy target is found, stop scanning and allow your soldier to follow the path. Once your soldier is quite close switch to following by Steering Behaviours. This will work most of the time but because Steering Behaviours are not a path finding algorithm your soldier will occasionally get stuck behind objects in crowded areas. To solve this you must keep track of the distance to the enemy target. If the distance increases by X amount for Y seconds you know your soldier is likely stationary and the target is moving away from it. In this case, stop following with Steering Behaviours and perform another Dijkstra scan. 

The problem with adaptive difficulty is that games live from problems the player "overcomes". If you analyze the strength of the player then that is very linear and predictable. Either it is too easy all the time or too hard. I would suggest the opposite: Instead of changing the wave difficulty depending on the player strength let the player adapt to the difficulties ahead. Generate one difficulty progression at the start of the game and let the player know it in advance. If in 2 waves enemies will come that are resistant against arrow towers, tell the player. He will than be able to change his strategy accordingly. Add a user select-able difficulty level and you should have a game that is enjoyable for both "hardcore" gamers and "casuals". How you generate that wave progression is a different question and will require a lot of tweaking values until you get a satisfying result. I would suggest first putting down some "milestones" and then interpolating between them. E.g. 

Rather than move your enemy every 500ms you should define how far an enemy should move in 1 second. For example, say an enemy can move 3 distance units every second. If you know the time between the last frame in milliseconds you can simply do this: (pseudo code) 

You don't set these values in the shader. You set them in your program, generally when first creating the texture (though it can be set or changed whenever). If you've already uploaded your texture data to OpenGL then all you have to do is this: First bind the texture if it is not already. 

My solution to this is to group the units together and create a path from the unit closest to the centre of the group. I then use steering behaviours / flocking to sensibly navigate the group along the path to the target. The problem I am struggling with now is that the user may select many units which aren't physically grouped together. Some may be very far away from each other, others may be close but separated by walls, etc. It is not really possible to create one path for such a group. 

The general advice with prototypes is to use something that's completely throw-away. The goal for a prototype when developing games is to simply make sure you're brining the fun. Does the main game mechanic that your software relies on actually make for a fun game? That's an important question, and one that you want answered as quickly as possible. Use whatever means are necessary to get to that answer. 

I looked into this a while back for a small project, but didn't get too far. I'd like to create a small program that lets a user draw a train track and then allows a "train" to follow said track on a 2D plane. I'd like the track to be pretty free form and result in a nice smooth line. I played around with cubic splines and had decent results, but had a ton of trouble getting the train to follow the spline. I also had a lot of trouble creating multiple tracks and switching a train from one track to another. Does anyone have advice, articles, or source code that can help me figure something out? Thanks! 

You can use a tile based collision approach independently whether the landscape itself is tile based or not. It's basically as fast as it can get and also as easy to implement as it can get. If you need a really high precision and memory usage is a issue you can use a quad tree instead of a simple array. (A data structure with almost O(1) performance but which is more flexible in how much detail is stored.) If you want more complex physics you probably want a collision polygon, so you can handle slopes, rotations etc. better. 

In this case I am using glfw to get the function pointers, but the same is possible with WGL. (WGL = Windows OpenGL API, glfw wraps multiple different APIs including WGL from different systems into one and makes sure everything just works) This is of course a lot of redundant code but unfortunately necessary. Using WinAPI directly will make it even more complex in the case of post 2.1 OpenGL so I recommend using GLFW. Thankfully there are quite a few loader libraries, which do all the function pointer loading for you so you don't have to do it manually: $URL$ 

Currently in my game engine when a user selects a large number of units and commands them to a target each unit finds its own path using Jump Point Search. The performance of this is generally OK. What I dislike is that over longer distances all the paths tend to converge so that the units end up competing to reach the path's nodes. 

Assuming your vertices haven't been multiplied by any matrices the tangent and bitangent will be in object space. Edit: Your vertices are in object space. A normal is a vector perpendicular to a face (usually a triangle made from 3 vertices). Because the vertices used to calculate the normal are in object space, the normal will be also. The same follows for the tangent and bitangent. 

This will allow your enemy to move in smooth increments every frame. The enemy will also move the same distance at the same speed, regardless of frame-rate. 

When a arrow shaped object is fired it slowly adjusts it's rotation to match the direction it is moving. But what is the actual physics behind it? 

So, I am conceptualizing a P2P trading card game. The issue is the network: knowing the identity of a card is giving a major advantage, so both clients need enough information about a card that they know it exists, but not so much that the "value" or "specialties" of a card can be determinated. The basic approach to that is simple: each client has a public and a private key for each card, and to decrypt the card you need all private keys associated to that card. Whenever a card is played the appropriate key is send over, whenever a card is drawn the other players send the needed keys over. However there is a issue: the start state is known and from it you could determine which card is which, what makes the whole thing a bit pointless. How do I shuffle cards over the network so that the client doesn't know the actual end state (without knowing the keys)? 

The last time I checked in on terrain rendering, ROAM was the new hotness. Yes, that was a long time ago. I liked ROAM a lot, though, because it was extremely simple to program, and gave pretty decent results. I imagine that the technology has improved quite a bit now. What are the most popular methods for terrain rendering these days? 

Google Sketchup is about the only 3d cad program I can use, because I suck. Do any 3d engines natively import Sketchup models? Are there any major caveats when doing so? 

I care deeply about good coding practices (design patterns, TDD, SOLID, continuous integration, etc.) and put a lot of constraints on my developers when they do this exercise. Pretty much everyone knows the rules of Monopoly, and the entire game can be completed in a single day. This gives new developers a quick win and really gets their engagement up. The initial requirements start off with keyboard controls, but then I add a requirement for mouse controls later. This gets developers thinking about several things, how to refactor existing code, programming changing parts of the system to interfaces instead of concrete classes, better/proper abstractions, what to unit test, what not to unit test, WHY to unit test, and what makes for GOOD unit tests. 

GLFW is modern and has a very well defined scope. It's also under very active development. SDL on the other side is rock solid and has a lot features in different scopes but is somewhat lacking in all of them (for example: SDL can do audio, but you might prefer using OpenAL because its far superior in that matter). It might be notable that SDL was ported to many different platforms, unlike GLFW which is only for desktop platforms (win/linux/mac). GLUT, well, should be avoided. There simply isn't really anything about it what makes it good. 

And you can just check for equality. Edit: Above works well if the movement is limited and straight forward. But movement is often not that predictable. The alternative is checking for proximity rather than the exact position. This will become necessary if the movement is physics based. 

There is no reason. It's just a stupid thing which works but is completely unnecessary. The author probably just wanted to write down the chance as percent and not as permille . Better is: