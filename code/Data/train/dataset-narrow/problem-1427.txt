Personally I prefer to put the const on the right. There are one or two corner cases were this makes a difference and when doing complex C++ templates this has saved my butt. 

Have you ever tried searching for all occurrences of the variable in the resulting loop. The number of false positives will be a pain in the arse. Name your loop variables so you can find them easily. Hiding variables names: 

Again the pop_back() has the inefficiency of forcing a check that is not needed. Also causes branch predication problems. 

Another Dry situation These two look identical. I am sure you can factor out the identical parts into their own function. 

Additionally with the addition of template varargs the use of emplace to create the data object in place using parameters is always an option. 

Recursion is a neat trick to teach for education purposes. But in industrial code prefer a loop here. Recursion has the potential of blowing your stack. A loop will always work no matter what the size of the list. Should be encapsulated in at a higher level (the owner of the list nodes). 

But it does. But what does it mean? Not sure. Not sure I want to find out either as there is no pointer semantics involved here. But since you have a constructor this will never be activated anyway. Writing code that has no clear meaning is a bad idea. I am assuming your code in the lambdas is just example code as it does nothing. Final Thought. The point of this exercise was: 

Double initialization of your array. First time with constructor. Second time with assignment operator. Its fine for POD classes but anything that manages its own memory this is excessively expensive. This looks like it will fail. 

Expectations: The and interface imply that the / don't actually do anything until you call execute/async. But in reality the threads have already started. This is bad design (don't confuse your user). Also they don't work. The thread doing the work could have already started and finished and marked as false. Then you call and is marked true (even though it will never again be marked false because the thread has already finished). 

If i is smaller than 50 then j can not be greater than 50. If i is greater than 50 then the test will fail and there is no need to test what the value of j is. Bugs 

This is because the compiler will generate default versions of these. Under normal situations the default versions work. But when you start messing with memory management they usually need to be defined to work together (deep copy problem). In this case Subject has a compiler generated copy constructor and assignment operator. These will do a shallow copy of the object. This will result in both vectors holding the same pointers and the destructor of these objects will delete the objects (resulting in a double delete). 

and just use where you use There is no need to have two versions of the function just use default parameter values. 

All the nodes were allocated with new. Does your list use sentinels? (not at the moment see below). (Sure I could come up with more). 

Things that are broken Must always take ownership When you create a smart pointer it must always take ownership if things go wrong. If the constructor fails in some way then you must delete the passed object (becuase the destructor is not run if the constructor does not complete). The problem with this is: 

Also its really simple to read. I also notice you missed the move assignment operator. This means your class will only use copy assignment (which comes into play when you look at your move constructor). If you change the design writing these becomes trivial. 

Avoid not using braces. It may seem like a waste of time. But get used to using them they will save you from bugs now and then and they do no harm when not needed. 

Technically this is creating a temporary object then calling the copy constructor of to copy the temporary object then destroying the temporary object. Fortunately most compilers will spot this and optimize out the copy and destruction and just create your object. But this is simpler to declare as: 

Now your technique is not wrong. But you definitely make it harder for your self to validate the input and user interaction is not that great as they are used to typing one value return (and getting feedback on that value). I would change that so that each value is queried for separately (and use a function to get the value). 

Extend your timer function so it can take all the parameters needed by Don bother to pass by const reference. 

Yep. Basically your memory management is broken. When you push elements on you create them with and when you pop elements off you delete them. But what happens when the stack object goes out of scope? Anything still left in the stack is now leaked. Also the use of a maximum count in the constructor suggests that you should be allocating a single piece of storage once on construction to store all the values. The point of using a linked list is to allow the list to grow dynamically. It would be a better idea to just create a storage area and keep track of how full it is (if you are allowed to use std::vector in your assignment this does all the hard work for you). From this: 

You will notice the above compiles (as the compiler generated the copy constructor). But because the compiler generated version does a shallow copy both x and y point at the same list. 

I would say this one (though if the condition variable is written correctly it should not matter). But I tend to want to stay on the conservative side when coding with threads. Thus any resource that is used by multiple threads should only be accessed when you have a lock to make sure access is exclusive. In my opinion is a shared resource and thus needs to be only accessed when you hold a lock. 

Returning a copy is probably not what you want (especially for anything interesting). But returning a reference is not really an option either as that opens you to situations where you have race conditions (you have a reference to the top object and another thread pops it (destroying it) just before you call a method). So you need to provide a method for accessing the object while maintaining the lock (this will probably require the return of a wrapper object that maintains a lock on the queue) or alternatively removing this function. Other non C++ things that should be addressed: The mutex should be locked/unlocked using RAII. You are leaving your code open to exception handling problems. If an exception is generated by which you have no control over then you could leave your queue in an unusable state with the mutex locked and no way to unlock it (because the stack of the locker has been unwound past the unlock because of an exception). Yes this is correct: 

Most languages have decided that exception specifications are a bad idea. In Java they devolve (over time) to throw Exception and in C++ the only useful one we found was the specification that said this function does not throw. 

This is all wasted code. If the map does not contain an element then then operator[] will auto insert a default node using the default constructor for the value type (which in this case is the empty set). 

So now that I see that the same problems exist for both and versions. I would go back to my original position of not using here. But it is non trivial and you should think about it. 

There is also another technique to resolve all these problems. Its called the "Copy and Swap Idiom". 

You don't want other people reaching and changing the hit points of a character without using one of the offical mechanisme: like 

Note: members are initialized in the order they are declared in the class declaration (not the order they appear in the initializer list). If you turn up wanings the compiler will warn you about this. If you make the compiler treat warnings as errors (as you should be doing) then it will not compile if the initializer list is in the wrong order. 

I could go on. But I think your first task to better organize your code so that it is readable. After that we can go into how it to make it better but you are a long long way from being able to do anything useful. Yoda conditionals: 

Though I will sometimes put one liners in the header file I still usually prefer to put all methods into the source file (let the compiler worry about the inline optimization you have more important things to do). Technically this is not allowed: 

So the next thing. Is constructing the object of this class. Integers have no type. So I would introduce types that represent the different units of measurements. These types know how to convert to a Unit of Length: 

Passing by pointer is very rare in C++ (very common in bad C++ written by old C programmers). The reason for this is there are no ownership semantics associated with the pointer and thus potential for misunderstanding the interface and thus leading to memory leaks. In C++ we want to very clearly define the ownership of pointers as it is the owner of the pointer (and nobody else) that is responsible for deleting the pointer. The language has introduced smart pointers that allow us to specify ownership so that when the pointer is passed we are explicit in passing ownership with the pointer. In other situations were ownership is not passed we use references. If I was using your function for the first time I can not tell if I need to dynamically create the vector or not. Is your function going to call delete on the passed pointer. I can't tell from reading the interface because pointers have no ownership semantics. If you change your interface to pass by reference then it works just as well and there will be no confusion. If you want to pass ownership you need to use smart pointers to indicate the type of ownership that is being transferred. Prefer prefix increment. 

I suppose this interface you are passing ownership of the object to the heap and you expect the user to manually remove all items from the heap and call delete on them when you are done. You should reflect this in your interface by using . This tells any user of your heap that you are passing ownership of the object to the heap. And when you return it pass by so that it is obvious that you are returning ownership of the object and the user is expected to delete it. You also need to add a destructor to make sure any object left in the heap on destruction are correctly destroyed. Normally containers use value semantics (not pointers). So you insert an object and the container takes a copy (or in C++11 moves the object content). I would suggest you move away from using pointers and use value semantics. Heap Management I don't like the need for people to manually rebuild the heap . When I insert an item I expect the heap to be placed in the correct place to maintain the heap. What I would like to see as the interface is simply: 

So for every string you are iterating over its length. before adding it to the buffer. There must be a better way. Most of your strings are compile time arrays you can pull the size at compile time with a bit of work. 

No reason to be able to get the unit!. You need it because of the way you implemented check_type(). But you are leaking your abstraction here. Prefer to change check_type(). The other reason to leak this is for streaming purposes, but a better solution would be to implement a print method. OK. Self modification. 

You are giving the option to pass by r-value reference this implying you are going to rip the guts out of the object. But you are actually just making a copy into . A cheap copy as the tuple only contains references. But I think the interface is better if you pass by const reference to more accurately reflect the usage semantics better. 

The main difference is that the C++ version puts the types correctly in the namespace rather than the global namespace. These types already seem to have the same names. 

Complexity The main issue with your application is the calculation of the "Fibonacci" number. Here you are looping over the range . Each time you are calling it recalculates the Fib values from scratch. 

Casting to bool. It is useful to use a shared pointer in a boolean context and thus allow you to test its state naturally. 

Let the vector handle the memory management. You can handle the business logic. PS. You still need to implement the rule of three. Your connection is dangerious: 

First this means you need to look up RAII to make sure these members are correctly deleted. Second you you need to look up the rule of three (or 5 in C++11) to make sure they are copied correctly. You have owned RAW pointers in your structure. This means you need to correctly manage the object as a resource. This means constructions/destruction/copy (creation and assignment) need to be taken care of correctly. Either do this manually or use a standard container that will do it for you. I suggest a standard container. 

Even after removing all the chaff the above line is still unreadable. Split it up into multiple statements and use temporaries. This way you can comment on what is happening. Its not as if a single line is more efficient. The compiler is going to remove any unused temporaries. 

If any of the parameters have a space (modern directories tend to have them). So best just to add double quotes around all parameters (I personally also like to add to make them stand out more but thats more optional). 

That is a relatively trivial hash function that is known to have a bad distribution. If your keys are the same length you are very likely to get clashes. 

Also prefer not to use when all you are doing is returning true/false. Just return the value you were testing. 

If you call the destructor on an object you want to keep, you must call the constructor to make the object live again. You can do this with placement new. 

The reason I would not advocate writing your own is the actually complicity of all the edge cases. Though your code embodies what is happening the actual code has not reflected this in a long time (you have basically written the deprecated version of boost::lexical cast). Also the boost version has a whole bunch of special case optimizations. 

Unless you are using a software package that asks you to set this it is probably not a good idea. Put header files in order. Most specific (ie your header file first). To most generic last (The C libraries are the most generic). 

I don't particular mind them but I also would prefer to have and defined (Note you can simply make these call write/read respectively). With the stream iterators defined this becomes less useful. 

That's 67 lines compared to the nearly 500 for writing it yourself. And I am being generous as I could collapse all the symbols into a single line. This code is basically readable BNF so any computer scientist should be able to maintain it. Code Review There are so many of these lying around. You could have picked up a nearly standard one from boost 

But you did it perfectly by enclosing it inside the smallest scope possible (so I can really say anything bad about it and its absolutely fine in this context). My personal preference is that anything from the namespace/class that I am currently defining does not have a prefix. But Anything from another namespace needs a prefix (though a namespace alias is fine for long things I like the prefix to be short 3 or 4 letters). 

Again the only use is do tests and fiddling that should be part of the responsibility. You should send the transaction to the account which may reject the transaction if it fails any of the account specific validations (ie you can have a negative balance). Like this. 

wRecently needed to swap keys with a colleague on the other side of the country. This script encrypts a file using the other persons public key that is stored on github. It outputs a script that will re-generate the original message (if you have the private key).