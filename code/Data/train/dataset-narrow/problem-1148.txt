Trying something out of my comfort zone here, and attempting to implement a D-style range around . Looking for any and all suggestions or improvements. One of the things I'm not exactly happy about is having to declare , and just to fullfill the forward_iterator concept properly, yet not being able to actually use them. I feel that this allowing me to initialize a vector straight from the iterator pair is worth the clunkiness, but I welcome any opinion on the subject, or suggestions on how to make it better. Thanks! 

I have one big swooping recommendation that I feel you should address before tackling anything else: Mind your class invariants! When designing a class, ideally you want to ensure every single public member function handles correctly any possible valid state of the class, in conjunction with any possible passed argument. In your case, ask yourself: What happens if gets called before ? What happens if gets called twice in a row? What happens if is called after ? A good way to tackle that is to define what's known as a class invariant. First, jot down on paper a description of the legal internal states of the class. That's known as the class invariant. For example, you may want to have in your invariant definition, but would be even better, because it allows you to rely on that being true, so you don't have to constantly check. Second, for each public member function, make sure that the function's behavior is well defined for every possible invariant state, and that it leaves the class in an invariant state after it's done. Mind you, it doesn't mean that every public member function must "work", just that it doesn't explode, cause memory leaks, etc... Edit: There are some extreme exceptions to this, such as 's . But this is an exception, and the class' documentation makes it extremely clear that you enter no-mans land if you call that with an index outside of the bounds. 

Background: I'm in the process of writing a relatively simple behavior tree driven AI system for a game that I'm working on. Basically, the behavior tree is made up of individual gameplay tasks (move, attack, etc.) as well as composite tasks that iterate over sub-tasks in a variety of ways. Each gameplay task is a leaf and will return a status (success, failure, or running). For example, a sequence composite task iterates over its sub-tasks in sequential order. If all of the sub-tasks in the sequence return , the sequence will also succeed. If any of the sub-tasks in the sequence return , the sequence will end early and fail. Finally, if any of the sub-tasks return , the sequence needs to store its position, return this frame, and re-tick the same sub-task again next frame. I had no issue getting my behavior tree to work correctly within a single frame of execution at first by recursively calling down the tree. This works basically like a depth-first traversal. But I've been having some issues finding a clean way of dealing with storing and resuming from nodes that return . I probably can't post all the code needed to compile and run this without making a mess of this question but here's the basic flow of the program: 

You don't need to compare and during each iteration. The difference between the new and the previous sum is simply the current term : $$\frac{8}{(2i+1)^2}$$ If you want this term to be smaller than , you can solve: $$\mathrm{error} > \frac{8}{(2i+1)^2}\\ \iff (2i+1)^2 > \frac{8}{error}\\ \iff 2i+1 > \sqrt{\frac{8}{error}}\\ \iff i > \frac{\sqrt{\frac{8}{error}} - 1}{2}\\ $$ Now that you know how many terms your series should have, you can return the result directly: 

Just a collection of thoughts... Terminology Since you're talking about graphs, it might help the readers if you talk about nodes (your ) and edges (your ). Your graph is directed, and as far as I can tell, you're looking for the "strongly connected components". Use simpler objects Lists of pairs of pairs aren't very readable IMHO. When showing examples, you can replace them with lists of strings: 

One possibility would be to use a in order to check for duplicate integers. If there are no duplicates, the length of the list should be : 

Links between multiple edges What happens in the case of link connecting more than 2 edges, for example 

As you mentioned, Pandas or at least NumPy would do just fine. They're fast and the syntax is clean and straightforward for this example. With NumPy You just need to define a mask as a boolean array: 

This is pretty dodgy. At the very least add a comment listing what each of these are. I don't like your implicit cast operations from your wrapper types to the native GL handles. If you are going to use wrappers, commit. There will always be a few edge cases where some functionality needs the native handle, but that's what is for. regarding . Libraries shouldn't just write to . You would be better served to build a string and invoke a callback that is application-defined. I would make the calls to in the VertexBuffer constructors. regarding . You do not want your GL thread to be ever waiting on I/O. It's better to receive a buffer, and delegate the file loading to someone else. Use the GL* types (instead of ) They are there for a reason. 

You are mixing your functionality with your test harness and have no business being members of this class, and should be free-floating functions. Once you do this, you will realize that there is a lot of stuff missing from your class as it does not expose the interface required to implement these simple cases. 

T must have a default constructor T's constructor get called for all objects as soon as the pool iscreated T's destructor doesn't ever get called. T basically can't use RAII semantics 

Upper bound for p_n There is a known upper bound for the n-th prime. It means that you don't need any loop inside , and you don't need to check if either. 

The main problem is that your method relies heavily on your hard drive. The process needs to recursively look inside every sub-folder, which takes time, especially with 50000 files. Windows search is much faster because it indexes the files and doesn't scan the whole drive for each query. If using Python3 is a possibility, the only thing I'd change in your code is to use and replace the loops with: 

You seem to think that this code would display 500 numbers between and . It doesn't. Instead, it displays , , and returns . You need to replace with . Alternative You can use to look for the substrings, them and replace them: 

Done! The huge advantage is that anyone with some experience of numpy or pandas will understand the code right away. 

You get more information, it's more robust, you get diagrams if you want, it can handle more complex cases and (who knows?) it might be faster than your solution for large datasets. 

looks like . With Sympy You can delegate the job to and be sure you'll get a correct result with arbitrary precision: 

This is looking pretty good! But there is definitely room for improvement: Better template parameter name generally refers to "any type". Since your template is based on a character type, you should use something like to be more explicit. Is there really a reason for this to be mutable? , and is just extraneous api surface to me. I would personally have favored a public API consisting entirely of: 

This is a little fragile, since should you make the class more complex, that's a lot of places to refactor. The following would be better: 

Logic error: end() never ends needs to finish somehow. If was only ever called in the destructor, you could then guarantee that no one else is interacting with the object at that point. It would then simply be: 

Instead of going through every little improvement one-by-one, I'm going to make two big sweeping recommendations: 

Use maps to handle mappings instead of having constants for each individual ratio, you might as well have a single constant that holds both the ratios and their respective strings, as well as being able to map one to the other. Consider this: 

This way, you can consume from vectors, strings, character arrays, etc... and there is no need to make a copy of the data into a vector prior. member functions that do not mutate the class should be marked const. Pretty simole, should be marked const. Use const references when not taking posession of the data. For example: 

This worked fine, but it felt a bit messy and brute-force. So I thought about other possible ways to do it. Thinking back to some of the C++ code that I've written, using something like an iterator came to mind. After a little research I found that IEnumerator seems to be more-or-less the same idea in C#... Second Attempt: So, going back to the drawing board, I tried rewriting my code to make use of enumerators. Now, instead of storing a reference to a task, my composite now stores an reference. I've used foreach loops and IEnumerable objects many times before in C#, but this is the first time I've ever needed to deal with IEnumerators alone. Honestly, I went for a kind of 'lazy' approach to calling instead of doing so in the constructor because I figured that tasks might be added and removed dynamically at various points in time. I added some small convenience functions for controlling my IEnumerator to prevent cluttering my code in other places. Here are the changes to my CompositeTask abstract base class: 

Conclusion Anyway, that's about it. Both of these "sequencer" composite tasks work correctly now, but I'm not convinced that the code couldn't be a lot better in both examples. The first code is just a brute-force reference comparison of the saved task against the current sub-task, but it's relatively clean and simple. The second code is based on iterators/enumerators and feels like it's on the verge of being the right path, but it's also a bit messy and it probably shows my lack of experience in certain areas. I'm alright with that, as I'm here to learn and improve! After all, I don't have many opportunities for code review! My main questions are: 

Upper bound for p_n There is a known upper bound for the n-th prime. It means that you don't need to guess how large it could be. tells us in less than a micro-second that the desired number cannot be larger than . You just need to apply the Sieve of Erathosthenes up to 114320 and you're done: 

Python strings are basically tuples of characters, so you don't have to change much in your code. The above example is isomorphic to yours and is much more concise. KeyError When calling , you're hoping there won't be any . Your example would fail with : 

Another alternative would be to work with generators and join the letters at the end instead of building a new string character by character. 

It calculates the 100000th prime in less than 230ms on my computer, compared to 1.5s for your code. itertools.islice Another possible optimization would be to use to get the n-th prime out of the generator, without converting it to a list. 

Theory Your function is very similar to the structure of . Keeping only the essential, you could write as : 

networkx If you work with graph theory in Python, you should take a look at . It's fast, easy to use and offers many algorithms. All you need to do is to preprocess your data and feed it to a . Your example could become: 

Here's my new sequencer code using IEnumerators. It works as it should, but honestly I suspect this code is kind of bad! The basic idea was to store an enumerator that always references one of the sub-tasks. If a sub-task is succeeds, the enumerator moves to the next one and we tick it immediately. If a sub-task fails, the enumerator is moved to the beginning. And finally, if a sub-task returns we don't touch the enumerator and we just back out. Next time the composite is ticked, it will tick whichever subtask is referenced by the enumerator. Here's the altered Sequencer composite task that I rewrote using IEnumerators: 

All the code samples below are functional and in both cases my sequencer is behaving as intended when populated with some simple test tasks. I recognize that I'm being a bit loose with the permissions - a lot of things are public that probably shouldn't be but it makes it easier to test and debug in my current engine and I'll buckle down on that a little later. I'm a self-taught programmer who hasn't worked with many large or experienced teams yet and I'm still quite new to C# as a language, so I'm more than happy to receive any critiques or advice on how I can generally improve! First Attempt: This was my first attempt at handling real time tasks (for example, automated character movement over time). If a task can be performed with a single frame/update/tick it will either return or , the tree will continue being traversed, and as many nodes will be ticked as possible. However, whenever a task node returns we need to store that task somehow, back out of the tree traversal, and resume from node next time. Because each composite task calls on its sub-tasks, it seems like the state of the tree at any given time is tied to the function call stack. I can't just store the running tasks in a list outside of my behavior tree, because despite being easy to tick them again next frame I would be losing the bigger picture of their place in the tree and wouldn't know where to go next. I 'solved' this by creating a reference to a task in each of my composites. When one of a composite's sub-tasks returns a reference to that task is stored in then the composite also returns . Next time the composite is ticked it checks if a task has been saved. If so, the is reference compared to the current iteration and the loop will jump ahead until we find a match. This is the behavior tree class which only really serves to encapsulate everything: 

Code Here's the refactored code. It's much shorter and 3 times faster than your original code for the primes below 1 million: 

? Your current algorithm doesn't seem to take it into account. A might help, for example to keep a list of nodes beginning with and another list for nodes finishing with . Output format If you only sort the edges, without grouping them in connected components, you're losing information which you have to recover later. You could return a list of sets of edges instead of a flat list of edges. 

Even with more than 140 000 terms, the series only gives the 3 first digits of π². This formula is very simple but converges too slowly. What's very interesting, though, is that the difference between and seems very close to \$\sqrt{2\mathrm{error}}\$. It seems to hold true for any , so we could update the function: 

Better formulas Adding a delta Note that represents how small the terms are, not how close is from π²: 

Performance The first part will be slow (300ms on my laptop). It doesn't depend on the pattern, so you could calculate it once and cache it with or . took less than 100ms. The second part is really fast though. For , the trie version is more than 1500 times faster than @200_success' code (40 µs vs 68 ms). The trie code gets a bit slower with more placeholders, it's always a few orders of magnitude faster than the other answers, though.