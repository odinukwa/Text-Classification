I would try using an N-ary tree structure. The bubbles stack up in a skewed formation. If you take a bubble and surround it with other bubble, you will only get 6 possible connections: top left, top right, left, right, bottom left, and bottom right. Contrast this with a 2d grid and you get 8 possible connections: top left, top center, top right, left, right, bottom left, bottom center, and bottom right. This should make using a 2d array a bit cumbersome to keep track of the proper connections between nodes. My approach would be to make each node have 6 connections, make the tree big enough to represent the entire play area, allow for empty nodes, and allow for edge nodes or null node connections. 

This is a debugging issue. The image gets drawn where you are telling it to be drawn. The problem is you are not telling it to draw in the correct place. Use the debugger to examine when you enter the method. My guess is that will not have the value that you are expecting. If this is the case, look through your code, and find where is being set, or where it is being changed, and make sure those bits of code are doing what they are suppose to do. 

Instead of operating off the minimum clicks to calculate a multiplier, you could have a par number of clicks for each basket. If the player gets in the basket under the par you can use that difference as your multiplier. For example, if it is 2 clicks minimum to get the bronze and 7 to get to gold, the par for each basket respectively could be set at 5 and 10. If the player get the bronze in 4 clicks it is a 2x multiplier. If they get the gold in 9 clicks it is a 2x multiplier. If they get the bronze in 3 clicks they would get a 3x multiplier, likewise, if they get the gold 8 clicks. 

Often times your ai is the result of several components working together, not just one master ai piece of code. The solution you are after can be achieved in this manner. As already mentioned you can give your creatures states so that they know what their current task is, roaming, rushing, standing ground, retreating, etc. Next you can add pathfinding. This will tell the creature how to get to where it needs to go, regardless if it is chasing a player or roaming. Finally, once the creatures know what they are doing and they know how to get there you can implement object avoidance, so that the creatures will dynamically adjust their paths as they travel to avoid one another. EDIT: This solution is relevant whether your game is real time or turn based. If a creature is: Roaming state - it will target and seek the nearest empty node x tiles away. If the player comes withing y tiles from the creature and the creatures bravery is high enough then the creature will enter Attack state. If the bravery is not high enough then the creature will switch to Congregate state. Attack state - creature targets and engages player. If bravery drops too low creature state will change to Retreat. Congregate state - creature targets and seeks nearest enemy. If creature is within 2 tiles from target state will change to Pack state. Pack state - closely follows lead creature and gains a bravery boost. If lead creature attacks, this creature will switch to Attack state, regardless of its bravery level. If the "pack" does not engage the player within 10 turns then the creature will "forget" threat and switch to Roaming and its bravery boost will fade. Retreat state - each turn creature targets the nearest node to the creature that is the farthest from the player. Once the creature is 10 tiles away from player then it state will switch to Roaming. If the creature is "cornered" in Retreat state, it will switch to Attack state regardless of its bravery level. Once the creature has a target, you can calculate a path, tile by tile that the creature needs to take to reach that target. Each turn the creature takes the next step to reach the target. To avoid collisions with other creatures during movement you can check "a move ahead" and see if there will be a collision. If you find a collision, you can choose to let it be first come first serve. So, first creature on the list gets to move to that tile on the next turn. The other creature can choose an alternate route around that tile, or choose to wait and not move for that turn, hoping that next turn that tile will be vacant. 

You might want to take a look at these articles. They are a bit old; however I think they cover what you are looking for. Coordinated Unit Movement Implementing Coordinated Unit Movement 

The error comes from and . Since you are using a rectangle that is wider than taller, your is always greater than your . This is way when colliding in the x directions it works, and when colliding in the y directions, the wrong thing happens. You can test this by swapping the width and height dimensions of the box, and the error will be just the opposite then. You should be comparing how far the player is penetrating into the box's x space, with how far the player is penetrating into the box's y space; then based off whichever is great, adjust the player accordingly. I think this was your original intent. Try replacing: 

You are calling every time you enter . You keep erasing the last ball drawn. To see each one you need to redrawn each ball every frame. Just store the position information created by in a container such as . Then after you call loop through the list and draw the ball at each position. 

Have you considered using a messaging system like the observer pattern, or the publish/subscribe pattern. You could create a trigger object, register any platform that needs to be notified with the trigger object. Then when the trigger goes off it informs all those that are listening that the event has happened. The nice thing is you can have as many or as few event listeners that you need and they do not have to be aware of each other. Just place the trigger somewhere before the player gets to the platforms. If the trigger is a non-drawing game object, the player will be completely unaware of it. 

Obviously I am making some assumptions about your class hierarchy, but I think you get the idea. This behavior would work well for what you are asking about, as well as animatiable floor switches and pressure plates. Also, implementing something like this would allow you to make a trigger control more than just a platform, for example: dropping block, swinging chains, flooding rooms, etc. Anything you derive from can be registered with a , (or more than one if you like). 

EDIT: I was curious so I looked this up. If you are using a custom cursor, you can set the hotspot. If the hotspot is off this could be the error you are seeing. With a cross hair the hot spot should be in the center, as opposed to a arrow, where the hot spot should be at the tip. 

This really isn't an answer, but hopefully a nudge in the right direction. I think my approach would be to have the background image painted with the hole dug, and then place a dirt pile image on top. When the user swipes across the dirt pile you can erase that portion of the dirt pile image. This way you will slowly reveal what is under it. sort of like a scratch ticket. You could darken the image on one edge of the swipe and lighten the opposite edge to simulate highlights and shadows. 

You can use to define the outer edge of your rounded rectangle. This actually creates a . To turn this into something you can use, can be called to create a list of points that can be used to step along the path. You can use this information to draw your circle as it progresses around your progress bar. Here is a good example of what you are after. FlatteningPathIterator 

I am not familiar with SpriteKit, or Cocos2D, so I can't answer that question. However you should be able to accommodate any screen size if you use percentages. If you calculate the percent of pixels where each circle is placed in regards to your original image, you can use this value to calculate the placement of each marker in the target resolution. For example, in the image you posted, the top left corner of circle 35, looks to be at (roughly) 55% of the screens width, and 45% of the screens height. If these values are accurate, you can calculate the screen position in any resolution very easily. 

Point A will have passed point B when the signs of the vector components of B - A have changed compare to the original B - A values. Another solution would be to use the dot product of the original B - A vector and the current B - A vector. If the value is positive then A has not reached B yet. If the solution is 0, then A = B. If the solution is negative then A has passed B. Further, if you normalize these vectors before you take the dot product you will get either 1, 0, or -1. If A is not traveling along this vector then there needs to be a plane that contains B that acts as the threshold. A will start on one side of this plane and when it passes to the other side of the plane it would be considered passed B. Beyond that there orientation would be completely arbitrary. 

My guess is that the problem is in In your loops, it looks like you are manually incrementing posX, and posY. The and should probably be and . 

I agree with @jspurim that your collision bounds checking, but that is another matter. You are asking about inconsistent jumping off of walls due to the flag flip-flopping, right? From what I gather reading the code you have posted, when the player jumps and collides with a wall, they stick to that wall and begin to climb vertically. After a brief moment the player can then jump off the wall, or continue climbing the wall they are currently stuck to. The flip-flopping is happening because after the short pause you say it is ok to stop ingnoring collision, when in fact the player is still running up the wall and there is no need to check for wall collisions yet. Try moving out of and put it in the code where the player actually jumps off of the wall. 

If the balloon does not stay in the center of the screen, then the and will have to be calculated off of the balloons current position. 

I would try using a screen buffer to draw all the walls (and possibly the characters) to. And then you can apply the perspective to all the walls at once. This should eliminate any errors you are getting because perspective is being applied to a single image rather than multiple images. You would than assemble the scene by drawing floor layer and then the wall layer on top of it. 

It looks like you are using a matrix to rotate the image when it is drawn. This does not change the position values you have stored in your class, but it does affect how the image is drawn. If you want to know where the 4 corners of the image are drawn you will have to keep track of them yourself. Same is true of the bounding box. If the bounding box is to rotate along with the image, you will need to transform the 4 corners of the bounding box just like you are transforming the image when you draw it. This brings up another issue. If you are rotating your bounding box, then you need to use a collision detection method that can properly handle non-axis aligned bounding boxes. An example would be separate axis theorem (SAT). 

Consider using Sub/Pub pattern, or Observer pattern as a messaging system. This will allow you to register as many event listener as you want, while keeping all the listener decoupled. The basic idea is you keep a list of objects that want to get the message when an event happens. When the event does happen, you iterate through the list, sending the event message to every object registered to receive it. Each object will process the message however they need to. If a listener no longer needs to receive the message, you simply unregister it. 

I use the same calculation and I don't have the same issue, perhaps the error is with the . I am not familiar with libgdx, so I can't comment directly on this. Maybe you can test this by shooting at an exact known location. One suggestion would be to color a pixel at say (300, 300), and shoot directly on it then check what the mouseX, and mouseY values. I like how you calculate the trajectory separate from the draw since this operation only needs to be done once. One tip, the result of any number squared will never be negative so there is no need to use . One more suggestion, if you are using a pointy image, like an arrow, as opposed to something round, like a fireball, you can rotate the image to match the trajectory. I took the liberty of rewriting something things for clarity of intent. You can generate a rotation angle and then rotate the sprite with this value. 

This should make sure the particle has the correct trajectory. Whether or not it has the correct velocity is harder to say without knowing more about how you are controlling the timing of the animation. If you have a fixed time delta then the code you have should be fine. If your delta time between animations frames if variable then you should be factoring this into your update function. Also, you can calculate the rotation angle of the particle in the moveTo() code if needed. 

To make a particle track your finger motion you first need to track at least two different events in , and possibly a third depending on what you want to happen when you lift your finger. You need to check for and , and possibly MotionEvent.ACTION_UP. The first event you will set the initial target location, and the second event will tell you where to alter the target location to. If you want to particle to travel to the last location of your finger after you lift it you can just ignore MotionEvent.ACTION_UP. 

I would try using a heuristic. From what I can tell there are at most 5 areas to move around in and 4 passages between them. As the bars move around, the 5 areas, we will call them, top, left, center, right, and bottom, are either expanding or contracting. Your heuristic could be based on whether an area is expanding or contracting. Obviously, it would be preferable to move into an area that is currently expanding. Actually, the most optimal area would be behind one that is expanding while the area clockwise to it is contracting. In other words, you will have the most time to maneuver in to and out of an area that is behind a bar that just left the edge and is moving towards the center, while the bar clockwise to it is moving from the center to the edge. Examining your picture, the optimal place to move to would be behind the left bar. As you move up one, and then to the left, a space will open up behind it. At this time the top bar is moving up and out of the way. This gives you plenty of time to move around. So your heuristic could work like this: 1)an area is most desirable when the bar for that area is at the edge of the screen. As the bar moves towards the center and back towards the edge, that area becomes less desirable. 2) A passageway is most desirable right after the bar that blocks it starts moving from the center to the edge. It decreases in desirability as it moves to the edge and back towards the center. You can then move the red block towards the most favorable passage to the most favorable area. The value of your heuristic can be arbitrary. What is important is that it makes sense. You can have it to be a value of 100 when the bar is at the edge. By the time it reaches the center it the value could be 50. And as the bar heads back out to the edge it could drop down to 0. Or perhaps when the bar reaches the center the heuristic is 75, and when the bar get halfway back to the edge it is 50. Then as it gets closer to the edge it starts increasing. This might give you a chance to start moving in the right direction ahead of time. Just to be clear, what I am calling a passage would be the region just above the left bar, the region to the right of the top bar, the region below the right bar, and the region to the left of the bottom bar.