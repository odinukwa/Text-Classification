We need to take their summations- this is the formula for getting the some of a linear arithmetic progression, n is total number of elements in the series. 

We need to get all the numbers below 1000 those are divisible by 3 We need to get all the numbers below 1000 those are divisible by 5 There will be repetition of numbers as there are a lot of numbers which are divisible by both 3 and 5. 

Of course we can use the modulo for each number below 1000 to determine which are divisible by 3 and 5. But isn't it a brute attack on these numbers? Why don't think it in a different way? 

You can see there are two circles A and B and they are overlapping with each other. In our problem we have two sets of numbers- those are divisible by 3 and those are divisible by 5. See these two sets have a common or intersecting set- those are divisible by both 3 and 5 (or 15 to be precise). Now the questing arises how would we get all those unique numbers from set A and B? Thats pretty simple as you might already understand. That is , pretty simple, right? This expression takes care of all repetitive elements in those sets and produces a set with unique elements form both sets. Now how do we get ? The formula is- = + - That means we need to subtract the set of numbers those are divisible by both 3 and 5. Lets find out which numbers belong to these sets- , and We have set our limit to 1000. Lets get the numbers those are divisible by 3 in the first place. 

If you anything with a then the result will always be . Here and . So the expression will be Using this algorithm you are not actually checking the numbers which are divisible by both 3 and 5. Still it gets you the correct answer. The reason behind is you are just traversing throw the numbers and moving forward. There is no chance of any repetition here. The accepted answer is all good :) 

This would be the finishing of the discussing. But WAIT as I mentioned earlier I have solved this problem and that solution is not matched with this one!! WHY !! Finally I figured I out, this is the result of not reading the question properly. They asked for the number below , but what I have done here? for and it was okay, but for ? 1000 is divisible by 5! We can't include it in the set!! So the actual summation would be , less than what we got here. People might argue why I have posted the whole solution here. But thing is that, anyone with a little knowledge of programming and the basic understanding of modulo can solve this problem like the questioner. Is this the right way of solving these problems? Was it the intention behind developing this problem bank? Of course not, at least I believe. They certainly want us to look at problems in a different angle. Look things those are hidden in the plain sight. Sketch the idea before painting actually. This post is for future reference only, intended to them those are interested solving the problems in this website. But also for others to show there could be some other perspective to any problem. Thanks for reading. EDIT As per suggestion by @200_success I am rewording here. As per the original question I agree with @Simon Andr√© Forsberg there is certainly nothing wrong with the modulo operation. And also it can be broke down to a simpler version as he already mentioned. I want to add with it that the condition writing is very easy with the basic understanding of . I am just breaking down the idea. In digital logic design is represented as and is as (and there are some more). So the condition becomes . Now you can have as many times as you like as its just an operation, so we can rewrite 

Your first question was answered nicely by @sockmonk. You could have written , which, though longer, is arguably clearer. Regarding the second question, I suppose that's a matter of individual preference, but I am happy to use a ternary operator when it fits comfortably on one line. One reason is that it reads fasters than an clause or statement, as we humans have greater experience reading horizontally than vertically. @200_success makes an important point in his comment on the question. For the example he gave: 

It makes sense that the number of factors should not depend on what the particular prime factors are, just how many there are and the number of times each occurs. (Note that if you don't care about displaying the prime factors, you could have --probably renamed--return only .) Suppose, for example: 

I would take a different approach. First I would convert the number to words using an idealized numbering system, with none of the complications of the tens or teens. By way of example, 413,230 would be . Here would be . (I have shown the results of this first step in the examples below.) Then I would use the hash to correct the grammar. This results in there being relatively little code, but a fair amount of data. Note that the order of the elements in the hash is important. (Insertion order of hash elements is maintained in Ruby 1.9+. This is the first time I have found that change useful, but useful it is.) The substrings must be replaced first, then the substrings (the numbers 11-19) and lastly the substrings. Please let me know if what I have is not quite correct. 

To my way of thinking, the shorter the method, the shorter the variable names can be. If a method is short, and you understand what value a variable holds, you don't have to remember its name very long, so it can be short. Here I used (and ) for "number" because I always use that convention. obviously is a method that calculates 's triangle number. I can use something short like because the expression says what it is. Same with and . If you want to get fancy you don't have to begin with the number . Instead, you could calculate a lower bound on numbers that have triangle numbers with the given number of factors. Calculate triangle numbers Next, in order, the method . Your method is fine, except doesn't add anything to the name and there is no need for an instance variable. Just return the triangle number, which also helps with the self-documentation of the method: 

Instrument Class Why not make this class an enum? By declaring the display Strings and key values as static variables in your class, it's already constant. For example: 

Who cares if it's not selected already? Doesn't hurt anything to set it to false again, plus now it's even more clear that each method is an unnecessary wrapper. Midi Class 

BeatBoxConstants Constant Class (of Interface) are a bad anti-pattern. Instead, we can easily just pass in the number of beats to the constructors! 

I prefer to accomplish this by creating the view, and injecting it into the controller in the constructor as follows: 

can be removed Instead of using a for loop and iterating with a counter, you can use the built-in iterator and iterate over . 

Added bonus: You can select new check boxes and the player will now start playing the new track without having to pause and restart the player InstrumentRow.java 

Resulting Code With all of the design changes in mind, here's what the result could look like: BeatBox.java 

Use static variables that are already part of the Javax MIDI library. For example, your and magic numbers can be replaced with and respectively. This applies for the message as well. I'm not sure what that's for or why it's necessary, but I'll take your word for it :) Similarly, that magic can be made a private static final variable on the class. And the . I'm not sure what that does either. Velocity? Let's go with Velocity. 

Midi class. If Midi is no longer to be sharing the MusicInfo object (since it doesn't exist anymore!), it needs to know when to update the track, and what to update it to. One option (there are probably better ways) is to expose a method such as: 

Just to reiterate, the view should be a very thin layer of the application. It does not have any business logic, and it should be the only place in your code where UI elements (AWT, Swing, etc. classes) reside. That is, no other classes should have ANY knowledge about what UI framework the view is using. Why? Those classes shouldn't care! (Separation of Concerns) 

MusicInfo Class Long story short, you don't need this (I also think there's a better approach than using a 2D array, but for now, let's assume the array stays). The 2D array that's being wrapped here is a UI component, so it can easily become part of the GUI class. The methods in this class are just syntactic sugar, and really don't provide any additional benefits. Plus: 

That's up to you, but you probably want to use the first form at least while you are debugging and testing. Calculate number of factors from prime factors Now let's go out of order and look at the method . This one is actually quite easy, as we can employ a version of the Tau function. Suppose we have constructed to return the array: 

Well, this is still not quite right. The calculation of is not correct, but it needs a fair bit of work to fix. I've therefore commented it out in . I also changed the name of the method because it's easily confused with the built-in methods for for strings and arrays. I'll leave it to you to fix the rest and of course others may offer additional suggestions. Alternative Solution Here is one way you could write the program more compactly. Code 

There are two cases to consider, depending on whether is even or odd. The easier of the two is when it is odd. Suppose, for example, and , so and is odd. In this case the range can be divided into and . Let be the array that will hold the products. When calculating: 

Where the first zero equals 's memo (or accumulated value), represented by the block variable , is the first character of and is that character's index in . By writing the block variables as , we obtain, using disambiguation and parallel (or multiple) assignment, the following: 

The way I've displayed the error messages may not be what you want, but that would not be difficult to change. Note that, when a file name has an invalid format, I've listed all the reasons it is invalid. When matching a substring against a regex, notice that the length of the substring is checked by including start/end anchors and avoiding the use of , and . For validity checks that involve a list of possible values, I've made the list an array of the values from your hashes, as the keys did not appear to be used. If the keys are needed, those arrays could be replaced with hashes. A potential problem with this approach is that it's not very flexible. If, for example, a validity check were changed to involve something other than matching a list or a regex, it might be difficult to alter the code to accommodate it. I initially considered a different approach that offered greater flexibility. It retained the array of hashes, , possibly changed somewhat, but also had a module that looked something like this: