This allows you to keep all your item related declarations together. Also, inherits from , but it has the same constructor and fields, which makes it seem redundant. You don't seem to be doing any typechecks with it, so you can just instantiate keys with the class. (Consider naming the classes and , because each class represents a single instance of that object). You can then just check if the item name matches the room's required key name. 

Try to pick a more description variable name. Also, you shouldn't store large constants like this in your program. What you can do is store them in a text file and read them in from the program. 

Not really, the code is still a little wet. Could use a little more DRY. It seems like code that is very similar to this is repeated a lot, but with slightly different parameterization. 

Welcome to Python, and welcome to Code Review! Here are some basic tips to help you along. 0.5. EDIT: I think you also have an unused import. is not needed. 

You're correct. You definitely don't need that many times. You can set it to false in the before your conditional checks because it is only set to true if the item matches your criteria. You can use regex to do most of your matching. It would cut down on a lot of logic. For example: 

Make sure you thoroughly document this in your code though, because this sacrifices readability for brevity. 

To invoke these methods, I would then have to export the models to the external calling file, which seemed like bad practice to me because I would then be exposing unnecessary internal parts of the module. My reasoning for designing the module the way I did was so that I could abstract away the complexity and only expose necessary methods. Is this good practice or am I approaching this paradigm completely wrong? This code works and accomplishes what I want it to do, so it falls under working code as per the site guidelines. If I invoke the exported functions in a one-off script however, the function will execute and then the script will hang because was never called. As far as I can tell from the mongoose tutorials, database code is supposed to be wrapped within a call, though I am not entirely sure how that works since the code that I have above works fine for database access and update. Should I wrap the functionality here with , and if so, what is best practice for doing so, or should I wrap the calls with in the external file invoking these methods? Is there a better way to do the bulk insert in the function? 

Again, pick a more useful variable name. You want to be able to come back to this in 5 years and still understand what is going on. Don't repeat yourself. 

For readability and clarity, put each of your classes in a separate file and import them from a runner script or game script. Why the need to do this? 

This is much more concise and conveys the same amount of information. Underscore prefixed function names. 

You're off to a good start. Keep reading and learning. :) Here are some nits and improvements for you: 

Anything involving styles should probably be in an external CSS stylesheet. You can paste your HTML into the question and make a runnable snippet so that we can try out your application. 

Consider following a style guide like PEP8. It will make your naming conventions much more consistent as well. Most developers will name classes with upper camel case, variables with lower snake case, and class methods with lower snake case. Let's talk organization and architecture. Your OOP doesn't look too bad, but here's what I would suggest: 

Generally, this is a bad idea and goes against the principle of DRY. An alternative is using a Python dictionary/list to store the hangman states. For example: 

You may want to take a look at ES6 classes. This is entirely up to you, but some developers will do to cut down on the verbosity of the code. This allows you to type less and increase readability. Use of ES6 template literals and arrow functions may help shorten some of your code and increase readability. Instead of this: 

as implemented above is computationally expensive. Depending on your use case, you may want to consider using regex. Don't pad your question with lorem ipsum lol. 

Making a board class would be advisable and would help you refactor some common functionality. You could implement bound checking methods in there. 

As mentioned in other answers, list comprehension is the fastest way to solve this. However, I'd just like to point out that you should also consider using a generator function if it suits your needs to prevent the need to load the entire dataset. 

Prefixing with an underscore is generally a developer convention in Python indicating that the method is private. Given the context of your function, I don't think you intend for your code to be a module whose functions are imported and used elsewhere. Having the underscore prefix seems unnecessary to me. Too much abstraction? 

Concatenating the address and postcode seems arbitrary to me, if you did the refactoring as mentioned above, you could shorten it to: 

This one is a little subjective. For an algorithm like this, it makes sense to only write pure functions as that can make debugging easier. Your code is readable and clear, if a little contrived, but I wouldn't worry too much about this. JavaScript is sort of a weird language to ask this about since most functions won't follow this rule especially when you do DOM manipulation and frontend JavaScript. 

Be aware that if you are modifying the objects in the list, you should use the copy to make a deep copy of them if they are not primitives. Try to make your code less verbose. 

Your function should be dedicated to its functionality. Have all the printing done externally. You don't need as a parameter. Have your function return or . It's much more useful and reusable that way. Having it return also allows you to exit the function early if you know the arrays are not equal. For example: 

You should feel suspicious any time you're repeating the same code over and over. Consider refactoring into another function whenever that happens. Avoid using to exit your programs. It's like killing your program with a chainsaw. Use a or to end the code flow. It's good practice to wrap your main code in a function or guard. 

Definitely do not create the URL that way without sanitizing the input. You can a package like sanitize-filename to prevent malicious users from messing with things on your server. There are a few ways you can address this: 

This looks a little more readable. However, someone reading this for a production codebase would have to actually figure out what each expression did. Let's rename some variables and make this easier to digest. 

Overall, the code looks clean and readable, so here are some basics nits and tips for the code snippet in your question. 

This allows you to keep all the world related logic in one file. You would then create a separate Python file that takes this and runs the game. 

While we're addressing this function, lets discuss code convention. You're using lower snake case, and your naming conventions are consistent, which is good (I suggest taking a look at the PEP8 style guide for a concrete set of rules around Pythonic code). However, some variable names are a bit too long. Descriptive variable names are good, but providing redundant information is not. 

As an additional comment on your variable names, long and descriptive variable names are good, but you should strike a balance. Variable names that are too long or convey unneeded information can and should be shortened. For example, shortening to , since one can infer that your functions are supposed to operate on algorithm elements. Why not regex? 

and I am guaranteed that the objects are already sorted chronologically by . I'm sure that this code can be vastly improved. 

Refactor the method to check if is in . Put APPS_MAP outside the functions so it can be accessed as a global variable. 

You're asking for elegance and conciseness. Elegance doesn't always mean short/hackish, and neither does conciseness. You should never sacrifice readability for brevity unless you're codegolfing. As per your comment, just because you can read it doesn't mean the next maintainer or developer can. Someone (maybe you) revisiting this in 5 years should know what the code does without having to pick through it. Let's start by breaking apart the code into its components. 

You could probably put that in a helper function somewhere. Have you considered using an XML parser to tokenize this? Or using the native JS DOM to store your generated HTML? 

If you don't know how deep the object is nested, then recursion is a pretty solid way to go. If you want to try a more hackish solution, you could also use and regex to extract the date fields from deeply nested objects (not suggested). Please provide more examples of valid objects to sort though, your code seems like it would break on certain instances. 

You get the point. You should refactor further to make the code easier to maintain and develop. Now on the other hand, if you're looking to use every JavaScript hack in the book to golf your code, you could use instead of . For characters, you could use the following to generate your date range: 

The following is a snippet from a script I have that fetches a list of objects representing requests to a server and graphs them using C3.js. I've only included the relevant code that parses the list of request objects for relevant data. 

It seems like is checking to make sure only one field is non-zero. Here's a quick one-liner replacement. Put the statements outside this function. 

If you're nitpicky about the , technically doesn't exist since all JavaScript numbers are floats. Use instead. See this SO post about rounding to 2 decimal places. Using it is completely up to you, there's nothing wrong with the way you're doing it. (This suggestion is slower, but looks cool I guess) 

You can use this in all sorts of ways depending on how you want to refactor your functions. , , and the other like functions are just aliases. Why not just name the functions that in the first place? Use an guard for your code and wrap your main code in a method (just convention, not really necessary and varies since you're not importing these modules anywhere else). 

For a small code project like this, it's not that big of a problem, but in the future consider defining accessors and mutators like to prevent accidental modification. 

You used a regex to split the string, why not use one for removing the parentheses and spaces? You can use a regex similar to this to accomplish the same task as the code block above: 

This would handle 3 digit date codes, but you could probably come up with one that fits your situation, and it would be trivial to handle letter + number codes. Using regex would make your logic a lot more readable and self-documenting. Your comments are good, but it is still very difficult to follow along. 

These are just some basic nits and optimizations. Other than that, I don't see any major glaring errors. Happy coding! Python Experience: LEVEL UP! 

I have the following code on my server that takes a string and inserts newlines in such a way that the string is separated into lines, all of which are shorter than in characters. This ensures that the text, when printed, will fit within a certain width. 

Very common in JavaScript. You should explore node.js if you're interested in learning more. Nit: . Aside from being a completely uninformative and useless variable name, this declaration isn't needed. You can rewrite the statement as: 

I have the following code in a file called which will handle all the database operations for my small application. For some background, this application fetches stock data from an API and stores it in a local database so that future requests can pull the data from the database instead of making a network request (basically a rudimentary cache). 

What if the user enters a non-numeric coefficient? Or what if the user enters 0? This is also applicable if the user tries to divide by zero in the function. Consider following a style guide like PEP8 to make your code more readable and consistent. 

For a small game like this, your implementation of is okay since you don't expect to have lag spikes. has no guarantee for its timing and it's behavior can vary from browser to browser. You should use to do this instead. Additionally, it is a bad idea to have your physics engine tied to your FPS/tickrate and it can cause unexpected behavior with more complex games. You can get around that by calculating the delta time between each update and using that to do your physics calculations. 

Other than that, the code is mostly understandable and readable. It is a bit monolithic however, which I suspect is why no one has reviewed it. 1200~ lines of code is a bit of a daunting task to read through. I suggest you break it up into submodules. Put all your utility/formatting functions in a file, and put all the typesetting functions in another. That's one way to go about doing it. Happy coding! 

Consider using a style guideline like PEP8. This is more of a general suggestion and will make your future code much more readable and maintainable. Consider defining all your constants at the top of the file. This makes them easier to find. In other languages, you cannot use a variable before you define it, so this is a good habit to get used to as well. Python is a self-documenting language. Generally, in Python and other languages, comments should not be used to state the obvious. Use comments to explain algorithms or non-trivial aspects of the code. 

It is much more Pythonic to define your functions outside the user flow and put the user flow inside of a function. The flow should look like this: 

This comment doesn't really add much value. Enclose your main code using an guard. Avoid putting it in the global scope. 

You can use the truthiness of instead of to check if an object is an array, which yields the following code: 

What happens if a player doesn't remove a card that was in their set of player cards, and then enters an answer that's not or ? Your function has a handler for that, but doesn't prompt the user again for input. Suggestion: 

This class reads a log file stored on my server, parses it, and returns it. It also caches the data so that subsequent calls to get the analytics data will not have to read from the file. The analytics files will be relatively small, so memory usage is not a concern. The callback passed to is expected to accept an error as its first parameter and data as its second parameter. Suggestions on improvements and cleanups are welcome. Link to file on GitHub 

If this is for something like unit testing, you should use a unit test library to like Mocha or Qunit to validate the behavior of the function. What data types are you dealing with? Are you only concerned with numbers? Do you want strict type checking and/or null checking? 

One important thing here is that you should put the game logic inside an guard. This prevents the logic inside from being exposed globally. This method of organization is just one way to do it. Of course, there are other ways to organize your game that make sense, but in general you should group together similar things and prevent circular dependencies. Avoid accessing member variables directly. 

Some developers will do so that getting an element by ID requires less typing. This is completely up to you. Comments should explain things that are not immediately obvious from the code.