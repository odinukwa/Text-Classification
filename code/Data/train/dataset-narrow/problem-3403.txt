Appendix C - Logical level converter using TXS0102 Now I know that Rpi GPIO can directly drive the relay module, but there are two problems. First, the GPIO signal with a long connecting wire is noisy, therefore not that reliable. Second, the flywheel diode 1N4148 might not completely suppress the coil back EMF, and if unluckily the 1N4148 breaks down, or not properly connected (poor contact, dry soldering joint etc), the back EMF might damage the Rpi. So I decided to use a logical level converter to shift up the Rpi GPIO signal from 3V3 to 5V. I first tried TXS102 converter and found it working well. Besides shifting up the GPIO siganl, the noise at the high level is also greatly reduced. 

I think it is important to use the 2N2222 based logical level shift up and buffer to take the 10~20mA sinking current from the optocoupler. If Rpi GPIO is directly connected to the optocoupler, the 15mA current might damage the GPIO pin circuitry. Rpi-SainsmartRelay-Wiring My suggested wiring is as below. 

The result was good. The 4 relay modules click and LEDs blink at 25cps as expected. The Rpi GPIO output signals stayed near 3.3V, and UDN output signals around 4.0V, implying that no input was overloaded. 

However, I found a big problem when feeding the converted 5V GPIO singal to the relay module. The relay still turned on and off as before, with the 3V3 signal, but when I used the scope to check out the waveform, I found the very surprisingly that 5V signal dropped by half, to 2.2V. I suspected the reason was that TXS0102 can sink current much better than sourcing current to the relay module. To verify my guess, I fed the 5V signal to another relay module, a pull down photocoupler type, model MK01. This time I found the 5V signal did not drop any noticeable amount. So I quickly concluded that the NPN transistor type relay module is a bad choice. I would stop testing this kind of relays from now, and move on the photocoupler type of relays. I also tested another photocoupler driver module MK101. This module has a jumper to select Higher trigger or Low trigger. I found that for Low trigger, the TSX0102 converted 5V signal level is not affected. But when Low trigger is selected, the converted 5V signal level dropped to around 2.5V, though the relay is still working. 

Welcome to Raspberry Pi Stack Exchange! I googled and found (on the official Adafruit instructions page for the TFT) that their files (the drivers/modules needed to run the TFT correctly) are for Raspbian only. You could compile your own kernel using their Patchfile but Adafruit doesn't have any tutorials and don't plan to support this in any way. Source: 

It won't destroy your Pi, as can be seen in the tutorial the Potentiometer is simply for contrast. QUOTE: 

I doubt it. There weren't any real changes to the core components or software of the Pi, the SoC remains the same, as well as the chip driving the USB/Ethernet. The changes were simply the extra USB ports, more GPIO, a new power circuit, a new port for audio/component video, and a redesigned board. Thus, if the Model B didn't work, I don't think the Model B+ will either. 

You've got the SQL command switched up. The should be within the and the should be where the is currently: Wrong: 

I believe this is what you need. As of right now, I believe your code is attempting to run the function within SQLite, and I don't believe SQLite has that. EDIT: My bad, you probably can't execute a command within a Python SQLite command/connection. This should fix it: Correct 

and changing the index from -2 to 0 via adding to the file. However, this wasn't working. The correct way to do it is to add followed by . Essentially what doing this is forcing the default sound module () to be disabled while the usb sound module () is enabled. What I believe was previously happening with just adding was that the module and the were conflicting, with both being enabled. 

This feature was available when using firmware from 12/04/2012 or later. However, this feature is removed from default firmware as of 18th March 2014. NOOBS still supports a safe mode, using the same gpio pins. If you are using a firmware version between 12/04/2012 and 3/18/2014 and wish to learn more about this, you can read a topic on the Raspberry Pi official forums and on the eLinux page. 

Have you looked into putting the the root file system on to an external HDD or USB pen drive? It's faster (in the case of the external HDD, as for the USB stick it is actually slower) and it extends the life of the SD card, as the SD card is simply used for booting; the root file system is stored externally. This also makes backups/restores easier, as well as transferring files. Here's the site I read about this on: $URL$ and here: $URL$ From the first post: 

Below to be shortened or deleted # Appendices # # A1. Opto isolated / Photo coupler relay module board and schematic # Opto isolated relay module has a photo coupler which is 4 pin IC. The picture below shows a photoCoupler PC1 (with its 4 pins labelled 1, 2, 3, 4 in green) and a transistor Q1. The ICs are not always marked. In this picture, PC1 is EL354, and Q1 8050. 

/ ... End of Appendices ** * Long Answer To be deleted * ** This long answer is too long winded and messy. I am now trying to remove the irrelevant paragraphs and perhaps replace them by asking relevant question and answering myself. 

Then I tried the MCP23017 io expander, and mux 4 of them, so that I can control 64 relays together. You can get the idea of the i2c mcp23017 way from below. $URL$ The above are a bit challenging and might take you weeks to catch up. If you are in a hurry, I would suggest you AdaFruit or SparkFun's tutorials for beginners. They also sell newbie friendly modules to help you jump start. 

Get a jumper wire. Connect one end to signal/input pin of relay module. Hold the other end and touch the Vcc(+) and Gnd(-) pin and check the results below. 

Now I am trying to vary the IN to transistor base resistance from 220R to a higher value, hoping that now even Rpi GPIO High of 2.4V is high enough to turn off the relay. 

Actually logic level shifting might not be the easist solution for you. You may consider throw away your BJT transistor input module and get photocoupler based module. Then you can keep you gpio pin signal at 3V3 logic level, and the 5V0 power at JD Vcc is strong enough to energize the coil. There are many advantages of using photocoupler. You might like to google to know more. 

However, I very soon found OP's relay module spec a bit unusual. It says drive current at least 4mA Ib, to switch on PNP BJT Ic to drive the 55R coil at 90mA. This implies a DC current gain of 90/4 ~= 20. I found my first PNP to simulate OP's module is not suitable, because the Ic(sat) too big. So I replaced it by 2N5401 (see appendix below for a spec summary), which at Ib = 1mA, Ic = 50mA, hFE already is 50. In other words, this 2N5401 module input current of 1mA, 1/4 of OP's module, is enough to switch on the relay. So I cannot simulate OP's module of 4mA input, 2.4V+ relay switch off condition. Instead, I just tried to bias the PNP BJT to trigger at 1.0V+, which is high enough to entertain RPi's 0.6V- Low. And the trigger/activate deactivate band is around 0.2V-. I repeatedly verify that the trigger signal 0.2V to 1.0V will activate the relay and 1.0V to 2.4V (rpi's high So Rpi's High of 2.4V+ must be able to switch the relay off!. After manually tested the module using a 0~5V power supply unit to simulate Rpi/Arduino GPIO signals and found everything working as expected, the time has come to do the real thing: actually using Rpi GPIO signal instead of the 0~5v PSU, using an working python program. But to my surprise, the program does NOT work! The reason is that I forgot there is something called hysteresis. The relay switch hysteresis characteristic is as below. / to be continued, ... Why the set-GPIO-to-input trick can switch relay off 

I am following the Baking Pi Raspberry Pi ASM OS tutorial here, and I thought that it would be cool if I could create a compiler/runner for like, BASIC or a language I create. I don't have the skill yet to create something like that, so hopefully I can get an answer that will help point me down the right path. My question is, can I (I'm guessing with a bit of work, nothings free/easy when it comes to low-level programming) get my ASM OS (that I created following the the tutorial, following the tut word-for-word) to run programs that run on the Raspberry Pi in Raspbian? Like a Python or BASIC interpreter or a simple text editor? It should work, I'm thinking, because I'm still using the same architecture (still the same ARM SOC) as what runs Raspbian, so shouldn't the same programs work, even if I'm not using the same OS? I'm thinking that I would have to create a program/system file that allows me to load a C/C++/C#/etc. program into memory and execute it, but I'm very new to this low-level programming world so I don't where or what to look for. 

The smaller partition is going to be your boot partition. In Raspbian it is anyways. I have yet to use NOOBS very much, so it may be different. The first is also most likely the boot partition, so just take the Disk name (...) and then tack on and the partition Number (marked below): 

I believe it may have been a battery/sync issue. I've used it since and I had to swap the batteries out and re-sync the keyboard and receiver. Granted, this was on Raspbian this time, but I believe it should work with NOOBS as well. Sometimes the answer is the simplest thing, just sitting there waiting to facepalm you. 

The OP has resolved the issue on his own, it was an issue with the feature, in this case, the OP hadn't disabled the safe mode feature in the file. This issue is common enough (I have this issue consistently on my Pi after messing with breadboarding,) and is caused by bridging (connecting) pins 5 & 6 on the Pi's GPIO headers. 

part, it just tells me . Does anyone have any clue why this is? I've run and I'm running now, but I have no clue why it won't download those two packages. 

ULN2803 and UDN2981 can be directly driven by TTL or CMOS logic signal with 3.3V or 5V supply voltages. Their rated 500mA outputs with clamp diodes are suitable to switch relays and stepping motors. 

I show below one similar relay module. I did the test without connecting to the rpi (especially not connected to the 5V pin on the RPi 40 pin socket. My module uses a different coil and NPN transistor instead of PNP. But I think the electrical characteristics should be very similar. 

In the above diagram, if GPIO is Low, relay is triggered/activated/switched "on", electrical circuit is "closed" (therefore electrical current flows), motor is switch "on". Your "open" seems to mean my "on", your "closed" means my "off". I am still confused. Let me try again. Do you mean that if you run the following statements: 

ULN2803 and especially UDN2981 are not so common. They have 8 channels and therefore have a bigger 18 pin DIP package size. For less channels, more common 74HC03/04 or 74HCT125 with 14 pin DIP package are more common and easier to handle.. 

You expect drain LED turned on in Second One, then both ATO and drain LEDs turned on in Second Two. But the problem is that in Seconds Two, drain LED is turned off unexpectedly? / to be continued, ... Appendices A1. SunFounder 2 Channel DC 5V Relay Module SunFounder 2 Channel DC 5V Relay Module with Optocoupler Low Level Trigger Expansion Board for Arduino UNO R3 MEGA 2560 1280 DSP ARM PIC AVR STM32 Raspberry Pi Relay interface board, and each one needs 15-20mA Driver Current Equiped with high-current relay, AC250V 10A ; DC30V 10A Standard interface that can be controlled directly by microcontroller (Arduino, Raspberry Pi, 8051, AVR, PIC, DSP, ARM, ARM, MSP430, TTL logic) Indication LED's for Relay output status 

I read that you don't need to use the eeprom to do DAC. You just give the command and input code to the data register and do the DAC. In short, we will start without the EEPROM. I also read that the EEPROM has a default input code which is at the middle point of the range. So if we use 5V0, we will get 2V5 output. 

How to modify the Beefcake module to make it compatible to 3.3V logic The Beefcake NPN transistor has a current limiting resistor R2 of value 1K. This resistor limits the base current at Arduino 5V logic high level. The base current within limit, after amplification (usually hFE > 100), is big enough to engerize the coil. Calculation of Arduino 5V GPIO current into Beefcake relay module: Arduino current i ~ (4V [Arduino High] - 1V [Vce(sat)]) / 1K [R]) = 3V / 1K = 3mA However, the Rpi's logic High signal is lower than Arduino, so the corresponding limited current is smaller and after amplification is not big enough to drive the coil. Rpi current i ~ ((3V [Rpi High] - 1V) / 1K = 2mA The modification is simple - just replace 1K R2 with a smaller resistor, say 510R. Rpi current i (after modification) = (3V - 1V) / 501R = 4mA I am making education guess based on circuit analysis and experimentation. I think my guess is 90% likely correct. Risk Analysis Though the small signal NPN transistor 2N3094 can be used for small load switching, it is not that reliable. For relay switching, it is safer to use power transistors such as SS8050, UDN2981, specially designed for inductive loads. The OP wants a safe method which would not fry his Pi, so for reliability, a source driver such as UDN2981 is the way to go. / ... # Solution 2 - Using UDN2981 to drive the Beefcake relay module # The comments point out that the OP's Sparkfun Beefcake relay module is high level trigger, therefore the commonly used sink driver ULN2803 cannot be used. A driver similar to ULN2803, but current sourcing, rather than current sinking, should be used instead I think UDN2981 is a suitable driver for the OP's relay module. I verified successfully UDN2981 driving a high level tirgger relay module similar to the Beefcak, and ULN2803 a low trigger one. Below is a summary. UDN2981 controlling High trigger, NPN transistor input type relay modules I first manually tested UDN2981, without connecting to Rpi, to blink 4 LEDs, to make sure the circuit is working OK. 

All of these come packaged up in a nice little box that you can order from The Pi Hut for £5.00 (inc. VAT), €6.26 (inc. VAT), or $8.39. There are also several free (6 currently, 8 planned) worksheets/projects that you can do with your Pi and the CamJam EduKit that you can download from the CamJam EduKit page on the CamJam site. Hope this helped some! 

As far as I can tell you would just use the ribbon cable, and then connect the wires from there, acting as if the ribbon cable was the Pi's GPIO. As Steve Robillard said, the ribbon cable will be acting as the Male-Female wire/jumper. If you are tight on space (such as a portable project or a project where you need to connect a lot of jumpers,) then you probably will want to purchase the cables, as the ribbon cable takes up a lot of space. Instead of a 1:1 used GPIO to breadboard space, you'll have used up about a 15 by 3 area on your breadboard for the use of only a few GPIO pins. While there are only 13x2 GPIO pins, there is overlap on the edges of the jumper's board, leading to a loss of breadboard holes. 

Explanation: You'll notice comes up a lot in this script, it starts 4 of the 6 lines. That's the statement, or keyword, for print ing something to the screen. You'll also notice that whatever's within the area between the Parenthesis is printed. However, in the case of and , you'll notice the quotation marks end, and are followed by a comma, then a variable ( or respectively.) Like this: . This is one way, in Python, you can print data that a variable is holding. The commas insert a space while the variable tells what to print. And that brings me to the next point, variables. In the and lines, you'll notice a word, then an equals sign (=), then input. The first word ( or respectively) is the variable that the input statement will put its input in. In simpler terms, the first word stores what you give the computer when it asks. If you enter for the first question, the computer will store in the variable. 

One thing you could do is overclock the Pi. This would increase overall speed, and should help with your issue.