The IP address on a home network wont be invalid. Your home router allocates dynamic internal IP addresses to devices on your network, these are not accessible from outside. However, you can tell your router to create a link between the outside world and a device on your internal network. This is called port forwarding. Essentially you tell the router which IP address on your home network you want to communicate with by specifying a port on the external IP. There is a resource here that explains the process in more detail. One caveat is that your ISP may assign your router a dynamic IP address itself, which may change every day, week, month, each time the router is turned on, or at any other random time. There's not a whole lot you can do about this. Some ISPs allow you to specify a fixed IP address that doesn't change, or some offer the service at an extra fee. In summary, you can communicate with your Pi from outside your home network, but you will need to forward the ports on your router, and it will be easier with a fixed IP from your ISP. 

I'm afraid you're going to have to fix the installation manually. You can download the relevant bin and elf files from the Raspberry Pi GitHub repository. Then mount the boot partition of the SD card and copy the files onto it. If this doesn't work then something more serious has gone wrong and you're going to have to re-flash the entire image. However, you should be able to save your data if you can mount the SD card as you can simply copy off the files you want. They will be in the directory . I hope this helps, let me know if you have any more trouble. 

It apparently has a . However it will be seriously limited by speed. It is only capable of transmitting at 115200 baud, which is significantly slower than USB. There will also by no way in which to map the UART pins to the existing USB interface, meaning that items connected wont be recognisable as USB devices. I might be able to provide you with a better solution if you are able to state what you are trying to accomplish. 

The parameter will mean that you don't have to wait for the repository history to be downloaded as well (since we wont be using it). Then add the binaries to your PATH variable: 

That command essentially renews the symlinks between the two directories. So, the default site configuration is broken, but it's not actually needed. You can safely delete the contents of : 

Nope, sorry. There is currently no way to run Netflix in Linux without emulating a Windows environment, which is something the Raspberry Pi will not have the resources to attempt. 

As long as the webcam is Linux compatible it should be possible to get it to work. However, if there are not ARM specific drivers available, you will have to build them yourself, which is often not easy. 

If you want the partition to mount automatically at boot then you need to add an entry in the /etc/fstab file. 

I'm pretty sure a strong enough magnetic field would have a serious effect on the Broadcom SoC, especially the data it stores in ROM for booting up the Raspberry Pi from the SD card. The question is; Is the magnetic field produced by your magnet strong enough to cause permanent damage? Probably not, but why would you want to risk it? 

The naming convention in this folder controls the order in which scripts will run and what they do. The first character tells you if the script kills or starts a process ( or ). I'm pretty sure the order of execution is determined alphabetically, so you can control it easily for using the next two characters. For example: 

NTPD appears to run successfully and poll the time server, however it doesn't actually set the time. 

If the system is running idle, it wont be interacting with the SD card. In fact, some of the boot process should be occurring in RAM. I would expect it to only halt when reading the image, starting daemons or mounting filesystems. Try creating or copying files, or unmounting filesystems when the system is 'running' after you help it boot. You should find that this is when it fails. 

If you symlink your script into the runlevel directories then you can control the order. I'm not sure what kernel xbian runs on but the runlevel directory is usually something like: 

Unfortunately, when packages with config files are upgraded, the files can change. To deal with these files appends them with the suffix . Merging of files can be a tricky process. You can find more information about them on the Arch Wiki. You can find your files with the following command: 

An incredibly easy way of resizing the image is to use one of the tools called . This of course depends on the fact that you have installed (which I know you already do Alex). The command looks like this: 

The timekeeping is all in software. Without using NTP there is no timekeeping. If you want to check if the clock has been set then just use to see if it shows the Unix epoch, which is what the Pi will default to. 

There is an application for this called . It will hide your mouse after a set time if there is no activity. I'm not a Debian user, but it looks to me as if it is on the repositories: 

Because the image that you flashed to the Pi is only 2GB, that's all the space the root partition can see. Either you can resize the root partition or create a new one with . 

I have had the same issues in Arch. Some files work perfectly, others not at all. I'm not entirely sure if this applies to you, but it's really important and fixed my issues. Sometimes when I upgrade my firmware my media player stops working and I have to re-install it to get it to work. Some of the libraries that interact with the GPU for video decoding are part of the firmware package, and I believe that the issues arise when these change. The applications that depend on them then need to be upgraded too, or possibly linked to the libraries again. I'm far from an expert at this topic, but perhaps someone else with more knowledge can elaborate on my guesswork, or perhaps tell me I'm completely wrong. Update: You update the firmware by running: