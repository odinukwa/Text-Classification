I faced this issue, a few years ago, when I started taking on .NET development projects. For instance, I would run into a piece of code that I never really heard of, but I see that there would be a lot of chatter about it online forums/stack overflow and so on. The more I continue to work on the project, the more I realised that I simply did not know so many things aka gaps on what I have self-taught. At that point, I decided to go to the official docs of .NET (MSDN), read through the whole thing. Simultaneously, purchased the official Microsoft recommended books on dot net C sharp, and went through the entire book. When I was done with MSDN and the book, I had an entire list of things I had never even heard. One by one, I self-learned them as well, filling in the gaps. I had to do this many times (for windows phone, windows 10, web and so on) and each time, this method has worked to my benefit. 

Write and Draw on a Projected Board. [I must acknowledge that somewhere above no comprende has commented this already, but I have my own variation. ] As much as possible, I always project on a board on which I can write. That way, I can zoom in, and draw circles and shapes around the code I want the students to focus. However, a huge problem is that the projector will start projecting on me, and since my powers of invisibility have left me, this isn't always ideal. So, I use the following to focus in my sessions. 

Some personal experience. I have a PhD in computer science and have had a very successful 40-year career in software development. But often, when presented with a new concept, I have had great difficulty "getting it". I think the problem happens when you build an incorrect mental model of what is going on. I think the first time this happened was on first introduction to algebra: with x=3 and y=4, I was convinced xy had to be 34. There's nothing stupid or ignorant about this, and it doesn't mean the pupil will never overcome it: there's just a misunderstanding that has crept in somewhere, and I think it can be very hard for a teacher to discover where that misunderstanding lies, and correct it, because the teacher simply doesn't realise where the faulty step in the reasoning occurs. Later, when introduced to programming, I remember I found it really hard to understand function calls. I don't know now what the problem was, just that I had great trouble with it. (I also found it hard to grasp that xy was no longer 34, or even 12, it was now completely unrelated to the values of x and y.) In recent years I've taught a good number of XSLT courses. One of the areas where I find students really struggling is with recursion. The main frustration in teaching this is that you don't know why students are finding it difficult. Sure, it's a very abstract concept but it becomes so second nature that you no longer see the difficulties, and that makes it hard to help the students overcome them. 

We don't have Scheme in our entire country (here in India) but that honour goes to C programming language. For the purpose of my answer, substituting C for Scheme, I keep asking myself, why bother with C. After that 1 semester of C, I have never used C professionally anywhere. In fact, once I step out of educational purposes, C becomes useless. That begs the question, after almost 25 years, why are they still teaching C? Why not something else? I think, why they are still teaching C (in my country) and Scheme (in yours) is probably because it is ubiquitous. there are any number of books written on C. More importantly, the faculties who teach them ( I think most faculties change their jobs once in 60 years) can teach the same thing for the rest of their lives, use the same lab manual, and use the same code, and ask the same questions, use the same evaluations. From a strictly logistical point of view, it makes sense to teach C 30 years ago, and 30 years hence. Can you image the mess, if every five years, the universities change their syllabus? Thats a logistical nightmare (not to forget other challenges) no one wants to deal with. For instance, one university could decide to go with C sharp, and another with Java. That creates all kind of problems. However, if all universities agree (which is how things are now) to simply keep using Scheme (in your case) and C (in my case), life becomes simple. Further, the foundation that you get by learning an ancient language is that, everything that came after it, be default, would be easier. I learnt to ride a bike (as in motorcycle, not bicycle) in my dads old bike which was, well not that good. However, because I drove the tough one, all of today's bikes seem like child's play. Although I don't use C itself, anytime I learn a new language, I unconsciously compare it to C, and learn from that. Update 1 : To add some context, I have been part of the IT industry for 11 years, and 5 of them as a developer/trainer/educator who travels widely. I am sure C is used somewhere, I haven't seen one single enterprise usage of C and I have worked for startups, small companies (less than 100 employees) and for MNCs (more than 2000 employees) and never ever has any division, anywhere talked about C, used C or implemented C. Again, no disrespect to C (or its legion of fans) but I request that my opinion be taken in this context. 

while both recursive calls of the right branch, since it was just a node without any children, have trees that are empty, which is None in python. Thus, they fall to the base-case, which means it is evaluated as 0. So now the original return value is like this 

Note, this evaluation was not performed according to any formal evaluation model (see substitution model or environment model); it was merely to help build intuition for how evaluation could be done. Extra (tail-recursion): I mentioned earlier about how recursion does not necessarily have these pending function calls that much be recursed back to once they finally have the result of the recursive call. Consider a recursive function to find the sum of a list (ignoring the python built-in sum()): 

How to use recursion Let's look at an example: maximum depth of a binary tree (where a tree with a single node is depth 1). A recursive solution in python might look like this: 

This indeed would have pending recursive calls, as it waits to add lst[0] to the result of the recursive calls. We can make this tail-recursive by accumulating the sum of the list in an argument that is simply returned unmodified at the end: 

First, note the difference between NP and NP-hard. NP simply means verifiable easily. NP-hard means verifiable easily, but also means that the problem is as hard to solve as the hardest problems in NP, which are not known to be easily solvable (see P = NP). For describing what it means for a problem to be NP-hard, I have had success by referring to the canonical Traveling Salesman Problem. I might introduce the problem like this: Given a list of cities, the distances between each pair of cities, and a number $k$, is there a path of length ≤ $k$ that visits each city and returns to the start city? And then I would say something like: If someone tells you a path to take i.e. an ordered list of cities, you can quite easily check to see if it includes every city, starts and ends at the same city, and is of length ≤ $k$. However, trying to come up with that path in the first place is more difficult. You could imagine trying every possibility exhaustively, checking if the conditions hold for each one. While there are algorithms better than this brute-force approach, which has runtime that is exponential in the number of cities, none have been shown to be polynomial in the number of cities. 

A quick online search led me to this. A Beginner's Guide to Access Technology for Blind Students It covers all the essentials 

I have no recommendations for the theory part but since you are asking for implementation advice as well, here we go. If you are looking to use C sharp (you haven't specified a specific language of choice) then, as a dot net guy myself, I would recommend you start your self learning on concurrent programming with .NET implementation of same at Threads and Threading. The link provides with what you can (most of the things you have discussed can be done in C sharp Threads) and what you cannot do. If you wish to dig deep, there are no specific books on threads in C sharp, but you can use the reference book I used which contains detailed implementation notes on the same at C sharp 70 483 

What I do is, I emphasize the fact that printf is like shouting, which does not help me as I need the answer on a piece of paper that must be returned explicitly. 

First up, the logistics. I had a detailed discussion with the HOD and also with the students, and convinced all of them to come for additional classes (I called them Bootcamps) The Bootcamp was a 2 day affair ( 6 hours each ) and was held on a holiday. No attendance or anything like that. Students who are serious can come (and 80 % of the class showed up) Taught the basics of OOPS. I essentially summarised the entire semester worth of contents into 12 hours. 

Firstly, I think CS degrees vary widely in how "theoretical" they are. Some try to teach you about programming languages and even vendor-specific products that you are likely to encounter in the real world; others focus much more on teaching the fundamental principles. Personally (as someone who has always worked in industry) I would much rather have people who know the principles and the theory, because that knowledge will remain useful for much longer. But whether your background is theoretical or practical, on your first real project there are going to be a dozen technologies or tools you have to master that you have never seen before. Secondly, I think CS (and even Software Engineering) courses find it very difficult to teach the things you will only encounter on large projects: how do you grapple with half-a-million lines of code, how do you work on a team with 40 developers? Then there are the non-computing aspects of the job. How do you handle a boss who has made an incorrect decision? How do you handle customers who try to make design decisions for you, and do it badly? How do you handle an experienced and respected senior developer on the team whose knowledge has actually become rather rusty? How do you manage conflicting demands on your time? One of the things that I think you can only learn with experience is to acquire a mature attitude to risk. Many of the decisions in programming are concerned with risk. Should we release now, or write more tests? Is it wise to use a new open-source library that has just become available? Should we move forward to the latest version of X? We know the customer's stated requirements, but how likely is it that they will change? How much should we invest in extra resilience or security? In the end, these are the judgements that make a project succeed or fail. 

I cannot think of a better alternative for LINQ to SQL, especially in Visual Studio 2017. You have said that you have spent 2 years already into MVC, which means, familiarity with MVC can be assumed. If so, I would say that don't give up on the LINQ + SQL + EF + MVC ( I will simply refer to this as the MVC combo ) combo yet. I am guessing that you have already looked at this link. I use that in my introductory sessions on MVC, and even newcomers ( I mean, people who have not even tried MVC, or any of the MVC combo components ) have found it easy to use. In my experience, 10 to 15 hours is all it takes to train folks on that (at least the basics). Give it a go, and yes, if you have questions about that link as you teach the different sections, come back and post questions here. We will take care of it for you. 

I have already looked at this and this, but it does not help me at all. I am teaching a guy who is something of a Java expert. Unfortunately, due to the mandatory-ness of the university curriculum, he is forced to downgrade himself to learning C. ( I use the word downgrade in a strictly technical sense, no offence meant to people who are fans of C ). The thing is, I am able to get him through the whole C syllabus except for pointers. More importantly, we want to use pointers inside structs, which are actually declared in a header file. I am teaching him to build sharable c libraries/header files. If you need more details, let me know in the comments, and I can share the code I am using in a repo and so on. Update 1 - I am also looking at this, but its not very clear to me. I haven't used C in a decade, so all this is a little blurry for me. Update 2 - getting even more specific, what is really happening in these two lines, that I am putting in the header file. I am defining the samplestruct in the corresponding .c file. 

and you have a variable r storing the root. If you call max_depth(r), it will try to evaluate the else clause; it will evaluate max(max_depth(r.left), ...) and then add 1 to that result. To the r.left recursive call, the input looks like this 

The r.left recursive call evaluates else clause, which means it tries to evaluate the max depth of the left and right subtrees, and add 1 to whichever is greater. The r.right recursive call also evaluates the else clause. So at this point you think of the return value of the original call to max_depth looking like this: 

All recursive paths from the right branch already reached the base-case, and now on this recursive call, all children of the left branch will as well, which means the return value of the original function is now 

Once this evaluation reaches the base-case, it has the the result of the original call to sum_list(), and it does not need to be added to, or modified in any way as you recurse back up. 

You don't need to think about how this is actually evaluated; you just define it how you would mathematically. If I somehow know that the maximum depth of the left branch is $x$ and the maximum depth of the right branch is $y$ and that $x > y$ (without loss of generality), then I know that the maximum depth of the entire tree is $1 + x$. This way of thinking about problems is one way you can use recursion. Of course, you need to make sure that the inputs to the recursive calls are in some way smaller than the input to the function that makes the recursive call, which segues into how recursion is evaluated. How recursion is evaluated To think about how recursion is evaluated, we can use the same example. In the example above, there are pending recursive calls, waiting to return (note that recursion does not necessarily have this, see tail call). To see this, suppose our tree looks like this 

A few days ago, I asked a question if I should use F sharp to learn functional programming and the discussion eventually suggested that I take up Scheme. So, I visited the scheme site (which did not say much) and then I ended up at the MIT site. and I also read on the wikipedia that there are several implementations of scheme. So, the question is which implementation ( I have given a reference of MIT implementation above) should I use for my beginner class on Scheme. 

Then, rinse and repeat the above so many times. It took me a while (a year or so) but eventually, I was ready to work in the industry. Now, years later, I switch between working as a developer and trainer, no problem. Since we are talking about transitions, I have found that while I still make a decent amount of money from training, development actually pays more. 

Intellisense aka Intelligent code completion, for those who came late, is a feature available in most modern IDEs (visual studio, eclipse. Xcode, Android Studio) where, like when you do bing search, the words are automatically prompted for you. Things like reserved words ( for example int, main and all that) and function declarations, library names and anything else that is fixed. You use this, you NEVER get a syntax error. Easy peasy. 

The ones who finish early, are also the trouble makers. I suppose that is somehow related. Once they are out, I can actually focus on guiding the ones who need my help. These early finishes become a constant source of interruption and that energy can be used on the slow folks. it acts an incentive. Knowing they have an opportunity to leave early, some students tend to put in a little extra effort learning the programs they need. That allure of leaving early can be great motivator. The slow kids also seem to be encouraged by this because they don't have to bear the gloating of the fast finishers for the next 2 and half hours.