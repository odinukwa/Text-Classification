All 3 of these only work as expected (or at all!) on Windows. Cross platform input handling and interaction with the terminal is rather difficult. 

The algebra is fine. That line wouldn't be necessary (IMHO even reduces readability), but apart from that it's reasonable. However, your solution is worse than it needs to be. It merely stays in-place, while the optimal solution to this problem can treat the input as read-only and limit the working-set to constant space. Your solution also depends on being implemented as in-place and manipulating the original list. Depending on such behavior is IMHO pretty bad design. In fact, if I hadn't checked the source of , I would have expected it to return a reversed copy instead. Which would obviously break your solution. 

Not using C++11 shared pointers with builtin reference counting? Respectively, any specific reason (like cyclic references) which would prevent these from working? 

This case of magic numbers is even worse, because this time I can't even deduce from the context what these numbers are supposed to mean. However, this time the solution is not to uses constants, there is a better solution. Remember how you didn't complete the work on ? It's time to implement another operator, . With that operator implemented, you can simply return an instance representing the offset the enemy is supposed to move, and add it to the enemies current location. Absolutely no magic number needed this time. 

Let's start with with revising what a tree is. A tree is coherent, undirected graph with a single root node and no loops. Let's compare that with your sample data (and the implementation based on it): 

Notice a difference? There is nothing modified by reference. In a recursion, there is no global state, each single recursion step only reads the data. A strange way to sort children There is nothing wrong with wanting to define an order on children of a node, but make sure you are aware what it actually means. It's still a tree, so the same construction applies. But in addition, you want to be able to sort the children of a node. Or even better, already have them sorted, e.g. in a linked list. A linked list just what you constructed with , except that you got it linked backwards, not forwards. If you really want to use this structure (I will cover alternatives later), do yourself a favor and use instead. This at allows to traverse the list of children in a more natural way. Furthermore, if you want to be able to use the linked list half way efficient, make sure that you always store an entry point to the linked list. This means in addition to , also store a on the parent node. Let's just extend the code sample for better comprehension: 

Why bother waking all worker threads when only a single slice of work was added? is more appropriate. 

Aside from messing up the state tracking on invalid inputs, your input validation in general is sloppy. Currently, your calculator happily confirms that . Say you only checked whether the input can in any form be parsed as a numerical, but not whether the field didn't contain additional garbage with potentially ambiguous meaning. 

WTF? Why is that part of the setup suddenly part of ? This class is apparently strongly coupled with . Once again an indicator that the guideline about low outer connectivity is violated. 

That is a problem. Because that is not how to properly handle an error case. You literally can't distinguish at all whether this supposed error message was generated by this function, or if it was actually read from the registry. Whenever you encounter an Exception, there are only 3 valid approaches: 

The at the end removes the trailing white space, resulting from the empty suffix, respectively the concatenation of the first valid suffix with the empty string. 

This is a huge problem. Even if you wanted to that again, you wouldn't be able to. You just threw away your only reference you had. If you would call now, your application would just crash or worse, because you must call on the same pointer as returned by . Even if you were to write this in C, you must always keep a pointer to the base address of the dynamically allocated memory region, or you won't be able to free the memory again. Even though it wouldn't had been necessary to allocate a new anyway. As you don't modify the data, but only the pointer, you could just have said in which case you wouldn't have needed to deal with memory allocation at all. 

Half of that stuff doesn't belong into the state or is redundant. E.g. all the "disabled" properties. They are only used in conjunction, and could have been derived all from a single boolean during the method. Neither does the belong into the state. It's a constant. 

Not that your input disabling logic would work properly either way. It only disables the inputs the first time an operation is performed, but once the inputs are re-enabled by a form reset, they stay enabled. Your method is literally breaking react, because it once again touches the DOM directly and outside the method. In case you haven't realized or don't know it yet: Any DOM manipulation your perform outside of is not properly tracked by react. React will assume that the DOM is still in the state interfered from , and will not update it. 

Did you just omit this when posting your code here, or did you actually write your scripts without it? 

Let's start with your solution, it feels weird, because it is. You mixed C and C++, and on top of that you even refuted back to C string syntax and pointer arithmetic. Especially in plain C, string handling is rather easy to break, even more so if the string didn't come from C to begin with. In fact, your implementation does not behave correctly in all situations. An can also contain null-bytes as regular characters. The very same null bytes which double as sentinels when attempting to interpret as a C string. Well, the assignment did guarantee you that only latin characters would appear in either input, ruling this case out. It's still a possibility you should be aware of though. 

Yes, you can improve that algorithm, by optimizing the following inequation: $$n \le \prod_{i=1}^{k}{\lfloor\sqrt[k]{n}\rfloor+b_i} \quad \text{with} \quad b_i \in \{0, 1\}\land b_i >= b_{i+1}$$ Just initialize the guess for all factors for a given \$k\$ with \$\lfloor\sqrt[k]{n}\rfloor+1\$, and replace the factors one by one with \$\lfloor\sqrt[k]{n}\rfloor\$ while you are still above \$n\$. That means you will effectively only need to calculate one root per \$k\$, followed by at most \$k\$ divisions, multiplications and comparisons. 

No real point in specifying the content type prior to actually outputting the image. As mentioned in the other answer, can error out in multiple ways. If error reporting is active, this will result in a mismatch between content type and the response body. Even if it isn't, you end up sending a wrong content type for an empty body. 

Let's take a look at "" then. Actually, that class would make a fine container for the game state, if it wasn't for misleading naming. What that class actually does, is that it handles most of the actual game logic. Do yourself a favor, and strip the stuff which doesn't belong to from that class and move if to where it belongs. Oh, and give that class a proper name which actually describes it's function. 

That's not exactly OOP what you did here. A single product is apparently defined by the combination of , and . So these 3 attributes should have been grouped together in a class: 

I hope you have placed a cache in front of that script. You are stalling the script with a REST query, and the memory footprint isn't negligible either. If the web server isn't configured to cache, you want to fix that. Caching the output with plain PHP is slightly more complex than that, with regard to acquiring a mutex on the cache during updates. 

Providing different layouts for different screen sizes? Good. Even though a "medium" sized screen hardly requires to switch to an effective 1 column layout yet. That would only been appropriate for "small". 

No move constructor? There is no need to perform a deep copy if the parameter is a "rvalue-reference". 

And a bug: You are placing the food randomly without checking for intersections with the snake's body. That can result in the food colliding with the snake. 

If you really want to do it in excel, make sure to use at least the tools available to the fullest. Let's go through the design choices one by one now, to see where things went south: 

With regard to the efficiency, the solution for that one is to use a cryptographic function, asymetric or symetric doesn't matter, which can work with a block size of 19 bit, together with a random key. Using that to map an steadily incrementing counter onto the combinatoric space of all possible names covers about ~78% of the namespace (524.288 out of 676.000 possible names) and yields pseudo-random names at a constant time. On 19 bit counter overflow, reset the secret to create a new sequence. 

Benchmark Now let's compare how the different versions actually fair against each other. I'm testing this on a 64bit PHP 7.0.4, running on Arch Linux 64bit, 2Ghz Intel Broadwell processor with Turbo disabled. Using the word list mentioned earlier, mixed case. Best out of 3 runs each. The times measured are only for building the tree. Memory is measured with . This is allocated memory, not memory actually assigned by the OS and in use. 

So if the player was already dead, he actually dies only on the next collision. But until you let him play, even if the health bar goes already into the negative. Well, it doesn't, since your implementation of the health bar actually hit's exactly 0. But this starts to bug out the second you allow custom damage values for the health bar. 

You managed to bypass the query builder, which could have implemented this as a trivial, single query on the backing database, and instead managed to emulate that query in an very inefficient manner yourself. 

And please don't use a trailing unless you know exactly what you are doing. You don't need it when using the class to build paths. Respectively, it doesn't even do what you think it does. 

You did not instantiate a new array in the object by default. There is a catch to that. The compiler can no longer deduce that is an array in all contexts accessing it. This does increase the effective memory usage. For a fair comparison, let's just fix that. And while we are at it, also use typehints properly, so we can aid the compiler as much as possible: 

You extracted logic which should have been encapsulated inside your function into the main function. That should never happen. If can't handle values between 1 and 99 itself, it's not living up to its name. 

Said ahead, the "fix" suggested by @BrunaCosta doesn't work either. The only way to reconstruct this information, is to record it when creating the stack. You can't identify the position correctly afterwards. This shows that you lack understanding of what data you need to compute in order to solve the problem. 

What is 177? OK, I know from the context it's an extended ASCII code. But without looking it up in a table, I don't know which one. This makes a magic number. The problem with that is, you reused it multiple times, and every single time in numeral form. If I wanted to switch out the ASCII symbol used for the border, I would need to check all occurrences of this number. But even if I did - I could not tell whether it had the same semantic. Use constants instead of magic numbers: 

Caps lock is for constants, not for mere static class variables. At least not if they can be considered "variable", and not constant. Well, actually something as a static class variable shouldn't exist in your application to begin with. You should try to keep your classes always instantiable and free from side effects. This also applies to this service. If you actually need to ensure that only a single instance of this service can exist, use the Singleton pattern. This is about the only exception to the rule where may be used to declare something else than a constant. There are quite a few reasons for that, among others that the and classes usually would also want to hold a reference onto the they have been registered with (and be it only to provide a clean shutdown by unsuscribing themselves!). It also allows you to move freely between Singleton and other techniques, such as dependency injection, should your code base require that later on. As the call sites already work on a specific instance of (with disregard as where they obtained it from!), there is little friction in changing that later on. Furthermore, methods should also be free of side effects, by convention. Performing constant calculations, or returning a constant result/reference? Good. Mutating some global state directly? Not good.