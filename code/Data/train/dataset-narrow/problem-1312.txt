You have inconsistent spacing, generally if you have 4 spaces for indentation, stick to it for the rest of the code, nothing is saved by not including it, and it makes it easier for other people to read. The same idea for names, shortening them doesn't really give much other than saving a few bytes, and makes it much much harder to understand what goes on in a few months, so descriptive names are better, unless the abbr. is really obvious or defined Below is your code with better spacing, and suggestions for better variable names, although the suggestions are not perfect, try and improve on them 

The padding works well up until 45 rows are entered, after that, it was too wide for my screen to properly read. 

There is a decent chunk of text here, so TL;DR is rename variables so that they are more descriptive, don't treat players any different from one another and make functions that represent that ideal, and finally removing duplicated code often gives leeway to notice patterns and simplify code even more. I hope you take on some of the points and post a follow up, I'm very interested in seeing more from you. Good work! 

Presumably, from the many links you have many pages in the site, changing the header and footer on each page, every time there is a small change gets tedious, and a waste of time. A server side script like PHP would be able to fix this problem, or if you really want, you could encode the headers and footers in javascript and have to wade through that code for ever small change. I think doing it server side would be much smarter in the long run, and you can then learn how to make other features like a login, or a contact us page that sends emails 

I attempted this problem from the ieeextreme, and I got timeout for just over 40% of the cases. Now that the competition is over, I was wondering what could be improved. The problem is as follows: 

I gave a naive solution as seen below, where I simulated the grid with a 2d array, and applied each operation as it came. I also tried to implement an array of fenwick trees, but that solution gave more timeouts, so I believe there are a lot more add and remove commands than query. Code: 

So many pretty powers of 2, I'm guessing it is deliberate. It is a good idea, it speeds up multiplication and division because x << 3 is the same as 8x, shifting bits is the same as multiplying by a power of two, and shifting bits is really fast. As far as I am aware, Java doesn't optimise this, so try switching division by 512 for right shifting by 9, and testing the performance. It might not make any difference because Java already did this, but it may be a micro-optimisation worth doing. But remember, the algorithm you use > the micro-optimisations you implement. Low level changes like these make code harder to read, harder to change later, and more prone to bugs, if edge cases aren't accounted for. Do them last if you need the small boost to go from 58 fps to 60 

You call this 3 or 4 times a round, put it in a variable so it is called once and only once a round. I would change the logic a little bit, check if there is no difference between the shot and the enemy 

This code looks mostly fine to me, when the method gets called, gets moved to and then when happens, gets deleted (and eventually garbage collected unless a reference to it continues to exist somewhere else). However I think you could do better by encapsulating each route in a function that takes care of and for you. Something like: 

Lock based concurrency in .NET is a fairly simple paradigm (compared to the other ways of ensuring thread safety in .NET). When you lock, you declare a block of code as a critical section, protected by that lock object. .NET ensures that a second piece of code in the same app domain will never be running in a critical section protected by the same lock object while one instance is. Here is a good resource for more threading information: $URL$ Pedantry When most people discuss thread safety they mean it in the same sense as saying strings are immutable. That is to say, as long as you don't do anything I shouldn't reasonably expect you might do it is safe. Unfortunately, locks aren't good enough to actually provide true thread safety (bulletproof against reflection and C# pointer code), they are good enough for most usages where you control the software stack out to the actual application. If you need to ensure thread safety in these instances you must ensure thread safety at the field level in your classes (stuff like the keyword will help you here, but watch out). Some example threads that would break your safety here: 

I really wouldn't be too worried about css efficiency, yes this does take a little more effort on the browser's part to render than a simple css background image, but the paths are all highly optimized already and this way you have defined the style instead of giving the browser a limited example (try a two line button with each, or zooming the document, or any other of the many ways to mess the button up in one or more browsers). Comparing the http transfer efficiency of these two probably comes out in favor of the latter as well. The image version comes in 2 requests, while the pure css version is only one. I'd bet they both are fairly minimal on the total bandwidth compared to your page as a whole, but if you were really concerned about this you could always inline the image. If you want to go that route, here is a useful tool: $URL$ 

You only need to bind the click event once (toggle is a shortcut for binding to click and attaching two alternating event handlers). 

However I know this function has a bug: javascript can have cyclic references (causing infinite recursion). To fix that I need to either limit the traversal to a particular depth or check if I have already visited an object. Here I'll do the latter: 

One thing I would not do is name this method as if it were an event and then not use based arguments. Conventions are good when everyone follows them, but when you don't but remain close enough that the code looks at a glance like you are then you have only made the future editor of your code think more. Edit: Using .NET 4, (still ignoring immutability) I would probably implement it like this: 

Basically, you don't need to round down anything if everything inside is going to be an integer. This also means you don't have to cast the double you got from Math.floor back to an int, saving even more time. 

This is equivalent to a list comprehension (or a filter) that might be easier to read. also reusing peiceSet for both the iterating variable and the list seems weird and possibly buggy 

Now onto the code overview. Strictly speaking, your code doesn't work at all. You never actually took in all the input. If its input looks like 

This will make it much easier to read, and you don't have to change code in multiple places, such as if a value changes. 

Now getting the median of this is a piece of cake, it will be in the middle slot of the middle row! Since N * M is odd, both N and M must be odd. Therefore the median is at matrix[N // 2][M // 2]. 

There is no need for a while True. Before adding the coords to the currentShip, we can check if they are in an empty part of the grid. If they aren't we abort early. The boolean validShip doesn't actually do anything, if you reach that part of the code you know it has to be True. That means it can be removed 

There is a little room for improvement here. While we only use constant extra memory, our time complexity has gone up from O(nm lognm) to O((nm)**2). For a better time complexity, I would recommend using inplace quicksort which brings us back to O(nm lognm). Another point is that we are doing too much work. Once we have worked our way up to the row N // 2 and the slot M // 2, we are actually done! We have put the median element in it's place, and we can stop. This is a simple enough check to add, but can cut the actual running time of the code in half. 

This function is weird. It highlights that the game board is strongly coupled with the players. The reason I say this is because this function assigns the names and characters each player uses at the same time for both players. What makes player1 and player2 special and need to be handled all at once? The code in this function could be halved and called twice, once for each player (or for an arbitrary amount of players if the game was a team game with a much larger board for example) 

Each call to this is an O(n) operation on the list, m times where m is the number of times the element occurs, x times where x is the number of keywords. So in big O (and worst case) we have O(nmx). We can be smarter about this, and do it in O(n) and in one iteration. We will use extra memory to store the keywords in a dict So replacing this: 

Since this function is called n times where n is the length of the string, and there are t strings, it is called roughly n*t times, so it is where a bottleneck has a good chance of forming There is no real need for a comment to say when a function ends, as good indentation will tell you that anyway. So, we are checking if the two characters from either end are equal, and if they aren't it goes like this 

I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

Back on topic: In my opinion, it is a bad practice to force the Javascript engine to go looking for your globals when you are not in global scope due to leaving off the window qualifier. Thus everywhere you reference without calling it (and the same goes for ) or caching it in a local variable is wrong. In the event where you run this script outside of a browser that implements you will get an exception. is slightly less of an issue because it is a reasonably safe assumption that you will not run this from a browser that doesn't supply a global namespace. For this reason I always pass the globals that I am going to use into my IIFE: 

ignoring immutability and such (like having a getter and no setter for FlatSideArea that computes on the fly)... What you are basically implementing here is an internal usage of the INotifyPropertyChanged interface. If you are going to implement that interface, I suggest you actually do so instead of only sorta partially doing so: 

not caching the inner jQuery object checking the state of each dialog by checking its implementation when we already have a structure modeling it 

(unable to check correctness right now due to not sitting at my work machine, but barring any syntax errors I think that is right) Am I doing something wrong here? I think a static constructor is fine for the singleton pattern as well, but I am not 100% sure it covers all thread safety issues. I don't see how a single lock object wouldn't though. 

In response to the comments: This is very similar to the code you initially put up. I derived it again on a gist using the code you put in your question here (slightly different from the code in the fiddle): $URL$ Clone that repository to see the full history. 

JsFiddle to show it works. Interestingly this version is also about 20% faster than the original code. (see: $URL$ 

(spacing to demonstrate relationship to terrain_map) With this array you can start with any coordinate and convert it into an index in this array via a the function and back with its inverse function. Once you have that you can move up or down by adding/subtracting and left or right by adding/subtracting from the index. Since this array is a padded version of the map, you never have to worry about wrapping around because you cannot move to these fake coordinates that make up the padding. This may or may not wind up actually being faster (it depends on how big your maps actually are and how easy the set of paths were to compute in the first place). code: 

Wrap the code in an IIFE (and add ) On top of other things this allows you to use a for here and not worry about messing with any conflict issues. There is no reason to name the init function that you are just passing to ; inline it. Cache the jQuery elements. Pass in global variables used to the IIFE (, , , ). has too many I'd rewrite it as after caching the element. Better still: