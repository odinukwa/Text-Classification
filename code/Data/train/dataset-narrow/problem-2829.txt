As you've noticed, there are pros and cons to each architecture scheme. Each pattern has its own implications for how objects will interact, and when. First, I'd recommend a quick refresher on SOLID design. Now, what we strive to accomplish with good architecture is enough abstraction that we aren't hampered by the system when we want to add a feature. If we can accomplish that with a couple of singletons or global methods in a way that scales to future development, great! It might even end up faster. Now, the object oriented approach typically has one or more factories that produce either generic entities you add components to, or specific entities in a non ECS design. These factories are usually contained close to the core gameplay class. As an example of the non-ECS version: 

That will locate the first object by that name. However, if you have multiple objects named that then you're in trouble. It would be better to expose a field on the component you're writing and link the object in the editor. Just drag the object from the hierarchy into the field on your component in the inspector. 

III. Either set the render target to the image to be erased or create a render target that is a copy of the original. I'll call this target canvas. IV. Draw the image to canvas using non-premultiplied alpha blending. V. I came up with the following blend state in XNA to use for the next step 

This is why trademark law exists - to prevent brand confusion. If someone actually buys your app thinking it's the other app they heard about then you've harmed the other app's business, or vice versa. It's also kind of rude to use a name someone has already published, particularly when publishing has an associated advertising cost. While you might have thought of using the name first, they may have invested money (or time) into that name already. Thus, you would effectively steal the benefits of their advertising money as well. 

I believe the solution is simple - mark vertices of the path as impassible and run regular Dijkstra for this input. If it fails to find a path you are sure they are on different sides. Edit: If your path does not split the graph into two components you can still use method described above with only difference - after finding the shortest route check whether it contains endpoints of the path. If it contains exactly one endpoint, you know the points lies on different sides (if it contains both of them, you know it went "the other way around", in example given in question it would take the bottom path, points still can be assumed on same side). 

You effectively answered your question: you want to move the boss towards the player Y, leaving X and Z unchanged. To do that, create new vector and give it X and Z from current position and Y from player position: 

note: the first solution should be preferred, casting enum to int is not the best practice - I am mentioning this only should you prefer avoid vector math completely 

In case you have opposite adjacency, it is just another mod. If you dont have neither, you can compute it. You can also distribute the alpha to adjected triangles based on distance for more in-depth smoother fadeout(just another inner loop or stack). Other approach would be to compute extremes(x,y min/max of mesh) and map x,y on some function, which simplest would be for example . Though this would work well only for convex-shaped mesh, best near-rectangle shaped. 

Your best bet is on abstraction - you should aim to create too complicated abstraction to be approximated by a mathematical model. You can also further annoy "cracking" the game with AI by giving it inputs that are harder to extract features from: an image or speech. Even if fed with input extracted with 99% accuracy, there is a chance for AI to receive wrong inputs, if it receives wrong inputs it is probably(depending on AI type) much more likely do make a wrong decision. Or by using combinatorial explosion (go used this) in rule set. For example, if a turn was to play card from cards hand, there are how to play the turn. If you were to choose cards for that hand there are "n choose k" options, giving total on that turn alone(!). Note: there are many other ways how to introduce something similar in a rule set. 

If you need to store entities in chunks it's probably better to actually store them in the chunks rather than a separate array. 

Since it sounds like you're using a human sized perspective, you can either increase your texture or your polygon budget. Usually, you would bake fine geometry into something like a normal map, but if it's that small then it probably isn't worth it unless that's a vital part of gameplay. If it is, then go ahead and use a model for it. Just be careful that you aren't blowing all your resources on things the player isn't going to look twice at. A game with multiple size perspectives (if the player can grow or shrink to that size) could use variable level of detail - to increase the detail of now large objects - and depth of field - to hide distant objects consuming unnecessary draw cycles - for these things, but that implies a lot more engineering than it's worth if they aren't going to be spending much time there. 

I think you want Dijkstra's algorithm, which is also used for internet routing. In short, you must create a graph where each edge is a path from one node to another. These could be pre-calculated if some of your geometry is fixed. For each starting point, you will order the nodes according to their distance from the destination. Then apply Dijkstra's algorithm through the graph to build routing tables for each one. The first route in the table will be the shortest path. Each route after that will be a variation depending on which nodes are blocked. These extra routes could be calculated as necessary, provided their order is maintained in the table (they should be ordered by the sum of their edge lengths). You'll refer to these routes again when a node is changed (blocked/unblocked). You can then add and remove nodes by splitting edges and moving the new midpoint, then recalculating from the origin node. 

Abstraction (e.g. task "draw something beautiful") Feature extraction (e.g. from non gaming: captcha) Decision making: unfeasible bruteforce solutions (huge state space, e.g.the go) 

Simply calculate UVs (0,0 point is left bottom, 1,1 point is right top) assuming you v got sprite texture dimensions sp in pixels just divide it by texture size: 

This way, level 50 swords can be anywhere between (low quality, low randomness), (lq, hr), (hq, hr) or (hq, lr), all equally likely. Or even all not equally likely(if you chose to use non-default distribution). 

You should have a look at sampler objects, if is it a solution that would suit you. Basically a sampler object is openGL object which can store these kinds of settings for later use(binding) in shaders. Example of usage: this tutorial. 

There is always brute force solution if you find yourself stuck and speed is not priority (one-time generation). In you case simple BFS/DFS might suffice. Just pick a node of desired type(either land of water) and continue your search, finding all tiles of same type within the graph(terrain part). Continue while there are any nodes not visited. 

use the buffer as ringbuffer, locking and updating only a part equal to current "pointer" + required size. Moving round the buffer using modulus. use technique called buffer orphaning, where you just discard the buffers from your point of view and rely on the drivers do the optimization 

because the vector is normalized and, naturally, points upwards you just need to check its length in Y axis(or the "up" axis if you use different one). It will be 1.0 when perfectly up and -1.0 if perfectly upside down. This simple code will suffice - if you don't require exact angle, of-course(you can still compute the equivalent Y threshold value of angle should you require it). 

Edit: Okay, with a little bit of testing I'm prepared to revise my answer. Going from 2D to 3D, you must now consider that "Y" isn't always going to be up. When you try to treat 3D as 2D, you can actually make things a little more complicated. So I'll do it both ways and you can decide which way works better for you. 2D in 3D As usual, we want the direction vector from our current position to the target. 

The default Unity project settings include some joystick axes already. So looking further down, we find the same axis defined again! Removing the extra axis definitions fixes the problem. 

You can still maintain the Chunks in row/column format elsewhere, but this way each chunk will be aware of its neighbors as well. When an entity leaves its CurrentChunk's Size bounds, remove it from CurrentChunk, add it to the corresponding neighbor, and change its CurrentChunk. You'll have to repeat that, of course, if an entity somehow moves an entire chunk's size in a single frame. 

Short answer, yes. Of course, only your lawyer can advise you of your legal risk in civil matters like this. However, a reasonable person should not be at risk of brand confusion - which is the question a court would have to answer in that case, as this more aptly falls under trademark which protects symbols identifying things with business value, as opposed copyright which protects the content. 

But I prefer not to reinvent the wheel - so is this "correct," or is there some accepted way of doing this that's totally different? 

For very simple and limited(in numbers) you could give each of your items tag. Alternatively, you can take advantage of the method signature - the one of the colliding object will be (.gameObject) and the other one is . This way you can access attached components directly, including all scripts. So assuming you have something like script on player and collider script on the item you could do something like: 

I would look at the problem differently: I would use navigation graph instead. I would "bend" the original navigation graph to your problem - each junction is a node(with 0 radius), and each edge stores its length and its direction. Player navigate on graph instead of in a world full of solid walls. Player can move each frame at desired speed along edge he is on if either "correct" direction button is pressed (note this could be generalize to support 8 or more directions). Another benefit is that generating such graph is trivial for uniform grid (any flood-type algorithm will do). 

...this would cower your example but be aware: The corners of the line strip would be broken if you did something that simple - the actual positions of and depends on next segment! To be more precise you need to find(same as above) all 4 corners for next segment first and then correct the adjacent vertices (for p0->p1 and p1->p2 those are vertices 1,3,4 and 6). In order to correct the coordinates you need to find the intersection between lines given by vertices 0 to 1 and 4 to 5 giving you correct position for vertices 1 and 4 (the "lower"/right joint next to p1"). Similarly the intersection of lines given by 2 to 3 and 6 to 7 gives correct position for vertices 3 and 6 (the "upper"/left joint next to p1"). Repeat for all joints. note: I dont go into implementation details of the line intersection - there are plenty of good implementations around here 

I'll refer to map nodes as tiles for the purpose of explanation, but the principles are the same. If you have more than one node in an area, then your "tile" would contain an array or list of nodes. For all of these, graph theoretic applications can be applied, though the method of application becomes more or less complex depending on what specific algorithm you're using. Now, if by matrix you mean a two dimensional array, that is probably the least algorithmically complex method, besides a one dimensional array where tile[x+y*width] = tile[x, y]. Structured this way you always know the distance of one tile to another, and can always access its neighbors without traversing memory in steps. Next is a sparse matrix, where the information is structured like so (as a pseudo-structure): 

WASD is just a de facto standard for FPS games. If you play an FPS from the pre-Half Life era, you'll end up with all sorts of variations. That said, the analogue from 5DoF to 6DoF is jump/duck, which varies for each game. Case in point, Quake used jump and duck for up/down movement underwater, even though it used arrow keys for forward/back and turning, with alt+left/right for strafe. The original 6DoF FPS, Descent, had flight-sim like controls and used the +/- keys for up/down. 

I've used forward/backward momentum here since it's easier to describe, but the same principle applies to lateral movement and turning. In order to turn, they need to shift their weight counter to the direction of the turn while moving forward or backward. 

Most rhythm games actually have a pre-recorded or procedurally generated rhythm track, but this is okay for testing. This is because many songs' tempos very over time, the downbeat (the very first beat heard in the song or measure) can take some time to get to, and typically we want to have more complex input than a single key press. That said, assuming ideal conditions where