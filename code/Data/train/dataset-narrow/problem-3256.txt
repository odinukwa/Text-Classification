If I compare the schematics of the two boards the first thing that I see is that the PiFace (schematic) is a much less complicated board then the Gertboard (Schematic on the last pages). PiFace The PiFace is actually an I/O extender that uses the SPI bus to extend the I/O capabilities of the RPi with 8 extra input and 8 extra output pins. While all 8 input and 8 ouput capabilities are routed to pins for external connection, some have a double function. 2 of the 8 output pins are used to drive a couple of Relays, and 4 of the 8 input pins are fitted with buttons on the board itself. Further the input pins are directly connected to the I/O extension IC, there is no protection for over voltage in these circuits. The 8 output pins are driven by a ULN2801A, this means that each output pin can drive up to 500mA (externally supplied) at a maximum of 50V. In theory you could connect 4 PiFace boards to the RPi, because the address of the SPI I/O extension chip (MCP23S17SP) can be set using 2 jumpers. In reality this will be very hard to achieve because the PiFace is a board that needs to be stacked on top of the RPi and the main connector (the one on the bottom that connects to the GPIO pins on the RPi) is not fitted with a female counter part on the top to enable stacking more boards. I guess they did not do that because the Relays are too high anyway to enable stacking. Further all the I/O is in a fixed setup, the board is AS IS and you cannot change it in any way. GertBoard The Gertboard on the other hand isn't fixed in any way, when you just connect it to the RPi, nothing (??) will work because nothing is actually connected to the GPIO pins. You need to use the scratch pad to manually make the connections to the desired parts of the board. This is done by using wires with a little connector on both ends. The number of options on this board are higher, but you cannot use everything together at the same time (??), so you will have to rewire the scratchpad when a different function is required. It can also provide extra input and output (Low voltage TTL) pins to use externally, these can be configured for input or output individually, there are 12 of these available and these are buffered (input and output) and the first 3 are fitted with onboard buttons. It also features 'power' outputs similar to the PiFace board, 6 of these are available, they can also provide a 500mA at a maximum of 50V (externally supplied) Further is has Analog/Digital conversion, and Digital/Analog conversion, a motor driver that can power brushless motors (servos/stepper motors etc). It even has a separate AVR microcontroller which can be programmed from the RPi to perform separate tasks, independent of the RPi. Conclusion Back to your question and the way you wanted it answered, to give a set of general rules the way you asked for is nearly impossible. The only useful thing I can comment in the 'if .. then ..' style is this: 

different types or protections/electronics are required that can have a totally different price tag then the couple of cents the normal buffers and optos cost. So the question 'when and why' you're asking for is not a question with one answer, it depends on the context. 

Wiegand is a swipecard protocol developed in the 1980s. It does not use any form of clock signal or speed indication, the data timing is done based on the last bit that was transferred + the Wiegand delay time. This is a disadvantage but does not make it impossible to use. Besides that there are plenty different implementation and alterations on the protocol itself, this is not done because it is such a good protocol. Wiegand 26, transfers a 24 bit code + 2 parity bits, even the most cheap RFID implementation (125Khz EM4102 RFID chips) use 40 bit code in every RFID card. Your reader emulates Wiegand because 'real' readers for that stuff do not exist anymore. Meaning that it will send the FIRST 24 bits of the RFID card and will drop the remaining 26 bits. This will result in duplicate cards, because the bigger part of the data is not even transferred! This issue even even more important when you use EPC (96 bit or more), then only a fraction of the total data is transferred. Most (I guess even all!) of the modern RFID reader have Wiegand as option to be compatible with very old installations, chances are your reader will also support serial output, please do yourself a favor and use whatever else is available except Wiegand. 

Yep you can, you need to use the 'Open Collector Driver'. These are described in on page 19 in the documentation, here an little excerpt: 

I think you can extend it to some length, if 50cm is within that range I don't know, you should try that. But the specification of the bare protocol look promising: 

If I messed up the conversion to html, here is the link logger.pl If you saved this script as logger.pl the command: 

Assuming that milliseconds is a fine enough resolutions for this type of experiments, I remember from driving theory books that they assume a human reaction time (eye/hand) between 200 and 500 milliseconds. In this range of time, the RPi will for sure be fast enough to record the output versus input. I have no idea what type of systems (hardware) + operating system you are using at the moment and what the maximum error in a time sample/stamp might be (because of kernel context switches, meaning other active tasks), but unless there is some special hardware in use for the current systems, I think you can safely get the same results using the RPi. Precise timing is used in RPi projects for ultrasonic distance measurements, they seem to work fine on the Raspberry Pi and the times there are in the range of microseconds. 

I guess that should not be a problem, for the USB device certainly not a problem. Depending on the USB implementation on the RPi it might not detect your device because it doesn't draw any current. If that is the case you can use a resistor to draw a little current on the USB output. (Put this resistor between the unused 5V and GND outputs on the USB connector) 

If you want to control the process with commands like start, stop, restart etc using the skelton script and altering it for your purposes might be the best option. If you just want the process to start and that's it, you might consider just putting the command, as you wrote it in your question, into the /etc/rc.local. (I don't have my RPi at hand, but I read online that there is an 'exit 0' line in there, you should put your command above this line) 

The RPi doesn't use 5V itself, only the 3 regulated voltages, and of-course the 5V is used for the USB connectors. This voltage drop that you experienced happened when you were powering the RPi from the normal USB connectors and not through the normal way (the mini usb). So probably the power supply of your USB hub is not the best quality (like most of them), or couldn't handle the extra power requirements from the RPi. About the GPIO pins, these are 3.3v, so all the ADCs and other stuff that you want to connect has to be 3.3v (or converted to 3.3v). Any reference voltages that are needed for external logic ICs is your own responsibility to make this as stable as possible. So the answer on the question 'What is the quality of the 5V supply on the GPIO' is: the exact same quality as the power supply that you use to power the RPi. 

Because I was also new to PBX I did not install the FreePBX because I wanted to get the feeling for the settings manually. Once you installed Asterisk (or both) I suggest you read the various how-to documents on the asterisk site to get the basics to work, like actually calling, voice mail boxes etc and connect a couple of software-phones. When all that works I think you're ready to add an outside line so you can call in from an external network. There is many info to be found online about the great amount of options that Asterisk has to offer, so I think you'll be happy hacking for some time is you want to make it really neat! 

You cannot compare both very well, for example I would never use the Gertboard in a product, I could however use the Gertboard for tests and use parts of it in a separate design to be used in a product. The PiFace could be used in a product if you just need some extra input and output contacts. Within a learning context: The PiFace could be featured in the first lessons to get some basic feeling for input and output and how to handle those from the RPi, the Gertboard could be introduced after that for more advanced tasks. 

You have to use always one of them as output, and one as input. On the output you let a bit 'walk' from bit 0 to bit n (7 or 15), these are the columns of the matrix. On the other you constantly read the value of the input and these are the rows of the matrix. The combination of what output bit is active and what input bit is '1' is the key that is pressed. 

The voltage levels are not a problem, a LVTTL logical '1' will also be a TTL logical '1'. The only issue can be the (sinking) current, as Alex Chamberlain already suggested. This can be a problem. This sinking current depends on the input circuit of the printer, as we can only guess how it is constructed, it might be better to be safe then sorry! So to be safe put a CMOS buffer in between. A 74LCX244 for example. If something would start to smoke then, it will not be your Raspberry Pi. Edit: I noticed criticism about the current statements, to back this statement up: Quote from klabs.org: 

I think you prepared it all pretty good. You even got an advantage over the way things are done in the original article (your inspiration) because the MRF49XA is a transceiver IC. The article uses a transmitter and a separate receiver module. Second the MRF49XA communicates over SPI, while the original article was a little vague on that part (or I missed it). But you also have a disadvantage, those modules that are used in the article are ready to use/connect modules, bought on (I guess) ebay for a very low price. You on the other hand will only have a bare IC that needs all the supporting components added to make it a working electronic module. If that is not a problem (soldering, designing a PCB, etc) you are good to go (I did see an application note in the datasheet so that could be your guide to get the IC working). I took the liberty to search around a little on this IC, and found a link that might interest you, it is a generic article about someone that used this IC in a similar way as you are planning to do, but connecting is to an AVR micro controller. This article might include some useful tips and information, but the reason that I bring it up is because at the end of the article, the person says that he uploaded the PCB layout to BatchPCB, this means that you can order a bare PCB there, add the components and you have a module ready to go!! Of course the PCB is based on his schematic, which suspiciously looks similar to the application note of the MicroChip Datasheet... This might save a lot of time.. Another option might be to search a little on ebay for similar device modules, but you need to check all the specifications of these devices with your requirements obviously.