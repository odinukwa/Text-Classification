The returned value is tuple ; now just check if the ; if it does, the answer is , if it does not, give -1. Adapting this into a class one gets: 

However if you have a veery big file, then you could mmap it into memory in the beginning of the process (this consumes just 1 file descriptor) globally and send it from there in each client: 

In Python there is an agreed-upon standard on how the code should look: PEP 8 -- Style Guide for Python Code. The standard is to use lowercase names with underscores. For shuffling a list, there is a function in aptly called . Use to interpolate values in string. Do not repeat yourself and just ask the thing once; one can combine these inputs together. Do not needlessly compare against using ; just use the implied boolean value of the expression (and if you need to be explicit then use instead of ). Store the letters in a list for easier modification. Also there is no need to write as a function, if you really want a set operation (that is, the same letter can occur multiple times in the word, even if only once in the original). Thus we get: 

Note that is equivalent to , and is much easier to read and understand. Is this code golf or something? It seems excessively brief, at the expense of clarity. It's better to put spaces around operators and keywords, and use indentation consistent with the logic. (One of the many reasons I love Python: it doesn't let you use misleading indentation. The indentation is the logic.) Your variable declarations should declare one variable per line, with comments saying what they do (or better, meaningful names that don't need comments): 

This Python 3 program outputs a list of all pathnames in the filesystem that match a list of rules taken from a file. You can add and remove sets of pathnames. The original purpose was to generate lists of pathnames to feed to for backups. A simplified version of one of my backup rulefiles should clarify how it works: 

I can't think of any way the file size could change without the mtime changing too. On the other hand, it does no harm to check, aside from making the code a little more complex. You use the expression quite often, so I would do this: 

I'm going to move a little more quickly now, because you're probably getting the hang of how to approach these problems. Next we need to format the results. Let's focus on re-inserting the comma between tokens. I'll write a dual to the function: 

Look at the source for that function. (You'll see that it would be easy to write our own function to allow blanks or decimal points as well as digits.) So now we have a way to tell if an individual character is valid in an integer. How do we tell if all of the characters in a token pass the test? Again, I suspect there's a function that applies a boolean test to all elements in a sequence, and tells us if they all pass. The type signature of such a function would be one of the following: 

Your code looks fine to me. If you wish, you could use Greek letters. This makes the formula easier to read, but if you expect to modify it often, it may be too much trouble to enter the Greek letters. You might find it helpful to split up long formulas, as I've done for . If you can think of more meaningful names than and , this might be a good idea. However, if this is a well-known formula in your field, splitting it up might actually make it less recognisable. It's a judgement call. If you wrote this in literate Haskell, you could include a nicely-formatted version of the formula using LaTeX. That might be useful if you're writing code with a lot of formulas. 

gives a short help text. would normally give a long help text, but since it's quite long and the contents don't affect the code, I removed it from the code posted below. I'll keep it available here for a while: $URL$ (this is now a dead link) Aside from general code review, I'm particularly interested in the following: 

The range checks have more parentheses than they need. If they find an input out of range, they should return 1 instead of 0, since that's an error. Statements like are legal and have well-defined behavior, but they're tricky to read and understand. It's better to break them into two clear statements. It's also better to increment in the loop introduction if you can (and I don't see why you can't, in these cases); people are used to reading loops that way, it's an idiom. 

I see one error. is initialized at the start, and thereafter retains the value it had in the last test. It should be initialized immediately before use. Aside from that, I'm not sure why some of your answers were wrong. With this structure and without comments, I found it quite difficult to follow the logic. I recommend the following structural changes: After reads each , it should pass it to a function that does the work. tests various cases. Each case should be preceded by a comment explaining how the solution is derived for that case. The cases should not involve more nested blocks than absolutely necessary. As soon as finds an answer, it should return the answer (1 for Yes, 0 for No), and have do the printing. That saves print statements, and makes the code shorter in other ways; for example, this code: 

This is guaranteed to be faster than your Trie method; the initial overhead comes from creating a tuple for all entries, which is still less burdensome than your solution having to create O(n) dictionaries; the lookup is guaranteed to be faster too. 

In case this is not fast enough, then instead of a trie, you can store all prefixes in a single dictionary! 

However, if you need to serve lots of files like this, then you might want to increase the limit of open file descriptors per a process, use a front-side cache such as Varnish and/or scale up into multiple processes, or hosts, or even use a CDN to deliver your files. 

Actually you should be more troubled by the use of as the dictionary key. Indeed, will catch not only but any exception derived from there. Now if anywhere in the code there will be that is being thrown, both yours and Janne's will just throw a , losing all the traceback. Also some of your defined exceptions might be subclasses of other exceptions, and in that case you would want defined order for codes in those case, thus we get something like: 

Now we need to separate the words from the integers. So we need a function that will tell us if a token is an integer. The problem statement implies we only need to deal with integers. So a token is an integer if it only contains digits. (The example given didn't have any spaces, but we could allow them, and even decimal points, if we want to.) So how do we tell if a character is a digit? Hmm... there's probably a function to do that for us.The best way to answer questions of the form "Is there a Haskell function to do X" is usually: 

Unfortunately, in the case there are a lot of functions with that signature, but eventually we find in . 

I think you've overcomplicated the problem because you're approaching it the way you would in an imperative language. I'll describe the way I would approach the problem. Notice that I do a lot of my "thinking" in GHCi! Your code reads the file and splits it up into lines just fine, so I'll move onto the part where we handle each line of text. First, we need to split the line up into tokens, where the tokens are separated by commas. The function is close to what we want, but it breaks at whitespace, not commas. So we'll write our own: