The Watts-Strogatz model describes a mechanism of generating small-world networks. The idea is to start from a ring network in which each node is connected a fixed number of its closest neighbors. After that, a rewiring is performed in which each link present in the network has a probability $p$ of changing one of its endpoints to a new random node. The closer $p$ to 1, the more random is the network. Is there a similar small-world model for bipartite graphs? That is, is there a mechanism for generating random bipartite graphs that possess the usual properties of small-world networks (a.k.a., the maximum of the minimum distance between any pair of nodes scales no higher than as the logarithm of the number of nodes)? 

Given a rotation system for a graph $G$, we define a face-walk as a walk in $G$: $$v_0e_1v_1e_2v_2...e_nv_0$$ such that: 

In the same book, an algorithm is given to trace the faces of the embedding. One starts with any vertex $v_0$ and any edge $e_1$ incident on $v_0$ and proceeds to complete a face-walk. They claim that this will give a face boundary of the embedding. To understand this, I need to see a proof for the following two statements: 

I think the way to do this is to create a table of mosaic knots with a set of restrictions to disallow shortcuts. So a knot table is a set of knots that have a given property. The property below is being a prime knot. 

Anything to do with Machine Learning has a lot of career prospects because you could be employed by either finance or technology companies in general. 

Currently bitcoin has a proof of work (PoW) system using SHA256. Other hash functions use a proof of work system use graphs, partial hash function inversion. Is it possible to use a Decision problem in Knot Theory such as Knot recognition and make it into a proof of work function? Also has anyone done this before? Also, when we have this Proof of Work function will it be more useful than what is being currently computed? 

Are there any algorithms to draw a billion node graph or to aggregate the information? The idea would be to allow for it to be parallelized using map reduce so it could be done in realtime I was wondering if there were any other algorithms? A google search turned up nothing. Very large graph drawing I have found are as follows 

A polyhedral embedding of a graph on a surface is an embedding without edge crossings such that all the faces are bounded by simple cycles, and any two faces share a common vertex, share a common edge, or do not intersect at all. I need an algorithm that, given a graph, finds a polyhedral embedding if the graph admits it. I have been looking around but haven't found it. I also need to know the time order of the algorithm. Deciding whether a graph admits a polyhedral embedding is NP-complete (proved here: B. Mohar, Existence of polyhedral embeddings of graphs, Combinatorica 21 (2001), 395â€“401, $URL$ I don't expect an efficient algorithm, just something that works. Note: I should mention that I am only interested in the combinatorial aspect of this problem. An embedding of a graph can be described by specifying the cyclic orderings of the edges incident on any vertex, and a signature for each edge, which is +1 or -1 according to whether the cyclic orderings of the two vertices on this edge are consistent along this edge. A face-walk is a walk in the graph where at all vertices the next edge is the leftmost edge according to the cyclic ordering on the vertex. A polyhedral embedding is an embedding where all the face-walks are simple cycles. The problem is then to find a circular ordering of edges around each edge and a signature for each edge such that all face-walks are simple cycles. 

Since the Hilbert Curve iterations converge uniformly, that uniform limit is a continuous path that solves the maze in the analytic sense. It's as if you were able to do the following recursively defined infinite set of moves $P$: $P = APA^{-1}BPB^{-1}CPC^{-1}DPD^{-1}$ Now you might argue that this is not in the spirit of fractal mazes since the Hilbert curve fills the entire square and therefore you could just draw a straight line segment from the start to the finish. This objection is easily overridden though - simply use the hilbert curve diagram embedding directly, as shown here: 

If a solution exists, breadth-first-search should find a solution. However, suppose there is no solution to the maze - then our search program would run forever going deeper and deeper. My question is: given a fractal maze, how can we determine if it has a solution or not? Or alternatively, for a fractal maze of a given size (number of inputs/outputs per copy), is there a bound on the length of the shortest solution? (if there was such a bound, we could exaustively search only that deep) 

Several state of the art approximate nearest neighbor methods in high dimensions are based on reducing the dimension of the space through randomized techniques. The main idea is that you can exploit concentration of measure to greatly reduce the dimension of the space while preserving distances up to tolerance $\epsilon$. In particular, following from the Johnson-Lindenstrauss lemma (upper bound) and a result of Noga Alon (lower bound), there exists a subspace of reduced dimension $$C_1 \frac{\log(N)}{\epsilon^2 \log(1/\epsilon)} \le \text{reduced dimension} \le C_2\frac{\log(N)}{\epsilon^2}$$ such that for any two points $u,v$ in your collection, their projections $\tilde{u}, \tilde{v}$ onto the reduced dimensional space satisfy $$(1-\epsilon)||u-v||^2 \le ||\tilde{u} - \tilde{v}||^2 \le (1+\epsilon)||u-v||^2.$$ Indeed, such subspaces are "typical" in a sense, and you can find such a subspace with high probability by simply projecting your points onto a completely random hyperplane (and in the unlikely event that such a hyperplane is not good enough, just pick another random one and project again). Now you have a nearest neighbor problem on a much much lower dimensional space. A key paper is, 

PSPACE proof attempt of Portal 2 by reduction from TQBF Application of section 2.2 of Gaming is a hard job, but someone has to do it! On portal 2. A direct proof of the statement: Given Portal 2 can you encode a TQBF in the game? We disallow portals in certain parts to simplify the proof since this is allowed in the game but, we will show that if all surfaces were white then this would allow you to bypass the proof. This either changes the topology of the graph or collapses quantifiers into being the same quantifier. 

extended abstract in Proceedings of the Thirty-Second Annual ACM Symposium on Theory of Computing (STOC'00), pages 73-79, 2000. technical report, in Electronic Colloquium on Computational Complexity TR99-045, 1999. $URL$ extended abstract in Proceedings of the Thirty-Second Annual ACM Symposium on Theory of Computing (STOC'00), pages 73-79, 2000. $URL$ 

I am old school and just use files and folders to organize everything. I have it in Dropbox and I share it with my professors or other students. I think using files and folders although it isn't very fancy but it works well. I have tried special organizers but never used them. 

Given: A degree sequence. Wanted: A graph and a polyhedral embedding of this graph (described by a rotation system or something equivalent). By polyhedral embedding I mean only the combinatorial concept. See here. Is there a fast way to do this? I tried a backtracking approach, adding edges one at a time, but it is too slow. It becomes intractable for a 3-regular graph of 30 vertices. 

A polyhedral embedding of a graph on a surface is an embedding without edge crossings such that all the faces are bounded by simple cycles, and any two faces share a common vertex, share a common edge, or do not intersect at all. Moreover, all the faces are disks. Given a graph $G$ with a polyhedral embedding on a surface $S$, one can define a dual graph $G'$ embedded in the same surface $S$, by creating a vertex in $G'$ for each face of $G$, and adding an edge between two vertices of $G'$ for each edge that the corresponding two faces in $G$ share. I have a feeling that this will be simple, but I don't know how to prove it, so here it goes anyways. Question: The dual embedding that one obtains for $G'$ is also polyhedral? 

For your first question I believe this paper may help a bunch. It has a 6 bit combinator calculus that is also an UTM. Also it has a universal combinator that seems to have size 7 with one element given what you want. They call it Zot. $URL$ I am not sure if you can say or prove that there is a minimal combinator. The paper would suggest it would have to be at least be less than 6 bits. 

Description of each gadget I define a door as two tiles of deadly water that can't be jumped over. To unlock a door you place a block on it and the door unlocks. 

No there is no current system that does all four steps in your system. If you want to design a system one of the first requirements is homoiconic language. At minimum you would want your core programming language that you have as small as possible so that when you enter the system and start to make it interpret itself it will work. So therefore you want a metacircular interpreter which was pioneered in lisp. Other languages have done it also but there is a enormous amount of existing research on lisp. The first step if you want to do this is to have a homoiconic language like Lisp or some framework where you can reason about a running program. Lisp is used for this for the sole reason that you could define a metacircular interpreter in the language or you can just treat your code as data. Treating the code as data is the most important thing. There is along discussion about what homoiconic means on c2 wiki. For example in Lisp your "Program" datatype is valid lisp programs. You pass the lisp programs to an interpreter and it computes something. It gets rejected by the interpreter if you don't program a valid "Program". Therefore a homoiconic language does three of your requirements. You can even in lisp define the idea of a formal program. Can you model lisp inside lisp? Yes this is frequently done mainly as an exercise at the end of a lisp programming book to test your abilities. SICP At the current time issue four is a research question and below is what I have found that attempts to answer this question. I would say there are many types of programs that attempt to do this. Below is all of the programs that I know about. 

This too contains a sequence of uniformly convergent continuous paths going from the start to the finish, by the same argument used to show the uniform convergence of the Hilbert curve. However it is a true "fractal maze" in the sense that it does not fill the whole space. Thus we have a fractal maze that is solvable by the analytic definition, but unsolvable by the graph theoretic definition..!? Anyways, I'm pretty sure my logic is correct, but it seems counterintuitive so if anyone can shed some light on this I would appreciate it. 

This is not an "answer" to my question, but rather an extended comment that people here might find interesting. I claim that there is a natural "analysis-type" definition of a maze and a solution, and it differs from the computer-science/graph-theoretic definition we've used here. In particular, you can have a fractal maze that has a "solution" under the analysis definition, but would be declared unsolvable by Marizio De Biasi's algorithm and Peter Shor's pushdown automata technique. Definition: A maze $M$ is a compact subset of the plane $M \subset \mathbb{R}^2$ containing a start point and an endpoint $s,e \in M$, respectively. A solution is a continuous function $f:[0,T] \rightarrow M$ such that $f(0)=s$ and $f(T)=e$. Now consider the the Hilbert Curve: 

A flow network is a directed graph in which each edge has a capacity. A flow through this network is an assignment of a value to each edge that is less or equal to the edge capacity, and such that the net incoming flow to every node balances with the net outcoming flux at that node. Two special nodes are exempted from this last restriction: the source (which can output a net non-zero flux) and the sink (which can receive a net non-zero flux). There are algorithms to find the maximum net flow from source to sink in such a network (for example, Ford-Fulkerson algorithm). I am looking for algorithms that generate pseudo-random admissible flows through such a network. Hopefully the space of admissible flows should be sampled as uniformly as possible. What methods are available here? 

Growth: Starting with a small number ($m_0$) of connected nodes, at every time step, we add a new node with $m$ ($<m0$) edges that link the new node to $m$ different nodes already present in the network. Preferential attachment: When choosing the nodes to which the new node connects, we assume that the probability $P$ that a new node will be connected to node $i$ depends on the degree $k_i$ of node $i$, such that 

So lets encode the trefoil in a machine readable format. We take each tile and assign them a number (01-11). Using the programming language racket it will look like this 

--Begin amended algorithm-- Step 5 is due to @vzn answer: Add a visualization of local regions. Therefore we define a region as a set of points that are "close" due to some locality measure. Pagerank is an example so you have a pagerank of 2 you are in the region. 

If I arrange the disks into a spiral pattern then the problem is NP-hard. It may be even harder in your general case. This would be a variation on the polygon covering problem. See $URL$ 

Yes, an example of a system that performs this task is T2. It does not solve the halting problem but instead it only attempts to solve certain special cases. A overview is at $URL$ . The newest version of this system is at $URL$ . 

Yes, ask your professor to give you a problem that you may solve as an undergraduate. You can also look for publications that say that the problems are appropriate for undergraduates. I think that a research project that you could do that would be interesting would be to create a language that would compile to the EVM (I suggest scratch $URL$ Another would be to explore user interface design for voice systems like making an Alexa App or one that you create yourself to solve some problem that you face. A good example can be found at $URL$