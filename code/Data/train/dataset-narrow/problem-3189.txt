That describes an application, not an entire system. If all you need to do is networking and "some small task", you don't need a VM to do it. You just need a program. Virtual machines, aka. emulators, have three primary purposes: 

This is a shame and I suggest you report that to the people who sold you the pi and the card. Obviously this is not what should happen, and exactly what went wrong may be impossible to say from afar. 

Are you sure about that? I suspect it is actually 14.9 GiB, and what you mean is the root filesystem in it is only ~8GB. If so, try this (you will need 8GB free to do it): 

If you click through the link, you will find a Pi Foundation forum thread where an Engineer makes it explicit: 

The pi does not have a hardware clock. That's not a big deal in one sense, since computer systems usually keep time with software. They do this based on the frequency of the processor, which is pretty accurate. On a systems which do have a hardware clock (most desktops, laptops, etc -- this is why you may have a little battery on your motherboard), the base time of day is taken from the hardware clock at boot, and you can later check the extent to which the software clock has deviated from the hardware clock. It probably won't be noticeable. However, it is a big deal in another sense, since without a hardware clock, the system cannot determine the initial time. Debian (and I presume openELEC) get it from a network source, which is the purpose of . So it sounds like ntpd is unable to do this on your wheezy for some reason (the fact that the daemon starts OK does not indicate that it has made a connection). An obvious reason would be that ntpd cannot connect to an external server because, eg, it is being blocked by a firewall on your network. 

This is an error caused by an mysterious identifier, . This could be because of a header that's the wrong version, or some unusual path taken in the build process due to context. You should have a look at . While I don't know anything about python modules, the rest of the half quoted warning, "Using deprecated NumPy API, disable it by..." might be worth reading and may even lead to a solution. 

I think you need to implement something that shuts the pi down when the voltage starts to drop. The new pi + versions have a brown-out detector that may help; while it won't cleanly shut down the OS, it will cut the power quickly rather than letting it slowly fade. As already described, sudden power loss is very very unlikely to cause any significant damage that can't be corrected with . Note, however, that it's probably not a good practice in the long run since you may still occasionally loose some data ( does the best it can and will leave the filesystem consistent and usable).1 You need to attach a voltmeter with a chip that can message the OS via GPIO; there are various kinds of things like this for the pi available online. 

Don't bother looking for software beyond the raspbian repos. Binary software must be compiled for a specific architecture (processor), which is why there are, e.g., x86-64 packages and i386 packages, etc. The pi has an unusual processor, and this is whole reason raspbian and the other pi distros exist. They've been compiled for that architecture, and software compiled for a different architecture simply will not work. Software that isn't available pre-compiled can be built from source on the pi, but I fear that "likewise-open", which currently is called something else, doesn't distribute source packages from their download site. The "open" in "open edition" implies the source might be available if you dig around (although beware this doesn't guarantee it will compile on the pi). There is also a good chance that the reason it wasn't ported into raspbian is because it's a genuinely non-free package for which no source is available. 

The diagram on page 89 and the description which follow do make it explicit only three interrupt lines are used. This does not seem like any kind of contradiction or inconsistency to me, anymore than having 4 phone jacks in my apartment but only 3 phones would be considered inconsistent. Having 5 phones might be a problem. 

There's no point in learning how to write such a script, however (it is a bit ornate), since the system is obsolete. The easiest thing to do there would be to just add something to the end of (but before the final line): 

You can't do this effectively, no matter how many transistors you connect. The motor is intended to run at say 5 watts. That would require 200 mA at 24 V (5 W / 24 V), but to step that up from 3.3 V you need 1.5 A (5 W / 3.3 V). The total amount of power that should be drawn through the GPIOs is 50 mA, and no more than 16 mA per pin. I believe if you try to go over this you risk damaging the pi. There's no way this could drive a motor big enough to power a car capable of carrying the pi around. Even if you used the 5 V supply and switched that somehow I think you would not have enough, since the input current is limited to 2 amps. You could use a relay board and a separate power supply. 

I have not used XBMC, but this is not a good idea WRT to a normal operating system unless you go to some lengths to set it up for that purpose. By implication, if XBMC isn't explicitly set up so, then it is not a good idea for it either. If the card really is read only, actually it will NOT damage your system, however, if it were really read only, you are unlikely to get to the point where you could run 'shutdown'. If you did (meaning again, you are certain the entire card really is read only!), don't bother running shutdown. Just pull the plug. Since nothing on the card can change, it does not matter what you do. Sure, you could find the init files responsible and edit them (obviously, the filesystem will have to be writable to do that). 

Including some code here would make things clearer, but this is probably all 32 8-bit registers listed on page 10 of the data sheet. The general idea is you are reading and writing to the registers described in the data sheet by address. For example, at the top of page 11 there are two "Touch Status" registers referred to, at addresses 0x00 and 0x01. Notice the addresses are 8-bit numbers,1 and so are the default values on page 10. This implies the registers themselves are 8-bits, and indeed, the little chart at the top of page 11 shows the meaning of the eight bits in each of the two registers. These ones are evidently read-only, since the "Write" rows are grayed out. [If you do not know what a bit field is, or what bitwise AND, OR, etc., refer to, you need to do some reading.] Each bit indicates some kind of state is either set (1) or unset (0). If you want to find the state of a bit in the first touch status register, you would read one byte (eight bits) from address 0x00 and then AND that with a one byte mask whose value is the bit you want to check (so, e.g., to check the third bit you'd AND with a mask value of 4). To set a bit for writable registers, you need to write a whole byte. That means you first need to get the value in the register and OR it against a mask with that bit set, and write the OR'd value. To unset a bit, you'd AND with a mask that has all bits except that one set (so to unset the third bit, you'd AND with a mask value of 255 - 4 = 251). In C, you would be dealing with the literal 1 byte (8-bit) value. A js or python library may provide some related convenience functions, but really there is not much for them to do beyond wrap the read and write calls. Note that all three languages use the same bitwise operators. 1 Because 0x00 is a hexadecimal number with two digits (the '0x' prefix is convention), and the range of two hexadecimal digits is 16 * 16, 0-ff, just as the range of two decimal digits is 10 * 10, 0-99. 16 * 16 = 256, which is the range of an 8-bit number (2^8 = 256), 0-255 in decimal. Each value represents a unique combination of bits and in one byte there are 256 possible unique combinations. 

It sounds a bit like the system perhaps ran out of memory, causing it to freeze up for a while, you ended up yanking the power, and somewhere in there the root filesystem got corrupted, which is why boot services are now failing. You could search through for to see if an out-of-memory event is reported there. There are timestamps in that file, so you could also look through the time period this occurred to see if there's any clue about the cause. You could try running on the second partition, although likely this has already happened. You can do this in another linux box, or, if you can get the pi to boot, as root: 

I think that should be "ESC" -- anyway, lots of informative stuff in the man page. In case you are unaware, there are 6 virtual terminals (VTs) with log-in prompts created at boot, but only the first one is where init messages appear. You can access these via CtrlAltF1-6. Which I think you know since you are using , making it sort of a strange question... 

If you get a lease, congratulations, everything works. Confirm with which should show an IP address associated with wlan0. If you can't get this to work -- e.g. fails -- it is probably a driver issue. Have a look at this list of wifi adapters known to work/not work on the pi and see if yours is there. 

PWM should not conflict with I2C. Everything below presumes the (predominant) Broadcom pin numbering scheme, which does not correlate to the physical arrangement of the pins. I've never used GPIO 4 for PWM; the normal PWM pins used are 12, 13, 18, and 19, making use of two separate PWM channels derived from one clock. Have a look at the chart here. Note that the crossed out pins simply indicate those which aren't available on 26-pin models. Although it contains additional information, the parts we are concerned with here are pretty much lifted directly from section 6.2 of the BCM2835 Peripherals datasheet, so they are authoritative. Notice that the normal PWM pins I've referred to have as either their default, or include as an ALT function, PWM0 or PWM1; this refers to the two channels just mentioned. The default purpose of one of them, pin 18, is access to the PCM clock, which is used for the timing of digital audio but may be turned to other purposes. Pin 4, which you have said you are using, is not connected to any of the above. Instead, it uses "general purpose clock 0". However, I can't fine any reason to believe this affects the I2C clock, and looking around at documentation for libraries which can make use of general purpose clock 0 via GPIO 4 and the I2C bus, there is no indication that this should be problematic. Put another way, it sounds like you have a eccentric issue. Whether this is due to a mistake in your code or connections, some physical defect in something, or the code written by someone else you are making use of (e.g., for the FM transmission) is impossible to say, but there is thus is no meaningful answer to your question because the problem you have is not reproducible in the general sense -- the "general sense" being that if you want to use PWM and I2C simultaneously there is not a problem and the "how to do it" is to just do it.