OK, is your code thread safe? Yes, I believe so. It is horribly complicated, though.... You have tagged your question as lock-free... it obviously is not lock-free. You have multiple locks. What's more, is that it is overly-locked. Additionally, I predict the performance in a concurrent situation will be much worse than you expect. Note that, for the typical put/take, you do 4 locking operations, and two atomic operations 

I have been though this loop before. I chose to do things in a slightly different way to you, in that instead of creating a Runnable, I instead add a try/catch block to the actual test. Each system has pros/cons, but the differences are really cosmetic. Using a does make the JUnit logic better contained in the utility code.... but makes calling the utility test code a little bit more complicated. I am not sure which one I prefer. I have a suggestion regarding this line here: 

This is generally nicely presented code, and it is good to read. Your suspicions that the code is not as efficient as it could be, is correct. There's some simple things to fix, and some harder ones. First though, the sieve: Sieve A sieve of Eratosthenes is best implemented as an actual array. Your code uses a list as a type of queue. Let's look at this code here: 

This is an inefficient way to do things with large input files. You should instead be reading the data 1 line at a time and processing each line as you get it. This allows you to have a much smaller memory 'footprint', and it allows you to discard data that you do not need.... instead of your while loop consider the approach: 

Finally, I implemented my own sort using the equals-value grouping, and turned the data back to limit it to 1000, and the results are: 

OK, that's enough about the general issues.... The better way. Storing your Rational numbers is an important part of many programs. The underlying problem with your class is that it is Mutable. .... you can change the value of a Rational. This is unfortunate for a few reasons: 

SuggestedEdits requires a special section.... You have three sections for SuggestedEdits. One uses the Creation date, the others use the Approved and Rejected dates. The approval and rejection are not activities by the Owner of the suggested edit, but you are counting them as such.... Only the CreationDate indicates activity by the OwnerUserId in the SuggestedEdit. The approval and rejection activity are recorded in the SuggestedEditVotes table (which you process from a different section). Note, you are missing 'accepts an answer' which can be calculated from the Post/Votes combination. As for your 'additional questions'.... Without the temp table Yes, this can be done without the temp table, and without the loop. You can do it all as a single query, if you use CTE expressions to hold the data. With a CTE containing the 'activity' data, you can find the first day in a streak (Using a self-join, does the user have activity on the previous day, if they do not, then it's the first day of a streak) Once you have identified the first day, you can also identify which activity belongs in which streak (the most recent start before the current activity must be the start...) Finally, the streak is as long as the furthest date that belongs to each streak.... As it happens, this is efficient enough to be run for all users on the whole of Code Review.... the query is (Here in SEDE): 

I was inspired to write a query that produced a graph mapping the perceived quality of your Stack Exchange answers over time.... in other words, "Are your answers getting better, or worse?" Because answer scores are very 'spiky', it seems natural to calculate a sliding average with a configurable window, to show trends. The result I have is: 

Enable FireBug Load the game (click the link) In the 'Scripts' tab in Firebug, select and scroll to line 273. This is the JavaScript code used to populate your initial grid....: 

By eliminating the array you save a lot of management time, and space. The code above contains a break condition inside the infinite loop instead of a loop condition. This is a common practice solution in Python for a do-while loop instead of a while-do loop. 

This logic would have to be duplicated in many, many places. It would be a much better design if you centralized the Gold (and action point, and position management) logic, and had methods like: 

General I am not happy with the variable name , it is too similar to which I also use. I have the code here in Ideone too: 

Why does it need to be public... what happens if it is called multiple times? That's an ugly solution. The ideal solution would be to construct the MessageProcessor at the same time as the MessageType, but, since that can't be done (as the MessageType is a parameter to the factory), I would instead recommend that you create a synchronized, or locked, or atomic method that is part of the Enum, and handles the situation for you. If your factory has the method: 

One important note here, is that I would not actually print the output of the result in the loop, but just record the details. The is probably slow, and that would make the timing results biased. I would accumulate the completion data in a different way, and print it all after all tasks are done, or, alternatively, in a different thread. 

you should probably have used a generator (yielded the grams, instead of appending them to a list). A generator would have identified you as a better candidate hmmm.... there really isn't a 2. Let me just repeat 1. Use a generator. 

Note the use of the "not a } inside the {}" logic in the regex. The examples above are running here in ideone 

At this point, the security 'level' is not changed from your original code. Unfortunately, if someone knows your code, and knows all the hashed passwords, they can easily rebuild this function, and then just start running dictionary values through the same algorithm, and if there are any hits, in any of the password hashes in your 'thousands' of users, they will gain access to your system. The probabilities of getting lucky are proportional to the number of users you have. What you have called a 'salt', is not actually a salt, it is just a way to make the attack slightly harder. A real salt is unique for each user. When the salt is unique, the potential attacker has to be able to know the salt value, and then guess the password too. The odds of getting these values are not dependant on the number of users you have the password hashes of. The trick for the salt is to create a random value for each user, and store the salt in the database with that user. 

Alright, apart from the thread daemon status and names, the rest of the thread model looks OK..... You have a thread that queues the events in an ordered queue, then a bunch of threads that decode them in paralle, and a final thread that removes them in the same order as their insert order. From what I can tell, this is good. Generics You go part way to working with your generics, but then you get lazy, or there is an inconsistency in your code. Inconsistency: you have where is Now, ChannelDecoderEvent is: 

Aseem has rightly pointed out that the preceding if-condition essentially makes the limit redundant. My preference is to keep it there for clarity, but, it does create duplication of logic which may lead to bugs later (How did I miss that the lenght is checked first... hmmm). Your call as to whether you should replace the with just . The Pattern should be made static. There is no reason to re-compile the pattern for every call to the method (Patterns are thread-safe): 

@tim has covered a bunch of what I was going to add, but here are some additional points: You should anticipate having whitespace in the input. A "simple" replace-all would suffice: 

This function takes the dimension of the board, the position (in one dimension), and which way we want to look for our buddy. So, consider we want to find the position of our 'left' buddy: 

Error Handling Your encode method assumes there is enough space in the array.... You should have something like: 

This type of question is always interesting, because I always feel there is the easiest, and the best way to do things. Easiest often relies on using native mechanisms for the work. The best, I feel, is often to use primitives and to do as few object creations as possible. Here are the two candidate solutions I can suggest for the easiest/best. The Easiest uses the method, but unlike other solutions suggested here, it is purely 'additive'. No inderting things in the middle, and no inserting extra stuff which gets deleted. It also does some input validation. 'Trimming' the value before the split is important.... The 'best' option is plain O(n) performance ( used in some solutions is not going to produce an overall O(n) solution). This suggested solution does not create all the intermediate String objects that the other solutions create, and it uses O(1) extra memory space. 

Bottom line, it is almost always a potential bug to have a synchronized method on your code, unless you fully intend for other programmers to be able to impact the concurrency model of your code. This applies for non-static methods too. In instance methods, create an instance lock: