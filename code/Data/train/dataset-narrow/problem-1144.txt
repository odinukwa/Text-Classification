print a summary (no details for each file), with a byte-per-block size ... i.e. print the number of bytes in the current directory. Then, using grep (and perl-compatible regex).... use quiet output, which returns 0 on a successful match, and 1 on no-match. In other words, make sure the line starts with at least 10 digits.... i.e. bytes. Putting it together, the grep will be successful if the current directory is at least 1GB. I tested this with: 

Now, you can call that method with either the or the top nodes... but, that method really belongs on the stack itself, not outside the stack. Move it to the stack, and it becomes: 

Extracting the unsigned calculation just to solve the possible overflow problem is unnecessary. Of course, having an unsigned version of the function may be useful for other reasons in "real" code, but that would be a different motivation. You can handle your problem here with a simple variable, and not a whole function: 

Now, even with the simpler code, you still have the two threads, one needs to wait until a condition is met, and when the condition is met, it needs to execute some work until the condition is reverted. In your 'working' thread you want a method to call which will start the lights blinking, and then which will stop the lights. The pattern to use is: 

That code is 'ugly' because it is hard to follow the logic through, the empty catch block is a mess, and the blocked lambda type expressions make me want to create a function for them, so I do.... I created the function: 

Note that I have a main method which processes image files from the arguments, and reports on their timing of various stages. Specifically, I report the time to load the image, the time to extract the array of pixels, the time to transform the pixels, the time to write the transformed pixels back, and finally the time to write the image back to disk. Note here, that the times for a large picture that I have on my computer, are long: 

Your problem is an integration and management problem, rather than a programming problem (though there are some issues there too). Approach 3 Approach-3 is a problem, and I would not use it for your task. Repetitive tasks require a well designed and reliable infrastructure to handle them. The quirks of time are such that things like daylight-saving, system clock resets, and other issues will play havoc with things. For example, What will your task do when you 'spring forward' in daylight savings... will it fail because the next scheduled time never happens? In fall, will it go idle for over an hour when the same hour is repeated? Cron (and on many Linux distributions, Anacron) has very well documented practices and behaviours for these types of issues, and the predictable, and reasonable use case makes a lot of sense. Use Cron. Additionally, if there is an issue sending a mail, or anything requiring rescue in Approach 3, you will fail to reschedule, and your program will break. Approach 2 This is actually quite similar to Approach 1, but it just shifts more logic in to the process method, and it mixes up the responsibilities in that method. SOLID principles suggest having just a single responsibility in each method, so I don't like this approach. Additionally, you can only process one campaign at a time using this approach. Too much happening in one place, and possible opportunities for parallelism are removed. Approach 1 I prefer this approach for the relative simplicity of the single-campaign method, and the way the campaigns are processed. Improvements Having said that, there are problems still. The biggest is that your program is not defensive enough. Even though you expect only one instance of the program to be running at any one time, you should still program defensively and assume there could be more. Cron (anacron) will ensure that it does not start a second instance of the program if the previous instance has not yet completed, so cron will not cause a problem, but you may have some mix up happening in your testing, or you may run it yourself when cron has it running already, leading to problems from there. I am not very familiar with RoR, but the following looks like it could lead to conflicts and race conditions with other running processes: 

newInstance() This code will work, but only for a subset of Collections. For example, there are many Collection implementations that do not have an accessible default constructor. What if the input collection is: 

NewLine The newline at the end is correct... at least according to your code. ignores the last line of input files if it has no characters. This is a standard system to have for most operating systems (the last character in a text file is a newline). Your code is perpetuating this process, and it always adds a newline after each line printed. Thus, your file always ends up with a newline at the end. This is a good thing. Exceptions Java Lambdas cannot contain expressions that throw caught exceptions. This is a weakness. The weakness is so sever that as part of Java8, there is the new Exception so that IO-based operations can throw an unchecked exception. The easiest way to use it is to change your catch blocks to: 

Now, that Node only works on values, but you want it to be an . Using generics, this is a treat (while we are at it, we will make and private and final, and add getters for them...): 

The only reference to any concrete class here is the in the main method. Everything else is treated at the lowest usable interface level (Collections, Lists, Iterables). I use StringBuilder to build things 1 line at a time. This improves performance because each print is expensive, so you do fewer prints. Java8 has a better way of counting the members, and also joining the Strings with the character: 

if either password was null, you would get a NullPointerException before you check to see whether they are null. Use instead of the calls. 

The above will queue threads up, using the 'fair' (FIFO) nature of the Re-Entrant Lock (or you can use the faster 'unfair' version too). It uses the lock to queue up threads, and it will release as many threads as times you call . 

This code prints each just fine, but the input to the function is always index ... so you only actually test the first input. The second item is that you only test for key1. The other keys are not tested. The loop code should look like: 

Your use of an array to store previous entries is convenient, but it requires a lot of memory use for values that will be thrown away and not reused. It's very simple to keep the two most recent values in simple variables, and not have the array at all. Consider: