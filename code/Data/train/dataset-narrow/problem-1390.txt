Beside that, I think your naming is quite remarkable and rather hard to read because of the length: For instance it's hard to quickly distinguish between: 

I'm not saying the below revision is an improvement but it has eliminated the need for . The penalty is to have the index as a separate argument to which violates the idea of a state object. One could argue that the index is not a part of the (splitting)state but just an iterator variable and then everything are nicely justified again :-) 

The first thing I notice is the somewhat misleading method name . I would call it , because it only checks if i is a factor of number - not if it is a prime factor. 

If their role is more advanced than that with methods and state, it IMO calls for at class hierarchy in some way like: 

Because of the flag-behavior of ConsoleModifiers.Control it will be true if any combination of Modifiers are pressed that involve . It would maybe be more useful to make it more distinct like: 

The only caveat is (as others have pointed out) that you don't check the before you start walking. That could be solved by using in a way like this: 

First of all: If I were you, i would create a Point struct instead of having two parallel vectors for x and y coordinates: 

EDIT I admit that Husk has a point about especially in where the length reach as much as but tests on my computer shows only a pair of seconds in expense for n = 8. The algorithm exhausts the stack for n = 10 anyway... As an alternative you could use which seems to have the same performance as Husks version. 

Writing something consecutively to the console is of very little value. OK, returns a list of primes, but you really can't use them until all primes are calculated in the domain of , and that's a lot. For instance, it is useless to write 

I am now considering ways to separate these concerns into several functions and even several independent libraries. For example, could be restricted to a single argument, to cover only the first concern: 

Stick to shared conventions for the naming of variables. Do not use all-uppercase for regular variables, only when you wish to indicate a constant value. Use a name specific to your appliation/website, organization or company instead of GLOBAL for the global variable referencing the root of your library, if any: it is no longer needed using Asynchronous Module Definition with requireJS. 

A separate function/library could be defined to declare dependencies, another for synchronous/asynchronous loading, and yet another to import and export symbols in a shared context. These separate functions may communicate and interact through a common event system (pub/sub). 

simple to declare JavaScript modules with dependencies simple to implement your own version of the library to customize its behavior 

The function has different implementations with different behaviors: it may create a module in the global scope, in a private scope, synchronously or asynchronously after loading dependencies. When the function is synchronous, it returns the module just created, which allows to use as a direct replacement of the Immediately Invoked Function Expression pattern typically used to declare modules in JavaScript: 

Please review the usability of this API from the point of view of a developer who uses the API and from the point of view of a developer who implements the API. 

You should use the JavaScript Module Pattern to create a private scope for your function declarations: 

I may be able to provide more practical suggestions if you show more of your code, especially at the "top", part of the main program. 

I checked the code with latest JSLint; it is a useful tool once you know what to expect from it, e.g. by reading "JavaScript: The Good Parts" from its author Douglas Crockford. It would definitely help you to spot the missing semicolons, which can cause unexpected issues when you minify your code. 

You could check if countto are allowed numbers using your own function getInput. For that, you can change: 

The code works, but I'd like to know if it could be improved (is there a clever and cleaner way of doing it?) and if the style is good. Thanks. (Here is a link to the original PDF file: $URL$ 

I'm not an advanced programmer, but I have some suggestions I think could improve the performance of your code: 1) In the first line you make and then you use this variable 3 times calling . Instead, you could use , so you'd call this function just once. 2) I don't understand the use of here. At least in Python 3.5.2 I ran the code wihout the and it works just fine. 3) In the first if statement inside the for loop you test the minimum and maximum values of inp[1] twice. You probably wanted to test inp[2] in the last part. 4) Here: 

2) When the program asks for a value to the extra bum, it says you can choose 0 for no extra bum, but you set the minimum input allowed to 1. So you must change min to 0. Answering some questions: 

(I used .format here because it's the way I know, but it's not ok to mix format and "%" styles in the code. You should change that for the sake of coherence!) 

This file had some singularities: 1) The information about each candidate was separated by '/' and not by new lines. And each information about the candidate (ID, name, exam note, composition note) was separated by ',' 2) new line characters were spread randomly throughout the text (I think that was caused by the Notepad or by the PDF program auto-break line) 3) The page numbers of the original PDF remained in the text file, and could be found beside the ID number, one of the grades or between parts of a name, surrounded by new line characters like "\n26\n". The page numbers ranged from 15 to 26. This is a fragment of the original text as read by Python: 

As others have pointed out you only have to check the number of distinct characters in the sentence. A one liner doing that using linq could be: 

This is great work and very useful. I have the following comments/suggestions: 1) The usual suspects: a) should/could be: 

If you've showed the environment the function is used in, the review could be more useful, but I think your reasoning is right, except that Lazy is used to defer instantiation and you actually use the lazy-created object () the first time it is called for by returning DataCache[key].Value. Therefore Lazy is of little use in this context as its object is instantiated at the same time as the Lazy. IMO your DataCache would give more meaning if you up front filled it with all possible queries without actually using them and then call them as needed. Alternatively you could just cache the queries directly in the DataCache without Lazy. 

Update I'm not sure, if this is obvious to others, but, if you don't want to "pollute" your classes with the DebuggerDisplay method or you want to create a custom debug display to a type that you can't modify, then you can place the DebuggerDisplay as a static method on a static class like this: 

I find your code clear enough, but you could improve it a little bit, so you only do the add operation once: 

2) When checks the input list it does not find changes to items in the list, if they are of reference types. In your test environment it find changes to the string items, because a string behaves like a value type in this case and the changes made to the string actually make a new string - not a change to the existing string object. So your method actually finds a new string not a changed string. If your list was a list of a class like: 

However none of the solutions are very performant if diamond size is increased (> 2000) due to the concatenation of strings. In that respect a good old iterative solution is preferable: 

Well, I'm a beginner programmer too, so I won't be able to answer all your questions, but I have some suggestions: Some minor changes: 1) This part: 

When you say retry you mean something like a "play again"? In this case you could use something like: 

5) You made a while loop that evaluates true and put an if statement that may break it right after it. Instead of doing that, you may test the condition of the if statement in the while loop itself writing and removing the else statement that breaks the loop. 6) (edited) That k variable is actually unecessary. If you set j to 0 in the beginning of the first for loop, and add 1 to j in the beginning of the while loop, you will get the desired result without the need of an extra variable. With these modifications, the program would be like: 

I made this script to carry out a specific real-life task, which was to sort a list of candidates in a public competition by grade. The file with the informations consists of a text file copied from part of a pdf with the ID, name, grade in the exam and grade in the composition. There are a little more than 1,000 candidates. I needed it sorted by the final grade, which is obtained by the formula: 

(You may note that there's a page number between the last grade of one of the candidates and the ID number of the next one right in the beginning of the fragment) So I had to find a way of detecting and removing the new line characters and the page numbers, and put each part of the string in the correct place taking into account that the names of the candidates could be of any size (Like "Anderson Soares Freixo" or "Maria Auxiliadora da Silva Santos Xavier". I came up with this code: 

I know these are minor changes, but I believe some of them may save some CPU and I hope they're useful for you. 

Like the method in AMD API, which is very similar, the function mixes separate concerns in a single call : 

Use a dynamic module loader such as requireJS. You can use it to load modules dynamically using AJAX, and it features an optimization tool to combine your scripts into a single file to reduce the number of HTTP requests on production server. 

The last two parameters and are optional. The name of a module is a string which identifies the module and allows to reference it in the list of needs of other modules: 

To use the function, you can write your own or build it from building blocks available in the scope or not project. The building blocks are sorted in levels. The level 1 provides the bootstrap, it must be loaded first. One building block may be picked from each level. Building blocks from lower levels are expected to be loaded first, but they are all optional. Building blocks in higher levels use the function of the bootstrap to define a replacement function "scope", declared as a module. For example: 

When you implement the API yourself, you may either create a building block on top of the scope bootstrap and other building blocks, or rewrite the function from scratch, replacing the bootstrap and all building blocks altogether. In a browser, you can load building blocks with script tags, then load your own modules: 

You should think about the way you wish to handle the communication between modules. The latest trend is to abstract and decouple the communication using publish/subscribe pattern. You can find more details in The Scalable JavaScript Application Architecture presentation by Nicholas C. Zakas, and you may be interested in the open-source framework that I developed based on this approach, which I presented recently in Paris JavaScript user group. 

For each dependency in the array of needs, a property of the same name is set on the context object which is provided as argument to the function: