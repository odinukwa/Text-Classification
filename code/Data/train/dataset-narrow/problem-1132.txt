First row of table, left = 20001, right = 21024, since Modify API is called and function arguments: start = 0, count = 1024, value = 1, inside Modify API the variable is calculated as 20001 and is calculated as . The two variables of left and right are iterated from beginning to end 10 times, each iteration two variables's values are recorded in the table. And the highlighted color yellow of column marks that the index of will be incremented by value , column marks that of tree will be incremented by value . 

Apply bit mask technique In order to solve time out issue, I had to use bit mask instead of using encoded key by using the above function EncodeKey with the argument HashSet numbers, apply bit mask techniques learned through top coder article called A Bit of Fun: Fun with Bits. The code is much easy to follow after I did draw recursive tree on the test case, and bit mask set operation is also easily to look up through the top coder article. Here is C# code with those two test cases. C# code passes all test cases on Hackerrank. Please help me to be a good tester, a smart problem solver to work on basics first. 

Four more places The start1 and start2 variable should be applied to the index value of the array in another four places. The comments are added starting from "bug fix", the variable's declaration of firstNode1, firstNode2, newStart variables. The following is the C# code without a bug based on Leetcode 4 online judge: 

There are \$k\$ obstacles on the chessboard preventing the queen from attacking any square that has an obstacle blocking the the queen's path to it. For example, an obstacle at location \$(3,5)\$ in the diagram above would prevent the queen from attacking cells \$(3,5)\$, \$(2,6)\$, and \$(1,7)\$: 

Reduce the number of conditions/loops. The whole method is doable in a single loop. See below for an example. Prefer nouns for names of variables and verbs for functions/methods. For instance, instead of calling the return value , call it . Refactor the code to handle the connection getting closed before getting all of the expected bytes. According to a Microsoft Winsock web page for the call, "If the connection has been gracefully closed, the return value is zero". At which point I believe your code will try again and get (with an error code of ). And then return false even though it may have missed only say the last byte expected. Recognize values that are constant with the C++ type qualifier (or as you've done for compile-time constants). Seeing as how you used (available since C++11), go ahead and also prefer using . Consider making the method a method of a class that the client can use too (I don't demonstrate this though). 

Regarding "best practices", I'd recommend checking out the C++ Core Guidelines for suggestions like: 

Instead of naming a bunch of elements that are all the same type, use an array for your structure's elements like , or use a . Or if you really don't want to change your structure's content, use to craft a of your structure's elements on demand. If you used a regular array use on the iterable elements of the two structures. A or already has non-member function support for operators like , , , etc. though. Kick back and enjoy a brewski. ;) (only if allowed of course and be sure to drink responsibly etc. etc.). 

2. Recognize your code's structural invariants, and then enforce those using encapsulation. Take the class for instance. I'd guess that the field is dependent on the field. If correct, then make these inter-dependent fields private. Provide accessor methods for these values and a mutator method for the data field which updates the hash. If nothing else depends on the or fields, then I'd suggest making this tuple of info its own class and put the encapsulation within it. Then compositionally incorporate this new class into your block class. This way can still be a with its members publicly accessible. Use Non-Member functions unless the function needs direct access to the representation of a class (C.4). For my favorite explanation of what I'm suggesting here, please see Scott Meyer's article: How Non-Member Functions Improve Encapsulation. 3. Prefer value semantics over reference semantics. You haven't shown any code which exemplifies reference semantics but for the sake of C++ developers everywhere (or at least for my preference), please keep with value semantics as long as you can: don't expose to your API any classes that inherit from other class (see inheritance is the base class of evil). How to improve performance? Use constexpr or something else? 

I would also suggest that you look into some popular MVC frameworks (Zend Framework 2, Symfony 2) to get comfortable and confident with the concepts. 

Let me make it clear for myself. You have an array of images, which sometimes can be empty. You start off by checking the first image, if it's valid for your needs you take it, and if not you keep on checking the next one, and the next one, and so on until you find the one which is valid. Is that right? If so, here are my few thoughts. Firstly, I must say that Glenn has made good points, namely: 1) factor the common code in all cases out to a separate function, and 2) if you have nested conditionals, most times it's better and more readable to replace it with Guard Clauses. However, personally I would prefer the following solution: 

The first code snippet is an example of Active Record, which, I believe, violates the Single Responsibility Principle by mixing the logic with the logic. The second code snippet is thus better in that it separates the responsibilities. The naming of classes is somewhat ambiguous and inconsistent with the commonly used terminology. The aforementioned responsibilities would often go into two separate layers (namespaces) called layer (sometimes , , etc) and layer (sometimes , , , , etc). The layer contains objects, like for instance. The objects may extend a base class often called or . The layer may contain , , , or classes depending on which strategy (Design Pattern) you choose for persisting the objects. So, eventually you might end up with something like the following. Package structure 

I think it's a matter of taste and preference. In either case, you would have to duplicate something. But, there's something that drew my attention. I don't claim it to be correct or be a solution to your problem. Hard to say without knowing the context and data structures that you use. Anyways, here we go... I noticed that in both cases, whether or not, you pass the same arguments, though to different methods. I suspect that this checking might occur in many other places as well. So, what if we create a method (e.g. ) and move this condition statement to that method. And the method would internally decide whether to add a new or modify the existing one. Somewhat similar behavior may be observed in the method, where the method checks if the element has already been added to the and then returns without adding it twice... Then, we end up with something like this in the client code: 

Problem statement You're researching friendships between groups \$n\$ of new college students where each student is distinctly numbered from \$1\$ to \$n\$. At the beginning of the semester, no student knew any other student; instead, they met and formed individual friendships as the semester went on. The friendships between students are: 

My introduction of the algorithm The algorithm is the hard level algorithm in hackerrank world codesprint 10 in April 2017. I did write a recursive depth first search tree algorithm in the contest, passed the sample test cases but failed all other test cases with wrong answer errors. So I spent hours to study one of code submissions and put together a C# solution after the contest. The algorithm turned out to me a simple depth first search(DFS) after hours study, debugging and walked through the sample test case. My understanding of DFS solution here is that the base case in the sample test case shown in the graph is the node with one connected edge, for example, starting from left to right, node with weight and node with weight . For any edge in the graph, for example, edge :, node starts a DFS search until it reaches node whereas node starts a DFS search ended at itself. The dynamic programming part is not easy to come out and it takes some time to build the recurrence formula. Base case is easy to figure out, node with one connected edges. For any edge to serve each of two nodes, it has to calculate the maximum/ minimum value include/ exclude itself within all connected edges. The C# code passes all test cases. Depth first search is my favorite algorithm, sometimes I forgot that recursive function is the economical choice for DFS compared to iterative one using stack. 

I like the idea of this utility class, but there are a few points I would like to mention. Let's start with naming. I would rename the class, probably, to one of the following , , or . The rule of thumb is to put the / nouns in the end of the class name. Personally, I like the first two. Then come the constant fields which could be shorter. For instance, they could be named as instead of and instead of . That is, the 'BETWEEN' part is redundant because it's already obvious that a separator separates the one from the other. Two other fields would be better named as and , which is more intuitive. Another thing is that you have two separate methods for adding the field names and values and then you check that there is a corresponding value for each field name in the method. You also check for indexes and arrays' length in the method. All these checks are error-prone, but they could be eliminated by enforcing the one-to-one correspondence rule of the field names and values in a single method for adding those fields and their values: 

This way you control the state of your object and have no need in the and methods anymore. Moreover, internally I would store the field names and values in one data structure, rather than in two separate arrays. The single structure could be a or a , the latter one is preferable if you have a class. This brings us to the class. I think, it would be more practical to encapsulate the field names and values within the class, which will yield a better OOP-style design. Also, this change will allow you to transform the class from an inner class to a static nested class, because you don't need the reference to the outer class anymore. After you encapsulate the field name and its value in the class, the field would naturally belong to the class. And because the class name is , the field could further be renamed to . One other opinion on the constants would be that you don't actually need them because you don't use them anywhere else besides the methods. So, you could just use the string literals instead: 

If the friendship \$1\$ and \$3\$ are added before adding 4 and 5, then the value is less than \$24\$. After the contest, I studied one of C# submission with maximum score, and then did some code review, tried to understand the graph design and also read the hackerrank editorial notes, understood the process to get maximum value of friendship. I put together C# code and also tested on hackerrank, the code passed all test cases. Please help me to review my C# code. Hightlights of changes Add name variable in the class GraphNode to help identify node; add the test case to help understand the algorithm, and be able to add comment to explain the function Connect; use meaningful variable names after code review. I already spent hours on the algorithm and really look forward to work hard on graph algorithm and be able to perform one graph algorithm in week of code contest in short future. 

To summarize, to increment nodes value by 1, only need to increment nodes represented in tree variable, the index array is . The design concern The API Modify and Query works together very well with SegmentTree, but however each node in the tree does not explicitly include the range it covers, I need to look into this issue and see if there is a quick fix. I may not fully understand segment tree or binary index tree and have some misunderstanding of segment tree, I like to ask code review. The C# code passes all of hackerrank test cases. 

Problem statement: Find \$kth\$ largest element in the union of two sorted array. My introduction of the algorithm I spent a few hours to review two algorithms, Leetcode 4:Median of Two Sorted Arrays and Leetcode 215:Kth Largest Element in an Array together since median is a special case of kth element problem, and also read the article to talk about the kth largest element in the union of two sorted array, 3 solutions: 1:The trivial way, \$O(m+n)\$; 2: A better way, O(k); 3: The best solution, but non-trivial, O(lg m + lg n). So, I decided to practice the algorithm "Find kth largest element in the union of two sorted array" (similar to Leetcode 4 and 215, but with some difference.), using binary search non-trivial one, C# Source code. Please help me to review the code. 

Which is an anonymous/unnamed return value. While your question is tagged C++11, I'll opine that it's a nice practice still to be aware of the newer standards and that with C++17 you're guaranteed copy elision. I suspect that compilers of earlier standard implementation are also likely more able to support copy elision when using unnamed return values. Copy elision tends to help with performance. Moreover, returning output through return values encourages value semantics, aids with constness, and I find it makes it easier for people to reason about the code. As to , I haven't seen it increase performance much of code I've used it with. OTOH, I love what recognizing code as means — computable at compile time — and I agree with Scott Meyers recommendation: use whenever possible (from Item 15 of his Effective Modern C++ book). A related nicety IMO is that types having constructors can then satisfy the concept. How to store the data that all are byte arrays, but some of arrays have fixed length (such as SHA256 hashes), and some have dynamic size (such as data)? I like how you've already done this — you're using for the fixed length types, and for the dynamic types. It's a preferable starting point so long as these types' access don't allow your data invariants to be violated. Prior to C++17, you may just want to update the type you're using in the and containers to . Since C++17, we can use for this type as one of the commentators suggests. Deeper in, you may need to answer whether speed is more important or data correctness is. A structure of arrays (SOA) often lends itself better to speed, while an array of structures (AOS) can lend itself better IMO to correctness. How to pass empty byte array? sha_t() is ok? It's not clear what you're asking with this question. Sounds like you may want to read about value initialization (introduced in C++03). How to deal with time and make code short and fast? Seems like this question is asking again about how to improve performance. If so, please see my response in that section. What SHA256 library should I use? The code from the most recent OpenSSL library is what I'd go with just simply because I suspect it's had the most eyes on it. If your code is license compatible, you may find it easier to just copy the OpenSSL code for SHA256 into your code instead of trying to build the entire OpenSSL library and then linking with it. 

My introduction of Algorithm I was asked to write a simple recursive algorithm two years ago at the end of important meeting. I like the algorithm, so I reviewed the algorithm today and write a short C# solution today. I am planning to study a few of short C# courses by myself on pluralsight.com called "defensive code in C#", "Code Contracts", "Provable Code", learn to write better C# code in next 2 weeks. I am learning C# right now. I am trying to get some critics on my practice today. 

Given the queen's position and the locations of all the obstacles, find and print the number of squares the queen can attack from her position at \$(r_q,c_q)\$. Input Format The first line contains two space-separated integers describing the respective values of \$n\$ (the side length of the board) and \$k\$ (the number of obstacles). The next line contains two space-separated integers describing the respective values of \$r_q\$ and \$c_q\$, denoting the position of the queen. Each line \$i\$ of the \$k\$ subsequent lines contains two space-separated integers describing the respective values \$r_i\$ of \$c_i\$ and , denoting the position of obstacle \$i\$. Constraints \$ 0 \leq n \leq 100000\$ \$ 0 \leq k \leq 100000\$ A single cell may contain more than one obstacle; however, it is guaranteed that there will never be an obstacle at position \$(r_q,c_q)\$ where the queen is located. Output Format Print the number of squares that the queen can attack from position . Sample Input 0 \$4\$ \$0\$ \$4\$ \$4\$ Sample Output 0 \$9\$ Explanation 0 The queen is standing at position \$(4,4)\$ on a \$4\$x\$4\$ chessboard with no obstacles: 

I like to answer my own question after 12 months. My review is to work on a simple algorithm first, at least a medium level to help understand the dynamic programming solution before asking code review. Try to understand the algorithm and how to solve it using dynamic programming solution with time complexity O(N) first. The best way to do it is to work on the problem "Find maximum two disjoint subarray product of sum" first, fully understand the design of dynamic programming solution first using the array's problem. I spent a few hours to think about the algorithm on May 30, 2018 and then I tried to isolate dynamic programming algorithm. The problem "Find maximum two disjoint subarray product of sum" is very close to Leetcode 152 Maximum product subarray. I wrote partial solution and the link is here. After that, the rest problem is to work on how to solve a depth first search algorithm on a tree. The whole algorithm should not be hard to solve anymore.