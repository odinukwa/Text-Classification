If you want to, you could even build that original array dynamically, which will make this much easier to maintain: 

Your code does not actually function the way you want it to. checks for the existence of that element, not whether its value is set. Your radio buttons don't have a attribute on them. They really should. You should cache your selectors. You're querying for a total of 7 times in your code, and an additional 4 times on every click. Instead of listening for every click inside , you should instead only listen for the event of the radio buttons. On page load, if there's a value in the input text field, all we have to do is check the correct radio button. The event listener will take care of the rest. 

There is one thing I don't line about : you are leaking memory. should be a pointer, not the object. You are creating the object with , by doing 

you are leaking memory because you lose the reference of the pointer returned by and you cannot free it when you destroy the object. And you are not checking if is returning 0. So I'd change it to: 

you are indeed setting a new value to , but because is just a copy, the original does not change and with you get the orginal object. That's why 

shouldn't do end in a recursion, because points to , but is still unchanged and points to . And now you can use the same behaviour for destroying the Employee object. Let's say you have function pointer in which points to the destroy function: 

Having individual setters has a couple of advantages: A dedicated setter allows you to put dedicated validations for these properties. You could obviously put them in the bulk setter as well, but that will make the bulk setter large and unwieldy very quickly. You want methods to do one dedicated thing instead. That keeps them maintainable. Dedicated setters clearly communicate which properties can be set. With a bulk setter, it needs documentation or a look at the source code to learn what I can legally set. I usually don't want to look at your class code. I just want to look at the public API and understand how I can use that class. That's not to say bulk setters are bad per se. If you know folks are likely to set two or more values after another because they naturally go together, you could allow for a method. But as you can see, that's still much more explicit than a generic . Also one could argue that if you need to set arguments that naturally go together, you rather want them to be in an object of their own and pass that object then. On a side note: Your bulk setter will create properties on the fly for those keys that are not properties in the class. While you could consider that a feature, it makes debugging harder because a developer has to know the object's current state at runtime to know what properties it has. On another side note: a base class is usually a code smell. It tends to amass unrelated functionality and turn in a God object quickly. It also hampers reuse because all your classes will depend on it then. 

The code above works, but the text is not associated with the radio button in any way. To remedy that, consider wrapping labels around your radio buttons: 

Are you sure you really need that selector? Wouldn't do the job just the same? While we're at it, why are you listening to the click on the elements, and then find the via ? Can't you just listen to the event on the s themselves? Is there any method to that configuration? I wasn't able to deduce any algorithm from what you've provided, but I'm sure there is. You'd be better off calculating it on the fly, if possible. 

you are dereferencing the pointer returned by and making a copy of the object into another object. But I failed to realize is that points to the original location returned by . So when you do 

and in you just do and . I've checked the code above (I've updated with the destroy functions) with valgrind and it told me that everything was freed correctly. 

edit3 The fact that my little changes do not have the problem of endless recursion in kept me thinking about it and I've been running the code with the debugger to see why I didn't have the problem as well. And now I understand why my code does not have that problem, and your's shouldn't have that as well. In fact, I realized that there is a way of freeing the memory correctly without have a separate member like . Let me explain: In you do: 

If you find that you have to do this a lot, you can abstract it into a custom filter, which you can then use in your selectors: 

If you don't care about IE, you can check the property directly, which is much faster and much more reliable, since also contains any arbitrary data that might have been set (possibly by a plugin): 

To make all this easier on yourself, don't re-invent the wheel. Look into John Resig's tiny inheritance library: Simple JavaScript Inheritance. 

P.S. is not very descriptive. You should consider coming up with a more intuitive naming convention. 

Please remember to always cache your selectors. To get the of an element, use instead of . There's no need to use two separate steps to first get the value, then set it. Instead, pass a function to , and return the new value you want. To convert a string to a number, just prefix it with the plus sign (e.g. will return the number ). It's safer, and more concise, than . When using CSS selectors, you should always strive to use the native CSS3 selectors, since they're much faster than jQuery's own custom selectors. and are not CSS3 selectors. In your case, you should use and , since they're native CSS3 selectors. Since IDs are unique per page, there's no reason to qualify an ID selector with the tag name (as you've done with ). Just use the ID on its own. Again, better performance. 

Yes, always. Except for when you can reasonably justify not to. Following SRP will make your code easier to maintain in the long run and will increase reuse possibilities. Once you assign multiple responsibilities, you will have to have the same set of responsibilities in another project if you want to reuse the class. And the chances for that are smaller than for single responsibilities. 

No. Having many small classes is perfectly fine. It's a matter of appropriateness though again. I found it helps to keep things separated and small. However, it also gets harder to visualize the code flow in your head then the more classes you add. 

Very good question. I'm pretty sure this can't be done within the selector. However, instead of checking the every time it's clicked, the collection before applying the event listener: 

No need for all that. Just use one bracket group, negate it (be prepending a ), and use the return value directly: 

jQuery's method can take a callback function - it'll be called for every element in the collection - and will use the returned value to set the element's html. You can use bracket notation to access the key in your , so that you can dynamically get to the key you want with the string in the brackets: 

so now the destroy method can do to free the memory of the base object. edit An alternative is that you create a init function for objects that gets an object as an argument and does not allocate memory by itself. I'd do: 

I told you that you would be leaking memory because you lose the original pointer that returns. And that is true, however I failed to realize that you have in fact a pointer pointing to the original address that returns: the member of the struct. In you do 

and this solves the problem with the overloading and the freeing, even though we both didn't realize it at the time. So again, when you do 

That depends entirely on your viewpoint. You certainly don't have to have a UserEntity, UserRepository, UserFactory, UserFinder, Email, Username and Password Value Objects, AuthenticationService AuthenticationAdapter and implementations. But you could have. Also, we could (no, we should) argue, whether storing the password hash in the user is a good idea. You'll only need it to authenticate and then never again, so that's one time in the application. After that, you can use a token or set a flag in the Session. There is no need to store the password then, regardless of where you do the authentication (a separate component sounds fine to me. You could inject that to the User and then delegate the call). The most important thing is that the code does what the enduser thinks it should do. However, it should also be implemented in a way that won't come back to haunt you, should your ever need to change the application. So whether it's "okay" or not pretty much depends on the scope of your project. Ask yourself: "is it good enough?"