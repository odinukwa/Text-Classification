Then, you can use as usual. I've declared it as , which is the type of a literal string (assuming you're using a reasonably modern C compiler). (I notice that you're not using any at all. Your code would definitely benefit from that.) In other places in your code (such as the handling of ), you do something similar where you when you could be just assigning a pointer. Also, you fail to the anywhere so you have a memory leak. 

The clause is not required in Python. You can just delete that (and the ) and the logic will be unchanged. 

As a matter of style, I would always surround conditional blocks with braces, even if they only contain one statement: 

Your function does not modify so it should be declared (). Normally, all-uppercase identifiers are used for macros, not function parameters. Consider calling these and . 

As you have probably noticed, this is not efficient because you have a loop running times (which could be over 2 billion). The way to make this more efficient is not to make your code faster, but to choose a better algorithm. I'm not going to tell you outright what the answer is, but do the following. Add some output to your loop: 

The return value of is a type such as (the exact return type ultimately depends on the template type parameter ). 

One optimisation that would make your code run up to twice as fast, is to use the observation that a prime factor of cannot be greater than . So you can limit the number of times you iterate through your loop. Additionally, you know that once you have tested for divisibility by 2, then subsequent trial divisions can skip all even numbers. If you continue down this road, you'll eventually implement a prime sieve using all the same tricks. One thing I would suggest is to use instead of at the bottom of the loop. It might or might not make a performance difference, but you'll avoid the CPU (and your readers) from having to think about the condition. It probably doesn't matter, but you could move the up above the label because whenever you , you already know that is zero. This sort of thing really needs to be clearly documented, of course. 

It's kind of long but not overly so. The first thing I would look for is elimination of redundancies. For example, in the last section there's no need to compare because you will end up with the same in both cases. You can cut out a whole lot of code that way. 

In Python 3.0 or later, you do not need to explicitly convert your numbers to . This is because the operator always does floating point division (the operator does "floor" division). For older versions of Python (2.2 or later), you can use: 

In , you should always first check to see whether you're doing a self-assignment and do an early exit: 

Declaring it as a local variable means you can remove the stuff about checking for allocation errors, and , and . It is generally considered good style to always surround blocks (such as an statement) by , even if it is a single statement. This is not required by the language, and you will find people holding both opinions, but there is no disadvantage to doing so, and you will save yourself from editing or reading mistakes later. I find the combined function-assignment-negate-test in the following unnecessarily hard to read: 

You have created a header file, but it's not clear why. Your code is not constructed as a library that others can call, but is a standalone program. A lot of the things you have put in the header file are specific to the implementation of your program. For just one example, is not relevant to any other code that might call your functions. Another example, and are internal functions that don't need to be in a header file. Your implementations of and macros do not properly parenthesise their arguments. Instead use: 

Code like the above is trying way too hard to write loops in one line. This harms readability because it's not clear what the loop body is and what the terminating condition is. Suggest writing loops like this on multiple lines. There are other instances of this such as the loop in . In your handling of , you can combine the two loops that measure and then convert the integer, into one. Or, call a function such as that does the job for you. You don't need the function at all. You can replace the call to it with to skip over the integer in the input. This also means you don't need , and can use directly instead of copying it to . does not appear to be used anywhere in your code. Also, it doesn't properly handle negative numbers. 

At first I wasn't sure whether this code would compile correctly (but obviously it does). The reason it does is due to two independent features of Java. The method has an overload that takes an parameter (and then calls to get a string representation of the object). Every type of object in Java derives from the base class. So, the literal string values you are passing are actually instances of the class, which is assignable to . But what about that at the end of the chain of conditionals? That's not a string, and an is not an either (primitive types in Java are not subclasses of ). However, Java has a feature called "boxing" where primitive values can be placed inside an object container, in this case the class. The compiler automatically boxes primitive values that are passed to parameters. If you were to explicitly construct and cast everything your code is roughly equivalent to: 

You can improve the performance of the inner divisibility test by using to do the division and modulo operations in one step. The following should work: 

The reason is that in a conditional expression , the types of and must match (or be subclasses of each other). In the above case, and are different incompatible types. And in particular, cannot be assigned to a . 

You would be able to see the problem if you were to call something like . What are and ? Those don't seem to be defined anywhere. Your function documentation refers to argument names like , , and , but your function prototypes do not have argument names so it's unclear what parameters you are referring to. The function would benefit from some constants defining the possible return values, or perhaps an . Never define functions in a header file. It doesn't make sense for another module to include your header file and try to reference those functions. Some comments about what is and why it is necessary would be helpful. It appears to disable large chunks of your program but the conditions under which it is enabled are unclear. There is no need for to be global. It's only used in one function. Also, there is no need for it to be dynamically allocated, since is a constant. It can be a local variable of : 

Note that I have used the explicit to check whether the pointer is null. I find this is much easier to read than , but is a matter of preference. An advantage of using a locally allocated is you can use in the above call to instead of explicitly saying . That way, you can minimise the number of things you need to change if you were to change the declaration of . Also, it makes it easy to see that matches the actual size of . I think you've got an off by one error in . Your algorithm seems to skip over the second-to-last byte in , not writing anything there. This will appear to work if that byte happens to contain a 0, but that's certainly not guaranteed. Your returns an empty string if is zero. It should return . The placement of the "return" parameter in is unusual, it's in the middle position. Generally, one would design the function so the "return" parameters are at the beginning, or the end, of the parameter list depending on your preference. The middle is a strange position for that. You have defined a number of functions as , but this is almost certainly not necessary for this program. And it's definitely not necessary for , which you take the address of anyway. What does mean for your program and why does this modify the help output? Under what conditions does the behaviour of your program change? Your function appears to return the same information in two different ways: both in the parameter and as a return value. Choose one. Your code always passes 0 to , so I would suggest using a return value only and eliminating the parameter. In your call to , you are unnecessarily using the format with a 0 parameter, perhaps in an attempt to ensure that the resulting string is nul-terminated. This is not necessary. always nul-terminates its output. You have chosen to make the exact number of bytes that your message is. Because always nul-terminates its output, this is insufficient and you have a buffer overflow. Also (if you fix the above comment about and therefore make it the correct length), a future modification to change the message may cause the result to be longer than what can be held in . You should do two things here: (1) use to ensure that you cannot overwrite the bounds of the buffer, and (2) declare to be much larger, say . 

which changes the old meaning of to the above. This makes the operation of more predictable as the result no longer depends on the type of the inputs. 

Your method calls incorrectly. Instead of calling with as the third parameter, use the actual size of the buffer: 

Because you are mixing different types in the conditional operator, you may find an unexpected behaviour here. For example, the following code does not compile: