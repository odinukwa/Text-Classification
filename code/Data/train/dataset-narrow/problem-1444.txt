This is an interesting question. Thanks for posting it! IMO, you don't actually have a class here. A would be a system object that has a name, maybe an id, a password, some relationships to material, perhaps one or more privilege levels. What you have here is an object that provides an interface to a database table - specifically, the user table. This is a Table Data Gateway in the parlance of Martin Fowler. Let's write some sample code: 

It's worth pointing out that right now your code is very fragile. You have a lot of array indexing, and any little mistake (like a plus sign instead of a minus sign, or an x instead of a y) is going to give you a potentially valid-seeming result that won't be quite right. You will need a strong set of test cases to catch this sort of thing. But I'd also recommend that you use variables or preprocessor macros to spell out things instead of expressing them symbolically. For example: 

This fails on many levels. First, comparing a boolean with in a conditional expression is stupid. It's a boolean! Just use it: 

It seems to me that filtering the list should be first, since that will shorten anything that comes later. You do a lot of code that appears to re-compute values that you should already have. For example, the constraints lists, the candidate records (dictionaries), the predicate lists computed into . Is there no way to store these into your DiGraph or someplace else cache-like, so that you don't recompute them? 

Separate your concerns One of the core values of OO programming is "separation of concerns." If your code is trying to manage user input and trying to do something else, then your concerns are not separated. All those try/catch statements for parsing integers, and loops for validating input are potential bugs. Push all that into the class, and write the code one time. If your doesn't have a method for doing "X", then write a method! Maybe you'll see that two slightly different things could be merged together. The idea here is that you should be able to simply call a method and trust the result! If you don't feel like you can trust the result, you get the kind of code you have now - a mishmash of concerns. Wrap that untrustable stuff in a method that does what you need, and then trust that method. The same is true for your other subclasses. When needs a character created, it should be able to make a call and trust the result. If there needs to be drama, or dialog, or uncertainty, try to get that taken care of before you call the factory method. (Hence, a method to talk to the user and then create the character.) If your code is only doing one thing at a time, you'll find it much easier to write. 

you have a loop nested inside another loop, specifically to handle the case where your month counter rolls over. Why don't you just reset your counter to the top, and handle the code in your main loop? I promise, it's possible. Of course, you might not be aware of this, but the C++ operator (modulo, or remainder-after-division) is perfect for use in this scenario. Next, this code doesn't do what you think it does: 

Since we got rid of the explicit check at the top, let's convert the to an and handle upper-case only: 

First, there is no empty string for zero. So I assume you mean "None will be replaced with an empty string". So why not store it in there now? Next, there is no function, so I assume you mean , which I have to find by manually searching. Except there is no special case there, save for the which does address the special case but doesn't handle the whole "why is ONES[0] not equal to ''" question in my mind. Of course, there is some handling for that, but it's in the function, and it's not a replacement, but rather it's handled in code flow using an statement. So 2 lines in to your program, and your comments are lies. This is why comments are generally frowned upon. You can't count on them to be true, or stay true - they don't get unit tested, and they don't get compiled. I would suggest that you simply store into ONES[0] and delete the comment below it. Another example: Consider this: 

This is you searching for a matching key in the list. I'll bet you have this same code in other places, like a "find" and maybe an "insert" (if keys are required to be unique). You should consider either defining a macro or a private (internal) function to do this for you. 

This is just wrong. The result of this function is not a calculated position. The result of this function is either 0 or -1, with a side effect of storing the input character in the board. Also, returning 0 on success is backwards. You should be returning 0 on failure, non-zero on success. I notice here that you have abandoned and in favor of . I still think a typedef is a better idea. Your computations are strange. You are trying to map to a row/column position, but your is going to be in the range (1..3). But you are subtracting 1 from when you index the . Wouldn't it be easier to just compute in the range (0..2) directly? You don't range-check the variable. The names and are not helpful. Once again, I'm left reading the code to understand what's happening. Why not use names like , , or and , , or for the two pieces of data? 

There's no reason to have a void return just before the closing curly brace of a function. (Except to use as a statement for a , which isn't needed.) 

Invert logic in checkWinner Your function contains various tests that look for a winner. Under each check, you try to print a message and return, resulting in 8 different copies of the printed message. I suggest you first look for a way to compress the test-expressions using list of tuples (or tuples of tuples) to store the various winning combinations as data, rather than code. Try the built-in function for this: 

This is "interesting" because it appears that you determine that the player has won the game by adding up the index of all the correctly guessed letters, 0 + 1 + 2 + 3 + 4 ... and matching the sum against a pre-computed value. This is so bizarre that I wonder if you copied your solution from a different language. Perhaps in C, or Pascal, or assembly, or just any language with bad string support? Also, of course, it won't work: you start with zero, and you use 0 as the index of the first character. This is a bug. 

Reports are aggregate objects. If there is going to be a comparison between two report attributes, allow the user to write out which attributes are being compared. That code makes no sense. And why would one attribute take precedence over all the others in a report? Why wouldn't or be the default attribute for comparison? In general, if you're not implementing a special high performance numeric library, you shouldn't overload the dundermethods for comparison. And you should never do that, because there's already a high performance numeric library! Instead, make sure that the attributes of the report object are returned in a sensibly typed fashion. You parsed the date information as a . Okay. Make sure that always contains/returns a valid , and let the user do this: