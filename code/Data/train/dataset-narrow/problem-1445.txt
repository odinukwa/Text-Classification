: There is no reason to use dynamic allocation, and are constant expressions!. Just use or better . That said you usually want to have dynamic sizes or your matrix may be larger than the stack limit. Then you should use . C-style arrays and dynamic allocation should always be limited as much as possible. Using proper class objects wrapping them is much safer. will take care of all memory management for you. If you are concerned that will layout rows non-continuously, then use instead and properly access the elements by . Also, in C++, you do not use and . Instead you use and . The difference is that not only allocates memory but also constructs the object in that memory. In most cases you would need to manually construct the object in the allocated space (although for double it is technically ok here). You should not declare a method, but rather everything freeing memory belongs in the destructor, which is automatically called as soon as the object itself goes out of scope or is destroyed: 

In : Is there a reason to set and to zero? A moved object only needs to be properly destructable, but the destructor does not use or . You can refer to the current instantiation of a template class without specifying the arguments, i.e. would be fine for the move constructor, too. To use you need to include . : You have a rvalue reference constructor here, but none for const references. That seems inconsistent. initially does the same as , you could simply call it: 

If you could specify exactly what your templates are supposed to detect / not detect that would be helpful. 

You should probably use more descriptive identifiers for and here. Instead of dynamic allocation you could also use for and . That would allow to simplify your code considerably. For example you could drop the custom copy/move constructors/assignment operators and the destructor and use the implicitly defined ones instead. You could also use the provided method of to get instead of saving it explicitly. If you didn't use for performance considerations, then I doubt that is a problem. Element access is through one indirection anyway and you do not have resize operations. Simply use in your constructor to allocate the proper size immediately. Only the required memory for might be a bit larger (additional integer for current size/reserved size and doubling of length ). Even if you still don't want to use , then you should consider writting an additional class (?) to handle the memory management or you could use , which would at least make your custom move constructor/assignment operator and the destructor redundant. In : The body is simply zero-initialization of the array. The same can be achieved with: 

That is fine, because all template arguments to are known at the time of parsing and is instantiated immediately, before the call to is parsed. At that point the compiler already knows that in that specific instantiation of is member function template rather than a non-template member and everything is ok. This however 

of course you need to implement the operators , and cast to first. This can also be easily improved by chunking to the maximal power of 10 holdable in an unsigned int or unsigned long. However this naive algortithm still has quadratic time complexity in the length of the number. I am not sure whether there is a linear time algorithm. Another quadratic, but possibly faster algorithm is Double dabble. In the GMP documentation there is a short explanation of a subquadratic algorithm. Maybe this can give you some directions. You may want to look at its source anyway as a reference of a mature BigInteger implementation. I am also quite confused by your function names. What is supposed to mean? I doubt the end of the function name is the correct place for whatever it is. Is it representing the container element types? If so that should belong into a template parameter. 

If is a non-accessible data member (e.g. private) your code fails to compile with gcc. However this seems to be gcc bug. (stackoverflow question) Still if your code is supposed to be compilable with gcc you should consider this. The templates give for non-accessible (e.g. private) members. That is usually good though, because someone using quering about a class should only see the public interfacce anyway. Still consider what the intended behavior of your templates should be. If is of reference type, then your will give , because taking an address to member of reference type is not allowed. is also if is a static data member with deleted or non-accessible , although this is a pathological case because I don't see a good reason to use in that way. You might want to take instead to avoid such a case. will also not detect member function templates, because the address of a function template cannot be taken. However that is probably expected behavior. The same issue also arises for overloaded member functions, though. The adress of overloaded function can also not be taken. This is probably not intended behavior. 

You are trying to do arithmetic with strings, that is bound to be expensive. Here is a naive algorithm to output a BigInteger in decimal: 

You forgot to in . There is no need for your limitation on integral types. You could just as well use the algorithm for any type with overloaded and or even only . You could follow the interface and make custom comparators available, too. However you would need to think about copy-constructibility and such. I think you cannot avoid limitation on copy-constructibility. I don't know why you write , is just fine in C++. It might even mask some errors, because will introduce as incomplete type, while will give an error if was not declared at that point. In C++11, which your code seems to be, you can easily offload memory management to in most cases. This makes the code shorter, clearer and safer, e.g. make and and leave the rest as . Then each node is owning its successor node and owns the first node. As soon as is destroyed, will be destoyed, which is owning the first node and it too will be destroyed, cascading down to the last node. There might be a problem with recursion for every node here if tail recursion optimization is not possible, though. In that case you can still use a custom destructor moving through nodes iteratively. You can spare a few lines of code, if you put and in the constructor of . Your code has undefined behavior if the input length is zero. You either need to check that this is not the case or change up your code a bit to work without handling the first node in a special way. It is unnecessary to repeat the node creation code so often. Just make a function which inserts a new node before the node pointed to by and updated to point to the new node. In fact I think this belongs into , rather than , so that will handle its own memory. I think holding the is unnecesary, as you can just get it from one indirection to . You are basically reimplementing a holding pairs of and . Maybe try using the standard library directly. I tried it out (I deleted the file accidentially though) and got your algorithm down in about 15 lines or so with and no performance impact on the test case and only about 10% additional time on the test case (but that might be improvable). If you used a tree () instead of a list to store your sorted values, then you can reduce the time to . I think this should also be possible while still keeping your behavior for smooth input. If you used a hash map () instead of a list to store your sorted values, then you can reduce the time to by counting all elements with the same key and ordering keys with afterwards. However the complexity for smooth data would not be better than that in this case, except if many consecutive values are identical. 

and should be . You need to to use . You are defaulting the copy constructor and assignment operator, but not the move constructor and move assigment operator. That's fine because the defaults are generated anyway, but it is inconsistent, I think. What is the point of ? should be . You don't want to have users create s. does not actually own the pointer it holds. It is copyable and will just copy the pointer it holds. It also does not create anything or delete anything in the constructor/destructor. Nontheless you provide a member. That seems very wrong to me. You don't know how the memory you point to was aquired, it could be with static storage or an array. In both cases calling would cause undefined behavior. The object creating the pointer with should also be responsible for ing it. Calling on two copies of also causes undefined behavior. The fact that the pointer is not owned seems to be a major flaw here anyway. Currently the user of your class needs to gurantee that the object pointed to keeps in scope until all 's holding it are destroyed and then it has to take care of proper deletion. Using it outside of is not allowed. So why not move the responsibility of managing the pointer to ? The same holds true for the lock. Currently the user needs to provide a suitable lock and keep it live until no references it anymore. Why not create the lock/mutex inside the constructor from pointer? Though I realize if you do it like this you need to manage references to the lock and you end up with fully reimplementing . Therefore I will just assume that this wrapper is explicitly only about locking and not managing ressource lifetime and that the user is required to run the destructors properly. is fine if copy elision is performed (not required in C++11, but in C++17), but is not either way. The object you create in is destroyed before the function returns. That means that is called before the caller expression using the pointer ends. currently returns a copy. It should return a reference. At least that is the usual way this operator is interpreted. In general the approach with and has some limitations. You may not call either twice in one expression or you have deadlock. But you are also not allowed to save the pointer returned by or a pointer/reference to the object referred because these are not guarded any more by the lock. I guess it would be much better to let the caller call a which returns a . Access to the holding pointer is then only allowed via and of this . As soon as goes out of scope its destructor releases the lock, similar to . This still allows the user to misuse a saved reference/pointer to the raw object, but at least more than one usage can me made in the same lock aquisition. An implementation via C++11 standard library would be similar to this (not tested):