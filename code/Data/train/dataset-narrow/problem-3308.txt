You need to use sudo (root privileges) to use hardware PWM from wiringPi. If you are using software PWM you do not need to use sudo. 

EDITED TO ADD Some background On recent Pis the audio jack output is provided by PWM channels 0 and 1. PWM channel 0 is fed to GPIO40 which is connected to the (stereo) right channel, and PWM channel 1 is fed to GPIO45 which is connected to the (stereo) left channel. These PWM channels may additionally be fed to user accessible GPIO. PWM channel 0 may be routed to GPIO12 and GPIO18. PWM channel 1 may be routed to GPIO13 and GPIO19. You route PWM to a GPIO by setting a particular GPIO mode as follows: 

piscope will not be seeing all the SPI traffic as the SPI bus is running at the same speed as the pigpio sample rate (default 200ksps). When you are testing drop the SPI sample rate to something like 50kbps to ensure all the GPIO level transitions are captured. E.g. use rather than . The code is sending two bytes (228, 0) to the LTC 1867. So the control byte is 0xE4. Is that correct. Could you show some sample of the returned data? 

That depends on the model of Pi you have. The Pi's PWM peripheral is used to generate the proprietary signals needed by the WS2812 (which are NOT PWM). The peripheral has two channels so if your Pi has gpios which can be connected to the two channels you could drive more than one strip. The gpios you need are 12, 13, 18, or 19. Gpios 12/18 are channel 0, 13/19 are channel 1. Actually the strips may be chainable (some are, you need to check) in which case you could control several strips from the same gpio. 

You probably need to circumvent the problem by knowing where you have placed the rudder. There are two "obvious" solutions. 

The LED is wired with inverse logic. Write 1 to GPIO 47 to switch it off. Write 0 to GPIO 47 to switch it on. 

You need root privileges to access /dev/mem. To allow access to the GPIO a new device was created called /dev/gpiomem. /dev/gpiomem can be accessed by members of the gpio group and grants access to the memory used by the GPIO. I give example code at $URL$ 

I think you are asking how to handle key presses in Python. If that is the case I suggest you use the curses module. Example 

You will not get an official answer. The USB specs says 5V +/- 0.25V. That covers everything connected to the Pi via USB. The Pi itself will run from a voltage in the range slightly larger than 3V3 to slightly less than 6V (connected to a 5V pin on the expansion header). The highest voltage I have risked is 5.8V. 

See this Raspberry Pi org post for details. Once you have done that, and rebooted, the system should see your dongle. You can then follow one of the generic wifi tutorials if it is not immediately usable. 

The Pi model B revisions 1 and 2 only exposes one gpio with hardware PWM support (gpio 18 on pin 12 of the expansion header). The Pi models A+ and B+ expose gpios 12, 13, 18, and 19 with hardware PWM support. There are only two PWM channels though so you still only have two hardware PWM settings to choose from rather than 4. However PWM suitable for driving motors may be generated by software on all gpios using either software or hardware timing of the pulses. So the answer to your question is yes, you can control two motors (with PWM to allow speed control) using the Pi and a L293D. 

The documentation is appalling. My best guess from looking at example Arduino code is that the output is an open collector digital signal. So connect a Pi ground to sensor ground, a Pi 5V pin to sensor power and any gpio to the yellow wire. Enable the internal pull-up on the chosen gpio to 3V3. Being an open collector output means the output line is never driven high, it will normally float to the pull-up voltage of 3V3 and read 1. When an obstacle is detected the line will be driven low and will then read 0. 

Using DMA bit banging it is possible to get accurately timed gap-less samples from the MCP3202. The same technique should work for the MCP3201 with the obvious change to the SPI command to request the data. The MCP3202 (12-bit ADC 2 channels) command SPI tranfer is 

There are a number of open issues on PWM with RPi.GPIO. See $URL$ I haven't looked too carefully at your code but you seem to make repeated start and stops of PWM. That seems to crash. My initial thought is that you should redesign your code to only use one start (at initialisation) and one stop (at termination). Control the rest with the dutycycle method. 

In bare metal programming you are in control of the hardware. You decide how you want memory to work and you decide if you want to program the memory management unit(s) to use virtual addresses. Terms like kernel space and user space are meaningless for bare metal programming. The mmap function is only relevant if your program is running in a Linux (or similar) environment. 

As far as I am aware collabora is still using wheezy based software, it has not been upgraded to jessie. If you want to use that repository change its entry back to wheezy from jessie. 

You don't specify the size of the region through which the marbles pass. If a Hall effect sensor can be positioned so that a marble always passes within a millimeter or so then it would seem a natural solution. No need for an ADC. The ones I have (OH3144E) default to Vcc and pull to ground when a magnet is close. 

It's a servo. It goes to the commanded angle. There is need to resynchronise (unless you strip the gears). You command an angle by sending electrical pulses 50 times per second. If the pulse is 1.5 ms long it goes to the centre, if the pulse is shorter it goes to an angle more counterclockwise, if the pulse is longer it goes to an angle more clockwise. The amount of turn in degrees from most counterclockwise to most clockwise and range of allowable pulse widths varies from servo to servo. You will need to calibrate your software against the servo. 

The name given to the serial port depends principally on how but also on what you have connected. If you connect a 3.3V safe TTL serial link to the Pi's GPIO (pins 8/10) then the serial port is called /dev/ttyAMA0 or (rarely) /dev/ttyS0. On Raspbian you should preferentially use the link /dev/serial0. If you connect via a USB dongle plugged in to the Pi the serial port will normally be named /dev/ttyUSB0 for the first, /dev/ttyUSB1 for the second etc. An exception is if the other end of the dongle is connected to an Arduino in which case the port is likely to be named /dev/ttyACM0. 

There are at least two ways to test your GPIO. Both programs should be run with nothing connected to the expansion header. 

The values read/written to that peripheral address are under the control of the GPIO peripheral firmware. The firmware knows the difference between a read and a write and will perform the appropriate actions. 

The Pi is 3V3 TTL (i.e. the signals are low=0V and high=3V3). RS232 is +/- 12V (i.e. the signals are low=-12V and high=12V). They do not mix. Feeding that signal into a Pi GPIO will destroy both the GPIO and the Pi. You need to use an appropriate adapter. It may be simpler if you use USB at the Pi end. At least you know the Pi will not be damaged by what's at the other end. 

Replace 4 with the gpio you have connected to the control wire of your ESC. Make sure to connect the ESC power supply ground and the Pi ground. If that doesn't work you'll need to trawl the web for ESC initialisation sequences. 

If you use the standard Linux driver you are limited to about 20ksps on Pi's other than the Pi3B which can manage about 80ksps. If you write your own driver or use a library which uses its own driver you can do considerably better. See $URL$ for my pigpio figures and some test software. If you want the highest sample rates you need to be using C. I'd suggest a limit of about 16Mbps for the actual SPI transfer bit rate. For this figure you may be limited by what the chip you want to talk to can handle. 

I don't think so. As far as I am aware it's the GPU which does all the camera "heavy lifting" and communicates with the camera via the CSI interface. I'm not sure that the ARM core(s) have any part to play in the image processing so I expect the 90 fps figure would be unchanged. Of course post-processing may well be improved. The new cores have NEON which can provide a huge increase in performance for some graphical tasks. 

The Arduino outputs each result with a line terminator. I suggest you use a blocking read line at the Pi. 

To debug the radio signal being received at the Pi you could try my piscope utility. It will work locally on a Pi2/Pi3 but if possible it's best to run the display on a more powerful Linux PC. It will display the signals arriving at a Pi GPIO. A quicker test would be to compile and run one of my fob programs. I suggest you try _433D as that is the most recent. That will attempt to decode a fob which uses Manchester Encoded signals which I believe to be the commonest protocol in use. 

The script is trying to manipulate /dev/i2c-0 (an I2C bus) as if it is a serial link. An I2C bus is not a serial link. To talk to as I2C bus use the Python SMBus module (or my pigpio's inbuilt I2C support). 

eLinux host a list of RPi compatible devices. There are separate lists for RPi USB Keyboards and RPi USB Mouse devices. 

I'm not surprised you couldn't find any information. The BCM2836 is a SoC not a CPU. As far as you are concerned the BCM2836 is identical to the BCM2835 except for the different ARM CPU. The main user CPU used on the Pi 2 is an ARM Cortex A7 with four cores. If you search for BCM2835 and the ARM CPU you'll find all the information you could need. 

Recent Pis (the ones with the 40 pin expansion header) and the compute module have two accessible SPI peripherals. The main SPI has two chip selects. The auxiliary SPI has thee chip selects. $URL$ shows the pin outs. Main SPI MOSI/MISO/SCLK/CE?, auxiliary SPI mosi/miso/sclk, ce?. The recent kernel driver (spi_bcm2835) can handle both devices and can also use arbitrary GPIO for chip selects. For details see the SPI overlays mentioned in /boot/overlays/README. Personally I would leave the TFT screen on the main SPI device and connect your synthesiser to the auxiliary SPI device. 

I don't think you can do what you want during boot (config.txt doesn't seem to have a way of configuring by EDID). Perhaps you could use the tvservice utility (tvservice --help). Interrogate the display (tvservice --name) and then set the correct mode accordingly (tvservice --explicit ...). 

The error is telling you the device is not connected to the I2C bus. I suggest you re-check your wiring and retry the script once shows the device on the bus. 

Boot your Pi. Plug your scanner into a Pi USB port. On the Pi go to a text window. Make sure the text window has keyboard focus. Scan an item. If text appears in the text window it is compatible with the Pi. 

I have experimented and have a sort of solution to sending 9-bit data at 1.25 Mbps. It involves modifications to my pigpio library. I've added a gpioWaveAddSerialX() function which extends the gpioWaveAddSerial() function to allow for setting the number of data bits. This function constructs a waveform representing the serial data to be transmitted. This also required an update to the internal waveBitDelay() function to allow for a variable number of data bits. The other needed change was to change the base clock from 1 MHz to 1.25 MHz by changing clkDivI = 50 * micros to clkDivI = 40 * micros in the internal initClock() function. The manifest constant PI_WAVE_MAX_BAUD in pigpio.h was changed to 1000000. 

The Pi's UART has a fault (in the firmware). Whenever the port is opened there is a 30 Âµs low glitch on TXD. See $URL$ and search for glitch. You will need to find a workaround as the fault will not be fixed.