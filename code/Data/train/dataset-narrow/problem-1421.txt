Now your GenQueue is a Queue (java.util.Queue) and it is also a List, and it supports all the features that are already embedded in those implementations. 

The above will do a shifting insertion sort. Just a suggestion. Duplicates. This is where there are the most significant problems. I would consider your algorithm to be a real overkill one. You can do it all with no extra data, no array, etc. A simple loop through the data should be fine. 

There is a bug in your code for those times when the two input values are not prime. Consider an instance when the input values are 4 and 6. In this case, your code will output F for multiples of 4, and B for multiples of 6, and FB for multiples of 24.... great... but, is it? No, 12 is a multiple of both, but will only print "F ". If you want to use the optimized cascading-if-else version of FizzBuzz, then you need to ensure the inputs are both prime, or have no common factors. It would often still be faster to compute the common factors and then after that do the system you have. 

Random adjustments Your code converts the positions to Â°'" in order to add an adjustment of minutes and seconds. There is no need to do that. Just have the adjustment in the format of a and apply it directly. For example, for the seconds, have: 

This will mean you will have to adjust the parsing part slightly so that it does not expect the "(" and ")" tokens.... The rest of the parsing does look fine (to my untrained eye). 

Your algorithm to calculate the final image dimensions could be improved by simplifying the logical process that you use to determine the final size. Fundamentally, there are two dimensions you are interested in, the height, and width of the final image. There are two possible outcomes for the scaling, one where the scaling produces the target height, and the other where it produces the target width. The scaling that is used is the one which produces the smallest image. The size of the final image is determined by the scaling factor, and there are two factors: 

Convert the input number to binary representation in a String, and if just one bit is set, it's a power of 2. That removes all the extra memory needed for the results, and it only needs to create a String that is a size which is logarithmic to the input value.... which is quite small, even for very large input values. There's probably faster ways to implement that algorithm, but the core concept is good: just count the set bits, and if there's 1, it's a power of 2. 

One other thing, I would expect that the sort method does an in-place sort. This is only because I am more familiar with that from the Java API. Retuning a new instance of sorted data is not wrong, just odd. Note, that for small (and empty) inputs, you return the same instance as the one you sort. This difference in behaviour is problematic. I would return a new instance on the small sorts as well as the large ones, or alternatively, just copy the results back in to the source at the end, and not return anything (in-place sort). Runtime performance. The performance problem you have here is significant. Using an ArrayList in the recursion you have, implies that you will be creating a lot of ArrayList instances. The other performance issue is that you have is in your algorithm. Typically, the merge sort is done in to a single equal-sized 'buffer' as the input. You merge the small blocks from the input to the buffer, then you swap them, and merge the larger blocks back in to the original, and keep swapping the buffers, until you have a result from the top merge. Generalization of input data type. This is the open question. If you bring your input data down to the lowest common denominator of the class, you could create a method: 

A in the middle of your game loop is a problem. No-one wants to see that. A really simple solution to this problem is do things a little differently.... 

That line needs to scan and group the entire XML doc, but my instinct is that a 2-limited split (see note on LIMIT) would be more efficient: 

Now, for long strings, the above will be more efficient than your solution. It goes through each character in the string just once, but it has to create a list of what's been seen, or not. If it is a new character, it has to count it as seen. Your mileage may vary. 

From the way you describe the problem, it is clear that there only needs to be one method. That method is supposed to: "... prompts the customer for the car type. ... Your method will return a valid car type". What you have presented here, is the guts of some code which prompts the user for a character value, and then another method which converts the to a type. From what I can tell (and filling in some blanks) your code looks functional, but I am not certain it satisfies the requirements (for just one method). I would start with the 'specification' for the method, and use that as a template for the code. I will make the assumption (as you have) that the method should return the 'full' name of the car type (i.e. return "Economy" instead of 'E'). The good things in your code are the use of the block. You have a good loop there, with good conditional exit criteria. You have not shown us what is so I will assume it is a on . If we wrap the code you have there with a method that makes sense, it would be something like: 

There are more efficient ways to reverse the digits, but a string reverse is not completely horrible. I think your most immediate problem is probably the array. There is no need to have that at all. Remove it, and keep a simple and accumulate to it: 

I need to create variable-length strings of dots/periods/full-stops to add to some text content, in a way that is similar to a formatted table-of-contents: 

set up a default value (or null if it is a complicated thing to do). do the hard work which may be missing dependencies or may fail if the hard work completes successfully, return that result. 

I would likely recommend you use a simpler DataOutputStream on a ByteArrayOutputStream, and then just get the Output Stream's at the end. That solution will be thread-safe, reentrant, and probably pretty efficient. The resulting array will be the exact right size as well. No need for statics. If performance really was a problem, then I woud remove the need for the byte array completely, and work directly off whatever stream/channel you have between the C and Java code. Basically, there;s a level missing in your presented code. There's a way to not have the buffer at all. Look for that solution.