Sixty Frames Per Second! If a game contains any form of action, it would benefit greatly from running at 60fps*, vsynced, without tearing. This can be the difference between an OK game and an awesome game. I expect that several uninformed newbies will now respond 'but the human eye can only see 25-ish'. That's nonsense. (Someone needs to write a nice little test program to demonstrate the difference, maybe split-screen 30 and 60fps) As developers we've got very sloppy about performance recently, in the push to add 'more stuff' and 'bigger stuff' to games. It's not uncommon for games to drop to 20fps or less, which is really quite poor. Back in the early-mid 90's, maybe even before, 60 frames per seconds was the very definition of 'Arcade Quality'. All those lovely smooth 16bit platformers and shooters. And remember games like Daytona and Ridge Racer? Early, groundbreaking 3D titles - that made the (correct) decision to run at 60fps, rather than add more visual detail. These days everyone's competing on screenshot quality, and making games 'bigger'. Gameplay has really suffered, particularly in certain genres, such as racing games, where 30fps or less feels terrible to play once you've had a taste of 60fps (*Ok, there's nothing magic about 60 as a number, but to look good, a game should by synchronised with the refresh of the screen, at a constant framerate of 50 or more. And use of lower framerates for cutscenes, for a 'cinematic' look is perfectly acceptable) 

The clever bit - When removing a 'dead' particle - swap it with the last active particle, and decrement NumActiveParticles: 

I'm designing a CCG/TCG game (with the Kotlin language), and I am looking for advice regarding the text of the cards. First of all, here is an example of one card, defined in XML: 

I've decided to use the ELO rating system for my chess-like strategy game. I've implemented the algorithm but I don't really understand it completely (I'm not a maths person)... I've decided to give starting rank of 1000 for new players, and I use 32 as max increase. Now for my actual question: Let's say that player A plays hundreds of games against player B, and player A is much better player (or player A has created a dummy account so that he cheats!). Do I need to take this in account in any way "manually" or does ELO handle this "automatically"? I mean, ultimately the difference between the two players will be so great that the "cheater" gets only +1 to his rank? So he would possibly have to play LOTS of games to cheat/climb up the ladder this way? Am I correct? I REALLY wouldn't want to disallow the ladder system completely for friend vs friend (invited matches). And I shouldn't need to: even www.chess.com handles this in some way. 

According to a post I found, the of a in LibGDX is not only a hint, but does nothing on desktop, and I can confirm this. I really need priorities for sounds in my desktop game. The first thing that comes to mind is to roll some kind of simple "sound system" with, say, a , but I'm not quite sure of how I would implement it exactly, and I'd like to re-use code as much as possible... has anyone here perhaps rolled one that I could use? 

I strongly suspect that there's simply no market for it. (Except for a small number of geeks/developers that would be attracted to any new and open hardware) There's plenty of devices out there that can play games very well, many of which are open, or 'open enough' for indies. We can already develop for a wide variety of computers, phones, and tablets. Whilst consoles are much more limited, we do already have Xbox Indie Games (XNA), and there's active homebrew scenes for some of the older consoles such as the Dreamcast (and I wouldn't be surprised if we see a thriving PS3 homebrew scene soon?) I suspect that in the future, we'll see a mainstream 'box under the TV', maybe a future iteration of something like Apple TV, that's not a traditional console, but is good at playing casual/less demanding games, and has an app store which is reasonably open to indie devlopers. 

As a former WoW player, my experience was that the login server was always the weakest link in the chain. The world servers were usually impressively stable, even handling exceptional load (e.g. new expansion pack releases) quite well. But the login server(s) just never seemed to cope so well, and would frequently be down whilst the world servers were fine. (meaning that if you lose connection in a raid/dungeon, you can't get back in, but the other players are waiting for you!) And now that the WoW login system is merged into Battle.Net, Starcraft 2 can become unavailable when WoW is under heavy load (as happened for a couple of hours when Cataclysm launched) So if you're building a game that will have very large numbers of users, scalability and performance of the login system is very important, too. 

It's probably best to have some simple AI routines and game-critical calculations on the server side, while handling the complex non-game-critical operations on the client side. For example, the server knows where a hostile NPC is and where the player characters are. When the player character gets within range of the NPC a server-side calculation can be done to see if the NPC should attack the player, and a simple pathfinding routing can be done to determine how long it will take the NPC to reach the player. Once the NPC has been transitioned to the attack state the client can deal with animation and fine-grained path finding. When the NPC is close enough to the client to attack the server can perform calculations to see if the attack hit, what the damage was, etc... You'll want to make sure that any calculations that truly effect the outcome of the game are handled by the server and passed to the client, while the non-critical calculations are handled by the client. In the simplest case you'll be keeping the client in sync with where it expects the server to be, the server will verify, then the client will calculate again. 

Working with the Wii I often find it necessary to recognize simple gestures, so far I've been able to mainly look at magnitude of acceleration in order to recognize the gestures called out for in our game design documents, but I'd like to create a more robust system that allows "recording" of example gestures and recognition of complex gestures. What strategies have you used in the past? Why did they work? Why didn't they work? What would you do differently? 

Coding positions seem to be becoming less exciting/creative and less respected with each passing year and increase in team size :( For each 'exciting' dev position (e.g cutting-edge graphics, or gameplay coding on a big title), there's about 10 coders needed to to fairly dull work (front end, TRC/TCR compliance, tools, porting to the lesser platforms) You won't make big money coding games unless you really get lucky (right place at the right time). The only real money is in founding a studio and selling up to a megapublisher. Or creating an unexpected big hit with a very small team. As a career, games programming seems somewhat dead-end unless you have what it takes to start a studio of your own, or are willing to give up coding and aim for a management role... 

Make a really good game. Get it on Steam. Market it effectively (generate enough buzz on gaming websites/forums) But the most important step is making a really good game. Kind of surprising to see suggestions of 'go for mobile development', given how oversaturated with $0.99 titles the iPhone app store is these days? - might have been a great idea 2 years or so ago - but isn't that gold rush well and truly over? - or have the new Apple devices re-ignited it? 

Another thing to consider is the texture format. Is it a raw 32bpp texture? If so, consider using a compressed DXT1 texture, which is 4 bits/pixel (taking 1/8th of the space), or DXT5 if you need the alpha channel, at 8 bits/pixel. Reducing the size of the texture data should result in reduced texture memory bandwidth requirements, and improved texture cache performance. Also, check that you've not setting maximum quality anisotropic filtering - that can add a fair bit of cost.