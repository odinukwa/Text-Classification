True full stack from the base install of an OS with an IP address up to the next StackExchange? Multiple classes.. HTML+CSS is always first, then Linux Admin, Back End Coding, and Pure SQL. Only order requirement with the last 3 is that Pure SQL has to be done before Back End Coding, but some of the Linux admin stuff could help with solving issues OR using neat new and exciting stuff when it comes to the back end.... 

Ultimately, it comes down to what you prioritize in your course and how you want your students to prove that they have learned the materials. What is critical though is if you use a course management/grade management system is that the syllabus AND the calculations in the LMS/CMS/GMS are in agreement with each other so that if a student does look at their grades it is calculated properly and accurately. My full time job is administering our college's online course delivery system (Canvas) and training instructors on how to use it. I also teach a few classes as an adjunct, and while they are face to face I use the LMS heavily (gotta eat your own dog food). In courses where showing applied knowledge and skill and ability is important - like my "Services with Linux" class - I use percentage based grading. This allows me to give 100 point exams, but since they are almost entirely based on readings and background information regarding the services, I can make them worth a relatively minimal part of the final grade (10%). I think it is more important for me to help produce a sysadmin who can actually configure a DNS server, a DCHP server, a Samba server, set up a LAMP server, or configure an email server and diagnose issues by reading headers, etc. In this course, I use percentage based grading - 10% exams, 15% discussions (relating to what and how to backup, security, pros and cons of various config options, etc), 25% projects (full documentation of local services setup, full documentation of internet services setup), and the other 50% in labs (all involving getting the various services configured, developing backup methods, etc). For an "Intro to SQL" course I teach, I use a points based system. Mostly because I'm just an adjunct teaching with the course content provided by a lead instructor, but also because it makes sense. Doing the readings, understanding the different data types, understanding the differences between join types, etc. are equally important as being able to write the SQL syntax. Coincidentally there are 8 labs/projects with 10 questions/sql statements to generate at 5pts each, and there are 4 exams (each covering 2 labs/projects) worth 100 points each, so 400 and 400 respectively, and so it works out nicely that way. Of course, the same can be done with a percentage based system just as easily. As far as the students go, I've seen a surprising number of them who never even check their grades in the LMS. And the rest of them just don't seem to be bothered between the differences of points vs. percentages. I've even had students in both classes in the same term and they either didn't notice the difference or seem to care. One last thing - do not go crazy with conditional logic in your grade calculation - although this seems to mostly come from our Social and Behavioral Sciences department. "Well, if students score above 80 on exam 1 and submit paper 3 at least 2 days before the deadline then they can do either this bonus assignment or take an extra 10 points on exam 2 but only if they take the exam on a Thursday or on Monday before 10am." 

This makes it hopefully obvious why such a comparison chart does not exist: because those two are entirely different concepts. 

FP and OOP are both tools in the box, none of them is better or worse. The same way you would not ask whether to use a hammer or a screwdriver to put in a nail, you should not ask whether to use FP or OOP. The question should be: what is the best way to solve your problem at hand? OOP excels when you need to describe abstract objects with code (hence the name). Describing the abilities and features of a car is something FP is not made for, so choosing FP for this situation would be painfully complicated. Vice versa FP excels when algorithms can be written as mathematical functions in the mindset of (more complex functions are also very much possible). Using OOP to describe the result of is possible but pointlessly complicated. In modern programming FP is usually used when volumes of data need to be transformed. If you need to map from Z to Y by using the transformation function f, then you can very simply write that in code using FP, i.E. in Java like this: 

Everything you learn is temporarily correct. This is the mindset you need when learning new things (in the IT). Even if you by chance happen to learn the perfectly accepted "right" way to write Python in your example, you still will look at that code five years later and realize that you have improved so much over that. In the IT business everything is constantly in flux. May it be that new languages with new ideas appear (e.g. functional programming), or that best practices turn out to be not that good after all, or something is over-hyped but essentially bad and simply gets out of fashion. In all cases you advance and improve yourself, unlearn old habits and learn new ones. So when you learn a new language, don't accept what you learn as the one and only truth, accept it as the current best known way to do things. Verify what you have learned and ask yourself: "Is there a better way?" If you find one, use that, despite what the books tell you, because those might be outdated as well. If you don't, then consider that you just haven't found a better way, yet, not that there is none. And if you realize at some point that everything you did was completely wrong, don't worry, be happy that you improved. With that mindset knowledge become building blocks that can be interchanged at any time. Learned a new technique? Replace the old one and adjust the surroundings. Suddenly there is no longer a "wrong" or "right" way to do it, just the current and the better way. And if you no longer quantify as "true" and "false" your brain will memorize things differently, and it will become much easier to upgrade old knowledge. A part of the reason is that the brain tends to harden something learned more, if certain emotions are associated with it. If you are excessively happy that you finally learned the one and true way to do things, your brain will set that in stone for you forever. If the same thing is just some information equally irrelevant as everything else, your brain will not put too much effort into storing that. This also means that you will forget things easier, but especially in IT most knowledge from 5 years ago is irrelevant anyways. And those things that stay true and correct will be memorized more clearly simply because you repeat them often enough.