I wanted students to have experience with the ordering of function calls in C. There are technically two correct ways to approach this, but because I specify the requirement to use each block, there's only solution here: 

My AP Computer Science Principles course teaches three languages: Scratch, C, and Python. One of the 7 Big Ideas for the course is abstraction. At the end of the course, I emphasize how Scratch exists at the highest level of abstraction relative to the other two as a block-based language and how the Python interpreter we use is written in C. Connecting this to lower levels of a computer, we form a chain that looks like this (from high to low): 

Share their own struggles. Period. The instructor can start dispelling the myth by sharing his/her own story (replete with self-doubt, struggle, and frustration most likely) about studying computer science. In Harvard's CS50 course, the professor shares his experience of not starting as a CS major and of essentially taking CS50 himself pass/fail. That's in the first lecture and communicates an important message about his journey not being one of simply innate talent. In another MOOC I've referenced before (Programming Languages from UW), the professor points out that he didn't write a line of code before college. As a student in each course through edX and Coursera, respectively, these small windows into the journeys of the professors has boosted my own confidence that one does not to be fluent in assembly at age 10 (exaggeration) to be a skilled programmer/computer scientist. I share with students my own long and winding road that led me to CS. I share with them what I continue to study in my free time. I display old, poorly-written code. I recall one instance from teaching last year when I was trying to communicate to students how important it is to read program specifications and language documentation extremely carefully. From a homework assignment for Programming Languages, Part A, I kept figuratively banging my head against the desk because I was sure my logic and code were right, but I wasn't passing the checker. The problem: I was misunderstanding how a library function was working. Once I re-read the documentation and realized my error, the fix was trivial. Moments like this happen to everyone at every level of ability. Everyone struggles with something at some point. Students need to see that the person teaching them is fallible, and that his/her knowledge has been gained through a lot of "blood, sweat, and tears," not because he/she wrote C code at age 5 (exaggeration again!) and never had a problem learning anything thereafter. I also find some of the stories from freeCodeCamp inspiring. Their forum and Medium blog are filled with examples of individuals making career changes, working hard for an extended period of time, and achieving some level of "success." The bottom line: find stories to share that show students there are more people feeling what they feel than they might first imagine. Prove to them that computer science rewards hard work, discipline, and focus. In my mind, that starts with the person in the front of the room sharing his/her journey. 

The full-length sample exam provided through AP Course Audit (a secure document) The 22 sample questions from the course description The prep book Fast Track to a 5 The online paid resource Albert.io 

I am toying with expanding my introduction on arrays next year to include this particular use of pointers. I recognize that it would involve taking maybe a single lesson on arrays and expanding to something closer to a week long to tie together all these ideas. However, is it worth putting aside the syntactic sugar in order to understand more accurately the indexing of arrays? On the other hand, does the introduction of pointers and memory complicate the process so much so that confusion about arrays will increase rather than decrease? (I'm thinking of this is a "lesson idea feedback" discussion.) 

The "real-life" examples are pretty clearly delineated here already, but since you asked for examples in programming as well, I'll add one to the list. Stacks can be used to build calculators. There's a great assignment in CS50 AP called Calc 2.0. Students build a command-line calculator in C using a stack to store the numbers passed in by the user. Additionally, it's an opportunity to teach students about prefix notion as opposed to their normal use of infix notation. The problem specification explains why this approach is worth pursuing: 

One technique I use for sorting algorithms follows after CS50's demonstrations of the differences among bubble sort, selection sort, and insertion sort. I have 8 students line up in the following order: 

Check out the Python books written by Al Sweigart. His homepage Invent with Python includes some great, free resources that are geared to the age range of your students. In particular he focuses on creating games which is, in my experience, an effective hook. Two books to use to inform your teaching are the following (in order): 

A few ideas... Scaffold your problem sets. CS50 -- and by extension CS50 AP -- sections students according to "less comfortable" and "more comfortable" tracks. (See what they do here for pset2.) Giving students options, especially in terms of difficulty level, is a key. This may involve creating problems with additional, optional components, which will be additional work on your part, but it also gives opportunities for other students to extend their learning. I also love what they include in their syllabus: 

In the end, students need to build their pattern recognition, and that comes with a lot of time and a lot of focused practice. There is also an inevitable connection among debugging skill, programming environment, and language. My students were better at C than Python when it came to fixing their programs. That's due to several factors: C being less forgiving, Python feeling simpler leading to carelessness, and the IDE trying to be helpful with errors as students wrote Python. In C, it took the compilation step to find an error whereas Python would identify warnings immediately, a "feature" that muddied the debugging process. 

Debugging is more a craft, an art, than a science. That's where the pedagogical challenge lies. That said, here are a handful of tools/techniques I used to varying success: 

I think there's one step between knowledge of HTML/CSS and writing userscripts: knowledge of Developer Tools in Chrome, especially the "Elements" tab. One demonstration students loved seeing was when I "changed" the school website. I simply right-clicked, selected "Inspect", and modified the text. I had to explain to students that I didn't really change the page but that I modified it locally and could "restore" it by refreshing, but it was a lasting demonstration, something they continued to bring up throughout the semester. (This demo also relates to what I said here about the value of CodePen because you can see your work live.) Even if there are thousands of LoC, you can get right to where your element is and see the entire path down the "tree" to this element. One fun demonstration is to show students how to "delete" a pop-up from a site or remove an ad or some other obstruction/intrusion by inspecting the page to "search and destroy" what you want to get rid of. Consider Bloom's taxonomy here. You have an opportunity to move up the ladder as follows: . This progression is important to keep in mind so as to adequately prepare students for creating something meaningful of their own, and I think the study of how popular sites are structured will aid in this process. Hacking away for fun at a page may give them an idea for what would be cool to script themselves. The teaching benefit is such that you can unleash students' seemingly unlimited creativity as they write helpful scripts for their own personal browsing experience. Yet, as you note, it does not come without challenges and must be approached methodically. 

Make them suffer through debugging spaghetti code. Come up with a few examples that make liberal use of the language features you don't want them to use. 100-150 lines of code with 1 or 2 small bugs because of these statements will be a nightmare for them to sort through. Make it a sort of game, too. Have students compete in groups to see who can debug the programs the quickest, and give them, say, three different ones to solve in a particular allotted amount of time. At the end of the lesson, show programs that accomplish the same goal in a more readable, debuggable format. This is the via negativa approach to teaching: show students how bad a choice is, so they are inspired to do , i.e. the good practice. It will really hit him if they have to struggle through what happens when best practices aren't followed. 

With array notation, we are explicit with 0-indexing, but the logic of it isn't apparent. Yet, with pointer arithmetic, it's more clear (I think...) why we use 0: the pointer stores the base address, so dereferencing the pointer brings us to that address which is where the array logically begins. Comfort with this leads to the topic of memory management on the heap with something like this: 

With this example the clarity of the code is made much stronger by virtue of the case statements for each operation. From a readability perspective, it makes it clear how the operations are separated out by showing so visually. 

I've been doing quite a bit of searching on my own the past week or so on this and just discovered a new great resource to share. It came from this GitHub blog post about Art Simon's work at Lowell High School. There are links to each of his course's curricula for AP CS Principles and AP CS A, both of which use Processing. (Brief tangent: including Processing in AP CS A seems like a brilliant idea. You get the benefit of Java syntax and OOP with the payoff of Processing's visuals.) Here are two great introductory-level assignments I found there: 

It's elementary, but with this basic structure it is easy to visualize nesting, siblings, and paths of traversal. Also, from a stylistic perspective vis-a-vis indentation, each child equals one further tab in, so this structure also makes it possible to address code style. As a result I wouldn't say one needs to know XML before HTML. Instead, one should know the structure common to both to be effective with either. 

Do you reward a student who knows everything from the start and doesn't show any signs of progress with a student who knows nothing at the start but makes dramatic progress? That's a huge philosophical question to consider in terms of how you assess student learning. Give him additional, empowering responsibilities. Find a way for him to have a special role in the class. Use this advanced knowledge as a strength for you to use. When giving time to work in class, have him be a source of answers to his peers' questions. Better yet, have him lead a walkthrough where he has to teach a mini-lesson for how to approach a particular assignment. If he's going to be bored during a lecture, encourage him to write a sample program or two for use in direct instruction. Make him complete the same work in a different language. Have him complete the same assignment, but in a language different from the one assigned. This will require him to learn different programming idioms, libraries, and paradigms. A solution in an imperative language would be much different from one in a functional language. No one is an expert at every language, so there's always a new challenge to be had with a different language. On a much smaller level, you could require challenges on a site like HackerRank either in the language of the class or a new one entirely. Edit: I also have two Java-specific suggestions... 

I recently completed the MITx MOOC 6.00.2x, which is modeled after an introductory programming class in Python at MIT. The course addressed the following topics from statistics that integrate nicely with computer science (especially data science and machine learning): 

One of the most influential texts in computer science is Structure and Interpretation of Computer Programs. Before changing to a Python-based approach, MIT used this book for their introductory programming course. It is freely available with a number of resources thanks to the textbook site. When perusing the list of schools using SICP, I see that all of them are universities/colleges, which leads me to my question. Is SICP appropriate for an advanced high school computer science course? In particular, I'm thinking of students who have taken two years of AP Computer Science, so they would have completed a year of CS50 AP and a year of Java. I see that UC Berkeley has a self-paced CS class that works through it. I understand that some things are at the university level for a reason, but I am trying to bridge the gap between post-AP CS classes in high school and intro CS classes in college.