Your code looks wide open to SQL injection. It is unclear what data is user supplied, but for security reasons I would treat all variable data as user supplied (it doesn't hurt). Use prepared statements with mysqli or PDO everywhere, always. OOP Currently, it seems a bit unclear what your class should actually do. Should it be a model that temporarily stores data, as the getter imply? Or should it perform database interactions? You could easily separate these concerns with a different structure: 

Performance It works fine for me in Opera and Chrome, but it is buggy in Firefox. Profiling reveals that is responsible (big surprise :) ), and there is not much to optimize without changing the whole concept. Two minor optimizations might be: 

Without going into implementation details, I would suggest looking into the following performance optimisations. 

I think this make the different logic parts separate and you will get cleaner code, where it's going to be easy to add a new transformer, while still paying some attention to performance. 

I would normally suggest consistent usage. In the example you provide, you use both constructor parameters as well as property initialisation. Depending on you options to change etc. the SubjectDto I would add another construction parameter to it and pass in a hasBeenAdded variable. When talking about improving the LINQ query, I think readability and maintainability has highest priority. Often performance optimisations degrade readability and enforces you to write some additional comments. 

So now you have divided you elements into specific entities like Quotation, Customer and Events. Adding more details to a Customer or adding a new Event type, don't require change to the Quotation class, but only changes to the specific entity. On the side, you might also find it beneficial to look into a simple visitor pattern for the events and provide algorithms to etc. calculate total price, date collisions, number of participants etc. etc. Enjoy. 

As as first step toward performance and code structuration, I suggest to compute the ability/effect in returnList once, and reuse it after. Typically, you may have something like this : 

Just one question : when do you release the key ? Suppose twice the same key is called almost simultaneously, so that one of the two threads involved will go through the 

is enough to solve this one. After this, reading again this code, I found a dictionary, a lock and a monitor. I'm quite sure that a ConcurrentDictionary could make the same job, with a cleaner code if not faster. Lastly, 100 threads with some of them blocked could become a production nightmare if too much keys have the same value. Hope this help ! 

Depending on number of nodes in your tree, recursive post-order traversal of the tree, might let you run into problems on the stack. If the number of nodes is huge, you might need to consider a non-recursive post-order traversal. Have a look at $URL$ which describes multiple solutions, both iterative and non-recursive. On think to keep in mind is that the non-recursive algorithms use more memory, as it need to push nodes to a stack. You might also consider doing a post-order tree traversal enumerator, but that might be for another day. 

Use buffered reads. If you actually read a line at the time it's pretty time consuming. Use buffered writes. Instead of writing each new line, collect in a buffer and write in chunks. 

Style I like the style of the website. It might be a bit too simplistic, but the general direction is good. But if the screen of the user is too wide, the black bars that span all the way across the screen might be a bit heavy on the eye. 

Data Handling & Security You use prepared statements, which protects you from SQL injection, which is good. However, the way you handle passwords could be improved to increase security. It's not a good idea to semi-randomly apply sanitation functions to user input as it results in dirty data. for example really only makes sense when magic quotes is enabled, so you should check that first (and then only strip the slashes in some init file, not every time you access GET). For example, if a user has a password like this: , stripping slashes reduces the password length from 9 to 6 characters. Same problem with , only much worse. If my password is , now my password is . You also don't need . As XSS protection it's not sufficient anyways (and definitely not needed for passwords, which aren't echoed); You should HTML-encode data when echoing it instead. There's also really no need to have a length restriction on the password, especially not one that is shorter than what your hashing algorithm allows. Hashing Simple sha is really not good enough anymore, as it's too fast. Use bcrypt instead. Error Handling Don't echo database error messages directly to the enduser. They won't know what to do with it, and it may provide attackers with information or enable some forms of attacks (such as error based SQL injection). It's also not a good idea to echo anything in a function, as side-effects like that make it harder to reuse. Structure I think your structure is pretty clean, and your code easy to read. Just a couple of small points: doesn't seem to have any purpose. I wouldn't call the constructor inside a function of the same class, but just use it directly. I would also not pass a magic array to the constructor, as it's hard to use and reuse (I have to guess how the array must be build and what it must contain, and I have to use the pre-defined array keys). Instead, just change your constructor to . This increases clarity and reduces future bugs. Misc 

Creating the DocXTransformer will load the file. Calling Transform, will execute a list of Transformer classes, which each implement the ITransform interface. 

The FastCollection contains an additional list and a dictionary of lists, so it's memory consumption overhead might become an issue. I would suggest that you look into representing your data structure (Product) in a data structure which is more optimal for searching than a list. If you into tree-structures or balanced tree structures, you will see that searching cost O(log n), where n is the number of elements in the tree. You can easily build the tree structure with a custom compare function, and thereby having a very fast generic searchable structure. Well, just an idea, which you might consider overkill :) 

Which version to use I wouldn't care about the timing difference. There may be situations where it matters, but in almost all cases, both variants will be so fast that the difference becomes irrelevant (we are talking about a fraction of a millisecond here) and other factors should decide which version you use. In this case, those other factors might be readability and reusability/adaptability. I think the second version is more readable, but as you said, the first version can be easily adapted. So if you predict that you need to perform additional changes to the segments, go with the first approach, otherwise with the second. Differences Please note that the versions are not the same (the first one only trims slashes, while the second one removes them all). For your use-case, this doesn't matter. But as this code will probably be wrapped in a function which may then be reused in different contexts (you could eg pass the slash as argument, and then use the function to trim whitespace from arrays (for the first version), or you could use it to remove an unwanted character from the segments (for the second version)), it still matters. 

inside the HostAsync method. By not putting the await keyword inside this async method, we get basically a synchronous call, a standard method. Not a big issue in most cases but have a look at : 

As most of times, catching a general Exception instead of a specific one means a bad pattern, I suggest to catch only specific exception, may be IOException. Althought you are logging the exception, may be rethrow them AFTER the logging. Hope this helps. 

It means we are testing the directory existence after downloading and before saving, a waste of time if the directory doesn't exist it seems 

line .. The first thread enters the lock, the key is added to the dictionary, fine. At almost the same time the other thread enters the lock, find the key already there and go sleeping. When the first thread exit, if you don't release the key, the other thread will wait a long long time .. May be something like