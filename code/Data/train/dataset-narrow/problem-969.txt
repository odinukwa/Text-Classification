Currently they all print to std::cout. But I can see the processes of haveing multuple of these running with different streams connected to different standard points. Looks like these should be normal members rather than static members. Hard code std::cout 

The DB is an expensive resources. There is no point in connecting to the DB or even getting stuff from the DB unless you have a valid username and password. 

Use Reserve Building the string character by character may not be the most efficient way of getting the date (as the string may be resized on each insert). 

Yes. Yes. It makes no difference for integers. But it does no harm to use pre-increment on integers either. But again it's one of those habits you should get into. There are situations where it does make a difference so it's best to pre-increment and then it will always be correct (even if you change the types of your objects). Prefer over The difference between the two is that performs bounds checking. 

But unfortunately is the local of the stream not the locale of the . So we need to dig a layer deeper before meddling. 

You are binding your representation of a vertices to always contain its list of edges in this manor. You should really define a more abstract interface on the class that will allow you to change the internal representations without affecting the implementation of Graph. When you add edges to a graph. You check that the source is there. But you do not check that a destination node has been created. I would expect this to be more symmetrical. Is the method 'void resetStates()' really a member of the public interface? In your BreadthFirstTour/DepthFirstTour traversal of the graph. Its not really a breadth first/Depth first tour (as this implies a breadth or depth) while a graph is bit less symmetric than that (especially since edges have a weight and the graph may not be fully connected). But as part of the implementation you actually store whether a node (vertex) has been visited as a member of the vertex. You are basically tightly coupling the traversal of the graph to its implementation which may restrict you in future enhancements to the graph (and limiting how the graph can be traversed). You can de-couple how the graph is traversed from the implementation of the graph by using a visitor pattern. This also conforms to the open/closed principle by making your class open to expansion but closed to change by allowing the traversal mechanism to be specified externally to the graph. 

Further Advice. I would suggest some more specific recommendations. But unfortunately you do not provide the expected usage semantics of your factory. Thus I may write something that is tially usless. If you can write some more details on how you think the factory is going to be used I can give you some more concrete information. Errors in the code: 

Tokenizer is complex You can seriously simplify by using self documenting code (split reading each token into its own function). Your current code is complicated because you are trying to read all the different types at the same time. The good thing is that you can tell the next token simply by seeing the first character of the next token. 

Everything @Jerry said. In addition I echo the view of @Bizket but disagree with the better solution. C++ emphasize the use of concepts (the exact type does not matter, the interface of the type is what matters when designing). You loop over an C-array and Bizkit says you should update to specific C++ container types. I would suggest that you update to use generic C++ container types (as long as your input acts like a container) that support the interface you need (then let the compiler verify its correct). Also C++ tends to use to define ranges (or containers). This allows you to be more flexible issue. Also why are you constraining your algorithm to ? Just make it generic then you don't need to write it again for other types. 

If your destructor does nothing (or the default thing). Then just let the compiler generate one for you. There is no need to waste space and cognitive resonance in your reader for something that is automatic. 

Perfectly good readable code. But you can simplify it a bit using iterators. The standard contains an iterator that reads values from a stream. 

Don't try and write C++ like Java. We don;t need a string function. It is much more preferable (and flexable) to write an output (and probably input) stream operator. 

I would expect this to be part of a class. Where and are part of the object. So you don't need to pass them around. Separation of Concerns Your code should either be resource management or business logic. Your code mixes the two different types of code together. Here the resource management is removing the node from the list. But you also have some business logic inside your code that is talking to the user. 

Of course this tightly couples your code with the logging system. To make singeltons work effectively they should always be used in conjunction with other patterns so that you don't tightly couple the code. There are a couple of different ways to avoid the tight coupling. One of the simplest is to use a factory pattern. Then get the appropriate logger object from the factory. This allows you to use a different type of logger during testing etc. 

This is a funny way of accessing member variables. Normally I would use to specify the exact member (rather than as that implies static members). But better yet is not never to shadow member variables. Shadowed variables will eventually cause a problem as you will forget to disambiguify them from the shadow and your compile will not warn you when you go wrong. A nice trick is to turn on your compiler warnings to tell you about shadowed variables and to treat them as errors. Comments I hate bad comments. But this would be a nice place for a comment. 

Since you should have a swap method anyway. This also makes writing the move constructor more intuitive as you can also just use the swap method. Also note your move constructor has undefined behavior. 

No Throwing methods Since the method is guaranteed not to throw you should probably mark it as such. 

Not sure why you specify a function. The problem is that a lot of code in C++11/C++14/C++17 uses lambdas (which are functors (probably)). So your handler should be a template that allows any generalized code to be executed. 

There is no requirement for bidirectional iterators to have a less than comparison. Unless you really want to store iterators in a sorted container I would leave this out. Note: A random access iterator does have a requirement for a less than operator. But it has a precondition that it can only compare iterators that are reachable from each other. see: $URL$ 

You are putting the largest element at the beginning. The result is that the partition does not work optimal (you basically are always getting the worst case scenario thus converting an O(n.ln(n)) algorithm into O(n^2) algorithm). Minor things: One variable per line. 

The standard containers (that support pop()) return a type. This is because there is not a way to implement an exception safe that returns a value. That is also why they have . So you can get the value with . Then do an exception safe . 

There are also some very good command line parsing utilities (so you don't have to write boilerplate code with potential mistakes). When somebody has gone to the effort of writing and debugging for you you should probably use them. $URL$ 

It has no place in your code. If you want to remember old code then use version control software. There is lots of free stuff around. A very popular one nowadays is . You can even host you repos for free on . Not much point in using a class if everything is public. If you are just using it is a property bag (ie no methods and all the code is in BST) then you can use struct as an indication that this type is not that important. 

Using new/delete is a bad idea. It makes you do all the memory management. It is better to use classes that do it all for you. In your case std::vector is a better choice for memory management of arrays 

So you have a bunch of different factories that all implement the same interface. But how do you know which one you should use. A common way is for a single creation point. Just ask the system it will create one for the lifetime of the application. 

These are technically illegal identifers as they are reserved for the implementation. refrain from using "double underscore" anywhere or and a single underscore as a prefix. Even if you know the rules like me others (like you) don't so best to avoid them. I don't think this is technically legal. 

If this actually generates a random number in that range then I would seriously kick the implementer of for generating an initial range of [1..(number-1)) This comment is even stranger: 

The blocks waiting for one of the file descriptors to become available so that a using it will not block when it is used. But you are blocking on the so you are not gaining any advantage to using select here. The point of is when you have lots of sockets with lots of data being read/written. Then allows you to continuously read from sockets that are ready and not block waiting on sockets that have nothing yet. Remove from this context. Printing error messages This code is way too low level to be printing error messages. 

Note If you have a hole in the wall that is exactly one block wide you need to hit it dead center to pass through the gap. To give you some wiggle room you can move the corners in slightly. 

Note most C headers have a C++ equivelent . By using these headers you put all the functionality they provide in the namespace. The headers you use put the functionality in the global namespace (though implementations may also put the functionality in ). As a result your code below where you use is very likely to fail on other compilers (or at least you can not guarantee it will compile out of the box). Design Note: this is a good comment. 

Move Semantics You don't take advantage of move semantics. To put something in the list you still need to copy it into the node. Sometimes this has to happen. But sometimes you can move an object into a list and save the cost of a copy. 

It makes it hard to understand what you are doing when you subtract integer literals from character codes. I would normally expect some form of value that conveys some meaning. For example lets assume ASCII (You probably want your keyboard thing but I don't know the appropriate macro).