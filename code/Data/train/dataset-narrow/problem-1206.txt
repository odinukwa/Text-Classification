As a rule of thumb always use braces in nested statements. You only need one loop that goes over the array once so start with determining the sum/product of the first subarray. Also if you use unsigned data, then the result is automatically rounded down for you. 

The idea with the offset is okish but not really smart. Why store the offset between two iterators, when you can remember the iterators themself? Then you can simply check whether the second is equal to the first. If not print the element and increment. If they are equal, increment the second iterator until they are not. 

Now that you have a vector with all the wealth of the beheaded people you can easily print them out: 

Actually there is a std::isspace for your characters, however find_last_of does not seem to take a predicate, so we are stuck with a constant. What is also really useful is the deletion of multiple consecutive whitespaces. Here std::unique is your friend 

Now the return is really not needed,and a look at the reference tells us that erase returns a string& $URL$ 

Holy moly, there is some really mean stuff in here. To reiterate the obvious that has already been mentioned 

You can obviously extend it to use your prefered generator. Then you should either pass this per reference to your function or create a class with generateRandomChar as a method. 

Avoid single line command flow statements like as much as possible. This completely breaks readability of your code as you know have to check every and statement if it has a coomplicated condition or hidden code or nothing at all. Your code does work, but it is highly inefficient from a mathematical point of view. As a hint I would suggest you think about how to utilize a std::map for this problem. 

I don't know what happened here, but I think the compiler ought to give you the sign-extended version of this instruction automatically. Bytes 83h,C6h,60h. 

Nice, but wouldn't it be possible to combine a few things (the first and the second )? Yes. Using and a conditional complementary the code has yet again shrunk, this time by another 2 bytes. 

Conclusion As you can see it's possible to optimize this code a lot, but I think the best advice I can offer is that all these macros really should have been written as subroutines. In this form the program is simply too long for what it does. I tried to not repeat comments that I made on the previous (shorter) review. Obviously they still count. I'm pretty sure that if all these modifications were applied correctly, and thus shortening the program considerably, more advanced tips (especially on program flow) could be given. 

On FizzBuzzGo the number of divisions was reduced by 49 percent. It is very easy to turn this binary tree into something shorter that doesn't use any conditional jumps. I decided however to not keep it because I feel there's at least some contradiction in branchless binary tree. Moreover it was a bit slower. 

Another optimization this time on compairing. To compare with zero, you can equally test the value with itself. So writing . This shortens the program. 

Currently your calculation shifts the BPB_RootEntCnt 5 times to the left immediately followed by shifting it 9 times to the right. Can you see that this comes down to just shifting it 4 times right? To get code that won't fail on exotic BPB_RootEntCnt values use next calculation: 

One final point about this code is about the use of . The negation of zero is also zero. That's why this kind of testing often uses which guarantees the value gets modified. This doesn't impact your code however since you've chosen an address that certainly does not contain zero. But choosing a fixed address like eg. 21h*4 (DOS isn't loaded for sure) would make setting up much shorter and even allow you to not use at all. 

Why is the head separated from the tail? If you use a container you can utilize to get the first element or for the last one. 

However with less indentation and easier control flow. You should definitely reserve memory in your merge function: 

What is generally less efficient is iterating over an unordered set. This is because the set is actually a hash table of the keys. So whenever you want to iterate over the key-value pairs, a std::map is generally better. Also what i apparent is that there is one function to do everything. This makes the code rather hard to follow and oversee. You should rather create one function for every functionality you want to implement and build your algorithm from short but clear functions. In your case there are at least 4 natural subfunctions that occur on the first glance. 

I would think, that you should try to divide and conquer rather than writing one long function. That means you should split your code into separable and reusable functions that do one thing. For example the individual minima you get by the following functions 

I have to say, that my compiler hat home complains about make_unique. In any case this should work too Now you have to add the links between the houses 

A binary tree that is composed of nodes. Generally the tree class would handle insertion and removal of nodes. So you should start with 2 classes and . Also a class should have a constructor and optionally a destructor 

This has a second advantag, now when endpos == std::string::npos nothing will happen, so we can avoid the if 

So this would be the plain algorithm you utilized. However, as you said this will most likely give you TLE. So what i believe would be the main idea behind the challenge is to realize that there might be immutable orbits inside the map, aka whenever you end up with the same combination of token and machine, you can shortcircuit by taking the remaining number of steps modulo the number of steps it takes you to reach the node the again. So the question is, how can you find out, whether you can shortcuircuit and how long it took to get to the same token again. For me the solution would be not use a std::pair, but rather a custom struct 

Each time you clear a register (any general purpose register!), you can do this more efficiently by ing the register with itself. 

A loop like this is wasteful because of the uncondional jump that gets executed on every iteration, on top of the conditional jump that needs to be processed anyway. You can make the conditional jump the only jump that gets executed repeatedly. 

This is a very nice approach! Although for reviewing purposes I had to read it a few times over, it is definitely better here than the simpler would have been. 

By popping exactly 80000000h, you guarantee that the will produce the desired 80000001h. I've used because it's 1 byte shorter than . 

Noticed the discrepancy between the dump and the instruction's immediate? If you copy/pasted this code then there's something amiss with the disassembler, else it's a typo. 

You don't even have to compare to 8 at all! When you shift the counter in 3 times to the right in order to find out how many qwords you have to process, you can look at the zero flag. If the ZF is set (meaning no qwords at all), you instantely know that the counter is in the range [1,7], and so the above snippet becomes: 

In stead of preserving the dword , which uses 4 bytes, you could content yourself with just and because the high word is never in danger of modification in your code. This saves another 2 bytes. 

A second optimization will be to get rid of all of those direct console outputs for CR and LF. You should incorporate these in the messages that you will print. Doing so will also remove the need to copy AL to BL using (you specifically asked this): 

Better Solution So these were the intuitive solutions. However, is there some room for further improvement?. Obviously yes. The point is, that you do not need to store the same element every time because you know what the maximum is. You can circumvent this by using two stacks. One with the current maximum and one with the number of its occurences. 

You function read_line does not what it suggests. It reads a file line by line. So you should find an appropriate name. Your choice of uint_fast8_t/uint_fast16_t is interesting given that your example csv table hold some larger values. Have you measured the impact vs unsigned int or std::size_t. Be aware that modern cpu can read multiple elements at once so you choice might actually have negative impact. Every line you clear numbers and build it up again. It will be beneficial to just initialize it once via and then just overwrite the old value. That way you can omit the unnecessary Getline takes a third argument which is the delemiter. Also getline stops at newline and end of file so you dont need all that error checking Given that you now the number of entries per line you can simply loop and accumulate 

The at the end is not necessary anymore with modern compilers. You should prefer pre increment over post increment , as the later involves a copy (at least for non trivial data types) Actually your code itself is way to complicated. Rather than assigning a new vector you can just shrink the old one 

I do not understand why rounded up is equal to rounded down + 0.01? You are checking whether the rounded down value is smaller than the original one. From my perspective it is more logical to check for equality instead as this is what you meant. 

Here you need to verify your understanding of the count in . It specifies the number of characters that you want to draw. The hexadecimal value 1000h equals 4096 in decimal, but the usual 80x25 textscreen only has 2000 characters to play with! In your program it seems to work OK only because the video memory is much larger than that single display page you're looking at. Nonetheless you should correct it to avoid developing the bad habit of buffer overflows. 

As you can see I combined a pair of settings in a single instruction. This saves space, can be a bit faster, and the comments make it absolutely clear what is going on. The same applies to drawing the gray bar, although it's not clear: 

You'll agree that much that was said about the 16 bit version also applies to the 32 bit version. To be honest, I found it lacks so much on comments that I hesitate to actually review it thoroughly. I will however point out the next optimizations: 

Since your intent is to put the value in on the stack, do so in one go with . And clearing the register right before a instruction is wasteful since 

You used very descriptive names for all of your labels. This is good. Please allow these 2 observations: 

Because all of your variables Sum, CurrentPrime, CurrentN, and PrimeMode reside in registers your code could/should benefit from this fact. You've calculated using: 

This is a misleading comment! Since the premise states that the results are to be below the inputted number, the line conflicts in the usage example given. 

Currently your program depends on the zero stored in number. In future you might want to re-use number several times and then the zero-terminator might not be there anymore. I think it will be more robust if you wrote