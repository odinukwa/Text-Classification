I would create multiple subclasses of the abstract class (or interface) to handle the disparate cases above. As well, I agree that you should define several versions of with different names and appropriate type hints. This will provide a nicer API for the developers that must use it. I don't see an example of when is a method. Do you pass in the method's name or its ? What about functions? Here's where named factory methods would be helpful since they could look up the reflection objects or defer to the lazy subclass. Remove all those s. The following are equivalent to in a boolean context: 

While the problem description isn't very clear, I expect the intention was for you to use to encapsulate a single (x, y) pair and use it in et al. However, your version contains two points and thus should be called or . What is the reason for this? I would remove the setters from to make it immutable. For one thing, they aren't needed by the problem. But more importantly immutable objects are easier to reason about and use in multi-threaded environments (later). While a square can be modeled using either pair of diagonally-opposite points, this won't work for any of the other shapes. should contain four s. You're free to have accept two points in its constructor, or a single point with a width and height, and calculate the four points from them to pass to the superclass. As for the hierarchy (you only show two classes so far), consider that a square is a special type of rectangle and should extend it rather than . There are other cases like this, and you should start by listing out the properties and constraints of each shape. This will help you determine the optimum class hierarchy. Pro tip: I would bet that the annotation's property defaults to . If that's correct, you can omit it for brevity. Update In two-dimensional geometry, a point is represented with two coordinates named x and y. 

Now you can pass one of the constants to which will forward it to and greatly simplify the code at the cost of exposing those constants. You could still provide the property-specific one-liners, though. 

Here each holds the specifics for a single unit belonging to a team: its position, health, action points, etc. The table lists the things that don't change about a unit: its ammo and fuel capacity, strength, etc. This minimizes the data duplication across tables and allows you to load up all unit types at the start of the game or in tools for easy reuse throughout. 

Many of these methods would be simplified by moving them to . The biggest clue is how you have to keep passing s around between the various methods and recursively. This makes responsible for managing its key, name, and children while leaving free to worry solely about the root. 

The Java memory model guarantees that the reference will not be written until all writes have been flushed. The field will be initialized when the class is loaded and safely available to all threads. This has the added benefit of avoiding synchronization to access the DAO. 

The main issue here is that everything synchronizes on the restaurant object. This means that the chef cannot prepare food while the client is placing an order, waiters cannot serve while the chef is cooking, etc. The first step would be to add s to and let them manage all of the calls to and for you. You'd need one queue of orders that waiters place and chefs take and another for food that chefs place and waiters take. When a calls on the order queue, it will block until there is an order available. A calling on the same queue will block until there is room in the queue. You can make the queues bounded (maximum size) or unbounded. You might even create a queue to hold the s waiting to place orders. s would the food and client queues in their loop so they don't wait forever for food to be ready when they haven't even placed any orders yet. 

I see no reference to . Is this a bug or intentional? Does the system ensure that forces to be ? Assuming the code is correct we can define 

Wow, arrays would be really nice for this, but I suppose you can give a "rewrite that first problem using arrays" once they learn them. :) What happens if they enter zero or negative values? Anyone born in February is automatically invalid: 

The purpose of your program was unclear to me before reading the problem description. I could understand the logic flow, but I had no idea what answer it was seeking. 

You should be able to omit the temporary array by inserting the call into the call at the cost of a little code clarity. Try it out to make sure the order of operations is correct. 

At least the complicated checks are encapsulated in these classes which is the whole point of introducing the pattern. The downside is that this logic can be more fragile than inheritance. Is this a good trade-off? 

One improvement you can make for DRYness is to replace the with a simple . This is possible because the AJAX call passes the field name in the parameter (they all seem to match). 

Store the current stations into local variables to avoid having to read and many times. Also, when you name variables identically except for and (unavoidable in this method), don't hide the numbers in the middle of the names. Finally, since all these time-based local variables are for line X and track minimum times, drop and from their names. 

I highly recommend Java Concurrency in Practice by Brian Goetz et al. This will give you a solid foundation for building multi-threaded Java applications. The biggest problem with is that it is not thread-safe. You must synchronize all read and write operations to be certain to see the latest values for fields. This doesn't mean you have to lock the structure the entire time. This is explained far better in the book than I can here. The short of it is that without synchronization via memory barriers, the JVM is free to cache values read in one thread and miss writes happening in another. 

Note that I would probably store the three variables into an array instead of individually-named variables, but I have no idea how they're being used in the wider context. The code here should be a drop-in replacement for yours. 

Using this technique can complicate some logic, for example which now must check to see if the node is a real one or not. One trick around this is to have the node return a stating whether it was able to insert the new node or not. If not, overwrite it. 

If you really want to drink the PHP Kool-Aid, you could implement the ArrayAccess interface so that clients could use 

Neither will be simpler than using the date function's code, and I'd bet $5* this would be faster than both. 

These are minor changes, but they clean up the code a bit. I also renamed to to clarify what it holds. They also cut the running time by more than half. 

Wow, that's pretty bad and quite unpythonic. :( Edit: Yes, I realize that reimplementing the problem doesn't help with reviewing the original solution. I was hoping to gain some insight on your solution by doing so. If it's utterly unhelpful, downvote and I'll remove the answer. Edit 2: I removed the unnecessary second recursive call. It's shorter but still not very elegant. 

Note that the author went for efficiency by precalculating many of the conversion constants. I wouldn't bother with that to start as it's probably premature for your needs. Your conversion methods should start simply: 

Separating the parser from the factory makes testing easier. You can now test the parser with a mock factory once and each factory without a parser. The factory creates the segment or error message while only the parser deals with the result object. This is separate of concerns at its finest. Because is now passed to you can reuse the same parser (one per factory type) and factories if you like. This also makes testing easier. You can create an abstract factory that implements and as you did with the original parser. Move the regex constant and error message prefix to constructor parameters if all factories work the same. 

A line is similar to a segment except that it extends past the endpoints out to infinity on both ends. A polygon (e.g. a square or quadrilateral) is formed by connecting segments in a closed loop. 

You're performing a breadth-first search of all possible paths through the maze which is what I ended up going with. By scheduling timer events you're essentially queueing up cells. I did the same but with an actual queue of cells to visit. This is the core of my Scala version. 

Other Thoughts I'd be tempted to drop the stack of sections () in favor of storing just the active section since that's all you need. To pop a completed section off the stack, a) store a reference to the parent section in each section instance and b) assign the parent to after each section completes. Finally, you need to handle exceptions so other sections can be run. You should be able to do it once in . On to Phase Two! I'm very curious to see this in action. With QUnit I am often forced to perform the same actions on the fixture as a previous test did in order to set up the current test. This causes code duplication whereas the whole point of setting up a fixture is to avoid it. In Java I've been building separate fixture classes that provide methods for setting up common fixture states that can be reused across many tests. While that's helpful, it's not as easy to do in JavaScript. 

Because the intervals are already sorted by start time, you can begin the inner loop at and simplify the test and drop the call to : 

If you're mocking a lot of JSON AJAX requests, you can create a common fixture to make this a little saner. You can call with a number for an HTTP response code, an object to convert it to JSON, or a string as the raw response. 

BTW, does follow xUnit conventions and put the expected value before the actual value? If so, your assertion error messages will be backwards: "expected 'foo' but got 'bar'" when testing the stub method 

Timing Variations The runtime of sorting algorithms can be greatly affected by the initial order of the elements. Each algorithm has a best and worst case initial ordering. For example, Bubble Sort requires \$O(n^2)\$ swaps when given the elements in reverse order and none when already sorted. Even by sorting one million arrays, when you run the program again you start with a new random seed which produces an entirely different set of random arrays. One seed may produce a higher percentage of worst cases. You can remove this element by choosing a random seed to use on every run with . In addition to that--and probably responsible for more of the outliers--you are calculating wall clock time. If the system swaps out your program to do other work, the clock keeps running. You can mitigate this by timing at the system level (e.g. using on Linux) which will track wall clock, CPU, and system time. Finally, the smaller arrays will involve a higher ratio of overhead compared to the actual sorting work. I recommend fewer repetitions with larger arrays, say sort 10,000 arrays of size 10,000. You may also want to consider creating initial arrays by shuffling the numbers \$(1..N)\$ to remove the unpredictable effects of equal elements.