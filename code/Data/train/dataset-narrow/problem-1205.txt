give names to your parameters. As is, this line is unreadable because one cannot know which parameter has which meaning. Do not define a destructor if it does not actually do anything. The compiler generates the empty constructor for you anyway. Put your s inside your header guard. There is no sense in making compiler and preprocessor do additional work if you do not actually use these headers. Order your s. As a rule of thumb, begin with the header this source file implements (if in a file), then all headers from the same project you are working on, then headers from other libraries and finally headers from the STL. This ensures that all your headers are self-contained, i.e. include all the necessary headers themselves. Also, you should sort your s (in their respective groups, of course) alphabetically to make it easier to check whether some header is actually included or not. Do not include C standard library headers directly. All of those headers have a C++ version with a prefixed that brings the definitions into the as opposed to the global namespace (i.e., instead of and prefix everything from that header with ). Why do you prefix all your variable names with ? If this has to do something with name clashes with parameters to your constructor, you should instead use the variant or, even better, if using C++11 or later, a member initialization list instead. Choose better variable names. One letter variable names are high up on the list of things that hurt readability the most, because knowing what a variable contains and what it stands for is often crucial to understanding code. I realize that some of your variables represent mathematical symbols, but those who do not should definitely have a more descriptive name. Make your naming scheme consistent. For example, why do you have some variables with a capital letter and some without? Why do some methods follow CamelCase and others a plain capitalize-the-first-letter-and-nothing-else-scheme? There is no general consensus as to which naming style is best, so you are free to pick one, but please stay consistent (and do not pick a style that is hard to read, e. g. all lowercase). Adopt a sensible indentation scheme. Again, this is something where a lot of programmers do something slightly different, but there are some general rules that most people follow. Most importantly, you should always indent when creating a new block, which you already obey. However, when you are not creating a new block, there are seldom reasons to increase indentation. In particular, lines such as 

should be . I hope you agree that the latter expresses your intent much clearer. Instead of , include . The former is a C header, the latter is the C++ equivalent. Also, should include (or similar) for . Even when dealing with C APIs, please try and stick to your C++ coding style as well as possible. This includes not using C-casts, using instead of , using functions from the C++-version of the C standard library headers (looking at you here, ) etc. If your member attributes have default values (such as and of have), you should assign them in default member initializers, not in the constructor. This prevents undefined behavior from missing an initialization somewhere in more complex cases and also declutters your constructors a bit. About C-style strings and string buffers: Don't use them. C++ has better things to offer:, (since C++17), even . Even if those are not to your liking, please take the time to find a better method of passing data around than pointer-length-pairs. Some typos: should probably be . Similarly, should likely read . 

Do not use , it is considered bad practice as it can lead to subtle name resolution errors and makes the code (in my opinion) more difficult to read because you now have globals, for example and in your program which are not easily recognizable. You do not need to define all variables at the top of each function, and, in fact, should favor to declare your variables as locally as possible, because this helps people keep track of what is currently important while reading your code. Nobody wants to keep track of several different, obscure variables whose meaning and usage is only introduced several lines deeper down. It is completely unclear to me why you wrote which is equivalent to but very obscure. Even more obscure, why do you even have a variable named if you never use it? Remove it. Rethink operator spacing. Ultimately, this issue comes don to personal preference, but please consider adding a space before and after each binary operator. Lines such as are much harder to parse quickly and correctly than . Do not use unless you have a good reason to, as it not only creates a line break but also flushes the stream, which can be detrimental to performance. Although it is unlikely to matter in your case, you might find yourself working with situations where it does matter, so you should make a habit out of preferring . Concatenate adjacent string literals when writing to . You could get away with fewer calls to if you wrote instead of . Omit . The compiler automatically inserts it for you (although only in ). You do no input checking at all. If a user enters anything that can not be parsed as a double by you will be running into undefined behavior because of uninitialized variables. Depending on your use case, this might be fine, but if you ever intend to have somebody else use this program, you should add some checks to make sure you actually receive valid input. You should consider letting the user input all three values of a vector on the same line, not only to make your code a little more succinct, but also to make it a little more user-friendly. 

What we do here is just divide the number in by 10 and print the values stored in (result - only if >0) and the - reminder. Printing the hints On fourth attempt you are putting the character to be printed in . It should be in . You don't also have to use different registers so just: 

You have a bit of code duplication that could be extracted and consolidated. But first with some error fixes (at least the code did not compile on my TASM). Compilation issues 

Compare Your compare method is kinda strange. You do not iterate at all and you don't use any opcodes that would do that for you. It works only when you have one-char secret. Not so cool :) I would write it like this 

The actual string starts on index 2 and before that you have max string length, and bytes read. Also there's no at the end. You have to put it there. 

Without the actual model and some numbers (how long does it take to execute/ how much 'space' it takes?) might be hard to optimize, but what I can tell is that you call quite a lot in such short method. When you do call it you basically iterate over a source (is it DB source? in memory source? other?) and grab it to the memory of your process. Try reducing the number of calls - it will improve your performance. Take a look at this fragment: 

and similarly in the second place. Also some checks for input length might be good to do. You should also comment more your code. I strongly believe the code should be self documented but not on such low level as asm :) So comment more. GIST 

is defined twice. First as a string ( and the second time as a label. I would rename the first one to and use it in 

Other things that might be good to fix You have the same loop for scanning the characters. Why not enclose it as another proc and just use in those two places? You can make assumption that for example will point to the buffer that has to be filled. Also in this scanning you could handle for example backspace character and delete the characters. 

which is just . So let's call it like that and make sure a requirement that when calling it we have dx 

A bit of explanation. This macro will do all the work that is required to check if a specific flag is set (specified as operand op1) and if so print the message specified by operand op2. We need to specify also our label as local so that there is no label duplication when macro is placed in code multiple times. We also keep the flags to be restored after printing. Having this we can simplify the code a bit to basically this: 

You could also add a new line to those strings so that, they are a bit separated from each other when printing like this: 

as in the will be the number of characters not the ascii representation of that number. If we could restrict ourselves to maximum 9 characters that would be easy. Just add 48(dec) to the and you get the value. Since your secret is limited to 21 characters we could go with a simple method for printing. 

You have a bit of code duplication that could and should be removed to avoid mistakes. FASM supports macros that you can use to remove duplicated parts. One can define a macro: 

Buffered input I don't know why you chose buffered input as your method of entering the hint, but in case of this command the data has a specific format. 

Using those instead of bare -ing will make your code more readable. Having those it's clear what you try to do with this code High-level functions 

You are calling on a source basically retrieving the whole collection with all the properties and only later you are taking just the two fields. If you want to reduce time and space - try taking only what's needed from the underlying source, but also it greatly depends on the typo of source you are using underneath. Consider dropping the LINQ at all. LINQ is great and compact but it has it's 'dark side' in term of hidden allocations. Also think abount some old-hasioned ways like 'paging'? For the dropdown that might not be the best way - but maybe it is. If for most cases only the top 20 repair issues are accessed then here's your optimization - and for few cases user would need to load more items to the list - that might be ok. 

What is the purpose of shortening the term "Prime(s)" to Prim in your method names? IMO and are more readable. The same is true for etc. can simply be Your spacing is inconsistent. Generally, it is recommended to leave a space between a control structure (, , etc.) and its following open paren, which you adhere to exactly once in , but not elsewhere. The same applies to operators: Write instead of . Your method is grossly overcomplicated. First of all, you check every number up to for divisibility, while it should be obvious that there can be no divisor greater than . Still, if you think about the problem, you will soon arrive at another conclusion, which is that you only need to check numbers up to , because you can write (with and being positive integers), which is to say that and are divisors of . Now, letting , and by thinking about how multiplication behaves, we can conclude that either or must always be lesser or equal to while the other must be greater or equal to , because when either or is smaller than the total product would shrink unless the other one grows to counteract this fact. The next problem is your use of a array, which is completely redundant. You do not need to store the result of the division test for each number separately, but you only have to keep track of whether you have found a divisor for (=> is not prime) or not (=> is prime). All in all, I would rewrite the method to something like this: 

This, on one hand, serves the purposes of checking whether each header file actually contains all required includes (say, for example, your header actually used something from ; with your current include order, your compiler would not complain because you include in before , thus hiding the missing include), on the other hand helps readers of you source code to verify includes quickly. Quite frankly, I don't see the reason you do this here. Why not just use ? Anyhow, if you really want to have this (and also have a good reason to), I would expect a similar for here because of consistency. Alternatively, one could argue that you should be taking an and a as template parameters, especially since the s and thus the seed types of random number generators in the standard library are different for different generators (for example, uses whereas uses ). Instead of , you should write to prevent subtle bugs when changing the type of The name is not very clear. Although the abbreviation "rng" is quite common, what "bp" means will not be clear to most people on first sight. Since your header is named , I would expect your class to have the same name. currently takes a as argument by value, but you only ever output it to , so you should take it by const reference instead. Don't write where would suffice. For example, when writing to , the former implies a call to and an additional indirection while the latter just passes the value directly. is not really a fitting name for the second parameter you pass to . I was confused the first time I glossed over that function because, for me at least, almost exclusively stands for . I would have grasped that parameter's meaning much more quickly if you had actually named it or anything along that line. 

Yes, there is. In fact, a very nice way to solve this code redundancy issue comes to mind if you consider that is a just type alias for and an alias for . Likewise, and are also just aliases for and , respectively. This allows for an easy template-based approach to the problem. What really suggests itself to me is keeping this alias-of-template-base-type pattern from the STL (although there may be other valid approaches as well), an implementation of which could look something like this: 

Do not try to do too much on one line. Constructs such as are difficult to read, difficult to parse and prone to errors. Instead, let each control statement have its own block, and do not abuse the comma operator to do completely unrelated things. For example, the line I mentioned should rather be something like