Which one is easier to read (and incidentally to write)? Notice that C++'s syntax for pointers dates back all the way to C, i.e., the mid-1970s. It's had a long time to polish and refine and streamline that syntax. You're trying to invent something "better", without the benefit of controlling the language definition. You shouldn't be surprised that the built-in, ~40-year-old syntax is really suitable for the exact job it was designed for. :) By the way, if you want to deal with empty trees in the "natural" way, consider the following refactoring: 

I suspect you'll find that this simple code is approximately as fast as your complicated file-handling code — by which I mean, you'll never notice any difference in runtime in practice. 

I think the short answer to your question is "what you're doing is fine, but there are other approaches depending on what you want to do." However, first: 

Your use of curly-braces for initialization of (with things-that-aren't-vector-elements) is problematic. Consider: 

I would also consider renaming to , since that's what it's doing. Sure it is "internal", but what it actually does is "single-step the PRNG function", and that's more important to understanding the code. 

As you might have guessed from that pull request, and from the observation that move and destroy must appear in pairs, IMHO it is good practice to combine them into a single operation, whose widely accepted name is . However, you'll still need a type-erased operation as well, to call in your actual destructor. 

Not sure what kind of feedback you're looking for here. What you've implemented is not equivalent to what's usually called . The usual semantics of allow you to do things like 

This makes a shallow copy of the heap and passes it in by value; used consistently, this can absolutely enforce that no weird mutations are going on, and even (theoretically) allow the compiler to optimize more. But it's definitely "for advanced users only" and maybe "not a good idea anyway." ;) 

Having to write that function signature made me notice that your function's parameters are named and , which makes no sense to me. is a name usually reserved for the "this pointer" in OO style, so from the signature of this function I'd be expecting the equivalent of 

That's assuming that you can use value semantics, i.e. you don't need polymorphism or are willing to hide the polymorphism behind type-erasure (a la ). If you really want to use classic polymorphism / pointer semantics / the heap, I'd expect something more like 

You probably don't really need the pointer at all (since now it just points to for some known offset ), but I haven't thought about it too much. 

This code, which rejects tilings with dominos that stick off the bottom of the grid, is important enough that I would recommend putting a comment on it. 

First of all, I don't think this is a good use of variadic templates. IIUC, you're trying to make a function that accepts any number of objects and returns a ? I would express that at least as 

Your internal helpers and aren't sufficiently differentiated to warrant two different entry points. Fortunately, we've just shown that is completely unnecessary. I'd argue that is also unnecessary and should be inlined right into the constructor. That is: 

Now, looking at , I realized that of course I should have known that it modified the heap — because it took a parameter of non-const pointer type! If it wasn't going to modify the heap, it would have taken a pointer-to-const. ...But then I looked and saw this: 

Inserting a word into the dictionary meant a . Searching for a word in the dictionary meant a linear scan — O(n). However, since n is small — on the order of 200,000 — this was blazingly fast (for my own interactive-crossword-dictionary and crossword-grid-filling purposes) and so there was no point in any further optimization. 

Three optimizations I'd make to this code for better API design: First, don't use default function arguments. If I meant to write but fat-fingered instead, give me an error! If I meant to write , trust me to write it. You're hurting more than you're helping when you try to save your caller that one extra character of typing. Second, use radians. Radians are the right answer for trig in the same way that UTF-8 is the right answer for character encoding. Trust the past couple millennia of mathematicians when they tell you that angles should be measured in radians. This will save you some repetition here, and some unnecessary rounding errors as well. Third, optionally, use ; it'll give you more accuracy and be no slower — maybe even faster — than if you're targeting a normal desktop computer. Obviously if you're targeting a 32-bit microprocessor with hardware and software-emulated , don't use . :) In your real code, the above will be super readable because you'll be using real names for the variables instead of long placeholders like . You can also say or instead of . So: 

This is not valid C, last time I checked. You'll have to make and enums or macros, not variables, to get this to compile with a pedantic compiler. (Unless this is inside a function scope, in which case what you've got here is a C99 variable-length array.) 

So we started with "let's remove 2 spaces of indentation from every line in the file", passed through "let's remove two helper methods by inlining them", and finished up with "let's remove the entire class, along with all of "! This is a common pattern in modern C++ programming — and actually in all programming. Eliminate all inessential complexity, and you'll find that what is left is the essence of the problem you're trying to solve. :) 

This is a breaking change / deliberate asymmetry compared to . What's wrong with narrowing? Your example implies that you're worried someone might accidentally leave the off an array type, but that's pretty far-fetched, isn't it? 

Two small problems with your code, related to your use of : First, you're using only 32 bits of entropy to seed your entire Mersenne Twister; it would be better to use as many bits as the has bits of state. However, doing this correctly is needlessly difficult in C++17, so you get a pass on it for now. Second, your class keeps a member of type . This might be problematic, because a is essentially an open file handle to . If you create a lot of objects at once, you might find yourself running out of file handles. Oh, and a third problem is that is non-copyable and non-movable; so your is also non-movable. That could actually be pretty bad, depending on how you want to use it. 

This seems fine to me, but I'm surprised that you're following neither the "Almost Always Auto zealot" pattern of 

Lastly, perhaps notice that is ; and perhaps deal with the possibility of division-by-zero when or is zero. Or even factor out the repeated code, now that it's been made blatantly obvious by our renamings: 

This (a function that blocks, but only for 1 second) is weird and dangerous. Don't do this. If you want a function, write one. If you want a function (that can fail if the queue is empty), write one. If you want a function (that can fail by timing out), write one. But what you did was 

More importantly, what is this function doing? Its name suggests that it should be returning : either you or you , right? What's the point of returning an integer? Reading the code of the function makes it clear that the function is definitely misnamed... but I can't figure out what its name is supposed to be. Also, you return the magic value to signal failure, and then in the caller you test for with . It would be much much simpler and easier to reason about if you returned on failure and tested for . (It might also be just a hair faster.) 

if you wanted to. It pretty much just depends on how important the idea of "attack power" is, to the reader of this code. 

which are nevertheless longer (in terms of number of assembly instructions) than the more "naïve" 64-bit version. Writing an appropriate benchmark for the various possibilities, and writing out the permutation matrices for and , are left as exercises for the interested reader. It would also be supremely interesting to feed these "rotation-permutation" functions to a superoptimizer and see what it produces. However, my wild-ass guess is that the optimal instruction sequence is in excess of 40 instructions, which would (I think) make it intractable for the current state-of-the-art in superoptimizers. But I could be wrong. Anyway, if you find out, it would be interesting to post the results here. 

The common implementation of as a double-ended array of pointers to arrays will definitely hit the bug that Deduplicator describes, whenever the deque reallocates its array-of-pointers. Here's a reproducer for libc++'s , which reallocates on the 1024th call to : $URL$ Reproducing on libstdc++ is left as an exercise for the reader. 

Minor nit: Declare your variables in the smallest, tightest scopes possible; this will aid the optimizer as well as helping the human reader understand the code. 

Notice also that I've dropped the from your , which means I can also get rid of your typedef — several lines of code saved, with no loss of performance or expressiveness. (And on top of all that: if somebody does accidentally pass to this function, they'll get a nice assertion failure instead of a segfault.) The built-in types are nice; use them, wherever possible. Similarly, for the "concentric boxes" pattern, what you're doing is coloring each pixel according to its distance from the edge of the grid. Pixels at distance 1 get red; pixels at distance 2 get yellow; pixels at distance 3 get red again; and so on, all the way to the middle. 

This should certainly be , to eliminate the copy-construction of . Also, stylistically, it would be good to wrap each control structure in curly braces. Putting it all together, we get 

Stylistically, I advise writing "increment thing" instead of "thing increment", intuitively because that's how English works, but also because it can be an optimization in some cases involving overloaded (and is never a pessimization). 

In C++, this does what you want (although modern idiom would have you write instead of ). In C, this defines a -qualified global variable; the idiomatic way to define actual compile-time constants (capable of being constant-propagated and so on) is to use macros or unnamed enums. 

Looks good to me! I mean, I'm not likely to convert to it because of its heavyweightness — you noted its use of , but it also pulls in all of every time you use it, too. Also, it's arguably coincidental that your expressions and work in this context, since what's actually happening in both cases is an implicit conversion from to . In some contexts, the user might need to explicitly cast or whatever. You could remove the dependency and simplify the user's job at the same time by writing a helper function , as in: 

Who says using is an optimization? It feels to me like a pessimization, because you're trading O(N) extra space (and more convoluted code) for something like O(lg N) faster lookups. I do see that e.g. Boost.DisjointSet implements "union by rank" as well, but I'd be interested in seeing some benchmark numbers on your particular use-case. 

If I were writing , I'd start by assuming that I already had the memory allocation taken care of. Then filling the buffer is as easy as what you wrote: 

But that's not what the function does — nor what I'd expected it to do before looking at the parameter names. So basically, your parameter names are misleading. The English names for them would be and , but personally I'd go with and . I think everyone knows what means. :) 

If you do this, about half of your code simply disappears! (You'll still need to specialize and/or overload the above function a little bit to deal with , but it looks like you've got the right ideas about that already.) 

My vendetta against curly braces is purely personal preference; I wouldn't say you were wrong if you preferred and . I tend to use curlies only for code blocks and aggregate initializers; for things that are "intuitively" settings-equal or function-invocations, I personally prefer or respectively. 

First, avoid -qualifying non-pointerish parameters if you can; all that does is prevent you from moving out of them in C++11. (Not that it matters for ; but it can matter for more complicated types, and meanwhile it's not buying you anything.) But do -qualify the pointee of that first reference parameter. 

This is the function you want to be writing. There's no reason to drag object-orientation into it at all. Your main function had been multiple lines long because of the mutation involved (and honestly it's not clear from reading this code that all the expensive work occurs on line 2 — so that's another downside to the anti-pattern above)... 

I have to keep in mind while reading your code that and are different types (despite being spelled the same). That's a good design choice for the user of your library, but it's a terrible design choice for the reader of your library. Therefore, IMO you should create a new name for your type in this file, e.g. ; and then at the very end of the file you should introduce . That way you get the best of both worlds: the user gets two things with the same name, and the library reader gets distinct names for distinct concepts. 

sounds an awful lot like what the STL calls . Function overloading does suck, but inconsistency sucks more. Prefer to copy the STL's naming convention in this case. 

Don't use function-try-blocks on regular functions such as . Use normal try-blocks inside the function body instead. The one place function-try-blocks are useful is on constructors, where they catch exceptions thrown from the member-initializer-list as well; everywhere else you're using them is just unnecessary confusion for people who don't know all the obscure corners of the language. 

However, I think your code as it stands is a bit sketchy, because of the overflow issue. should yield , not undefined behavior! To mitigate that issue, I agree with you that casting all of the parameters to would be a good idea. Let's implement that.