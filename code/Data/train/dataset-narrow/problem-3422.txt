Choose a GPIO pin (one with GPIOnn in the name, green in the pinout) and connect the red wire to it, and then connect the black wire to any ground pin (marked in black on the pinout) Then to make the speaker sound, here's an example in Python (unable to test so feel free to edit). For this example, the red wire is connected to pin# 11 (GPIO17) 

Your best bet would be to go with DLNA, it's a standard for streaming video and audio from a local server. Google "Raspberry Pi DLNA server" and you'll have your choice of tutorials. On the device side, you just need DLNA client apps (again, iTunes/Google Play search for "DLNA client" will get you what you need). It's worth noting that on Windows, Media Player has this functionality built-in. An alternative may be Plex, which has an official app for phones so you may have a better experience than with DLNA. If you go down this route, I'd recommend at least a Pi 2, a friend of mine tried this with an older Pi and it was not powerful enough to stream content in full detail. Both DLNA and Plex will have authentication methods so you can deny access to whomever you choose (for whatever reason). One final note - since both these protocols operate over a local network, there's no need to connect to the Pi directly. If possible, I'd recommend connecting the Pi to your router/network via Ethernet (for the best bandwidth) and then using your router/WiFi access point to stream from the Pi. Alternatively use the Pi as an access point, connect it to your router and set up bridging or connection sharing, so that your devices can still access the internet. 

If you just want SSH-like remote terminal without Ethernet, you can use a serial TTY to USB converter, which plugs into the Pi's serial GPIO pins (Tx&Rx plus 5v&Gnd), and the USB end can go into your laptop. This will allow you to control the Pi's terminal from the laptop (with some configuration). For moving files, you'd probably want to stick with SSH (SFTP operates over SSH) using a USB Ethernet adapter to keep the onboard Ethernet free. 

The LED stays off, or if I change the line to it stays on. I receive no error or warning messages. EDIT: Here is the code I modified it off, when I run this () it flickers as described. 

I don't think so - it seems that both of those devices do not do "pass-through" charging - i.e. provide an output whilst charging themselves. Of course another name for such a device would be a Uninterruptable Power Supply (UPS) - though there could be also a difference if the devices also have a "time-limit" when providing an output, which is not what you want...! 

As you are using Raspbian Wheezy I am assuming you are using the default init system provided by systen V rather than the that is used in Jessie and most other GNU/Linux distributions these days. That being the case you will want to check out putting the name of your script at the end of . This file is executed during startup (make sure your file is owned by and in group {} and marked as executable {}), is given with a full path name if not in the directory and, to ensure it is run as a shell script, ensure the first line starts with and to ensure it runs in the background and the system continues to boot after running it if it does NOT exit straight away you must do something like using the backgrounding option on the end of that line in the file. That last bit is important as the system will wait for your script to finish before continuing - which will make it impossible to log in normally otherwise! 

Here is a simple voltage divider circuit that should meet your requirements - note that the upper resistor will be sinking nearly half a watt when the input is 24V so should be 0.5W rating - 0.6W is a common rating for some manufacturers so should be easy to source... This will draw over 2 milliamps with a 24V input voltage if that is important for the circuit under test. 

This is not really the answer you are looking for but the Compute Modules do have native dual RPi camera support. However one of the connectors has a full four data channel path and the other only two, but I guess the RPi cameras only use a pair {that does lead to a little bit of speculation as to whether that four channel one could be split so that two cameras could be run on that port for a total of three cameras overall, but I do not have any evidence to support that.} The Foundation site has this page "Attaching a Raspberry Pi Camera Module to the Compute Module IO Board", which might give further insight... 

An expansion on Steve's comment on OP This is the pinout of the Pi3's GPIO, it's oriented so that if you have the USB and ethernet ports at the bottom, the top right pin (5v, pin 02) will be at the top-right of the Pi. 

The motherboard switch pins don't require huge amounts of voltage or current, as jet mentioned in the comments you should be fine with any of them. I'd go with either of the PiFaces as they'd have the best documentation for hooking up and programming. If you don't want to tie up a relay board, you would still be fine with some transistors and a breadboard, but it's up to you. 

I'm considering making a Pi cluster (Let's say 8 Pi 3s), and instead of buying an 8-port USB charger and 8 USB cables of exactly the right length, could I use a powerful enough (8A?) 5V wall wart and then hookup wires to plug it directly into the 5V header on the GPIO on each of them. Would this be safe electrically and not damaging to the Pis, and if not would there be a method to make it so? Or is it best to do it the 'normal' way? Thanks 

The Raspberry Pi only has USB host ports, and Android has a client port that can also be used like a host port through OTG. Therefore the Pi can't be connected to the Android when the Android is an OTG host, as the Pi cannot be used as a client. The Android could be connected to the Pi as a client, but this doesn't involve OTG, just normal USB operation. Hope this is clearer than my previous answer. 

I'd go for idea 2, using an Arduino for the ADC and something fast on the Pi (maybe C if you don't mind getting your hands dirty) to do the processing, and communicate between the two using serial (there are a few blog posts/instructables on how to hook up an Arduino to a Pi via serial). IIRC it's just enabling some options in the boot.txt on the Pi and getting baud rate right on both of them. 

So I need to measure the temperature in my conservatory, and with all the doors shut on a summer's day it gets pretty toasty (uncomfortable for more than a few seconds). My question is what sort of temperature range would be OK to use the Pi in? 

The (that is an 'el' BTW) flag is used to tell the linker the name of the library to link with (and an flag would tell it where to find it if it is not in the usual place. All three of those libraries , and which is what the linker will be looking for, are (on my Raspbian "Jessie" RPi) found in the directory and are part of the package. This does seem to be available for Wheezy (indeed it seems essential for usage of some parts of the RPi hardware) so my best guess is that you need to get included in the commands used to run the linker...! 

It can be yours, Gov. for the princely sum of around £164 + V.A.T. from Farnell for a one off CM3 and the Development Kit (they have several hundred in stock as of the time of writing), provided you are a UK company. As a private person, Farnell will probably direct you to their consumer arm C.P.C. who have a few for £125 + V.A.T. at present. I note that CPC do have the original CM + Dev Kit for (£59 + V.A.T.) and you should be able to drop the CM3 (possibly not the Lite one as that needs an external flash like normal RPi units - although it is possible that a new, common Dev PWB is now offered which takes any of the CM/CM3/CM3Lite types) for £22 + V.A.T. currently into the set up and save a bit more. YMMV, prices can change, other suppliers may be available etc... 

This is so that you can login via a serial connection, but will interfere with what you want. Disable it by editing the file as root or via and put a comment character at the start of that line. As for the second part, when you say you are sending 48,or 49 I take it you mean that you intend to send a single ASCII character '0' {ASCII code 48 decimal} or '1' {ASCII code 49} but there is also a Line-Feed('\n') or Carriage-Return/Line-Feed pair ("\r\n") at the end of the data being sent by the Arduino in the call. The way that serial port data is handled can be "line-buffered" which means that things are not sent out or processed when read in until an End-of-Line state is detected so this is not a bad thing. However your Pi code uses