Edit: I recently read D4128: Ranges for the Standard Library: Revision 1 by Eric Niebler which proposes to overload all algorithms with Projection callables exactly as you did. Note that the very same proposal also includes Range Transform View which is an analogue to the iterator transforms I mentioned. That is, Projections and Range Transform Views coexist and serve slightly different purposes. You can read the proposal to get all the details. In short, a future C++ standard may include a feature which is very similar to your suggestion. It may even come sooner than C++17 in the shape of a TS. 

The definition of function composition. A call to your is semantically equivalent to . Calling the linked article's is semantically equivalent to . Which definition is more natural is completely up to the reader. Both are perfectly valid. Your has the nice property that it is very easy to implement with variadic templates (since the recursion uses "pop front" logic). This is actually mentioned as an alternative in the linked article. Furthermore, they argue for their definition of function composition because it follows the reading direction. E.g., is semantically equivalent to which follows the expected behaviour of first receiving data, then decoding it, and finally storing it. To get the same semantics with your definition, we would have to write . Again, this does the same thing but is arguably harder to decipher during a cursory read-through. Alas, the linked article goes through a world of trouble to get that "pop back" recursion logic to work (using Boost.Fusion). So they do as they do not because they are oblivious of variadic templates but because variadic recursion simply doesn't cut it. Here's a quote from the article: 

Besides that, the code looks fine to me. Good job! Please also consider the alternative I wrote in the first part of this post. 

Let me know in the comments if you have any further questions or need some elaboration on my comments. 

All that being said, let me review the code that you already have written. Because, like I said, it is still an interesting approach! 

To sum up, the difference in complexity is because you seek different interfaces. Both interfaces are valid and work. Which one is more natural depends on the application. Edit: Here is a code sample of your version. Note that I just use auto return type deduction (as you suggested yourself in the code comment). 

Like Kumar have already mentioned, just keep it simple and use . It is a very efficient data structure since every element is stored next to each other in contiguous memory. This gives you great cache utilization for sequential access (which is what you do in the loop). As for the ordering, right now you are doing 

A very interesting question. I can identify two main differences between your implementation (using variadic templates) and the linked article's implementation (using Boost.Fusion): 

That's definitely an interesting approach. However, I would say that this interface is trying to accomplish too much. That is, should just be responsible for calculating the average value over some range and not worry about any indirection. E.g., only provide the signature 

which is in reverse order since what you want is {Filter1, Filter2, Filter3}. You have to reverse the calls to get the correct behaviour. Also, you are overriding in every iteration 

rlc has covered all the important parts in his answer. I merely want to mention since you specifically asked for performance improvements. Memory-mapping files can give you great speed boosts. Note that unlike , the file must exist before being opened. Also, the memory-mapped file is opened in binary mode so you must alter you code accordingly. Memory-mapped files are much more low-level than your current approach. Only pursue this option if you have profiled your current code and found it to be I/O bound. 

instead? I don't have the signature of an so it is hard to know. Beside those semantic issues, the code has good overall structure. Good job! I only have comments on the details. I'm going to assume that you use C++03 in the following: 

Note that I've changed your to an InputIterator since I think this is a better choice. Any indirection should instead be handled with iterator transformation. I.e., an adapter which wraps the raw and overrides to either return the key or the value. Boost has the which does exactly that. Even more concretely, there is also the which is very similar to your class. Again, the motivation is to divide up the responsibility into separate classes so that each such class is as simple as possible. Complex tasks are then accomplished by combining these separate classes. 

Macros can be quite good at alleviating these sorts of pains; there is , for example, which works well at handling Results; if you refactored your code so that all of the important stuff was inside a function which could then return , for example, you could use on all of the fallible I/O operations. As it is, you can do things like writing a new macro to assist, and also give a more helpful message explaining where the error occurred. Here’s something more like what I would write; of course, there are various points that are subjective, and I have made some stylistic changes to be in line with what I believe to be more common standard style: 

Expressed simply: testing your own code shouldn’t have any impact on the API exposed to library users. is already ; no need to wrap it in . should be rather than in most places. Basically, you should never need to clone the after the first time when you insert it into (to “remedy” that, you could use instead if you wished; not sure if I would or not). You’re doing a lot more memory allocation than is necessary. Unwrapping is undesirable. See if you can avoid it. can be rewritten thus (note how this also makes it only one lookup rather than two, so it’s faster as well): 

One must realise that in these common tasks that people tend to assume must succeed there are actually possibilities of failure. 

Secondly, you shouldn’t be using strings for this; you should be using paths, because that’s semantically what you’re dealing with. The easiest way to get a path tends to be to take a or a generic parameter implementing and calling on it; , , , and more implement it. You can get the base name from a with ; this admittedly produces a , so if you want to display the path you’d need to convert it back towards a string with e.g. . Anyway, the point of this latter part is just that for something that is semantically a path, you should be handling it specially, as a rule; a path need not be Unicode. Think on it more. 

If you wanted to minimise allocations, you could shift the definition out of the loop and replace its assignation inside the loop with . That way it can keep using the same heap allocation time and time again. But that’s an optimisation that is not necessary for something like this. I might or might not do it, depending on what I had eaten, if anything, for morning tea. Personally I think I’d go with instead of in this particular case, but that’s completely subjective. 

(Note: at present this actually doesn’t play optimally with using for as it requires you to clone the user ID every time you call rather than only the first time a user ID is encountered. RFC PR 1769 would fix that.) is unnecessary ( is in the prelude). shouldn’t be necessary; you don’t appear to be using any unstable features (mostly just benchmarking, really). Something to bear in mind: you’re locking the entire balances table to make any changes at present. This is probably undesirable. If you were doing this seriously, you’d be using a proper database which would take care of this stuff properly. Just thought I’d mention it. 

The name should, under Rust conventions, be . The macros could be written as private methods, and I tend to think that they’d be clearer thus. I would expect them to be inlined automatically, but you could mark them also; because of inlining, there will be no performance difference to the macros. wrapping is only needed to provide indirection so that recursive data types work. thus needs it, but doesn’t. Your implementation could (and thus should) be replaced with . You check if , but then report as the error that universe size must be > 2; the clause, however, would correspond to > 1. Now, concerning the equation; for starters, should be written as —superfluous parentheses hamper reading. But there is a more significant issue at stake: the actual equation being calculated. The comment gives this equation: $$2^{floor\left(\frac{log_2 x}2\right)}$$ But the code calculates this equation: $$floor\left(2^\frac{log_2 x}2\right)$$ These give quite different results; the comment would yield only powers of two, but the latter will yield all integers, and might as well be . I feel that would be clearer as , seeing as has already been asserted. In : would normally be nicer written as . One less indentation level, and a more natural way of expressing it. In : is being called quite a few times; it feels like it should be possible to remove some of them, but I haven’t thought about it much at all.