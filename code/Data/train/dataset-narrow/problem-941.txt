The Microsoft Scripting Runtime has a with a method. It takes care of those pesky backslashes for you. 

Why on Earth are you bitwise ing these? Just add them like in the documentation every other sane developer. 

P.S. You don't use Hungarian notation anywhere except the variable. Drop the part and give that variable a more meaningful name. 

does nothing useful. It just delegates off to another static method that does exactly the same thing. 

Why is code that adds binary numbers inheriting from a UI class? There's no need for this. Separate the concerns and create a module for this code instead. 

The method is public and you've done some proper argument checking. (At least I'm going to assume that returning the base is appropriate if it's < 1. Is it?) So, that's good! However, does it really make sense to Assert on a condition that has been gracefully handled? I don't think it does. Minimally, it can cause confusion for someone coming behind you wondering "why are we asserting this in s public method when we've handled that case right there. Like I said, asserts are awesome, but try to keep them in places where there're likely to catch actual bugs. 

Update 1 | 2018-05-10 | to Sumurai8 Even though it was a TypeScript code originally, I'd like it to be reviewed as ES6 (and I keep correcting the syntactic issues to ensure the question is valid). I also indicated ES6 in both "Feedback" section and in tags. 

On contrary, the results of are the great candidates for "caching" in the object fields. That's because both DOM access and manipulation are expensive operations. 

Nano variable names are evil. What is ? An error? An exception? An event? To figure that out I need to look at a place where the function is being invoked. That's mental burden. Same applies to , , and ... If you are in VS Code or any other smart editor, it's a matter of hitting F2 and renaming it. Names and are particularly unfortunate since they are meant to be symmetric to/consistent with and . Thus, should be ! Also, I could not decipher what the prefix means in both of these variables. Just spell things out: , , , , , . 

Visual Basic Naming Rules - Office 2013 Language Reference This pattern is a bit more restrictive than need be, but I think it will certainly cover the cases laid out above. 

Has just become a possible reason for your test to fail that has nothing to do with your test. For example, if this was part of a test suite in a repo on GitHub, I couldn't run this test successfully. It's important that tests be portable and deal only with the code under test. If you really want to know exactly which item caused your test to fail, use the overload that takes a message string. 

You've extracted no less than 5 subroutines from your main routine already, why is all this looping logic mucking up your main routine anyway? Extract anther subroutine. In fact, extract subroutines everywhere. Everywhere. Stop repeating yourself. Pass parameters. Restrict your variable scope. And that's just your first routine... I ran out of time to touch on the rest of this. I'm frustrated with this code, and I don't even have to maintain it. I'm sorry if that was harsh, but this has so far to go yet that I just can't think about it anymore. 

Instead of that you could rewrite your range function as a generator function (at a "cost" of it not being an arrow function anymore): 

The test that almost precisely repeats the code under test indeed does not provide much value and is tautological. 

One thing that pops up in my mind when I see code containing repetitions of almost exact copies of structure is how can we achieve reusability? DRY principle is a very powerful thing that helps identifying and fixing code issues, until gets to the point where the other principles are abused. 

Here's what functional style might look like. Unfortunately, it requires index recalculation, and overall more verbose and complicated, even though it tries to go the ".some()" way. :) I believe it's one of those cases where imperative code keeps things simple. 

Now alarm bells start going off for me, and anytime we're talking about performance and we see a , they should be ringing inside your head. Particularly when it's buried in an statement. Full joins are expensive and slow. You should take a hard look at this subquery and figure out why you're using one here. You only need to return . I doubt you need to use a full join. Determine if an inner join is more appropriate. In your next query, I like the insert and select parts of your statements. You're spelling out exactly where you're inserting to. That's good. I'm also a fan of putting your commas in front like this. It makes it easier to comment things out if necessary. 

The syntax for specifying multi-dimensional types in C++ is messy. For example, to specify a two-dimensional , one has to write . The syntax doesn't scale. So, I wrote a handy tool that provides easy syntax for this. Any kinds of comments are welcome ^_^ (original version of the code can be found here with unit test code here) 

Binary heap construction and maintenance boil down to the two basic operations: sift up and sift down. Following are generic template implementations of the two operations. Any comments are welcome. I'm preparing for an interview, and I hope my code will appeal to the interviewer :-) 

I don't intend to faithfully follow the interface specified by the standard/draft, because it's too cumbersome. Specifically, I didn't implement some methods and modified the signature of some others. Refining memory order requirements is left to future work. 

The response format is actually arbitrary. Just think about what would be useful for a developer to know so that they can start troubleshooting in a right place. 

"Caching" an Observable is by default a singleton in Angular just like any other service (This is thanks to the way dependency injection container works in Angular). This means you don't need to have the class fields as . Make them instance fields instead: 

You may not be ready or want to jump into @jasoninvegas' state machine proposal, but you should consider it among the alternatives you have. As the very first step, I'd recommend looking at plain old extract method refactoring... 

Possible bug This seems to be a bug, but could be that I simply misunderstand the intent. The construction is strange and not idiomatic (usually, we either see or ). 

Remember, removing duplication isn't the only reason to create a method. It's also used to provide useful abstractions. In and this line of code is duplicated. 

Well, having your abstract class rely on its inheritors like that makes it pretty much useless. This should be declared like this. 

Implicit Public Member documentation So, you're off to a good start. You can correct this by explicitly declaring the Subroutine's scope. 

You're not always using in what I think of as a good way. We should only use the keyword when it's obvious what type the variable is. Consider this line. 

Your comments indicate that you're using a pseudo-code driven approach. This is good, but the last (and often overlooked) step to that approach is to remove redundant comments. 

I tried to rename things and format it differently as per my understanding of readable code. I'm still struggling with a few names as you can see, but this is just to demonstrate the ideas in actions, anyway... First, and . 

Then you don't have the nasty proliferation of the micro-level details across the code base. It's nasty because it forces us mixing the abstractions of different levels... With the function above you can rewrite the code into a one-liner, because the complexity is encapsulated somewhere else 

If you are not planning to add the function that disables "moving" of an element, you may even not need a local variable holding the reference to a : 

Some Comments Are Fine While the following comment explains both the intent AND the implementation, it is better candidate for staying the way it is. The reason is Angular developers don't have to deal with these aspects on daily basis and a bit of context may be helpful. 

I don't have much to add, other than I noticed a complete lack of error handling. I'm going to guess that this template won't work correctly if the modules aren't loaded correctly. You should take some time to identify possible failure points and handle possible runtime errors by notifying the user that there was an issue loading required files, logging relevant info off someplace, and then shutting down the template. 

That's the faithful translation. I would find out if the requirements can be adjusted to only return the records that are in error. If the valid records are of no interest to the business, then something like this becomes possible. 

Now, the view interface is your public API and subclasses , so it's completely appropriate to expose the binding list directly and have your Presenter/Controller modify the View's collections directly. 

You will not like my answer. TL;DR: I could not find a specific point where a code change would lead to performance improvement. I have, however, noticed some correctness issues. 

With this design, each method added to is always -specific and there's no confusion about it. The regular 's method can still be reused by when a new method is implemented. 

The end-to-end test was not meant to be exhaustive. Unit testing can be dome much more thoroughly here. It just was not my goal (rather, to illustrate how the things work). If I had written the code as TypeScript I still would NOT mark array as . With data structure implementations I really want the internals to be directly available for observation from test â€” I'm very firm, it's fine to have internals open this way for consumption in tests. (I'm in agreement with Mark Seemann's thoughts on structural inspection not necessarily breaking encapsulation). Nevertheless, in real production code (if at all) I would add interface and use it everywhere to access the . This is to prevent the accidental undesirable data access by the consumer.