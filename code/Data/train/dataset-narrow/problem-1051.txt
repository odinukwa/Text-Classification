BTW: , so there is no need to pass both is suggested for action that might be triggered after setting. Some made up example 

your image might have 111 KB compressed as an jpg or a png. But for image processing it needs to be decompressed. It will be loaded into memory with 8 or 16 bit for each color channel. With RGB it would be up to 48 bit per pixel and 8 bit for the alpha cannel in case of png. So 5MB would represent roughly 1.25 million pixel, or something like 1000*1250 pixel. 

Core Data is a great and powerful framework. but beware: if you shoot yourself in the foot, most likely both your legs will be gone. 2 Years ago I was working in a team where the Engineer responsible for persistency accidentally overwrote an internal method of NSManagedObject. It took him one week to find the cause and fix it by renaming his method. This line of code was probably the most expensive in the whole project. There-for another hint: prefix your custom methods. 

is used in several places, both as a integral value and a pointer value. Try to use more explicit values (especially the more type-safe for pointer values), as currently every time is involved, I have to double check whether the value represented is a pointer or not. 

Yes, it's a lot of boiler plate code inside the s, but after that its mostly done (though some of it could probably be replaced with macros if it gets too bad). Plus side: you can't really get the final usage wrong! 

Optimization Your current code is not structured well enough for the optimizer. Why? If it could reason about it perfectly, it would remove all the code (as there are no observable side effects), running in near 0ms! Declaring all possible variables and moving them to the smallest scope possible helps quite a bit. Even better: Refactor the code into functions (and maybe classes) with proper annotations! Just this alone allowed MSVC and GCC to recognize that the whole calculations aren't needed (as they don't cause side effects by themselves), so they removed them and run-time went down to ~24 microseconds on my machine. To get relevant results, we now need to fool the compiler a bit: Adding a little side effect ( in the code below) and taking the number of loops to run as a command line argument were enough for MSVC and GCC (and clang, though not ICC). Now runtime (with all calculations!) went down from ~14 seconds (original) to ~12.5 seconds (again on my machine). 

Cocoa's name conventions suggest not to use the word in method names to indicate the setting of an object's state 

and you also dont need to declare synthesize, as it is default now As properties generate setters7getters for you, the implementation could be 

that sounds valid and could be the wrapper class mentioned above. But make sure, you create the model objects with , as you want them in your context. 

honestly: this code should be replaced completely. you dont give any informations about how your MyCell and MyTextField look like, so I can just give you a general advice: Let MyTextField have a delegate it can call if a certain operation is triggered on it. ie it could call and the implementation would be similar to: 

Algorithm You could actually skip looking up the maximum element in the range. This is because it gets cancelled anyways: $$y = {{e^{x - x_{max}}} \over {\Sigma e^{x - x_{max}}}} ={ {e^x \over e^{x_{max}}} \over {{{1} \over {e^{x_{max}}}}\Sigma e^x}} = {{e^x} \over {\Sigma e^x}} $$ Also, currently the results are stored in place, i.e. the original input data will be lost. This might not always be wanted, so maybe accept an iterator to write the results to? vs. SFINAE I personally like the SFINAE approach more in this case, because it's easier to introduce another overload if needed (e.g. for iterators over associative containers) and you get immediate error reporting. That said, if the decision is final that you won't ever need another overload, works fine. iterator Well, if the container is nicely conforming to standard library guidelines, you'll be fine with using . For custom containers, this might not be the case, though - for those cases you could use instead. 

you should read the settings plist once in and save the contents as a dictionary to a property. As you are doing, it is a huge performance hit as the disk will be accessed every time a cell appears on screen during scrolling. In and you then should only work on that dictionary. Further more you could introduce a singleton-like shared object, that holds the settings and can be accessed in any class. see my example code for how to do multiple selection and keeping track of the selected contents. 

oh, and of course it means: If you change some parts of the class, check, if you can remove imports. 

So the best we could get is an increase of by (by removing elements from the front and elements from the back, though that wasn't asked). Algorithm code In code (using arrays for consistency with existing code): 

Now we can go over both and and look what the best results for removing up to elements from the front and (so ) elements from the back. 

Additionally, the list of sizes supports a operation: retrieve the size at an index. Any suggestions for improvements are welcome! mpl_types.h 

Algorithm Your algorithm uses (as you correctly stated) \$O(K^2)\$ time by calculating all possible combinations. This can be reduced to \$O(K)\$ with a bit of cleverness: As far as I understand it, the problem basically boils down to: , maximize by removing up to <= total elements. This means to maximize , one needs to find how many elements to remove from each "end" of the array, because as you correctly deduced, only those matter. Now we can step from one end up to elements in, and for each step calculate the change in if we were to remove elements up to this point. If it's the best result so far, we note it for the current position, else we note the previous better result (after all, we always can take less elements away). We do this for both ends. Then we can add the noted values for taking elements from the front and elements from the back together (so up to elements total), and find the maximum for this value. This value is the highest increase possible for . Adding this value to the previously calculated original value of gives us then the maximum value for . Step by step Let's take your example: . Let be the map . 

I just had a look into Stephen G. Kochan's book in amazon. he is also sticking to the naming conventions, see page 96 program 6.2. as setter, as getter. Although he is not using properties in this example, he most likely will also explain and use them later in the book. 

Now to your code. I dont see any reason to overwrite the setter. if apple says that you most likely will never be able to write as performant accessors as the provide, they probably are right. Instead you should create your own method, that will set up a object as need. you could overwrite and similar methods, or access it via a wrapper class, that will set it up for you. 

An old trick is to cast a pointer to an array of bytes to an pointer of a struct (POD) with the exact memory layout of the final message(s). 

Empty destructors The only empty destructor I'm worried about is . does acquire some resources (e.g. SDL handles), but never cleans them up properly. OTOH, the destructor of does some unnecessary stuff (could as well be empty). Comments Ideally, the best code is so clear in its naming and design that it doesn't need any comments. In practice, sometimes comments might be needed to explain why (not how!) something is done. In your current code, it feels like you wanted to label certain code sections to clarify what they do, there's a language feature for that: functions! Collision handling Other than the bug(s) mentioned above, it seems to be fine (regarding logic). Design While your current design works, there are some concerns: Many classes have multiple responsibilities. Ideally, every class has only one responsibility, i.e. only one reason to be changed. I don't feel like any of the classes in your current design adhere to this philosophy (only candidates are and maybe ). If I had to design this game, I'd probably use the following (public) interfaces: