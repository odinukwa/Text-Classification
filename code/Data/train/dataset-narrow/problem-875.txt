Normalised the results are 18.7, 11.6, 6.6, and 4.2. You can see how the efficiency increases as you change the code. And on Chrome 11.7, 6.5, 5.0,and 3.0. I am surprised this ran faster on Chrome as it has been a poor performer compared to firefox also the variance (error bars) on Chrome are only 1/3rd of FF. Thus functionally identical with a few minor modifications in layout you can get major performance benefits. The 4 functions as tested. Not a runnable snippet 

Buggy as. Unusable I made a single change and then could not get it to work (turned out I added an extra space) Bugs Any spaces in the wrong spot, and deviations from the simplified equation, any fractions and more will cause the code to throw a variety of errors. Expectation When you create a function people that use it have idiomatic expectations. You must attempt to conform at least to common variations on these expectations, and or ensure that your code does not throw errors if the input is not as expected. One would expect a equation solver to be robust and handle all the standard input variations, like be 

Unless you have very familiar with all off javascript's operator precedence dont add expressions to statements. Also if the following line becomes too long, dont remove 

Not bad but needs improvement. First I will say 9 out of 10 for style. Not that I am a particulate fan of this style but you have the number one rule of coding under your belt. Consistent style, it is the most important skill any programmer MUST master or you will forever be in the hell of a thousand typo bugs. I am a fan of the singleton style of design. This encapsulates the toDoList within a single scope. Your code is very similar as you use the event to start the process and have everything inside that function. To make it a little more portable create it as a separate object that can be added to a page as needed and not rely on the event. 

You create a new function each iteration. This means there is also a new closure created for each iteration that takes heap space, an unneeded overhead, which can be avoided by pre-defining the function (see suggested improvements below). No zero timeout V8 (and other browsers) throttle the timeout, it is never 0ms. What it is for V8 on the version of node you are using I don't know as the throttling value has gone through changes, and may well do again. So if you iterate 100 times and the timeout minimum is 1ms the timeout will add 100ms to the total time to complete the iteration. The ratio of the iteration time to the timeout time needs to be controlled. If the function takes 1ms and the timeout adds 1ms you double the time to do the function. If however the function takes 100ms to do a single iteration then the timeout adds only 1% to the time to complete. As you suggest doing the await every so many iterations will improve the ratio. But without knowing the time per iteration you can not be sure of a reasonable count. A suggested improvement. The can be improved using a object to handle the promises based on time rather than iteration count. Inside the loop you use as follows 

The is really nasty here ! One expect to only return a value but before it does some unexpected computation ! You should write it in the form of a simple getter. 

The requirement doesn't state what's the behaviour when there are no cans, so I assumed it is nothing. If you know what the requirement is in this case, I'll update my answer accordingly. Looking at your current method, I think the requirement is not reached. First you erase the old amount of tokens with then you refill the vending machine with 50 cans when it is empty, which looks really strange and induces an unexpected side-effect (see Principle of least astonishment for details). The requirement also states that you should be able to only retrieve one can at time (and not many). Here is how I would implement 

At the moment there is an method. However since you should add cans and not set cans, you should rather take as an argument the number of cans you should add: 

Bill What does a need in order to compute a price ? A base charge and a distance. These two values must be provided in the bill constructor. The bill doesn't have to know about the . Then, the implementation becomes (note that I have made this class immutable): 

This kind of requirement is the kind of which clutters the code with at least one and is in general irrelevant. If you are okay to have a number in the filename (going from 1 to n), then why not having 0 ? After all, the requirement behind that is that no filename should be erased by another with the same name. So the real problem to resolve here is how to make sure this method won't create 2 files with the same name ? Since you stated 

Class is open to modification should be closed for modification, this is the OCP principle. If it's not, its behaviour can be altered (by inheritance for example) and can lead to an unpredictable behaviour which make it rather difficult to test and maintain. How to achieve that ? Mark . Executor never shutdowned Once started, the executor can never get shutdown, which causes the task to be run indefinitly. How to achieve that ? Create a method: 

There's still a bit of duplication between the but I think you get the idea. The goal is to avoid duplication in order to have tests that are easy to understand and maintain (clean tests are as important as clean production code). 

Simpler solution. This solution assumes you are not using any libraries that manage listeners (but then you would not need it). To solve the problem execute the following at the start of your code. 

Each group of three can easily be replaced with one. The click functions can use the click event to get the needed information from the DOM, and the result functions can be passed an object that contain the sound, message and element to display the message. 

But the repetition of annoyed me Access properties via getters and setters If you need to change the properties it is better to use getters and setters, though only as example, you can include some vetting on the setters 

Note. Direct element reference via the global object is part of the W3 HTML5 standard and is supported by all browsers. Many believe it is non standard, eg Quote by RoToRa "It's not standardized" in comments below. As with all variable declarations care must be taken to ensure uniqueness of the name across the scope of the document and javascript context. 

Well!! First off I will say that is an impressive amount of work for a sort, lots of research and references. BUT!!! I am not going to sugar coat the rest. The implementation is overly complex and very inefficient, the testing touched none of the edge cases or expected failure states, and the overall design and layout of the code is chaotic and difficult to follow. Your concerns 

2nd line, address? its a url or more apt a relative path to the image resource 1st line store it in a cache? Can't find any cache, but looking at the code I found the object which you could call a cache, and download no you are not downloading in the classical sense of the word. Maybe the following more clearly describes what the function does. 

The javascript Always start your code with "use strict" it helps you avoid some very common bugs and bad coding styles and runs your code significantly faster. 

...as it is much clearer what the intent is. Use quotes not apostrophes To avoid confusion with template string declarations delimited by Back Quote try to avoid using Apostrophes (AKA single quite) Don't duplicate variables The object creates the object and assign the property the value of the argument . This is just a duplication as the only place you use is in the function it is available as the argument Design You are on the correct path to using JavaScript to create private (protected) and public states. Though there is no need to create the objects as you can use the function scope to hold the private state, including functions Simple example of a object with both public and private states, using getters and setters to protect type ( as a ), and access to private state from private and public scopes (eg function 'show') 

Generates extern declarations for a darray type containing elements of , named , with functions prefixed . E.g. declares containing with functions like . 

I like to use a single global PRNG in my c programs (similar to Javascript's ) because it simplifies things and the unpredictable nature of a global is quite fitting for a PRNG. I recently started using multithreading more so I adapted my global PRNG by making it atomic. Besides the obvious, it is meant to be atomic in such a way that two threads requesting a pseudo-random number simultaneously won't get the same number in the sequence of pseudo-random numbers. Using a CAS-loop seems to be the only way of accomplishing this, if there is a better way do let me know. Primarily I'm looking for confirmation that it actually is atomic. Note that isn't the same as , the latter is a typedef of . Admittedly not the best naming ever. The real magic happens in but the whole thing is pretty small so I've included all of it. It can also be found on github. 

Generates actual definitions for a darray type containing elements of , named , with functions prefixed . The first argument should be either or , which will define all generated functions as either or . darray usage: A darray type as generated by the above macros represents a dynamically sized array containing elements of any one data type. Each darray type comes with a multi-purpose interface allowing it to be used as one of several data structures, such as a stack, a queue, a binary-searchable list, or all of the above at once. The individual functions are documented through comments. darray performance: Where relevant, darray functions perform bounds checking, which may incur a small (but likely negligible) performance overhead. The different usage patterns supported by darray (stack, queue, regular array, etc...) are balanced in such a way that each of them performs as close to optimally as possible without slowing down the others, minimizing the performance cost of versatility. Big O performance is about what one would expect for an array-based data structure, with length/get/set/pop/clear/ditch being , push and dequeue being amortized , insert/remove being , binary search being , and sort being or . darray returns: Many darray functions are documented as returning -1 despite returning (unsigned), which will actually wrap around to . It is safe to detect these returns by checking for equality with -1 or , but checking for less than 0 obviously will not work. EDIT: The -1 return has since been replaced by a constant so this is no longer relevant. The code samples are left unchanged to preserve the question. Several darray functions are documented as returning zero on failure, which simply means an all zero value of the contained type. For a numerical type this means the value 0, for a pointer type, or for a more complex struct type (all bytes set to 0). Getter functions which return zero on OOB or if empty do so merely as a safety feature (avoiding SEGFAULT or returning garbage data), using these to check for errors or OOB is strongly discouraged as this practice will break when zero values are stored in the darray. darray.h (Bear with the highlighting, StackExchange doesn't handle macros too well.) 

This is the kind of test I would write (I picked a convention for the names, you can choose another since it stays coherent). Given the previous refactors, the test implementations are more expressive now: 

Meter I think this class totally useless since you only wrap an (for nothing ?) Don't you think it's a bit redundant to write instead of ? I would remove it. CarType As Tunaki said, I won't couple the distance into the , this has nothing to do with a . Don't you have the feeling when you compare , and that there's a lot of redundancy ? From my point of view, it's screaming for an enum since the only difference between all of that is the value of . I would refactor all of that into the following: 

Update: taking into account This is how I would fully replace a boolean into a business class. It looks like overkill but in reality it's not. Each class has a single responsibility, is testable and maintainable. is now abstract because the "blocking" behaviour can't be defined here but only in suclasses. 

Using LocalDateTime Since Java 8, there's a new API to use when you are using dates. I refactored the code to use this new API instead of the old one. 

The method could event be marked so anyone reading this code knows that this method doesn't have a side-effect on an object attribute. 

TaxiMeterApp This class also doesn't need to depend on , the only useful information is the amount of the base charge. One now takes as a parameter since the distance is obviously not known when starting the taxi meter (the base charge is, however). I also removed the App from the class name because I think it has no value and only bring visual noise. 

Final solution All these remarks put together, I came up with the following solution. Note that is an inner class because it doesn't have to be known in the outside world. 

The hardcoded string for the path The fact that you directly depends on , making the method hard to test 

Extracting UI calls Finally the UI calls must stay in the UI-part, namely into the JavaFX controller. Typically it could looks like this (simplified): 

Exceptions are (badly) swallowed is closed but not opened in this method. This could be a major flaw because it induces a nasty side-effect. It is a general idiom that the one who opens a resource is the one who closes it. is declared in the , no need to close it manually ! (it will be done automatically)