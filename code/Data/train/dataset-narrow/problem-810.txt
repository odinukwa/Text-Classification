Why the ? It's completely unnecessary. There's no reason to have the code if in an block here, because you have an early-return. 

And not even at any conventions, but at what does and doesn't make sense. You have a inside the ...that's fishy, really fishy. The great thing about Razor, MVC and C# is that you don't need to do that. I can see why you're doing it, but we're going to remove the from that and rename it to . 

About the only huge, performance-impacting change I can see that would be necessary is replacing the for a literal array. This actually has a huge speed impact. So, making that change, and inverting the related conditions causes us to have the following method: 

This is code that's part of a library (closed source) that I have that generates a unique value for Twitter OAuth. Essentially, it generates a random number, combines it in string form with an string separated by a pipe, computes a Sha-1 hash, and then repeats the process if the Sha-1 hash (when converted to Base64) contained any non-alpha-numeric characters, which are subsequently stripped. 

Whitespace is free, use it. It makes it clearer as to what steps belong together. I would personally prefer this method, as you can extract this out into LINQ-SQL style, instead of using the methods. Personally, I prefer the LINQ-SQL style rather than the methods, but the choice is up to you. 

These are all fields. In C# we don't make fields public, fields don't support events on , , etc. They don't support any sort of access control, and just allow anyone to read or write that value. This is almost always very bad. Instead, make them properties. It's really simple and easy to do: 

Let's talk about early returns and catching input validation issues for a moment. Generally, we try to return as early as possible, and throw any necessary exceptions as quickly as possible. This means we use what are called "guard clauses" to validate our input. 

Now that the lecture is over, let's look over the code quick: You have a lot of "magic numbers" here, most notably and , you should consider giving them a identifier. (Consider what and mean in each instance, and what they mean if you were to be writing a Base32 converter instead of Base64.) Your for loop () can use instead of there, just as well you should assign first, then use it instead of everywhere. I.e.: 

This eases our code greatly. Next, we'll adjust our method (and rename it at the same time, to follow conventions of Pascal Case). 

The purpose of these two classes (and hence why I am including them together) is to allow you to create a , that indicates a "render zone", and track an object in this , so that when the of the changes, the changes to reflect that. Ignore the unimplemented method, I've yet to decide what to do with it. GitHub link to this version: , , . The class: 

Be consistent. If you're using in one location, use it in the others. I used to be anti- period because I felt it made my code look less organized, but to be honest, it helps align all the variable names to the fifth textual column (counting the space), so it's easy to identify where something is declared. (Of course, with the highlighting Visual Studio does it's not necessary, and F12 is a wonderful tool, but it's still helpful at times.) It also allows you to ignore what type it is when declaring. I'd have to type out in one of those two places on that line (though one can argue that with intellisense when you type it automatically suggests to finish it) so I don't mind changing the manual typing from to , personally I type faster that way anyway. 

I don't notice anything glaring about your document manipulation, other than one concern about this: 

There's no telling what those numbers ( and ) mean and why we're looking at to determine if that's what they are. Create a constant that represents them and compare against that. 

There are people who say comments are "unnecessary" and you should never have them â€” I disagree and this is the perfect example of why you should have them. Your comment here tells me what I need to know: why you chose this method of . That's it, that's exactly what I needed. Now, all the good information aside, there are a couple things that could use improvement, and many of them are 'nit-picky', but if they're corrected then this code goes from very good to amazing: 

First, C# member naming rules indicate that should always be used; second, we talked about the properties thing already; third, the value is the default for types. .NET languages have mandatory default constructors on objects that initialize all fields/properties to their default value, for any numeric type (, , , ) that's , for it's , etc. 

It doesn't matter what you do with this code, the can always be accessed in the . As a test, here's what you should do: Launch your application outside of Visual Studio. Take a new instance of Visual Studio and go to 'Debug' -> 'Attach to Process...' and then locate the process for your programme. Once you have done this, run your programme until the SQL point, then hit the 'Pause debugging' button in Visual Studio. Once you have done this, go to the Diagnostic Tools and take a memory snapshot. While it's paused you can view the memory dump of the snapshot. You should see a record appear in the 'Memory Usage' tab of the diagnostic tools, click the 'Objects (Diff)' link. 

The interesting thing here is we may get an increase in performance by making this array mutable, but at least it shortens our method prototype: 

This really isn't great, and unless you're supporting a legacy system that already expects these enum members, I would rename the while thing: 

This code is for dispatching and handling certain events from GitHub (and also Bitbucket). Things like pushes, issues, etc. can be handled by this system, and strongly-typed objects will be returned. I left the XML docs out of all these, as somewhere from 2/3 to 3/4 of the files were XML docs. (We all know how much I love my XML docs.) The first file here is the which is what handles the event dispatching. This is a common interface between the GitHub and Bitbucket dispatchers. On GitHub: . 

This eliminates the portion and brings some of your code back to the right of your IDE. This is not counter-intuitive as it is considered part of . From the moment you have determined that is not a null or empty string, it is considered valid throughout the rest of the method. Thus, the entire method does not need shifted to make room for this one validation.