So I've been kind of irritated with my logging recently as I find myself copying and pasting the same kinds of generic messages around to lots of different methods or retyping them ever so slightly differently (when they ought to be identical). Hence, I created this kind of framework: 

I wrote this script to backup some important files. It backs up the files to a local folder as well as to an external hard drive. It creates a new subdirectory which has its name constructed with the current date and time. Works perfectly, but I'm just wondering if there are any Python best-practices I'm missing or if there's any way I could've made it better! 

These methods make no sense if you think about them logically. Your client code will pass in a that it already has, in order to invoke on it? Why wouldn't that code just do it itself? Here's how getters and setters work: 

Name your variables more descriptively. Never copy-and-paste logic; if you find yourself doing so, make a new method or analyze why you're repeating it. Don't pass around components if you don't have to (like es). In general, Swing components are global variables. Follow appropriate code formatting. (Proper tabs, indentation, spaces between brackets, etc.) Don't create unnecessary variables (i.e., ) Perform validations and error handling while doing dangerous things like downcasting. 

Have descriptive, intuitive variable names. (Example: what is ? No clue.) You have a of a . It looks like the your custom class is much like a key-value pair in a . I think it would simplify your code a lot if you just went ahead and used instead of jumping through needless hoops. Be more consistent in your naming conventions. You have some variables which are named in (which is the accepted way to do it in Java), and then you have some which have the elements separated by underscores (). The capitalized/underscore format is good for constants (like your ), but that's it. It's good that you're trying to comment your code, but some of your comments are overkill and unnecessary. Because you chose good names for your methods, the code is self-documenting in some places, which is a good thing! So the following comments are pretty much useless, as they say exactly what the method names express: 

The algorithm itself looks solid, and your code looks good! I just wanted to provide some general style tips for Java. First, why are you performing the core of your logic in the constructor? That's highly irregular for Java. A constructor in general should only perform processing to initialize values unique to each instance of the class. It would be much more object-oriented to either move all that code directly into your method or into a different method. Having a instance doesn't even make sense here. Second (and much less importantly), you are breaking with several Java style conventions. I'm assuming you come from a Python background, because your code "feels" very Pythonic. That's not a bad thing, but they're two very different languages. Python attempts to always be short and to the point, while Java emphasizes verbosity and long, descriptive names for things. As such, here are a few tips to make your code more Java-esque (if you care): 

These are all very odd variable names. In general, are constants (). The beginning underscore is also a paradigm that isn't really Java-esque (and to my knowledge in other languages it is generally used for -like fields). public static int glGenBuffers() { Your method names are also oddly named for Java. In general, Java method names should be actions and verb phrases. (For example, ) 

I'm very wary of having any method named outside of classes which implement the interface. This isn't something you'd know about as a beginner, but basically has a very specific connotation which regards using multiple threads. I might rename this method to or something of the sort. It looks like you have a lot of functionality tacked on that is just needless overhead. For example, you have a method which only has one line of code: . There's no need for you to have a wrapper method here. The name of your variable and the method you invoke from it state what you're doing very succinctly. Because you've chosen your variable names well, the code is somewhat self-documenting. Over-architecting your solution can be as big of a problem as having all of your code just slapped in the method. (This comment applies to a chunk of your methods below ). If you're going to have big block comments over every method, consider formatting them with JavaDoc. It's never too early to learn how to properly document your code. 

It's okay if you don't know what all this does. Basically it's just checking to make sure that the returned by is actually an before trying to downcast it. If it's not, if will throw an . I might've rewritten this method like the following, but in my production environment I really dislike using and this kind of downcasting. (In general, it creates "code smell".) 

Notice that I immediately check for in the first line. Because logical operators "short-circuit" in Java, if , the condition will never even be evaluated since the will evaluate to regardless. Next, notice that I store whether or not to trim the associated characters in a variable right off the bat. This prevents me from constantly having to examine and break up the passed in , which not only makes my code slightly more efficient but, more importantly, makes it vastly more readable. Finally, the throwing Exceptions bit at the end might be a bit more advanced than your level, but there's nothing like a taste of the fun stuff you'll get to do to keep you interested. :) At first I simply had the last line as , since every ending branch must return something. But because the code should never reach that line anyway (since I have an exhaustive list of all possibilities in my if/else-if blocks), I thought it was better to throw an Exception (i.e., raise an error the program) in case it ever happened for some reason, since it means something fundamentally broke. Note that I could have also just left the last block as an in order to avoid the need to do something like that, but I wanted to make the code as explicit as possible for you to read through and understand. For reference, here's how I originally wrote it: 

For a website, I've got some inline PHP, posted below. It's supposed to log traffic to the website, and it does its job fine. But at the end of the day, I'm not even close to a PHP developer, and this is really just hacked together from Googling and inferring from other, more familiar languages. How can I improve this? Is using PHP in the actual file like this bad? (This is in .) Also, I don't believe I'm open to an SQL injection attack since the variables are all drawn directly from the server rather than the user, but I could be wrong. 

Just wanted to say that this is a perfect example of the kind of method that belongs in a "utility" class. It's completely divorced from the actual game and really is just a helper method. Great. 

Not a bad start at Java! :) Below are some comments that I hope can help you improve. Some big things: 

You might wonder why I'm using an here instead of an , and how that could possibly work with the rest of the code (since I explicitly declare that I'm returning an in the method signature). Java has a handy little feature called autoboxing which lets you switch pretty much at will between the primitive data type and its associated object wrapper. In this example, an is associated with the object, so when I (where is an object), it will automatically be converted to an to the caller since that's what I've declared as the return type. Why would I bother going through all this hassle and trickery? It's a good question. The reason is that a primitive type can't be . An defaults to . I want to have something good to check for in my condition, and I can't really check against an appropriately, since anything an can hold is... well... a valid ! By doing it this way, I always know that I haven't gotten valid input by checking that one variable, rather than setting a dummy (possibly valid) value like or making another needless .