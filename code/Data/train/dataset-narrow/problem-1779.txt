Try configuring zones for your blacklists, and configure them not to forward. Something like this should work. You will need one of these for each blacklist zone. 

An FQDN is a fully qualified domain name, for a host it consists of its hostname with the domain name as a prefix (e.g. host.example.com). Usually you can use your ISP's relay server as the smarthost, but if you already have a mail server for outgoing email, it is often better to use it. This enables you to have better control of origin of email from your domain. Always use email addresses which can receive email as the sender for all your email. Using an address like noreply@example.com is acceptable for email that does not need a reply. Addresses like noreply can accept email and automatically delete them. Doing so with address that look real is not appropriate. Make sure mail addressed to postmaster goes to someone who can take appropriate actions. You may also want to do the same with abuse, webmaster, and hostmaster. This will enable other administrators to notify you of problems easily. The "Visible domain name for local users" should get rewritten to the "System mail name" when email is sent off the server, but this shouldn't matter as you should use a proper domain when generating email to be sent to the Internet. I believe this domain is used in generating the Message-Id header, so it should be a unique FQDN for each server. Consider setting up SPF records for all your domain. This will help discourage spammers from using your domain to send spam. 

Databases don't like backward steps in time, so you don't want to start with the default behavior of jumping the time. Adding the option to the command line will slew the time if the offset is less than 600 seconds (10 minutes). At maximum slew rate it will take about a day and half to adjust the clock by a minute. This is a slow but safe way to adjust the time. Before running to adjust the time, you may want start with a option like to verify how large an offset it is detecting. This will set the panic offset to 2 seconds which should be relatively safe. An alternative option I have used before this option was available was to write a loop that reset the clock back part of second every minute or so. If you check to ensure the reset won't change the second this is likely safe. If you use timestamps heavily, you may have out of sequence records. A common option is to shutdown the server long enough that there is no backward movement of the clock. or can be configured to jump the clock to the correct time at start up. This should be done before the database is started. 

You will need to export both the key and certificate from IIS. You should be able to export this into a PKCS7 file. Use to import this into your java keystore. (It is also possible to use the PKCS7 file if you wish.) If IIS is delivering the applet, you don't need a server certificate for the applet. If you are using a different server to deliver the applet you will need to import the key into that server. I expect your issue is with signing the applet. Your key may not be flagged as usable for code signing. Use a tool like or a browser to display the flags on the certificate. It is possible to have a certificate that is useful for both a server and code signing. EDIT: It appears you have a certificate that is good for both signing code. (You should sign your applet.) And it also appears to be valid for encryption (HTTTPS). If you wish to use it for HTTPS, it should have a Subject Alternate Name for every domain you wish to use it with. This will allow validation that the certificate is for the domain. Normally, you would not use a applet to as a server. It may open connections to the server from which it was loaded to look for additional classes. It could also be opening additional connections to other servers. Modern browsers will want you specify the access the applet needs so that the user can verify whether or no to grant them. 

Your IP range is public, and should not need NAT translation support. Current practice is to use public addresses only for servers in the DMZ. Many organizations have migrated their internal network onto the private ranges. The private ranges provide some security from the Internet as they are only reachable with NAT support from the firewall. They do require NAT support to reach the Internet as well. 

The above does not deal with the fact that the script could just look up the MX for the destination and bypass your mail server. This would be missing the DKIM signature, but DKIM is frequently/usually not configured correctly. As a result, I am a long way from using DKIM for email validation. DMARC helps for those domains that publish a policy but is not widely deployed. On Linux you can prevent the mail server being bypass with a firewall rule. It is possible to filter traffic based on user, so that only the mail server userid is allowed to send traffic on port 25. You may want to permit traffic on port 587 as that should require authentication. 

If you don't need to provide web service to Internet hosts, add an ACL to your Apache server similar to the above. Consider blocking incoming web requests with iptables as well. If you do need a proxy, consider using a dedicated proxy like with appropriate access controls. You could also create a separate virtual host on a different port for proxy purposes. This should have appropriate access controls. 

My usual Shorewall firewall configuration starts with the example configuration for the number of interfaces on the server (or access zones: NET, LAN, DMZ). Note that if the zones share interfaces and or routers the may be less secure than they could be. Then I adjust rules as required. I often to disable any default outbound access policies. These are replaced with rules allowing outbound access on the required ports (DNS, NTP, SMTP, etc.).