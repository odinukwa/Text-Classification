My application accepts different messages. A is described by its . MessageFormat: represents . (, , ) Message: represents an abstract Java Object for . Schema: represents an abstract Java Object for descriptor. Contains MessageFormat. SchemaFormat: represents . (, , respecively for each MessageFormat) MessageParser: has a method . There is one concrete for each MessageFormat. SchemaParser: has a method . There is one concrete for each SchemaFormat. At start-up, all of the supported schemas are loaded and parsed one time each and kept inside the memory as concrete objects. When a message comes, we pass the message with its schema to the appropriate parser. It would be optimal to also have each appropriate parser instance inside memory (schema - parser, one-to-one). What is the best way to achieve this? My current layout is to have a switching the static parsers by asking a for the reference at the static parser that is inside that factory (as well as all of the parsers, for schemas and for messages, all are static). Strategy: 

That way I can just completely delete the and the classes. If they are present, however, each Parser in lazy-initialized and as soon as it's initialized, it's kept in the memory for the rest of the time. If I have all of the Parsers inside the enum then for each message an object gets declared and then discarded. But what happens with the performance when the application obtains 150 messages of 5 different types within a short period of time? I'm concerned that it would be really slow and the memory will bloat until the garbage collector comes and cleans it. I also don't have the way to load the schemas at the start-up, so I may choose the option with putting the s inside the just for the reason I will parse them once. But several data providers may choose the XML schemas, so, I that case I will instantiate the XML parser twice but that isn't a big deal, because there will not be more than 10 data providers. 

Result: msgJson is now: {"Metrics":{"agentId":"12230","callsPerDay":"15"}} Now, I'll explain the classes briefly (too much code to fit here): Serialized: Has a private field, sets in the constructor, there is a getter. Deserialized Serializable: just an empty interface. Should I implement Serializable? I don't really know much about it, just seems appropriate. Schema Deserialized: represents an abstract Java Object for any kind of . Has a getter for FormatMessage value. Message Deserialized: represents an abstract Java Object for any kind of . Has a toJSONString() method. Parser: empty. Because for a message I need 2 parameters, for schema one. ParserMessage Parser: has a method ParserSchema Parser: has a method Format: empty FormatMessage Format FormatSchema Format For each FormatMessage value, there is a concrete class for Message and ParserMessage. For each FormatSchema value, there is a concrete class for Schema and ParserSchema. Obviously, ParserSchema returns its corresponding Schema and the same with messages. Now, the main part: Deserializer: has 2 methods: and . For both he accepts a Format (for message in a form of schema). Inside those two methods this class uses a by calling methods named and . Inside those methods, there is a call to a ParserFactory which holds all the concrete Parser static instances and gives away references to them by by the given Format on the appropriate . The problem is that I'm afraid that the Deserializer class abstracts everything too much that I have to cast a lot, even the caller has to cast a little. My team accepted this design, but I just want to make sure :) UPD: The code for and the as requested. 

Data storage If you change your typedef to be anything other than , your linked list implementation has to be copied and modified to handle multiple types (so it's less generic); on the other hand, you get better type safety. The tradeoff is probably in how you're going to use it. One thought: I would suggest looking at how the linux kernel does linked lists: they have a struct, which is then included inside the data types that you want to put into a list. So it looks something like (e.g., if you had a linked list of strings): 

Improved version of original program To start with, I just applied some polish to the original program, maintaining the approach and spirit of the algorithm while tidying up the code. Starting immediately after the line: 

you can then just print that list to print the (filtered) row. Note that you could also do this filtering yourself, using a list comprehension; however, has the twin advantages of being common (hence readable) and carefully optimized (hence fast). 

Producing sample output on STDOUT, according to a command-line "count" parameter (this is not nice code, it's just here for reproducibility). Obviously, the performance of the filtering algorithm will depend not only on the number of sets, but also on the number of possible different names from which the sets are drawn, and the size of the sets. Smaller numbers of names make some approaches pathological; larger sets create more work for most approaches. Original program Your original program did not run as-is---it seemed to rely on a few parameters provided elsewhere, and a particular directory structure. So I modified it a little to accept a filename as its first argument, and output to STDOUT for easy testing. I also moved around the manipulation of the variable, as that seemed to either have the wrong indentation or be in the wrong place. 

(for erate character), but that's open to debate. Redundant s The statements in don't hurt, but they are dead code, so they take up mental space. I would be inclined to drop them---and to align the from the default case with the others, to emphasise that all of the cases return directly. No from main I know that the C standard allows it, but it will still always look wrong to me. Depending on the context for this program, other people might look at the source and have mental space occupied by the sense that the lack of a from looks wrong. But that is essentially entirely a matter of opinion, and arguably I'm the one that's wrong there. As I said though, overall it's really rather pleasant. 

the macros and get expanded to the filename of the containing C file, and the line in that file at which the macro appears; then you can pass them through to the function, which could then log something like: 

Bug: Check in is always true is a statically-allocated array. It will never be a null pointer, so this condition will always be true (high compiler warning levels should catch this). Usability issue: There are lots of platforms which are not windows or linux; exploding on those platforms because you can't work out what the path separator should be seems excessive. I would suggest wrapping that whole block in something like ; that way, you can define the macro using a compiler flag, and you don't have to care that you can't auto-detect this. If you were going to do that, I'd also suggest renaming to , as it has a kind of global scope (it's also a clearer name). Portability issue: only works on windows Strictly, I think that backslashes appearing in paths is undefined behaviour in some C standards. It certainly doesn't work right on Linux. On most platforms, should work if the file exists. If you were feeling really fussy about portability, you might also want to make it possible to get reasonable behaviour on systems which: