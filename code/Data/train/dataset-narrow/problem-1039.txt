I’m having trouble following this code. You have classes and that look like they should be polymorphic versions of an abstract policy because they have the same and functions which are declared . But they are not derived from anything. Then, you have a template which as far as I can tell doesn’t do anything at all. It derives from one of the above classes, but then adds no functionality or members at all. So why? Then you have PolyInterface which holds pointers to push and pop functions, with free functions to populate with the push/pop from the original Policy classes. That’s what the base class would have done automatically. I think what you want is: 

(that is the default for output streams, but you can also make it print “true”/“false” if you set that formatting option) Prefer using over 

The idiom of using unqualified non-member forms for etc. is preferred (ref 1,ref 2), and will make your code work with templates. (and make all code look the same rather than writing it one way if not using templates and another way in a template) Code often evolves by taking what you did once as a plain function and generalizing it somehow; or, the type of something in a large project is changed and you have to hunt down all uses and fix things, so the same techniques used when you don’t really know the exact type in the first place will help you here too! Anyway, here is your starting point, a pointer to the beginning of the whole string as the start of the first token. Now you loop, finding the delimiter beyond this position, make that the End, extract what’s between, then update the start to resume where the End was on this iteration. 

This is rather long, so I’m posting a new answer rather than making it a P.S. on the first note about visitors. 

Many years ago, long before Boost existed, I implemented reference counted pointers (as did a lot of people, I’m sure). Since the compiler did not have partial specializations it was basically impossible to make and automatically produce different classes (the version lacking the read-write forms of access and having different implementations for some of the functions). So I did the obvious and made two different named types — and . Nobody was bothered by this, even years later when it would have been possible to write a partial specialization instead of two classes. (It was also natural to have more than one flavor of non-constness by having separate names — shared reference vs copy-on-write). Also, compilers did not allow for template member functions, so it was not possible to write a templated constructor that implicitly converts. I used two work arounds which you can find on the linked page. 

is silly. It is meaningless to change that without changing the existing values. Now if you had a function to change the internal representation to the chosen form, that would be better. Having , is not a normal thing for a simple numeric class like this. You would normally just form a new complex number, not change one of the parts of an existing value. E.g. to get the complex conjugate of , write Force{'C', z.r1, -z.r2}; but now you see another issue; there is no way to ensure that I’m in C format to begin with nor a way to transform it into C mode. If we had accessors like , , , then those would return the desired value whether stored or computed. E.g. if I had a polar value, would calculate it from the polar information it has; if it was a Cartesian value, it just returns the first stored number. I suggest modeling your complex numbers on the standard class, linked in the previous paragraph. 

Again, that’s odd… why do you explicitly cast the value to a different type before giving it to the constructor? I would expect 

and note that having the parameter with the same name as the data member is not a problem and is in fact idiomatic. If you ever need to write a lot, you are doing something wrong. In this particular case, take advantage of move semantics. In full: 

and get in the habit of using the non-member versions. These are to be called unqualified, so you need to import into your scope first (known as the "two step"). That is not needed here, but that will be needed for generic code, and also to keep your code from breaking when other parts of the program change. 

Tell your instructor to become familiar with the Standard Guidelines. You can find presentations on youtube where Stroustrup introduces this as a keynote speech, and many others speaking on them since. 

Keeping the general idea you have of find the delimiter and then extract the range before that but after the previous one found, use iterators rather than string index positions. So the starting place, rather than index , is the (or ) iterator. Your loop is structured oddly; it is not really a style loop at all so using the keyword is confusing; and you have to do the twice. Keeping the same general idea, just express it cleaner in a way you will find common in C++ STL: I’ll start with the easier case where the delimiter is a single character. So we have parameters Set things up: 

All and all, it looks like good code, well-written. You know about current features and style, and you seem to have made a through catalog of all the members and features, not just the basics. Just get rid of naked s, to do better than the common implementations! 

Another thought — if you want to avoid accidentally providing names that the derived class will inherit and step on something, you can make the accessor a free function template instead of a member function. But what about the static counter itself? It still has a name. Is there a way to put that outside but still distinct for each instantiation? There is indeed an easy way to do that. Make a variable template! 

Very interesting that you allow salesman to be initialized with a segment of a larger vector. Is that a use case you anticipate (e.g. a huge list divided up among several salesmen)? It’s enlightened but only part way to what we expect: it is limited to segments of another vector, and can’t take begin/end iterators to locations in general (anything that can be iterated). Also, you should be using the . Here is the simple/direct way to take that information in the constructor. 

You put a lot of work into writing the iterator from scratch. Use Boost.Iterator to do most of the work for you, instead. This can be a façade around the pointer type, and you change only the category (to bidirectional) and write simple and functions, and how to unbox the data from the node. All the various members and variations will be done for you automatically. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. You seem to be exploring different styles in this code; I see three different ways. 

Don’t define an empty destructor. Let the compiler supply it; it will generate better code that way. If you must, just declare it as in the class. 

Your code review Don’t write . You can, however, in a CPP file (not H file) or inside a function put individual etc. (See SF.7.) 

Piece of cake, though you have to replicate the small case clause by hand. Now, what about reading? You’ll notice that the classes reflect my earlier comments in that the deserialization is done by the constructor. It can be implemented in the same manner as the visitor. 

This identical line is present in many of the functions. Take a look via Compiler Explorer or your debug asm window: the generates a lot of code. Contrast that to the main path you want inlined, which is a simple deref and assignment. So, make a separate member, and make it not-inline. Call that from the inlined functions. Also can use compiler-specific features to mark the test as expected vs unexpected. (Microsoft's distribution of the GSL includes a macro for cross-platform) 

What is , ? That is not C++. Your top function uses exceptions for normal flow control, and is completely unnecessary. 

Just how do you write the function? We already looked at double-dispatch and are not doing that. Note that we are assigning our own type ID codes, which is a fundimental part of having a wire encoding of different packets. That’s what we need for the protocol and ultimatly how the receiver does in fact know the type. So just use that! Unlike the C++ typeid, these are a compact range of integers so a / statement is possible and very efficient. 

You defined but not a matching . Usually these things are defined as non-members taking two arguments, so handling of the two args (typically involving conversions) is symmetric. 

The member function re-allocates and copies the buffer? It also appears to leave the rhs object’s buffer unchanged, rather than switching it to the other one. That is not right, and the comments “As I am assigning…” makes me think you got your wires crossed. It is important to have a function. It should just switch the pointers just like it switched the sizes and index. 

Let me be the first to say: Don't say You use of specific numbers in the array sizes gets my attention. Then, 

A pre-allocated fixed capacity can be achieved by using an underlying collection with that behavior. 

which I don’t find as clear and succinct as it should be. You still can’t beat normal code inside a loop — maybe I need a joiner that can be declared, fed in a loop, and then have the result extracted. more iteration woes The member function needs to iterate over two vectors in step. Boost’s function crashes and burns big time when used with native C++17 features. 

It appears that this could be a range-based loop. I see you refer to eight times! And you are wondering about performance? 

Again, can your implementation do better than a linear search? Just let the user use and on your collection! 

Wow… Start with use auto (almost everywhere). You only need one object in the summation for it to work; then it will take a mixture of anything that can be implicitly converted to . So far, that gives us: 

The copy default constructor is not involved here, as this is a different constructor. You should use initializer list, not assignment to the data members (as you had in the first constructor). However, the change I suggested earlier — putting them on the data members themselves — works across all constructors. So with that in place, you do not need to initialize them here. You don’t write for access to your own members. Declare a variable when you are ready to initialize it. You almost had that here: 

comparison operators You don’t need so many forms of the comparison operators. First of all, a single template for will reverse the sense of any that you have, so don’t write all of them twice. Second, don’t write special forms for . You are discouraged from writing explicit tests against and instead use the contextual conversion to and . In fact, before C++11 you could not have special forms for this. If you have another value that is null, the general form will be used; so, it has to handle the null case. You can however provide a non-explicit constructor that converts to the smart pointer type. 

duplicated traversal code I note that both functions have the same logic to traverse the tree, in their core. Normally, like in standard containers, there will be a single function that does this, and it is used by all the other functions. If these are the only two functions you have, it’s probably not worth the effort. But if you have more (remove, find the closest match, etc.) then you should do that. 26 The first thing I noticed on your update was that you replaced the evil macro with a magic number, rather than a better way of defining a constant. 

No, they are not! You print the message, but never delete the pointers contained in the object. Or did you mean that this object is being deleted? 

Portability of character encoding It’s been noted that the letters are not necessarily contiguous in the source character set. However, if you are writing in (original) EBCDIC you have worse problems and would not be able to type the characters into the source file. (I’ve discussed C++ on a primitive type of forum software running on an EBCDIC system that was lacking and a few others, and it is not simple. The execution character set is distinct from the source character set, and depends on the locale. More generally, you can see that it depends on the source of the strings such as a saved file — if the file uses a character set that doesn’t use the same codes for letters as we expected, then things will go bad. So, part of the specification is that the input strings will always be in UTF-8, or (sufficient for our purposes) is compatible with ASCII. What about at compile-time though? The standard says that the value of a character literal is in the execution character set, not the source character set, which is good. Except that the execution character set is not known until run time, so how can it do that? However, you can specify that a character is using UTF-8, regardless of any locale or whatnot going on in the compiler or target system. 

It also lets you use a range- loop for the kind of access used in the function. However, your code to access each position in a systematic mannner (rows, cols, diag, box) is inefficient. As I pointed out in the tic-tac-toe answer recently, you can declare a linear array and multiply the rows and columns out yourself for single position access, but use single additions of a stride to navigate your pattern. (actually, the stride probably works even if you declare the array as 2D as you have it. I’m not sure that’s completely proper though) Then you can have a single predicate which takes a starting point and a stride and does the loop of nine comparisons; this one function will cover rows, columns, and diagonals, efficiently. 

edit: ( has an init-list constructor in addition to other constructors. Touted as a feature when uniform init was promoted, it actually causes headscratching in code reviews exactly as I just fell into myself!) use (almost everywhere): 

Once this function is chosen by overload resolution, then it checks that the contents of the range are conformal. So, if I mess up the definition of the structure I pass, rather than just getting “ctor not found” (due to SFINAE), I get an error more suitable to the real problem. (Aside: the is after the place where the real usage error would occur, both lexically and in program-flow. There seems to be no standard as to the order of error messages anyway. On Visual Studio, I indeed get the static assert message first (only) rather than at the end of a template spew.) results output Imagine implementing a game for real. It probably won’t use console output, but will draw icons and format fancy fonts and whatnot. So I don’t want a string output — I want the results in a usable form for handling in another function. The instance provides a of indexes into the configuration array, showing which of them matched. The config data can also be read from the object. As indicated in Free your functions, it would be good if the rendering of the output was not a member function. Instead, I make sure that a non-member can be written, and the consumer of the library can do whatever he wants with it. Supplied is a simple text string output routine, to make it complete and to illustrate how to write such a renderer for your fancy GUI screen. I really don’t like writing fresh loose code to concatenate strings together with a delimiter in between them (not before the first or after the last), so I use . But the strings are not existing in a neat list to feed it. Rather than make a temporary vector first, I use range adaptors (from Boost — Range.v3 is not quite ready for production work or Microsoft compilers) but the resulting specification gets bloated into the lambda 

I have not seen this in a while — a class-specific new/delete. But what is the point here? It just calls the global one. Since this class is exposed, users could declare things of this type in other ways. So always supply the array form of new/delete as well. And, can take a size parameter now, too.