To avoid the line being to long I put the initializer list on the next few rows (indented). This will prevent lines from getting to long. Also with more members you want to initialize one per line. 

I would not do that. It is a very inflexible format thus hard to update in the future. Also it makes debugging hard as it is not always human readable. Pick a format that is easy to parse both by humans and computers and is extensible. JSON springs to mind. 

That's no so self documenting as you think. Just spell it out. There are a couple of other conventions you need to keep in mind. 

One could even argue worse then useless as the comments over time may stray from the code (or it takes extra work to keep the comments lined up with the work). The code should explain itself (as it does: the function free_matrix() does not really need any explanation). You should use comments to explain why (or potentially how). 

Very Minor personal preference. Personally I prefer on the right of the type. The rule is that binds left unless it is on the very left hand side then it binds right. There is one obsecure corner case were this makes a difference. But it is obscure so don't worry. 

Though not technically wrong (you can define the semantics for your class). It would be nice if the behavior was the same as a normal array (and std::vector, std::array etc). Thats a very long line: 

The use of is fine. But it does have lookup. If you switch back to an array its . Its a time for space thing. Pick the one you want. I don't like the two line creation of nodes. 

You use an iterator to copy it into a vector so you can get the iterator to use in a standard algorithm. Why not just use the algorithm with the original iterator. 

This will fail if a previous library call set to . Don't like the extra indention of you r function: 

This code is not excetion safe (not all exceptions need to derive from . Just make this a local variable and all the problems of management disappear. 

It is better to use local variables and pass them as parameters to functions. Having global variables (better know as mutable global state) makes it hard to change the program from other situations (also known as tight coupling). Also don't declare multiple variables on a single line (don't be lazy, one variable per line). Declare variables close to the point where you are going to use it. Here you are declaring temporaries like a million miles from their usage point. 

The move operator should be exception safe (otherwise it does not help having a move operator when using standard containers). As a result you should mark the move constructor and move assignment as . 

I can see how it works. Does not change the fact that it is bad practice. Global mutable state makes functions harder to reason about (as other functions can mutate the state when you are not looking). Passing a value as a parameter allows you to control the state better. 

Declare them as close to the point of use as possible. This becomes important when your types have constructor/destructor (as they execute code). But it also makes the code easier to read as the type information is close to the usage of the object. Please declare one variable per line (easier to read). 

Otherwise you will screw up RVO done by the compiler and it will generate a copy rather than a move. At the call site the value returned by a function is already an r-value reference. So adding the move here does not change anything (it will still be moved). But this is not going to move the values: 

Macros don't obey scope rules and have no type information (they are simple text substitutions). Prefer to use const variables (or constexpr in C++11); 

Basically this causes calls to new for every call to . You can optimize this by allocating the temp space once in and pass the section of the temp array that recursive function can use. I know you are trying to be explicit with . But it is more traditional to use single letter for template types. Also there is no compiler validation that your iterator is random accesses (so you are giving a false sense of security to your user). C++20 should add (finally). Single letter template types will work well with this. 

You can basically remove all the getter/setter methods and put in methods that actual manipulate the object. Edit Based on Comment: 

Admittedly serialization does have certain drawbacks. Because it is not necessarily a fixed size overwriting a value in a file becomes harder. But you can get around that with a tiny amount of work. Personally I think the extra work is worth it in the long run. Normally when you write serializers for an object your overload the and operators. 

Comparison. This test to see if it is the same objext. It does not test to see if the list contain the same elements. I would expect the latter. 

You don't show it so I have to assume you are not following the "Rule of Three" (look it up). I would have done this: 

The stream already flush themselves at the most appropriate time to make themselves efficient; manually forcing a flush is more likely to cause inefficiencies. Return a non zero value to indicate failure The OS uses the return value of main to detect if the program ran correctly. 

See at @Caridorc first. Use the full power of the stream. The standard stream operators will read a word at a time for you. 

The system header files aready define FALSE/TRUE. Also in this situation you define TRUE as 1. This is not correct. The only thing you can say about is . Which is not necessarily the same as 1. 

The you must be using a pre C++11 compiler or a compiler that has a bug (or the bug in your code I pointed to above is causing you problems). 

You know what the types are so why not be specific (personally I think that will make the code easier to read). 

But this means all code is using the same cursor. This makes threaded code impossible and even single threaded code hard if you are using the list in more than one place. In C++ we end to use the concept of an iterator. The iterator is an object itself that tracks the current position in the list. Can be copied so you can save a position; incremented and decremented to move along the container; de-referenced to get the element value. It is then used in conjunction with the methods of the container for insertion/deletion. But the important point; it is a separate object. 

All operators that have an assignment version are easier to define if you define them in terms of the assignment operator. It keeps the meaning consistent. What I mean is: operator+ is easy to define in terms of operator+= 

The way your function is written it will mutate the string if it finds a partial. This may not always be necessary I would break this into two functions. One that finds the amount of mutation needed and another that does the mutation. That way another user can potentially use only the non mutating part and get better performance (say if they were passing it to a function using iterators). 

Commonly referred to as the pattern. Simple tests can sometime be replaced by the trinary operator. BUT be careful if overused or used in bad places this technique can make the code work (so be careful of using this). But in this instance I think it makes the code easier to read: 

Variable declaration Variable declaration order is important. Objects will always be constructed in the order they are declared inside the class. 

Potentially there are a couple of places where you can use range based for operator. General This seems redundant (and thus dangerous). 

But you still allowed the object to be constructed? Now you have an object in an inconsistent state and no way to detect that the object is in a bad state. You should just throw an exception at this point. Let the caller decide if it is worth continuing by catching any exceptions. 

Easiest to right after main() is entered. You don't need a switch to convert a random number to a value. You can calculate it (or with enum cast it). 

Notice a couple of things: We don't copy the string. Pass it in by const reference. We work out where in the input string the start and end are. Then we use the string method to just hack out the part we need once. There are a whole bunch of string manipulation functions in string that make this easy. OK. So I cheated and it does not do white space just space. So think of this is draft one. A tiny bit of extra effort and we can do the same thing but check for white space by using . I would also think about a version that modifies the input string: 

So that when I read the implementation of these functions I could see why it was being done this way. Still don't believe the copy and move can be done in the same assignment. Try this: 

Thus you are not getting the benefits of any registered out of memory handlers. Maybe you should just call the normal version of new so that the out of memory handlers are called for arrays as-well. 

This should modify and immediately return the changed value. Since you have modified the current value you can return the value as reference rather than generating a copy. This is the post-fix version. 

That is not all these headers have. Do I need to keep the comments up to date over time? Headers These are headers from the "C" language. You should note this is a completely different language. 

Sure. You are returning the shortest length from source to target. But would it not be more interesting to return the path most of the time. Also a graph being a vector of vector of int is a bit restrictive. You could have created a concept of a graph. Then templatized the algorithm based on the concept. Then writing a wrapper for vector of vector of int to implement the concept would have been trivial. 

When you have protected it usually means a bad design. Re-look at your code and make sure you absolutely need it. 

This is wrong in every language. You attempt to read and see if it worked. EOF is not set till you try and read past the EOF. The last succesful read will read up to (but not past the eof). So the next read will fail, but is still false. 

This should be that's so much easier to read. And if it quicker to shift that is what the compiler will actually do. Don't try and outsmart the compiler the only thing that will is happen is that you will outsmart yourself. Also its not actually 8. TO be compliant and accurate use . This is a bit inefficient.