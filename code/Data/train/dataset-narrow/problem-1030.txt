These lines seem to be based on the assumption that all numbers eventually reach 1. While this has been verified for numbers you are likely to come across, it hasn't been proven for all numbers. You might want to instead check whether you've entered a loop. Also I think it's better to explicitly return whether than relying on Python returning the last line executed by default, so you should have . And get rid of the semicolon. Also, you're repeating a lot of code. The only difference between the odd and even case is that in the former case you have and in the latter case you have . The and statements are the same. So you can simplify your code to the following: 

(Note that if an block has a return in it, you don't need to follow it with "else"; you won't get to what follows the block unless the condition was false). As for the function, you don't have to loop through every integer up to sqrt(n), you just have to loop through primes. Your and functions are rather useless. Just do and , and then use and instead of and (note that is a reserved word in many languages, so it's probably a good idea to not get in the habit of using that as a variable name). Instead of doing , you can just replace with , etc. You could rewrite your function to add neighbors according to various conditions, rather than having a separate dictionary for each case. e.g. 

Code Style As @coderodde also remarked, you should import specific classes. Wildcard imports are for throw-away code and early development; no later than when your code is approaching completeness, you should replace any then-remaining wildcard imports with specific imports. There are tools that can help you with that. Also, format your code consistently. Your indentation and placement of spaces are irregular. I find code much easier to read when there are spaces on each side of every binary operator, but if you prefer not to use such spaces then at least be consistent! I/O For what it's worth, unlike @coderodde, I have no problem with for your input. For input whose form is so simple, does not provide much advantage. Performance This is the main area of concern, and indeed I do not find it surprising that your code ... 

Stylistic issues "Indivisual" is not an English word. It seems likely that you mean "individual". Please use CamelCase with an initial capital letter for class and interface names. It makes your code much easier for others to read. Specifically, --> , and --> . Please use camelCase with an initial lowercase letter for method, field, and parameter names. In particular, --> , or, more precisely, . Class names generally should be singular nouns, for a class always describes one thing, even if that thing is an aggregate. Descriptive class and variable names are generally good form, but it is possible to go overboard. The name is considerably too long for my taste, and at the same time a bit inaccurate. I tend to read it as "absurdly long name", which defeats the purpose of descriptive naming. It would be even worse if there were other names of such length to distinguish among. For this particular case, I would certainly choose something more pithy, such as . Where descriptive comments for variables are needed, I generally prefer to see them on the preceding line, not as trailing in-line comments. The latter work for me only if they are quite short. However, do resist adding such comments at all when they add nothing to what your nice, descriptive variable names already say. It's at minimum unnecessarily verbose to compare boolean variables with boolean literals, such as in the expression . It is usually better form to just use the boolean variable either directly or subject to boolean negation: . Correctness issues is flawed. Given distinct instaces and with the same values of , and will both return -1. Just because you're comparing floating-point values does not mean that you can ignore the equality case. Performance considerations You wrap up your question by raising a series of performance considerations: 

Most of your code is just repeating the same instructions over and over again. Define arrays newStats, deltas, and statMinimums, and your entire LOSSES block can be collapsed into one line of code: However, before you try to figure out how to implement what you want, you need to clearly define what it is that you want. What exactly do you want as far as the distribution of stat changes? There are several different methods, depending on what distribution you want. For instance, if there are n stats, you can: 

Generate an array of n percentages. Calculate the average percentage. Subtract the average from each element. Do a for-loop of i from 0 to n-1 and set 

There was a previous question that I answered regarding Tic-Tac-Toe that I'm too lazy to look up, but this is a common enough subject (as you are apparently aware, there's even a tag for it) that you might want to take a look at other questions and see what applies to your program. Taking a broader look than the other answers to your question, why are you even checking for a win in the first place? If your program is running this function after every move, that's horribly wasteful. All you have to do is check whether the new move creates a win. You only have to check the lines the new move is in, and you only have to check two locations for each line (you know that wherever the current player just moved has their symbol in it, by definition). Also, any time you have , you don't need an ; if the first is satisfied you won't reach the rest anyway. 

The actual palindrome search uses an exceedingly naive -- but clear -- algorithm. For each length from 2 through the length of the string, you test each substring of that length by extracting it as a , computing its reverse, and comparing the two. Note first how many redundant reverses you are performing. You need only reverse the whole string, once, to obtain the reverses of all substrings. Note second how many redundant palindrome checks you are performing. Given any palindromic substring of length greater than 3, the string obtained by removing the first and last characters is also a palindromic substring. You don't need to find all those inner ones separately if you structure your search to find the palindromic strings centered at each position. Note also that your approach creates and discards a rather large number of temporary strings. It does this mainly because it relies on to do its comparisons. You could build a much more efficient approach by: 

General comments Your code is pretty clean, but it's unclear what you imagine it being used for, except possibly just to illustrate adjacency lists. If you're looking to build something actually useful, then I suggest coming up with a few model applications, and thinking about what you need to provide to serve those applications efficiently and easily. For example, how would you model a shortest-path problem with your graph, and how would you implement Dijkstra's algorithm to solve that problem? Or how would you compute (and represent) a minimal spanning tree? graph.h As to specifics, I'll start with your API definition, as presented in the header file: 

If the number consists solely of n nines, then the next number consists of n+1 ones. Otherwise: a) find the last non-nine digit. b) Add one to this digit. c) Replace the original digit, and all following, with this sum. 

In your first thing, you're checking each character one by one to see whether it's a decimal point. Using string functions, you can just do: 

Don't rely on users following your instruction to enter in lower case. Do . Instead of doing , check each possibility separately, and ask again if it's neither (you might want to do rather than `'wet' == conditions in case they put an extra space at the end or something). Since you're going to divide by a non-integer, you're going to end up with float anyway, so it's probably better to cast as a float to begin with, and avoid rounding if they don't enter an integer. You should also do a block to catch people entering non-numbers. 

You don't need to store the whole previous node, just the value. Also, you can replace checking whether the gap is smaller with , although it's mainly a matter of taste. And is a rather opaque variable name 

Of course there can. You already said yourself that the standard library's does not offer some of the operations you really would like to have, and therefore that you have to use a workaround. On the other hand, the standard library's PQ has to be very general; all the operations it does implement, it must implement in a generic way. Although I have every reason to expect the result is robust and efficient -- and obviously, it's already there -- it is likely that additional efficiency would be possible from an implementation tuned to your need. 

Compute an upper bound on the time required as m * max(xi). Perform a binary search over the times between zero and the upper bound to find the least time after which all the grains have been consumed. 

You can quickly compute the exact total number of grains that could be eaten over a given time span by multiplying the time separately by each consumption rate (== truncating division by seconds per grain) and adding up the results. Having such a function in hand, you can avoid simulating the entire course of the process by instead searching the space of possible times. For example: 

Maybe I'm the one who is confused, but I think you have misunderstood the phrase "unique words from x". It doesn't mean "the set of words in x that appear only once", it means "the set of words in x, with each word presented only once". So, for instance, the unique words in are . My solution: 

Since each element can be put in p1 or p2, there are two options for each element, giving a total of 2n different options. Since you are avoiding the cases where p1 or p2 are empty, it's 2n-2, which is twice the Stirling Number of the Second Kind (you're double counting since the Sterling number is based on p1 and p2 being indistinguishable). Since Big O ignores adding or subtracting constants, it's simpler to just give the complexity in terms of 2n rather than putting it in term of Sterling Numbers. And as @Peter Taylor points out, you are looking only at the number of iterations, and ignoring the complexity within an iteration. You can avoid most of the double-counting by taking combinations up to n//2. Anything past that will be just a partition you've already gotten with p1 and p2 swapped. At i == n//2, you will be double-counting, so you can use @Peter Taylor's suggestion and set aside one element and then add it back in to a fixed partition. 

You store your palindrome substrings in a , and avoid duplicates by testing whether that already each candidate you discover. This part is O(n2) in the number of palindromic substrings. You could instead do it in O(n) and without requiring an explicit check if you used a for palindrome storage, or in O(n log n) and without the explicit check if you used a . Between and , the latter also allows you to skip the subsequent sorting, but for large numbers of elements it may be cheaper to collect elements in a and afterward dump them to a and sort. 

In fact, the user must exercise some care with your class to avoid the possibility of SQL injection. In the end, this comes down to another aspect of the problem of your class relying mostly on the user to format values correctly for the database. Relying on the user == accepting the consequences of user error. Including security consequences. Literal appearance of the substitution character Your class appears to provide no mechanism to express queries in which the substitution character appears as a literal. It cannot distinguish that case from the one where that character is a placeholder for a parameter. Variation from standard prepared statement behavior JDBC and native prepared statements provide for placeholders for SQL values, appearing wherever values can appear, not for arbitrary text at arbitrary positions, as does yours. This is why they don't have the problem with literal appearances of value placeholders that your code has, but it's bigger than that. In particular, standard prepared statements do not support placeholders for SQL keywords, for table names, or for column names (and this is what allows for them to be pre-compiled). Of course, you can support placeholders in those contexts if you wish, since you're not parsing, much less pre-compiling anything, but the resulting class will feel a bit alien to users familiar with JDBC. Name of the methods The name of the methods is a bit confusing, and the variation in its overloads is very confusing. Since the method name does not itself designate what is to be set, I would expect the parameters to pick up that responsibility. Some of the overrides do, sort of, by accepting a parameter index as their first argument, but some don't. Implementation details 

What is your desired output? Your function has no return statements (other the one commented out), and the only print statement is in the block. Have you run this function? Unless I'm missing something, it won't do anything if you input 0. And when you strip out the last digit, you don't actually store it anywhere, so it's just gone. You seem to be doing double tabs for your indents, which makes it hard to read once you get several levels deep. Also, you can save yourself an indent level after the block; since you have nothing but an block after this, you can put a return at the end of the block. Then you won't ever get to the block unless the condition is false, making the redundant. So you can get rid of that and move everything in an indent level. You don't show what face_value is, so it's hard to evaluate your code when it comes to that part. Also, unless I'm misunderstanding, the block should be something like this: 

So .. you're repeatedly subtracting a number from another number, and seeing how many times you can do that without going negative? There's a word for that: division. EDIT: Since you want the actual code 

Your inconsistent and unconventional indentation makes your code harder to read than it should be. Although Java accepts multiple top-level classes in the same file as long as no more than one is public, it is poor form. Every top-level class, interface, and enum should have its own file, whether public or not. Among other things, this makes it much easier to find all the classes, both for you and for the compiler. It is a bit questionable that you're willing to destroy the list in order to test whether it's palindromic, but inasmuch as you are willing to do so, you could perform your palindrome test more efficiently. You would use two primary Node references, one that advances one position for every two that the other advances. Using the trailing reference, you would reverse the front portion of the list as you go, so that when the lead reference finds the end of the list, the trailing reference is at the midpoint, with a reference to the reversed first half already in hand. I'm sure you see how to proceed from there. You could also consider using an auxiliary data structure to build the reverse half-list or an equivalent; in particular, pushing the nodes one by one onto a stack would have a comparable effect. This could be done in a way that does not destroy the original list. Or on the third hand, if you were willing to change to a doubly-linked list, and especially if you were willing to represent the list itself with a separate data structure that contained a reference to the tail in addition to the reference to the head, then the palindrome test could be performed much more simply. You would just start at both ends and work towards the middle. That doesn't modify the list, either. 

if you're having trouble understanding , consider the case of generating the 7th number. This is going to be 4+7+13. But 13 was calculated by 13 = 2+4+7. So the 7th number is 4+7+(2+4+7) = 2*(2+4+7)-2, which is 2*(6th number) - 3rd number. So the nth number is 2*(n-1)th number - (n-4)th number. This does require handling the first few rows separately. One way is to manually create them, and then if you don't want them, you can delete them afterwards. Note that if you're deleting them, then you don't have to fill in the ratio column for those rows. You will also have to initialize to the proper value. 

Also note that if none of the words are "long", then the loop method will go into an infinite loop, while the other methods will return an error. 

If something is called "RiemannSum", then it should return a sum. If you want summation to be a separate method, a better term would be "partition"; you could do RiemannPartition.sum(), for instance. Several other variable names are bit unintuitive to me (e.g. rectangles, index). You can eliminate several lines by doing: