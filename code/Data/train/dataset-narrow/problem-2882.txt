A line is a list of connected points. For each point you'll need to calculate the X-Texture coordinate of that point, the Y coordinate will always be 0 for the upper point and 1 for the lower point. After you have defined how long one texture segment is you can do so by stepping through all the segments you have generated and noting how much distance you have covered: 

Sure you can. You can also use WAV files, they are not patent protected. The formats themselves can't be protected by patents, however algorithms used in certain formats can. For example MP3 is affected by that. But there are also other, probably better formats for that purpose: Ogg Vorbis: Open & lossy codec, very small size, comparable to MP3 FLAC: Open & lossless codec, not as small as OGG or MP3 but still a lot (~50%) smaller than the PCM data while retaining the same quality. 

Most differences are negligible. DLL's are more flexible but make the building process more complex. I would only use DLL's if: 

I have a universe: a list of "Systems", each with their own center, type and radius. A small part of such a universe could look like this: 

There is no magic filter that will make your game look good on high resolution devices, you simply need to increase the resolution of your assets. Down-scaling high resolution sprites looks considerable better than up-scaling of low resolution sprites. Edit: Fonts and pixel art are a special case because they are so small and shape that important that each single pixel is important. As a basic rule of thumb, don't ever scale bitmap fonts down and only scale up to multiples to integers using nearest neighbor filtering (e.g. only 2x, 3x, 4x, not 2.25x). You might want to create a few fixed font sizes and chose the most appropriate one for each resolution. If you really need arbitrary font sizes you'll need to use either vector fonts (.ttf extension) or use distance field rendering (probably more suited for games since faster). 

Jumping is usually just one impulse, rather than a continuous force. Many games don't allow influencing this force and just allow moving sideways. (Or not even that.) 

The length of a vector x, y is sqrt(x^2+y^2). That's basically the gist of that whole snippet. If you properly define vector operations and a "length" method for them it would look like this: 

Well no, generally not. Only thing is that changing the texture state is somewhat slow. So using less textures can make the rendering of the GUI a whole lot faster (~a few milliseconds). But it won't impact anything outside of the GUI rendering code. We are talking about really tiny amounts of memory here and also tiny amount of indices. That wouldn't even have made a impact 10 years ago. 

Searching through 5000 elements every time you add a element could already become a CPU bottleneck. You are dealing with real-time graphics here, so if it takes a few ms it's already too much. Iterating over 5000 elements is probably much less than a ms, but iterating 5000 times over up to 5000 elements quickly adds up. Say iterating over 5000 elements takes 0.02 ms, now you do that 5000 times that's already 100ms, 10 fps. For the iterating alone. I would suggest you to do the sorting only once, e.g. shortly before you are drawing them. Another option would be to just check the last or the last few sprites in the list, it's quite a simplification but still should be able to optimize most cases. Edit: Oh just noticed that you are using a std::map as data structure. It iterates over it's elements to find stuff. std::unordered_map is a alternative which makes use of hashing and can access elements in constant time. 

The difference is just in how hard it is too learn, C++ is one of the hardest practical languages out there. Lua is a purely embedded language and the API is customized by every game, it's easy to mod a game which is using Lua, but making your own game using Lua isn't. It only pays of when you have a lot content. 

A object has a position and a speed vector. Usually only the position is used to check if two objects collide, this is problematic for very fast moving objects as it can happen that the object moves so fast that it is in front of the first object in the first collision check, and behind it in the second collision check. 

If you convert or modify something it still falls under the same copyright law as the original work. So the answer is no. But don't sweat about it, there are a bunch of fonts which are actually free, for example at OpenFontLibrary and dafont.com. I am sure you will find a free font which will suit your needs. 

mini (ˈmɪnɪ) Something that is distinctively smaller than other members of its type or class. A mini game is a game that is very small. 

The advantage of using Vector/True Type Fonts over Bitmap fonts is the greater deal of flexibility inside the application: you can draw them at any size, italize them, bold them, add some fancy transformation effects, all with maximum quality. There are many many professional Vector Fonts out there, many of them have thousands of glyphs and many metadata for each, making it very profitable for dealing with displaying non-ascii strings, useful for translations. The difference in performance will only show during the font loading given you cache the glyphs correctly. (The SFML render code isn't optimized at all, the glyph loading and caching is done properly however.) FreeType has its own rasterizer and font loader and doesn't use the system ones, so quality and font formats won't be a problem. 

OpenGL just does the displaying, it doesn't do these kind of jobs for you. One way to rotate points is to calculate the angle and distance to the point around which it should be rotated, applying the rotation to the angle and then converting the angle and distance back to a coordinate with sin and cos. x and y are relative to the center of the object. 

Note that the different float-implementations on the different CPUs might behave slightly different. So to get really 100% synchronization you'll need to either write your own float type (slow, but you have float precision) or to use fixed point numbers instead (fast, easy to implement) 

Bonus: Where the magic happens. As I said the only additional axes are the movement vectors. The movement is time multiplied by speed, so in a sense they aren't just space axes, they are time-space axes. This means we can derive the time in which the collision could have happened from these two axes. For this we need to find the intersection between the two intersections on the movement axes. Before we can do this we need to normalize both ranges though, so we can actually compare them. 

Embedding scripting is never easy. Squirrel or Lua might be simpler as long you don't plan to use classes. For example you probably won't need a class for the bullets, a function SpawnBullet(x, y, angle, speed) would probably be enough. (If you need classes AngelScript takes quite a bit of work from your shoulders because it was designed to interact with C++ classes in the first case.) 

So my idea is, instead of expanding a point, why not expanding a rectangle? This results in a Hexagon. Now, so far so good. But how do I actually check if two Hexagons of this kind intersect? Note that these are very specific Hexagon's. 

There are other, more powerful factors than just "reward". In the case of competive multiplayer games such as LoL the most important one is the social component, you will likely have friends who play LoL too, and that alone will make the player much more likely to continue playing even if they are fed up with it. Another is the overcoming of challenge, and competition. You want to become better so you play more. And you want to show others how good you are. 

You can apply the transformation matrix to a point and calculate the orientation and the scale from it. This of course only works if there are no other transformations than that. 

In the case you can't listen for scan codes (like for example when developing a flash game) you can make a key binding which works for as many layouts as possible. Most keyboard layouts are very similar, with just a few exceptions. The keyboard layouts following ISO 9995 (that's most) are arranged like this: 

It seems to be a slight misunderstanding here what a engine actually is. The foundation of a game is always called a engine. Can you build a car without a engine? No. But you can build your own, you don't have to depend on any premade engine. Your engine can be a tiny 100 lines of code or it can be a big beast of hundred thousands lines of code. Either way its a engine. Building big reusable engines is something rather new, ten/fifteen years ago every engine was a very specialized one, specifically build for the one game it was used in. Building your game from scratch can teach you a lot about the implications of design decisions and I think every game developer should have gone through that process at least once for a small game. However using a already existing engine will make a game require a lot less work, and why do the work again if it was done once already? I tend to interpret the slogan "Make games, not engines" as "Make your engine as small as possible" because many programmers tend to work years on the engine for their game, implementing many things they don't really need, rather than the game itself. That way they never finish it. 

Now instead of sending over the result of onMovePlayerLeft, you just send over the fact that the "onMovePlayerLeft" was executed. Upon receiving the message you can than execute exactly the same code and both games are in the same state again. Almost all calculations are deterministic as long as they don't depend on the hardware or the OS. (Unfortunately you will have to avoid using floats as different CPUs implement floats differently.) 

No. You can't distribute anything you don't have permission for. Crediting or not makes no difference. Unless the song was distributed under a license which explicitly permits redistributing it (such as CC-By) you'll need to get permission from the copyright holder, else it will be copyright infringement and the copyright holder can sue you for it. 

This works because the nearer the spacecraft gets towards the lower the error becomes. So the calculation becomes more stable over time. The error is the difference between the calculated needed time to reach the planet (TimeNeeded) and the actual time needed to reach the planet (after taking into account the new TargetPoint). 

You could create a structure of points where you can "attach" images. Then you could set these points according to the current frame. For example a simple hero character which can have different helmets and different melee weapons and has the animations "move" and "strike", for these animations you have a sprite sheet with everything except the weapon and the helmet, now you can take these sprite sheet and a text editor and note for each frame where the helmet and the weapon is, including rotation and maybe size too. Using this data you can dynamically compose the character. Example code for better understanding: 

There is a concept called "synchronous networking", that means that all actions in the game are deterministic and thus will return the same result on all devices. If that is a given then you simply execute all actions on all devices in the same order and will end at the same state. 

If you notice any errors in the code examples let me know, I haven't implemented it yet and thus was not able to test it. 

However if for any reason you really want to modify the mesh on run time note that you can use glBufferSubData to update only a part of the buffer, as opposed to replace the whole old data with the whole new data. 

Now what would you think would a database do if you asked it to get every object less than 1000px away? It would do exactly the same! Just with a bunch of overhead which would make this one extremely simple operation cost about 100 times the processor time (depending on how many entities you have). Databases ain't no magic. Don't use databases for anything else but server applications. 

It is likely that the actual reason for it is just politics. Many experienced game developers use DirectX since ages. Thus DirectX is used. (And than OpenGL was later added by the developers that made the Mac port.) One thing however is that people that use OSX are sure to have GPU's that have properly working OpenGL implementation. This can't be said for sure for Windows PC's, due to the long time where games on Windows were primarily DirectX. This is bound to get better in the future though, with the rise of Steam for Linux and thus cross platform game development. If you want to write OpenGL code for Windows without having to worry about the OpenGL implementation of the GPU you could try ANGLE. 

You can make fewer updates on the objects depending on the distance. For example near objects could be updated every 0.1 seconds, while objects that are a bit away could be updated every second (that's a speed up of about 10x already!), and very far away objects could be updated every 10 seconds (~100x speed up). The small time steps in games are usually just so that the player doesn't notice them directly. Once you are outside of the view of the player you can simulate much more sparely and you will still get proper results. You can also approximate more, for example for the path-finding or the AI. The player won't notice. Now, if you want to save memory it gets a bit more tricky, since in that case you want to approximate the state of the object too. That means that you would need two different ways to store your object, and approximate the values you haven't saved once the player approaches them. 

Now there is also line based collision checks, in which you only check if the movement vector of each object intersects with the bounding-box of the other one. This can be seen as a expansion of a point. This only works though if the fast moving object is really small. 

Unless there is a reason not to just ship them as plain directories. Less complexity in your code and you can replace content without needing additional tools for packing and unpacking. Using PhysFS isn't wrong however, having multiple search paths is a good practice, the other features, such as reading from zip files are just a nice addition. 

You don't need to implement anything in your game for this data. Tools such as Massif Valgrind can extract all necessary data from the Debug Symbols. You can view the dumps of Massif in Massif Visualizer. 

It will give you the same result but without those divisions and conversions to float. Or if you prefer floating points over fixed numbers: 

The question is: How many degrees does the ship turn in a second? I usually approximate the effect by simply setting the rotation to the angle of the velocity, however this is not possible this time since the player is able to influence the rotation of the ship by steering. 

When I asked this question I kinda already accepted the compromise that there will be a few rare false positives with this method. But I was wrong, by checking this time intersection we can test if the collision "actually" happened and we can sort those false positives out with it: