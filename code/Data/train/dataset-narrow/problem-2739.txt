If you then get certified, maybe. If you don't even have a related degree or demonstrable work, why would the employer assume you have any skills at all? And if you do, why would they care what books you've read? With job applications, saying "I've read about X" makes no difference at best and hurts your chances at worst. 

What is a good, simple way to do this? If possible, give the answer as a method. I already have a method available, if that is helpful. 

A typical random walk is equally likely to increase or decrease the distance to any given (plus the small chance of tangential movement). I must be able to bias my random walk such that, while still random, the direction on which the sprite "decides" should be more likely to bring it closer to . The random walk should be "smooth"- the sprite should not rapidly change direction, as this will look like it's "flickering" or "trembling" to the player. It should gradually veer this way or that, moving randomly, while slowly getting closer when averaged. 

I would like to say that the errors you are getting have now changed from the first post you made, which highlights now the fact that it is becoming a service configuration problem in .NET now, and no longer an issue with trying to get DLLs working in Unity. I would strongly suggest that this question is not drawn out any more, as it deviates from the original question too much, and might confuse readers in the future. You're more than welcome to contact me directly on Skype, at coombes.jason, where I will help you further if you need. 

You're starting point is to look at the Game State Management tutorial provided by Microsoft here: $URL$ In that example, you can create and use global variables in the ScreenManager class for score etc. This would provide a simple method of persisting across the various states. 

They aren't. If your maze is a bunch of rectangular (or polygonal) prismatic rooms connected by hallways, a heightmap is quite unsuitable. This is because you give up some huge things: Rooms cannot ever be above each other for instance, because for every z-level there is only one value. The heightmap, in other words, is a function, which can have only one output for a given input, this is quite an illogical constraint (why should it be the case?). I say this especially because if you accept that assumption, your question becomes trivial. Just generate a 2D flat map as usual, generate (randomly?) a height for each room, flood fill, paint gradients in connecting hallways, done. Then, yes, perhaps a "heightmap" is appropriate as you say. An alternative way of representing is to simply keep a list of tiles which have walls. The coordinates are 3D, because you'd need a 3D grid for storing a 3D level. 

// 0.5f = min distance to check // 8f = max distance to check. Further, there wont be a selection block 

Assuming that the sample tutorial from MSDN here $URL$ works, you might want to look at this from Blender $URL$ on exporting to XNA 

The block then, is quite compact, but not defined for extremely low memory here. To do that, I needed to look even further, for example: 

"HoverText" should be in the Resources directory in the project. The gameobject itself should have a GUIText component added to it. 

If you are looking into designing the platformer, consider other parts of platformer design too, as mentioned in this blog post: $URL$ Collectibles arent necessary in platformers. They are a choice decision by the game designer, in the overall design of the platformer gameplay. 

Profile your function, figure out the slowest parts, speed them up. When deciding whether a node is passable, put the most likely situations at the top, so that most of the time the function returns right away without bothering to check the more obscure possibilities. But this is for making it faster to check a single node. You can profile to see how much time is spent on querying nodes, but sounds like your problem is that too many nodes are being checked. 

Firstly, your pastebin is hard to read. I took the liberty of doing a simple search and replace, to make it Tab-delimited instead of space: $URL$ Hope you don't mind. Don't forget to toggle off line wrap! 

You need to add fog as parameters in a gpu shader file. For example, set various parameters in your code: 

Here is a list of genres, description of possible gameplay/activities, and an example game demonstrating that genre/gameplay: 

texture becomes the output sprite, as a Texture2D. The code isnt really doing a change here to the spriteTexture. But it illustrates how the spriteTexture is rendered to a new RenderTarget. The actual change would happen just prior to the spriteBatch.Draw method call, where some effect, or modification to the spriteTexture would be done, eg, removing some pixels because of the explosion. 

This is not your problem, im guessing. You need to create a single vertex array for every block in the view frustum, and send that to your gpu shader in a draw call. The code you pasted is probably part of your generation call, which usually isnt as much of a problem as the tesselation call. Look at my Techcraft code on codeplex.com for an example of how this can be done single threaded. 

However, once you do more 3D-stuff than a sprite-based isometric game would entail, as you are, I think it would be much less trouble to do everything in 3D, unless your goal is to make a 3D engine from scratch. As for your question, hopefully it is clear to you now that what you want to do can be done, it can be done easily, and it is routinely done by just about everyone out there who does 3D as a matter of course. To sum it up: Yes, it can be done, and it's fairly straightforward, but you shouldn't do it and would save yourself a lot of needless work if you just used a 3D engine. For learning about linear algebra, you may find sources like the Khan Academy or the MIT lectures helpful. As someone who already knew linear algebra but had no idea how it applies to 3D graphics, I have found XNA and RB Whitaker's XNA tutorials very helpful and easy. They also explain using matrices for 3D like I did here, except better. 

So, we are able to make reuse of the memory allocated on that object, and still allow the gc later on to delete it. In a way, we are informing the gc that it is safe to clean up the memory footprint of that object. And for clarity, a link to explain them a bit better, with a code example: $URL$ 

If we look inside the ContentVaultServiceClient class, we can see a constructor that accepts both binding and endpointaddress parameters: 

I've been developing procedural voxel terrain engines for a few years now in XNA. In most frames, the engines are transforming literally hundreds of thousands of quads. In my profiling, i've found that frustum and occlusion culling make performance boosts. XNA HiDef profile (not Reach) has an OcclusionQuery class that is used to perform Occlusion Culling. Occlusion Culling removes those quads from a viewport that are hidden from view by other quads. Something else that you should consider is theading both the generation and tesselation separately. So yes, when you approach a very large number of quads in each frame that are being transformed, you need to think carefully at how you can apply culling and threading techniques to maintain the frame rate, by reducing the traffic to the gpu shaders. 

The compound Bezier function described above (deliberately left unvectorized to make it clear how much evaluation is needed for each call): 

What is your concern, exactly? Performance, or code beauty? With C#/XNA, a common, simple, practical solution is to have a sprite manager component, which subscribes to the main class (and thus its update/draw methods get called regularly). You can easily duplicate this code without having the actual component API. Speaking of components, occasionally the question of making every single instance a component comes up. It seems a reasonable enough idea, and it's always mentioned that you shouldn't do it, but I could never figure out why. Anyway, point is, that's an option too. 

In one of my projects, as I was starting out, I wanted to make something right away and not get bogged down with technicalities. I was using Java and ImageIcons, so when it came to loading level data, I simply drew the level in Paint at one pixel per tile and parsed that into my array. It was a hacky solution with zero thought involved, but in the end worked out quite well. Bitmaps are very easy to edit, and the different channels can work as layers easily. Most languages tend to have relatively simple methods for reading pixels as well. For complex maps with very varied tiles, it wouldn't work very well, but I don't think that is the case for you. 

It looks like your attempting a voxel based terrain game built using cubes. Forgive me if I'm wrong, but if so, you are welcome to look at TechCraft, which I coded a few years ago: $URL$ The simplest form of single threaded xna/c# based code in that project, that demonstrates procedural terrain is found here: $URL$ (set the NewTake project as startup) Incidentally, the project also includes a voxel terrain that is pregenerated, in the TechCraft project. I hope it helps in you learning about cube based voxel terrain in XNA. It uses matrices, so the code has examples of how to use them also in what you are attempting. Good luck! 

In one of my voxel engines, the voxel block explosion was done by creating a defined amount of minature blocks at the explosion point, and applying physical properties to them, eg velocity and gravity. Then, set them at random directions, and draw them. So, the actual voxel model wasnt really being disintegrated, but the voxel particles gave that impression. That is one approach. Another approach is to actually break up the voxel model. To achieve that under testing, was to detach the smaller voxels from the model, and apply the same techique for the previously mentioned explosion. No new voxels were created. In relation to pixels, I would imagine it possible, yes. An approach might be to look at using a rendertarget for the sprite, and where the texture pixel coords match the explosion points, store those coloured pixels in a dictionary, with position and colour values. Then, the rendertarget would form the source of the sprite without those pixels present. Use finally some type of custom particle manager to explode the pixels from the dictionary, using a technique similar to the explosion of the voxel model that I mention in the second part of this response. Edit: As requested in the comment, here is an example of using a rendertarget to regenerate a sprite: 

No offense, but this is like saying "I have driven a racecar that other people maintained and repaired, can I become a car mechanic?". If you want to work on engines, you should work on engines. In practice, that means make a 3D game, write your own engine, and have it do something interesting. Maybe the employer will see your unrelated programming experience and decide that you are worth hiring due to the overall skills you must have. But it seems a really bad idea to bank on that. Also, out of curiosity, if you already have a team which can release a game, why are you trying to get a job at a big company? I had gotten the impression that they're quite awful places to work at if you want to make games.