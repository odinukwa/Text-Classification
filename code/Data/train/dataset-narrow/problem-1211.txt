You only need to bind the click event once (toggle is a shortcut for binding to click and attaching two alternating event handlers). 

In response to the comments: This is very similar to the code you initially put up. I derived it again on a gist using the code you put in your question here (slightly different from the code in the fiddle): $URL$ Clone that repository to see the full history. 

Before I do anything else I feel compelled to clean up your spacing convert " to ' to consistantly use only one type of strings 

I am not sure I understand the question. What are these classes going to give me that a standard lock wouldn't? I would write that first class something like this: 

I was going to make this a comment to Dan's answer, but it started getting quite long (and I wanted to try and actually code it to see if I remembered how). Assuming is big and doesn't change between builds of the application (or if it does you have the ability to replace a single dll), you should build a dll containing the compiled regex representing it to get a much better search then you would if you used that linq expression. 

JsFiddle to show it works. Interestingly this version is also about 20% faster than the original code. (see: $URL$ 

Lock based concurrency in .NET is a fairly simple paradigm (compared to the other ways of ensuring thread safety in .NET). When you lock, you declare a block of code as a critical section, protected by that lock object. .NET ensures that a second piece of code in the same app domain will never be running in a critical section protected by the same lock object while one instance is. Here is a good resource for more threading information: $URL$ Pedantry When most people discuss thread safety they mean it in the same sense as saying strings are immutable. That is to say, as long as you don't do anything I shouldn't reasonably expect you might do it is safe. Unfortunately, locks aren't good enough to actually provide true thread safety (bulletproof against reflection and C# pointer code), they are good enough for most usages where you control the software stack out to the actual application. If you need to ensure thread safety in these instances you must ensure thread safety at the field level in your classes (stuff like the keyword will help you here, but watch out). Some example threads that would break your safety here: 

So binary search should be faster, if comparison is the main factor, for n > 4. If n is constant (its seams 64 in your case) you can even hard-code the binary search to avoid the overhead of a loop. (that is also possible for linear search.) As an example how to hard-code a binary search: [for a array with 8 entries] Code will get quite long for 64 entries, but it will be fast. If your intervallBoundary array is intervals[0..7]: 

You can also unroll the - loop, by copying the inner body 2 more times. If you can manage to change the mask_function: 

Simplified tail-recursive code: end-recursive methods are likely to be detected by the interpreter and transformed to a loop. So this code might be faster and may nor waste memory. For more information see wikipedia Tail call 

How to compare the the Algorithms: Either determine the complexity of your algorithm and the complexity of the solution in the tutorial. If you want to avoid to determine the complexity based on the source code you can simply implement the tutorial solution and compare the runtime of your algorithm and the runtime of the of the tutorial-algorithm. To get a good idea of the complexity behavior of both algorithms you need inputs of different lengths to approximate the runtime related to the size of the input. How to improve yours If your approach is very different you might not be able to improve your algorithm by looking on the tutorial-algorithm because they are too different. If the Tutorial-algorithm is better at all, you can try to understand the steps it does and try to memorize the general idea of this steps for your next algorithms that address similar problems. 

to a method passing 1330 or -25 as a parameter and reuse it instead of having nearly exactly the same code twice. 2. You can extract 

I don't like that you use to set the function. suggests that I can append a bunch of functions and they all get called when the event happens, which is not the case. would be better. It would make sense to take advantage of move semantics. The lambda that gets passed into is moved into and then copied into , when 2 moves would have been enough: 

Your solution If I wanted to do the obvious solution of squaring the array and sorting it it would look something like this: 

You get somewhat worse error messages but most likely better performance. Same goes for , it should take a variadic template argument that gets perfect forwarded into the call for efficiency. Speaking of efficiency, the flexibility of comes at a price. It is known at compile time what types can be, so should be exactly the same type without type erasure and virtual function calls. You can make that work with a style function to get the type of the function and create an with the appropriate template parameters, but you lose the ability to specify the function later. There are extra parenthesis in the call . Maybe it is a style thing, but I would write instead. Oh, and is not very C++y, but it was just an example. 

If your constructor initializes members the class initialization is treated as not existing (so no loss in performance for double-initializing), but if you forget or leave it out you get sane defaults. I would like to see and in the part of for encapsulation. If you let users access those types they will use them which I think is not intended. 

I dislike that your class mixes functionality (a mathematical vector) with memory management. A class should only do one of those. If I prefer I have to rewrite your whole class. There is actually a thing in C++ that is better than smart pointers, which is value semantics. People rarely screw up the lifetime management of an , it just works naturally. When you do tricky lifetime management try to mimic the way does it. The should be (as well as , and ). It should also work on s and not only on pointers. The standard way to add s is this: 

You need to check if each letter occurs the name number of times in both strings. One method would be to sort the letters and compare the lists of letters for equality. Here is my approach: 

If a number can not be divided by 2 it can also not be divided by any even number. So you can check2 and than only the odd numbers. you can make a list of all little prime numbers and check these and from the point where you have not the primes, try all odd numbers you can stop checking at sqrt(n) but that is quite expensive to calculate. Not so good, but still halves the work, stop at . 

calculate distance to each polygon surrounding circle and eliminate all polygons which are too far away to be a match Entity: performs a loop through all not eleminated polygons. Polygon Loop: loops through ALL vertices of the polygon in the current iteration. Vertex Loop: if the distance between the entity and the current vertex is lower than the distance between the entity and the previous vertex, save the current vertex and the ID of the polygon the vertex belongs to. Once all loops are finished, take the nearest polygon/vertex and get the vertex of the polygon to the left and right of the nearest vertex. Check the left and right vertices to see which is closest to the nearest vertex. Doing so, finds the nearest line of collision to the entity. 

And so on until you have only short methods with speaking names. This makes the code easier to read and understand. 

You can move your method to a Utils-class and pass instances of different Classes all implementing the same Interface. e.g. Based on your parallelizationEngine #3: Utils: 

You could extract the content of inner loops to methods with speaking names. E.g. You could introduce a method like 

The bigger issue here is that I am not sure if reading this stream async will get you anything. The blocking operation here is the out of process request to write the data to postgres. I am not sure a controller is ever waiting for input data. It comes down to considering what is doing for you. allows you to take an already blocking operation you do not have control over (a network request for example) and free your thread to do something else while that is waiting for a response. This means that if your application was sitting at 100 requests before async and most of those requests are spending most of their time waiting for the database to respond, you could switch to async code around those database requests and now all of that time you were sitting around waiting can instead be used to queue up more requests from the clients. 

Use instead of ; it is shorter and faster in all cases I've ever bothered to test. Don't use inline, javascript doesn't have block scope (only function scope) so it is better to declare all necessary variables at the start of your functions. Cache to make code more readable. Use toString instead of a regex test for checking for the bool type simplify loop and store the upper bound in a variable instead of computing it every time Use a check on the loop. 

is an awful variable name; that underscore adds nothing to it but makes it more annoying to type. Rename to . This: 

This implementation (whether or not you pull out the functions is irrelevant to this single use) will let you manage inheritance properly, but it does have some inefficiencies (setting radius raises the event 3 times, similar to how your implementation does). If you weren't concerned about inheritance you could simplify this by not bothering with the change event and modifying the private members outside of their own setters: 

It is a bit annoying to do all those things from the linked documentation, especially when you realize that you need to follow more links because it says "The type satisfies " which has yet another list of requirements and that one links to more requirements. On the upside once you did all of it the standard algorithms work with your iterator and you can delete a bit of code. Also algorithms from other libraries like boost tend to work when you have standard iterators. You can initialize members in the class declaration, for example 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

That way you can also leave out the constructor. I dislike the name . The return value tells me if it searched or not? I would prefer so that the return value fits to the name. Your leaks memory. It creates s with but doesn't them unless you manually call for every single item. You have 2 options here: Insert a destructor that deletes all the nodes or just make , and s, which will delete the nodes automatically. If you go the route you will have to change the implementation code a bit, because you cannot copy a (then it wouldn't be unique anymore) and instead or them. Your can be copied but the copy does the wrong thing. Instead of a copy I get 2 trees using the same nodes (because it just makes a copy of the pointer). If I change one tree the other also changes. Instead you should write your own copy constructor that deep-copies the nodes. Same goes for the assignment operator. Also your would benefit from moving, so you should add a move-constructor and move-assignment, too. prints stuff. As a user of your class I don't want that. Or at least let me specify an where you should print it to. should be a function. Right now I cannot search for a value in a , but I should be able to. In you keep the , but it is not used for anything. You could simplify that function to something like this: 

I recommend to do the in a separate method (or simply use I recommend to use instead of I recommend to return an array with the size matching the new number of entries. even if might be cheap to compute, you should avoid computing the same over and over again in the loop-condition. 

To see where the bottleneck is, you need to profile your code! Here something which may be a little improvement: replace: 

by an Enum which would add typesafety and also helps your IDE to detect e.g. if a state is not handled in your statement. 

But only profiling will tell you if / how much speed improvement that brings. Also you should always profile before trying to optimize. See were the bottleneck is. 

Why do you need a linear search [O(n)]? You can determine in which interval the value belongs by a binary search [O(log n)] (do not implement is with a recursion! use a loop or hard-code it))). Average number of comparisons for linear search is n/2. Binary search needs a constant number of comparisons of ceiling( ln(n) / ln(2) ). 

This algorithm is far from optimal runtime O(n*logn), but I have chosen it because of its simplicity. For an Efficient algorithm see the comment of @corsiKa for a quite simple O(n) algorithm. 

I think speed will only increase a bit, if at all, if you use arrays (The List implementation you use may already use an array). But you will reduce memory consumption if you switch to an array based implementation if you reduce the number of objects used this way. You should profile both implementations to compare speed and memory consumption. 

It is a matter of taste, so there is no 'better'. But more common seams to be because often the conventions of JavaBean are used. If you work in a team, I would discuss the naming conventions to use with them.