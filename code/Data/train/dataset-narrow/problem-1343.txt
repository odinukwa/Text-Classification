If you don't mind modifying the original array, you can shorten the (perfectly adequate code you have) with this: 

Drop one-time use local variables and use libraries such as PyHamcrest to improve assertion readability. Compare 

Update: Since you're storing the certificate (or not) so you can check its validity, I assumed you were checking it at a later time and ideally multiple times. If this is the case, extract the logic into a hierarchy using the Strategy pattern. If the certificate is checked once in isolation of any other data, this isn't necessary and I see no reason to store the certificate in an instance field. 

Capture the enclosing section and current next task. Do nothing if this new section should be skipped. Create a new next task that will either 

Map vs. List To your comment, since the caller is free to use sparse keys, e.g., 1, 29187, 23957172, 6832, 4772589, etc., the map (assuming it's a hash map under the hood) will give you \$O(1)\$ access for the most part. If you were to assign the keys as indices into a list in and return the new key, you could use a list instead. I don't know how Go's internal map and list are implemented, but I assume it must provide some sort of growable array class. If not, they aren't difficult to build. As a user, I would prefer to have the graph assign the keys for me. 

Broken Code There seems to be a great deal of confusion about the class. The class you posted does not compile against the class you later posted, on account of the node class not being generic whereas your sieve class contains code that assumes it is. The sieve class also does not compile against the linked version of the class (which is generic), on account of being in that version, but the sieve class attempting to modify that field. The posted Node class has similar form as the linked one, but also considerable differences -- primarily, the former has been made specific to elements of type instead of generic, but it has also been reformatted, been made , and its has been made non-. This review is based on the version you provided, assuming the aforementioned error in is fixed (which can easily be done). Naming My apologies, but your naming is overall terrible, and that makes your code much more difficult to understand than it needs to be. Field and local variable names for the most part are meaningless or simply reflect data type; few of them clearly reflect the the significance or intended use of their values. Even the meaning of the name of inner class is obscure, plus it appears to be a verb -- class names should be nouns. Some methods have obscure names, too. In addition to being unclear, the names and in particular are also non-apposite. As a pair, they should be either and or and . Code Layout I strongly recommend a more conventional layout with respect to placement of the inner class. In your code, it is placed between two methods of the main class, and that makes it harder than it needs to be to follow which method belongs to which class. If you're going to declare an inner class, then the best place for it is after all the containing class's fields and methods. Correctness The adaptations to the class make it possible to use it in a manner that is not thread safe, and it is in fact used in an unsafe manner because instances' fields being accessed and modified by different threads without synchronization. This can be rescued by making the field , but that substantially slows the program (as should be expected). Even if it were implemented in a thread-safe way, your "restriction" mechanism would still have a race condition, because your code lies. The check against the restrictions interprets the restriction values as representing the last numbers flagged as composite by each running task, but when you initially create each one, you set its value to the first composite the task intends to mark, and then queue the next task before that composite is actually marked. It is possible for threads to be scheduled such that the next task starts before the one that enqueued it actually marks the designated number as composite. Algorithmic Improvements The most work is required to sieve the smallest primes, and the most work of all is required to sieve 2. You can efficiently handle 2 as a special case by initializing all the chunks in your bit set to the bit pattern 0x5555555555555555L, thus striking out all the even numbers very efficiently, and then starting at 3 for the rest of the algorithm. This modification speeds your original code by more than 30% for me. That's in the same vein as your own suggested improvement. Yours is more comprehensive, and with the threshold for enabling the optimization set to 32, my variation on that approach cuts the elapsed time in half. The two can be combined, but using them together provides only a marginal additional improvement over yours alone, so that's probably not worth it. One important thing to glean from that, however, is that atomic operations and operations on volatile data are expensive. You can get another significant boost by getting rid of your "restrictions" and the associated Node objects altogether, along with the operations on its necessarily volatile . The objective of those is to ensure that each previous task has progressed far enough that a given one can correctly identify the next prime from the sieve. We can avoid the need for that by simply not enqueuing the next task until we are confident that it can immediately proceed. We cannot know the earliest time when that is possible, but we do know that it is possible if the current task has already processed all values up to at least the square root of the sieve size (recognizing that the current task did not start until the previous task proceeded that far, etc.). That's an easy criterion to check, and it leaves plenty of room for many concurrent tasks, because the square root of the sieve size forms a much smaller proportion of the total sieve size than 1/(# cores). That optimization cuts the runtime by about 20% relative to my variation on your optimization alone, for a total savings of about 65%. The code is much simplified, too. I have not tested this one, but I'm inclined to think that further speedup could be obtained by doing away with the altogether, and instead using an analog that relies on an ordinary array. To make that thread safe and still performant, you would implement coarse-grained locks protecting large sections of the array -- for example, blocks of elements. That could trivialize the previous optimization, and although there would be increased contention between threads, I anticipate that the replacement of millions of atomic operations with normal operations plus a (comparatively) few lock operations would be a big win. Additional Comments 

Blech! :) You could solve the problem and expose a cleaner API by providing type-specific accessors. 

This algorithm requires the values to maintain the same structure in both trees which is probably okay for this assignment (homework?). If these are binary search trees, there's at least one optimization you can make right off the bat: inside the block you don't have to check both directions. Think about how you would find the root node of the subtree in the main tree. And yes, choosing meaningful variable and function names and using consistent formatting (I fixed it) goes a long way toward keeping code readable. 

or create a configuration interface with implementations backed by raw values, an array, a object, or anything else and pass it to the service being configured. But it should definitely not accept a generic or the it produces. 

And seriously, you're not saving yourself any time by omitting vowels at random. In fact, it probably takes longer as you have to keep correcting yourself when you type . 

Notice that I chose to throw exceptions for missing sections/values or when calling the wrong method on each. You could also accept a default value for and have return an empty array when it doesn't exist. Configuration By passing the or to the class directly, you're coupling these classes unnecessarily. The should be given only the properties it needs; it shouldn't know how to grab them from a configuration object unless it's a custom object with named getters or a simple array with known keys (see next section below). The simplest form of configuring an object is passing the values to the constructor. 

Stylistic issues "Indivisual" is not an English word. It seems likely that you mean "individual". Please use CamelCase with an initial capital letter for class and interface names. It makes your code much easier for others to read. Specifically, --> , and --> . Please use camelCase with an initial lowercase letter for method, field, and parameter names. In particular, --> , or, more precisely, . Class names generally should be singular nouns, for a class always describes one thing, even if that thing is an aggregate. Descriptive class and variable names are generally good form, but it is possible to go overboard. The name is considerably too long for my taste, and at the same time a bit inaccurate. I tend to read it as "absurdly long name", which defeats the purpose of descriptive naming. It would be even worse if there were other names of such length to distinguish among. For this particular case, I would certainly choose something more pithy, such as . Where descriptive comments for variables are needed, I generally prefer to see them on the preceding line, not as trailing in-line comments. The latter work for me only if they are quite short. However, do resist adding such comments at all when they add nothing to what your nice, descriptive variable names already say. It's at minimum unnecessarily verbose to compare boolean variables with boolean literals, such as in the expression . It is usually better form to just use the boolean variable either directly or subject to boolean negation: . Correctness issues is flawed. Given distinct instaces and with the same values of , and will both return -1. Just because you're comparing floating-point values does not mean that you can ignore the equality case. Performance considerations You wrap up your question by raising a series of performance considerations: 

You can simplify your model by using , /, , and / values. The name is superfluous because the left edge's coordinate will be the same at the top and bottom in any rectangle. Even though you store the four sides in one implementation and the height and width in the other, you could still provide the full set of accessors for both. For example, 

The parser should handle the optional file validation (does it exist? is it a file? is it readable? is it well-formed?), parse the file, and return the full data array wrapped in a object to provide the remaining features. 

Is this desired? What about if the first and third intervals above butted up against each other rather than overlapping themselves? 

Contract Enforcement There are a few ways to violate the singleton contract, but none need to be guarded against. 

As Kinjal suggests, logging the error is a good alternative when failure is recoverable. However, I would throw a custom exception (or use ) and let the caller decide to log and continue or terminate. I really don't like returning success codes when I can avoid it because it muddies the code with checks. Finally, instead of setting a certificate or leaving the field blank consider modeling a certificate checking strategy. This would require a simple one-method interface with two implementations: and . Again this improves testability by providing a seam for mocking, separating concerns, etc. It also removes the need for checks and allows for more strategies and certificate types. 

Your inconsistent and unconventional indentation makes your code harder to read than it should be. Although Java accepts multiple top-level classes in the same file as long as no more than one is public, it is poor form. Every top-level class, interface, and enum should have its own file, whether public or not. Among other things, this makes it much easier to find all the classes, both for you and for the compiler. It is a bit questionable that you're willing to destroy the list in order to test whether it's palindromic, but inasmuch as you are willing to do so, you could perform your palindrome test more efficiently. You would use two primary Node references, one that advances one position for every two that the other advances. Using the trailing reference, you would reverse the front portion of the list as you go, so that when the lead reference finds the end of the list, the trailing reference is at the midpoint, with a reference to the reversed first half already in hand. I'm sure you see how to proceed from there. You could also consider using an auxiliary data structure to build the reverse half-list or an equivalent; in particular, pushing the nodes one by one onto a stack would have a comparable effect. This could be done in a way that does not destroy the original list. Or on the third hand, if you were willing to change to a doubly-linked list, and especially if you were willing to represent the list itself with a separate data structure that contained a reference to the tail in addition to the reference to the head, then the palindrome test could be performed much more simply. You would just start at both ends and work towards the middle. That doesn't modify the list, either. 

In PHP 5.0+, variables that hold objects are actually identifiers for looking up the object. Only assign using the reference operator if you truly need to bind those two variables together. Assigning normally will only copy the identifier and not the original object. Do you need a destructor that calls the parent's? I suspect that you only need to override it when you want to augment its behavior just like normal methods. However, I admit I've never needed a destructor in PHP and could be mistaken. This comes down to coding style, but I am not a big fan of leaving off braces for single-line blocks. I used to be, but once I got used to putting them on every time I became a convert. I can't count how many times I've added a second line and forgot to add the braces and wasted time trying to figure out why it was executing the second statement when the block wasn't entered. Finally, I'd add an explicit for those methods. I believe this will eventually be required for all methods (no more default) in PHP. 

Do you have to instantiate new object input/output streams every time? Depending on how expensive this is, you may want to store them in a , especially when using the byte arrays above. You are seeking twice for every operation which could have a large cost if the block containing the header is far from the head/tail of the queue. Could you tolerate writing the size of the queue less frequently or in a separate thread? Are you writing to disk for fault tolerance or because it might grow too large to fit in memory? If the latter, keep it in memory only and write it when the application terminates or every x operations. Why do you need ? Can you use as the initial offset for an empty queue? Abbreviating to is terribad! It looks like the plural form of and doesn't add any value. Pay those extra two keystrokes for clarity and call it exercise if you need an excuse. :)