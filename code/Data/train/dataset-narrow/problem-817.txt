is just a call to get as a (instead of an ). And so on... This lets you easily add a lot of logic ("Do I add this set of tags?"), doesn't require a multitude of s, and you can go back and add more things to a tag later. 

This removes the need to worry about casing, lets IntelliSense prompt you for valid values, and throwing an exception on an unexpected value ensures that you catch it during testing the moment it occurs, instead of the subtle "hey, this just keeps failing to validate" of always returning . 

I can't say that it's going to be more efficient, or better designed, but one option is to take advantage of polymorphism by creating a set of classes for this. 

You're right that all the casting is a sign that there's better way. Rather than using the value of an as the index to an array, you should use a structure that's designed to store two values in the first place. There's a couple of alternatives here. My first instinct is to use a . That most explicitly matches the concept of what you're trying to do (each has a value ), but it's not actually the best option. You're not going to be looking up the value based on the key, the order of the keys may change which could lead to hard-to-reproduce bugs, and it's less memory-efficient. Instead, I'd use a , , or (in C# 7) . They're all effectively the same thing in this case, and best convey the concept "here is a pair of related values" without implying the A->B relationship of the Dictionary. (Note that you can also use arrays instead of , like I do below). To make handle this, you would need to make it generic, so that you can pass any arbitrary type in and get that same type out. Here's what the code would look like using C# 7's ValueTuples: 

There many things here that can be improved. First off, let's tackle some best practices. Generally, doing stuff like this with isn't very good: 

Catching exceptions It's generally not a good idea to use - blocks when you aren't specifying what s you want to catch, as you've done here: 

Personally, I'd prefer the top version, but as long as you're being consistent, either style is probably okay. The code contained in the file suffers from a lack of blank lines, and whitespace in general, which makes it very hard to read. I took the liberty of adding a few blank lines, and some whitespace in there, and this was the result: 

I'm currently working on an FPS shooter game and I needed a generic movement controller that supported both keyboard and Xbox One controller input. My main goal in designing this controller was to address two common issues that occurred in previous FPS controllers I've designed, which are: 

Another possibility would be to store the words in a dictionary of nested dictionaries. The key would be a letter, and the value is another dictionary of every letter that can follow that. Repeat until you've reached the maximum depth. For the sample case, this would look like 

I find this much more readable than trying to do conversions to an Enum, and more straightforward than a decision grid. That being said, it doesn't scale as well as either option. 

As an alternative, since you already have the letters and their counts, sort the string then make the regex . 

Both methods can be made , because they don't depend on anything specific to whatever class they're in. Rather than redefining the odds each time that is called, you can create a and populate it once. This also lets you do that right next to where your enum is defined, so that when you add a new enum value, the odds are right there. If you have other properties associated with an , you may want to consider a class to consolidate them all, rather than let each place they're used keep track. 

Using for string formatting is deprecated. You should be using instead. Here's how one would use : . also supports using keyword arguments. Here's an example of that: . Near the end of the function , underneath the block with the condition , you have comments above every line. These are unnecessary and can be removed. Finally, I'm not sure why you have square brackets, , around the value of the variable . If these aren't needed, they can be removed. 

It should be relatively self-explanatory what this chunk of code is doing. It's called when an instance of is created and sets the value of each property to the corresponding argument passed. An example of creating a new instance of this class might look like this: 

If your program unexpectedly exits, or crashes, resources that are taken up by the opened file aren't freed. This can be bad in some situations. The proper way to open a file would to be using a context manager, or , like this: 

Just to build on what @svick said, this is definitely not a good way to handle things. If you want to catch all exceptions, simply . If you don't want to catch everything, then only catch the specific types you want. There's also the block which you can use to do any cleanup which is necessary, regardless of whether or not you've handled the exception. 

Everyone has had good ideas, but since you're asking about OOP, I'd suggest refactoring it altogether. 

Back when using .NET 2.0, I wrote a class which inherited from , and a which inherited from . For legacy reasons we still use it, but I'm pretty sure it could be rewritten in half the code as a few extension methods. Here's a small sample: 

This will kick off a new solver run each time the prior one displays, up to the limits of what your computer can handle. 

The function, when no arguments are specified, will remove leading and trailing whitespace. This means that a user can enter something like without worrying that the program might reject their input. In addition, you could also consider using if you want to get rid of additional characters. 

Removing duplication Rather than (again) recreating the function to run a different function each time, you can add an additional argument to the end of the function signature, . You function would then become this: 

Nitpicks You have a lot of unnecessary comments in your code. The best example I can find was probably this one: 

One blank line between the functions in . Some more blank lines in between blocks of code in the module-level, and in any function in the class. 

In general, you should never do something like this. In the case of this example, you should be catching a , like this: 

You don't provide any example of how would differ from , so I can't be more specific, but here's the gist of what you should do: 

LINQ has extension methods for any which will help with this. There's , which will return the first elements, and which will skip elements, then return the rest. Of course, these don't actually change the they're operating on - they just return a new one. But that's a safer pattern to use - it means you have the option of keeping the untrimmed version around if you need to. 

If is your slowdown, you're not going to be able to get a huge improvement, but you can get some by parallelizing all the calls to it. Replace your loops with this version: 

You'll still need to code each calculation function, but you don't need to manually attach each calculation to a specific crop or trait. You can just have a database table which tells the code "Crop + Trait = Enum value" 

Which is automatically inserted by the compiler if it isn't found. In short, can be removed. In addition, a few of your error messages don't include a newline at the end, as seen in this line here, and two other places: 

Class names should be in . Not . There should be two blank lines between each class/function/code block on the top level of your file. You have a blank line before each of your class declarations. Preferably, you should either, put a docstring here, or, remove the blank line. 

Nitpicks There is no need to convert the result of to a using the function. Rather, you can do something like this: 

This will also mean that the variables and will have the default values of and in the Unity Editor as well. In addition, in your class, you also don't need to initialize in as well. 

Heslacher is correct in that you should split this into two separate methods. That said, sometimes doing that isn't an option, so I want to point out an alternative to passing the "magic values" of and into your function. When you have a function argument that only takes a very limited number of values, you're usually better off replacing it with an . That enforces the limitation when you're writing code, and helps avoid typos and other subtle gotchas. 

Each grouping of numbers is an instance of a object, and we test if two are equal based on the items in each . 

Everything that's the same gets put into . Everything which could vary is defined as an method or property, and then the subclasses implement just those things which make it different. 

Everything in your code should either require the interface or the interface. If the former, it can accept any of the four classes. If the latter, it requires the plus four bit. Since a plus four can always be downgraded to a pure zipcode, this set of inheritance will let you pass a +4 wherever you are looking for a . Also, by always requiring the interface, rather than the concrete type, you can trivially implement the null object pattern you asked about. 

This eliminates the need to create duplicate methods for each individual type, and makes your code generally easier to read. This can also apply to your overloads with just two arguments. I wasn't quite sure how to implement them in this context, although I'm quite sure you can figure it out. Be sure to use though rather than , as may return when is expected. 

This is a pain to type more that once though, so you can extract this into a re-usable function, like this: 

There are quite a few things that can be improved here, so let's start with the obvious. Rather than having multiple individual conditional expressions to check the value of a variable, simply create a list of all possible values and use the operator to check the variable's value, like this, for example: 

Once you're using the context manager, it's guaranteed that the resources taken up by the open file will be properly freed, even if the program unexpectedly exits. 

Here's a pseudo-coded recursive function to build the query, since I'm feeling lazy and don't want to double check all the string functions. I haven't tested it for speed - it might be too slow, but I think it should work. 

I realize this isn't necessarily faster, but it will be much easier to maintain, and at least one example ought to be posted using LINQ. So here's that example, using LINQ and the Combinatorics library to do it in a single statement, and in a more object-oriented manner*: 

You could use instead of the in the second case, but I seem to remember reading that it's faster to do as an array than with LINQ. 

The first method is an all-purpose "Add"-type method which will either add it or update it depending on whether or not it exists. The second is specifically for dictionaries where the value is a . It'll let you add an element to the , creating the key if neccesary.