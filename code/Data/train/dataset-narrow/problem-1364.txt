It's a pity that there is a restriction to avoid the usage of an external resource file. This would be more flexible to read the data from elsewhere, thus separating the concrete stuff from its abstract representation in the code. And in case of a fix/update no rebuild of the application would be necessary. Ok, so let's remain on the requirement that the data should be hardcoded. Before remarks on the design choices, here are some observations about the improvement of the current code. The Private Fields Since the information wrapped in mostly prepresents constants, all the fields should be final. 

class will declare and as abstract members, typed as of respective type. The implementors will need to initialize these sequences with the order of items required by the implementor. This will allow to iterate on these collections directly on the abstract layer and make them immutable. For example, will fill the s from min to max; will fill them randomly, etc. function will acquire iterators on and sequences and iterate on their elements until the required percentage is reached. (named properly) will have a default implementation redirecting to (also named properly). It will be sufficient for and , but will need to be overriden in and , because they add their specific calculations. 

I totally agree with Vogel612's observations. Since there is a lot of code for this review, I'd like to add a couple of items. DatabaseAdapter Class In method, there are three issues, two of them are quite serious: 

However, for the should be kept, since there is no UI element that holds the value. What About Modal Dialogs? There is one important issue concerning the solution that you implemented. Often, applications need to show a modal dialog (that blocks its preceeding windows until the user gives some input). Currently, there is no way to plug the panes as modal dialogs. A solution for this issue could be found by providing the owner object through the s and calling and where appropriate. Refactor the Builders The definitions contain repetitive 

I've had a lot of occasions to face similar problems, but must admit that there is no ideal solution. It is difficult to avoid code duplications in JPA entities definitions. However, there are some things that I can recommend. Both Fasterxml and JPA annotations work on fields and on methods, which makes possible to extract common things to interfaces. For example, you have several entities that contain and fields like the one of your example. You can create interfaces to manage JSON representations of these fields, for example: 

The three classes are thus removed from the original code. I can also suggest to extract all the nested classes (, , ) to their dedicated files: this simplifies the structure, makes it easier to navigate and is simply cleaner. Update: The arguments to can be refactored with shortcut methods: 

The handling of in looks rather messy: its instantiation or retrieval could be done with just a single call of . As @SharonBenAsher already mentioned in his answer, Java 7 has a number of interesting tools to handle concurrency in a more flexible way. For this case, I'd suggest to use a write lock when the resource is retrieved and a read lock when it is served. 

They should be separated. All JavaFx-related stuff would remain in class and the model would be better described within a dedicated entity. For small applications like this one, there is probably no need to implement fully the Model-View-Controller pattern, but at least model-view separation would be beneficial, bringing more flexibility and extensibility. Don't Abuse of Generics Please look closer at these declarations: 

Put constant parts inside the pattern, leave formatters only for variables, e.g. . Args in are usually used for variables. Use a to build. 

The streams inside are not wrapped in a try-with-resources, but should be, to prevent from leaving an unclosed stream in case of exception. 

Both one-for-loop and solutions represent a naive approach: its main drawback is that for each index you need a dedicated variable like or . Since you confirm that the array can be quite large, this also means that you'll need as many variables for indices as there are items in the array. Of course, there might be more flexible solutions and I see that the first step is already in the original code, supposing that is an enumeration like this: 

Style: the prefix for the private fields violates standard Java naming conventions. There is no need to call to check if the item is already in the map. For s, there is the method that does exactly the same in one line. I'm not sure that and are necessary in . How do you expect values to be present in the collection, if method checks the object to be not null? 

The code you posted is rather huge for all-in-one review, so I suggest to make it in more than one iteration. For this first approach, let's cut more general things from details. InteractionMediator Type. It is declared as . Is it intended to be used in matchers or to be tested for equality among different instances? If not, that should not be a case class. Functions. There are really a lot of public s inside. Are they all called from outside or some of them remain callable from within the class? I think that it should be useful to reduce the visibility of some of them. Moreover, these functions do many different things and this makes me doubt that should wrap all this stuff. There are functions to validate details or templates, load them or generate other entities. It looks that a split is necessary: create an entity that will provide validation, another for loading, and yet another for other useful actions. This will be much easier to read, analyze and test. Wizard This class looks like a big mess of s, s, s and directly executed calls. Really difficult to see what is happening there. Reordering, restructuring and splitting are the first things to do about. Some ideas: 

If this is a generic implementation, my first question then is why interface is there? This interface is part of Swing API, which has it own sphere of application. The objects implementing this interface may (or may not) be convenient here; anyway, they tend to be used in Swing/GUI-related situations and I'd not interfere with their scope for a generic case. There is also something even more important concerning . As you know, it has method which returns an . This type is a very old Java thing (since JDK1.0), introduced even before Collections, and currently it looks like a rudiment. And it's not very pleasant to iterate on. But if you still need/want to keep , a type bound mark should be added, in order to avoid compilation warnings. To replace , I'd suggest to create a short and concise class, which points to a (or even a ) of children s and overrides and methods. This class would also be useful in other examples of your article. Code Blocks I understand that conciseness and lack of extra space is the priority in this code, but when I see this 

should not be caught, because it is wrapped in yet another . Is it useful? The messages in are not informative at all. The type of the wrapped exception is known anyway, so the messages should be changed or removed, to have simply . Law of Demeter Multiple calls like 

is called before crawling the files in a directory: it corresponds to the original code under condition . wraps the main logic of producing a hash for a file, under in the original code. The size of the byte buffer (2048 here) can be adjusted: try to play with different values to see whether the perfs change. 

In , the names of the attributes begin with uppercase letters (). This violates common Java field naming conventions. Database column names are usually case insensitive. Depending on the underlying DBMS, the instructions like may fail, because the searched value could have been stored under e.g. key when being read in . Either it should be normalized by applying there, or it should be checked with in constructor. Looping over the entire map in constructor is unnecessary. The fields may be initialized with e.g. and there is no need to use local variables , etc. In : var is not typed (raw type), which is not good. This variable is useless, because is an and can be directly initialized with , without casting. 

The part of this method may be extracted to the super-class. This will avoid repetitions in the concrete classes. Expressions like should be extracted to static constants. They do not need to be evaluated each time the method is called. Remove useless comments like , and others. Validation: constructor arguments are not validated. If , or args are negative? Without entering into theoretical discussion, I suppose that negative values will be invalid in the context of your API. In main(), the array would be initialized better with 

The approach with + definitions is indeed extremely hard to maintain. There is no need to create intermediate wrapper objects like , because JAXB supports annotations and the same output can be achieved by using: 

This approach with a sort of ad-hoc parser is particularly difficult to test, because of the high complexity of conditions. There is a much simpler way to implement it: regular expressions! It looks like the arg is expected to be something like "He7m2". A corresponding regular expression would be . The values in the matched groups will correspond respectively to , and . If does not match the expression, this is a good reason to throw another IAE. Invocation 

Language Issues DRY It The three functions of contain boilerplate repetitions of instructions like or . Dedicated shortcut functions can be created in order to reduce number of arguments and chained calls, for example: 

Changes of this kind will drastically separate distinct functionalities of the class and will make them more readable and easily maintainable. 

I think that the second implementation of the function is the most readable and concise. There is just the name of that should be changed. is too vague, would be more concrete. It's probably a matter of taste, but the first implementation seems to contain too much nesting (parenthesis and braces). The third implementation looks also a bit more complex than the second, mostly due to the mechanism of . By the way, I've got two suggestions that may slightly improve this code.