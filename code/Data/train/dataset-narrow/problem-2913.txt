GUI/interface related stuff should be taken care of client-side, the server doesn't need to know if you're opening a dialog screen. Send the server information that changes the game state: if your menu screen has a "delete voxel button", send a packet telling the server , not . In your example, clicking on a certain block could ask the server for information about the block (block type, position, etc...), then when that information is received, the client opens the interface, and if the player does something that changes the "game state" through the interface (for example, changing the block type, position, color, etc...) you send that action to the server, not the GUI-related action. 

But I also don't like the fact that I have to create new entities like this. I would prefer creating entities via the Field object itself. How can I make entity/component creation more elegant and less prone to bugs? 

I've asked on the DROD forums how they did it, and a user replied that it was breadth-first search. The game is open source, and I took a look at the source code, but it's C++ (I'm using C#) and I found it confusing. I don't know how to do it. Every approach I tried isn't good enough. And I believe that DROD generates global pathmaps, somehow, but I can't understand how every entity find the best individual path to other entities that move every turn. What's the trick? 

I'd like to explain this problem with a screenshot from a released game, DROD: Gunthro's Epic Blunder, by Caravel Games. 

Since many of the components (and also logic) of the entities require to know what the tile they're in is, or what the field they belong to is, I need to have mEntity.Initialize(); to know when the entity knows its own field and tile. The Initialize(); method contains a call to an event handler, so that I can do stuff like this in the factory class: 

This solution is the most basic one, and has many problems. I wrote some articles about 2D collision I advise you to read: $URL$ $URL$ 

Cache misses will be present when allocating with new, but it's not so bad. In my entity system I can create/destroy >10000 components without noticeable frame loss. It will probably never be a bottleneck, unless you require an amazingly high amount of entities/components. If you want to check my implementation, it's on GitHub. If you want to check a data-oriented component entity system, check out Artemis. 

I've decided to go with fixed 2D grids. I've made two videos which explain in-depth how I implemented them, and the current implementation is available on my GitHub page: $URL$ $URL$ $URL$ 

In my game, I currently move the player by directly setting its velocity on key press events. This makes the game feel very responsive and allows the user to quickly change direction. However, I would like to implement knockback and elements like conveyor belts that should push the player around. My first idea was to add a variable that was set to when the player was under the effect of an external force, but it didn't work well in practice. Then I thought of another way: how about adding the exact required force to move/stop the player at a desired velocity instead of acting on the velocity itself? It would allow the user to move and stop like if velocity itself was being set, but also allow external forces to act on the player. Basically I want this: 

I've tried implementing pathfinding in my clone. First attempt was making every roach find a path to a yellow guy every turn, using a breadth-first search algorithm. Obviously incredibly slow with more than a single roach, and would get exponentially slower with more than a single yellow guy. Second attempt was mas making every yellow guy generate a pathmap (still breadth-first search) every time he moved. Worked perfectly with multiple roaches and a single yellow guy, but adding more yellow guys made the game slow and unplayable. Last attempt was implementing JPS (jump point search). Every entity would individually calculate a path to its target. Fast, but with a limited number of entities. Having less than half the entities in the screenshot would make the game slow. And also, I had to get the "closest" enemy by calculating distance, not shortest path. 

From my tests it seems slightly faster than the previous approach, but it isn't a big improvement. Also, passing the same and the same () four times seems weird and unnecessarily expensive. I couldn't figure out a different solution since every sprite has its own MVP matrix, color an hue. 

Is definitely possible using C++11 variadic templates, with no performance difference from the original versions. 

to enable cheat codes. CVars are used intensively during the game - if they were set or retrieved by string name lookup there would certainly be a performance hit. Therefore, I'm assuming CVars are somehow cached. How would this kind of system be implemented? I thought about storing pointers to the real values in a map having the CVar names, and then use the real values in the game. Is this a viable approach? Do the AAA games have a better one? Example: 

If I apply the shortest penetration vector as a force during collision resolution, the dynamic AABB will get "pushed out" from the static one, but its velocity will never decrease in a simulation without gravity and it will keep moving forever. Is there a way to apply a "temporary" force? A force that deals with pushing the first AABB out of the second AABB, then stops when the AABB doesn't collide anymore? Entire source code available here: $URL$ 

This creates a new Player at [10; 5]. I'm using a factory-like class to create entities via composition. This is what the CreateEntity method looks like: 

The game is turn-based and tile-based. I'm trying to create something very similar (a clone of the game), and I've got most of the fundamentals done, but I'm having trouble implementing pathfinding. Look at the screenshot. The guys in yellow are friendly, and want to kill the roaches. Every turn, every guy in yellow pathfinds to the closest roach, and every roach pathfinds to the closest guy in yellow. By closest I mean the target with the shortest path, not a simple distance calculation. All of this without any kind of slowdown when loading the level or when passing turns. And all of the entities change position every turn. Also (not shown in screenshot), there can be doors that open and close and change the level's layout. Impressive. 

I started experimenting with OpenGL ES 2.0, and I'm trying to figure out a way to optimize/batch sprite drawing, where sprites only have the texture in common, but differ in the following properties: 

I want to give players the ability to create and share bullet patterns for a shoot'em up. The pattern scripts should have all the common programming stuff like loops, if/else, variables, and so on. But in the end, I just want them to call a "spawn bullet at X, Y with Z angle and A speed" in the C++ game. To spawn a circle of bullets, the user should only have to write a script with a for loop that goes from 0 to 360 and calls the spawn bullet function on every iteration. I tried integrating AngelScript, but I am getting nowhere - it looks way to complex for a simple task like this one. Is there an easy to integrate library that can solve my problem? Thanks. 

I've never dealt with sending/receiving data from web servers in my games, so I absolutely have no idea how to do this. I tried googling for a good solution but couldn't find anything satisfying. I currently get data from my web server by doing a HTTP request that gets the contents of a JSON text file stored on the server, and parses them in-game. I do not know how to "write" high scores to the server, and even worse I do not know how to avoid people sending what they want to the server since the game is open source. How is this usually done?