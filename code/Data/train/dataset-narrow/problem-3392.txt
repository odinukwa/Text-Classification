You can find tutorials on using this software online. There is even a blog article describing the usage together with the Pi camera module. The software also supports DSLR cameras, albeit a bit experimental. I quote the section of the documentation: 

I have bought a touch LCD from waveshare and am trying to set it up. I have changed my config.txt to enable SPI and set up the touch device: 

You may want to use PulseAudio on your Pi and your target machine. There are binaries for Windows available. Your setup would look like this: 

You need a Python library that can output MIDI (e.g. python-midi or python-rtmidi) You need a soft synth. You can use Timidity for that, which can be used as an ALSA sequencer device. 

It will also print the number of minutes until shutdown. This should be sent to all users logged into some console. 

The Pi is still a bit weak to be considered a general purpose PC, at least when comparing it to current PCs running current software. You can obviously run XBMC on it rather well, so playing movies seems to be no problem. Internet browsing is still a bit sluggish, mainly due to lacking graphics acceleration and the meager CPU and RAM of the Pi. There are also some projects for attaching compact HDMI displays to it. For example: 

Where xxxx denotes the version number (5655 as of this writing). You seem to need to have a digital command station for your model train, which will be attached via ethernet or USB to the Pi. You need to figure this one out for yourself, but the Rocrail wiki seems full with information on this. 

You need to supply more information. I suggest you hook up the Pi to a screen (via the HDMI or RCA output). I can think of two things happening in your setup: 

I don't have my Pi in reach right now, but you can do it like this: First, find out which playback devices you have. You can do this with : 

Your device seems to employ a Prism54 chip, according to the Raspberry Pi Wiki. Furthermore the Wiki says that you need a powered Hub for this device, probably because it consumes quite a bit of power. If you still want to stick with the device, the Wiki recommends to follow the instructions in the Debian Wiki. But maybe the firmware is already included in the non-free firmware package, so you might get lucky by just using the powered hub. Instead of buying a powered hub, you could also buy one of the many dongles utilizing a Realtek chip, as for example the TP-Link TL-WN725N. That one doesn't need a powered hub either, and it is rather cheap and very small. 

If you are more of a software guy (like me), and you are living in a European country, the Gembird power strips are also a way to go. They use electromechanical relays and have USB interfaces. Each strip has 6 outlets, 4 controlled via USB. You can use multiple strips via a USB hub. They can be controlled via sispmctl, which is also available as a package in Raspbian. I even started writing a simple web frontend for , but it is very primitive at the moment. 

I also had lots of page allocation failures on my Raspberry Pi Model B (256MB RAM version). The fix I am using now is to increase the value of in . 

You can fetch the original file yourself. The Raspbian package repository can be found here. The package you are looking for can be found like this: 

Since my Pi is stationary at home and uses only one WiFi network, I wrote some scripts to make it automatically reconnect upon lost WiFi connections. 

The cpu frequency is scaled on demand. You can set the threshold via the `up_threshold' sysctl variable. You can set it via: 

This will use the builtin aac encoder, which has to be enabled via the experimental switch. It may have some quirks, but so far it has worked fine for me. As long as I do not want to scale videos down to 720p, this seems to be fine and uses minimal amount of CPU. 

With these settings, my Pi has achieved an uptime of more than 20 days (after which I rebooted it manually). 

I have no clue about model trains, but a quick Google search reveals that there are multiple projects for Linux which allow you to control model trains. It seems that Rocrail is one of them, and they even have a Raspberry Pi page in their wiki. You need to fetch one of their pre built packages, and install it: 

Please run and compare the output with the above checksum, or rather the checksum corresponding to your file. It will most probably not match. Then you should re-download. You can easily use to fetch Raspbian: 

This will set the threshold to 20% CPU utilization. The scaling governor can be set to ondemand via: 

It might be useful to check the output of shairport. It's best to keep it running in or and to check the output whenever you fail to see it. I am also running shairport, and sometimes it just crashes, or goes haywire. Hence I have a cron job which restarts shairport every night, which helps. Also, it might be that the avahi daemon fails to advertise the shairport service. It might also be neccessary to restart avahi, if it fails to function. These fixes are a bit crude, but it might simply be that the programs themselves are not yet robust enough to run for a long time. 

First of all, you should be able to access your Pi via its hostname, like . Second, you should make an entry in your file for the Pi: 

This will enable X11 forwarding for the host with hostname (replace with IP if you like). It also enables compression, which is a good idea for X11. You could also specify an RSA key here for authentication, so you don't have to type a password. Edit: To actually don't have the X11 connection forwarded, but to instead use the local X server, you can do the following: First, you have to run on your Raspberry Pi (not via ssh). Second, you have to set the display variable for your remote command to you can test this by running ssh interactively: 

When using less than 64MB GPU memory on a full HD display, I was having massive problems. Running headless or with console only, I was successful in using only 16MB GPU memory. So, if you are running X11, you should leave the GPU/CPU split at the default 64MB. 

Have a look at the Joystick API of the Linux kernel. The API is really simple, you just need to open the device and read data from it. There are several ioctl parameters to query the number of axes and buttons. There is a nice, but old tutorial on the linuxgames mailing list, and all the important stuff is defined in the header. If you want to use a portable solution, that works outside of Linux, I would suggest you take a look at the SDL Joystick API. SDL works on a variety of platforms. 

You can use the program to make the program run as a daemon. The advantage is, that you can also read the output in the system logs. And you can start and stop the daemon, if you put it in a rc script. I wrote something like this for the scrobbler program. You can use my script and replace the with your program. 

If you run this program (), you should be able to point your browser to $URL$ and see the output. Update: I just tried the above script at home, and it works. Not nice, but it is a start! 

My Pi is running headless, so I can't test this, but first have a look at this page. Then try if you can set the keymap from a terminal: 

However, the modules will not be loaded upon booting. dmesg shows me an error with the systemd modules loader. This is what the service tells me: 

However the ALSA device does not seem to support both outputs at the same time. The OMX API for the Broadcom chip however does seem to support setting the audio splitter to route to both outputs . Furthermore I found out that aplay lists two devices for the Broadcom card: 

I recommend using pulseaudio for this, if you don't want to setup shairport and RAOP. The pulseaudio documentation describes how you can do this. You need to setup your debian laptop to provide a pulseaudio rtp sink. There is also a nice howto available on mpd and pulseaudio. For some first tests, you can just run these commands through on your laptop to set up an rtp sink: 

I've been using the Roland UA-1G for years, which is very high quality, but is discontinued. For the last two years, I have been using it with the Raspberry Pi without great problems. Just make sure that ALSA doesn't produce delay warnings, but there's a workaround for that. Roland has a couple of new devices, of which I guess the UA11-mk2 could be quite affordable and of high quality. Make sure to set the EXT switch to the ** setting, or ALSA will not recognize the module. 

Make sure the Pi is running pulseaudio Install PulseAudio on Windows SSH to the Pi (possibly also install a Windows X11 server) Tell the X11 clients to use the PulseAudio server on your Windows host. 

Accessing ALSA sound device is always a bit tricky. I suspect there are calls for the pcm devices of ALSA, but it is probably best to use a library. There is a very small library called tinyalsa, which already comes with an example called . This could be a good starting point for you, without the need to use the heavyweight ALSA library. SDL is also a good idea, as Frepa suggested. 

If you want do develop using gnuradio, make sure to also install and maybe also the different packages (you can search for them using ). 

The $ sounds like you might be trying to use jQuery. If this is the case, you may want to download and install it as well. Since you are on the Pi, I would also recommend trying to write your own web application using Tornado. It is written using Python (the Pi's favourite language), and I always find it very easy to create web applications using it. Just install it using 'sudo apt-get install python-tornado'. I just wrote a minimalistic tornado web-app, that you could try out (I could not test it), by taking a function from some other forum post: 

Even better than is (in my opinion) . You can install it via . Also check out the manpage with . You can start it by typing on one of your consoles (see XTL's answer). Here are the most important commands ( means: press control and B at the same time, then press D): 

This should also work with the VNC solution. The X11 solution may be faster and nicer looking, but the VNC also has its merits (most notably that you can dis- and re-connect). 

The gcc documentation explains this in detail. Basically, you can tell the compiler to forcibly use armv6: 

On top of phalt's answer, you should check out one of the dynamic DNS services, such as No IP. They allow you to access your home network under a static host name, although your IP address may change daily, due to your DSL or cable provider disconnecting you. They also have a nice getting started page, which also introduces you to setting up your router accordingly. You may want to install the package on your Raspberry Pi to update your No-IP DNS entries, when the IP changes. You can do this by running: 

I have a 3.5" ads7846 based touchscreen for my Pi from Waveshare. Is it possible to toggle the backlight and/or change the brightness? 

I have googled and tried to construct a pipeline that takes a MKV file and uses the omxh264dec as well as the omxh264enc to transcode it to mp4 format. The examples that I found do not work or are easily adaptable and the gstreamter docs are... complex. Any hints? Background to my question: I am using Plex Mediaserver on the Pi to manage my videos. I am mainly using AppleTV, iPhone and iPad to watch that media. The Apple devices easily only support h264 and aac in a mp4/m4v container. Hence I want to transcode some of the videos which do not match this. Plex can do this, but without hardware acceleration, so it's very slow. Plus I want to scale some videos down from 1080p to 720p for the iPhone and for disk space reasons. gstreamer with omx is reasonably fast and can do all these things I guess. Update: I am currently using avconv to remux mkv files to mp4, and using the builtin AAC encoder to recode AC3 tracks to AAC. This is probably the best I can do without doing actual video transcoding. An example command line: 

You can put this in your , so it will be executed during boot. You can leave out the stuff then, because is run as root anyway. More documentation on CPU clocking can be found here. 

I am using the Pi as an SMB file server. So it seems that networking may fragment the memory quite a bit. The changes are applied after a reboot. You can also apply them (temporarily) during runtime by running: 

I am using cron-apt to keep my Pi up to date. However, since a few weeks, I always get these error messages in the mail, when cron-apt runs: 

Which yields the package . It can be found under the letter in the package repository: $URL$ You can download the current version ( as of today) and inspect it after download. I use the Midnight Commander ( in a terminal) to do this. Just navigate to the deb-package and hit return in . You will see the contents then. The original file can then be found at inside of the package. You can even hit the key to copy the file out of the package. This strategy works with most packages that come with default configurations.