Effects 11 is not supported by Windows Store apps for Windows 8.0 because it requires D3DCompile APIs at runtime. Hence, 'technique11' and it's kin are deprecated. Effects 11 also has specific compiler support in the HLSL compiler, which in the latest (#47) is still there but emits a warning. Some newer DX 11.1 and DX 11.2 constructs are not supported with the legacy fx_5_0 profile. All that said, you can technically use Effects 11 in a Windows Store app for Windows 8.1 because D3DCompiler #47 is present at runtime. You can also continue to use Effects 11 for Win32 desktop apps as long as you recognize a future HLSL compiler revision is likely to remove support for the required fx_5_0 profile. See the Effects 11 CodePlex project. 

If given all that advice, you still need to use the legacy D3DX library, or if you are using XAudio 2.7 or XInput1.3 to support Windows 7 or earlier, then you can mix the use of the Windows 8.x SDK and the legacy DirectX SDK. However, the path order for doing this is reversed from previous recommendations for VS 2012 and VS 2013: 

Your problem is the difference between XMMatrixLookToLH and XMMatrixLookAtLH. The DirectX TK SimpleSample is using which is computing: 

There are different answers here depending on which REDIST packages we are actually talking about. In most cases, the reason that REDIST packages are used is because the components involved require administrator rights to install because they install drivers, update system components, install files into , and/or install Windows Services. For User Account Control support, you can really only require administrator rights at install time, not every time the application is run. Visual C++ REDIST packages The rules here have changed over the various releases of Visual C++, so some of the usage here is based on simply looking for the easiest and quickest solution. In most cases, games already have an installer that requires administrator rights so it's just easiest to launch the VC REDIST EXE (either x86 or x64 depending on their game EXEs) to deploy the CRT DLLs system-wide. Application local deployment (i.e. just copying the DLLs with your game EXEs) is an option, but for security servicing it's actually nicer to have a system-wide version that gets patched automatically as needed. For VS 2005 / 2008 the Fusion Side-by-side manifests tried to make it possible to service even local deployment, but it was a bit flakey. As of VS 2010, the use of these old manifests were removed so if you use local deployment you have to update your application to apply any CRT security fixes. The only really good reason to do application local deployment for the Visual C++ CRT is if you are trying to avoid the need for admin rights for deployment, but you have to take responsibility for security updates and don't get anything 'for free' in this regard. 

Direct3D9Ex exposes the WDDM virtualized memory behavior, whereas Direct3D 9 on WDDM emulates the XPDM behavior. With Direct3D9Ex, you never get "Lost Device", but you can get "Device Removed". "DYNAMIC" is a specific behavior which requires memory that is accessible by both the CPU and GPU that is in limited supply depending on your system setup, so you should definitely prefer to use "static" data wherever possible. A lot of detail on this is covered in the talk "Why Your Windows Game Won't Run In 2,147,352,576 Bytes" 

The question is what pixel format are you converting your and images to for the , and with what tool? Many of the older tools, including the legacy DirectX SDK texture tool, will default to using a 24bpp format . The problem with this format is that there is no DXGI format that is 24bpp. The DDSTextureLoader in DirectX Tool Kit is designed for efficient runtime use, and therefore performs no conversions. Either the file in question directly maps to a DXGI format, or it fails to load. The texconv command-line tool in DirectXTex is a modern converter. It can load and convert older legacy file formats that don't have DXGI equivalents as well. See Direct3D 11 Textures and Block Compression. Depending on what format you are choosing to convert your files into, there are potentially other points of failure based on your video card's Direct3D Feature Level. For example, you can't use a or texture on a Feature Level 9.x device. The DDSTextureLoader functions don't throw C++ exceptions. They return values. While a common pattern is to use to handle the return value, you can also inspect the HRESULT in the debugger which could well provide a clue as to why it failed. See the DDSTextureLoader documentation for more for details. PS: If you are new to DirectX, consider taking a look at the DirectX Tool Kit tutorials. 

Direct3D 10.x and Direct3D 11.x do not support the 'legacy fixed-function' pipeline that your Direct3D 9 code is using. Preparing to move to Direct3D 10 or 11 means eliminating all fixed-function usage and moving to programmable shaders. It is also apparent from your code snippet that you are not using the state objects correctly. In Direct3D 9, you set hundreds of individual settings. In Direct3D 10 and Direct3D 11, you manage all state through a few objects and a few simple individual switches such as primitive topology. You have really need to take a step back and understand the major shifts in technology here. All fixed-function rendering needs to be replaced with programmable shaders, state management needs to be changed from a 'lazy-evaluation 'model to a 'known groups' model. In other words, you cannot meanigfully translate the single line: by itself to Direct3D 10.x or 11.x. You need to know the state it is grouped with and how you are using them all together to render your scene. 

The basic difference is simple: The standard Rendering pipeline configures the GPU so it processes data as vertices, then rasterizes them into points/lines/triangles, and then processes the result as pixels which are written into a buffer using optional blending. A DirectCompute shader just takes data from a buffer and then process them in parallel to produce data in another buffer. The data could be visual, it could result in something that could be reused in the standard Rendering pipeline, or it could just be data that is used in some custom way that has not at all to do with graphics rendering. 

C++ is really a family of languages that are all in one compiler, so it's difficult to be truly a master of everything. There's a 'core' language which is a 'better C', there's an objected oriented langauge (i.e. classes, inheritance, virtuals, etc), the Standard Library (including but not limited to the STL), and a meta-programming template language. Add in the complexities of evolution from C++98 to C++11 to C++14 and it can be a bit daunting. Personally, I'd suggest once you have the basics of C++ down, read the three Scott Meyer's books: Effective C++, More Effective C++, and Effective STL. Then read his blog for the notes on what he thinks is most important about C++11. I think his list is pretty good, but I wish he'd have mentioned which I've found to be extremely useful. You may also find the content in my article Dual-use Coding Techniques for Games useful even if you are not targeting Microsoft platforms in particular. Being a really great coder in any language requires experience mostly learned 'on the job'. Looking at examples of code can also be a good way to learn it. You may want to dig into some existing code that has been well code reviewed by peers and generally judged to be 'good code' in terms of style. I've had lots of good feedback on DirectX Tool Kit, DirectXTex, and DirectXMesh which all make use of C++11 standards and have been though many peer reviews. Of course, being an "expert in C++" doesn't mean much if you are not also proficient in whatever specific area of computer science or technology you are supposed to be addressing with your "expert C++" code. There's many well-known classic books in each field, so figure out which one is most relevant to your job search.