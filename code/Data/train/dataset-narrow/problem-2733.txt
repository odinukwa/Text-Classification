However, normally, you'd keep it somewhere and only load it once, as it is faster to look at a global object than calling the ContentManager.Load method. 

If you know the points of all the corners, it's simply a matter of taking the average of each point component. 

Like Byte56 suggested, rather than fix the collision, you simply doesn't allow the collision to happen in the first place. Here's a snippet of how my engine handles it 

In the line you noted, you are continuously adding a Force, every time the object updates. Lets use a static value to see what I mean 

You can see it in action here. Now, you'll need to implement a rendertarget swapper to further edit the "hole" rendertarget, but I'll leave that as a challenge for you. 

The problem comes when I try to get the Blocks in the maps using a method called , where the last line is . This line returns a Block with completely random values like and such like that, found out through debugging. So my question is, is there something wrong with the blocks being declared as const obejcts, and then stored at pointers and accessed later on? The reason I cant store them as is because that makes a copy of the Block when it is entered, so the block wouldn't have any of the attributes that could be set afterwards in the constructor of any child class, so I think I need to store them as a pointer. Any help is greatly appreciated, as I don't fully understand pointers yet. Just ask if you need to see any other parts of the code. 

This way you avoid using the built-in one that seems to have issues, and instead you use one that has been tailored to work. This is definitely a workaround but unless you want to force your players to update, it's the only solution. 

Here's a custom BlendState that should do the same as Game Maker's does, based on the post found here. Here's a complete example with combining two RenderTarget2Ds, so you also see how they work in practice. 

I would never recommend having one large image. One large image will make changing and creating levels very tedious. In my tile engine, I draw all the tiles to a separate screensized render target, and reuse that render target as the player moves around in the world, only drawing tiles as they enter the screen. This all happens in the background. I then use the render target as the background, and then draw the entities on top. This is what I believe one of the most efficient ways of drawing a tilebased world. 

How to I implement a variable number of threads that all execute at the same time, and force the main thread to wait for them using join() without stopping the other threads? How do I make the VAO objects thread safe, so when a bunch of Regions are being created at the same time across multiple threads, they don't all get the exact same VAO? Turns out it has to do with GL contexts not working across multiple threads. I moved the VAO/VBO creation back to the main thread. Fixed! 

This works in that the world loads about 3-3.5 times faster, but this forces the height to be a multiple of 4, and it also gives the same exact VAO object to every single Region, which need individual VAOs in order to render properly. The VAO of each Region is set in the constructor, so I'm assuming that somehow the VAO number is not thread safe or something (again, unfamiliar with threads). So basically, my question is two one-part: 

First off, you should really store the tiles in a 2d array. As far as I can tell from documentation, has a method. This method gives the coordinates of the top-left point of your view. Next you will need the coordinate of the mouse, in relation to the top-left of your window. Finally, you add the two coordinates together, and you'll have the world-space coordinates of the mouse. From here, it's a matter of basic integer divisions to get the tile you are currently hovering. 

This is a direct copy of a functioning BlendState.AlphaBlend from a working Reach profile Silverlight application I have. You should declare it in the class that needs it, in the constructor or Initializer as it only needs to be done once. Then change your function from this ... 

And finally, the maps that I'm using to store references of Blocks in relation to their names and ids are declared as such: 

I've started trying to make a 2D game in C++ using OpenGL, and I'm using SOIL as the imaging loading library. The problem is, I've been trying to get a simple 64x64 image of a red square to open and display, but when I render it, I get a 64x64 white square. I've used SOIL before to great effect to load textures for a 3D program I was working on earlier. I have copy-pasted code from that program into the new one, but the texture is not displaying for some reason. I've checked that it was loaded properly, and the ID is being set to a proper ID, and it's getting the dimensions correctly, just not the colors. Even more confusing, when I try to get the height and width of the texture, they are both returning 0. I'm starting to believe more and more that its something I did wrong initializing the Orthographic Projection matrix, or something is missing from my OpenGL initialization code. Here is the initialization code: 

This gives you a very dynamic approach, and lets you modify things at run-time. Maybe you want to make a spell deal double damage when a buff is applied. Maybe you want to have it bounce. All these things could be hardcoded into a single class, but it would get messy fast. This approach lets you give each "effect" their own separate implementation. 

After that, you save the file, close it, then right-click the project and click reload. Now depending on the build configuration you use, you'll either use Debug or HiDef. Please note that opening up does not reflect the difference, but you can test it when you build. 

Here's my way of adding transparent holes in your background. It uses a simple pixel shader that subtracts the values. I'm not sure this is the best way, there may be some tricks possible simply by using a custom BlendState and the Subtract function. What I did was create two rendertargets. One holding your dirt. This could just be a large texture, however, to get it tiling dynamically, rendertargets was a good choice. First I prepare them in the LoadContent override. 

I'm creating a game in C++ using OpenGL, and decided to go with the SOIL library for image loading, as I have used it in the past to great effect. The problem is, in my newest game, trying to load an image with SOIL throws the following runtime error: 

Image Here As you can see, the app.h/.cpp files are in the "\app" folder, but the includes are able to reference things from "\lib" without including "..\lib" to go up a folder, effectively treating all of the source files like they originate in the base folder. TL;DR: How does one include multiple folders from different places as filters, and how do you treat all source files like they originate from the same place. Any help is greatly appreciated, as this will help me organize my project better. Thanks. 

I see basically two ways you could solve this, but in both cases you'll need to utilize my SharpCraft project, which is a C# powerered way of injecting functionality into Warcraft III made by me, with research from a bunch of other people. Do note that the readme is outdated, but I'll do my best to help you out with the current release. Use JASS This way you have easy access to the full JASS API, which allows you to fetch everything easily. What you do here is add some custom natives to the JASS API that help bridge the gap between JASS and your application. This could be natives that write to the hard disk or natives that send messages to your application. Use C# This approach has the advantage that you can keep it in all C#, which is much more versatile than JASS, but you can't use natives that use strings. You have full access to the JASS API from C#, so you'll not lose out on any features. There's a plugin included in the pack that shows the XML structure for plugins. To use the library, you add a reference to SharpCraft.dll, and then create a class that implements the FullPluginBase class. From there you have access to the different parts of the API. 

I am making a game similar to Minecraft, and I am trying to fine a way to keep a map of Block objects sorted by their id. This is almost identical to the way that Minecraft does it, in that they declare a bunch of Block objects and initialize them, and then the constructor of each block puts a reference of that block into whatever the Java equivalent of a std::map is, so there is a central place to get ids and the Blocks with those ids. The problem is, that I am making my game in C++, and trying to do the exact same thing. In Block.h, I am declaring the Blocks like so: