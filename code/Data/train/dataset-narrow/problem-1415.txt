Is there a better to test this requirement other than to iterate through all the possible scenarios? I'm doing something like this. 

Next up it's Board. Board was doing too much. It was keeping track of the players, moving them, keeping track of turns, etc... So I split it into two classes: Board and Game. First up it's the new Board. 

I watched a presentation by Dave Thomas on Elixir where he gave an example problem that he solved using functional programming. He mentioned using Ruby to solve the same problem, but did not show an example. I decided to give it a try. The problem goes something like this: For a list (Ruby doesn't have lists, but for our purposes an Array is close enough) of n numbers, create a new list where unique numbers are represented once, and repeated numbers are represented by a tuple (again, Ruby doesn't have tuples, but for our purposes a Hash or an Array would do) where the first element is the number itself, and the second is its count. For Example, the following list: 

For the sake of brevity I have not included the enter class, but you can see it here (65 lines). And here is a gist of my proposed changes. Only the and methods change. 

I've packaged this into a gem, with appropriate tests. I have learned a lot, but still not enough to nail down my perfect design. I still feel that my interfaces are designed poorly. Here's an example: A rule states that a player who rolls three sixes in a row returns to square one, and may not leave until the player rolls another six. How would I bake this into my current design with minimal interruption? The natural thing feels like Player should control its own movement. The Player class doesn't know about Board and . So the interface has to be redesigned. There are other issues too. But this is a start. I will post a follow up. 

I want to offer an alternative to helpers because I believe in this particular case using a presenter to isolate view logic is better than using helpers. As stated yourself you have many more attributes, so having a presenter class avoids having to write generic methods and gives you a scalable way to handle view complexity. You can use a gem like Draper, or roll your own, which I prefer. 

Flambino's answer is great. I will add another way to solve this; although, as Flambino points out, it is a math problem and loops aren't needed. That said, you can use an Enumerator. 

Doing so means the placement methods for ladders and snakes only have to worry about working out the range and populating their respective hashes, which are the only two differences between them. This reduces duplication. 

Outside of the jQuery DSL I've hardly ever written any JavaScript. I never bothered learning JavaScript until a couple of months ago. After a slow start I got stuck in and created this game today. I usually program in Ruby, and this is proving to be an obstacle because I'm thinking in ruby while writing JS. The code may come as a shocker to experienced JS programmers. My greatest challenge is to separate presentation from logic. I haven't figured that out yet. This is a case of knowing the syntax without knowing the language well. I'm interested in comments about structure. I know this is hardly maintainable code. It's obvious. What is not obvious (to me) is how to make it maintainable. I'm only adding the JS code here, but the entire game is included in the snippet below the code. 

Finally The habitable range for ladders and snakes is the same, so this can be replaced with a single range : 

I removed the and private methods. They added no value. Ruby 2 introduced keyword arguments. They are superior to an options hash. So I removed that in favour of keywords args in . Player exposes a setter. Instead of passing to the player under , just set the player's position to the cell's location using the setter. 

I suggest you extract two methods: to check if the user is authorized, and to handle behaviour. You would then end up with this: 

A snake's head can't be on the last square otherwise you can't win the game. A ladder's base can't be on the last square since there's no where to go. A square can not contain the base of a ladder and the head of a snake. You either slide, or climb. Players start off the board. 

I wrote a sample app based on the ReactJS tutorial, and I would like some thoughts on how idiomatic this code is. Unfortunately there's no ReactJS integration with Stackoverflow snippets, but I do have a working JSFiddle. You have a phases box, and inside it we have a list of phases, and a new phase form to add a phase to the list. There's a link to show the form, and another link on the form to hide it. There's also validation on the form. I'm curious to know how idiomatic this is. Some things to consider: 

I'm looking for feedback on this live-filter I wrote in JavaScript. You can test it using the included snippet. 

The rules are a win earns three points, a draw one point, a loss zero points. For example, if we feed the method this match data: 

I was not able to get @Jerry Coffin's particular implementation to work, but I used his idea to create this similar \$O(n)\$ implementation. As he describes, we reverse the array at \$A[0..S-1]\$ and \$A[S..N-1]\$, where \$S\$ is steps and \$N\$ is the length of the array. We then reverse the entire array. 

You only need to sum the first 11 numbers to get the correct sum Take advantage of Swift's functional aspect 

I added a feature that allows you to send in a Regexp filter instead of a string. It's my first use of Procs, and I'm sure it can be done better. It's not very readable, and probably not efficient. 

Because we removed the Cell dependency we can remove the method in favour of a setter. As with above, I replaced the options hash with keyword arguments. It makes more sense for a player to keep track of its turns. Each time a die is rolled, it is a turn. I created a array property to track turns. Its size is the number of turns a player has had. removes the need for temp variables to hold onto the current roll in the board class. always returns it. So I added a convenience method. 

With the benefit of several days of thinking I'm going to have a bash and review my own code. To aid my understanding, I made a rough diagram of how my objects interact with each other. The Portal class remains unchanged, so first up it's Cell. It's decent, but it can be compacted. 

Try not to use with and conditions because it becomes confusing. It's clearer to use negation: . Some people are boolean impaired, including myself. I'm not sure under what circumstances the hash does not exist. So checking for its presence may be redundant. 

Some would argue that a service object adds a needless complication. They may have a point. I think it depends on each use case. 

The method returns an Enumerator object, which responds to the method. The enumerator's size is the number of jumps (or loop iterations) that the frog needs to reach its destination. can take up to two arguments; the first is the goal, or the value needed for the enumerator to terminate, and the second is the value by which to increment the goal. 

But I suggest you think about using an authorisation library, or extracting authorisation logic into a policy object. This way you gain the benefit of DRY, and an extensible way to add and reuse permissions. 

Your method has two hard coded dependencies. The first is the name of the class . Should Resolver's name ever change, or be replaced, you must make changes to resolve_url. This is more subtle, but it's a dependency nevertheless. The order of arguments that Resolve accepts is hard coded into resolve_url. Should those change, those changes will cascade down. 

Is this a good way of testing me controllers? The part that makes me think is where I'm generating the JSON using Rails helpers instead of explicitly writing the JSON myself, or looking for keys in the response body. For example: 

Once more, I've opted for keyword args in . I've simplified the method. It plays a turn, moves the player, then checks if the player has won (landed on last square). If the player does not move (no where to go), it checks if the last roll gets him in excess of the last square. If either of those things is true, it sets , otherwise the turn ends. 

What happens if you changed "Logged in successfully" to "Welcome, mate!", or "Merry Christmas, Mohamad"? Your tests will fail even though the code is sound. Is "Logged in successfully" part of your spec? Or is your spec "The user should be signed in and have a session." I think that looking for a specific CSS class on the page, as well as other classes, (link classes that should or should not be present if the user is signed in) might be more robust. I would even look for link text, like "Sign in" and "Sign out". Sure, those can change too, even CSS classes. But they're less likely to change than messages to the user. 

As pointed out in the comments, I would use a name other than and . Your example code is lacking context, so what I'm about to say may or may not be applicable, but... 

How can I improve this? If there a better way to get the unique teams from the match info? That parts looks convoluted. I also feel that the method is too large. 

This example illustrates my point but it is not complete. You must wire the policy to the controllers, maybe include it in a concern. But it's not that hard. There's a great gem called Pundit that gives you similar interface. Asides 

It depends. I prefer the newer syntax because I feel that it is more readable. As others have pointed out, however, the newer syntax is only compatible with Ruby 1.9.2+. You should be aware, however, that the new syntax does not entirely replace the hash rocket syntax. This is because you can only use the newer syntax with symbols. 

Are there any edge cases I'm missing? Also, this doesn't seem efficient: First, there's an added dictionary. Second, there is a linear search on each iteration to check either the keys or the values of the dictionary. There's an \$O(n)\$ on the array resulting from the string, as well, but I'm not sure if we can avoid this. 

I wrote this jquery plugin to do remote validations on the server. The code self explanatory. When the field blurs (event is customisable), the plugin checks to see if there is a value and sends the request. Nothing fancy, but since I'm relatively new to JavaScript I'm sure I might have missed a few things. I think the init method is a bit long in the tooth. I am also calling from a bunch of places in the method, but that might be necessary. 

I'm passing a callback to handle hiding the from from the parent to the form, and then to the link component that hides the form. Seems excessive to pass down a callback through descendents. Validation is very complex, but I have a simple case here: text is required. It seems a bit ad hoc to validate this way. 

I wrote this short, plain Ruby lib to handle email address validation inside and outside of Rails applications, and I would like to know what you think. 

I'm going to be bold and review my own code having spent the last hour refactoring it. The original implementation had bugs. Sometimes less than 10 ladders were placed. This is because the algorithm did not check to see if there was a ladder already present at the current insertion point. 

This refactoring addresses concerns one and two regarding the mechanic. To some extent. More on that later. 

Explanation We use to create a new array from the existing numbers array. The new array contains the first 11 digits of each number from the original array. Each element is an int, converted using , which lets us apply to sum the array. We then convert the sum to a string, and take the first 10 chars. And voila, you solved it. This assumes you already have an array of strings, as is the case in your code: 

Am I testing too much? Is there a better way? Running 70 or 80 tests for something like this seems excessive. As an aside, can my regex be expressed better? 

Please review this small program I wrote to create a World Cup Group Table. You feed the program match info, and it builds a table based on that info. 

I wrote a Ruby gem to analyse strings for word length, word density, and a few more hand methods... The class accepts a filter (String). The class will remove any words from the original string that you include in the filter. Spec: 

Finally, should you add more classes to User, Series, and Lessons, you must modify your method, and add the necessary conditionals. So ask yourself if this code really belongs in the method. My two cents. 

The rest is self explanatory. checks to see if is not nil. I've isolated dependencies on and in their own methods. The only thing that may not make sense, which I omitted from player class is , this is just a convince method for to check if the last rolls gets it over the winning line since the player can't move off the board. 

I'm building a JSON API. I'm writing my controller tests so that they compare the response body to actual JSON I'm generating in my tests using ActiveRecord. I wrote two helper methods that make the process easier. The first simply parses the actual response body and returns it. 

The and temp variables represent a transitional state. I would ask myself if I will use them in any other form. If not, and if their entire reason for existence is to transition to text, I would do away with them and have one entry point for clean, or savable text. I would consider if generating the report is the class responsibility. The report is a presentational concern, and I feel it should have its own class.