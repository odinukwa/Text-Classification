If the CR2032 button cells don't provide enough current, you could try 4 AAA batteries instead of AA batteries. That should reduce the weight some. 

Dimming the back light of an LCD is not as straight forward as dimming simple LEDs. A lot depends upon the specific LCD you are using and the specific circuitry it is attached to. Without the specifics of the LCD you are using, it is not possible to give a specific answer. Some LCDs have a pin that can be used to adjust the back light brightness. Typically this is done using a variable resister to control the voltage level applied to the back light LED. However, it can also be done by PWM, but typically requires a transistor and resister. The RPi is then used to control the transistor which adjusts the current flow to the LCD back light pin. This all assumes the circuitry for the LCD isn't hardwired to a set brightness level. Doing a simple web search on "Raspbery PI LCD dimmer" and the name of your LCD (i.e. 1602) should get you detailed options for your specific LCD. 

A simpler solution would be to use . Then function a only has to determine if function b executed by checking the button's property. 

I recommend using the gpiozero library. It is designed to make physical computing much easier. The documentation is great and has lots of good beginner examples. Using , your example becomes: 

Depending on your data sampling needs, you may want to consider an SPI bus solution. I2C is limited to 400 kHz, while SPI is only limited by the physical hardware and can get over 1 MHz. Yes there are commercially available boards that will do what you want. I recommend using the following search words: Raspberry, pi, analog to digital, hat. The keyword hat helps find boards that are "plug-n-play" ready for the RPi. 

There is an excellent tutorial in the MagPi Magazine that explains how to Add an Off Switch to Power Down Your PI. You should be able to modify the instructions to make use of the unused button on pitft screen. 

In addition to @goldilocks answer, I would add that the ground pins have been strategically placed to make it easier to connect to specific functions with smaller connectors. For example, physical pins 17 and 25 are at opposite ends of the SPI0 bus pins. Check out the Raspberry Pi Pinout site for more information. It has a ton of information about the RPi pins as well as various hats, boards, and other accessories. 

The second line of your error message tells you that you need OpenSSL If it's already installed then set the environment variables as mentioned in the error message. Otherwise you need to install OpenSSL 

actually, .bashrc won't work to start something on boot. You might try running stuff on /etc/rc.local, that will print output to what you see during boot time. But in order to work "right" your script has to either finish or it has to go into the background. If it hangs forever without letting execution continue, boot sequence won't finish. Addendum: Real question was related to user login time, not boot time. The answer is to use ~/.profile. 

Apparently time stuff (with ntp) can be set up to use gps devices $URL$ This one is for raspberry specifically: $URL$ 

Ok.... I was able to get the modem to connect (disregarding wwan0 interface) by using wvdial. I only had to use these init commands: 

The first routing rule when vpn is working is sending traffic to a lot of IPs through the VPN (0.0.0.0/1). 

Well... even if your script has no mention of any sound stuff, pygame could very well include sound-related stuff inside and that's why you are seeing those messages. If you want to avoid those messages from showing up on the terminal, you can just redirect output so that you don't get it at all: python my-script.py &> /dev/null and voila! No output on the terminal. Could also try with 2> instead of &> if you want to only avoid error messages or even play a little bit with pipes if you want to avoid ALSA messages and see everything else ( blahblah 2>&1 | grep -v ALSA ). 

The problem is that you have set up both interfaces within the same network segment (192.168.9.0/24). So, once both interfaces are up, when traffic is going out, the routing code will chose among any of the two interfaces where it could go out (when going in, actually, you can't choose which interface it will come in because it's sent to either one interface or the other from the other box so the rpi has no power there.... you can check this by using a sniffer). So the problem is that when you want to reach the IP assigned to eth0 from another host, the traffic is getting to the rpi fine (check with a sniffer, for real, you will see that traffic is reaching the rpi through eth0) but then when responding, the routing decision is choosing the other interface to respond... and then to the originating box you get some traffic that is coming back from the rpi but it has a different source IP from the IP that the originating traffic was sent to.. and then the box will drop this traffic because it's not coming from the expected IP. Long story short: Set up two different network segments, one for each interface so that they don't overlap or set up a bridge (the instructions are on the that rpi manual page you linked). 

As suggested in the comments above, I ran a simple test using two copies of the same data logging program and found that both programs are running fine side by side in the background. While I haven't tried the specific scenario posed in the question, the fact that two programs accessing the same set of sensors is not having problems, I suspect the originally posed scenario will also work equally well. UPDATE: I also tested a scenario where two separate programs attempted to output text to the LEDs. Both programs executed "normally". However, you could see the competition between the two programs as the LEDs flickered between the two messages. 

I recommend the Sense Hat. It has several sensors built in to include a magnetometer and IMU. It also has a very nice and we'll supported python library. The library gives you both high and low level access to the IMU data. The led array and buttons can come in useful for headless operations. 

I also recommend checking out the recipes section of the Gpiozero documentation. You will find many options that are easily adaptable to your situation. 

First, it sounds like you might be overloading your supply power circuit. (I assume you are using a wall outlet.) If that is the case, you need to address the root cause of the power supply fluctuations. Second, what is the quality of the power adapter you are using for the RPi? Is it rated at 2 amps or more? Also, what else do you have plugged into the RPi that is drawing current? Third, instead of changing the pins around, I would add a larger pull up resistor to reduce the current drawn by the button. Finally, depending on the length of the transient power fluctuations induced by the external load, you could try modifying the if statement to require a period of time for the button signal to be low. The theory is that a human pressing the button will hold the signal low longer than the signal generated by the external load. This solution ignores the safety issue of resolving the source of the transient power fluctuations. 

Based on the information at the RPi pinout site, you connected a bunch of the GPIO pins to ground. The sense hat uses the I2C bus which was not connected correctly. It also uses a couple of the GPIO pins for interrupts and communicating with the Atmel chip(s). The potentially worst thing you did was to short the RPi's 5V pins to ground. So you are lucky you didn't ruin your RPi. Depending on what protection circuitry is in the sense hat, the board MAY be fine. I suspect you may have corrupted the EEPROM on the sense hat. The EEPROM is used to let the RPi know what board is attached and how to configure the hardware. The good news is you might be able to reprogram the EEPROM. Check out the Sense Hat documentation page for the details. 

I have a little experience with GPS dongles and so far I have been able to read from them by opening the device file as it it were just a normal plain file (with open) and then pulling with readline(). The only details I've had to change (say, set no echo or change speed) I just call stty with supprocess.popen and then I just go and open the file and read from it till I reach EOF (device was disconnected, for example). How long does it take for your application to fail? Because you can try with cat (on bash, say)... run cat on the device file and see if it will run longer than your application reading from the device. It should run forever, actually... if it goes fine, then I would expect open/readline() to work just as well on python reading from it. 

I'm testing openvpn to restart if it fails for whatever reason. I edited the file /lib/systemd/system/openvpn.service (with vi straight, just in case) and set the Type to simple, added Restart=always and RestartSec=60. Then ran systemctl daemon-reload and then started my openvpn service (systemctl start openvpn@blahconfig.service) which makes it start. Then I forcefully kill openvpn process with kill and it remains as dead, no intent to restart it. What should I try next? 

I've been struggling since yesterday trying to configure a wwan interface that I get when I plug in a huawei modem into my rpi. This is what I have on /etc/network/interfaces but it just doesn't work (I'm in Costa Rica and the SIM provider is Movistar): 

Talking about X server, you have to make sure than X is configured to accept tcp connections and that should be enough. If it's wayland, I'm not sure of how exactly it would work but it should be something similar. Then you could set up this script to be started with systemd on boot, which is a whole different topic. 

Set up the correct APN in Init3 command and you should be good (plus the other usual stuff like device, phone number, etc, etc etc) 

Do you have, by any chance, physical access to the computer? If that's the case, shut it down, put the sd card on a computer (I mean, like a laptop or a desktop or a server, you get the idea), mount the / partition of the sd card (/dev/mmcblk0p2, probably) and edit the profile file so that it doesn't work when you start the terminal (or add a & at the end so that it goes into the background). Another possibility: Did you happen to set up a different user on that board? If that's the case, try to log in with that other user, then sudo kill the process (hoping the user is a sudoer).