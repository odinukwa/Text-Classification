Update April, 2014: On newer versions of OSX, the original advice (below) no longer applies. "Newer versions" here means at least 10.8 and 10.9. It should apply to any version of OSX with a dedicated recovery partition though. Here's the newer way to do this: 

Always read the output of or carefully, before saying yes to anything. Remember that you can always do a dry-run using or . The flag is your friend. 

The command is a good start. In addition, you probably want to remove all the dependent libraries that were installed only to get Gnome. You can do that via in or, if you use , it should happen automatically. Note that the command has an oddity: it purges items you remove explicitly, but only removes any automatically removed dependent packages. (That is, if you enter and gets automatically removed at the same time, is purged but is only removed.) So a good way to recursively purge is this: 

If you want that formatted so that you have only the names of packages and the word "install", can do that too. This gives you a list ready to feed to : 

Replace with whatever you want to call the newly created archive, and with whatever is the name of the folder you want to archive. 

This is a great question. You would think that there would be one nice, handy-dandy tool to tell you such things, but I don't know it. I'll go one by one, and give my best suggestions. 

If you didn't change anything, it's odd that it was working and now isn't. That aside, I normally add this to get the most out of the backspace key with Vim: 

Those are listed in my order of preference, but you should investigate to see which will fit your needs best. 

I had this exact experience when trying to do an upgrade to Leopard. The answer in that case was to backup any settings and data that I wanted to keep and then do a complete reinstallation of Leopard (that is, wipe the drive when you install - don't just upgrade in place). Anecdotally, I've since heard from many people that this is common with significant Apple version bumps. They tell you that you can upgrade, but really you should reinstall. It takes longer, but it was worth it for me. 

Before actually installing anything, consider carefully what you're being offered and how the upgrades may affect your system. I use Debian rather than Ubuntu, but I would be surprised if Ubuntu really had security updates daily. That said, you never know which day they will be available, so it pays to check often. See here for a tutorial on Ubuntu's command-line tools for installing software. (Based on other pages from her site, I take it that Ubuntu now recommends GUI methods rather than apt-get.) I know that you asked for command-line methods, but you can also use Synaptic manually. That is, instead of waiting for the automatic check, just fire up Synaptic, let it update your sources and see if it tells you that there are upgrades. If you're not used to the command-line, that will probably be easier. 

You can get the standard *nix ones via Fink or MacPorts. I'm partial to slrn, but that's a console app. If you prefer a gui, there's Pan. I've used it on Linux, and it was good. I can't speak to how well it works in OS X. (The Pan webpage mentions OS X as supported, so that's a good start.) If you are comfortable tracking down dependencies and compiling, you can also build these on a Mac without Fink or MacPorts, but the package managers make upgrades and removal a lot easier. 

Take a look at Little Snitch. It monitors which applications are using the network and also tracks usage. From its website: 

You can use the command. If you don't provide any variable, the line gets saved automatically into the variable in Bash. If you provide a singe variable, the line gets saved into that variable. If you provide multiple variables, Bash will split the line as words (the splitting is done on whitespace), trying to put one word into each variable. (If there are more words than variables, each variable gets one word, but the last gets the rest of the line.) Example: 

You are misunderstanding . In that scenario, the command doesn't cause the connection; the pipe connects the previous command to . Also, you're saying 'input' where I think you mean 'output'. What you type into the terminal is the input in this case; the output is whatever spits back out. receives the output of the command via (aka, the pipe). The pipe takes the standard output of one command and plugs it in as the standard input of another. (You might find this Wikipedia article helpful as a start.) To assign the output of one command to a variable, you would normally do something like this: 

On Macs I use Aristotle Pagaltzis's freely available , which like Debian's is Perl-based. You can get it here. Or visit here to read it first - always a good idea. You need to place that somewhere in your and make it executable () and then you're good to go. 

That command resets 's sense of what packages are orphans and should be removed. Here's the reason it's sometimes useful: for awhile now, both and will track packages that were automatically installed as a dependency of something else. So, for example, if you install , you might get as a dependency. They do this, so that if you later remove , gets removed too. But and handle this clean up differently. immediately tries to remove all orphaned dependencies; but merely suggests that you run to clean up. (The logic behind all of this is that you only got the library since needed it. If you don't keep , you shouldn't need the library any longer. If another package still depends on it, then both and will know this and not try to remove the library.) What's my point? Well, if you've been seeing constant nudges to run and you switch to , then you may be in for a shock the first time you try to install something. will straightaway try to remove all those orphans. In general, this will be fine (they're orphans after all, and not necessary), but there is one complicating case. The desktop meta-packages all involve a complex dependency chain where each individual program is pulled in as a dependency of a virtual package wrapper. For example, if you have Gnome installed because you installed the package, then all of your normal desktop programs were installed as dependencies. If you have uninstalled a single one of these programs (e.g., Ekiga or Gedit), then in the eyes of the rest of your desktop should be removed too. Note that always asks before it removes things, but people often enter 'Y' without reading. In my experience, this is the single most common complaint/confusion for people new to Debian. Two general pieces of advice: 

A default set-up on Unix-like systems is that user-installed software gets installed in /usr/local/bin, and most *nix distros put that directory before system-wide directories in the default $PATH variable (which is how your shell knows where to look for programs). That way, if you install something new, the new item gets found first. However, a default OS X $PATH looks like this: 

That's a function not a program. There's very little to it, and I'm only going to use it if I'm already working in the shell. I also find it cleaner to put all the functions for my shell into a separate file (.bash_functions for me, but I think you are a Z shell user, so adjust accordingly) which I source from my shell's primary rc file. A last tip is to add something like this to your aliases: 

There's a larger question here that's worth addressing. Shell commands are not chatty (they don't double check what you want), and they expect you to know what you're doing. This is fundamental to how they are designed. It's a feature, not a bug. Some people feel macho when they use such commands, which I think is pretty silly, but it is important to understand the dangers. You can do a great deal of damage in a terminal, even if you're not root. I think you probably really just cared about , but since you said "Can we undo the the operations done in terminal", I thought this was worth saying. The general answer is no, you can't. 

The good thing about is that it allows you to read about how the editor works while actually using it. Beyond that, you can take a look at the links here: Vi Lovers page The nice thing about that page is that it briefly discusses the various links it provides, so you get a sense of which are better or worse and why. I would add that the best way to get comfortable with Vim is to use it exclusively for a bit. If you end up hating it, fine. Use something else then. However, the only way to train your fingers and brain is to use it. My fingers now do out of habit, even when I'm in a gui email client at work (instead of Mutt). 

Lots of good advice is already here, but let me add one thing nobody has mentioned. If you do decide to switch, you may want to run this command, depending on what you've been up to with : 

Note that many modern Unix-like distros block this "reset the root user password without knowing the old one" hack, but I just did it on the Mac I'm at (a brand new MacBook Pro). So, apparently, Mac hasn't blocked it. That's too bad in general, but perhaps good for you and your friend. Edit: Some people have mentioned in the comments that you can skip resetting the root password and simply reset the user's password. To do that, at step 3 above enter and then enter a new password for the user. If you do that, you can skip steps 5-7. Just follow step 4 to boot into the GUI and you're done. This is a good alternative if that user was an administrator for the machine. However, if the user was not an admin for the machine, you should make sure to reset an admin's password as well (or to reset a root password as I did above). You can repeat as many times as you need for various users. Just make sure to reset at least one account that has admin privileges. That way you have not only a user's password, but administrative access to the machine. 

I wrote a blog post about my experiences with the same problem, but in a nutshell I think you need to apply this patch to your Ruby build and then build Vim with that Ruby specified. When you build Command-T, make sure to use the same Ruby interpreter. Here's the patch to make it easier for Googlers: 

After that, you just enter your leader (which by default is ) and then to clear the matches. You don't need to use ; if you prefer, pick something else. You can also remap your leader to something more comfortable, if you like. I use a comma: 

Boot the system into single-user mode. To do this, reboot and hold down Command and the 's' key at the same time. You're going to get a black screen and a lot of text. Don't freak out. Mount the root volume by entering this (this command should be mentioned near the bottom of all the text you see as well): /sbin/mount -uw / (Edit: Read all the way to the end for an alternative approach here.) Change your root user's password by entering (no 'o' and no 'r'). It will prompt you to enter a password twice. Remember this one. Enter to boot the rest of the way into the normal pretty Mac GUI. Open a terminal, enter and your new root password. Enter but, you know, put the name of the user whose password you want to change, instead of . Change that user's password. Enter to drop the superuser status and powers. Enjoy your new password.