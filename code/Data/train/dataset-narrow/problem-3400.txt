Besides the requirements of the electronics that is connected to the GPIO port, cost is normally an important factor in choosing a form of protection (if implemented at all). The page you are referring to is a mix of various methods for various types of potential hazards. Input and Output is thrown together in one overview, without any notice for the usage of the described type of protection. I hope this page (which is under construction) categorizes it's chapters in the future a little better, because in this way it is pretty useless for in-experienced technicians, and just a summary of frequently used techniques. But for every type of protection you need to find a balance between cost and effectiveness, you cannot protect against everything and still make something that is affordable. All types of protection depend on factors, like: 

The Archlinux site provides the images in zip format, I guess OS X automatically unpacked it for you. Because the file size you noted in your question is the file size of the unzipped image. 

There is somebody that already has written a LIRC kernel driver for the Raspberry Pi, it can be found here: LIRC Raspberry Pi driver. Also the required hardware and connection schematics can be found on this page. I haven't experimented with LIRC myself, but there are many applications available that use LIRC, I guess they now all work on the Raspberry Pi. If you want/need, I can dive into this subject a little more deep and come up with some additional information. For the Python part, there is a Python module to interact with LIRC, called pyLirc and a newer maintained version called pyLirc2 

Let me help you a little with your worries on providing a stable power supply to the Rasperry Pi. A DC-DC converter will do this job for you. These devices convert a DC voltage to the same or a different DC voltage. I found one on ebay that will provide sufficient power for the RPi and some 5V external storage device. It is called a DC/DC Converter 12V/24V Step down to 5V it outputs 25 Watt, on 5V this means 5A, more then enough for what you want to achieve I guess. Here is a more general link to ebay (in the case the item is removed) that shows the search result for similar converters: DC-DC step down converters 

Without any knowledge of Python, I found out that the actual communication is done using a .c source, that binds in someway to python. From Python you call functions from this .c file. I see that the SpiDev_new function (which smells like a constructor) accepts as first parameter the defined structure (as shown above), in this structure there is a field that states the maximum frequency of the SPI bus (max_speed_hz). In your source I see a call to: 

If you're just looking for some protection for normal level digital signals within a normal frequency spectrum, a general purpose buffer or general purpose opto-couplers will do just fine. Both (depending on type and how they are used) can work as input or output protection. If you have special needs for protection, like: 

I guess you can add some parameters to this call to get things working like you want... What and How I don't know yet... 

After running this command the package (csync2_1.34-2.2_armhf.deb) should be as a file in the directory you started the command in. After that I needed to install using the normal way two additional packages: 

About the Hardware: The only thing you can do is methodically, and very precise, check every part of your hardware first. The fact that a line gets momentarily pulled to 0V does not mean that the communication is actually working. On a scope you should see a 'pulse train' when checking the communication wires. When no data is being sent both DATA0 and DATA1 are pulled up to the 'high' voltage level. When a 0 is sent the DATA0 wire is pulled to a low voltage while the DATA1 wire stays at a high voltage. When a 1 is sent the DATA1 wire is pulled to a low voltage while DATA0 stays at a high voltage. You should see this on a scope, on 5v before the level converters and at 3.3v after. You should trace/monitor this signal all the way to the GPIO connected ON the RPI board, if that is constant you can say that the hardware is working stable. Be also sure you're using the correct pins and the signal looks still acceptable when it enter the RPi. Breadboard, because of the way they are built, do have some effects that are unwanted (mainly capacities), but for the average speed of Wiegand this should not influence too much I guess, but check it anyway. After that you can start to look at the software. Those errors (-2) you talk about are an indication that something is not happy, you'll need to check those before you continue. I am sure Google or a man page can provide the answer to that. Further, when data comes in those interrupt handlers should fire (I guess around 26 times per 'swipe'), if that does not happen, data is still not coming in. But checking the code, it looks that it should be able to work, so I guess for the moment, the hardware is still not in optimal shape. You can also see if those interrupt handlers trigger by just manually connecting and de-connecting the 3.3v to the input that you are using, if you add some printf() to the interrupt handler, something should be printed at least one time when you disconnect the 3.3v from that pin (edge and falling are used by gpio, I assume that means trigger on falling edge). And to answer your last question, Yes, I had no problem using RFID readers on the RPi, but I avoided Wiegand from the beginning! Hope this helps... 

Okay here the results of a short investigation: As you already know csync2 does not want to be installed using apt-get, the reason for this (as far as I can see) is that the debian people made a mistake in the dependencies of the libgnutls26 package. It states on a package line that it will break csync2 versions lower or equal then 1.34-2.2, which is odd because the version provided IS version 1.34-2.2, I guess the error is that the 'break' rule of the package should state versions LOWER then 1.34-2.2 and not LOWER OR EQUAL then version 1.34-2.2 What does it help to know this: NOTHING. But there is a way to get csync2 installed anyway, here is how: first we're only going in download the package using: 

I think that the snd_bcm2835 is the hardware abstraction layer for the audio I/O for the BCM2835 SOC. ALSA and other drivers (for example for network cards) that need to deal with a lot of different chips/hardware implementations, are normally designed in a way that separates the lowlevel hardware control from the (more highlevel) process control. Meaning that for Audio Chip A you need to set some parameters in a certain register, but for Audio Chip B you need to set some other (similar) parameters in a different register (different addressing for example). In that case you can decide to make two separate drivers, one for chip A and one for chip B. When you create in both hardware drivers a function 'Init_Card()' (that might do very different thing, but with the same result: initialize the card) all the software layers you create on top of these hardware abstraction layers, do not need to know HOW to initialize the hardware, they just call that 'Init_Card()' function to the the chip in a usable state. When you do this for all the functions that the chip has (play a sound, change mixer settings, record sound etc etc) you created a hardware abstraction layer for the chip. So for all the functionality of the various audio chips, you only need to call the same functions, but in different drivers (specific for that chip). The higher software layers now do not need to worry about the hardware, they just read some data stream, buffer this if needed and hand the data to the correct function of the correct hardware driver who then makes sure that the data is processed according to the chips specific specifications. 

Threads are within one process, so I guess you mean separate process that runs in the background (like a deamon process)? Anyway, adding '&' at the end of the command will make it detach from the terminal and run as background process. This works for everything, executable and script. Depending on the format you want it stored (the uart data), you probably can find a script/executable or just a unix command utility that will do it for you. If the data is pure ASCII: 

Programmatically there is only one way of using the GPIO pins, that is writing and reading to a piece of memory in the processor. But because it's a unix type OS we're using mostly, and unix maps everything to files, the kernel driver that is loaded to use the GPIO pins maps pins to these files that you're talking about. But internally this driver does the exact same thing, use this piece of memory to get the required result. This is called memory mapped I/O. So the RPi.GPIO code you're talking about uses the memory direct, the node.js uses the kernel driver (and thus is a little slower), based on the file you're writing to (or reading from) the kernel driver 'knows' what address to write to / read from in memory. Because this node.js application is unaware of 'how' to use the GPIO pins itself, it is better portable then the RPi.GPIO code (but that is a little background and for the current status of the RPi totally irrelevant) 

Using the SPI bus by just connecting the digital out pin of the ADC to pin 11 of the RPi GPIO will not work. This bus need a couple of more wires, 4 to be precise. The ADC will also need an SPI input, Clock and Chip Select pins connected to function properly. Luckily there is good information on this available from multiple sources. First if you would like to know a little more on the working of SPI, I suggest to read this page on Wikipedia to get to know SPI a little better. Second there is a very nice tutorial of Adafruits that exactly discusses this subject, it includes Python code and guides you through the processes of connecting the ADC itself and communicating with it. One (minor) disadvantage is that the code used in this tutorial does not use the SPI port itself, it software emulates the SPI bus (called bit-banging), this means that you are more free to use the pins on the GPIO port that you want. I suppose for your relatively simple project (although I am happily surprised nowadays 6th graders do these sort of tasks!, for them a lot of new information is thrown at them by making these types of projects), the bit-banging solution will work just fine. An advantage of using bit banging is that for learning purposes it suits better because you create all the SPI signals yourself, the processor does nothing automatically, so you'll end up with a much better insight knowledge of SPI and serial communications in general! Maybe it is a nice idea to start out with the examples from Adafruit and move at a later point to using the hardware implementation on the RPi for SPI, in that case you'll need the datasheet (also handy while using the Adafruit software implementation), Chapter 5 and 6 describe the communication and what needs to be configured to use the ADC. 

Just a couple of commands in the rc.local script, the same as you use to do it manually (be sure that the kernel module is loaded) The better option (but a little more complicated) is to use udev, I assume for the moment that arch linux has that package. But it uses a configuration file (in /etc/udev on my Fedora system), in this config file you can specify all sorts of rules and things that need to be done to some (or any) file during creation of these device files. 

The reason for this truckload of diodes is that it will prevent things like ghosting and masking of keys. Ghosting is the effect that if you press more then three keys at the same time, it is possible that it is interpreted as a totally different key because more rows will have a logical '1'. Masking is the effect that, if you have multiple keys pressed and release a key this will (in some situations) not be detected because the row for that key is still a logical '1'. 

Sadly connected to nothing! No chance to get anything connected to that!! But something odd is going on, if these pins are the actual missing I2S pins then the V2.0 board should also not have these pins on a connected. But the documentation states that is does have these pins available on the newly added connector P5. These are connected to different pins then the wiki says... This needs a little further investigation... soon more.... 

This display (according to the provided datasheet) is capable of communicating over SPI, that would make it a candidate to work with the SPI port that is available on the GPIO pins. But you said that you did not understand very much of the datasheet itself, that might already answer your question. If you don't have any experience with electronics and do not have some tools to investigate on the lowest level what is going on (like a oscilloscope or something) it will be VERY hard to get a thing like this to work. First you need to get the low level SPI communication to work, this display is not going to tell you if it received the data (only when fully initialized, you'll see output). Having linux to do the SPI communication will help big time. Second you probably need to send some initialization commands (according to the protocol of this display) to get the display in a state that is usable. (again without any output from the screen) Third you can send some basic things to the screen and when the steps 1 and 2 were correct it will actually show something. You see there are some 'blind' steps that need to function correct before you can make some library to make some nice output. I am NOT saying it is impossible, but it will take a very long time and a LOT of finding stuff out and learning to get it eventually done, if you are willing to invest that amount of dedication and commitment into it, please DO! Maybe you find your new career along the way, (because it IS fun to get it to work, I can assure you that!). But I can also tell you, that there will be times that nothing seems to work because of a tiny little mistake (or some unaccounted/missed variable) and you're ready to throw the whole idea and the display itself into the trash. If you can overcome those barriers and still have FUN doing it, DO IT! But it might be a very good idea, to get some basic understanding of electronics by trying to make something a little more responsive than an LCD to work. Start with some I2C chips and make them output some data you want on LED's etc etc. those are likely to succeed without too much knowledge to start with, and you'll get some feeling for this stuff. 

Those messages are good news, it means it is working and waiting for a connection on port 8080. Use your browser on any other machine, go to the IP address op the Raspberry Pi like this: 

There are already (or soon will be) displays available for this port, with (rumours) touch screen support. The chance of getting some other display to work is at this moment not very high, extending the cable for that special RPi display is a nice test to perform. If you did tests with this, I hope you'll be so kind to share the results with us. 

If it is possible in haskell to use the GPIO through memory, I guess so, but I have never used haskell, but there are more ways to use the GPIO pins, for example the same way you can use them in a bash script, through the 

If you don't have a problem using a soldering iron for an afternoon of nice DIY, I would suggest buying a 5v regulated power supply, like these on ebay, in combination with some wire and these connectors or similar and you can add a great amount of RPis to one supply. For example the 40A supply that is on the top of my list would have no problem at all to power 40 RPis. You'll be done for a little over 30 USD. Hub You are not going to find USB2.0 HUBs that officially supports more then 500mA per port, for the simple reason that 500mA is the maximum power output for a single USB 2.0 port according to the USB 2.0 specifications. In reality however many of the USB Hubs just connect the input power supply to all the output power contacts of the various USB output ports of the hub, meaning that you could dissipate the full power of the Hubs power supply over one port. But for this you need to open the Hub and see if it is constructed like that, if so you can also add a bigger power supply to the Hub itself and dissipate 1A per port without problem, BUT AGAIN: You need to check this on a PER HUB basis!