Pretty clearly this depends on the industry standard, but in web development, there is a move towards semantic versioning as a standard, which you can read about here: $URL$ 

Here's what I'm now considering: Since every "trait" essentially requires changes in the code anyway, so I've decided to just keep the traits (and any default data they require) in the code itself (at least for now). E.g. 

I'm trying to create a travellable map/world. I want to model able-to-be-occupied nodes/tiles/locations and allowed paths between them to create a space infinitely able to be built upon in all directions (not just flatland), in a browser-based game ( $URL$ , for a sense of it). For example your character will be in a node "a field", and could then move north into "the first floor of a shack", or south or east or west. After moving north, movement choices would then be: south back to the field, or up to the second floor of the shack. Basically, a grid maze with the minor complexity of the up and down option. What are useful methods for modeling both the inhabitable nodes and the paths between them? X,y,z euclidean coordinates and relational lists of available connections from individual nodes? Or are there alternatives to grids that could still allow fun visual representation of movement options? 

So that would be a javascript game that would be served from my website. How to check success I then want to set up a verification scheme to verify that the game has been completed, the browser would ping the website with a verification code or scheme to say "hey, I'm done, and the javascript mini-game is complete". There are two ways that I can think of to make the verification work. 

Json is still nicely readable in the database so if you're working bare to the metal with the sql and sometimes access the database directly as well, it's manually modifiable if you wish to. Now, all of that is a hack, and I don't advise copying it, but here's the overall point: Don't rely only on one system. Use a relational database and fudge the system. Or use two different types of data storage systems (e.g. flat file and relational database?), so that you can get the most benefit from both. No matter what people suggest, or what one system you go with, down the line you're going to find circumstances where another approach would work better, so be prepared to add an alternative and see where it takes you. 

I'm not really sure how to model the extra data that results (e.g. the damage that a sword will do, the damage_type, etc). I'm also not especially happy that the whole of an item would be stored in more than one place, e.g. in order to create a copy of an item with a different name, like a "short sword", I would have to copy from multiple tables to create the duplicate item. Is there a better way to lay this stuff out that I'm missing? Edit: I should just note that I've already got a postgresql database in use on the site, which is why I want to use it for my data storage. Edit: I've added an answer for the implementation that I'm currently looking at. 

Have you done something like this, and if so, what overall approach did you use to model the in-between-the-nouns behavior? 

If you have a brainstorm list of ideas you're part of the way there. Pick your favorite 2 or three and break down what you liked most about them. E.g. RTS: liked building the buildings -> make a game centered around only building buildings. dungeon-crawlingRPG: liked the combat with monsters. -> make only the combat part. no character choice, no stat or equipment choice, just the killing. Oh, and don't do it alone, get at least one other person in on it who can keep you sane. If at worst you can't get a developer, at least get someone you can bounce your ideas off of and who can play whatever simple prototype you make and who you can watch try to play it, or talk to while they play it. The second you have anything manipulatable (not balanced, not playable, just does something), get someone other than yourself to start manipulating it. Set yourself a hard definition of "a working prototype" and a hard deadline of "max prototyping hours" and pause once you reach them. Set the gamelet down for a bit, like two days, and when you come back to it, re-examine whether you can make it fun and want to add another prototyping goal to it or prototype something new. (I advise this because despite being continually full of ideas, I got myself embroiled in developing a single live, legacy game, and 7 years later I'm still trying to get it to a "fun to play" state.) Luckily, fun doesn't -require- complexity, and often you can add complexity later around a simple core for more options when you find a promising base. 

Really, games are fluid, they're concepts, and you haven't implemented your game yet, so to me, that begs the question: Why even bother doing something that seems to you excessively similar to the other concept? If there's any question in your mind that it's too similar, then it -is- too similar, by a long shot. And why would you want to put lots of work into something that someone else might consider similar as well? Now is the perfect time to throw some original ideas into the game to take it in a different direction. 

When making an npc combatant, it's easy obvious what to do to get a robot deathmachine by optimizing combat tactics, timing and attack types, but harder (and more interesting in a fight) to get an idiosyncratic, inpredictable enemy. What behaviors (algorithms?) are useful for creating a more organic, unconventional enemy? Edit: My specific use case is with MMO-like enemies, e.g. World of Warcraft, although with less graphics involved. Note that that means both human and inhuman enemies (animals, monsters, etc) 

Don't create an algorithm! Determine what you want to happen, first. Do you want player skill to trump stats? How much of a level difference should a skillful player be able to overcome? How much benefit should high level/experience/age in a character make? Does strength trump armor, or agility trump strength? Set the parameters of exactly what you -want- to happen, and then create tests of the behavior that you expect. Then when you create the actual algorithm, you won't just be shooting in the dark, you'll know whether it's doing what you want. 

Pick a skill, any skill, and excel at it Even ignoring that most game studios/indies have a ton of their own ideas to work with and aren't going to care about some random person with ideas of their own... ...have you looked around the web? It's full of nothing but game ideas, almost all of which haven't and won't come to fruition. Everyone and their little brother has game ideas, so you had better work on becoming better at bringing an idea to fruition, the hardest part. Which requires organization, or management or capital, etc. Write english instead of code Either that or write instead, which totally skips the programming aspect, though also isn't easy to get published or if self-published, get popular. You can create games with just writing, and you can create writing that feels playful like a game, if you work at it. And people will enjoy that in the way that they would a game, so why not? Pick a different language, or two, or three I would hate C++ if I were writing in it, too, which is why I don't. I write in different languages instead (I like clojure, though I often don't get to use it, and I don't hate javascript). Programming is not an identical experience across the various languages. That said, having a career of programming, well, it's different than just doing it for fun, regardless of your exact circumstances. I work from home doing web coding, and develop games on the side, but even despite that I don't have a boss, work for myself, freelance, and can use my time almost as I will, it's still stressful and you have to struggle at making money, and it'd be nice to get out into the outdoors once in a while... Try to find programming professors/mentors/coder friends that don't hate themselves Just a final note, have you really examined the attitudes of the professors that teach intro programming to crowds of not-right-for-programming kids? In my experience, they're not happy, enthusiastic people. Don't take that to heart, that's just them trying to reconcile all the horrible "programmers" that they'll be unleashing on the unsuspecting world by failing the barest minimum. Probably with heavy reliance on alcohol to get through it. If, instead, you get together with enthusiastic people who love coding, or coders who love game design ( try a game jam: $URL$ ), you might find yourself liking the experience a lot more. 

I recommend that if your overall goal is to get them to watch a large percentage of the videos, structure the videos themselves like pick-able items. Give each video a challenge rating, but don't force a linear progression, so that they can pick and choose for themselves which challenge to watch, and they can skip around as their interest changes. Then just attach some gamified badges & points to watching videos through to the end. The point being, you want to avoid at all costs making the process be a grind, so the more choice you allow for them to mix & match as their interests allow, the more they'll keep up their interest level on their own. 

With moving creatures, mobs, npcs and pcs. Though not that I'm not looking to acheive this scale, I'd probably start of showing a quarter of this content or so at any time. Probably some of the background/immobile tiles could be loaded statically. But for creatures/animals and things that can move, I'm not sure what technology solutions would be most effective. I'm aware of though I don't know whether its capabilities fit this use case. Certainly some amount of javascript is going to be necessary. Are there javascript libraries or canvas libraries out there that fit this use case? Another technology that I am not aware of? Anyone know of any examples of websites that have done anything similar to this, so that I can crib ideas from them? 

From my own personal experience, google adwords is a (relative) very cheap PR method, you can get a lot of coverage, and get "testers/players/viewers" at quite a cheap rate. 

Lately I've found myself constrained by the rigidness/difficulty of adding to relational databases. I'd love to explore document-based databases (e.g. couchdb), as they seem very suitable for games, state, and flexibility. But it's not really practical to set up multiple database types for a small project. As a result, I've set up a hack similar to just using a binary blob field in certain fields of the database. What I'm doing is using json encoded data in the database and a wrapper that converts the data into json and back out whenever it's needed. So a basic character profile might look like this in the database: 

I'd like to build a webapp for my game website that involves using text characters to represent animals and people, and have them move around on map squares with independent (server driven) AI. So essentially, a dwarf-fortress map in the browser: 

I think that the most important aspect of brainstorming is that someone write stuff down (type it, perhaps even digital-voice-record it, for later transcription/summarization), otherwise it's easy to forget intricacies of ideas that make them good. I've had great success in using an online todo list (via $URL$ basecamp) for a continuous brainstorm. When I come up with an idea (e.g. when I'm out at a restaurant), I write it down, stick it in my pocket, and add it to the online todo list later. Then, when it comes time to actually code, I pick stuff from the todo list that I actually want to do and are high priority. 

I just had an off the cuff idea of decreasing stats (strength/speed/stamina) as players level up. After all, higher level characters should have higher level of challenge! (And it's not hard to rationalize as a character aging & weakening process) I would put a minimum on the decrease, of course, and provide items, armor, and skills to provide increased offense and defense by active actions. I haven't seen this done in any game I can remember, though. What are the downsides that I'm probably missing? (apart from player dis-incentivizing). 

I've got this BBG going ( $URL$ ), and the character stats currently are simplistic. I'm looking to add a few stats to the current 1/2 (strength and maximum hitpoints, essentially). I've come up with: (strength (unchanged), speed, stamina, and some others that are somewhat interesting wildcard stats). However, I'm not satisfied with how boring the effects of some of these stats are, because they're very linear. Better stat, better effects of the stat, but the stats don't interact with each-other, there's no Rock-Paper-Scissors interaction, having more is always better all the time. So what I'd really like is to see examples of interesting character stats or effects of stats? Examples that I can think of off hand: Call of Cthulu's Insanity stat (things get really weird/chaotic if you start losing sanity) White Wolf stats, to a certain extent (the stats themselves have some basic effects, and all skills effectiveness base themselves off of stats as well) What are some other ways people have used stats to check out?