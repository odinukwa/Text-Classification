In Tales of Symphonia, Phantasia and I believe most other Tales games, you control one main character and your other characters are AI-controlled. If you're not familiar with Tales RPGs, the battles are carried out in real-time, so the option to have other characters be AI-controlled makes battles easier to manage. In Symphonia, you can set them individually to "Auto", "Semi-Auto" and "Manual" in the battle settings (which you can also change during battle). It is possible to set all characters to Auto and just see the AI plan itself out. It has a semi-strategy RPG feel if you periodically adjust these settings so the AI can react defensively or offensively. 

It's hard to visualize whether the ring is supposed to just expand, or both move away and expand, but it seems like you would want to set ringWeight according to the color mask 

In Blender 2.5 and later, select the face or edge you want to measure in Edit Mode, and turn on the Properties shelf by pressing 'N'. In here, scroll to Mesh Display > Numerics. You can select to display the edge length and the face area of the faces. To get the size of an entire object, the Properties shelf in Object Mode will list the X, Y and Z dimensions. It's right in the Transform section. 

I would represent the range arc as a spotlight model, since these types of lights stop right when they hit a wall and don't shine through. They have a set lighting angle and attenuation distance which would correspond to the characters' fire range. As you have a deferred lighting system in place already, this shouldn't be too hard to apply. Spotlights are usually represented as a mesh, so you can make it either conical or pyramid-shaped, whatever suits your needs for the game. All you gotta add are the textures. The Cansin Deferred Renderer has a spotlight rendering feature- it would probably be a good idea to see the code behind it. 

My vertex structure is not very large, using only a Vector3 for position and Byte4 for color and normal lookup info: 

Reliable rule of thumb for most colleges: if it has a TV commercial somewhere, it's probably not worth your time. Local community colleges and trade schools that don't fulfill white collar jobs are the exceptions to this rule. A college that would be worth looking into that's close to Digipen (and also in your country) is Vancouver Film School. Needless to say, this one is also of a high pedigree and you'll probably need ridiculous amounts of talent to be admitted to and keep up. 

You are on the right track about keeping the HUD out of the ECS. HUDs and game screens in general benefit greatly from inheritance, as the flow of gameplay is essentially one tree where you can branch out in different paths or backtrack in a manner that makes sense to the player. I use a variation of state pattern, where However, the HudLayer and GameScene can be condensed (in the programmatic sense) into the same type of object. I consider HUDs to be GameScenes too, in that they can contain entities and a update->display loop that may await user input. Entities in HUDs are the background, icons and text, in a similar way that characters and backgrounds on the battle screen are entities composed of graphics and locations. While this means HUDs contain elements that are part of the ECS, the HUD screens themselves are not in the ECS. Going back to inheritance, if the battle screen is considered the primary GameScene that is active, all the on-screen HUDs and menus can be children screens of the battle screen. When you open the inventory screen from the battle screen, the battle screen stops taking input and creates the inventory screen. The battle screen keeps track of the active character and what cell it is on, and any character-specific menus are loaded with this information. After making a selection and closing the menu, a value based on the selection is returned back to its parent, the battle screen, and the ECS would take care of making the character entity respond appropriately. 

Will that work, again please clarify your goal and how the current code describes the steps to get it done. (add commenting) Thanks Do you only want indexes that divide by 15 with no remainder for some reason? 

socket Fast and responsive, great for action games. The server needs to handle all clients simultaneously (concurrently) and ceaselessly. This means possibly more processing power and more memory. This means that you are running a process that doesn't stop supposedly ever (PHP isn't oft for such processes). You need a reasonably powered machine with serious bandwidth capability. This is considered more resource intensive. The code is also far more complex and often requires threads or chunking up the work into small portions and supporting multiple user request in parallel. Both threads and chunking up the workload into small pieces make the code somewhat more complicated and harder to debug. Please be aware that this means the devs need prior experience with either threads or what is basically an implementation of threads as a serial program. Also considering that most server CPU's nowadays have a bunch of cores, using threads is possibly preferred. Side-note: Generally, an indie socket based game + server could cost could somewhere in the tens of thousands of dollars to develop. This is because of the graphics and client-side programming any game would require plus the added costs of developing a stable server. 

The tricky part is multiplying this points, you have to use dot product. If you like, I have the code for this and I can share it here in the form of a function that simply returns a boolean if there is a collision or not and an angle of collision. Some problems could appear in naive implementation of a collision engine like this for instance a fast moving ball could get caught between two curves. I recommend avoiding it for now, just sum up the coefficients for the x axis and for the y axis and add them up. The use any reliable method you may choose like Newton to find the roots, check the distance from the root points on the bezier, 0 <= t <= 1 to the circle center and check the distance for the two ends of the bezier (start and end) to the circle center, whichever one is closest, will tell you if there is a collision. If the radius is smaller than the minimal distance, there is a collision. The angle is approximately the one between the center of the circle and the closest point on the bezier. That being said, if you truly wish to make a game with collision physics, I suggest you just iterate over the bezier 

So foreach point , find the closest point on the lines of the other OBB , check if they are on that OBB's segments and if not, compute the distance to the corresponding corner of the OBB. 

The kind of gameplay experience you are talking of is a result of glitches and chaos in an environment that is too complex to allow for complete testing of every possibility. The more complex the world and set of abilities you create, the more likely it is there are paths you haven't thought of. Even if there is an infinite number of ways, there are always some ways that are superior to others. A game's speedrun can only be improved up to a point and from there it's very hard to make a tiny improvement. Consider leaving in bugs like an enemy attack that knocks the player character far away allowing you to traverse over chasms you wouldn't be able to without getting hit. Another example would be that getting hit leaves you invulnerable for a second or two and you are then able to go through things like spikes that would normally instakill you. The way to create gameplay that is unpredictable is by leaving in buggy behavior, giving a set of powers that you haven't fully tested and nerfed to limit the player and letting the player / monster /environment interaction result in cool things like very strong knock back or temporary invulnerability. If all that fails you can leave in bugs like players being able to phase through walls at certain speeds. 

And I believe it's correct. Now since I need to draw it with a variable number of points, I'm trying to apply the explicit definition: 

The parameters metalness, smoothness and transparency are uniforms. I try to vary them, but I cannot get something similar to this result: 

I'm trying to draw an Earth, as I've found the textures in this site: $URL$ I loaded the diffuse, specular and bump maps: 

light{Specular | Diffuse | Ambient} : 0xffffff (converted to a rgba vector of course); materialAmbient: 0x543807 ; materialDiffuse: 0xc6901d; materialSpecular: 0xfdefce; materialShininess: 27.8974. 

But I get a result similar to a lambertian surface or Oren-Nayar model, where the specular component is absent: 

I'm trying to implement the Schlick shading model in the fragment shader. I took the formulas from Karsten Schwenk's "a survey of shading models for real-time rendering": 

Which seems very strange to me, I've seen other images of Ashkhmin-Shirley implementations on the web, and they aren't similar. This is an example: 

I checked many times the formulas and the implementation, and it seems like I've done all correctly. What's the problem? 

But I know there are more, I just can't find a resource that mentions all the built-in variables. Also, some of these variables are passed by three.js classes, I need to distinguish the built-in variables from the ones which are created by the class. Does someone have a list? 

It is practically equal to a lambert shader! I tried a lot of parameters combination, but I never get a shiny teapot like it should be. I also debugged the shader, and it seems like the specular component is zero in many parts of the teapot. I tried to add an if that makes look red all the areas where the specular component is zero, that's the result: 

I implemented the Strauss model with the metalness, transparency and smoothness parameters, taking the formulas from the book "Programming vertex geometry and pixel shaders", this is how I implemented it: 

The plist file was invalid because I renamed the image, so that the name contained in the plist file wasn't the true one. So I just made the spritesheet again with zwoptex and now everything works fine. 

First of all I don't understand why there's H and H'. Isn't the halfway vector unique for both layers? It says that just p,r and F vary from layer to layer. But the fragment is the same, so I don't understand how to compute H'; I also don't understand, for how it may seem banal, what does [F D] mean. Is that just a plain multiplication? I don't understand why it uses the bracket square syntax; To compute D' should I replace p with p' and r with r' ? 

I want one like this !! Maybe I am using wrong values of phi and other values? Or there's something wrong in the formula? 

But there is no property for the bump map. The only way that comes to my mind is to use a MDLMaterial but I see no way to convert the material back to a SCNMaterial. The method: 

All the tutorials that I've found online speak about using Metal alone, without any other supporting library. But I don't understand if it's possible to create a SceneKit game and then use a Metal layer just to make some optimizations. 

Runs just in Objective-C and not in Swift. Does anyone know how to convert it to a SCNMaterial, or alternatively to use another way to apply a bump map in a SCNMaterial?