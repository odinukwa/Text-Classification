I don't tend to focus on the memory saving aspect; memory is cheep, and early optimisation is a bad idea. “optimise for readability, and maintainability, (and big O, when they are older) let the compiler do the rest.” 

In touch of class — Bertrand Meyer, He start with the big stuff: object orientation, working programs. And then breaks it down toward the detail. So an top down approach, as opposed to the often seen bottom up. e.g. bounded loops (foreach) before unbounded loops (and how to implement bounded loops using unbounded once). Using objects before creating them. I can not see how to teach by starting with explaining each of the bricks, before teaching how to but the bricks together. I think it is better to explain what a house is, and then break it down, to explain how to make one, and as you do this explain the properties of the bricks. 

I won't tell you which one, as I don't know, and would just be my opinion. But here are some criteria. 

History In history, the history of computing could be taught. The focus would be history, with little technical knowledge needed (except what is needed to understand the history). It would include, the history of: 

I.E. there is no contract. They don't see it because it is not there. Without pre and post conditions, there are no promises, there is no contract. An example of a contract may look like this (I have to make up some syntax). 

Expecting someone to implement a particular sorting algorithm from scratch, is an impossible ask. You are asking them to invent a sorting algorithm, and be lucky that it is the correct one. (Or to already know it.) I took in some cards, and asked groups or volunteers to sort them. I then asked them to have one person to do the sort, and a 2nd to document what they did. To then write them as instructions (this is pseudo-code). Test and revise them, and then get another group to follow the instructions, to sort some card. After feedback from the other group, to revise and test once more. I then looked to see how they did it (What sorting algorithms had they discovered), and give them the names of the algorithms. Latter I would get them to implement some of them in code, using the pseudo-code as a guide. 

You can discuss what the best strategy is [binary search]. One you have a completed table (4 or 5 entries), you can start to look for a pattern. It there a general formula for a polygon. Also getting pupils to pretend to be the turtle can help, or teacher is turtle. In ether case another pupil is the instructor, that tells turtle to move and turn. While doing this they gain a deeper understanding of how the code works. 

What about some formulaic music. Music has a lot of repetition, could you get them to play some music based on a nested loop algorithm. I am thinking drumming on tables, and a lot of shouting. e.g. something like 

In Bertrand Myers book/course (I have only read the book) “Touch of Class”, he deals with this, by first teaching a language with few quirks (Eiffel). Then at the end of the course/book, after all of the concepts have been learnt, he teaches C♯, Java, C and C++, by teaching how to translate Eiffel code into each of these. It is at this point that he would cover the quirks of the languages. He has claimed that it is quicker to teach Eiffel then all 4 of the other languages at the end, than it is to teach any one of them from the start. Unfortunately I can not give testimony to this, as I already knew C, C++, and several other languages by the time I learnt Eiffel. However I now realise that I did not truly know C++, until I first learnt Eiffel. Therefore first avoid, by using a better language such as Eiffel, and then embrace by teaching how the other language(s) relate to Eiffel. (See other answers on how to embrace.) 

I think that selection needs to come after parametrised subroutines, as I don't know how to do it with out variables. However it can come before mutation (almost everything can come before mutation). 

You may have to rethink the curriculum design at a higher level ( involving other staff ). Do you kick people off the course, loosing revenue. Do you teach extra lessons to get them up to entry level, extra cost. I think it is a good idea to teach Unix. it is a very consistent operating system, making it easier to learn. However there is an initial unfamiliarity. Therefore, if students are familiar with MS-Windows, then link to it. Show how MS-Windows copied (badly) from Unix in stead of , and why. Because they had already used before they implemented directories. (Interestingly Unix made the same mistake had already been used, so they went for . I would avoid Vim (I love Vim and Emacs), but why make things difficult? You may need to cut it down, doing , and other programming, as well as shell may be too much. At least at first. Check with the bosses, on what is expected by the end of the course. If this is not feasible then you need to push back, to get thinks changed. Details of time spent on my 1st year (1991-1992) undergrad course, in the module of computer applications. In the hope that this will show what can be done in this time. Summarised from the handouts. This module was, mostly, not about computer security. However it is a prerequisite. I have it here as it is similar to the basics you talk about in the question. You will not have to teach it all, as some is not relevant. 

There are already answers here. I will add a contrary one, as this point of view is missing. When designing a program, the best ones are the ones where the business logic was designed first. Therefore it is better to design the back-end first. That is get all the processing done. Then output the data, possibly in json. Then think about how it will be displayed to the user; How the back-end will output html. However as other answers have pointed out, it will probably be better to learn the front-end stuff first. Therefore, one possible approach could be: 

However for beginners for loops, can be very confusing (I am not discussing foreach, or for in python). Therefore prefer while loops over for loops. But foreach loops over while. See image from LearnableProgramming — Bret Victor, showing program flow through a for loop. 

You say “when he is finished, he no longer fully understands them.” There is a good practice to write self documenting code. This is done not with comments, but with well named entities (methods, classes, objects). This helps you to see what the code does (I do not mean how it does it, but in turn it will help you understand how it works). Therefore teach him how to do self documenting code. Example 

The ?: operator is not syntactic sugar (OK in most languages it is, and no guarantees/checks are made). It is a different construct. is procedural or is functional The first does something, the second evaluates to something. The value is that the functional form tells you that you are doing something functional, that there are no side effects. Thus making the code easier to read (once you have the vocabulary). In this example 

Nature vs Nurture It seems that nature plays a large role: you can not teach a cat to code (even though they share approximately 90% of our DNA. However most of the variance between humans is probably nurture. See Carol Dwecks word on growth mindset, for who some learn and some don't. Note that we can have a growth mind set in some subjects, but a fixed mind set in others, “I can't do maths.”, “I can't program.”. Everyone (that can learn anything) should be able to learn to code at the level of you example. However not everyone will be excellent at it. I have taught a lot of pupils in year7 (UK), they can do this in scratch. Many of them that had good teachers in primary school, can do it when they arrive (see choice of language below). Therefore help students to get a growth mindset. Syntax vs Concept Is the student struggling with reading the language, or with the underlying concepts? If the student does not know the idea of a loop, or the higher level idea of loop until successful. Then understanding the code will be very hard, it may even rely on discovering the idea. Therefore ensure that students understand the concepts, before teaching a language. This can be done using «robot teacher/student», or other paper/acting/physical based activities. Procedural vs Functional vs … Are you teaching in the best language? What influenced your choice of language? Is it the best teaching language? vs Is it popular in industry? Bertrand Myers has claimed in (I think) “A touch of class”. That it is easier and quicker to teach Eiffel then C# and Java and …, than to teach any one of these from the start. Yes he teaches his CS student all of these languages, but starts with Eiffel, as it is easier to learn (yet also more powerful that the others, and the only pure OO language that I have seen. It is also one of the languages where all the new ideas are coming from (see also lisp) ). In a camel has two humps (an argument for natural ability, I won't go into why this research is not valid here, but there is one thing of relevance), it looks at mutating-assignment, and shows that student that don't get mutating-assignment struggle to program. Therefore teach mutating-assignment last. E.g. functional, but you can do functional in any language. Is this semi-functional program easier to read? 

I will cover “colouring n fields with p colours, no restrictions”, as the first part was covered by @Keelan. Number bases There are at least 2 special cases that they should already know: “How many values in an n bit binary number?”, and “How many values in an n digit denary number?” Ask them to answer for specific examples e.g. 1 bit, 2 bit → 8 bit. Create a table. Then find a pattern, and generalise to write a formula [$2^n$]. Then add a column for base 10, and maybe base 8, and 16 (if they have done these, in CS class). Now get them to find a pattern again, and generalise [$b^n$ where $b$ is number base, and $n$ in number of bits] Then link this to non-numberbase, problems: generalise to colours.