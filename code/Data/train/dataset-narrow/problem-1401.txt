What should I do if I want to refactor this class? I've been thinking of treating it as just a simple data structure instead of like a class, since all the does in the file is hold data about the client, but I'm not pretty sure of what to do here. There are 17 classes, and each one holds a different number of members, which stand for "fields." I'm also thinking of eliminating the extra class, since I feel it does nothing to improve the design. My intention at first was to have different kinds of "fields" like , and so on. 

I'm working on an important project. We're an IT services provider and we have a project where we have to build a new system to process data from a specific client. The problem is that usually we process their data, but they send us a pre-processed data that's easy to parse, but this time around, they're trying with a new format, which is extremely weird. Anyways, there were two senior programmers that didn't want to mess with the project, and it's been on hold for one whole year. I'm a junior programmer and I managed to build a system that kind of works as intended but I want to improve on it. I don't like the way it ended up, even if it works. The thing is, this format is for generating account statements for a local bank, and they're sending in RAW data. I managed to read and parse the data by using a configuration file that's able to read the data from it's position on the file, which can have up to 500 MB of text data. I built a method that uses reflection to fill in the data in the different classes. The data comes grouped in s, which have many fields. Each holds specific information, like transactions, client info, balances and stuff. I created a superclass called , and then made the other corresponding types of register extend from this superclass. The thing is that there are 17 different kinds of registers, and a can have from 1 to more than 30 members. I only use one from the superclass, and using reflection I can set the member variables for all the other registers. I feel that my approach is kind of stupid, even if it works, and I'd like to improve it and make it more clean. Right now the whole system has like 25 different classes and I feel that my solution is too disorganized. Any advice on how to improve on my design? I'm going to just include the code for the that contains the information for the client. We are talking about bank data here, and this code is used to generate statement accounts. Please note that the class was designed this way because that's the way the customer documented it, and the way the data is arranged in the text file we receive: This is FieldParser class: 

Now we can add and delete. But how about bulk updates? They constitute a special case because can't see that you want to propagate your update onto multiple values. So we need to tell it WHAT to update. Here is a proposal that uses the relationship between the key, the old value and the new value that should be accessible to all keys that other would have a relationship with the old value: 

So far so good. A slightly annoying thing is that we can't really read what is in the database even though we can get things in and delete them. This calls for the SELECT STATEMENT - or python's method. But(!) we need to be careful, as our database stores data internally as a s that are accessible from keys. So we need to unpack them onto something useful. As I like working with lists, I have chosen to provide lists, unless its a single value, whereby I only return the value itself: 

We have now implemented the INSERT STATEMENT in our database. Now it's time to worry about how to delete records and relationships. For this we hack the function to both take a key and a value. Why? Because otherwise we won't know whether the user wants to delete a single relationship only, OR all entries associated with the key I thereby choose that: 

Update 1 Above: Runtime test without power-functions including Janne Karila suggestion to break down the power function to x * x * x 

Next we can test our bulk-load method: together with the "many keys - shared value" which is focal in your problem: 

Next we need figure out how to get data into the database. This is similar to the SQL INSERT STATEMENT, where we maintain both our keys and values in single transactions: 

don't want to be an ass here, but in your case all the heavy lifting is actually done by which is implemented in Swift standard library (I suppose, not a swift programmer my self). All your code does is actually +-1, so there's not much field for performance improvement I suppose. Generally in order to improve performance, you need to optimize the most time consuming operation, so in this case you'd have to reimplement or implement custom sqr root method for integer, maybe based on some integer numerical approximation methods. Last but not least - this forum is IMHO rather for code style / quality review, your question rather belongs to stackoverflow.com, it's more popular so you might expect more feedback there. 

Ok, so my 5c is that just looking at the code, I can clearly see that you should rethink what each class should do and re-module the whole solution again. For example, the http communication seems scattered across both FileTailReader and RolledFileReader. After reading the aim of your task, it seems that you have a typical IN - process - OUT scenario. In this scenario all parts should be as much independent as can be, communicating between themselves through interfaces. Such decoupling would at least allow you to test each module separately. In your implementation, I think, that each IN contains some part of OUT which. Another thing - you've added some async behavior to your *Reader classes. While I'm not sure what they actually do (sorry tl;dr) you might benefit from decoupling the file parsing logic from async behaviour. Again, it might at least, allow you to easily run tests. Next thing, you create some object within classes with new(), maybe you should create them externally and pass as a constructor parameter, in other words, do dependency injection. You don't need to use any fancy framework, just create all the components in Main() in proper order and start job. If it makes sense to define an interface for any of the injected classes, consider doing it. Same goes for all hardcoded parameters - put them in a *Config class and just set as default values. 

Now we just miss one thing to pass all your test: The bulk loading method where you map N keys to M values. This is a "cartesian" product, which is a fancy word all N's maps to all M's. In Python this is a walk in the park as we can iterate over both and reuse our method: 

A dictionary can hold 1 key to N values, but not N keys to 1 value. Fortunately the reverse operation of N keys to 1 value is the reverse of the dictionary, so we can trick around this by creating a class: 

Update2 Above: Runtime test without powerfunctions and with Justin Peels recommendation to use return list(a.values()) 

This is a very basic relational database. So the first piece of feedback is that new programmers often start coding with poorly defined test-cases or non-normalised test-cases whereby they get lost developing their test portfolio. If you would have started with clarifying your case, I'm sure you would have cracked this problem. Let's start defining our operations from examples Sometimes we will have the database maintaining links: 

In test03 I need to pack the value into a list, because iterload needs two iterables. I could made my code much harder to read by accounting for many different cases, but I think the programmer should build a function for one thing and make it clear for future recall of what the function is supposed to do. In test04 - below - I have added the usage of the update function. 

This is a simple repeatable question regarding the usage of Python3's comprehensions: Could the Python3 syntax be used in another way to speed up the process, further so the gap between Python3 and numpy would be reduced? (see chart below). The results & code: