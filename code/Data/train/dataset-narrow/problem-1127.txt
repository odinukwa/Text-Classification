Item 5: And here's a version with no globals at all. It uses the class of the menu to control and discern visibility. You can see it work here: $URL$ 

Your use of in the first implementation is just wrong. In fact, it won't even work if you run your code in strict mode. When not in strict mode, in the browser. So, you're just using which is not a particularly good way to do things. gets a meaningful value if you call a constructor with the operator or you use or or you call . Otherwise, it will just be the global object (in regular mode) or in strict mode. I'd suggest this simplification which uses a function closure to store the state of the sum and returns an internal function to allow the chaining. This is OO-like solution where creates a function object that stores the current sum in a private closure and on the returned function is a means of extracting the sum and is means of adding to it and chaining is supported: 

Then, you can fetch an individual parameter anytime from the params object. In fact, you won't even need to store them all in globals since there already stored in this one variable. 

As with all things related to performance, you must measure. Here's a jsperf with your original code in it and several other iterations: $URL$ You can do several things to speed it up considerably: 

Creating a new promise when you already have a promise is considered a Promise anti-pattern. Instead, you can just use the promise that is already available to you. This then saves you all the reject handlers because if anywhere in the promise chain, there is a rejection that will propagate back. So, I think you can just do this: 

You're doing a 200ms interval on a 400ms animation or a 200ms interval on a 700ms animation. That sounds like you're asking for trouble and won't visually get what you want with two/three animations competing at the same time. You probably don't want to be recalculating the selectors every time your setInterval gets called as that's a lot of wasted CPU multiple times per second. Calculate them once before you start the setInterval and use that result. should be changed to in this code as should only be used if you're saving a reference to the removed items and reusing them later. Otherwise, does a better job cleaning up jQuery stuff and I assume you probably want to only clean up the item you are no longer hovering over: 

It appears that you're just trying to create a list of players from the id values on a list of tags and also build a comma separated list of those ids. If that's the case, you can do the entire code block like this: 

Cache since it doesn't change. Make your comparison be because you may never get . Use a larger pixel increment until you get close, then step down to a smaller increment 

Wrapping an existing promise with a manually created promise is a promise anti-pattern and should not be done. Instead, you should just return the promise you already have. If you're going to use more than one async operation and thus find you want to use rather than chain your promises with , then you can do that like this: 

Well written animation functions typically use a tweening algorithm that checks the system clock to see how much time is actually remaining in the originally specified time allotment and then adjusts the animation increment to put things back on time, even if the timer events weren't coming in exactly on time or the browser was super busy and you weren't getting all the cycles you might want or the host CPU just isn't very fast. Done well, this can even allow you to adjust the step value for smoother animations on more capable computers and coarser steps on less capable computers. As you have it, you have a hard coded step function in time of 1/10th the time and thus 1/10th the total opacity change. On capable computers, you can run much, much smoother than this. Here's an example: 

Or, if all your ajax items keep their useful ID like you have above, but have a common class name, you can do this: 

When you do need to modify the return value, you just add a handler and the modified value you return from that handler becomes the new resolved value: 

Note, there is no need to check because calling on something that is already visible just does nothing and is a slightly expensive operation because it has to check the visibility of every single parent object. 

FYI, I did not check only for the specific error like you were doing. If there's any error, then the DNS check did not succeed so in this type of structure, it seems you're looking for any single success or all of them failed (no matter why they failed). 

There's a big problem here. can either return a promise or throw synchronously which is a bad design and very unfriendly for the caller. Instead, you want any synchronous errors to be returned as a rejected promise. The beginning of your code should be changed from this: 

In , why don't you use to see if a handler is already in the array rather than do your own from scratch iteration? 

Now, it seems as an additional improvement for this particular usage, you can move the clause to a place where you don't have to save the variable to the higher scope because all paths with a successfully open go through one promise chain (assuming no exception in the handler is thrown before is called: 

There are times when you work on going for performance, but even then you don't lose sight of the priorities that come before it. 

If you explain the purpose of that, we could offer help on whether that's the right way to to it. Storing an array of a single value that's a comma separated string list of values seems a bit odd which is why I ask. 

The object already exists, so no need to wait until it loads before attaching an event handler to it. Don't cache objects outside of the event handler unless it's really needed (consumes more memory, code is less encapsulated, makes your page susceptible to problems if layout or DOM elements change, etc...) Use jQuery chaining for multiple method calls on the same jQuery object Only use one event handler and put both calls in the same event handler. 

It seems a little risky to me to just blindly use the language designation that the URL contains. If it's possible to trick Express into looking somewhere in your file system besides where you expect (perhaps with dots in the path), then you could have a security issue. It would be safer if you checked to see if it was one of a list of known-safe designations ("en", "fr", "ge", "sp", etc...). If you wanted, you could build a list of known safe designations by looking in the the file system at server startup and then just check it against that. I would also recommend using instead of adding in the path separator yourself. That will make your code more platform friendly should you ever want to run it on Windows.