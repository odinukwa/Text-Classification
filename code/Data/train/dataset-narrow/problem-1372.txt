Your seed with a defined function seems wrong. THe first thing is you are missing the braces around the if and only the first statement is inside the if. 

As a rule of thumb always use braces in nested statements. You only need one loop that goes over the array once so start with determining the sum/product of the first subarray. Also if you use unsigned data, then the result is automatically rounded down for you. 

However with less indentation and easier control flow. You should definitely reserve memory in your merge function: 

I think you routine is buggy. Also it will always return the first empty location after the first nonempty one. As an example look at , which is not the last empty location. Also from the name find empty I would expect it to return the first empty slot it finds. So if you really want the first empty spot behind the first nonempty you have to traverse from the back. Also you are inconsistent in your return value. If you found an unused value, you return , but if you did not found one then you return , which is off by one 

The main problem of your solution is that your methods have temporal dependencies. Your are manipulating the "purchase" variable on in total different states of the object without checking if it is allowed. What if someone calls the method to calculate the tax twice beforw you even have a purchase? My suggestion without providing code but providing a strategy: Try to keep your object inner state consistent whatever the call order is.... OR If your structure may be inconsistent do not encapsulate behaviour on it. Let it be a simple Value object. This will be a more functional approach. 

Sure, you may speed up your code execution. But the core problem remains: Inresponsive UI executing a long running task. If you expect the user wait for completion a long running task you should consider UI supported synchronized mechanisms to adress it. Asynchronous execution is mentioned here: $URL$ The idea is: Execute your code in a separate thread and synchronize results by publishing them through the Java FX thread. 

UPDATE Toby is right, that this only adds points to the unit circle, rather than the full area of the circle. The solution is rather simple, add a random variable for the radius 

Separate operators like with spaces, that makes the code much easier to read. Also you should separate language constructs like or with a space afterwards, to readily separate them from function calls. You should use range based loops when you already have the vector fully initialized, it is much more concise. 

This has a second advantag, now when endpos == std::string::npos nothing will happen, so we can avoid the if 

This also brings me to the bad choice of your loop variable. the iterator is called last and you compare with , which one would expect to be out of memory access. Instead define an explicit iterator and use it in your loop, avoiding confusion. 

It's a value object so recognize the immutability and hashcode/equals overriden. One other thing is the invert method which is a convenience method to express the other side around. You may consider to use "real" objects to represent "Rock", Scissor" and "Paper" instead of String-Objects. Introduce class "Result" It represents the outcome of one round. 

Sometimes it is easy to decide wether to raise an exception or not. Sometimes not. The reason for that are semantics. I will try to break it down: Something strange happens between one element in the list and zero elements in the list of hands. After all the returned element is always an element of the list given. The point at this statement isn't true anymore it's an exception. You can rephrase your function that it will return the list given sorted by excellence. Implicitly the best hand will be on top of the list. So if you input an empty list the valid output would be and empty list. There is no exception. By doing that you solved one part of the problem (best on top) and externalize the problem (are there any elements) to the caller who certainly will raise an exception. 

Regarding negative steps I would stop making my live hard and simply swap t_end and t_start. That way you can use the same code path for both cases without worrying about signs etc. If you is not a multiple of your you need to evaluate again with a smaller time step at the end of your computation. You are stuck with float or double for h. The steps are non integral so ... RK is a multistep methods, where you calculate the n-th step using the result of the n-1 th step. So it is not possible to parallelize the computation of a single step. What you can parallelize is the computation of the different ODEs. You need to really step back and consider whether your code is doing the right thing and then you should ask your self how long it took you to come to that conclusion. RK is a really simple method and your code makes it just so incredible complicated 

The complexity of this algorithm: well the worst case scenario is actually 2 consecutive Fibonacci numbers. The answer will be 1 but if this is the nth and (n+1)th Fibonacci number it will take n iterations to unravel. Thus it's complexity where N is the higher of the two numbers. 

Now we can use on . Note it changes from upper_bound before to lower_bound because of the case where our value is equal to the value. The difference between and is when the searched value equals the key, and this time we want the cell we are in, not the cell below it, so we want . If our percentage is, say 75 we would now search for -75 which falls between -80 and -70 but the lower bound is the one that has -70 because returns the first cell whose value is greater than or equal to the searched value. ( returns the first cell whose value is strictly greater. It would work for -75 but not for -70 itself). 

Missing model You are totally missing a model. I don't know if you have the intention to introduce one. But setting the text and the background color of "b1" directly in the ActionListener is across country. I'd expect the ActionListener call a model that will change. The change will be populated to "b1" again through another listener mechanism so the ActionListener isn't aware of what has to be changed in the UI. You really see the missing concept of a model by looking at following statement: 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant. 

Also you iterate from the end so you might want to think about using reverse iterators aka and When comparing or increasing iterators, you should use and or accordingly. This works with every kind of iterator. 

Have a look at your function arguments and declare those const who are not modified. Also you are always passing a copy rather a reference so you should either be dooing one of the following. 

Your insert function is bogus too. When reassigning the values, you overwrite the old ones here . This should start at seqSize+1. Similarly your insert function can benefit from 

You might even put this into variadic templates and overload min. Now you can get the minimum value and define a switch statement 

"How can I make it better?" "How can I learn to write better code and logic?" You have to know what's the difference between better and worse code. There are some general rules beginners have a at least some chance to produce ordinary code. But in real world projects even experts have problems to produce "good" code. As you are convinced that there is something like "better" or "worse" (I guess so) you are on the right way. First of all you have to train algorithmic thinking. After that you have to get a feeling what the general programming paradigm you are applying is all about (OO vs. functional programming). My suggestion is to start with only one paradigm to not be confused. I would favor OO in JAVA. But for training purposes take what you want. After you master algorithmic thinking (you are able to "SOLVE" even complex problems) and you have a basic understanding of the programming paradigm structuring code is the next step. You can slowly go into clean code as a set of best practises in programming. This will take time if you are serious. Passing every level of clean code you should study the design patterns of the GoF. Having a look at literature for object oriented analysis and design could be helpful. Then you should go into architecture and master some technologies in every layer (ui, backend, persistence). Finally the SOLID principles together with the "law of demeter" are the "Holy Grail". Applying them you are able to improve your code in every iteration you identify violations of SOLID. They will also drive architecture and you will find out the exceptions of every best practise. Now to your code: The first idea is that your code should not hide its intention. Somehow you should mention that... 

I want to see data structures and logic separated from parsing and string representation. As such you would be able to use a different method of laying out the data and only have to modify your token parsing or printing logic, not the classes themselves that hold the data structures. The class should exist whilst allowing more than one string representation / layout. Work on the grounds of data structure and algorithms and then write external parsers and printers that can parse/populate your structure or read/print them. This is where I see your design lacking extensibility. 

The main issue I see here is that you are loading in a map from a file and I see you load in the keys but cannot see anywhere where you load in the values. Loading in all the keys first isn't necessarily a bad idea, and if you do it that way then you do need to use a vector or similar container as a temporary container (so you retain the order when you read in the values). Unless you already have files in your file system that you need to load into a map, and you can't change these files, then I would take a somewhat different approach for a "generic" map read (and write). For example if you have a function to read a vector then you can use that also to read the map (by reading all the keys) then again to read the values. Note that these cannot read until "end of stream" (well particularly the key-reader cannot) so there must be a special marker to determine where these end, or a header section so you know how far to read. Once you have determined how the layout is going to be, then write the code for it. I would suggest you make this section use a generic "stream" rather than a file as such. 

My advice is to make rare use of the Optional-construct. It may make the code look "cleaner" and surly "shorter" but it brings a false sense of safety. BTW less code is no metric to follow. I would come from the other side and ask questions like: 

NEVER implement a hashcode on the base of attributes that may change. So following implementation is invalid by definition as the "id" is either expected to change or you have nonsensical objects: 

Learn the theory of sequence, selection and iteration Train your algorithmic thinking by solving problems with the elements of 1. in a programming language of your choice by increasing difficulty Get familiar with the language mechanisms Apply programming paradigms like functional or object-oriented programming Formalize you code fragments by learning the currently identified 26 design patterns and learn to to apply them in the correct situations Organize your code by following the correct semantic of each code fragment and learn and apply the SOLID principles as they guide you through the jungle of design decisions Learn the restrictions of the language you use for a problem. Maybe in another language you are able to express the solution in another way that is more elegant.