I think that this question is quite open-ended, since there are a few pieces of code you'll need before you can link the rooms properly and how you code that up depends a lot on how things make sense to you. Having said that, I can make a few recommendations to help you go in the right direction. First of all, if the room sizes are constant I'd recommend making a higher level coordinate system for the rooms. Something that would look like this: 

I would recommend starting by looking at X11, since SDL runs on top of it for Linux. My guess is that SDL will call straight to X11 for window creation and management. It's the protocol you'll be implementing in any case. If you get a window going in assembly, your graphics routines could look like anything, so SDL would merely be inspiration at that point. Keep in mind that my answer is more theory than experience, since I think the idea is a bit insane (I wouldn't reimplement either SDL or X11). Also I wouldn't expect any portability, but if you know assembly you probably know about that. Godspeed, sir. 

The simple answer is that you need to track all of the snake's body positions, not just the head and tail. If the snake is always going to stay 3 segments long, you can stick to an array of (x,y) positions of length three. When doing your movement logic, before you update the head with a new position, loop through the array from tail to head. For each position in the array, you need to change it to the next value in the array. So in some pseudo-code: 

The procedure you've described seems to be about generating a number of regions on your map. For this problem, I'd suggest using a voronoi diagram instead. A nice tutorial for generating one can be found here. I think this would be faster than your algorithm. Looking further ahead to road and building generation, there are a lot of different algorithms because of the different requirements. Is this a modern American city with sky-scrapers and suburbs or a historic Roman city with temples and 1-story buildings? This type of difference will affect what you want from your city generator. If you're interested in reading some academic stuff, I'd recommend a couple of papers on Pascal MÃ¼ller's site. 

But never actually use the data in the shader, does that incur any runtime cost at all? It's convenient for me to do this but not at the cost of slowing runtime performance at all. When I time it I don't see any difference... 

Casting requires mental discipline but also requires large amounts of energy to flow through the body. Holding the body in the right position and directing the flow with precision requires physical strength to hold the arms and the head and the fingers just "so" while huge energies are flowing through them. If your muscles are not strong you have to take it very slowly and carefully, the more physical strength you have, the more you can rely on your body to hold the necessary position while you channel the energies. Which is to say that strength affects casting speed and channeling rate. Maybe 

This is a general post about why static classes cause you more trouble than they are worth. And this includes singleton classes which are just a fancy way of doing the same thing that avoids construction order problems. No advice fits all cases, so take it as advice, not as an instruction that it is always better to do it this way. In general code shouldn't reach out to get the data that it needs to provide it's job, it should be provided with that data. I'll give an example from what you said - 

So you write you main rendering loop and in there you call something like Game::getSetting(ScreenWidth); That all works well and is nice and easy. Then one day you decide "wouldn't it be nice to let the player make screenshots. And it would be good to do them at higher resolution than the screen so they look good!". Now you have a problem. All your code depends on getting the screen size from the static getSetting function. If instead you'd provided your rendering code with the screen size instead you could simply call it with different parameters. Another problem - You write an amazingly cool user interface class for your game. It needs to know what font the user has chosen so you call Game::getSetting(UIFont) to get it. Nice and easy. But then you decide to write a separate game editor... Now in order to use your amazingly cool UI class there is a dependency on your static Game class so you need to drag in the whole of the Game class too... Which probably has dependencies on other components. Sure you can change the code to work differently, but then you have two copies to maintain. If only you'd provided the font as a parameter to the class instead of letting it go get it itsself it would be much easier. In general having functions go out and get the data they need to do their job introduces coupling between components and makes your code harder to maintain and change, and reuse, and you are better providing from outside the data that is needed either as a function call parameter or when you construct an object or whenever. And the main advantage of static data or singletons is that they are easily located in random bits of code. If you don't need random bits of code to reach out to the static data then it doesn't need to be static any more... Note that this doesn't mean you need to pass dozens of separate bits of data. You might create a group of related settings where you generally need all of them for related purposes and pass that. For example make a UserInterfaceSettingsContext structure and store the related settings needed to draw a user interface in there and pass an instance of that to anything that needs it... 

When modding games, you'll be vulnerable to legal action from two places. First, from the original game creators. I'm not sure how common this is now, but at one point making mods was against most EULA's because it required reverse engineering the game files. I'm sure there are plenty of games that still have this type of clause to try to combat hacks and cheats, however a lot of games encourage a limited form of modding by providing official tools to do so. IMO, modern gaming culture has adopted a general rule of thumb that as long as your mod is free and requires someone to own a working copy of the game, there's no real harm. In your example of GTA3, you should read the EULA that you agreed to and watch that specific modding community a bit to see what mods have been already made. Secondly, IMO more probably, you might face legal action from the owners of the copyright on the characters/places/themes that you want to import into the game. There has been at least one recent example of a cease and desist letter sent to modders because they were using copyright content. In your example, the owner would be DC Comics. Satires/parodies often have a lawyer on staff and take care to scrub out every trademark or direct reference to the material they're covering. To sum up: Selling a mod will probably get you in trouble. Distributing mods to your friends will probably get you in trouble if you're using themes that are copyright or trademark. The general rule is to ask a lawyer (I am not one, the internet doesn't count either). 

I once used Excel to help a designer give me a list of simple football plays for a football mini-game. Basically the requirements were for 8-10 destination sets for 6 linesmen on the field. The game itself (engine and all) was still under heavy development. I took an image of a football field and aligned it so that the coordinates were the same as in game, then made a point graph overlay to represent the positions of the linesmen. The designer, then simply needed to type in the coordinates that he wanted by trial and error. Of course instead of using this tool, he played around with photoshop leading to yet more iteration, but that's beside the point. The point is that Excel is extremely general purpose and can be used for almost anything. 

I'm having trouble understanding some of the math behind normal map textures even though I've got it to work using borrowed code, I want to understand it. I have a terrain based on a heightmap. I'm generating a mesh of triangles at load time and rendering that mesh. Now for each vertex I need to calculate a normal, a tangent, and a bitangent. My understanding is as follows, have I got this right? normal is a unit vector facing outwards from the surface of the triangle. For a vertex I take the average of the normals of the triangles using that vertex. tangent is a unit vector in the direction of the 'u' coordinates of the texture map. As my texture u,v coordinates follow the x and y coordinates of the terrain, then my understanding is that this vector is simply the vector along the surface in the x direction. So should be able to calculate this as simply the difference between vertices in the x direction to get a vector, (and normalize it). bitangent is a unit vector in the direction of the 'v' coordinates of the texture map. As my texture u,v coordinates follow the x and y coordinates of the terrain, then my understanding is that this vector is simply the vector along the surface in the y direction. So should be able to calculate this as simply the difference between vertices in the y direction to get a vector, (and normalize it). However the code I have borrowed seems much more complicated than this and takes into account the actual values of u, and v at each vertex which I don't understand the need for as they increase in exactly the same direction as x, and y. I implemented what I thought from above, and it simply doesn't work, the normals are clearly not working for lighting. Have I misunderstood something? Or can someone explain to me the physical meaning of the tangent and bitangent vectors when applied to a mesh generated from a hightmap like this, when u and v texture coordinates map along the x and y directions. Thanks for any help understanding this. 

I think the inherent difficulty here is that RPG's are generally about investing time in exchange for character progress. People who invest large amounts of time should, almost by definition, have a further progressed character. Speaking as a person who falls quite squarely into the 'casual' label, I don't see this as a problem until it limits interaction between characters with different power/progress levels. As such, I would focus on ways of eliminating large power differentials that are the barrier to character interaction. It's possible that the 'hardcore' players require this power differential to enjoy the game, and in that case it becomes very difficult to balance. I would do two major things different than MMORPGs I've played. I would put the bulk of the content in the leveling game rather than in the end game, and I would make some sort of power scaling system (such as seen in Guild Wars 2). I would do this in the hope that some players could play the same character through multiple parallel story lines, and some could start a new character each time, and they would be able to play together whenever they wanted. The remaining issue is then why would a full level character play lower level content. I would try to solve this with distinct flavours or themes per area. This would make it interesting to explore the whole breadth of the game. I would also try to solve this by spreading out the best-in-slot equipment over as much of the game as possible, so that a min/max-er would have incentive to play the whole breadth of the game. There are many other techniques that can be supplemented, such as rested XP for time logged off, micro-transaction purchases, and per-day XP caps. I wouldn't put too much focus on them because I've seen them implemented and haven't been impressed. 

You can then find the next position for the snake's head and set snakeArray[0] to that. If you're going to be making the snakes grow and shrink a lot, then consider the linked list answers. Lists will make your life easier, but are not mandatory. 

The idea being that when you're making room (0,0) you ask rooms (-1,0) (0,-1) (1,0) and (0,1) where the adjoining doors are. If you need screen coords, it should be easy enough to add a GetScreenCoords method or a transform matrix if you're into those. Next you'll want to be able to query the list of rooms. Going through all of the rooms in your list (up to 5000!) just to find the neighbouring rooms will get costly. For a quick way to get things up and running, I'd recommend using a instead. This way when you're making room (0,0) you ask for existing neighbouring rooms you simply ask for etc. and to add your newly generated room at (0,0) you'd do If this becomes too slow, it might be worth looking at sorted lists. Perhaps a sorted list(x) of sorted lists(y). Finally you'll need to add some way to get the door position from the neighbouring rooms. A new method like should do the trick. I'm sure there will be a lot more work for you to code a full solution. I hope this will help you get started.