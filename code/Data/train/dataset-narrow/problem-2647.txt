In my opinion as perfectionist GLFW is the better choice. Because it does exactly what one wants, nothing less nothing more. The very active development is also a good sign for long term projects because it usually means that bugs will be fixed, that new features will be added, it will keep up with newer standards and that it won't be abadoned anytime near. This isn't important for a quick port or a 6-month game, but for a engine or a library you want to reuse I would keep that in mind. 

In most games the physics are not synchronized as it either requires a lot bandwidth or a completely synchronized network code. The synchronized network approach means that at the start all data is the same for all clients, and the whole game is calculated on each client in the same time steps. Just the controls the players push are transferred. If all game logic is deterministic then all games will keep in complete synchronization. Upside of this is that this approach only needs a few kbit's to work properly, no matter how complex the game is. Downside is that the controls of the players are delayed by the lag and that it requires a fixed time step that is the same for every player. A fixed time step also means that if one player lags all players will notice that lag. This approach is/was used by strategy games mostly due to the large amount of units. A quick note about determinism, floating point implementations can differ from processor to processor, so they are deterministic as long all devices you target have the same floating point implementation, if you can't be sure of it you'll need a physics library which uses fixed point math. 

Old MUDs and Talkers (mostly the talker code bases) would use an array of arrays of structs for keeping lookups only to possible alphabetic matches. This would be done with 

Solution: You only detect and react to a collision on an object once per frame. This would move the second collision detection in step 3 to the next frame so that it will not enter an infinite loop and freeze. Problems with the solution: If the two objects are not springs, but are instead solid objects you will see an age-old problem where it will look like the object shoots out at very high velocities from where it was. This may or may not be an issue either by the design of the game in question or simply because it would not matter if it does happen. Two common solutions when this happen, both of which require detection of the situation, is to remove the object either outright, or apply damage to it or the like or to alternately scan for the nearest 'open' area and move the object to that location. Hope this helps 

Basically Update() updates its internal state so advance the animation to where it should be for its time stamp, if it reaches the end it should then go to the next animation (mark it as active, deactivate this one.. however you want to do that part based on your component systems flow). This lets you put your FSM in to data, the animations know where they exist within the data they have loaded (Good for having a single 'Jump' animation but where you want the jump to have 'Jump', 'Jumping', 'Falling' and 'Landing' at different key frame indexes within that data). Again, end of the week brain dump to help get you going in the direction you want to go in :) I hope this helps. 

Add this script to your LineRenderer GameObject. It will allow you to set the SortingLayer and the SortingOrder in that Layer for your LineRenderer and correctly draw it with an additive material. 

If you're just looking to make your game compatible with some older devices consider using Quality Settings . Go to Edit->Project Settings->Quality Settings to set up each level and instruct Unity to use full size textures/half size etc.... Then add a Menu Scene that will load first allowing the User to select the settings he wants for his devices. 

When a Resource is Loaded its not actually Instantiated and added to the Scene so Awake() is never called. Change your code to something like the following: 

Limit Velocity Over Lifetime->Dampen in the Editor. From Unity Docs: "(0-1) value that controls how much the exceeding velocity should be dampened. For example, a value of 0.5 will dampen exceeding velocity by 50%." For best results set Speed under Limit Velocity Over Lifetime to a Curve that shows how you want the particles velocity to react over its lifetime then use Dampen to fine tune it to your liking. 

I have an app made in Unity3d for android and iOS. In it, the user has the ability to link their accounts with Facebook and Twitter. For Facebook I use their Unity plugin, for Twitter, I open an external browser page that lets them accept or decline Twitter integration that then redirects to a php page the calls the app URI to return focus to Unity. On Android this all works perfectly using an Intent in the Manifest. In IOS I'm running into issues though and I don't really know my way around XCode. I'm using the newest version, XCode 7 Beta 2. The App runs as expected but for both the Facebook and Twitter authentications, upon returning focus to the App from the Browser, it completely restarts the App as if just launched rather then returning from a suspended state. In the Unity build I have "Run in Background" selected. I setup the URL Scheme in XCode. Its a pretty basic app so I don't think its being closed due to Memory usage. Any ideas or any settings I can change in XCode that might be preventing it from resuming? *Note, if I just hit Home and send the App to the background it will properly resume, its only when called by the URI from the browser that it seems to completely restart. 

Scripts are written for a scripting language. People can use the words in slang sentences to get the muddling that you are referring to but ask anyone for the definitions of Script, Scripting and Scripting Language and you will get something like: Scripting is the act of writing Scripts using a Scripting Language. When you embed a scripting language into a game engine, or core language as you are referring to, you are exposing not only the objects within the game engine but also allowing logic to be written for the game engine. One other thing of note is that this turns your game into kind of a virtual machine, as scripting languages seldom compile down to machine language and are instead put into a form of byte code and interpreted at run time by your game engine. This has some huge benefits to the development team, a few of which you can find listed next: 

Now some caveats to this.. I do not have the code and have not tested it. What I do hope I am showing however is that you separate out a measurement of the tilt that is not going to be used for motion. I called it carTilt in this case. You can then decrease this over time instead of instantly and use it to return the car to its 0 orientation smoothly. Hope this helps. 

I'm working on converting a dx11 shader from a .fx file for use in Unity3D and I'm a little puzzled by the HLSL Buffer<> type declared in the shader. More specifically, what are these and how can I implement them in Unity? I'm aware of the Structured, Append, and Consume Buffers but those appear to be different then this and the Microsoft documentation wasn't to helpful. Is it just like an array that is populated and sized from code before getting assigned to the shader? Are they read only or writable as well? So far I'm thinking the closest approximation I can use is a StructuredBuffer but the .fx file has its own declaration for that as well so I'm not entirely sure I should go that route. Example: 

} 1.) Consider using Transform.LookAt to simplify the rotation. 2.) In your movement code, myTransform.Up represents the Up vector of the transform in local spcae, so if your model is tipped off center then Up will no longer point Up in world space. Use Vector3.Up as MistaGiggles suggests. 3.) You can make your enemy hover above the player by adding an Offset amount for the Y axis like the sample code above. Additional way to rotate your enemy based on your comment: 1.) Get the normalized vector from enemy to player and assign it to Transform.Right, which would be your X axis. Unity takes care of updating the Transform's rotation internally when you set Up/Right/Forward manually. 

About the actual question: The coordinates of the entities themselves should be absolute because relative coordinates would have to be converted whenever you do position depended calculations which should also work over map borders. 

It depends on your game. The containers are different in how fast the access to a specific element is, how quickly a element is removed and how quickly a element is added. 

Your question could be renamed to "Will having millions of people seeing my game improve my sales?" People will only buy your game if they know of it. When your game is greenlit, it will be published and more importantly "announced" on Steam. Which means most people who use Steam (50 million according to Wikipedia) will get notified that your game is available. That's a insane amount of people and will result in a lot sales, probably enough to form a critical mass (that's it, that enough people talk about your game that your game will make constantly sales without being announced on other platforms). Note however, that you already need publicity to get the game greenlit at all. That's not easy at all. Greenlight is not made to live solely on it's own but rather that you have to bring the people to vote for your game, it's not possible to reach the greenlight amount of votes without having a big community already. On the other side, being on Greenlight is already a form of publicity, which will bring more people to your game than most other platforms will. 

I am not sure you can answer this question but I feel an explanation as to why might be a helpful enough answer. So, Answers in a nutshell: 

Disclaimer: I have not programmed for the android. There might be two things going on here.. When rotating pretty much anything you want to do it around the center point of the object in question.. So where you are calculating the center for the current sprite shown (width and height divided by two) you may also need to include the current frame offset. The m.preRotate() may be handling this but I am not sure, and this would skew the frames aside from the initial one. Second is if you are using all 66 texels (pixels of a texture) of the frame, then when you start rotating and it does the sampling of the texture through rotation to screen pixel coordinates you will start noticing fuzzy or jagged edges. You may want to put a little padding on your animation frames or 1-2 pixels per edge so your animations are 68 or 70 texels wide. This hides the fuzzy or jagged edges by making it blend together completely transparent texels into a screen pixel. Hope this might give you some things to look into, but again, I have not programmed for an android before so I have no way to test this.. Just issues I have run into on the PSP and Zunes over the years. 

There is nothing on the client side which can not be faked, everything somebody has physical access to can be manipulated. The IP contains routing information and thus hints on the location. But the player just needs a proxy and whoops... the IP hints at a completely different location than the player actually is. Trust your players, don't give them a reason to try to trick the system in the first place. 

It all derives from the western writing system most people are used to, it reads and write from the left to the right and due to the amount of text nowadays this order is linked in our mind, from sketches, to coordinate systems, to visual flow. After a time it's perceived as natural flow, even though left and right actually plays almost no difference in nature. This of course finds itself into technology and everything else human made, such as games. 

Classes and objects are just bundled functionality, nothing more. And that way you should work with them. Ideally you should build your classes around composition. The more advanced object should consist out of multiple smaller objects, and do all the communication needed between the smaller objects. The smaller objects should do nothing on their own and should know nothing about their parent. They just should do what is wanted from them. In the case of this question that would look like this: 

I have a texture shown over the screen using screen space UV's. The Texture is 495x,596x, Screen size is 888,500, but can change. The Texture has a Tile of (3.469775f,1.392644f) to correct for distortion from being stretched to the Screen's size, and has repeat set to Clamped. So basically, I'm showing a Texture of an arbitrary size on screen and using Tile and Offset in the shader to correct for distortion and keep the texture at its original aspect ratio. Now my problem is I want to Zoom in and out by a set pixel amount in Screen space. So lets say: I need the texture to increase in width by 10 pixels in screen space. What is a formula I can use to recalculate the Tile and Offset so that the texture stays at the same aspect it was but increases by the amount I want it zoomed? I've been trying things like: 1 Pixel = (1f / Camera.main.pixelWidth). So to zoom by 10 pixels I would go something like Tile.x += (10f * (1f / Camera.main.pixelWidth)); But this doesn't seem quite right, I'm not seeing it increase the Texture by the right number of pixels... My current function is something like this, but for Zoom = 5f, it's only enlarging by about 2px. AspectRatio = Tiling in the Material and WidthOffset/HeightOffset is just the Offset. 

There are no guidelines or rules for that. But keep in mind that it should be practical, write it down in a way you could use it as reference when developing it. You should have developed a few games haven't you? (If not you will probably have a hard time getting a job as game designer.) 

The most important difference between Flash games and Android games is that Flash games are pretty much exclusively financed by ads while Android games are partially financed by ads, partially by selling the games themselves and partially by in-game purchases. For the customers that means they don't have to pay for their games, they can play as many games as they want and can try out any game at any given time, this means, in the end that if your game is good it will get at least some attention. The downside is, you are bound to have a lot more people to play your game, because the average every player will just give you a penny or two as opposed to a dollar or two for android games. Conclusion: 

So far so good, now we can already check if the two hexagon's intersect. But it get's even better. This solution will work for any convex shapes (for example triangles) and any sweeped convex shapes (for example sweeped octagons). However the more complex the shape the less effective it will be.