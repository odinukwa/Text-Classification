However, in real gear the whole process behind this parameter is implemented in hardware, and this setting is currently simply ignored by Dynamips' implementation of the NM-16ESW module. Dynamips implements its own garbage collection system which deletes old MAC entries after only 30 seconds, making CAM overflow attacks noticeably more tricky to stabilize (but may be a good training against the "backpressure" functionality described by Łukasz). The code in charge of this can be found around line 2516 of the dev_nm_16esw.c file: 

I will now take each of these point individually. Knowing where difference with real gears lies For performance reasons, a lot of switch things are actually not part of the IOS code but are implemented in hardware. This includes the ARL, or Address Resolution Logic, which provides all the methods to add, remove and lookup entries in the MAC address table. Therefore, for the NM-16ESW module to work in GNS3, Dynamips had to reimplement all these normally hardware provided services, or at least push this far enough to allow an unmodified IOS to run on it correctly. The sad thing is indeed that this is unfinished work, as stated in this module's source code header: 

Most high end network equipment (switches and routers) can act as a NTP-server for hosts in the network, but I cant find any information on how stable these are. Does anyone have any information or insight? Edit: So, my actual question is: Are switches and routers usable as ntp servers in a network? Or should we go for specific hardware? 

Consider a scenario where I have two border routers one peering with ISP A and the other peering with ISP B. Let say I receive full tables from both ISP A&B. Internally we run OSPF and my question is how do I make sure that outgoing packages are routed to the correct border router in the first place? If the best path to a certain prefix is via ISP A packages should always be directed to B1 and not B2 to avoid the extra hop. 

My first question has to do with the links between Core and aggregation. I could use MC-LAG (Dell VLT), Stacking or just OSPF everywhere. 

I've raised this issue to GNS3 teams so it can be fixed in GNS3 future updates. I also advocated to raise the MAC table garbage collection timeout from the current 15 seconds to 5 minutes in order to be closer to real gear behavior. Until this gets fixed upstream, it requires a manual modification and recompilation of Dynamips source code but this is a very quick and simple process (there is no need to recompile the whole GNS3, only the binary, and I provided the patches in the tickets linked above). 

Now, let's see how a switch works when the CAM overflow condition has been triggered and he did fallback into the so-called "hub" mode... Actually all of this is just nonsense: there is no hub mode and the CAM overflow triggered strictly nothing. The switch just continues to work as it always did: 

For the short answer: yes, CAM overflow attacks can be simulated in GNS3, however this goes with a few requirements: 

On every vlan I have two ip ranges (for historical reasons). To PXE boot machines on these vlans I use ip helper/dhcp relay to relay requests onto the vlan where the dhcp server sits. But the dhcp server only handles DHCP requests for one of the ip ranges (the one used as source address in the relayed dhcp message). How could I tell my dhcp server så accept dhcp requests for multiple subnets from one specific IP? 

Ok, lets try again. It seems Im having problem asking the right questions so lets take it from the beginning. I work at a HPC center at a university. We have a number of small (<300 nodes) clusters and a few storage systems. To our site we get a statically routed /22 network. Today we have the whole /22 in a single broadcast domain and we have decided to redesign and renumber the network for better scalability and performance. To do this we have bought two new L3 switches (Dell s6000-on) to use as our backbone. Connected to these we will have the aggregation switches of the individual clusters (which are HP 5400) and it will look something like this: 

So you're warned: as stated in Łukasz's answer forget about QoS and expect some oddities. Hopefully here we are not dealing with QoS but with CAM overflow, and except the final bug (of which the correction should be included in some future GNS3 release, I hope) there are two main oddities which are of concern to us: one is affecting the MAC address table size and the other the MAC address aging process. First difference: the MAC address table size tops at 8189 entries This was the main topic of your question but is in fact a non-issue. The CAM overflow attack exploits the fact that a switch is not able to add any new entry to its CAM table, and therefore fallbacks into "behaving like a hub" (as it is often described, I'll come back on this later). Most probably due to a minor bug, it seems that the MAC table is considered full at 8189 entries instead of 8192. However, full still means full: the ARL will still fail to store any supplementary entry and the CAM overflow attack will still be successful. Second difference: the setting is not honored By default, MAC entries should remain the MAC address table for at least 5 minutes (=300 seconds), as defined by the setting: 

First of all 802.11g is 2.4Ghz only and 802.11a is 5GHz only. If you don't have a dual band client (a+g) it can only connect to g OR a depending on what band your client supports. 802.11n can do both 2.4GHz (gn) and 5GHz (an) depending on your AP. A 2.4GHz 802.11n (gn) device can always behave as a 802.11g device because the n only means bigger channel width (40MHz) and up to four spatial streams. But it can revert back to using just one spatial stream if there is a 802.11g client. The same is true for a 5GHz 802.11n (an) device, it can also revert back to fewer streams if needed. Please have a look at: $URL$ 

I have a full mesh core network running OSPF. I use OSPF down to the "L3 Agg switches". Now I want to restrict traffic between some of the networks at our site, but how is this done when there is multiple routes to every network? Behind every "L3 Agg switch" there is a cluster that in some cases need to be isolated from the rest of the network. 

This flag is re-enabled whenever the switch receives a new packet from the corresponding MAC address, keeping active addresses in the table. You will have to take this behavior into account in order to design a successful CAM overflow attack: 

This launches the function every 15 seconds. What this function does is to scan the whole CAM table and check a hit flag associated to each MAC address: 

On incoming packets, if and only if the source MAC address is not present in the table will the CAM overflow have any effect since the switch will have no free slot to add this new one and will therefore skip this step. If the address is already present in the table, the switch will reset its aging timer as usual. On outgoing packets, if and only if the destination MAC address is not present in the table will the switch indeed send the packet through "all" of its interfaces. If the MAC address is present in the table, the switch has strictly no reason to act weirdly: it will simply proceed as usual and send the packet only through the port associated to the MAC address. 

Now we want to renumber the hosts with private IP-adresses (one net per cluster) and use OSPF internally, to reach the internet we still use a default route to some central university router. One important thing is that we still need to have some hosts with public IPs reachable from the internet (a few login nodes per cluster and some other services). 

In classful networks the class is determined by the leading four bits in the ip-address. B-networks start with 10 (binary). So, in fact 190.28.0.0 is a Class B network. $URL$ When it comes to CIDR you can say nothing about the size of a network from just 190.28.0.0. But 190.28.0.0/16 tells me there is 16 bits in the network part of the address and the remaining 16 are host bits. Since ip-address calculations are performed in binary, to find a netmask that will divide a /16 into 8 subnets you do the calculation 2^x = 8 (looking for how many digits you need in a binary number to have 8 combinations) which is 3. So, a /16 can be divided into 8 /19.