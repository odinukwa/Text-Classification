How do you bridge the gap between the library's low-level event system and your engine's high-level event system? (I'm not necessarily talking about key events, but also about quit events.) At the top level of my event system, I send out , and others of this kind. These high-level events only contain the abstract values of the keys (they don't say that Space way pressed, but that the JumpKey was pressed, for example). Whose responsibility should it be to map the "JumpKey" to an actual key on the keyboard? 

I've seen some games from the early 2000s that had a launcher where you could select the rendering engine you wanted to use: DirectX or OpenGL. Maybe I haven't looked hard enough, but I haven't seen anything like this lately so I have two questions: 

Currently I'm doing some prototyping with physics in Python and I later plan to port the code over to C++. Box2D has some features that I really like so I'd rather use that library instead. The problem is that the Python port of Box2D is pretty tedious to install and I'm lazy, :D while the Chipmunk port is very easy to install. Is it hard for me to switch libraries later on when I port the code to C++? (Will I have to do big architectural changes?) 

All these types of decisions they have to do seem like they should be implemented in different components. But how should I manage them? How can I give different components different weights that reflect the importance of each decision (in a given situation)? I would need some other component that acts as a manager, but do you have any tips on how I should implement it? Or maybe there's a better solution?... 

Given two joints that define a bone, I would like to know how to decide where, between those two joints, I should draw the sprite. This should be a fairly simple thing to solve, but there is one thing that I am not sure about. After I've determined the rotation of the sprite (which is the absolute angle the joints form with the x-axis), I also need to determine the origin point from where I need to start drawing the transformed image. So how should I position the sprite between the two joints? Should I make the center of the image be the midpoint between the two joints, or should I make one the of the joints be the origin? Do these things matter that much (could the wrong positioning make the sprite move oddly during the animation)? 

I would like to ask about how vertical camera movement should be handled in a platformer in which the player changes his Y position frequently. For the past two days I've tried to adjust the camera movement and I haven't made any satisfying progress. In principle, the camera's height should change as infrequently as possible, to avoid causing nausea. It also has to react quickly enough to the player's change in direction so he could see where he's going. An example of vertical camera movement done very, very well is in Rayman: Origins or Rayman: Legends. How did you think vertical camera movement should be done in a platformer? 

There are a few things I think could be problematic in this setup. For one, if you look at the function you will see that the Entity forwards the event to the controller as well as to the representation. The controller uses the event to alter the state of the Entity; the representation however uses it to alter its own state (to use some other animation, to decide whether it should play a sound, etc.). This means the representation has a state of its own which is characteristic to this Entity only. Do you think it's bad that each representation can only be used for one Entity? (Note: this does not mean that in case there are two entities using the same sprite, that sprite is loaded twice in memory: the sprite itself is a common resource.) Another thing I'm having problems with the deciding how to organize the actual entity data on disk. Where should the bounding box info be read from: the animation or somewhere separate? should there be a single animation file for each character? should scripts be separate from the data or should everything related to one type of entity be stored in a single folder (scripts and animation and sounds)? 

What are good free and widely used tools for editing 2D sprite-based game levels? I'm looking for one that allows exporting data to a custom format. One that I know of is Blender — a 3D tool, primarily, but can be used for 2D art as well — which also supports Python scripts for exporting data. 

I'm trying to learn about dynamic shadows for 2D graphics. While I understand the basic ideas behind determining what areas should be lit and which should be in shadow, I don't know how I would "lighten" a texture in the first place. Could you go over various popular techniques for lighting a texture and what (dis)advantages each one has? Also, how is lighting a texture with colored light different from using white light? 

On the other hand, if you store the position inside the entity script, the advantages and disadvantages are exactly the opposite of the above. 

As you can see from the bone hierarchy, the legs are not children of the torso. This is because I extruded them from the lower part of the torso bone. Is there any way I can fix this? Also, on another note, would this be a good skeleton for 2D animations? 

Various versions of DirectX are available on both Windows and Xbox. Are the libraries the same on both platforms? Obviosly I'm talking about the interfaces — such as the ones for working with windows, input, etc —, not their actual implementation. 

There's a small open-source game called Sand Traps. It's about sand, not water, but the mechanics are rather similar. The game is for Wii homebrew, but maybe you can still learn something. Here's the WiiBrew page (liks to source): ► $URL$ And here's a gameplay video where you can see the code in action: ► $URL$ 

tl;dr Can you give some some general advice on how the Entity should interact with its controller and its representation (i.e. sprites and sounds). Also, do you have any advice on how the data itself should be organized on the hard-drive? 

Unless you know of a third-party service for leader boards that can be used on all devices, you'll have to write platform specific code. The wiki has a tutorial on that. 

I want to make a game where you have to run over a bunch of zombies with your car. When moving around, the zombies have a few things to take into consideration: 

I am just getting started with Unity and I'd like to ask a question. If I have a "Vehicle" object that has two children: "FrontWheel" and "BackWheel" (both 'wheels' are cylinders), how should I set everything up such that I can move the entire vehicle by turning its wheels? When I apply a torque to "FrontWheel", the vehicle starts to move, but instead of the whole thing the moving together, the chassis is rolling on the cylinders and eventually falls off. How can I prevent it from doing that? 

Sometime in the near future I'll release my first Android game. It's not going to be anything special, but I'm trying to make it as polished as possible and I would like to know what I can do to prevent it from falling into obscurity. If you look hard enough, you can find some pretty well-crafted games on the Play Store that, nonetheless, are virtually unknown. I recently came across one developer that has published six well made games that are pretty fun and have good art as well; out of these six, two are moderately popular (10,000–50,000 downloads), while the rest have very few downloads (1,000 or fewer). What are some techniques to increase your game's visibility on Google Play upon its launch? 

I assume your object's position in the world is not the same as its "center" (otherwise, if you specified the center in local coordinates it would always be the zero vector). It all depends on your requirements, but I would imagine that specifying the "center" (whatever you define the center to be) in local coordinates would be easier since whenever your object moves you would not need to update its center vector as well. 

Edit: The should have two children: a and a . The will have as children all the things you want to appear in the left of the screen, such as score. The will be the parent of the and any other actors you have in your game. 

I understand SGV images are used in 2D games to store shape data for the physics engine of the game. I'm unsure though, should the raster sprite also be stored in the SVG or should it be separate? Also, what about animated sprites? In a non-skeletal-based animation system, how should the shape of the character be handled? Is a simple rectangle enough? 

I'm trying to determine what format the shapes in my 2D game should be stored in and also what software I should use to aid in making the actual shapes. Up until now I used PhysicsEditor from code'n'web, which saves shape information in XML format. The problem is that the way the file is layed out, it will require a lot of parsing to extract the actual information I'm interested in. I've made my own "format" for storing shape information (see below). I used JSON instead of XML since it's a lot less verbose. Layed out like this, I require minimal parsing to get the actual information. 

That components have a way to communicate between themselves very fast (this implies passing the right components to all other components that need them, so they are able to access them directly). There's a messaging system in place so that components can inform each other when something rare happens, without having to check their state every frame for something that only happens very rarely, like sending a message when the player gets hit. 

I'm a complete Blender novice and I'm trying to create a humanoid skeleton. I'm having problems figuring out how to make my leg bones children of the torso bone. Here's how my skeleton looks like: 

What public animation file formats are there available for 2D games? I'd like to know about both formats for procedural/skeletal animation, as well as traditional animation. 

The question is about how to handle data about entities, but not particularly useful to the entity itself. An example of such data may be the external script that controls the entity's behavior or the path to the animation file — such data is gathered when loading the entity and is no longer useful until you save the game; it certainly doesn't belong in the entity object. Any tips on how to handle metadata? 

In a 2D physics-based platformer game that has ladders in it, how do you determine whether the player moving up is caused by a jump or him climbing a ladder, such that you know what animation to play? And in general, obviously the direction vector is not enought to determine the animation to play: how do you also determine the cause of the movement (so you know the correct sprite to use)? 

... or better yet, removing the need to search the map altogether. I'm either looking for suggestions on how to optimize my code, or a change in design. In my component-based entity system, the Entity is comprised of Attribute and Behavior objects. The Behavior objects are just stored in an std::vector; they are no issue, I just call their update function. Attributes, I store in a map of and they represent the path of communication between Behaviors (Behaviors never interact directly). When a Behavior needs an attribute it searches its Entity's map. That's a bit problematic for Behaviors that access that information a few times a second, like the Rendering behavior (draws the Entity on-screen). Rendering needs to read the Position, the Orientation, and a few other things, and it needs to do that a few times a second. How can I solve this issue? It should also be noted that the base classes Entity, Attribute, and Behavior are written in C++, but their implementations in Python.