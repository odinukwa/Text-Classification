My worry here is that there is no general solution other than to improve any question when you reuse it based on the answers you saw in the past. I have to admit that, even as a very experienced Java developer who is also very Pattern literate, I missed it entirely since I didn't actually read the Javadoc before I looked at the code. I came up with only minor quibbles. The specific problem here is that I was looking at the Class in isolation, not as part of a larger whole. Also, I was reading the class, not writing it. I'm pretty sure that if I were writing it I'd have built a Singleton in some form instead. But, you can't expect that every student will notice everything, and you can expect that some students (me, perhaps) will get lost in the detail before analyzing the bigger picture. On the other hand, missing the point of your exercise can lead to a forehead slapping A-Ha moment for some students that is valuable in its own way, as long as they don't feel that they are punished in some way for missing it. It isn't a general solution, but had you here, or in general, emphasized to the students to RTFD (Read The Full Documentation) then more of the students would be likely to get it right. But that is a general prescription for how you teach about programming, not a specific recommendation for this sort of question. "Be sure you understand the intent of a class before you worry about its details" is a good lesson. For this one, though, perhaps making the Javadoc more complete (longer) would have helped a bit. A longer explanation before the start of the actual code would be less likely to be missed. Making it obvious would also help (A Singleton is required here) but likely defeat your purpose. It would, however, be essential in production code to be just that obvious. Even saying the key thing twice would help. 

I'll assume that you mean a first programming course that uses a language (Java...) that has well integrated testing tools. If you just use unit testing as an add-on then I'd guess the proper answer is no. There are other things the student could be doing. However, if you are willing and able to modify your teaching a bit then unit testing can be a big win. I've used it in teaching introductory programming to adults for years (since back when Extreme Programming was young). I do two things. First, I give out assignments differently at the beginning. Rather than giving students a narrative to describe a programming exercise or project, in which they must first decompose the description into tasks, I give them the task list itself. In Agile Programming language, I give them a small product backlog or story-card deck. The tasks are numbered in a logical (do this first) order so that when the backlog is completed the project is done. Therefore I'm using a bit more than just unit testing. Other "personal" agile programming practices are employed, including pair programming. I also act at the student's Customer, answering questions as needed. The second thing I do: On the first day of class I do a demo project in public. I start with a small number of "stories"; tasks that decompose a simple project. I pick out a student (volunteer or other) and we pair program on a laptop connected to a projector so all can watch. I start out as the "driver" with control of the keyboard and my student is the "navigator". He or she may know nothing of programming, or very little. We look at the first story, discuss it a bit to get a "picture"/analogy/metaphor. I then fire up Eclipse, start a new project add JUnit to the project and write a test for just that one card. It fails of course. So then we (my nav and I) write app code to make that test pass. Repeat. At some point we switch roles and the student becomes driver and I act as a very helpful navigator. If the class isn't too large you can also open "navigation" (comments, questions,...) to the class as a whole, to get them used to the process of aiding the driver. Along the way I discuss what we are doing at each step (go "meta"). This can take up much of the period, but if you have enough time you can distribute the code you've done to the class. They can pair and work on the next story as you wander about giving help. So, they see unit testing and pair programming and build on the test-first philosophy in an integrated way. Another thing, that works well with this is that, when you assign them a project, you can give out a unit test suite along with the product backlog. In other words, you write the unit tests and they make them pass. The down side of this, however, is that the tests contain identifiers from the app (class and method names for example). In the big picture, the test suite is your low-level design space where you decide on such things. If you write a test for the "increment" method, you will normally do it before you even have a stub for the method. In writing the tests you discover the name as well as the args it should have and its return type. If you give the tests initially you have already done this step and so need to teach it a bit later. Maybe by the 3rd exercise. 

My original answer here, missed the fact that there is a new local variable created in the block. That is part of what confuses me about the example and might be part of what is confusing students if this is a real example, though it may not, in fact, be an actual example presented to students. 

Unfortunately I need to question the very premise of your post. Consider the following scenario (suggests Socrates). Suppose that a teacher is asking a student questions. Suppose further that the student has access to a perfect Oracle. Suppose that the Oracle will correctly answer any question to which the answer is known. Suppose for each question asked of the student, the student consults the Oracle. Since in most situations a teacher is unlikely to ask a question for which he or she doesn't already know the answer, the Oracle itself knows and gives that correct answer to the student. The student then transmits the answer back to the teacher. What has been gained by anybody? The teacher learned nothing new. The student has been nothing but a courier between the Oracle and the teacher. The student needs to learn nothing in this transaction and even if he/she tries to memorize everything all they wind up with is a disjoint set of "facts" rather than any skill. Tasks are posed to students not to get answers or to create programs, but to elicit a change in the mental state of the student. We try to prepare students to answer questions to which no one knows the answer and to create programs that have never before been done. We do this by posing tasks that are in fact known to have answers/solutions but those answers and solutions are not known to the student. We want the student to treat the problem as if it is a really hard problem so that they will work through the difficulties - increasing their mental abilities through practice. Suppose you spend a year or two never using your left arm in any way. Never even lift your hand or flex your muscles. What will happen? Of course, the muscles will atrophy. The same is true of your brain. If you don't use it you will find that it has turned to mush. The answers you get on Stack Overflow (SO) are the answers of experts. They are like an Oracle. If someone knows how to do it, you may well find the answer on SO. But if you haven't worked on the problem yourself you are just a scribe or a courier of information. You will never be able to solve hard problems unless you solve problems that seem hard to you. You will never be able to advance the art if you haven't practiced on things that require hard work. Sometimes the "right" answer is the "wrong" answer.