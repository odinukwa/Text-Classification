Manuel Blum is a well-known theoretical computer scientist and a Turing award winner. But more interestingly, he has the highest number of students who have gone on to win a Turing award (Leonard Adleman, Shafi Goldwasser, Silvio Micali) in the whole computer science. The list of his students is amazing and even more so if we include the students of his students. Can anyone comment on Manuel's supervisory style? What makes him so successful in training exceptional researchers? Anything that can help other supervisors be more successful in training exceptional researchers? 

Recently I have seen several articles on arxiv that refer to a proof system called sum-of-squares. Can someone explain what is a sum-of-squares proof and why such proofs are important/interesting? How are they related to other algebraic proof systems? Are they some kind of dual to Lassere? 

Razborov proved that the monotone function matching is not in mP. But can we compute matching using a polynomial size circuit with a few negations? Is there a P/poly circuit with $O(n^\epsilon)$ negations that computes matching? What is the trade-off between the number of negations and the size for matching? 

Lynch's Distributed Algorithms book is a classic but it is from 1996 and rather out of date. Are there any recent distributed computing books that can be used as textbooks for a graduate distributed computing and algorithms course? 

I was reading Andrej Bauer's paper First Steps in Synthetic Computability Theory. In the conclusion he notes that 

ETH states that SAT cannot be solved in the worst case in subexponential time. What about average case? Are there natural problems in NP that are conjectured to be exponentially hard in the average case? Take average case to mean average running time with uniform distribution on the inputs. 

I am trying to understand the bitcoin protocol in the context of computational cryptographic security. The question is a reference request to foundations of cryptography articles on bitcoin. My first question is what abstract cryptographic protocol bitcoin is trying to implement? Do we have a definition of electronic money/digital currency in cryptography that captures bitcoin? What are the security requirements for a secure electronic money? If the answer is yes, companies like eBay provide a centralized mean of electronic money transfer. Does considering a decentralized electronic money changes the definition of abstract cryptographic protocol for electronic money? Or is it just the same concept but in a model where there is no trusted third party? Can the adversary break the protocol if it has more computational power than the combined computational power of other (honest) parties? Assume that we have $n$ parties $P_i$ for $1 \leq i \leq n$ plus an adversary $A$ networked and the adversary wants to break the bitcoin protocol. For simplicity let's assume that the network graph is $K_{n+1}$ and adversary does not control the network and simply is a party like others. What would be the exact mathematical claim about the security of the protocol in this simple case? 

There is a nice trick to reduce $\geq k$ cycle to finding a cycle of length exactly $t$, for $t \leq 2k$ (I first heard of this trick from Daniel Marx). The key observasjon is that contracting an edge of $G$ may not increase the length of the longest cycle in G, and may only decrease the length by a factor at most two. Thus we can search for cycles of length exactly $t$ for $k \leq t \leq 2k$. If no cycle is found, contract an edge and repeat. This shoukd be quite a bit faster than the treewidth based algorithms, I believe, especially if you use the sieving methods for finding t-cycles (paths). There are very efficient implementations for $k$-path by Bjorklund et al: Fast Witness Extraction Using a Decision Oracle, with Andreas BjÃ¶rklund and Petteri Kaski Proc. 22th Annual European Symposium on Algorithms (ESA 2014), LNCS 8737, 2014, pp. 149-160. This should be adaptable to your problem. 

It is $W[1]$-hard even when $G$ has maximum degree $3$, but $FPT$ if $G$ has constant treewidth (all the above examples have constant treewidth). See the paper Everything you always wanted to know about the parameterized complexity of Subgraph Isomorphism (but were afraid to ask) by Marx and Pilipczuk. Indeed, it follows from an earlier paper of Marx: Can You Beat Treewidth? Theory of Computing 6(1): 85-112 (2010) that a $f(k)n^{o(k/\log k)}$ time algorithm would violate the ETH. Here $n$ is the number of vertices in $H$ and $k$ is the number of vertices in $G$. This holds even when $G$ has max degree $3$ (but the degree of $H$ is unbounded). 

There is a recent paper by Glencora Borradaile, Hung Le: Optimal Dynamic Program for r-Domination Problems over Tree Decompositions (IPEC 2016). Here they show that there is an algorithm that given as input a graph $G$, an integer $r$, and a tree-decomposition of $G$ of width $w$, computes an optimal $r$-dominating set of $G$ in time $O((2r+1)^wn)$. Furthermore, they show that this is the best one can do, in the following sense: an algorithm with running time $O((2r+1-\epsilon)^wn^{O(1)})$ for $\epsilon > 0$ would contradict the Strong Exponential Time Hypothesis. 

We prove hardness for $k \geq 3$. First observe that the problem is equivalent to the following graph problem: Input is a graph $G$ of maximum degree $k$, with an integer demand $d_v$ on every vertex $v$ and an integer weight $w_e$ for every edge $e$. The task is to find an acyclic orientation of the edges (i.e resulting in a DAG) such that for every vertex, the sum of the weights of the incoming edges is at least the demand. Here the demand of the vertex corresponding to bin $i$ is $Q-c_i$, and the weight of an edge is the "reward" or "penalty" incurred on one bin when capping the other. We prove hardness for $k \geq 3$. We reduce from $3$-SAT where every literal appears either $1$ or $2$ times. This variant of $3$-SAT is known to be NP-complete. Make one vertex for every clause and every literal. Connect every pair of literals corresponding to the same variable by an edge of weight $-2$. Connect every literal with the clauses that contain it by edges of weight $1$. Every clause gets demand $1$, and every literal gets demand $0$ if it appears in two clauses and $-1$ if it appears in one clause. For the forward direction, if there is a satisfying assignment orient all edges away from the literals set to true and into the literals set to false. This is clearly acyclic and it is easy to check that all vertex demands are satisfied. For the reverse direction consider an acyclic orientation that satisfies all vertex demands. For every variable, look at the edge between the corresponding literals and set the variable accordingly: if the edge is oriented from $x$ to $\bar{x}$ set $x$ to ${\sf true}$, otherwise set $x$ to ${\sf false}$. Now, if the edge is oriented from $x$ to $\bar{x}$, then, in order to meet $\bar{x}$'s demand all other edges incident to $\bar{x}$ must also be oriented towards $\bar{x}$. The same holds for $x$ if the edge is oriented from $\bar{x}$ towards $x$. Since every vertex corresponding to a clause must have at least one edge oriented towards it it follows that every clause contains a literal set to true.