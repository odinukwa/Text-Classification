If you need to setup your serial port first, you can use the command stty for this purpose. Please, check the stty man page for a truckload of parameters and options. If you don't want to use cat or you need to convert/format the data (to hex for example because it is not ASCII only) this perl script will give you a good start, although using cat and a couple of other utils, you should be able to get similar results: 

I do not have any 1wire stuff laying around to actually test if this 'rewrite' as mentioned in point 3 works. And specially how it should work, but on the info page they talk about disabling the w1 kernel module or run OWFS as root so it can unload the w1 kernel module, but if this is already implemented and working I have no idea. I hope this information gets you a little further, and please let us know some results. 

N.B: This is more a 'thinking out loud' piece of text then a real Answer The idea also crossed my mind some time ago, and I still like the general idea! As far as I know, the high-end scopes are since 15 years (or even more) just computers (PC) with a bunch of specialized high speed I/O. I think that when similar I/O is designed/connected to the RPi, the result might be surprising good. IMHO a good way to do this is to let the RPi just store and display the gathered data (received for example over the USB port) and let some specialized hardware do the high speed measuring. This high speed measuring unit can then also be controlled by the RPi based on user input or something similar. In the first version on the RPi there were/are some problems with the USB ports, I have not searched lately if those are solved at the moment. I heard also a rumor that the new 2.0 version of the RPi should not have these problems, but I also have not checked this rumor. I think the results without any external (specialized) hardware are limited because of the number of I/O ports and the fact that a whole OS is running on it (which limits the realtime options). Unless you're planning to write your own OS? Also using for example I2C chips for this purpose will not have sufficient speed to do something really nice. SPI gives already a lot more bandwidth (upto 100Mhz from the top of my head), but I would go for USB and if needed compress, or use some good encoding scheme before sending the data, to gain more bandwidth. So I guess it is possible, but the hardware that needs to be added to the RPi will be much more expensive then the RPi itself. Last but not least (before I stop daydreaming about this subject) I would not be surprised if a search on internet would result in some group already busy doing this. 

As noted in the comments, you've misused resistor and transistor in your question and title. I guess you were hoping to do this with a resistor to drop the voltage? That won't work. Here's why. Ohm's Law is V=IR. You need a 2.3 V drop, but to choose a resistance R you'd also need to know the current I. Unfortunately the current will vary, so this isn't going to work. (In addition the voltage on your battery will start to change as it drains, so that's more variation.) You could use your battery with something like a buck converter, for example this one: $URL$ (I'm not associated with Adafruit but I have used that converter.) That's a bit more complicated than a resistor, but it should do the job. 

Your resistor is probably too big in this case. Image looks like it's 10k, if I see the colors properly. That's giving you less than 0.33 mA current. (It would be 0.33 mA if the LED had no forward voltage drop, which is actually does. That's usually around 2 V.) Try a smaller resistor. Depending on your LED, you probably want to get down in the hundreds of Ohms, not the tens-of-thousands. For more information, look, for example, here: $URL$ That gives information on how to determine the right resistance given your LED and your goals. 

The Peripherals datasheet for the BCM2835, used on the Raspberry Pi, gives you the answer in Chapter 8. I quote: "The PCM audio interface is an APB peripheral providing input and output of telephony or high quality serial audio streams. It supports many classic PCM formats including I2S." 20 pages of information on this subject alone. Like you said: not all the pins are available from the GPIO connector! PCM_FS and PCM_DIN (the one you probably need) are not on the GPIO connector, you'll need to check the schematic to see if you can reach those in some way. UPDATE: According to the schematics you're out of luck: 

Yes it is, for all the info available on the I2C interface (which is part of the BSC, Broadcom Serial Controller), I suggest reading Chapter 3 (BSC) of the BCM2835 ARM Peripherals datasheets. On the first page of Chapter 3, it mentions the Clock Divider register. On page 33, it explains this register in more depth: 

I can only help you with the hardware part, Chapter 10 of the datasheets discusses the SPI bus, there is a register that is the 'SPI Master Clock Divider' (see Page 152 on the bottom). But how you can do anything with that register in Python is for somebody else to answer, or do a search on google for Python programming, or I am also sure the Python module you use, is full of writing data to specific registers, checking that source will also provide the answer. Update 

The 5V pin is always "on" in the sense that you mean it. It is not one of the GPIO pins, even though it is on the same header and looks the same. The GPIO pins are the ones that you can control programmatically. 

Not all of the pins are accessible. Barring ripping up the board and accessing the chip directly, you can only use the ones that you already identified. 

You can connect multiple i2c devices to the same set of pins as long as they have distinct i2c addresses and compatible voltage levels. The i2c pins on your Pi are 3V3 logic. If you have a 5 V logic device (or a mix between 3V3 and 5 V devices), you'll need to take some extra care. There are multiple other questions here on those topics. 

I didn't check your wiring diagram to see if it's correct. The answer about connecting two wires, though, is this: Connect them via a breadboard or proto-board in lines that are connected inside the board or splice the wires together somewhere away from the board. I see you're using stuff from Adafruit. You can get a breadboard from there (among many other places). If you're soldering pieces, their particular form of protoboard is called "perma-proto breadboard." 

The picture shows an example of ghosting, buttons A, B, D are pressed and besides Row 1 (for button A) also Row 2 (for button C) is high, at the moment Column 1 is active, which is not correct. After the whole hardware adventure, you need to write or adapt a kernel driver to actually use the keyboard under linux. A nice starting point might be this link: Driver for keys on TCA6416 I2C IO expander, this is a similar idea, but only uses a 16 keys keypad. Hope this helps you a little. 

You can put a heatsink on top of the CPU, but as you can see in the picture below, the CPU isn't the hottest part of the board. 

Some answers for you: H1. I guess you could just connect everything to this relay, as long as it doesn't dissipate more power then the relay contacts can handle or have a very odd/extreme cosine-phi factor. The toggle button will act like a manual ON/OFF switch, so you can control the connected device using this switch and x10. H2. I found out that the modules that I found in a quick search online, do not report the status back without asking for it, meaning what you will have to poll these types to know if they are still on. About the power dissipation: I suppose you tell your database what type of lamp you use (the wattage?), because I haven't seen devices (yet) that actually measure the current and report that back. Meaning that you need to provide the power of the lamp for your calculations, and if the lamp breaks the system will not know this and assume/continue to calculate full power while it is actually broken and thus off. (I would not be surprised if there are devices that DO current measuring/sensing, there are a lot of companies that make x10 stuff, but the costs of these devices will be higher) H3. You cannot keep your original wall switches, if you want full control from x10. You can if you settle for x10 control with a manual override OFF switch. Meaning that you can turn stuff ON or OFF using x10 as long as the manual switch is in the ON position (when connected in series). Manual switch OFF will be dominant. If you connect the two switches in parallel you have the opposite, you can use x10 to turn devices ON or OFF as long as the manual switch is in the OFF position. Manual switch ON will be dominant. Both solutions in my opinion work awkward, so replacing the manual switch might be the most optimal solution. H4. Yes, there are signal boosters, repeaters and devices that do this in combination with your H5 question. H5. There are 2 or 3 phase repeaters/bridges on the market. They 'virtually' connect the 3 phases (!! ONLY for the x10 signal of course !!) Unless you have a Very big installation, you do not need repeaters, if you have 2 or 3 phase connection you only need to bridge those using a bridge like you suggested in H5. In the case you DO have a Very big installation, you'll also need a couple of repeaters, but get those when needed. Hope this helps. 

Connecting the left to the right will do the bypass that you want, in the sense that it will change this into a "simple" on-off switch. That's the first part of the answer. Now as to which should be connected to GND and which to GPIO, that depends on whether your signal is high or low. You still seem confused about how inputs work at a very basic level. (I remember your earlier, related post.) You need to decide - and coordinate in both HW and SW - which type of signal you expect when the switch is "on". That means configuring either a pull up or a pull down resistor somewhere. (That somewhere could be the built-in pull-up/down on the Pi.) And then you need to wire accordingly. There are multiple questions here and many, many posts on this subject around. 

I agree with the answer by CoderMike that you've probably fried your Pi. Based on the wiring diagram though, I differ in thinking that it might have been avoidable with this hardware if you had connected it different. You put 5 V into the shield's logic circuits by connecting the shield's Vin to the 5 V pin on the Pi. That's the orange-ish line near the bottom of your figure. You probably then got that same 5 V level running through your GPIO pins, which, as CoderMike said, is going to damage your Pi. You might be alble to use this same hardware if you connect the Pi's 3.3 V pin to Vin on your shield. Before you try that and maybe burn up more hardware, however, you should read the specification for the shield. Look to see if the shield can operate on 3.3 V, and verify that this connection results in 3.3 V at the GPIO pins. If you're unsure though, I'd get a motor driver designed for the Pi. That won't be super-expensive and may be less frustrating in the long run - especially if you burn another device trying to make the Arduino shield work on your Pi. 

If you just want to make a keyboard, without using your Makey Makey, you can do that using the GPIO functionality of the Raspberry Pi. But like commented before, the Raspberry Pi does not have sufficient pins available to make a keyboard that is actually useful. However, if you are willing to add 2 IC's you can make yourself a keyboard with so much keys that you will have a problem to come up with a function for every key! My suggestion is to connect 2 I2C IC's to the I2C bus on the Raspberry Pi, and use those to create your own scan matrix. If you use one PCF8574 you have 8 I/O pins available, if you get a PCF8575 you even have 16 I/O pins available. By combining then you can get a scan matrix of: 

command? That nearly only works well for memory chips and I guess RTCs, or chips that without any request output something (Temperature Sensors, some not all of them). This IC needs some stimulation in the form of some settings before it outputs something usefull. I assume you're talking about the Freescale MMA7660FC (There is also a Bosch component that is called MMA766, but that dissipates 15W so, I don't think we're talking about that): According to the datasheet, it has a couple of modes of operation (page 9), it needs to have power supplied to the DVDD AND the AVDD pins before it will even start to think about doing something. (It will otherwise be in Power Down mode or Standby mode). If you did not read this datasheet yet, I urge you to read it, it contains a lot of information about how to use this chip, and how to set the configuration to make it do what you want. And please confirm that we're talking about the same chip, because otherwise it is very difficult to help you. 

So you keep writing to the variable . At the end of these statements you have the state of pin 21. None of the other pins influence the outcome of the program. As far as simultaneously reading all of the sensors: That cannot be done with infinite precision. If you do true multithreading, you can get it pretty close, but only up to the number of cores that you have on your machine and still subject to misalignment in where the various threads are in the execution path due to thread scheduling at the OS level. It's also worth noting that you cannot do true multithreading in Python (at least with the default interpreter) because of limitations at the interpreter level. Depending on what you're doing and how precisely you want to make this read simultaneously, that may or may not matter in practical terms. 

The Pi uses 3.3V logic! Even at 5 V you will probably destroy your device, never mind 6 or 9V. All of the GPIO pins are 3.3 V logic, including Tx and Rx. 

You need to use an appropriate transistor and an external power supply. The transistor is a three-pin device that will (if you choose the right one) let you use a 3.3 V GPIO pin to switch current on and off on a higher voltage circuit. Do not try to connect you GPIO directly in the 14 V circuitry. In the best case, that will result in nothing happening. In the worst case you'll burn out your Pi. To get the right transistor, you'll need to shop around and check specifications. You probably want a MOSFET device for this application. If you search for those terms, you should find a lot of information from many sources giving details of how to connect this. When you're shopping, make sure that the device you choose is rated for the 14 V load at the current level that you expect and that it can be "saturated" (turned completely "on") with 3.3 V or less. Here is a related but different question from EE.SE that includes a circuit diagram. In that case they are talking about 24 V, but the same basic principles apply. 

When the RPi can talk NFC, it should be able to talk to any NFC equipped Android Phone (or NFC equipped device in general). I personally did not play with that combination, but I found a tutorial on this subject. It uses a RPi and a 13.56 Mhz shield for the NFC/RFID communication. The only thing that worries me in the text is that an Arduino suddenly pops up, I guess that is not the idea to also add an Arduino. I found a second source of information from Ada Fruits, they have a ready to use piece of hardware and they also have a library to communicate with the hardware, this might be a fast solution to start using NFC/RFID. In the text I only see that they use of for reading mifare cards, so plain RFID, but making this talk to an Android device is just a matter of a (little) programming. 

It will complain about the same stuff as apt-get did before, but it will install it anyway. One latest check to see if all library requirements are met: 

The cheap (raw pixel) cameras will not give you a FPS even near the 20. They will only give around 2 to 9 FPS. This is mainly because the RPi will need to encode the frames before sending them, and that is a lot of data to encode. With JPEG (those are mostly HD cams) encoded cameras you'll get a little better FPS rate (around 15 up to 20 FPS), because the encoding is done in the camera itself, the RPi only needs to send these frames without the need to encode.