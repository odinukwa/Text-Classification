What user account are you using to login to the pi? The boot script and deluge auth file from howtogeek are setup for the user "pi." Is that the user account you are logging in with? If not, we need to find out who you are logging in with so we can get the right settings in place. I personally prefer to run deluged as my user I log in with because of all the permission problems I ran into. The command "whoami" will print to the terminal who is the currently logged in user. 

EDIT: I personally prefer to use ACLs for managing ownership and permissions, simply because it's dynamically applied to all the files and subfolders in a directory. ACLs are a bit more advanced, but much better to use, because I can add cjohnson with 755 permissions to a directory, and all the new files and folders that are added to that directory, will always be set with the user cjohnosn with rwx.r-x.r-x permissions to anything in that directory, even if I'm not the owner of said directory. 

And, unless your preference is to use static libraries (massively expands the size of the executable,) I suggest generating a file: 

You need to read the document that contains the 'modbus' implementation (and restrictions) for the sensor, which is linked to from your first external reference . the referenced code example is not correct 

I strongly suggest you keep the compile step and the link step separate The link step should look similar to: 

the first thing to do with the received data is to check the command code to assure it matches the sent command. the second thing to do with the received data is to check the function code (mostly for error indications, I.E. the returned function code will have 0x80 bit set) if an error condition is indicated, read the next byte(s) for which error occurred. the third thing to do is read the data byte count (that tells how many data bytes were actually returned) the forth thing to do is verify the CRC the fifth thing to do is extract the register value(s) Which are 2 bytes per register. 

You will see a different list than me, and VirtualBox wouldn't display my connected USB, but you should see a short description of your connected devices by USB including you drive with "lsusb" and you will hopefully see your connected drive with all its partitions when you run fdisk. BE SURE TO USE fdisk -l SO YOU DON'T CAUSE CORRUPTION. Fdisk is a partitioning tool, so proceed with caution. Now, this can go down several different roads because your external drive may need the partitions created and formatted The unfortunate thing about the howtogeek article you used to setup deluge, made a lot of assumptions about previous articles that should've been read to make sense of the current article, which is never a good idea in writing. The article was somewhat confusing, and very unorganized for the guys at howtogeek usually write. Deluge has a great support page for getting deluge up and running like it should be, which I'll link here. $URL$ This article will create a user and group named "deluge" that will run the deluge daemon and would need permissions for the deluge user on the USB folders. The way deluge works, is all controlled by a config file usually located at: "/home/$USER/.config/deluge/core.conf". If you use the linked article above, the config file would be at "/var/lib/deluge/.config/deluge/core.conf" So our goal is to make sure that we are using the right config file with the right user, so our scripts will work and so we can configure proper permissions. I use systemd to manage my startup scripts, and I use my main user for deluge. My /etc/systemd/system/ service file: 

using 3 6:64 latches, driven by 6 gpio for the address lines, 2 gpio for the chip select lines and 1 gpio for the desired new state you can control 64 RGB LEDs I.E. using only 9 gpio lines. By increasing the number of gpio being used for the chip select lines you can easily control even more LEDs. I.E. double the number of LEDs for each additional gpio chip select line. However by routing those first 6 gpio (for chip select) into a 6:64 latch, (and adding another GPIO for this new latch enable) you can control 64*64 (4096) RGB LEDs using only 10 gpio 

We need to make sure the USB is connected when we setup your sub directories, so we can assign permission to the folders on the USB. The funny thing about USBs in linux is that you can create the sub directories without the USB connected and the directories will really be created, but once the USB is connected, those directories will not show up until the USB is disconnected once again. So what is happening is the pi see's those directories as real directories, because they are, but when you mount a USB on top of those directories they no longer exist since the USB is now actively showing its directories. So, we need to make sure the sub directories are being created while the USB is connected so we can setup proper permissions on the directories. There are several ways to determine if your USB is connected and working. The first and easiest is using "lsusb": 

use the 'any device' address (broadcast address) of 0xFE use function code 0x44 (which does not exist, perhaps you meant 0x04 it says to start with the 9th register (register numbers start with 0, 0x00 0x08) it says to read 2 registers (of 16 bits each) (this field is two bytes, not just one byte, I.E. 0x00 0x02) then the CRC (which I have not verified, and is probably wrong) is 0x25 0x9F 

the borsch documentation for the chip is available at: $URL$ the chip documentation does not agree with the posted code. Please read/understand the documentation, then design the code. Amongst other things, the three byte pressure is not sequential bytes and the way to tell if a conversion is complete is to read the control register and look at bit 0x40, which will be 0 when the conversion is complete. The oversampling count is set by bits 0xC0 in the control register. and several other problems with the posted code. If any more misunderstandings arise about the documentation or how to write the code, then update the question register 0xD1 is not defined, so no version available. Please read the documentation. 

Fstab can be a little tricky, especially with USB drives. We can setup the USB drives in fstab the right way once we get to that part of the problem. The proper way to mount devices in fstab would be by using the UUID of the device that will be mounted because sometimes the device names will change, but not the UUID; and then we can assign the right options. To get the UUID of all devices: 

Basically, we want to mount the USB drive on boot at the right mount point and with the right permissions, and skip mounting if it's taking too long or not physically connected so the pi can boot the machine just in case the USB is disconnected. I like to reference the Ubuntu Community Fstab document, since it's pretty good. The syntax of your file would need to look something like: 

For the second question, if i hook up a small keyboard or mouse to the Pi, hitting a particular button would be the equivalent of sending play/pause, back, forward, etc, to the phone. the current in car system has a small remote on the steering wheel, which is based on RF, and unless it can be hacked, i don't think this can be used. I would like to be able to use some sort of remote, not necessarily the one that i currently have, to control the phone. 

I have a 2011 BMW 520D, and it has a very large display for media and sat nav. The car supports showing traffic information via TMC (Traffic message channel), but not in Ireland. When I visit Northern Ireland, it does pick up the TMC station and shows me details of traffic... Since the Raspberry Pi can be used as an FM transmitter, I am wondering can I take the pi and turn it into a TMC transmitter (I think it's RDS that's used to send traffic info) transmitting on the station that it uses in the UK? The theory being that I pull the information from Google or another traffic source (or multiple sources for that matter, possibly including the Irish TMC, which my car does not support), recode it and transmit it in a way the car can use... Possible? [UPDATE] Just to clarify: The traffic info can be received from anywhere (Google, Bing, Here Maps as suggested by @user12321). That is not actually the problem. The problem is more the encoding and retransmitting the data using the TMC station... [UPDATE2]: Ok, after a lot more digging, i found out something... my theory of the TMC being encrypted is somewhat true, but also a little wrong. BMW do not have the TMC database in their nav system, so, even though they technically could "here" the TMC info, they dont know where it is... TMC might say 0122,33223,163322 where 01 is the type of issue and 22 is heavy trafic, 33 is road and 223 is, say M50 north bound between N7 and N4 and 163322 is a start time... BMW can read this, but have no idea what it means... 

Be sure that your Operating System uses systemd before writing a systemd service file. The howtogeek article uses init.d scripts instead of the newer systemd service. The delgue article I linked shows how to convert init.d scripts to systemd if your Operating System supports it. The only changes I made in my config file,"/home/cjohnson/.config/deluge/core.conf", are location options where I want to store my data. In your case, these need to point to your External Drive once we are sure it's setup right: torrentfiles_location autoadd_location download_location move_completed_path Once the drive is mounted, we need to create the sub directories that you would like, in the howtogeek article it's the folders under /media/USBHDD1/shares, and we should be able to use this command: (We will have different folder name rather than USBHDD1, I'm just using that as our example and our $USER will be whatever user we determined to run deluged at boot)