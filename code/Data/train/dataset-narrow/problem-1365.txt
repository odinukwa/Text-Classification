I am puzzled by how you use both inside and outside . Each iteration of has its own scope, so its own . For instance, if , which item do you mean to use inside ? The way it is used now, the seen by that function will be another on the outside scope. If this is the intention, this variable should be named differently: 

That way the original list is not in the Controller but the Service, and Controller simply asks for it. Here the jsbin to enjoy! 

I would try to split into simple pure functions doing one thing each. Search for Robert Martin aka Uncle Bob advices on clean code. Is this just a helper to display an array: 

UPDATE. Having another look I see better what you are trying to achieve. Still I would improve design by making the directive more re-usable. You basically want to throw any HTML inside the directive and pick the associated with event's target. The directive makes this available on the scope of your expression . Just like made available inside the . I would then mark this as something special like: 

The last argument inside is too far away down, making the code hard to read. It is better to define your function separately, and use it a short line inside . Also executing your function inside is a recipe for errors and hard reading. 

First, you should wrap your code up in a closure to prevent collisions with other code. I typically use an IIFE for this. Also, you should add to your code to help prevent certain issues. 

What this code does is move the charts onto there own rendering layer. This prevents the browser from having to check the surrounding areas because each chart is now separated from the rest of the content. In Chrome, you can see the performance difference this makes by watching the Timeline in the Dev tools. In the original, it spends ~180 ms repainting the screen and ~100 ms performing calculations. In the updated version, it spends ~20 ms for each. Add this over four graphs and you can see why the cpu is pegged. The is a new CSS property that will basically do the same thing as the two lines above in the somewhat-near-future. I have updated the fiddle with just this change and you can see the difference. Now, the code review: As always, the first thing I recommend is to remove your code from the global scope. The easiest way to do this is to use an IIFE. This will basically create a private scope for all your code which reduces the amount of code you place in the global scope, which in turn, reduces the chance of collisions with other peoples code. Since you are using jQuery, this also provides a way to make sure always points to it. 

When you create the methods inside the constructor then those methods are duplicated in memory for every object created. When you use the prototype those methods only need to be defined once. If you want to write code that feels like a class then use an actual class. (JS has those now). Aside from that, don't store you data in the function that creates the list. Pass the data into the constructor or create method. 

I personally would have saved it as a simple timestamp rather than a date, whether or not that's actually a better idea is debatable, but a timestamp requires half as much space as a datetime and is, imo, much easier to use. On the client side you can get the user's UTC offset with a simple which will return the difference between the user's time and UTC in minutes (multiply by 60 to get seconds). Then you can use PHP's function to get the current timestamp and subtract the user's offset. When you need to display it as a human readable date, PHP's can take a timestamp as a second parameter to display a specific time. Timestamps are just a lower level, more efficient way to handle time differences. 

When you build a string like this you are loading the entire string into memory every time you add to it. In this case it's likely not going to be a big deal, but it's generally a good idea to use a buffer to build your strings, which basically means ing string segments into an array and then ing them together when you have all the parts ready, eg.. 

You might also want to consider DRYing your code. Since the click functions on both the and are so similar, you can combine them and just pass in the "main" element you want to work on. For example: 

The next thing you should consider is caching your selections. Since accessing the DOM is one of jQuerys slowest operations, you want to minimize this as much as possible. Anything you refer to more than once, you should cache. 

I prefix all of my jQuery selections with $ so I know they are jQuery objects. You should also start using for defining your events instead of the shorthand of . Behind the scenes, uses so just skip the middle man. 

Another thing that is adding unneeded complexity is checking to see if the class is on an element before removing it. We can just make the call to remove the class. If it has the class, it's removed. If not, no harm no foul. 

I will leave that code up to you. At this point, you should see a noticeable increase in the performance of the page. Some other things to consider: In your function you have a bunch of Magic Numbers such as 86400. Although this is fairly straight forward when you know what you are looking at, it might be easier to set up some variables to hold those that provide some explanation for them: 

contains both and data, so you can use that in place of . Now, everywhere you have that request method check, instead just do , and everywhere you use , replace it with . Then your code will work with both GET and POST and it will also be quite a bit shorter. 

I wouldn't have a function that sets the event handler since this is usually something that is only done once. Instead of using you can use assign the keyup listener to the document and have jQuery only respond when it lands on that element, this way you never need to call it more than once, which mean you definitely don't need to put it in a function. 

Sidenote: I'm not sure if you really need , if the string is numeric it should be cast to a number implicitly. 

How I would do it (Assuming I wanted it to be as fast as possible, and that you want it to output what you said it should output rather than what it actually outputs) 

Dont re-invent the wheel This function already exists natively in PHP. is almost the same your , but the second parameter is inversed. So my idea was to get a list of tags that already exist in the string and then see which ones weren't in the lists of tags to remove, then let do the dirty work. Logically this should be two functions. Getting tag names I didn't want to use regex because it's notoriously bad at parsing HTML. I used simple string functions to get the tag names. My algorithm is as follows: 

With this function, will always be at least 2 characters long. Now before updating the charts, check to see what are current value is. If it's the same as the new value (which will be typical for minutes, hours, days), then there is no reason to update them (or there text for that matter). Adding a element with jQuery is a great way to keep track of this. 

There a few simple things you could do to help clean up this code. The first thing I always recommend is to create a closure for your script using an IIFE. This allows your code to run in its own scope and keeps everything out of the global scope. You can also pass in to the function expression and safely refer to it as . 

The first thing you should do is encapsulate your code inside of an IIFE. This will create a private scope and help prevent pollution of the global namespace. Since you are using jQuery, you can pass it to the IIFE to make sure your reference to is always . 

There are a few simple things you should do first. 1) Move all of your tag to the bottom of your html right before the closing tag. Because of the way browsers parse your page, having them at the top will only slow down the page load. 2) You have two references to the jQuery library. You only need one. 3) Your HTML is not consistent. You have some open tags without closing tags. You also have different markup around some of the form fields than around the others. For instance: 

Nice work! I presume the complicated way of getting the right element measurements is to cater for many browsers, won't comment on that. 

Warning. Keep in mind using inside HTML, that your code becomes invalid as soon as those s are not unique. This can easily happen by copy-paste and forgetting to change the . Unless you use reliable validators, and consider this a feature to help your validators, I would avoid using s whatsoever. Styling can be done merely with classes and is a recommended way. 

Again, pure functions without side-effects are easier to test in isolation. Use the and methods on arrays for shorter and simpler code and libraries such as Ramda (my favourite) or Lodash. 

You define as array of anonymous functions, which is a bad practice in itself. You can't reliably test these functions as your index will change any time you update your array. A better way would be something like: 

Your code is manually recreating HTML, which is an anti-pattern. The Angular way is to supply separately HTML template and its data scope object. 

Having looked at your code I can see one major problem - your directive hides but does not isolate its scope. That makes it vulnerable to both external and internal changes. Internally you may change a variable and forget to adjust it and suddenly your directive is using the same named variable from outside! Imagine all the bad things can happen to your directive! That makes the maintenance a nightmare - you can't even use reliable tests to catch the "leaky" variables that you forgot to declare. They will keep "sleeping" quietly deep inside your code until the wake-up explosion :) Your directive seems to be intended as encapsulated drop-in component. For which Angular's isolate scope is the best solution. The isolated declaration inside your directive tells you exactly which attributes are "allowed" inside and how are they named. You see it clearly right at the top of your directive, which makes your code more readable and maintainable. Now you can change the outside-inside coupling nicely inside that declaration. That also would make your code cleaner, shorter and DRYer. As side remark, I would generally try to avoid, if possible, the low-level "system functions" such as , etc. They are used by Angular internally to expose more user-friendly (and reader-friendly) API to you. Such as the isolated scope binding and using filters rather inside your templates (i.e. what it is meant to). 

Also, all of your code is in the area. Does it all need to be in there? You can probably define a lot of what you want to do before the load event and then kick it off when the load event fires. 

Next, you have each droppable in its own call. That is unnecessary. You only need one call. We will add that in at the end of the code. Since most of your code is actually in the event handler and it is almost entirely the same for each instance, we can DRY out your code. Just pass in a string that contains the one difference between each function and cache some of the variables. 

Notice how that is pretty much the same thing repeated over and over? That means it needs to be it's own function: 

Also since we don't care about the order in which this is done, we can use a loop. It is typically the fastest ways to loop in JavaScript. 

First, I'll get to the fix for your problem. The problem is more in the CSS than in your JavaScript. Because you are updating the graph every second, that area of the page has to be repainted each time. Due to the way browsers handles these things by default, it has to also check the surrounding area to see if it now needs to be changed as well. So the idea is to minimize this. And the simplest way to do this is to add the following lines into your CSS: