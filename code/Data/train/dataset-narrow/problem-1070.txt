The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

Looks ok. A is a more interesting way to do this, since you can then auto-close the resource. There's one thing I took an issue to: 

Finally (unless I missed something), the inside can be avoided simply by using multiple , and statements like this: 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

We'd usually make the solution more functional. That is, move the "fizzbuzz" logic into something that returns a string, and use that: 

The solutions given are simple but have quadratic complexity. I tried to improve upon it, while keeping it strictly functional. The solution I came up with is huge, though some of that resulted from breaking it up into smaller pieces for readability. While it is much faster, I'm not sure if that's due to an improved complexity, or just better heuristics detecting when no more palindromes are possible. I feel like it could be improved, perhaps with some Scalaz tricks. I see a couple places where I could remove some code by using an Scalaz abstraction, but not enough to be worth. On the other hand, I'm not particularly familiar with Scalaz. So, here it is: 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

Each condition is a function. It might be that you could write it more concisely, but I think the code is clearer if you do this: 

That is, if used as you did. I'd make it an instead, and initialize it at creation. I'm not sure would help you here, but might. I just don't think it is a particular good fit for BFS, but it might just be ignorance on my part. 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

You are running into undefined behavior here, because you are reading from a union property without writing to it first. Unions should not be used to convert types to each other. It is not safe! I am sure, the code doesn't do what you expect. Your code says, you are converting a uint8_t pointer to uint16_t integer. You are not accessing the data, just the address! 

Use C++ not C First of all, you are making a lot usage of C, not C++. In C++ you either use the keyword class or struct to declare a class/struct, not together with the keyword typedef. You are using uint32_t a lot. This is also C style, the proper C++ style is the std::unit32_t type. But most of the times you don't really need to specify the width of your integer directly. This only makes sense if you want to serialize/deserialize them. Use new and delete instead of malloc and free. Better: use smartpointers like std::unique_ptr and std::shared_ptr. declare properties private (encapsulate them) The problem here is, you are using public available objects inside of the IMAGE_STRUCT struct, which can be modified from the outside. split-up your functions Your atImageEvent function is huge! Split it up into smaller parts. name conventions There are no explicit name conventions at all, but you should not declare your classes/structs with only capital characters (like IMAGE_STRUCT). Most of the times words with only capital characters are macros. It's not a mistake rather than a bit of taste. if I am not totally wrong names beginning with _ are reserved by the standard and should not be used for custom code. To be honest, I am using them by myself, but I think its worth to mention this. undefined behaviour 

Most of the points are already mentioned by others, thus I will only tell you my opinion about the missing ones. I don't really like your function. You obviously know how to use , why don't you simply use them for your purpose? It all boils down to something like that: 

tl;dr Sort the , remove the duplicates and use a binary search instead of your linear approach and you will discover a huge performance benefit. 

Be aware of the fact, that you have to take care for the cases, where your vector size isn't a multiplication of thread count. There will be some elements left untouched, but I let this job as a task for you ;) 

I prefer over , because it enables the possibility to create the objects inside the vector in place instead of copying. use the parallel std algorithms In the end you could simply use the std::transform overloading for ExecutionPolicies rather than writing the stuff yourself on the base of threads. Have a look here. 

don't use You should not use because it eliminates some important information, which may lead to some conflicts with your classes or classes of other libraries. It is not uncommon to have a class, which has a totally other meaning than the . And to be honest, it isn't that much more work, to type in front of the classes/functions, is it? use You do everything with for loops, which is bloated and error prone. Use the algorithms of the namespace instead. I provide you with a short an clean example, how you could do the above task (and more) with less lines. your algorithm itself You should think about logical improvements. Is it necessary to store every score in a vector, when equal scores produce the same rankings, and the following scores just increments by one? Therefore I took the algorithm, which returns a . doesn't erase anything itself. It just moves duplicates to the end of the range (our ); you have to them manually. But, before you can use you have to order your elements. I don't know if it's guaranteed to get the score input in a descending order; thus I simply use to ensure this. After that, it's a simple (which is a binary search instead a linear search) to get the first iterator to an element, which is not less than the provided score (ok, I had to pass an other function object, because we want to check for greater and not for less). starts with a zero index. This means, we have to add 1 to our index, to get the official ranking. Easy, huh? 

I am no expert in streams so this may not be an ideal solution but here's a moderately streamed version. Essentially, the game is a stream of objects which are evaluated, grouped by the result and counted into a Map. Most of the streaming is in the method. 

There is a neat fact about the Java LinkedList. It implements the Double Ended Queue or Deque interface. This means that it can be walked in either order (end backwards or start forwards) so in this case you actually don't need to find it's length, you just need to walk both lists backwards. Here's an implementation of what you are trying to do. 

I use EHCache to maintain a mostly read-only cache of results from database queries. It works perfectly for over a dozen queries. However, there is one table which needs an odd access method that is causing me grief. I hope someone with a knowledgeable eye could see what I am doing wrong, if anything. Note that these classes are marked because I have torn them out of live code and put them all into a single class - just for you. :) Here is the object which wraps an ehcache object. It works fine in all case except my special case I will post further down. 

Examining the similarities and differences I would suggest you factor out the Attack/Defence attribute into a separate class. This can then be used as a parameter. An is an excellent candidate for the attribute - I will call it a , I am sure you will come up with a better name. The result is very succinct and I think quite neat: 

I totally understand how exciting it is to make full use of the richness of the Java language but sometimes you must stand back and decide whether you have don good or bad. Here I think (and this is only my opinion) you have not done good. My problem with this is that it is not obvious how to use the mechanism. I would suggest that the transform mechanism should not reside in the enum, it should be in the . Something like: 

See that by refactoring properly you can now add more validations steps without affecting the main code, each one will only add to the quality. You have now transformed brittle code that is comparably difficult to understand and enhance into something clear and flexible. This encourages you to focus on the fact that you are trying to mix validation with parsing. If you let your worries guide you properly you will see that the validation is a separate process and your attempt to mix the validation into the parsing process is making your code smell. Validate first - then parse. Do not pre-optimise and merge them into one until you have a good measured reason to do so - and even then measure again. Added Just for the joy of it - here's what it might look like in Java 8 

My problem is that sometimes (unpredictably but after at least 1 hour of idle time - which is how long the cache pill takes to expire) the code passes through this mechanism, does not rebuild the cache but retrieves a . I know that the thing was added to the cache in the last rebuild so my logic follows that something unexpected is happening but I cannot think what. Any ideas? Notes 

I realise that in CR we are encouraged to review the code rather than suggest alternatives but in this case there are good reviews so I hope I can be forgiven for posting alternative methods. How about this? 

The first regex only accepts some of these - only the second accepts all. See here for a very good narrative on the subject. 

I would recode the list of s into a list of tests and implement them as an . There are other techniques but s offer a nice succinct way of doing this. 

Yes it looks tidier and neater but now look what happens when they change their mind and request an enhancement. All I have to do is add: