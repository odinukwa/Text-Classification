Instead you should have some sort of factory method that creates new classes for you, setting up the mixins behind the scenes. For example: 

First off the code is hard to make sense of, because I only see part of it. Most importantly I don't have the source for SessionsStruction class, which you are extending, and the name "Struction" doesn't make any sense to me (is it even in dictionary?). It would also help to have a code sample of using this class. The class also has no documentation describing its purpose - and after reading it all, I'm still wondering what's this all about. Some immediate problems I see with this class: 

It's likely doing several things that could be extracted to other classes or functions. A good candidate for extraction is the function. It seems to me that this has been taken from some 3rd party website or library, as its dash_separated_name doesn't fit in with other camelCasedNames in this class. 1. Replying to your comment: 

Each view would have an array of its subscribers. method would add a new item to this array. And in , after the data has been fetched from server, we'd loop through this subscribers array and call a method like on each view. 

You'd still be defining the inside another component, but most of the code would live outside. Additionally... 

The first one will be animated with and default delay, but the second one will be animated with both and because each time is ran, the values it overrides in will stay there. This jQuery plugin is hard-coded to a concrete selector. Instead of selecting class directly inside the plugin, you should use the context element: 

Currently your and operation both have O(n) complexity - adding 100 words takes 100 times as long as adding one word; similarly counting a word that occurs 100 times takes 100 times longer than counting a word with one occurrence. To improve the performance: 

I would expect MySQLSessionHandler to change when you need to change something in the relationship of how you're storing the session data to MySQL database. However I would not expect changing how session ID is generated to require a change in MySQLSessionHandler. The SID does not have much to do with MySQL - you might use the same ID generator for FileSessionHandler or PostgresSessionHandler. 2. Replying to another comment: 

If you're planning to place a ton of these characters on a page, you might be better of using event delegation, instead of binding the event handlers on each and every element - see the jQuery.on() function reference. 

Indentation and formatting First and foremost, this code is not properly indented. If a candidate presents me with an unindented or sloppily indented piece of code, I wouldn't hire him, no matter how good his code otherwise. 

I suggest you study some existing libraries that implement their own JavaScript class systems. There are lots of nuances of the JS object model that you need to be aware of. I strongly suggest you don't use your own home-grown class-system for production, but instead adopt some already bettle-tested implementation. But writing you own is a good way to learn more deeply about JavaScript. 

Try to write one assertion () per block. This way you can give a more descriptive name for each scenario you want to test. Don't simply repeat the same test multiple times. For example, you're testing the with , , - it's essentially the same test: three sequential numbers. Try to come up with more fundamentally different scenarios: 

Each of these arrays in keeps a count of how many winning points a player has already scored in rows, columns or diagonals. These arrays are checked after each turn to determine if player has won - first player to get 3 marks into any of these arrays wins. However, instead of just looping through all these arrays to determine the winner, some kind of very convoluted logic is applied, which only checks the row, column and diagonal where the last move was made. Maybe an optimization, but completely needless for such a small game. But really... you should just store your data in a simple 3x3 array and inspect this array after each turn to determine the winner. And try to think of how would you build a tic-tac-toe of 100x100 grid. 

Of course the itself is a lousy name for a function, but it's more of a helper in here I guess. I see no reason why you would use and options object instead of passing in just two parameters, but even when you use an options object, it would be simpler to extract its values into local variables and work with these. One can also easily drop the use of in favor of simple operator, which is the canonical way of implementing default values for parameters: 

Then produce HTML Normally one would now transform this list of tokens into a tree structure, but as the BBCode-to-HTML conversion is very one-to-one, we don't really need to, and can pass the list of tokens directly to another function that converts it to HTML: 

Nevermind: I thought that the original code tries to skip over undefined values in array with this nested loop, but turns out that this is just an awkward way to avoid going past the last element in array. 

Or alternatively, drop callbacks altogether and use refs to extract user/pass values when the Login button is clicked. 

In the code above you first set and then inside you set again. These two are not the same variable. Do not define instance variables outside class methods, unless you want to do some meta-programming with them. You define method for accessing the variable. As this is such a common pattern, Ruby provides a helper for generating such simpler getter methods: 

On surface it's a well laid out code with bunch of helpful comments and good method names. However, looking deeper the data model of this game looks rather odd. Instead of storing the game state in a simple 2D array as such: 

We could write a separate function that eliminates undefined values from our input array and then feed the result into order checking function. Well, we don't even need to write our own function for that, but could use _.without: 

But taking the wild cards into account complicates the whole thing considerably. Now it really becomes a question of combinatorics. A brute-force approach would be to try using the wildcards in each of the empty positions. This can be optimized of course, but I suggest you turn to StackOverflow with this question - some math-minded people might be able to provide you with a better algorithm over there. 

Regarding performance There are three rules about performance: measure, measure, measure. If you seek for a more performant solution, you should first determine how slow your solution currently is. So, you should measure how many seconds, milliseconds or microseconds this code takes to execute. After that you can come asking for performance help. Telling us how slow exactly your code currently runs, why that speed is not acceptable for you, and what would be an acceptable speed. 

I guess it comes down to an age-old question: which criteria should you use for splitting up your code to modules/classes/functions/etc? A good guideline to follow, is the single responsibility principle, which states: 

Also note the naming: the original name seems to be talking about some coordinates, which doesn't sound correct to me. By separating the two, it should be also easier to improve function so that it would not return duplicates, without having to modify anything inside . Additionally: 

It's pretty hard to understand what this code does. There's a lot going on and the code doesn't communicate well what it's doing. Like the variable names and look completely arbitrary. My main suggestion is to split this function into two: 

Text is widely considered a much better protocol format. If you decide to go binary, you better have reasons for doing so: 

Avoid logic in tests. Logic is error-prone. While hard-coded values are a big no-no in normal code, in test code they're usually OK. Instead of: 

You're passing your app state as the parameter to almost all the functions. This suggests you're better off combining these functions into a class, where you could assign these values to which would be automatically accessible from all methods in class. Alternatively, if this all is a tiny app, you could just use global variables, which too would be accessible from all functions. 

I think your answer is perfectly valid and much better than the editorial solution. I only have two suggestions to improve it further: 

Shouldn't the values be all skipped, returning as a result? Herein lies the main problem with this function. It's attempting to perform two distinct operations: 

The element has no attribute. That attribute is for . Also cannot contain text within itself, only inside . There's a pretty long line for deciding between these different displays: 

As this looks like a school assignment, I'm answering with a bunch of questions for the student of algorithms to ponder: 

I doubt that these apply in your case. Perhaps you have some other valid reason. If you don't have a strong need to use binary... don't. The future maintainers will thank you. 

Would be better two have two functions that separately perform the tasks, something that could be used like so: 

Each cell is instead indexed by named coordinates like . This completely hard-codes this solution to 3x3 grid. Attempting to extend this solution into a larger grid would lead to a lot of trouble. Another big oddity is that in addition to keeping the gameboard state in the grid where it naturally belongs, it's also partly kept in each player object: 

Within this loop, there's another low-level for-loop, which I would again replace, say... with an method. Now, in your code the loop goes over all the parts of the key, checking each time whether it's the last part. Instead of this, I would first remove the last part, loop over all the other parts to ensure all these are initialized, and then simply assign the value to the last position. With some additional improvements to variable names, I would write it as such: