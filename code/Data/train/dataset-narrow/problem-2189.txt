This is not an answer, but another version, NOT equivalent to the original of this excellent, but perhaps hard to grasp question. Define the bipartite clique partition number of a graph as the least number of its complete bipartite subgraphs that cover each edge exactly once. Similarly define the support of the fractional bipartite clique partition number of a graph as the least number of its complete bipartite subgraphs that have a positive weighing such that for each edge the sum of the weights of the subgraphs containing it is exactly one. The question is whether these two parameters are always equal or not. I find it quite surprising that while fractional version are studied a lot, I've never heard of studying the size of the support of the fractional version. I also wonder whether this latter parameter has any applications. Also, the question could be asked about several other parameters. 

So here is an extension of Emil's argument that shows that search problems where the number of solutions is 1, 2 or 4 (we do not need to know which) can be solved in the above way. I'm posting it as an answer because it's way too long for a comment and I hope that someone smarter than me can prove that in fact the number of solutions can be anything not divisible by 3. Say that a random string $r$ is close to a solution (i.e., to a $y$ for which $R(x,y)$ holds) if one of $R(x,r)$, $R(x,r+1)$, or $R(x,r+2)$ holds. (For simplicity, suppose that $y=0$ and $y=1$ are not solutions.) In Emil's solution, it was enough to generate a random string $r$ and output $r\bmod 3$ except that we locally fiddle around at solutions; I don't go into details, see his answer. It is enough for us that if $r$ is close to a solution, then we can kill an arbitrary number$\bmod 3$ by possibly outputting a solution so that for the rest of the $r$'s the $r\bmod 3$ function gives a perfectly uniform number$\bmod 3$. Now, let us suppose that the number of solutions is 1 or 2 for any $x$. We generate two random strings of length $n$: $r_1$ and $r_2$. If at least one of them is not close to a solution, we output $r_1+r_2\bmod 3$. For simplicity, suppose that $n$ is even so that we have an extra 0 if we just did this, and also suppose that if there are two solutions, they are far. If $r_1$ and $r_2$ are both close to the same solution, we fiddle around so that we kill a 0. If $r_1$ and $r_2$ are close to different solutions, then if $r_1<r_2$, we fiddle around so that we kill a 1, and if $r_1>r_2$, we fiddle around so that we kill a 2. This way if there is only one solution, we kill exactly one 0, while if there are two solutions, we kill two 0's, and one 1 and one 2. This argument cannot be extended to 3 solutions, but can be for 4, and from here I'll be very sketchy. Generate four random strings, $r_1,r_2,r_3,r_4$ and output $r_1+r_2+r_3+r_4 \bmod 3$ unless all of them are close to a solution. Again suppose that there's an extra 0 and solutions are always far. If all the $r_i$'s are close to the same solution, we fiddle around to kill a 0. If three of the $r_i$'s are close to the same solution that is smaller than the solution to which the fourth $r_i$ is close, we fiddle around to kill a 1. If three of the $r_i$'s are close to the same solution that is larger than the solution to which the fourth $r_i$ is close, we fiddle around to kill a 2. If all the $r_i$'s are close to a different solution, we kill three 0's. The correctness for one and two solutions is similar to the previous case. For four solutions, notice that we kill four+three 0's, six 1's and six 2's. I think that the reasoning of the the last paragraph could be extended to any bounded number of solutions that is not divisible by 3 with some algebra. A more interesting question is whether there is a protocol that works for any number of solutions. 

An exponential upper bound has been given in Anna R. Karlin, Shayan Oveis Gharan, Robbie Weber: A Simply Exponential Upper Bound on the Maximum Number of Stable Matchings. 

The answer depends on the universal Turing-machine used to define K. Note that a Turing-machine is called universal, if on input "T", x, where T is a some standard description of a Turing-machine T, it outputs T(x) but we do not know anything about its behaviour on other inputs. If on every other input it halts, then such strings exist as shown by mjqxxxx. Howoever, suppose that on input "zip("T")", x, where zip("T") is a more efficient description of T, it uncomputes T(X) and if it is of the form SS and the length of S is about twice as long as |"zip("T")", x|, then it outputs S, otherwise it does not output anything. (On other forms of input, it does not do anything.) This second rule will never give to a string a shorter description than its length, so it will not reduce the complexity of SS type strings. But if we get short description using the first rule for SS, then we get a shorter for S using this second rule. Note that I did not specify "T" or zip, but it is clear that there are compressible descriptions. 

So first, there is the class called IP, see e.g., $URL$ The trouble with verifying is, of course, that the Prover might lie. Now, imagine that you can ask two Provers, who are not allowed to talk to each other, then they might give a different answer to the same question and be caught! This class is called MIP, and is probably stronger, as IP=PSPACE while MIP=NEXP. In fact, it can be proved that having even more Provers won't help. Moreover, we could ask a Prover to write down in advance his answers to all possible questions, turning him into an oracle. This has a similar effect to having two Provers, as to any question you get always the same answer, so the possibility of the Prover coming up with a "random lie" is eliminated. Also a paper I just googled for: $URL$ 

For your first question, if $l=1$, then $\frac{K^\frac 23}\epsilon$ is sufficient. This follows the fact that the lower envelope of some lines has the same complexity as the upper convex hull of its dual point system and if you have a convex polygon with integer vertices in $[0,K]^2$, then it can have at most $O(K^\frac 23)$ sides. I know I did not explain the details, but this is anyhow only a partial answer to your question... 

No. What is a key exchange? Both parties have a private random sequence (that they've generated for themselves) plus possibly some public random sequence (that the eavesdropper can also see). Then they want to communicate so that the other party learns something about the probability distribution of their sequence that the eavesdropper doesn't. But whatever a party says just updates the probability distribution of their random sequence for anyone who sees their message. 

Okay, this seems easy. Below I sketch why it is NP-hard to decide if a unit distance graph has a $3$-coloring. They key observation is that in a $3$-coloring any two vertices $u$ and $v$ at distance $\sqrt 3$ must get the same color if the two vertices at unit distance from them are also present in the graph. With this gadget we can convert the decision problem of the $3$-colorability of any graph $G$ into the decision problem of the $3$-colorability of a unit distance graph $G'$as follows. Map the vertices of $G$ into the plane such that no two are at unit distance. Connect every two adjacent vertices with a polygonal path that consists of segments of length $\sqrt 3$ and one segment of length $1$. Add the endpoints of the segments to the vertices of $G'$, and also the two vertices at unit distance from the ends of segments of length $\sqrt 3$. Now $G'$ is $3$-colorable if and only if $G$ is $3$-colorable if there are no additional coincidences among the vertices of $G'$ but we can pick the paths in a generic way. With a little more care, we can also show that the problem remains NP-complete if we restrict it to planar unit distance graphs. For this, we need to use that it is NP-hard to decide whether a planar graph with maximum degree $4$ has a $3$-coloring. We can repeat the previous construction, just if we map the vertices of $G$ far away in the plane, then the respective paths won't cross. (For this reduction, maximum degree $6$ would suffice.) This also proves that it's NP-hard to decide whether the chromatic number of a coin graph is $3$ or $4$. A similar construction also shows that deciding whether a unit distance graph is $4$-colorable is also NP-complete using that there is a unit distance graph in whose only $4$-coloring two given vertices at distance $\frac 83$ must get the same color. Using this gadget, $\frac 83$ can play the role of $\sqrt 3$ in the previous construction. 

Here I show that the problem is NP-complete. We convert a CNF to an instance of your problem as follows. Suppose that the variables of the CNF are $n$ $x_i$'s and the clauses are $m$ $C_j$'s, where $n<m$. Let $U=\cup_i (A_i\cup B_i\cup Z_i)$ where all sets in the union are completely disjoint. In fact, $A_i=\{a_{i,j}\mid x_i\in C_j\}\cup\{a_{i,0}\}$ and $B_i=\{b_{i,j}\mid x_i\in C_j\}\cup\{b_{i,0}\}$, while $Z_i$ is any set of cardinality $k=2n+1$. Also denote $Z=\cup_i Z_i$ and fix for every $Z_i$ an increasing family of length $k$ inside it, denoted by $Z_{i,l}$ for $l=1..k$. For every variable $x_i$, we add $2k$ sets to $\mathcal F$, every set of the form $A_i \cup Z_{i,l}$ and $B_i \cup Z_{i,l}$. For every clause $C_j$, we add one set to $\mathcal F$, which contains $Z$, and for every $x_i\in C_j$ element $\{a_{i,j}\}$ and for every $\bar x_i\in C_j$ element $\{b_{i,j}\}$. Suppose that the formula is satisfiable and fix a satisfying assignment. Then pick the $k$ sets of the form $A_i \cup Z_{i,l}$ or $B_i \cup Z_{i,l}$, depending on whether $x_i$ is true or not. These are $nk$ incremental sets. Now add the $m$ sets corresponding to the clauses. These also keep increasing the size, as the clauses are satisfiable. Finally, we can even add $k$ more sets (one for each variable) to make the sequence cover $U$. Now suppose that $n(k+1)+m$ sets are put in an incremental sequence. Notice that at most $k+1$ sets corresponding to $x_i$ can be selected for each $x_i$. Thus, if there are no clause sets in the incremental sequence, at most $n(k+1)$ can be selected, which is too few. Notice that as soon as a clause set is selected, we can pick at most two sets corresponding to each $x_i$, a total of at most $2n$ sets. Therefore, we have to pick at least $n(k-1)$ variable sets before any clause set is picked. But as we can pick at most $k+1$ for each $x_i$, this means that for each we have picked at least $1$, as $k=2n+1$. This determines the "value" of the variable, thus we can pick only "true" clauses. Update: Changed value of $k$ from $n$ to $2n+1$ as pointed out by Marzio. 

It is a classic result that every fan-in 2 AND-OR-NOT circuit that computes PARITY from the input variables has size at least $3(n-1)$ and this is sharp. (We define size as the number of AND and OR gates.) The proof is by gate-elimination and it seems to fail if we allow arbitrary fan-in. What is known for this case? Specifically, does anyone know an example when larger fan-in helps, i.e., we need less than $3(n-1)$ gates? Update Oct 18. Marzio has shown that for $n=3$ even $5$ gates suffice using the CNF form of PARITY. This implies a bound of $\lfloor \frac 52 n \rfloor-2$ for general $n$. Can YOU do better? 

I really don't think that there is a known algorithm to be optimal. In fact, there is a major conjecture about how effective a set of code words can be, see: $URL$ (the name I knew for affix code is fix-free code). If an algorithm was proved to be optimal, then most probably it would also solve (or disproof) this conjecture as well. 

Consider $(p,q,m)\in R_k$ iff there is a set $S\subseteq \{\frac{1}{n}:n\in\mathbb{N}, n> k\}$ such that $|S|=m$ and $\frac{p}{q}=\sum_{s\in S} s$, so $R=R_0$. It is easy to see that $(p,q,m)\in R_k$ iff there is an $k<\ell\le \frac {qm}p$ such that $(p\ell-q,q\ell,m-1)\in R_\ell$. 

It is NP-hard for $k=3$. The reduction is from 3-SAT-(2,2), which means that every clause contains $3$ literals and every literal occurs in at most $2$ clauses. First of all, for simplicity, let's admit honestly that this problem has not much to do with automata. Your problem is equivalent to the following: Given an edge-colored digraph where each color occurs at most $k$ times, is there an $st$ path that uses at most $n$ colors? For the reduction, the graph starts from $s$ with a path of length $n$, where $n$ is the number of variables of the 3-SAT-(2,2) input. Each edge of this path is present twice, and all $2n$ edges have a different color. The colors used when traversing this path correspond to which variables are true. After this path, there is another path whose length is the number of clauses. Here every edge is thrice, where the colors correspond to the literals of the clause. We can get to the end of this path using no extra colors (thus in total $n$) if and only if the 3-SAT-(2,2) input is satisfiable. 

If there is such a $\Psi$, then it can be used to make others to solve computational challenges for us (with possibly replacing solving a CNF with other problems - I chose CNF because I wanted to make the problem more specific), in such a way that they cannot profit from a possible solution even if they know what problem we've used them to solve. For example, we could embed a factorization problem into a computer game, which enables players to play only if they work on our problem in the background, from time to time sending back proofs of computation. Maybe software can be even made "free" this way, where "free" hides a (possibly higher) cost in your parents' electricity bill. 

No, you cannot. See Thm 2.1 of $URL$ (it says that a random family gives an example, with appropriately chosen parameters). 

The cutting lemma (a.k.a. cell decomposition lemma) states that given $n$ lines in the plane it is possible to divide it into $O(r^2)$ regions (even triangles) for any $1\le r\le n$ such that the interior of any region is intersected by $O(n/r)$ lines. For more see e.g. Matousek's book Lectures on Discrete Geometry or this post. My question is whether the plane can be divided by $O(r)$ lines (into $O(r^2)$ regions) such that the interior of any region is intersected by $O(n/r)$ of the original lines. 

Lemma. If a graph has a $k$-plex on $m$ vertices, then it has a clique on $\frac m{k+1}$ vertices. Proof. Greedily pick the vertices of the clique from the $k$-plex. Since a clique on $m$ vertices is also a $k$-plex on $m$ vertices (for any $k$), we get that the size of the maximum $k$-plex is a $k$-approximation of the size of the maximum clique. Since clique is hard to approximate with an $O(n^{1-\epsilon})$ factor, determining the largest $k$-plex is also hard for any $k=O(n^{1-\epsilon})$. 

I know that you can use other non-solvable groups, but is there a proof that uses a completely different approach? In case someone would not know the theorem: $URL$ 

Primality was a nice problem that was in ZPP but was not known to be in P. Is there a (preferably simple to state) problem of which we can prove that it is in ZPP but we do not know whether it is in P or not? I know ZPP=EXP might hold and so on, I want a problem surely in ZPP that is not surely in P. 

Kolmogorov complexity is only determined up to some additive constant, so it is not possible to give an exact answer. The bound that I describe here is even weaker. Of course the expected number can be computed easily once we know how many of the $2^n$ strings have complexity less than $n_0$, so let me answer this. It is usually the first statement about Kolmogorov complexity that this number is at most $2^{n_0}-1$ - since there are only these many strings of smaller length. On the other hand, if your program says "of length $n$, take the $x$th number", then you get $2^{n_0-K(n)-C}$ strings of complexity less than $n_0$, where $K(n)$ is the prefix-free version of Kolmogorov complexity of $n$ (so at most $\log n+\log^* n + O(1)$). In more detail, the string first contains the description of the Turing machine that taken input $px$, where p is the description of a prefix-free program that outputs $n$, outputs the $x$th number of length $n$, which is $O(1)$ bits, and then this is followed by $px$. Probably it is possible to improve these bounds, but I doubt that you could get an exact answer.