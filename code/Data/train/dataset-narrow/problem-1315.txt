When running this query as is, using a temporary table built from 's up to 7 from $URL$ I got the following output: 

I'm not quite sure I understood your requirements, but as I understand it you want to find the variant id for a set of values with the values for the three options. In other words, you need to do a double join in order to access the three different values, this can be achieved using some thing like this: 

Performance review You are asking if there is another way to separate your input strings, and there is at least one method using tuples which can achieve this. Then instead of storing you store (or ). However this has a penalty when creating, and when accessing again. When speed is important, it seems like your current solution of postfixing with or is faster, although more unclear when reading the code. I reimplemented the faster solution of David Z as a function, and got a performance gain. But I got an even greater gain when loosing the iterator, and using a previous and current variable set. Here are the two main contenders for performance comparision, the first is a version using tuples instead of postfixing the strings, and not using the pairwise iterator: 

I would also fix the spacing, so that it is consitent. In the three lists/dictionaries/... at the top you vary between having spaces around or not. Personally I like to see stuff with spaces after the separators, so I would try to be consistent with using (that is spaces after at least the initial colon and after commas. It seems like your code might be faulty as you have braces around the but not around the two others? Are the braces optional? If so, it would look better if you used the same for very similar lists. Regarding that last code block I would perhaps include a little more vertical space. And possibly, it it's legal, replace the with or similar. That would make the following lines easier to read, I think. 

Style review From a style point of view, you are violating PEP8, and should name your variables somewhat differently. Maybe something like: 

Performance is important, correctness is usually even more important. In your case I would possibly opt for a combined solution of transformation detailining and performance issue. Build one block to handle all standard cases, that is for when the has good values. This will give you a bulk case for the primary part of your data. Next build a special case for when it is , and handles this in a case by case basis like in your first example. Experience usually dictates that 80 % of the migration work, takes 20 % of the time, whilst the remaining 20 % of work, take 80 % of the time. Once you realise this, you can focus on writing good, precise and fast migration of the general cases, but make sure that you have routines and procedure for all the exceptions which will arise. 

And similar for the other one. This also allows for a little better file handling as Python keeps track of the file handles, and you don't need to. :-) Assign tuples to variables Another point related to readability would be to do something like the following: 

There are flaws in your design, and room for improvements, so here are some comments to choice of coding algorithm: 

Another element not covered is what is typical values of the size and length of the arrays, and this might affect some of the other parameters. This could allow for temporary storage in an another container like an or a , or possibly given larger size to rather use or similar to swap the elements. Using would also reduce the chances of getting errors related to big or little endian issues, which could arise elsewise. 

However there is an even neater solution to avoid most of your code, and that is to use all of the capabilities of the fractions module. Using this module your function can be reduced to: 

Using this construct would allow for your code to be reused as a module later on, whilst still allowing it to be run directly from the command line. It also makes it very easy to understand what happens just skimming the code. 

Lets first review your code, and then introduce you to one alternative on how to do unit tests in Python. 

The operations in here is \$O(N)\$ where N is the number in the list, and that you can't beat. The cost for each element is the creation of one or two sets, and the comparison of those sets, which is dependent on the size of the sets \$O(M)\$. In general since the \$N << M\$, the loop over the elements should be prominent. This means, without changing the data structures there is not a whole lot to be gained, as you do need to loop through all elements, and you need to verify membership agains the list. If any optimization is to be performed it needs to address the actual comparison somehow. Another view on your solution is the readability of your code, and how to understand what is happening. The list comprehension is understandable, but the comparison is not obvious to me, at least, and I would have liked a comment. Or a rewrite, so let us attempt an rewrite for readability and see how it performs. This rewrite is using a Python specific concept to avoid a flag variable: 

I'm not saying this code is optimal, but I think the comments are slightly better, and I've shaved off some methods. Lastly I removed the multiple calls to and which was called 4 times in the original call, with 2 calls to . To me it is now a little easier to see what is actually happening, and it's a little more failsafe as the test for a node is done in all methods, and there are no redundant methods. Update: I was made aware that the could allow a null to pass as an external node, which is not correct. Added a test at start to correct this behavior. This also triggers a question on what is correct behavior for when receiving a null node: Should it cast an exception if , or silently ignore it and return ? 

There are loads of options on how to store and execute equations, and here is one version where you are able to remove all of those / blocks, and where the check of arguments/fields is moved into each equation function. The full code is as follows: 

Coding is supposed to be fun, and there are tons of lessons to be learned for us all out there. Hope this somewhate elaborate code example can give you some ideas for further coding! Happy coding! 

Combine these, and you'll get a fast enough solution. Style review of current code Some tips according to PEP8: 

All three variants has been 'normalised' to produce a number between 1 and 3, and the last variant generates all of the numbers in one go. And the last one is way faster than the other. In other words, I would suggest to pre-build the random numbers, and make a custom generator feeding you from this pre-built array of random numbers. This would potentially drastically reduce the running time of your algorithm. Using a prebuilt random number array Here is a simple rebuild using a pre-built array of random numbers from numpy: 

My other answer says most of the stuff related to your underlying question of how to handle cleanup. In this answer I would like to focus on reviewing your code. 

For the sake of the review, let us ignore the fact that there is both a sum (from Python 2.3) and statistics.mean (from Python v3.4), and analyse your code: 

A better solution related to MongoDb However instead of doing a busy loop with some code which I don't fully grasp, I believe you should look into the monitoring of the mongodb. This would allow you to get notified when commands are executed against the mongodb. At least, that is how I read the documentation, with little knowledge of mongodb. And this pattern of adding a listener, and then waiting for it to respond is a bettern pattern rather than busy waiting and changing stuff to check if it is alive. 

In addition to the new function to actually do the split, I've also added some basic handling to allow for filenames to be defined on the command line. And packed everything in a construct so that the file can be used as a module presenting the function. 

The main change in this file is consolidation of factors into the precomputed and , in addition to using simpler and faster numpy alternatives. The somewhat strange is a little hack related to running the code with or without . The code runs as it stands, but to profile it you need to comment the . If you don't intend to profile it, you can remove the and the decorators. File: 

I've commented out some debug statements, and left it a little more verbose than the original code. If you want, you can easily replace the remaining statements with and . A stripped down version would then look like: 

In other words if you decompose each of the numbers of your range, and then count how many of each you need to create each of the numbers, this can be used to calculate the answer directly. To help you get on the way for the range through let us decompose the final numbers as well: \begin{align} 11 & \rightarrow \mathbf{11} \\ 12 & \rightarrow 2 * 2 * 3 \\ 13 & \rightarrow \mathbf{13} \\ 14 & \rightarrow 2 * 7 \\ 15 & \rightarrow 3 * 5 \\ 16 & \rightarrow 2 * 2 * 2 * \mathbf{2} \\ 17 & \rightarrow \mathbf{17} \\ 18 & \rightarrow 2 * 3 * 3 \\ 19 & \rightarrow \mathbf{19} \\ 20 & \rightarrow 2 * 2 * 5 \\ \end{align} I've bolded the numbers not already present in our set, and those are \$11 * 13 * 17 * 19 * 2 = 92738\$. So the end result will be: \$92738 * 2520 = 232792560\$. So there you have yourself a new challenge: Implement this alternate, but more efficient algorithm. 

Out of these I believe the last one, dedented multiline, or the implicit concatenation (with internal ) are my favourites. (But it's also kind of cool that you could use to get the docstring of the function, and possibly use that!) The two first multiline options fails either on outputted indentation, or not so nice looking code (the code indentation is disturbed). 

It does look kind readable, but there are points I would like to address, in addition to most of the points by codesparkle. 

Notice how the two first files would have gotten a wrongly rename use your original code. Code refactor (added) To accomodate for your question regarding building this into a larger script, and to give example of error handling, I've refactor your code into the following (using the tip from Janne Karila on using ): 

But all in all, stylewise it looks quite nice. Code review I do have some more issues when reviewing your design choices for this utility: 

Now when you, as a developer or support, gets a hold of the exception you should be able to locate where this exception occured in your code base by a single search for "Failed creating user account". This message is not dynamic, but unique. The properties are dynamic, and should add details to the exception. With such an exception you can locate the offending code even though the stack trace is not available, which it wouldn't be if the exception is found is shown in a dialog window or status bar, or in some cases in a log file, or if it being copy-pasted from somewhere into an email. The unique message is also something you can train users to respond to. They can now search in a given list where they can follow some procedures, whilst for other (and unknown exceptions) they contact support. One final note on unique messages, even a unique number, would be better than nothing at all. Just don't let it be autogenerated which renders it useless when you rebuild your code. Some code bases I've seen has numbering schemes like Exxyyzzz where xx can denote module, yy file in module, and zzz could be a running number within that file. 

You've clearly been around, and most of your code does follow the PEP8 guidelines, with some minor exceptions: 

All in all, your code did work locally, but when posting it got a little scrambled and dysfunctional. You should clean up your code to avoid having magic words and number, and rather use constants at the start. And you should cleanup your naming and spacing to make the code easier to read and understand. Text handling and documenting (both internal to the code and for the user) is also areas you need to look into some more. 

This should replace most of your methods, whilst still providing the correct result on whether the sudoku has been solved correctly or not. 

This review is made under the assumptions that the challenge you're solving is the Kattis DVDs challenge, and the proposed solution has not been tested, but hopefully it does do the trick. But before proposing the new solution, lets review parts of your code for style: 

This code expands the list comprehension into the double loop which is hidden in the list comprehension. The inner loop breaks up the list into each element, and tests for memberships. The criteria for the to be kept is that all elements should be members, so if any member is not present, we break out and start checking the next candidate. The trick to this solution is that if the inner loop doesn't complete naturally (aka no s), the part is not executed. Try the following and play with it, to understand this mechanism: 

Could still need some tweaking, but you get the gist of idea to make it more modular, and to make it read a lot easier, which in turns will make it more maintable. 

In addition your code calculates the modulo one time too much as you could already know the answer for . A good way to handle this, minimizing calculations, is to build a list of all fizz buzz words, and then for the final output check if you have values in the list and join them together. If no values in list, return the string version of the number. Code refactored Here is an alternate version combining these suggestions, and an extension allowing for additional fizz buzz words: 

The advantage of this version, is that it doesn't depend on a prebuilt table, which also is it's disadvantage if you are going to test this for a large number of \$N\$'s. Another benefit is that it only calculates as many binary looking decimal as needed, which for \$N = 97\$ would make the loop go until \$i=225\$, before returning the result: "11100001". That is saving over 3800 iterations of precalculations in that particular case. It also displays a different version on how to find all the binary looking decimals, and if so wanted can be a replacement for the calculations used in with a few slight modifications. As the code is untested, I will not claim it to be faster or slower. But the memory footprint, should at least be smaller. 1 Conversion to a binary string based on a variation of this answer 

Please don't use instead of , that is an anti-pattern. Also use construct, as this also allows for your code to used a module from another script by simply importing it, and doing The output could now be like the following: 

I made the into a global dict with integers as key, named . After some testing I found that the extreme variant was slower than expected, so I fumbled around and found this to be the fastest in my environment: 

This code will catch the error situation, and as it stands it will display an error message with the offending line. I've set it to use option b), that is continue with next line. If you want to use an empty string and write the output to file file, uncomment option a), and comment out option b). 

Refactored code running within time limit So as not to spoil the fun for those wanting to solve this challenge by themselves, I've chosen to have the code hidden beneath a spoiler. That is if you hover over the block below you'll see the code. 

At the end I present some bit manipulations stuff, but first of some comments to the style of your script: 

You are specifically asking about how to reduce the number of return statements, where one answer suggest a total rewrite, which most likely is a good option. However to tackle the general question of reducing the number of the return statements here are some ideas to play with: 

Making a true generic implementation for a Generic Deck of Cards, is hard. Very hard. What kind of cards are you aiming to cover? Only standard playing cards? Or pictogram cards? Tarot cards? Uno cards? In this review I'm focusing mostly related to standard playing cards, as used for Black Jack. Natural methods of interfaces Which methods are natural to include in the interfaces, is yet another hard question, and I've got the following comments related to your interfaces: