doesn't seem to be used. It also again assigns even though this already happened in the constructor. 

etc doesn't mean anything. IMHO this should be a with a meaningful as the key. That way you can simply loop through the 's values and use its attrribute to generate the output. 

has eight parameters. That's waaay too many. Instead, construct a class where each of those params is a property, and pass that class. 

If you need comments to document the flow of your method, then you're doing it wrong. Obviously this needs to be split into much smaller methods, each dedicated to their own logic. That was you could move the three lines below to a method of their own that would return a BitmapSource, and you could encapsulate in a block (considering it's an ). Same for : another stream you're not properly disposing of. Quite frankly, I'd move everything inside the into a class of its own and start refactoring from there. 

You're mixing UI and back-end code. There is no reason for the code to be in ; it should be in a class of its own, expose a method that receives the values of and as a parameter, and report back the elapsed time. 

But hasn't changed since then, so all of that logic is pointless. And thus you can remove it, which means you end up with the final version. 

Comments shouldn't tell me what is happening, but why. and don't tell me anything useful. Meanwhile tells me that isn't perhaps the best way to check if you need to do an insert or an update. 

EDIT: To provide some guidance, here's an example of how I handled a similar problem. I had to call a stored proc in an Oracle DB, which required a number of parameters. So I created this class: 

Where did I go wrong? Is there a more elegant way to bind the radio buttons in the View to the code in the AdminController? 

(Not a full review, just focusing on one method.) I think contains a lot of repeated code that can be significantly reduced. First of all I'm not a fan of the "use a switch to set a value that you then return"-approach: just do the return directly, especially if there are a lot of cases. I'd group all of these: 

This should be in a DAL that returns DTOs etc. Binding a dataGrid to a dataTable is IMHO outdated, especially when you need to need to write this kind of code to sanitize the data: 

I also feel those comments are mostly superfluous, describing things that are clear enough in the code. Abide by the rule: Code Tells You How, Comments Tell You Why. 

Then suddenly we encounter , yet is nowhere defined. I assume this comes from outside the loop? If so, then why is this code located here? 

and do basically the same thing, except for the logic in the and the filename. So they're candidates to be replaced by a single method that accepts these as parameter. Of course, the logic is hard to represent as a parameter, so that's an indication you've done something wrong. What if the logic was simply a , ? That would make it easier. So the question is: how can you compare something against that bool? The solution: add a (read-only) property to the class, which returns the result of . Of course, I'm again combining things when your teacher told you: 

is used twice, so perhaps it would be beneficial to store its results. Same for , and in that case it is even more important considering it is used inside a loop. 

Your method is called but it does far more than that, doesn't it? It interacts with the UI, it logs urls that were downloaded, it even retries the download attempt. There's a lot here that looks like functionality that should be handled differently; it almost looks like you've stumbled upon mimicking a queue or a background worker. 

Your class name is yet your methods contain this acronym in all-uppercase: . The naming conventions say: "Do capitalize only the first character of acronyms with three or more characters, except the first word of a camel-cased identifier." 

The also raises some questions: is cast to an -- so why isn't it one in the first place? Same with and others in that namespace. Why the need for and in the first place? It seems odd to use subclasses for such fundamental values. This whole block is just a mess: 

Your constructor is 50+ lines. That's far too long, IMHO. Some of it should be moved to private methods, but I'd urge you to keep lean and move the logic in your constructor to a separate "Creator" class. I'd make into a class of its own as well. (Why is this a method?) Perhaps also look at replacing it with a and finding a more elegant way to fill it instead of a 70 line . 

IMHO the class of a console app should contain as little as possible; mine usually contain little more than an instantiation of another class and a call to its public method. That way you at least escape the requirement for methods etc. to be . You class is approx. 200 lines and is supposed to do half a dozen things: that's way to much. "Ideally" each of the functions should be a class of their own; though sometimes that could be overkill. 

I don't know what you're doing with , but judging from its format and the comments it looks like you're using it to pass arguments in a delimiter-separated string. That's odd, to say the least. I also don't see the point of compiling it inside and then not using its value. 

Comments should say why something was implemented that way. doesn't tell me anything I can't see with my own eyes. 

My main problem is that you'll need to maintain a class that's currently 100+ lines long for a few simple actions that an ORM like NHibernate can easily handle in far less code. Sure, your "WHERE xxx NOT IN" would require a named query, but that's still not that much extra effort. Based on your code right now using an ORM is looking like overkill. But I doubt the above will remain the only functionality. Suppose you'll need to maintain additional tables: that would require you to add another 100+ line class featuring much of the same functionality, so you copy-paste the existing class and change things... But then you feel that perhaps you can make this more abstract and pretty soon you're writing your own ORM which you really should not do. Imagine how much code you'll need to change if will get an additional field. Using Dapper could already reduce your code, although I suppose it isn't that useful if you need to do s and s -- though that's possible of course. 

Things like belong in a separate class IMHO, or perhaps in a config file. Why do you name your parameter and then assign it to the variable ? Plus in your test method you call it . 

That way is less error prone: what if you accidentally switch and when calling the method? (Though that could be prevented by using named arguments, of course.) Your constructor would become: 

You code is partly in English, party in Spanish (I think). Same for your comments. This is confusing; ideally I'd advise you to stick to English. 

I would even consider using the correct types for () and (), though that seems to be a bit OTT for your purpose. 

Now all I needed to do was assign the proper values to the properties, and pass this class to the method where I needed to use the parameters. Is this the ideal way? Not if I had to create a dozen of these classes, no: then I'd made sure to use reflection to figure out the type of a property so I could return the proper OracleDbType, I'd have used an attribute on a property to store the parameter name, etc. 

Avoid names like and , especially considering neither of them is an , they're . Why is assigned? It isn't used anywhere. as a variable name? 

Part of the 50+ lines of shenanigans with (bad name since this is a ) should be moved to a separate method; perhaps even a separate class. 

The logic in that second block makes even less sense to me and seems to me to be in the wrong place. Again the code can be reduced significantly: 

This is an unusual style which doesn't improve readability, IMHO: , , . You don't seem to do this consistently, anyway. 

Why parse the input to an (also: again you're putting a lot of trust in your user) and then cast it to a ? 

I'm worried by the fact that this is created in a . At the very least I'd move that to a separate method, but quite frankly it looks like your UI and business logic is mixed together, which is another bad idea. 

(Note that is a bad name, it should be a more meaningful name.) You then populate that class like this: 

is an incomprehensible variable name, especially considering that it isn't a single item but apparently a list of items. Why do you even create it? Why don't you simply use ? 

Strings like and and get used multiple times, so they too should be s, and of course then moved to that static class mentioned earlier. 

Could you also indicate what kind of project this is? I'm guessing Windows Forms, but it would be useful to get a little more context. 

There are 100+ lines of code here, and all you've done is retrieved one field from one table and displayed that. I'm all in favor of separation, but to me this feels like massive overkill and it is likely to become very unwieldy very soon. It looks like code that would have been barely acceptable ten+ years ago, these days it feels outdated and bloated. 

Your method names do not follow capitalization standards, they should be PascalCase. However, what's worse is that their names do not correspond to that they do: 

Method names should tell you what they do; yet sounds like a boolean and calls the other methods which execute your logic. This is bad design. 

Everything inside should be moved to a separate method; matter of fact make that everything inside . Also, don't you know about ? 

Quite frankly, this still doesn't satisfy me. It feels inelegant. But at least it is much more readable that the original, because you don't need to parse 20+ lines to discover that two separate processes are happening inside that . BTW if was a HashSet, you wouldn't even need to do ; 

does this method need to be public? Does this even need to be a method? I'd be inclined to make it a property: 

The should be inverted to avoid 30 lines of indentation. Why not do and immediately afterwards? Also, is a fairly meaningless name. 

The logic is simple: since the shift is always the same amount of days, I calculate it once (using the earliest available date) and then apply that offset on each day. You could perhaps even avoid using and .