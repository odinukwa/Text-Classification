Where the rest of your logic resides in the sub. But that's vb6. I don't know what the best practice is for vb.net and that's what you're using. Which means that the kind of error handling that you're using is antiquated and only exists for backward compatibility. Any newly developed code should take advantage of the blocks. You can read about them on msdn, but here's some psuedo code of what the pattern should look like. 

Okay, so here's an actual performance improvement for you. Copy/Paste is slow. Only use it if you're copying a big range of data all at once. Here you're copying one cell at a time to a new location. 

The following input from a file will bring cause the check to return , likely bringing the rest of the code to its knees. 

Well, yes and no. You do need to create an event routine for each control, but there's no reason to repeat all of that code over and over inside each of them. Extract the logic into a paramaterized method. Then, your event procedures will look something like this. 

There's not much to review here really. I'd be more interested in reviewing the code that's actually doing the work, but here goes. 

Declare @threshold variable. Set @threshold variable. Create temporary table to store vote_candidate & votes_above_the_threshold. Populate temporary table. Use temporary table in place of subquery in all places the subquery is now. 

Note that utilizing this strategy, you could likely implement all of the logic in one ctor, where it belongs. Braces Use them. Always. Take a look at this snippet. 

But it doesn't matter much, because this method is kind of a useless abstraction. I would just directly set , etc. 

Obviously is not a very good name, so I'll leave that as that. The other thing that immediately jumps at me is the poor formatting. It's hard to read multiple items strung across a single line. Doubly when they're aliased. 

I think it's important to remember that is not always the best name for generic types. This is definitely important to remember when you start numbering them... 

The prior means that you added a reference to the Scripting Runtime, yet you've declared and as types. The latter declaration should really be strong typed and look like this. 

But you never do any checking of those values. So one of two things will happen when calling the function with invalid arguments. 

Looks fairly clean to me for the most part. You could reduce nesting a bit here by extracting a boolean method in the code behind. 

I'm wary of any name that has the words or in it. It often indicates that something has too many responsibilities. Names like inside of a class are also indicative that you should be considering some inheritance and an OOP approach. I'm not saying for sure that it's better, but you may want to consider using an abstract base class that both and derive their common functionality from. 

This is what I came up with. I couldn't test it, but it should be pretty close to what you need and easier to understand. I went ahead and just renamed all the variables to something meaningful. 

It looks pretty clean. As far as I can tell, you have a good separation of concerns. Everything is properly cased and your functions have verb-noun names. All good things. The only nitpick I have is the variable. I'm not a fan of ultra short names of any kind. You could call it or some such thing. Seriously though, that's a huge nitpick. I just couldn't find anything else to comment on. 

Potential Memory Leak At the very beginning you declare an error handler for an undefined line label, but you never use it. This means that if an error occurs, the record set never gets properly closed and released. You should put the clean up code in a "finally" block using the pattern. (If you look at questions tagged vba + error-handling you'll find one of my many answers on the topic.) SQL Injection You're concatenating arbitrary user input into a SQL query. This is terribly unsafe. It allows a malicious user virtually full control of your database. I recommend this Tom Scott video for a primer on the subject. Style 

I think you've done a great job of creating comments that say why, not what. That's very promising. Well done. You also did a great job of keeping your main method small and the "business" logic separated from the input/output of the program. One small thing to mention in addition to what's already been said. 

Which seems close at a glance, but really doesn't hit the nail on the head. An ArgumentException would be much more appropriate here. Even better, use an exception to perfectly describe what went wrong. 

So, I believe you could remove the second half, but it's possible that it's actually a bug and you need to think harder about what it is that you're trying to check. 

If you stick with the regex to do this, you'll find that you can use an almost identical pattern for several implementations. For a hypothetical you would have this: 

Is there any reason you don't just use the cancellation token to stop the thread? I'm also wondering why you're using an explicit thread at all. This is asynchronous programming the hard way. async-await and s are the idiomatic way to do this for the last several versions of the language & framework. I'm imagining your code looking something like this. (Totally untested. Might not compile.) 

This is similar advice to what you've already received, but I'd like to expand on why it would be better to return an . First off, it's always better to code to abstractions rather than implementations. is an implementation of . 

Refiddle here but that sucks too. Like you pointed out in the comments, this pattern would be closest to spec on argument naming. 

This is terribly error prone. It's hard to get right the first time and it's even harder to refactor later. Always use . 

As it is, is still alive after the loop has ended. Also, doing it this way means that you have to manually increment the index. You should declare and initialize it in the loop header and let the language do the work. 

But I personally don't like doing that if I can help it. You can remove the need to implement the interface if you keep your connections short lived. 

I would opt for option number three myself. I hope I've done enough to convince you that is not really the same thing as an . Making it it's own thing makes sense. This could also be considered the most "correct" thing to do because you really should never change an interface once it's been created and used. To quote CPearson: 

Well, you say that both and inherit from the base class . Considering that, and the fact that you never actually use either the Student or Teacher specifically in this code, why bother checking the Role at all? Your is taking in a person, not a or a . Now, if I would happen to be wrong about that, I would suggest looking into the Factory Pattern. You could create a factory that takes in all of the fields from your GUI as arguments, and decides which type of to create based on the arguments it's recieved. It won't do away with all of the logic, but it will abstract it away and hide it from your GUI and make your code more testable. 

I have an SSIS package for SQL Server 2008. In this package, I need to verify that a file exists that matches a pattern of where the wild card replaces a date. It doesn't matter what the date of the file is, just that any file matching that pattern exists. If a file does not exist, I need to fail the package before using the built in "For each file loop" task. This allows our server to alert me to the package failure. It's a pretty simple bit of code, but it has a huge smell. I'm catching . I think I'm doing it for the right reasons though. Basically, I'm saying that if any exception gets thrown, fail the script task, and thus the package. Is this a case where it's okay to catch all exceptions??? For reference, these are the possible exceptions that Directory.GetFiles can throw. Of course, I'm pretty new to c#, so please let me know if I'm doing anything stupid. (Yes, I know I'm programming in , but this is short and sweet. I don't see the harm just this once...) 

For now, let's ignore the fact that there are easier ways to add binary numbers. There are other issues with this code. 

Use braces around that else, or at least add a newline before the next statement. —- There’s more, but that’s probably a good start. I’d try to fix those issues (everywhere, some of them show up in multiple places) to make it more readable then come back for a second review. 

Do yourself a favor and generalize your Serialize method a little bit. It should be generic and take in a file path as an argument. 

You can early bind your objects, eliminating the time COM takes to do a dynamic lookup. However, the time this saves will be minuscule compared to the total runtime. 

Are you sure your id system works as expected? If I recall correctly, a new controller instance is created for each request. That means the id will get incremented, the class will go out of scope, and then the next call to the controller will create another entry with an id of 0. 

Which is fine. You don't want to use a boolean because you'll be adding more status codes in the future. Cool! But you shouldn't be hard coding the error code numbers. This is what enums are for. 

White space is your friend, particularly if you're focusing on "people friendly" code. (That's a noble goal by the way.) 

It's a small point in comparison to the other answers, but worth noting for a beginner. This is the LED header file. 

There is almost always a better way to loop in Ruby than actually using a loop. Unfortunately, I don't know Ruby well enough to say what that better way is. What I can say is that this line of code is a bit obtuse. 

See how it doesn't matter what type we get back from the factory? All of the differentiating logic is stored and implemented in the specific concrete implementations. 

isn't a good name. It doesn't say anything at all about what the subroutine does. It doesn't seem to make much sense to have a subroutine here at all. You could remove the statement and just execute it in your main script without changing the semantics or execution at all. (I don't recommend actually doing that, but I'm not quite there yet.) 

This is not for the faint of heart, and I wouldn't want to tackle it without an excellent refactoring tool like ReSharper and a copy of Working Effectively with Legacy Code by Michael Feathers nearby. Best of luck. Remember, keep your changes small and safe. Don't change logic if you can avoid it and drive as many tests as you can at the code before changing it. (Although, you'll have to make a few changes to make it testable first... So... Slow and steady friend. Slow and steady.) 

Next I created a model that is a subset of the full object from the 3rd party library. ./Models/SurveyModel.cs 

There's no reason to set here. You're already doing that by passing the argument to your base class' constructor. Both of your subclass ctors could look like this. 

So now, we can go ahead and write that method. We'll pass in the actual checkbox control along with our predefined true state and false state. 

There's no reason to Activate/Select all over the place here. You use variable reference elsewhere, there's no reason not to do it here too. 

I'm honestly not a fan of concatenating cell addresses like this, but I think it does a world of good to the readability and maintainability of this code. While we're at it, I think this is useful enough to extract into it's own subroutine. 

First, I find it in consistent to use a sub in one place, but a direct raise in another. I know you're only using error #9 in one place now, but pulling this out will certainly make it easier to use it elsewhere in the future. But I mentioned the magic numbers didn't I? Normally, I would recommend defining some module scoped constants to make it clear that the code is raising a Subscript out of Range and Type Mismatch error (respectively), but these are built in VB errors we're raising. We're likely to use these in many places in many modules. Given that, I think it's absolutely worth the time to create a module with a public [VbErrorNumbers] Enum. It's some work, but you only ever have to do it once. In fact, I believe I'm going to do this myself later today. A full list of built in VBA errors can be found here. 

returns a boolean value, so what you're saying here is or . When you think of it this way, you'll see that you can simplify this by simply saying . 

Then any change made to will "cascade" into . This means if you ever change it, you only have to make the change once instead of twice. This also simplifies the Heavy class a little bit. 

Now, it's tempting to get rid of the BAL when it's just passing through like this, and eventually you might, but for now, leave it in place. It'll give you some wiggle room while you're replacing that abomination of a data layer with something modern. Next thing to go is the declaration on all of the BAL methods. Just remove it (one at a time!), then compile. Follow the errors until you've instantiated instances of the class everywhere you need it. This is called Leaning on the compiler. Once that's complete, you'll need to stop returning those s from the BAL. This will be by far the most tedious and painful part, but well worth the effort. Start modeling the data and creating POCO's to be returned from the BAL. Databindings client side will need to be updated. This means invasive changes in your views. Use the BAL to map the s coming out of the DAL to your POCOs. For example: 

There's an unofficial principle I try to abide by. I call it the "Single Page Principle", but in this case, we'll call it the "Single Screen Principle". What that means, is that any one method should fit nicely onto one screen without scrolling. Scrolling breaks Mr. Maintainer's concentration and focus. 

I'm not terribly familiar with directly working with pointers this way, so I have no idea why this uses . A well named constant would help a schmuck like me understand what's happening here. 

That's a familiar smell. I came across the same thing when I was building a test framework in vba. Fortunately, you've got better tools at your disposal than I did. This is easiest handled by creating a custom attribute, marking your test methods with it, and then reflecting over the code to generate a list of test methods to be run on the fly. Implementation is left as an exercise for the reader. 

It seems that someone else has addressed the structural issues, so I want to talk about Naming. Naming is hard; I get it. Still, I cringe every time I see Hungarian notation. Particularly in c#. It makes my eyes bleed. Why? Because it's useless. The IDE will tell you that it's a Boolean. So kill the Hungarian notation with fire and replace with . 

It's much better to use proper constructor injection of dependencies. That makes it crystal clear what is needed to make your class work. 

Jenkins DSL doesn't support and from what I can tell (I get missing method exceptions when I try), so I implemented my own map & reduce functions to use. I'm not sure if there's much to say about this small snippet of code, but I'd love to hear from some groovy or FP folks. 

Using a filter allows you to access the interface members. Of course, that means you'd have to go mucking around with the auto-generated EntityFramework classes making them all implement a common interface though. So, all in all, I'm not sure I'd recommend it. Boilerplate code is the price we pay for working with many frameworks. 

To make matters worse, you decided to use parameter names for the dictionaries that almost identically match these types. It took me far longer than it should have to grok what is really a pretty simple signature. Being represents a 's type and represents a 's type, I would recommend the rather idiomatic and over the generic name. (No pun intended, I swear.)