Yes you can have different formats if you like, the default __toString() call will result in something like: 

First i have introduced an overloaded method to remove the null check against the List (null object pattern for collections are the empty versions of them). Changed the type to ICollection which is more flexible and intruduced a new static member which get involved in the process where no parameter is passed (can be static for reading it is thread safe). I also removed the AddRange call becouse internally it is interating through the parameters with a foreach loop but only works with Array type parameter so after introducing our foreach loop calling Add manually we have removed an extra ToArray() call which would involve an unnecessary memory copy in the background. Also changed the fill of the DataTable to a more used way and the MySqlHelper.ExecuteReader() does the same thing too. 

This will mean that if we have an url like book/details/5 then the framework somewhere will instantiate the book controller and call it's details method with parameter 5. 

Seems like that might cut the time in the final loop by almost 50%. The extraction from match_iter doesn't change, so it will take the same amount of time. The append will take about the same amount of time as one of the appends you're already doing. Since two appends will be eliminated, I think the time they're taking will go away. 

That way, apply_filter doesn't have to be aware of the list being built. It just returns a list of what it finds -- either a line that passes the filter or an empty list. Passing an empty list to extend is a no-op. 

Overall, it looks pretty good to me. I agree that you have good commenting and variable and function naming. I see just a few things to comment on. 

Let's see if I understand what's going on with get_filtered_lines() and apply_filter(). First, get_filtered_lines() reads physical lines from the file and strings them together in line_buffer. When we find the beginning of the next logical line ('['), we pass line_buffer off to apply_filter() so the material that has been collected gets processed. Then we empty out line_buffer and start over with the beginning of the logical line just read. Here's an approach I think is simpler and clearer: 

You can derive from the model class without any problem your attributes will get applied in you view model also (not every but for exmple the validation attributes will). I also recmommend to have copy constructors becouse they can help you a lot. Beside this my opinion is that no need to worry about display/display format attributes in you model classes it doesn't feel an incorrect way and it helps to keep things clear if you have a lot of derived classes. 

The second one seams to me a better approach but you say that the ManID is a primary key, so why are you handling it as a non primary key and using the query result as a sequance? 

First i have provided az overload to avoid unnecessary passinf if the IEqualityComparer and in the method i'm checking against null values. Then checking their references because if they are the same there is nothing to do. After this i'm using the as operator to check if the input collections are real ICollections and if they are are their Count equal. The casting is fast no need to iterate throught the IEnumerables to get a fixed size collection to get the item counts. Next step is to get the item counts it is using a Dictionary (as Hashlacher did it) with another casting to try get the initial size of the dictionary (not good idea when we have a list with 5 million items but every item is the same). If we have the counts we can make another checks against them: if the item counts or the null counts aren't equal then the collections aren't equals. If the counts are OK then we try to check every item from the source collection whether it is in the other or not. If not the collections aren't equal. 

Locking As I read the code I can see that any public method has big which should be fine for thread safety. Any transactional usage would need another locking, but that is not problem of your static class - well, you could somehow expose the locking (e.g. creating helper for code like ) but it looks fine to me as it is. Private members do not use locking. That is fine too. Style Well, looks like you are half the way between C++ and C#. Namespace starting with lowerCase, UPPER_CASE_WITH_UNDERSCORE constants (as in C# is more like in C++, not good old ). and ...hmm, nothing to add - that's C++ not C#. Second Look (added) Well, it is thread-safe as it can be, if that is your only concern, but the whole class is... ehm, ugly, sorry. Why ? Why Get/Set methods instead of properties? Why locking at all? I would rather think about singleton pattern (init once, live forever), remove locks inside simple getters (but leave the simple check to throw if you forget to call ). Or it can be full class - just create it with proper args and get the info parsed untill you free the class. I can see only one setter - , but the is only used in getter and , but I guess you can use it to index some of the lists... so, why not returning readonly collections? Maybe I am missing something here (the expected usage), but I would really design it in completely different way: 

So display() keeps showing the menu as long as userInput() returns None. userInput() returns None if the user's input doesn't match a button, or the inputSel value if it does match. I think the way the Controller loops is fine. The program will always stop when it gets to raw_input() and read stdin until the user hits ENTER or RETURN. That's what raw_input() does. You're managing your buttons as a list, which means you have to scan the whole list until you find the navigation element the user selected. If you put them in a dict, you can simply use the user's input to index directly into the structure and select the correct button (or determine that the user's selection is invalid). However, you still want them as a list for display because you can't control the order in which entries are pulled from a dictionary and I think you want your menu to display in the same order every time. That needs a list. I would suggest the following for the constructor for the Display class. We're going to pass in a list so it's easy to define, and we'll keep the list, but we'll also have the class internally turn that list into a dict so it can more easily find the user's input on each selection. 

The construcotr may not contain any business logic/work process Your logic is not enough clear to me (hard coded WHERE clause first [id=2] then in getNumVisits() is just a simple select all query, etc.) No they should not be used in classes, force to inject them into the worker methods (ISession interface) Clarify your logic please Just read the common OO and SOLID principles, search for Martin Flowler's name 

Yes, there is: create a stored procedure and UNION the result sets then sort the records and return them to PHP. 

You aren't over complicating things - you try to over simplify them. Class loading In your solution you are loading all classes if only (for example) 2 of them required to serve the request the loading of the other 52321 class is just a waste of time and resources. Read about automatic class loading: Autoloading Classes With this feature in your mind you can create a custom logic to load the necessary classes (name resolution, class location in file system etc.). Template The other thing what you want is loading your templates into the rendering process. This is hard to do it right, all depends on your "framework" solutions for example naming conventions, is your app frame an MVC based stuff etc. 

Style No complains about style. Parts nicely separated (initialize_board, print_instructions, ...), consistent indentation. Good :) ...but provide full code with all the 's (or enums/consts) next time, that I don't have to guess what e.g. is (looks like ). Design and Pointers I see no problem in the design or usage of pointers. EDIT: removed complain about My fault, it is correct. 

After some tests (adding more time-points), we can find that the double for-loop used to find all abundant numbers is the slowest. Now we can think about speeding it up, by shortening the inner loop. We start with and try every number we find can divide upto . We immediatelly know that the product will of course divide the number as well, but need to take special care for numbers of the form . 

Normal Class (not static) Read-only (getters and reaonly collections) Tiny objects if you really need to change the index - create helper class that can access the collections and return the indexed value. 

That looks like you plan to derive from while providing and in the constructor and overriding which should therefore be . Did I get it right? Await Response Unfortunatelly, I am forced to use .NET 3.5 and therefore don't understand / that much (use threads and events instead). I hope that some override in your or casting the result to appropriate type (as the original returns , not or ) will solve the problem with type and later usage: . What I don't like is the active waiting (or it at least seems to be active waiting): 

GraphicalView, OscilloscopeView, and DioramaView each have to implement curve() and line(), obviously, each doing the right thing to display the shape described in its own terms. 

One way to get the neighbor coordinates without checking for (a != 0) or (b != 0) on every iteration would be to use a generator. Something like this: 

With the simplification in userInput() and display() above, the shouldCycle member goes away. Now, with the menu defined internally as a dictionary (self.menu_dict) and as a list (self.menu_list), display() and userInput() will look like this: 

So, let's say you build a website that uses this class for storing data. Then, one evening, you and I both visit the website at the same time. We both hit the button that opens the table and reads the data into memory. Now there are two copies of the data in memory -- one in the page you're looking at, one in the page I'm looking at. You add a record. The "insert" function adds your new record and writes the file to disk. Now I update a record. But the copy of the data in my window doesn't include the record you just added. So when my instance of the code hits the statement file_put_contents(...), what happens to the record you just inserted? This is the sort of reason it's recommended to use real database engines like sqlite or mysql. They're designed to serialize calls and protect users from each other so they can't overwrite or corrupt each other's data. 

Beware that the comparision operators need some fine-tuning especially when you compare integral vs. floating-point (which to choose as common type) and that in conversion operator may be problematic (not sure). (Finally imagine , but I use my own header while explicitly using selected std features/classes in the namespace and then using the namespace). 

?? Again and again in the loop? You don't need the . And I would personally use instead of as type of the variable, in constructor, (or some readonly collection) as property type and some during the build phase. 

Hacky ways vs. BOARD_SIZE It appears that you have board of size 3x3 and never tested with bigger board, because this won't work for bigger board: 

Code Styling Your code is very good at first look. Good structure, code-styling, new features used, clever trics. Functionality and Usability The message is for the user, the code is for you to debug it. Exceptions currently allow adding good message and naming properties won't help a bit (to the user, if it is designed to tell the user: "You did something wrong" like "Wrong Value Format"), but to diagnose problems, you'll need more than property/method name. And for that, you have the stack trace. To state it simple: the problem is not in the exception and what additional info it can carry (it already has the stack-trace), but in the way you present it. This is my own code I use: 

You don't need "if not out:" at the top of this -- you're in a "while not out" loop and out hasn't had a chance to change since the top of the loop. The "for items" loop just scans through the inventory looking to see if you have the door key. That can be done in a single statement, as I show. Once you've opened the door, you're out, so we can just break out of the "while not out" loop and carry on from there. Several of your descriptions are hard-coded: 

Actually, I agree with Quentin. For a first effort, your code looks pretty good. You have a hero class called Erdrick and an Enemy class instantiated as a Slime. A class structure like what I show below would allow you more flexibility with less repetition. See what you think... You might want to work out some way for specialized weapons to increase the damage a hero deals and for armor to reduce the damage suffered. 

I think using that form of the import will let you drop the line where you instantiate the Publisher. I like to put my mainline code in a main() routine right after the imports so it's clear where the work begins