Note this will render anything actually in that directory inaccessible (but not delete it) although from the sounds of things there was nothing there to start with. In any case, the contents of that partition -- -- should resemble this -- and it must be there or the Pi would not work. That github repo actually doesn't contain a , but whether or not there's one there on your system, that partition is where you want to apply it. If you mount this before running it should work out. If you don't want it in , manually: 

Here 'height' is in meters and is 101.325. In case this is not clear, it means 1.0 - (height/44330.0) raised to the power of 5.255, times mean sea level pressure. This is for kPa. You would subtract that from sea level pressure then add the difference to the adjusted for temperature figure. That should nearly match the number from local weather. 

That's not how mobile networking works. You cannot have a static stable IP for incoming connections. This is not the same as your provider actively preventing anything, it is simply a limitation of the context. The fact that the unit is not truly "mobile" doesn't make much difference. You could route through a server with a stable address or domain (a domain can resolve to a dynamic IP). There are paid and unpaid services for the latter; I think the best known is "no-ip". 

That's a B+ running pidora, but raspbian is the same. It's been on four or five days. The largest userland process is actually , which manages DHCP for internet service, then (which is optional on pidora, but required on raspbian sans systemd), then , then (on raspbian, that would be ). The init setup is reduced from stock (e.g., I don't use NetworkManager), but not drastically. and other tools don't report the memory used by the kernel, which is probably about 5-10 MiB. You will get much better performance if you do leave a decent amount of free memory due to file caching. You can of course also use a swapfile (raspbian does by default), but using significant disk swap will slow the system down. 

Below is a picture of a cable end I made by bending pins to span what looks to be about the same gap as an "AD-100" one day when I did not have the patience to wait for a cobbler type breakout in the mail: 

If you call to do anything in the src directory, it will use the src directory makefile which will include the correct src directory headers. 

Errors and usage are explained in 1 <- note the 2 here; that's the system calls section of the manual system (see for more about sections). You have to use numbers with the uid/gid argument; you can get those with : 

You mention in a comment to RooTer that A) you have reduced the initial partition size with , but still copies the whole card, and B) that you want to include both partitions in the image. Issue "A" is easy to explain: you are still copying the whole card because that's what refers to. The individual partitions are of course and . This is the complication in issue "B", but you cannot simply each partition and concatenate the two files together, because of the partition table at the beginning of which indexes the beginning and length of each partition. Without that, the image will be unusable. However, you can get the length of each partition from , and use that to determine some parameters for . For example: 

Yes. This is to stop the kernel from using that for console output (boot and warning/error messages). Make sure that file remains all one line. Parameters should be separated by spaces, but key/value pairs should not contain any (i.e., , not ). 

You have two choices in this kind of situation. You can try and build from source, which is sometimes wonderfully easy and sometimes plagued with problems; I don't recall doing it with omxplayer so can't say which is the case. The other choice is to see if a precompiled version can be made to work. There is almost always a way to get Debian/Raspbian packages working on Fedora, because the latter is almost always ahead of the former in terms of software versioning, making it easier to satisfy dependencies. If an application depends on (e.g.) libxyz, it usually isn't on only one version of it, and latter versions of the library are usually intentionally backward compatible on a ABI level. So if libxyz 1.2+ is required and the system has libxyz 1.6, you are probably good to go. A complication with the Pi, particularly for applications which exploit the GPU, are dependencies in , which is not part of stock Fedora ARM. I believe there is an official spin for the Pi now and presumably it includes this, but if you are not using that, I have an explanation of what you need to do here. Once that's taken care of, you need to find the precompiled version. With a lot of stuff you can download it manually from the Raspbian archives and unpack the -- but in this case I don't see it there. Fortunately someone maintains builds here, in a package (as used on Raspbian). As per wikipedia, these are standard / files. To unpack on Fedora: 

In the code implementing the class, the direction is set by writing to the file in (for this case) , once that directory exists (by writing to as mentioned above). The rest of this requires further explanation. The event triggers make use of the or system calls. These are not perl, although perl like every other language has a wrapper for them. They are most commonly used in networking and IPC; they allow a number of file descriptors (presumably, network sockets) to be polled for readiness to read or write. Basically, you submit a list of file handles, and the call blocks until one or more of them is ready. This is not any kind of busy or half-busy loop. Depending on what the handles refer to, the kernel implements this via genuine hardware interrupts. Such calls are often used as the opening condition of a program's "main loop", and that is the model I will follow. Like a server, we are just going to wait for and respond to events when they happen. I'm using three buttons to demonstrate that you are not limited to just one at a time. This is also a single-threaded exercise. Note again that ALL general purpose languages will have their own version of and/or , which is why this is a language agnostic methodology. You should be able to find out what they are easily. If you haven't used whatever it is before, you will want to read the documentation and perhaps find some examples or tutorials. I prefer , so I'm using perl's core module. The file you actually want to hold open for the descriptor/handle is . However, there are a couple of special things to note: 

There is no point in changing to to on a normal Raspbian install. Those are partition numbers starting from one and there are only 2, so will never work. NOOBS uses additional partitions (and it is not impossible for the numbering scheme to have intentional gaps, but Raspbian does not -- see comments at bottom). The original error is probably because the partition table was corrupted. If you have another linux machine or something you can run on stick it in that and look at the output of to see what happened. Unfortunately, unless you have a backup copy or the original image you installed from, figuring out how to set up/correct the partition table will be awkward because the boundaries have occasionally changed. If you don't have something with , there are probably other tools that could be tried on any operating system, but again, you will have to use them to investigate the state of the partition table first. Even if you do restore the table, there is no guarantee the data on the second partition will be okay and you should make sure to run on it before you do anything else. However, the fact that the system still boots is a good sign -- the corruption might be very limited. 

Yes, that is high level configuration and would likely be the same if you ran your desktop with the card (if lower level stuff permitted that). 

Since it apparently worked on the copy, it should work on the original. You should/may have to ensure that the partition isn't actually mounted at the time (there's no need for it to be); should work for that. Doing this will be simpler and probably less time consuming than using the repaired copy. The first partition should be checked too; since it is vfat and not ext: . 

Some of this is likely for the NOOBS menu, and some of it maybe passed as options to the kernel or init -- in any case the general idea is pretty clear. I would not bother investigating further as I doubt this system will suit your purposes well. 

The bottom line updates every 2 seconds. As an example of the class interface, this is done like this: 

An Alternative to Staying Foregrounded with init... The purpose of leaving the X invocation foregrounded is just to block the execution of the init script until X exits, so that the next line in the script () will run: 

Wow, you improved that by < 1 MB, which could happen as a matter of course anyway in the time it took to enter the command twice. That "drop caches" trick didn't really gain you anything. In fact, it only made things worse. 

According to wikipedia, the Network Time Protocol used by default on Raspbian and millions of other networked devices and computers: 

However You don't have to completely disable it. You need to find where the rules are and change them. There could be a file in /etc called, eg, "iptables.rules". Optionally, you can create a file from the current loaded rules with: 

Notice none of those have anything to do with the hard float ABI because if you are using the compiler than came with your pi B+ distro, it will use the correct architecture settings anyway. Adding will be totally meaningless except to add extra wear to your , and keys. Sort of like ordering a cheeseburger by saying, "I'd like a cheeseburger with cheese and a beef patty in a bun". If you are referring to a cross-compiler (you don't mention this in the question) you could use those, but if you got it from the official github tools or used a sane approach when building it, they'll be irrelevant there too. Note that if you are using an armv7 cross compiler for the 2B (these are stock on most linux distros, unlike armv6 capable ones) you should leave out , it won't work, and armv7 binaries will work fine with Raspbian and other armv6 distros on a 2B. 

The is not necessary but it will make the space need for the modules much smaller. There should now be a in that directory. Copy the directory into on the SD card's root filesystem partition (the 2nd one). If it is mounted on : 

No. As you can see below, on the Zero v 1.3 the camera connector extends completely to one end and the SD card holder to within a mm of the other -- and slightly outside that line there's a resistor (?) mounted (immediately below the holder in the picture), so you probably do not want to file anything off. Looking at one in my hand I'd say if you removed the clip from the camera port first, you might be able to take a millimeter off that side and 0.5 mm off the other. Unfortunately this is less than 1/16" total. The 2.6" measurement is also accurate. 

You could try hitting enter a couple times, carefully (since you won't be able to see it properly) typing , then hitting enter. Here's what that's about -- you don't really have to read it, the point is it's with regard to the terminal settings, not the system in some more serious sense, so it is harmless even if it doesn't work and won't have any weird side effects. If that fails, try . For future reference: $URL$ Looks like the python shell has a "help" feature and you can exit it via or ctrl-d.