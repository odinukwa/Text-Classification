I take you to mean that you want to tokenize a language similar to the one recognized by the standard POSIX shell (since you tagged [posix] and presented an example), or maybe even that exact language. You posited in comments that perhaps you needed a parser generator such as or for this job. Although these tools can indeed do such a job, code for such a subsystem -- a "lexical analyzer" or "scanner" -- is more often generated via a different kind of code generator; and its GNU variant are the canonical tools for this purpose. These two particular tools allow you to describe your tokens (and separators) via regular expressions, and from such descriptions they generate C code for a table-based DFA that processes the language character by character and splits it into tokens. This is certainly one plausible way you could proceed. On the other hand, depending on the language you want to recognize, it's not necessarily unreasonable to write your own lexical analyzer from scratch, or in favorable cases to use an available function such as to do the job. This affords the possibility of a better-tuned implementation than can be produced via a general-purpose tool (or not), it does not incorporate an additional language into the project, and the source might even be smaller. You ask, 

General comments Be aware that there are other C dynamic array implementations available, including at least one other I can think of that is implemented entirely with macros. I am uncertain, however, whether there are any others that attempt to cleave so closely to the C++ interface. I am by no means convinced that that's a desirable characteristic, but neither am I criticizing the project on that basis. Macro form The usual convention for the form of a macro that must provide a code block is to use / , not / : 

Code style Whether you write an / chain with common actions afterward (my preference, and your original approach) or a series of separate blocks, each of which returns, do put the body of each conditional block inside braces (), contrary to the example presented in another answer. Omitting the braces creates a big maintenance booby trap, as last year's major Apple SSL vulnerability demonstrated. 

Sieve implementation The Sieve of Eratosthenes is a reasonably good choice. There are other prime number sieves, but the SofE is pretty simple to implement and surely adequate for this task. Your particular implementation could be more efficient, however: 

(Note that typical implementations of , like , do not evaluate their operands). That approach will not work for , however, or any other macro that must expand to an expression, because declarations cannot appear inside expressions in C. Error handling Several of your macros afford the opportunity for memory allocation failures. You appear generally to have reasonable handling for those cases, except that there is no mechanism for informing the user that a failure has occurred. A user who delved deeply enough into your implementation could probably figure out per-macro means to check whether each macro succeeded, but the macro set ought to provide a standard mechanism. Perhaps you could provide a member in your dynamic array structures that serves as an error flag, and macros to test and reset it. (Lack of) memory management The code does a decent job (modulo my preceding comments) of managing the memory associated with each dynamic array itself, but it has no provision for managing memory associated with array elements. That becomes important when elements are pointers to dynamically-allocated memory. This might be acceptable, and certainly it leaves your code simpler, but it would be well to at least discuss the topic either in the general documentation or in the documentation of macros that can cause elements to be lost. Specific Comments Don't rely on pragmas Other than a handful of standard ones, pragmas are implementation-specific. Do not rely on them in code you want to be portable; specifically, in this case, use standard guard macros to protect against multiple inclusion, not . is misleadingly named This macro takes a declared dynamic array structure as an argument. It does not create a dynamic array, as its name suggests; instead, it initializes one. Personally, I would name such a macro . should set the pointer to NULL Since does not, in fact, destroy the dynamic array object itself, it should do its best to leave it in a consistent state. That would involve setting its pointer to after freeing it. This leaves it in the same state as would a failed allocation by , but more importantly, it avoids undefined behavior in the event that the dynamic array object continues in use instead of being discarded, for is a valid first argument to , whereas a pointer to space that has been freed is not. You might also consider renaming this macro, since its name doesn't quite fit. No especially appropriate choice of name immediately occurs to me, however. The best I've come up with is ; YMMV. Surprising behavior of will shrink the allocated space if the requested reservation is smaller than the array's current capacity. This is not what I would expect based directly on its name, nor is it analogous to the behavior of . Moreover, it is unclear why you need this, in its current form, in addition to . Macro overkill The and seem a bit overkill to me. Just make it clear (for C types; C++ folks will already know) that the iterator type or each dynamic array is one that is suitable for use with the dereferencing and pre- (and post-)increment operators. While you're at it, there's no need to hide that other standard pointer arithmetic works, too. works only for scalars Because of its reliance on comparing elements to the specified value via the operator, is unsuitable for element types other than arithmetic types and pointers, and for pointers it tests pointer equality, which may not be what is expected or wanted. Consider, for example, if the element type is -- how does a user count based on the contents of C strings to which the elements point? And it's worse for some other element types (structure types, for example), for which expanding this macro produces invalid code. At the very least you need to document these limitations, but it would be nice to have a version that relies on a comparison function. Unneeded reallocation in and These macros reallocate space if the new size is greater than the current size, but they need to do so only if the new size is greater than the current capacity. Problems with printing The given implementation is workable only for certain element types -- mainly C strings and scalar types. It cannot be made to print the members of a structure, for instance, if the element type is a structure type or a pointer to such. If this macro is supposed to provide a general-purpose facility then it probably needs to have a parameter by which an element-printing function is provided. 

Before I go into details, I feel obliged to say that your project is fairly ambitious for a C beginner. I have several criticisms, which I hope you will receive as constructive, but overall, your code makes me suspect that although you are new to C, you are not new to programming in general or to multi-threaded programming in particular. If I am mistaken about that then please take it as a complement. Data races Your code contains some data races involving the manipulation and testing of students' variables. The main thread modifies these as a result of command input and at shutdown, and each student's thread both reads and writes that variable for its own student. Some of the student threads' accesses are performed under protection of the mutex (those in functions from gym_routine.c), but others and the main thread's are not. Since these variables are written to by at least one thread each and read by multiple threads, every access must be appropriately protected once the per-student threads are started. You've apparently chosen to use a mutex for that, which is fine; you just need to be sure to protect all accesses. Busy loops You use high-iteration-count busy loops for making the and functions consume non-trivial time. At minimum, you'll need to greatly reduce the iteration counts when you correct the data races there, as locking and unlocking mutexes is costly. Really, however, you ought to choose a delay mechanism that doesn't consume CPU. provides one such mechanism, with the advantage that another thread (e.g. the main one) can interrupt the wait if needed. That could be made to work in concert with resolving your data races, by giving each student its own mutex and condition variable to protect access to the student status. That would also allow you to set the durations of the workout and rest times in terms of machine-independent time units. Unnecessary dynamic allocation There are many good uses for dynamic allocation, but it's complicated enough and easy enough to mismanage that you should not use it where you don't actually need it. In particular, just because you need a pointer to something does not necessarily mean that that thing needs to be dynamically allocated. It's not uncommon to use a pointer to an ordinary local or file-scope variable, obtained via the operator. In your code, this applies to most (but, oddly, not all) of your synchronization objects. For example, I recommend changing the member of from a pointer to a plain . (It will then need to be handled slightly differently, but mainly the dynamic allocation will go away.) Similarly, there is no need to dynamically allocate your object. Just declare an instance. Input handling In your main input loop, you should account for the possibility that returns (indicating end-of-file before any input is read, or error). On the other hand, you probably do not have to account for because always copies at least one character from input to buffer upon success (provided you specify a buffer size of at least 2). Literal characters in the input could conceivably trip you up, but if you need to accommodate those then you need to handle input altogether differently. If you mean to accept only one command per input line, then I'd recommend consuming the balance of the line, up to the next newline, at the bottom of each iteration of the input loop. The one thing to watch out for there would be input lines containing a newline at index 1, which your current code will reject as invalid, but for which the trailing newline will already have been read. Issues with headers and #includes As a matter mostly of style, each of your headers should those headers defining constants and identifiers used directly by that header, if any, but not any other headers. (Each C source file should do the same.) Do not otherwise have your headers include other headers; it is unnecessary, and under some circumstances it can be harmful. For example, given it's current contents, your is right to include and , but there appears to be no reason for it to include . On the other hand, I would encourage having it include for the definition of , or else to combine those two headers into one. As a separate matter, it is a good idea to ensure that each source file and header that s headers includes them in the same relative order. This is less important for standard library headers, but there's no good reason to distinguish. It can be the case that changing the order of headers changes their interpretation (which would be a weakness of one or more of the headers involved, but sometimes that happens). In your case, your files differ on the order of and . 

Missing features You asked about missing features. I can imagine a lot of things that you could provide, but here is a fairly minimal list of additional things I think you should provide: 

They are both clear and largely superfluous. You've chosen reasonably good names for your variables, so the meaning of the code is fairly well readable from the code itself. More generally, I rarely think it appropriate to comment every single one of a series of simple statements. It is more effective to document at a somewhat higher level: if each statement reads well in and of itself then document the purpose of groups of lines. Also, I prefer trailing comments to be very short. If you have something longer to say then put it on its own line or lines. Additional comments Clearly your class is constructed for the express purpose of demonstrating , as it is missing methods that one would expect a general-purpose list class to provide. That might or might not be an issue if you were to present such an answer in an interview. Note that you could provide a full-featured implementation of by extending and implementing its method. On general principles, the inner class should have a constructor with which its field and maybe its field can be initialized. It may be appropriate to make the value , too, as @forsvarir also suggested -- this is possible only if you provide a constructor.