This is not how CPUs work... at all. As it currently stands, your CPU is perfectly capable of running at 100% usage, assuming that it's not being throttled due to temperature related issues at 80 degrees Celsius or more. That being said, you don't (generally) want to see your CPU pegged at 100%. If you're routinely at 100% CPU utilization, you likely have too much for your processor to handle. This will cause stuttering and a generally unhappy user experience. To compare with something more physical, your CPU utilization is a lot like a car. The car is likely capable of going 100 mph, but there's a good chance your speedometer reads something significantly under that. When in town, you may never be able to get about 25 mph. That doesn't however change that the car can go 100 mph. You simply haven't pushed on the accelerator hard enough. If you simply make the RPi do more things (push more on the accelerator), you'll see the CPU utilization figure go up. For example, watch the CPU utilization when you run the command in a terminal window (Remember that ends terminal commands). This will increase your CPU by 25% as it maxes out one of your four CPU cores. 

How close do you mean by "exactly"? There's a couple problems you're problem running into, that you may or may not be able to overcome. 

That might be a tempting idea, but no, bluetooth will not work well here. Bluetooth transmission is really slow. You're just not going to get the bandwidth you need for a proper video chat. Secondly, the range of bluetooth is probably not going to meet your requirements. You need a fairly clear line of sight if you want bluetooth to go very far. You're much better off using WiFi (through adhoc networking) or running an ethernet cable. 

No, leaving the RPi on all the time won't harm it at all. The RPi is designed to be an embedded device, and run in an enclosed space. Unless you have it somewhere stupid like an active dryer vent, your device should be fine. You are actually far more likely to damage the device by constantly unplugging it. 

Your problem is probably due to the fact that you pulled the plug on the RPi while it was busy doing something important. In general, it's a bad idea to pull the plug on any computer, including the RPi. Your SD card is displaying a small capacity in Windows, because of the way Windows works. On removable media, Windows will only ever display the first partition. If you repartition the card through the administrative tools, it'll go back to normal. As far as your RPi is concerned, the hardware itself is probably fine. That being said, you're probably going to have to reimage and reconfigure the RPi. Sorry. 

I don't know about Chromium, but YouTube videos should work under Epiphany and Ice-Weasel. On the RPi, you'll want to view the videos under HTML5. Use YouTube's HTML5 compatibility checker to make sure it's supported in your desired browser. 

USB stands for Universal Serial Bus. Generally speaking, anything that charges with a USB cable should be using 5V. The only thing I would worry about is the device not being able to output the required amperage. As Steve commented, the Apple is fine. So long as the PS4 controller meets the minimum power output requirements, it too will be acceptable. Below is a list of the minimum power requirements, taken from the Raspberry Pi Foundation's website. 

There really is no such thing as a "server OS" (at least not in our market segment). There are certainly package configurations and types of software that make a machine better suited as a server, but there isn't actually anything different about the core operating system. With this in mind, we really need to consider what we want in a "server OS". For the purposes one would use a Raspberry Pi for, I think we could sum it up with two main points. In the "real world" there are other points, but they don't really apply to our use case. 

Some carriers allow you to text an email address from a phone. After that it's a simple matter of having a ruby or python script check the email address for your text/command/whatever on a regular interval. 

Download the source code from its project webpage. Install some dependencies: These were the libraries I was missing. I already have a lot of development libraries installed, so you may be missing more than this. Feel free to leave a comment if you get an error from this step. Extract the source Enter the new directory Configure the software by running When that's finished, compile the software by running: . Do not use the option. The Makefile does not appear to be properly configured for it. Note: this will take a long time to run, especially if you're not using an RPi 2. Grab a cup of coffee or something and be patient. Install the software by running: Refresh your session. If you're using the default bash shell, this is accomplished by typing Enjoy your new software. At this point you can delete the directory you extracted the source files to; you no longer need it. 

A pre-loaded card means that it came with Raspbian already installed. What you see when you hook the Raspberry Pi up to a screen and power it on is the desktop. It's similar to the LXDE desktop found in lubuntu. 

Handbrake would probably be an option with raspbian, but I wouldn't recommend it. The Pi really doesn't have the guts it needs to do any kind of major encoding. 

According to the troubleshooting guide, it sounds like there is something wrong with the SD card reader. My guess is the SD reader is broken in some fashion if a working card is not read properly. Edit: Apparently my source predates the RPi 2, and may not be accurate for the newer devices. I will leave the answer, however, for anyone having the same problem with the A, A+, B, or B+ models. 

The RPi 2 has a 900 MHz arm7 processor, which is significantly different from the x86 architecture in the requirements above. It's kind of like giving instructions written in German to an English speaker. Sure, they may mean something, but they'd be unusable for me. 

The Cirrus Logic card you're using has a manual that describes the steps required to mount and then utilize the card. What you're looking for is likely step 4, method b. That will let you patch the kernel on your existing operating system, as opposed to installing a custom image provided by Element 14. You can download and install their kernel patch from a dedicated github project. 

It's unlikely that any Arduino code will work on the Raspberry Pi. While Arduinos are programmed in C, their source code contains a lot of functions that are specific to their boards. The RPi won't have these libraries. In addition to some software headaches, the hardware of the RPi is very different than that of any of the Arduinos. You could learn a lot about how the sensors work from the example code, but you'll have to manually convert it to something more usable with the RPi. 

There's a command line utility, built into Raspbian that will tell you the state of the HDMI. To detect the full state, you can use the command: . On my RPi this currently outputs: 

The answer is basically the same. The RPi's hardware only supports a single display. What you do with those displays is irrelevant to that fact. 

You're not telling your web framework that there's images to serve. The only url you've specified is the Index page at . Take a look at web.py's image documentation. 

Generally speaking, most issues with the RPi (all models) can be traced back to power issues of some kind. Many of us have had RPis run for literally years without ever once corrupting an SD card. Running for 3 months without an issue implies that the power supply to your RPi is satisfactory. My assumption is that your power source had a hickup during which the RPi was doing something important. I keep both of mine connected to a UPS, and if you're going to use the RPi (or any other device) as a mission critical device, I would suggest you plug one of those in yourself. 

You may need to toggle the number in the portion of the command, but the above string of commands will give you the top 10 largest directories. 

By Hardware Revision If you need to be more specific, you can check the revision entry from the output of . If you want to just exact the revision number, the following command should do it: 

You shouldn't need to set the entirty of the HDD as read only for owncloud to work (I didn't). My main suggestions would be to 

The software you're trying to compile on the Raspberry Pi is only designed to work on an x86 platform. It will not run on the RPi. 

There are a few things that are stored on the RPi itself, but nothing that could cause your problems. Unless you did something extraordinarily weird to the RPi, that storage space can't be accessed normally. It is far more likely that there is something wrong with your build. 

When dealing with anything network related, setting up the initial connection has a massive overhead, especially when it's not a local application downloading something. WinSCP operated by creating a new connection for each file. You didn't specify, but I assume these files are on the smaller side, which means that you're spending more time opening and closing connections than you are actually transferring files. There's two primary solutions to the issue you're facing. 

It sounds like your power supply is inadequate for the printer. According to Adafruit's documentation (on the link you provided), the printer requires a power supply that can support at least 1.5A output.