In this specific case, this last form would make an extra copy (and make the line only modify the copy). I wouldn't worry about the extra copy here, but you could avoid it by using as shown above or by changing the type to (although at the expense of producing more garbage). Your routine has a channel that doesn't get used. If this was for future expansion, or for use if/when was turned into a cancel-able function then that's fine. (Although, perhaps using immediately after creation would be more idiomatic in that case.) However, as-is can be greatly simplified by removing the unused channel. Instead of checking for a pair of explicit user ids in the middle of your code, it's cleaner to move those into either a list or a map. In particular, using a allows the check to be just . Finally, for things like , I prefer to put any authorization/API tokens anywhere but in hard-coded constants. Alternatives are on the command line, in an environment variable, in a config file, or some combination of those. Oh, and it's unclear to me what the API is, but perhaps you should be setting the "since" field in your request to either the latest timestamp or something like or somesuch. Edit: I made this change but forgot to mention it. You rarely need/want to call an error's method. In particular, is a long winded way of saying ( handles both , aka , as well as interfaces). I've seen others do things like which is worse then since although the message is the same it throws away any extra information/context (lost to someone trying to for example). 

Here is what I came up with after applying the above. [Also available as a git clone-able gist with changes made a few at a time so you can see some intermediate alternatives.] 

since the rename is redundant. As already mentioned, it's more common to be a bit more explicit with error handling in Go and let utility functions (such as your ) return any errors for handling "higher up". In addition to Effective Go, I suggest looking at the Go project's Code Review Comments page. Although the later is only what the Go Authors use and isn't necessarily more widely applicable, I find it a good starting point. Among other things, with respect to naming it suggests (again as previously mentioned) using , , , etc instead of what you use. Also, while on the subject of naming, I personally subscribe to Russ Cox's naming philosophy which suggests vs , versus , and vs for identifiers used within a short span (as opposed to file or project wide identifiers). When it comes to marshalling to/from JSON, use of struct tags allows you to not only map Go style names to JSON style names but also apply other attributes (notable things like "omitempty": ). In particular, without this if you tried to marshal your stucture back into JSON I believe you'd end up with your JSON fields capitalized (as Go's package can only deal with exported fields). The code review comments page also recommends applying caution/restraint to the use of named result parameters. They can be useful for documentation via but I try and avoid them just to save a variable initialization line in the body. Your tastes may vary, but if you use them be careful of shadowing the named returns (e.g. with a named and inside an if/for having something like ). Instead of using something like to pre-read all the data I find it useful to look for "streaming" based alternatives. For programs that process large data inputs (e.g. reading from a large file) piece by piece this can make a big difference. Here, provides a type for this purpose. In this specific case I don't know if it makes any memory/performance difference but I find the result of using it (and combining your send and parse functions) seems to simplify the code. Back to marshalling, it can sometimes be helpful/useful to create your own thin wrapper types with custom (un)marshalling rather than limiting yourself to basic types. For example, in the code below I've added a type that unmarshals from the way StackExchange API is documented to do all time/dates. You could easily add a method if marshalling was also required. The difference isn't that important here, but for example, it allows easier use of all the methods/functions (e.g. , changing the output timezone, etc. In several places you do things like: 

The value of the privete field should NOT be tested, as it is only an internal implementation detail. Also what should do if the user has not yet logged in? 

You have written nice small methods with clear names that greatly helps with understanding the code. However it is very easy to mix up parameters that are passed into the method and fields of the object when reading the code. Therefore it is better to prefix all your fields with “_”, so making the code read like: 

So if writing unit tests don’t help you writing the code then don’t write unit tests for code that is tested by acceptance tests. However unit tests help you developer the API to your class and provides examples of how to use the class, so may be of value even when you already have 100% test coverage. On a normal sized code base, it may also be quicker to track down way a unit test if failing. 

It is normal in production quality qsort code to switch to another sorting method (maybe a unrolled bubble sort) when the size of the input is small (often 8 is used). QSort has very high overheads, but scales well, for a small input size the overheads are much more important than the scaling. If you run your code on an input that is 1000 items long, then I expect that your qsort would be faster than your bubble sort. Try writing a test problem that increases your input size in steps of 100 and then graph the results with both sorting methods. The other way to look at it, is to find the largest input that each sort method can sort in say 5 seconds. 

Also your qSort could be written to be a lot faster by not creating 3 new , it is also very important to quickly choose a good item to privet on. You do not even set the size of the list when you create them, hence each list will have to be reallocated and copied many times as you add items to it. You have a qSort that is implemented is an inefficient way compared to a boubleSort that is close to the best implementation for boubleSort. Yet as you confirmed in your comment the qSort does better when you have over 10000 items, slowing just how much better qSort scales. 

On Fixed Size: I don’t think I have ever backed a queue with a fixed sized array apart from code written for university exams. However it is easy to extend what you have done to allocate a new array of double the size and copy the item over if the queue gets filled. Doing so tends to be faster than using linked lists on modem CPUs (due to the processor cache) and also creates lets garbage so helps the garbage collector. See Strategy: Stop Using Linked-Lists On Naming: Lets take this code for example: 

I actually did just look up the docs and it seems that does return (in VBA terms, it's a Sub), so my advice isn't very practical. However, it's also been marked as Obsolete and the newest version of that method, returns a boolean. So, I'd give that a shot. They're also saying that uses caching to speed up the call, so you could see a significant performance boost as well. 

If your interviewer gave you the requirements that you posted, then you're good. However, if the requirements were actually the latter, then you've missed an opportunity to keep your code flexible and DRY. Based on the classic requirements, imagine that the numbers changed and you now needed to print "Fizz" for multiples of 5 and "Buzz" for multiples of 7. Instead of making two changes to the code, you would have to make three. Not only that, but the maintainer would need to understand that 15 is the lowest common multiple of 3 and 5 to be able to calculate the new constant for "FizzBuzz" numbers. You might be better of removing the 15 constant and making it what it really is: the lowest common multiple of the other two. 

The existing answer did a nice job of refactoring your code, but there are other things that can be said about it. To begin with, I'm not sure you're doing a great job of validating . 

If you're curious why I choose error number 5, it's because it's the internal error number for . In a real life situation I would define a constant for it. 

Don't one line things that shouldn't be one lined. Just because you can do something, doesn't mean that you should. Extract the duplicated query into a method of it's own that returns an Don't query the database twice for the same count, execute the query and store it in a variable. 

I don't see anything particularly bad with what you've done, but perhaps I'm inexperienced or lacking larger context. The only thing I might recommend, would be to keep a around and just call the clear method instead of creating a new instance from scratch all the time. Let me be clear though, I'm not 100% sure that's good advice or any better than "newing it up". 

You can apply that through out your query. (In SQL Server I had to leave it duplicated in your Cross Join.) This subquery shows up a lot in your code too. 

You should create a resource file to store your strings. Then they could be changed without recompiling your program. You also have a typo here. 

But that's more code! Yes. It is, but we're not going to leave it this way. We're going to extract methods that take in the data reader and return new business objects.