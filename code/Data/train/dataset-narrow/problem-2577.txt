the Monte Carlo Tree Search (MCTS) is applicable but not very good in this case, as the opponents actors are not "random" but will choose the best move they can. However, if you choose to use MCTS you have to 

Another possibility to cheat would be to "change" the random number to another number that matches has the same hash value. The approach would be the same as above. While in most cases it is very hard to find another number that has the same hash value, this could be pre-calculated, if you just use the hash of the number. Therefore, you should exchange that random prefix (or suffix) string that has to be added when calculating the hash value. I'm not 100%ly sure, but I remember there was some technique for the MD5 hashing algorithm to quickly calculate other matching values for the same hash, if you are given a value that results in that hash. So better don't use MD5. I don't know about this kind of attack for SHA1, but there might be one. At least make sure the hashing algorithm has no known weakness of that kind -or- the calculation at least takes very long. If you have done the above right, you should further improve the security of the method by limiting the time for the exchange of the hashes and values. Only if the exchange is executed within some time limit, it should be valid. This ensures, that neither party has enough time to apply one of the above 'hacks'. If it takes too long the procedure must be repeated. What still needs to be solved One of the parties may still be able to influence the outcome by applying the above techniques. In most cases (e.g. 99,99999% of the cases depending on parameters) the time will be too short. But, given enough chances one party might be lucky to break the hashing. For example, a Player could just randomly try out numbers to find another "random" value with the same hash value he had send to the other players (last approach) for as long as possible (to not let the timeout catch him). Especially, if the player lets all the others send him their random values first, he would know what kind of values would give him the biggest win. So he could just try these ones. The evil player then would either let everything time out and restart (to get another chance without loosing) or just lets the game go on and use the next dice round for another try. You could decide, that if a player doesn't deliver its hash or random value within the timeout would automatically loose. So this reduces the problem, but it still increases the chance of a player by some very very small amount. This weakness is especially critical, if this very small amount of additional chance is enough to disturb... For example if one player could this way decide a complex outcome and wins a lot of money. For imagination, assume you apply this algorithm to a lottery game where one of the "players" is the Bank-Server. We ignore for the moment that if we have a lot of players the amount of data transfer would be not realistic (each person had to tell all other person, its hash and random value; which resulted in N*(N-1)/2 messages needed to be exchanged, which is over 1 Million for just N=2000 players and increases quadratically). Okay, back to the issue. If just one player would "break" his hash and is able to decide the outcome, he could illegally win some Million Dollars from the Jack Pot... Got it? If you have such a critical application, you must calculate the chance, that at least one player cracks his hash code within the time. Then multiply this by the maximum possible win of all players, not under your control (e.g. the bank player is trustworthy). This would give you the maximum loss per round. In the lottery example, the lottery bank would loose this much money per round, if all players would try to cheat. The lottery chances therefore would need to be adapted in a way -or- the probability of a successful 'hack' must be further reduced. To reduce the probability you can: a) reduce the timeout time, b) use a more complicated hashing function, c) use longer numbers, OR: d) distribute the outcome over multiple rounds. Distributing the outcome over multiple rounds would work by only deciding -a part- of the "result" within one round and executing multiple rounds. For the lottery example, each number could have its own round. This way, a lucky cheater would only had the possibility to change one number each time he manages to break the hash. So he would have to have luck 6 times in a row (if the lottery is selecting 6 numbers) to illegally win the jackpot. WARNING: Each round should only influence one special part of the outcome (e.g. one of the numbers in the lottery). Do not just exchange multiple random values / hashes and sum them up, as before. If you do this a player having luck in the last round would be able to change the whole outcome (!). But, for example, you could do one round for each "bit" of a random number. Another problem to take care of is, that one player may "disturb" the game by letting the whole thing time out over and over again. This might be a problem, if players are anonymous and you cannot just bann people who do not play fair. OK, I hope this covers all problems and attacks ... Good luck ;-) 

You can use a Hash-Table to only calculate the same game state "subtree" once. Imagine player A walks up and down, while all other players "wait", you end up in the same game state. It's the same as for "left-right" or "right-left". Also moving "up-then-left" and "left-then-up" results in the same state. Using a Hash-Table you can "reuse" the calculated score for a game state that has already been evaluated. This reduces the growth speed quite a lot. Mathematically, it reduces the base of your exponential growth function. To get an idea of how much it reduces the complexity let us look at the moves possible for only one player compared to reachable positions on the map (=different game states) if the player may just move up/down/left/right/stop. depth 1: 5 moves, 5 different states, 5 additional states for this recursion depth 2: 25 moves, 13 different states, 8 additional states for this recursion depth 3: 6125 moves, 25 different states, 12 additional states for this recursion To visualize that, answer yourself: which fields on the map can be reached with one move, two moves, three moves. The answer is: All fields with a maximum distance = 1, 2 or 3 from start position. When using a HashTable you only have to evaluate each reachable game state (in our example 25 at depth 3) once. Whereas without a HashTable you need to evaluate them multiple times, which would mean 6125 evaluations instead of 25 at depth level 3. The best: Once you calculated a HashTable entry you can re-use it in later time steps... You can also use incremental deepening and alpha-beta pruning "cut" subtrees that are not worth searching in more depth. For chess this reduces the number of searched nodes to about 1%. A short introduction to alpha-beta pruning can be found as a video here: $URL$ A good start for further studies is $URL$ . The page is related to chess, but the search and optimization algorithms are quite the same. Another (but complex) AI algorithm - that would be more suitable to the game - is "Temporal Difference Learning". Regards Stefan PS: If you reduce the number of possible game states (e.g. very small size of the map, only one bomb per player, nothing else), there is a chance to pre-calculate an evaluation for all game states. --edit-- You could also use offline-calculated results of the minimax calculations to train a neuronal network. Or you could use them to evaluate/compare hand-implemented strategies. For example you could implement some of the suggested "personalities" and some heuristics that detect, in which situations which strategy is good. Therefore you should "classify" situations (e.g. game states). This could also be handled by a neuronal network: Train a neuronal network to predict which of the hand-coded strategies is playing the best in the current situation and execute it. This should produce extremely good real-time decisions for a real game. Much better than a low-depth-limit search that can be achieved otherwise, since it doesn't matter that much how long the offline-calculations take (they are before the game). -- edit #2 -- If you only recalculate your best moves every 1 second, you could also try to do more higher level planing. What do I mean by that? You know how many moves you can do in 1 second. So you can make a list of reachable positions (e.g. if this would be 3 moves in 1 second, you would have 25 reachable positions). Then you could plan like: go to "position x and place a bomb". As some others suggested you can create a "danger" map, which is used for the routing algorithm (how to go to position x? which path should be prefered [there are some variations possible in most cases]). This is less memory consuming in comparision to a huge HashTable, but produces less optimal results. But as it uses less memory it could be faster because of caching effects (better use of your L1/L2 memory caches). ADDITIONALLY: You could do pre-searches which only contains moves for one player each to sort out variations that result loosing. Therefore take all other players out of the game... Store which combinations each player can choose without loosing. If there are only loosing moves, look for the move combinations where the player stays alive the longest time. To store/process this kind of tree structures you should use an array with index-pointers like this: