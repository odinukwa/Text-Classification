You mention that the user feels "safe" if the spiders are all offscreen. This is probably the most important thing to address. Fortunately, you want the right kind of thing: a gut feeling that the user has that nothing is ever safe. The "gut feeling" people get is an amalgamation of many small cues that the brain processes together to try to guestimate an unknown (in this case, the position of the spiders). Your goal should be to provide many small clues in many different ways, visual and auditory, rather than trying to come up with one big clue which tells you where the spider is. Many have mentioned music. Sound is always good for gut feeling effects because we humans use it for wide awareness of our surroundings. It's the thing which tells us to stop focusing on trying to fix our radio because there's a zombie behind us. However, visual effects can also be used. You just need to make the spiders have a presence. A few ideas: 

You interpolate to find states between known values, and you extrapolate to find future states. Think of the problem in terms of state variables, like positions and velocities. In the best of all scenarios, every computer which needs to work with state has access to the state data for the time they want to work on. For example, a collision algorithm to see whether laser-rifle shot X interesets player A's head, the best of all cases is when the algorithm knows the exact position of every object at the time the laser was fired. In the real world, we are not always so lucky. Sometimes the truth information we receive is more sparse. For example, if player A is a remote player on another computer, you may not know exactly where they're going when you fire the laser and need to calculate the shot. In this case, you need to create an estimator for A's position, typically with interpolation or extrapolation. The difference between the two is whether you have data that is bounded on both sides, or only one side. Let's say that Player A has already announced their truth position for t=0 and t=1. Player B shoots a laser at t =0.5. In many situations Player A's announcement of their position at t=1 can occur before Player B pulls the trigger. Why? In many games, the responsiveness of the controls is less than perfectly instantaneous. In a racing simulation, much of the player's position is bounded by the physics of a moving vehicle. You may choose to announce a "future position" because you know you really can't steer all that much in a short period. If you have information in the future, you can interpolate between the two values. What if you aren't lucky enough to have a t=1 value? What if Player A wasn't in a position to announce their future location, and you're stuck deciding whether you hit or missed with only the information from t=0? In this case you have to extrapolate. In extrapolation, you use what you know about the motion to extend beyond any data you have. You might know that Player A has a certain velocity, so presume that if you multiply that by time, you can get a position at each time. The difference is in the behaviors. Interpolation requires you to have an upper and a lower bound, which you do not always have. However, in nearly all situations it has vastly better results than extrapolation. Extrapolation can easily lead to unrealistic movements. Consider the case of a player who is sidestepping left and right to avoid being shot while advancing. At any given point, their velocity is along a diagonal, so if you extrapolate, the player may appear to run off to the side when, in fact, they never do. If you only do interpolation, the values tend not to stray outside realistic values. Interpolation and extrapolation are two extremes in the world of filtering. There are many many many many many filters out there for handling data like this which mix and match properties between interpolation and extrapolation. Accordingly, don't be surprised if you see algorithms that are not clearly interpolation or clearly extrapolation. Those two are just the tip of the ice berg. 

I'm currently developing a Javascript web game for desktop users. It is a sort of tower-defense game that relies on mouse input only, developed on canvas using EaselJS. In the future, or perhaps simultaneously, I would like to adapt the game for mobile devices. I can see at least 3 potential areas in shifting from desktop to mobile: 1. resolution size and UI rearrangement, 2. converting mouse events to touch events, 3. distribution as native app wrapper or mobile Web. What would be the best strategy to facilitate this desktop to mobile conversion? For example, should I try to code the game for both platforms, or port the game UI over to mobile by branching the code base. Should I just publish on the mobile Web or wrap the game in a native app framework? And if I were to code for both platforms using the same codebase, should I register both click and touch events, or remap click events to touch using dispatchEvent? 

I don't think you should go with a browser game because it might entail producing 2 version of code: one for browser and one for desktop. In addition, browser technology might not be powerful enough to handle your game (depending on your exact situation). Unity might be one of the better choices for both desktop and browser deployment, but you have to consider the download of the Unity Player. While its filesize is actually quite lightweight and likely to be much smaller than your game itself, people are rather put off by the need to download. See $URL$ 

How you present these effects as the spiders close in is more important than anything else. The gut feeling parts of the brain work almost entirely on logarithmic scales. Thus we get the same amount of relief from the spider moving from 1 to 2 units away as we get from the spider moving from 2 to 4 or from 10 to 20. Cues which work to this scale will be more well received than anything else. Take the spider sounds, for instance. Instead of just having one spider sound which gets louder as they get closer, consider having multiple, which all come in at different rates. Perhaps have the music start to change when the spiders are 8 feet away. Around 4 feet away, you start fading in the sound of their scratching legs against the trees. When you get to 2 feet away (which may be right off screen), you could start hearing the noises from them mashing their mouth parts hungrily (why not... they're evil spiders!). You don't always have to use powers of 2, though they are obviously natural for game developers. Maybe the small animals flee when the spider is at 30 feet away, and the squirrel starts looking visibly nervous when they get 10 feet away. Then, at 3.3 feet, color drains from the background. Of course, for all of these, its best to fade the effects in gradually. That way, for any spider distance, the player's gut has many smoothly varying signals with which to develop its gut feeling for where the spiders are. The more small signals the player is paying attention to, the more they will be drawn into the moment. This is the real key. A small number of obvious cues will have less effect than a large multitude of small cues which all operate on different scales, and ideally you want to let the user construct a reasonably logarithmic worldview using those cues. 

} 1.) Consider using Transform.LookAt to simplify the rotation. 2.) In your movement code, myTransform.Up represents the Up vector of the transform in local spcae, so if your model is tipped off center then Up will no longer point Up in world space. Use Vector3.Up as MistaGiggles suggests. 3.) You can make your enemy hover above the player by adding an Offset amount for the Y axis like the sample code above. Additional way to rotate your enemy based on your comment: 1.) Get the normalized vector from enemy to player and assign it to Transform.Right, which would be your X axis. Unity takes care of updating the Transform's rotation internally when you set Up/Right/Forward manually. 

1.) You need to update _lookRotation when the mouse is clicked or it never changes so your agent will never look at a new location. Simple Coroutine Example: 

When a Resource is Loaded its not actually Instantiated and added to the Scene so Awake() is never called. Change your code to something like the following: 

Add this script to your LineRenderer GameObject. It will allow you to set the SortingLayer and the SortingOrder in that Layer for your LineRenderer and correctly draw it with an additive material. 

I have thought about just coding a 2D game on Android using just pure Java and the Android SDK, no engines like libdgx, cocoa-2dx attached. I don't know if I really need to use a game engine or not. Doesn't Java already come with basic libraries and APIs for most things already? I'm not interested in the cross-platform aspect of game engines. The game is 2D, so there's no complex issues with 3D, importers, or what not. I also don't like to have to code around level editors or pre-built constructs like a character or tile class. Given this, are there any other benefits for me using a game engine to code my Android 2D game? For example, I'm clueless with OpenGL so if I'm doing it w/o an engine I would be using pure Java, would that be significantly slower than using an engine like libgdx? 

Briefly, yes. Zynga's Caf√© World and PlayFish's Restaurant City uses Away3D. I think developers might use more of 3d engines because 3d is not everyone's cup of tea - they can just focus on implementing game logic and mechanics instead of meddling with math. However they would shy away from game engines like Flixel, for reasons that Nick Wiggill has mentioned. (eg. risk of middleware) Source: $URL$ 

The number one thing I have found that limits educational game is a hard lined insistence that the adult programming the game define what will be learned in the game. Much of a game's appeal is from the player deciding what they want to get out of the game. The game maker can make suggestions, but in the end, it is the player that decides. If your game suggest "You should want to learn to add positive and negative numbers," and that's not the player's definition of "fun," they'll quickly put the game down. Instead, make room to permit the player to decide what they want from the game. If they want to have fun in their particular way shape or fashion, let them! Sure, reward them for wanting to have fun in ways that support your educational goals, but don't make it hard to enjoy the game outside of a narrow window. Let's use your cannon game as an example to brainstorm on. Unless you feel like adding numbers to get to a zero, it's a rather boring game. However, what if summing numbers to zero instead offered you power ups, and the "game" was a more standard cannon game. Now the game is just a game, but there's a way to make it easier by doing math. If a player wants to win simply by shooting every number out of the sky, guess what: they learned geometry! As the game progresses, you may try to encourage them to play the math part of the game more by making it gradually harder to progress without playing the part of the game you want them to play. If they want to stick to the easy stuff, that's fine. If they want to rely on raw twitch fingers to blast everything, that's fine. If they want to concentrate on the math, great. If they want to find their own balance between math and twitch, that's even better! Now, consider that paragraph with respect to Candy Crush, one of the more addictive games of all time. The primary focus of the game is on studying patterns in the game grid. Instead of making that the game, they make it a way to power up: cookies kill off whole colors, wrapped sweets slaughter columns or rows, etc. At first you can just play the game any way you like. However, as you progress in the levels, the power-ups smoothly become more and more important, until you reach a point where some of the simpler power-ups are absolutely and utterly required to beat a level, and the game encourages you to reach for the more powerful power ups. Candy Crush is a good example for how to not make a game boring! 

I'm planning out an adventure game, and can't figure out what's the right way to implement the behaviour of a level depending on state of story progression. My single-player game features a huge world where the player has to interact with people in a town at various points in the game. However, depending on story progression, different things would be presented to the player, for e.g. the Guild Leader will change locations from the town square to various locations around the city; Doors would only unlock at certain times of the day after finishing a particular routine; Different cut-screen/trigger events happen only after a particular milestone has been reached. I naively thought of using a switch{} statement initially to decide what the NPC should say or which he could be found at, and making quest objectives interact-able only after checking a global game_state variable's condition. But I realised I would quickly run into a lot of different game states and switch-cases in order to change the behaviour of an object. That switch statement would also be massively hard to debug, and I guess it might also be hard to use in a level editor. So I thought, instead of having a single object with multiple states, maybe I should have multiple instances of the same object, with a single state. That way, if I use something like a level editor, I can put an instance of the NPC at all the different locations he could ever appear at, and also an instance for each conversation state he has. But that means there'll be a lot of inactive, invisible game objects floating around the level, which might be trouble for memory, or simply hard to see in a level editor, i don't know. Or simply, make an identical, but separate level for each game state. This feels the cleanest and bug-free way to do things, but it feels like massive manual work making sure each version of the level is really identical to each other. All my methods feel so inefficient, so to recap my question, is there a better or standardised way to implement behaviour of a level depending on state of story progression? PS: I don't have a level editor yet - thinking of using something like JME SDK or making my own.