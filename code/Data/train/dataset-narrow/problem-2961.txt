I personally dislike the loop, so I tend to avoid them when I program. However, in spite of this preference, I still end up teaching about them as part of the AP Computer Science A curriculum. 

Number 1 allows me to relax a little, and demotivates cheating. Since the tests and quizzes are largely where students grades are determined, this is where I must watch students carefully. Number 2 gives me a pretty good sense right away of how much trouble the student had with the exercise. Number 3 is easy to check in my environment, since I do code interviews with the students. Number 4 is still a little sticky. I remind them of the line, I remind them of its purpose, and I tell them that this is not a "letter of the law" policy; it's a guideline so that they can use to understand my thinking. Stupid shenanigans ("I didn't describe my solution! I made a graph that illustrated it!") here is not okay. 

Of course, code like this should make us want to puke just a little bit into our mouths. We'd ideally want the compiler to stop us. and that's the key point: declaring variables as removes our beautiful compile-time protections, and leaves both the coder and other human readers adrift. Sure, it's an , but what in the world is it? Similarly, with , you can borrow some examples from the very page you linked to illustrate why can be a bad idea. I also might not introduce the concept until you have introduced Generics, as that is one of the first times that it can actually make things easier. This would allow you to couple the example of where it can make things easier with examples of where it also can make things insanely more difficult (the more over-the-top, the better for your illustrating purposes). This will enable you to have a discussion about appropriate usage based on real principles, not just course policy. After this discussion, you can explain where you will accept these in your course, and there should be little resistance from your students. After all, what you are asking for is simply sensible. Hopefully, this will allow you to create some balance in the lab work you receive. 

I am not aware that cognitive modeling of memory structures in early programming education has been directly studied, so anything that I say here is entirely speculative. However, I suspect that the models themselves would somewhat depend on teacher presentation, and would otherwise be relatively stable. Take negative indexing as an example. A reasonable initial cognitive model for a list would be some sort of cycle. If it is later explained as an array with indexing performed with a modular operation, then we have moved our conception to some sort of line. When we even later explain about memory references and data size, then we can finish the picture as an array (line) of fixed size memory references, each pointing to a different object in the heap. There are only so many simple physical shapes that we can use to represent these ideas. Which actual conceptualization a student takes will depend on their maturity in the subject matter and on how the data structure is presented by the instructor. I don't see any reason to believe that the initial choice of language would have any substantive, lasting impact on these cognitive models as the student matures in their understanding. 

I've never encountered this particular problem (possibly because I mention that truth tables are great, but we need both sets of skills?) Looking through the examples that I teach, though, a few of them pretty easily motivate boolean algebra: 

I have student who is attempting an independent study next year in audio processing. Her goals involve detecting the meter of a song. Thus could be done through machine learning, or through other forms of AI. While she will eventually be creating a science fair project, she has asked for advice on what to study over the summer in order to make the most of next year. I have no experience in this realm. I know that she had not yet taken AP Statistics, but I also don't know how much statistical knowledge is really necessary. As some context, she is a rising high school junior who has already taken AP Computer Science, and a course on C and Assembly Programming. Can anyone advise on how I can guide her? 

If we now wanted to run , it is true that has a value, but what is its location? If is true, will be at the higher of the two addresses, whereas if it is false, will be at the lower of the two addresses How would the compiler know where to direct to find ? Thus, the scope of variables declared during statements must be local to that statement, and cannot be used outside of it. 

Student Beliefs There are a few things that the students need to know, and these should be directly taught and modeled at every opportunity. 

(emphasis mine) It seems to me that this is exactly backwards. The reason to give an incomplete picture is to allow students to absorb important grounding principled before adding wrinkles and complexities. This is what motivates the entire enterprise. Second, the principle is one for usually, and not for always. I've repeatedly observed in my own classroom that, if my students are already somewhat lost in a complex topic, even hinting that there might be more complexity beneath the surface causes them to completely lose the topic. It has been consistent enough that I am utterly convinced that this effect is real, and we need to treat it with care. I have two brain-based theories for why this might be. I have not found any research to support (or detract) from these theories, but they could both well explain the phenomenon: 

So what do I do? Well, I do leave it up to them mostly, but I don’t allow electronic devices, with a few exceptions... they 1. are not as effective for learning as hand written notes and 2. it’s too hard to draw the kinds of technical diagrams that my classes use. So far, I have been allowing tablets with a stylus, if they ask me, because that fixes #2 and all the research I know if for #1 is based on keyboard input, so it’s not clear which way stylus input falls for actual learning... (if anyone has info about stylus notes, please let me know!) 

In light of this question (and many others on this site), I have been noodling around with the idea of reversing my AP Computer Science A course and taking an Objects-Early approach. I'm having a bit of trouble conceptualizing the whole thing, however. How would a class like this begin? What is a first activity that the students can actually do in an objects paradigm? 

“Students are adults.” Legally, yes (with a few uncommon exceptions). However, there is a huge gulf of maturity between an 18 year old and the same person at 23. For that matter, the 23 year old will continue to mature for several more years... Of course there is individual variance, but don’t overestimate how mature college students actually are. “They know what note taking method works best for them.” I doubt it, in most cases. Most of them probably can’t actually distinguish what helps them learn best... they do know what helps them take notes the easiest and may assume that’s best, but for learning it’s usually not. Also, they only know what they’ve tried, and probably don’t think to try different things (especially “harder” ones), let alone research and seek out novel alternatives they may not have thought of before. The unstated assumption: “Their note taking choice affects only them.” Superficially, this is true... but when their “choice” is to take notes on a laptop, but then they end up on (e.g.) Facebook and the students behind them are watching over their shoulder, their choice is then distracting other students. (You won’t know from the front of the classroom whether they have OneNote or Twitter open on their laptop. You think you will but you won’t - just do a classroom observation and you’ll see.) 

What did you do well this (year/grading period/semester/etc)? What could you have done better? What did I do well? What could I have done better? Are there any other comments? 

Quality goes down, because material is less vetted. There may be unclear instructions, or even outright errors. Creating this new material just seems to take a really long time. 

This is the stuff of math teachers' nightmares. The problems here, from my experience teaching about grammars1, are two-fold: 

Ah, the famous bimodal distribution in computer science! When I took my first CS class in college, I frequently helped out a fellow student in my section who struggled mightily, spending unreasonably long amounts of time on seemingly simple labs. We made very little headway together. In spite of a semester-long effort bordering on the heroic, the student just couldn't seem to get programming. I asked my professor about it late in the semester, and he said that there were a certain number of these students every semester, and that he didn't really know how to help them. He said that, if they didn't withdraw and kept working, he would let them go with grades of C instead of the Fs they actually earned on their exams. I saw it again years later, as I started teaching my first computer science courses. In every class, there were some number of kids who just didn't get it. And I was not alone! Others were seeing it, too, and there was even an unpublished research paper that started to make the rounds on the internet called The Camel has Two Humps, which asserted both the bimodal nature of the field and that they had created a test that could predict who would be able to "get" it. That paper was hardly the beginning of the story. In fact, professors have been investigating this bimodality for years. Lately, however, the story has been changing. The author of the original unpublished study issued a partial retraction, and researchers began looking at far larger datasets of introductory CS grades. It turns out that that bimodal distrubution is not really bimodal after all. So what is going on? When we teach programming, we want our kids to be able to program. So we test them on programming, and we want to heavily weight our grades on, well, whether or not they can obtain the proper output. To illustrate this, let's take a hypothetical problem prompt, and some sample answers. The question, which will be in an introductory Java class, will read, "Create a function called that, given a number , fills and returns an array with $n$ sequential values". Answer 1: 

My poor blackboard1 only gets light use nowadays, I'm afraid. Coding examples are usually too large to put up there, all of my intricate diagrams are clarified with (judicious!) animations in PowerPoint, and my debugging gets demonstrated live on the projector screen. The humble blackboard has seen its role reduced in CS classrooms as the years have gone by. It still has its place, though! Improvised diagrams go up there, such as when a student asks an unexpected question about a linked list. And pulling a struggling kid up to the board (during individual work time, not as some form of humiliation) can give us space, both mental and physical, to work through a conceptual problem together. Of course, in more advanced CS coursework, we start veering back towards the mathematical, where the blackboard is still king. Well, maybe not the king anymore, but at least a Marquess or an Earl. Working through problems and proofs at the blackboard keeps the pace slower than a PowerPoint and gives the students that much more time to absorb the material, and asking students to write up the answers to in-class questions allows us to have class discussions around the results. And there's one more place where the board comes in handy: harder labs, especially the kind that kids have a hand in designing themselves. I've found that my students naturally gravitate to the board when they need to brainstorm or work through a particularly tricky problem. Something about having all that space to think and try frees the mind. Paper just doesn't seem to do this same trick. The blackboard may be dying, but it ain't dead yet. 1 Okay, technically I use a whiteboard in my classroom. I'd prefer a blackboard, but I don't get that choice in real life. But I get my choice here and now, in this very answer, and blackboard, I choose you. 

One elegant way to deal with this sort of problem (though it does take a lot of work) is to create a self-explanatory review packet (including a practice quiz!), give it out on day one, and promise that there will be a quiz on its contents during the second week of class. You then don't need to spend another minute on the material in class, at least for that first week. (Especially for that first week. They should not feel hand-held at first! See below...) You might want to make help available during office hours, however. This has a second benefit, which is that you can set a recommendation for withdrawal from the class. I would give this a soft sell: "if you can't achieve an 80% on this quiz, then the kindest thing I can do is to recommend that you drop the class. It's not to be mean, but you WILL NOT have a good time here if you haven't reasonably mastered these concepts." By putting the onus of weeding poorly performing students back on the students themselves, you will find that you get very little resistance. And folks who choose to stay on anyway will be making an active choice to work very hard going forward (or suffer the consequences). The big brunt of the work need only be done one time; the review packet and the practice quiz can be the same every semester. It is only the quiz itself that need be changed. While this should weed out some of the lowest performers (and give many others a much-needed review), if the students are as low-performing as you say, it might not hurt to touch on some of the harder concepts that people get stuck on when you come to them again in the class. Hopefully you'll have much better performance in the course going forward. Best of luck! 

The math is not strictly necessary. The students signed up for an image processing workshop in the context of programming. The core skill that they expect to come out with is the ability to program graphics manipulations. Spending a substantial portion of this time learning about the underlying math, certainly important in a full semester's undergraduate or graduate coursework, only moves very slowly towards what they (presumably think) they signed up for. Some kids get turned off by math. One of the unstated goals of every course is to both show the value of the field, and hope that the student wants to go on with the material and learn further. That means that we want them to like it. Using a voluntary summer workshop to emphasize the more abstract parts of the material may turn many of them away from graphical processing entirely. 

Because I want the lab to involve design of a good system, and not merely utilization of a preexisting system, I have been getting myself stuck. I want this to be an Objects Design Lab, and I'm not sure how to get started. My classes have 15-22 kids, and they are expected to do a substantial portion of the lab work during class (with me present). 

Goal-oriented action Part of this really depends on your goals in administering the exam. If your goal is the traditional idea of creating a nice bell-curve to rank students, having a study guide makes very little sense. You can separate the wheat from the chaff without providing any assistance to the students prior to the test. However, if you want to utilize the tremendous cognitive benefits of testing to actively help your students learn, then you're looking at a whole different set of priorities. There is a lot of research on the benefits of testing in the learning process. Unfortunately, I don't have access to my bookshelf right now, but the incredible book How People Learn summarizes the results very nicely.1 How do tests help? Basically, tests accomplish two things that really help us to learn. First, there is retrieval practice, which is simply giving the brain a chance to practice holding on to (and recalling) information. The second is emotional: by giving the information heightened emotional importance, we increase our chances of actually encoding it. So, where does a study guide fit in? Having a list of topics isn't as useful as you might think for an examination. If I tell you that you're going to have an examination on "Operating Systems", there's not a lot to go on. You might get to the exam and find questions about threading, or disk management, or you might find questions about how to transfer photographs between an iPhone and a Linux box. There's little to focus your studies, and you may find that you have expended a great deal of effort studying things that your teacher does not consider to be the core, central ideas of the course. My example is over-the-top, but this is done purposefully to illustrate the problem. Your subtopics may not seem as broad as "Operating Systems", but in a field of effectively infinite knowledge, you are presuming that students have gleaned what the important core ideas are for your class from readings and from listening to you during your lectures. For some kids this will work. But what about the kid who missed something? Perhaps they didn't understand something really fundamental about one of the sub-topics. Or perhaps they got sick and missed a class. Or perhaps they've just forgotten some things thoroughly enough that they really can't recall what the important ideas were. Creating a good guide A study guide is your chance to give some very gentle guidance. Take your syllabus, and write a sentence or two for each topic that starts with, "Make sure you understand ..." or "You should be able to ..." or "The most important idea here is ...". This is a relatively easy task, but even this small amount of guidance will help your students to focus their studies on the most important ideas of your course. You can actually go a lot further with this effort if you want to, and there are good reasons to consider putting a lot of effort into the guide. Your efforts here can have an outsized impact on your students. This is what they will study, so what you put here is what your students are likely to remember when they leave your classroom for good.