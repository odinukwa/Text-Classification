I implemented a function to shift an element after another in a logical circular array. Shifting in this case simply means moving element at position to in front of element at position . Of course I can't simply swap the elements at position and , because I would alter the positions of two elements in this circular array. Here's the code I came up with: 

I was trying to create a function to delete the node at index from its current position and insert it after node at index from a . These container is logically a circular container of nodes, that is there's no actual first or last node, i.e. after comes . I really need this function not to have bugs and to be as performant as possible, so I'm asking here your help to a further check and for eventual suggestions to improve its performance. So, this is the function: 

I have written my own one time pad algorithm for encryption and decryption, but I would like to listen to your opinions about its correctness and eventually how could I improve it. My idea was to keep it readable, but not so bad in terms of performance. I have also written some tests. Here's the code: 

I've made arValue into local variables instead of an array because it's easier to type. There may be a performance difference in some direction that you may want to profile. I'd also worry about whether the GetNbitsWordBE function is inlined and optimized as well as you'd want it to. Oh, wait, there are three of it! Now I'm confused. I'd prefer not overloading it like that, but that's a style issue, not a performance problem. 

Sorry if I'm misunderstanding the code, but here are some ideas of how it can be improved, focusing on performance. Those are the things that immediately came to my mind. I've probably missed things, and there may be higher level optimizations that can be done that I didn't see because I just took a quick look at the code. What's the point of the POW2 array? It doesn't make the code any clearer than using the shift operator, and may make it harder for the compiler to find optimizations. So instead of doing 

I think the whole interpret method can be rewritten to something like the following. Note the changed names. 

You can imagine the idea of my algorithm as follows. I have the numbers of the set in the vertical axis on the left, where the first element is actually the empty set. These numbers are not considered as only numbers, but, as I go down from the empty set (the first element), I start considering greater sets, that include all previous elements plus the current one. Example, suppose I have the set . I first consider the empty set, then the union of the empty set and , then the union of and , and finally the union of and . In the horizontal axis you can imagine I have an increasing sequence of numbers up to the number we want to obtain (by summing the numbers of a certain subset of ). Example, suppose we want to obtain 4, then the increasing sequence would be . So, I first start considering I want to obtain the number 0, and then 1, 2, etc, as it is usually done in a dynamic programming algorithm using a bottom-up approach. Apart from the setup of the matrix, my algorithm assigns 1 to , for some , where is the size of the set , and for some , where is the number we want to obtain, when either the current number in the subset, that is , is equal to the number we want to obtain , or when the previous solution to the subproblem, where the number we want to obtain is , was 1. That might seem a confusing explanation, and I think the code is self-explanatory. Is my algorithm correct for all instances of the problem? Is there a way I can improve it? 

No shit, it's a dictionary. But can you find a name that tells what kind of dictionary it is? To reduce code size, you may consider , but some people may find it too "clever." 

Here, vals could be a list instead, like . Making it a tuple just makes the code a little bit more complicated for no reason. 

Sorry for bluntness, intended or not, but here we go! Not very good readability IMO. It takes a while to understand what the code does. Unit tests or at least some sample input and output may make it obvious. In general, naming should be improved. It's difficult to understand what a function or variable does from its name. There's also much shuffling of data back and forth that seems unnecessary. It looks like this can be simplified quite a bit, see inline comments. Also, you use tuples in many situations where a list would be more natural. As I had problems understanding the code, I may have misunderstood things in it, so read the following inline comments with that in mind. 

I was trying to write a dynamic programming algorithm using a bottom up approach that solves the subset sum problem's version where the solution can be either an empty set and the initial set can only contain positive integers. The following is my implementation, but I am not sure it is correct for all cases. 

I have implemented a "infix-to-postfix" function that takes as input a list representing the parsed expression, resulted from applying a certain regular expression to an expression, and I would like to have your opinion regarding its correctness and efficiency. Good suggestions are of course more than well-accepted! For making you able also to test directly my algorithm, I decided to include also the regular expression and other important details. 

I have a graph represented as an adjacency list. I need to find a triangle in this graph. A triangle is a triple of vertices , and , such that , and are edges of the graph. The graph does not necessarily needs to be undirected. I found the following pseudocode for solving the problem: