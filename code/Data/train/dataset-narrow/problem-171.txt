Your suggestion is almost correct, except for accounting for the additional Left and Right edge of the received bytes. 

High re-transmission percentage is a definitive sign of something being wrong. But unfortunately it isn't always a direct sign that congestion is the issue. If you could provide some packet captures, that would help us help you determine what the problem is. I would also suggest running sets of 1000 pings throughout the day. Look at the resulting Round Trip Times (RTT) and the resulting Packet Loss %. Those each tell you something different. Typically, high RTT means congestion, and high Packet Loss indicates an unreliable path (which can also be due to a plethora of different reasons). 

(all others are reserved / not in use) My question is specifically surrendering the "Interface-Local" scope. I understand academically what it means, the multicast packet travels only so far as the local interface (aka, doesn't actually hit the wire). But practically, what are some use cases for the Interface-Local scope? 

You can use one physical switch for "in front" and "behind" the App Server, with two different VLANs. Or you can use two separate physical switches. Also, the easiest way to cable the above is to use two NIC's on the APP Server, one facing the Upstream (towards the Internet), and the other facing downstream (towards the Server1/2). If you only have one NIC available, you will have to use a Trunk link to a single switch, which will send both VLANs to your server over one physical connection. Then you will have to make your APP Server VLAN aware so it can properly segregate traffic going to the Internet or traffic going to Server1/2. In all cases, you will have a particular IP Network for the "in front" VLAN, another one for the "behind" VLAN. The "in front" VLAN's IP will be set by your hosting provider. The "behind" VLAN can be anything you choose. I used VLAN#'s 10 and 20 above, but those are arbitrary, they can be anything you like them to be. 

Each of these pairs of /24 networks would each receive its own set of IPsec tunnels (one for outgoing traffic, one for incoming traffic), identified by a specific SPI (Security Parameter Index -- fancy term, its just a 8-hex digit label for a set of security algorithms and keys -- also known as a Security Association). So for example, SiteA might have something labeled like so: 

A Stateful address assignment involves someone keeping track of the State. Which is to say, some system exists that provides a log that certain IP addresses were assigned to certain MAC addresses. DHCP / DHCPv6 keeps truck of such information. A Stateless address assignment does not keep track of what has or hasn't been assigned. It simply determines what address it should use on a particular network (to include possibly picking it at random after determining the prefix) and uses a system like Duplicate Address Detection (DAD) to see if it inadvertently selected an address already in use. TLDR: Stateful requires a DHCP server to have been configured to hand out addresses. While Stateless address assignment simply requires the Router/Default-Gateway to understand and implement RFC 4862 Your assertion is essentially correct. 

EDIT: Oops, I just re-read your question and I believe you are hoping to limit who can SSH to your ASA using the "ldap-attribute-map". As far as I know, the LDAP Attribute Map feature is only used for modifying VPN access, not management access to the ASA itself. I'll leave my original answer below in case you (or anyone else) finds it helpful) 

Hopefully that will help you distinguish or place protocols in a particular layer. Again, keep in mind, it never works out perfectly. The OSI model is a conceptual model, not an explicit standard everyone strictly adheres to. 

The answer is "eventually yes". Each layer adds to the original data what it needs to add in order to accomplish its purpose: 

Notice, you are intending to change the destination IP, and not the source. But remember, what we are looking at here is the attributes for the incoming packet, not those of the return traffic. If we were to map out the Return traffic, we would end up with the following: 

Obviously, capturing on all four of these points would also create 4x duplication of the traffic. So capturing on one of these would be sufficient. A common practice is to deploy netflow on the ingress interfaces of all your 'access' routers. Which in the (again, simplistic) example above would mean setting up a capture at these points: 

Hosts do not know whether they are connected to directly to another host, or to a switch, or to two switches. They only know who the other party is they want to speak to, not what devices may or may not exist in between. After having completed the ARP process, the host will be able to create a packet with a L2 header that includes a destination MAC address of the other host. The switch will then behave as follows: 

In this example, the initial frame is addresses unicast, directly to Host B. The switch will flood the frame out all ports because it does not know (at this point) where Host B's MAC address exists. Had the initial frame been a broadcast, which is to say a frame destined to the MAC address , the effect would have been the same -- the switch would have flooded the frame. 

You would have to capture packets to be sure, but I suspect what is going on is an ICMP Redirect. If a Router receives a packet for which a better next-hop exists, it can send an ICMP Redirect to the original sender to inform them to use the better next-hop when trying to speak to that same destination. The initial sender will update its routing table temporarily with the new information. I believe for 10 minutes, but this is probably different with each OS/vendor/implementation. There is generally a way to disable ICMP redirects at the Router. And there is more than likely a way to disable accepting ICMP redirects on the Host. If not specifically, then indirectly by blocking it with an ACL or iptables entry. You can read more about ICMP Redirects here: $URL$ The are now-a-days considered a security vulnerability, but when they were created they were based on good intentions. As the Internet got bigger, and less trust-able, however, their use has been significantly reduced -- and discouraged, for that matter. 

If SiteB wanted to be completely correctly configured, must have the exact mirror configuration for its Encryption Domain. So in a perfect world, it would look like this: 

The "instability" would only exists if both ends of the VPN tunnel are using different values for the subnets on either side (aka, the "Encryption Domain"). Let me explain... There are three main symptoms of instability you would encounter if the subnets don't match perfectly. I'll start by describing a "fully working" tunnel, then list out the possible scenarios for a misconfigured tunnel where the subnets are not the same. 

My question: OTHER than the two differences identified above... what are reasons why one might choose to use the command verses the command. Does it simply come to personal preference? Or local policies? Or are there other definitive use-cases that would require the use of one or the other. 

Both PC's are still using the MDI NIC, which means they are both sending on what they believe are Pair 2. But the individual wires are crossed so that what is sent on Pair 2 arrives on the other PC on Pair 3. PC to Switch to PC But what of a Switch, then? How do they fit in to the mix. Switches are designed to be "in between" two PC's communicating. Therefore, switches are created with an innate crossing of the wires. This is accomplished by switches using the MDI-X standard, which is the opposite of the MDI standard. The MDI-X NICs send on pair3, and receive on pair2: 

The link you provided was broken, so I couldn't validate the context. But, as I contributed to the other thread, I might be in a good place to help contribute to this =). At the end of ISAKMP (Phase 1), three keys exist: 

I was going to post this initially, but when you said everything is now working with Proxy ARP disabled, I was rather confused. Because in fact, it shouldn't be. Could you post the relevent portion of the Router's "show arp" entries for the Firewall and Server IP addresses? The ones equivalent to the 9.9.9.2, .3, .4, and .5 addresses from my example above. 

If we ignore all the cryptography involved in the Confidentiality and Integrity services that both of these services provide, the only main remaining difference between SSH and SSL are how they engage the concept of Authenticity. Authenticity is the process of confirming the other party of the communication is indeed who they say they are. Both protocols approach this differently. SSL/TLS SSL/TLS is primarily concerned with Server Authentication. The client in a SSL/TLS communication is rarely authenticated (at the SSL/TLS layer). For example, when you connect to your bank website over HTTPS, your browser receives a certificate from the bank which proves the bank's identity. BUT, you or your browser are never forced to provide a certificate to identify who the client is. Your bank website will probably ask you for a username and password, but understand this is happening at the HTTP layer, and after the SSL/TLS negotiation has already completed. At the SSL/TLS layer, your Bank website has no idea who you are. Additionally, in the traditional mode of operation for SSL/TLS is the concept of Chain of Trust. Namely, when you receive a certificate from a Server, you only trust it because some other entity vouches for the validity of said certificate. This "other entity" is known as a Certificate Authority (CA). If not for the CA, the Client has no way to really know whether the other party in the communication is who they say they are. SSH SSH, on the other hand, is more concerned about Client Authentication, but provides some measure of Server Authentication as well, but not the same way that SSL/TLS does. When you connect to a server using SSH, the server requires the Client to provide a username and password (or an SSH Key) to identify whether the client has access to the particular server. This process is built into SSH itself. Once connected, the Server gives you an RSA identity signature, which your client can store locally as a sort of fingerprint for said server, so that in the future when the Client is connecting to the Server, he can validate the signature to ensure he is definitely connecting to the same Server he originally connected to. Notice the difference, however. In SSH, you can connect to a server, and then ensure future connections are connected to the same server. But the real identity of that server is never truly proved. No third party entity vouched for the Server's identity. In fact, you only know you are connected to the right Server because of your own prior knowledge of what should be on the Server. Which is to say, when you SSH to a server, you know before hand that you should expect to see a certain set of files or software on the server. 

Key to answering your question is making a very important distinction: Duplicate Address Detection (DAD) and Multicast Listener Discovery (MLD) are completely separate protocols. Now, that said, I think this paragraph of RFC2710 explains the "duplicate" transmission: 

By default, the K1 and K3 values are set to 1, and the K2/K4/K5 values are set to 0. These values can then be plugged into the full (rather complicated) EIGRP composite metric calculation: 

That said. I think your simplest solution is to just use a switch. Then your two wall ports can be extended into as many switch ports as necessary, and then on the other side you would still only need two router ports. Even a simple hub will do if you're just trying to get one or two extra ports out of your already existing wall-run. 

Before you can really understand how the Switches learn source MAC addresses, you have to learn how the packet travels from HostA (on the left), to HostB (on the right). I put numbers at each position of the packet and the direction it is traveling to get to HostB. The Src/Dst IP/MAC at each position would be as follows: 

If one site has the internal address space of 11.11.0.0/16 and the other has 10.1.1.0/24, then technically you do not have Overlapping networks on either side of the VPN tunnel. If you want the 11.11.0.0/16 network to speak directly to the 10.1.1.0/24 network, then you don't need any type of NAT. If you want the 11.11.0.0/16 network to speak to another network, but have that other network be translated to 10.1.1.0/24, then you would need to set up a Policy NAT. For example, if you wanted to hide the 10.1.1.0/24 network as the 22.1.1.0/24 network, you would set up a Policy NAT on the Router/Firewall on the 10.1.1.0/24 network that essentially says: 

SNAT automap applied to a VIP will only affect traffic that has arrived inbound to the VIP. It won't affect traffic initiated from your real servers heading outbound. For that, you will need to create a SNAT Pool. More information here.