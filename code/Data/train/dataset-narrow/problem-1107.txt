Incomplete or Incoherent Design I see (make it singular) but no classes for admins and requests. Is used? - what does it mean to "take" an admin? & - they should both be "Makexxx" or "Addxxxx". And "MakeAdmin" suggests that it makes an Admin object, but there is no Admin class to make it from. Why not instantiate member, manager, and request objects? You are forcing the client code to instantiate them. That's a guaranteed way to corrupt the integrity of your data. 

Using composition instead of inheritance means that we've hidden all the public methods - so we can control how our collection is exposed to the client. And, we write methods in terms of our problem space. The simple above, for example, may seem redundant but that is not the point. Further we can add functionality, for example if we don't want duplicates, or there was some other criteria for adding or rejecting an we can do that. So our methods written in terms of our domain are customized for our domain as well. 

This is a factory pattern because the client uses a class (the factory) to build the Rental car information list. It strikes me that this is almost the builder pattern. The Builder is simply an object that encapsulates the building of a more complex object. IF, along with building a particular we had to build a custom version of the to go along with it - well then 's class diagram would look like a builder pattern I believe. So it occurs to me that perhaps a Builder (pattern) is simply an encapsulation for a more complex Factory (pattern). 

Edit This edit is about moving functionality out of and into class where it belongs. The themes are rigorous encapsulation, using game terminology, and Single Responsibility Principle. 

This could be the basis that get to where you want to go with the code. As pump, motor, etc. will subclass Product you have the polymorphic framework you need. 

THIS - Let the Visitor do the walking and talking (decision making). And the decision to evaluate empty squares is delayed as long as possible - push details down. Note that Board, Square, Piece visiting logic is decoupled/layered. 

Hey Rocky! Watch Me Pull A Rabbit Out of my Hat If you're a Rocky & Bullwinkle fan you know how that always turned out! Well, here goes ... It looks like every generates a parent, child, and grandchild node. So, how about we generate all the nodes first, holding them in parent, child, grandchildren s. Then adding to collections is simple. Extension Methods Great for putting "core" things in understandable terms. Even without all the craziness I think you should implement some Extension methods first, then refactoring will be less confusing. 

Logic nesting is too much. When I read that final Im saying "else what? Where am I?" Too many s is bad enough, with code clarity is out the window and bug potential explodes. 

Looks like you'll have every rule iterate the order items. I'd rather see the iterate the items; and only once. 

DB call control flow Right in the middle of , (and member) gets called. What happens if there is a partial failure somewhere? I don't see clean recovery here. At the very least I'd separate group, admin, member DB calls for better flow control. Is it essential that an Admin gets set in the DB before creating the group is finished? In any case look into your DB's support for transactions. I'm not saying you need transactional behavior, that's a design analysis issue. 

IMHO the ideal will be to pass a parameter to the factory that unambiguously tells what to construct. As is, the factory is making gross assumptions about the content & validity of the incoming query string. But there is no telling what free-form text is in it. The client code should evaluate & validate the query string and then pass the appropriate thing to the factory. And IMHO do not pass a string. Use . are: 

You have managerId and employeeId as local variables. Are these not already part of the employee class? You will find in the long run that it is a mistake to gut object properties and "lay them out on the table." You are corrupting model integrity. You now have to keep redundant properties in sync and for each layer (M.V.C.), that's 6x the work per property. The whole thing is very un-Object Oriented. Make your methods do their jobs should know how to handle a null employee. Its a cruel world and methods must not rely on the kindness of strangers to pass valid arguments. As is the method is not at all reusable. Every client will have to know 1) don't pass in a null 2)I'm supposed to get a zero in this case. You'll re-write the exceptional handling over and over and .... That's like the customer - every customer every time - having to tell the restaurant staff where they keep the french fries. So, not this: 

We are lying the foundation for code organization and extensibility. With 20+ "types" this differentiation is also the single responsibility principle in action. This is fundamental functioning that every class/type needs. Now I can identify a plain-old byte[] by it's "type" and it behaves like a unique individual via it's values - as used in , , , , , etc. w/in the .NET framework. The entire statement will devolve to one line: 

Create coherent classes. A coherent class has appropriate properties to describe/define what it is and appropriate methods to describe/define what it does. This design goal is in play regardless of specific overall implementation. The OP does things that should do for itself: emit it's property values - ; and . Minimize coupling and maximize coherence 

Resizing? I thought this is what we're trying to avoid. Where is the "resizing"? I assume it will be in and . If there is no resizing - the size is fixed at instantiation, then the class name is wrong. The conventional wisdom says resizing is less performant than resizing a . In fact the team went to great lengths to make sure automatic resizing performs well. Do you have the time and other resources to make your home-spun resizing worth not using what the .NET framework already gives you? Wrong Perspective I see the client having to write his code in terms of s and array elements when it should be in terms of your business objects - , for example. The structure - the array - should not be the emphasis in your design. If you keep going down this road you are in for ugly maintenance problems over time. Give the business classes "collection friendly" capabilities I imagine sorting, searching, preventing duplicates, uniqueness, etc. might be important qualities when we make a collection of things. So should implement and . , or any other user's code, should not be doing this: 

Now the test code stays small yet your tests are as variably complex as your data object collection. 

If you're going to build a game on this stuff, you better start coding object oriented. Good OO coding naturally manages complexity. Without coherent classes, proper encapsulation, etc. adding game complexity will turn your code base to mush. 

I've written this in C#, but it should translate to Java easily. I made call itself, reversing the order of player1 & player2. This eliminates fully half of the 'if else` maze. 

Business Rules affecting Design All 3 controls always work interactively If business rules apply to all 3 controls together then let's keep them in one class. The calender has rules relating to the dropdown, and separate rules relating to the text box. And the dropdown and textbox have their relation rules too. In this case, one class to rule them all. However we assume these rules are the same; it doesn't matter if we're going to use is for "stop" or "start". Below we'll see how we get that context through class composition.