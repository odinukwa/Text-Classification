What this means is that if you're teaching how to use , you can skip having to talk about generators/the whole iterable vs iterator thing entirely, and just introduce as a special sort of list that's specifically optimized to represent a large range of numbers w/o needing to consume a huge amount of memory. This means you still need to introduce a new concept ("oh btw, here's another list-like thing"), but hopefully this shouldn't be as new of a concept if you're also planning on introducing things like tuples or sets. You could even use this as a way of introducing the notion of objects/how everything in Python is an object. For example, you could introduce the concept of fields and methods using 's , , and attributes and and methods. For zip, no such luck, I'm afraid. The function genuinely does return an iterator (e.g. an object that's consumed after one iteration). But given how is really more of a convenience feature more then anything, you could perhaps defer talking about it until later once students are comfortable with the notion of iterating over various collection types. 

To a certain degree, it comes down to experience. But if you don't have experience, I feel you can get a lot of mileage of just trying to do the simplest thing possible to see what'll happen and googling your questions as you go. At some point, you'll run into an obstacle you didn't anticipate and realize you need to pivot and adjust or even entirely re-write your code to accommodate. (Having to rewrite code can seem painful at first, but it's basically something everybody needs to get used to. It's helpful to have a sort of zen mindset, where you let go of your attachment to your code). Once you do this enough times, you start to develop a sort of gut sense for what sorts of obstacles you might end up. For example, take your shell example. If I had absolutely no idea what I was doing but just moved forward instead, I would probably... 

It sort of sounds to me like those students don't have a good understanding of how to effectively study computer science and programming. In that case, it might be worth explicitly taking some time in front of the class to explain what effective and ineffective study habits specifically look like. In particular, I would try emphasizing the following things: 

Ok, how do we do all three of these things? Well, if we drill down, we might end up coming up with something like this: 

Well, for one, computing a truth table doesn't scale: generating one takes exponential time, with respect to the number of variables you're using. You can perhaps "subtly" drive this idea home by asking your students to manipulate some proposition that contains 7 or 8 variables (which would require creating a truth table with 128 or 256 rows). That would require an exhausting amount of work -- the benefits of using algebra should hopefully be more obvious, then. To make the problem more tractable for the people who are using algebra, you could perhaps engineer the original statement so some of the variables end up "vanishing" (e.g. they simplify into something like ). I think it would also be worth explaining why it's useful to be able to systematically simplify or manipulate boolean expressions in the first place -- for example, you could explain that when you're designing circuits, you have a vested interest in minimizing the number of gates used to keep costs down (as well as potentially minimizing the number of unique gates used). And finally, another idea is to just simply tell your students why you're asking them to learn this material in the first place. For example, you could say that you're trying to prepare them to write proofs later on in the course (assuming that's what you're doing). After all, a large part of writing proofs is about correctly manipulating and applying definitions, and that's exactly what you're asking the students to do now. Generally, I think sharing your gameplan is a good way of getting students on-board (albeit sometimes reluctantly). 

You aren't overwhelming the students with feedback -- if you give too much, they tend to ignore it altogether (I learned this the hard way). The students are actually aware that they're given feedback, and that they're expected to read it. I'm not sure how exactly you're returning feedback, but if it's through some website, perhaps that website's UX is bad. They're aware that the feedback contains info they're supposed to apply/contains warnings of things you're going to continue deducting points for. 

Basically, while I'm a fan of functional programming, it's hard for me to see how exactly you'd go about teaching it to beginners. I'm sure that if I were really pressed, I could figure something out, but it's non-obvious to me how I'd teach the material in a high-quality way and how I'd rearrange certain topics I think are essential. (For example, many students struggle immensely with the notion of "indirection" -- basically, how to use things like references and pointers. But if we're using an immutable language, indirection suddenly isn't as relevant: a variable could be a reference to some data or a copy of said data: it makes no difference. In that case, how and where should I teach students about indirection?) Taking all of the above into account, I think a more tractable alternative is to start with a language like Python (or maybe Java?) first, then move on to more challenging languages like C or Haskell second. 

Then you rinse and repeat... Another strategy you can try is to try planning ahead: specifically, figure out what precisely you want to do, then decompose that plan into smaller and smaller subproblems. The nice thing about this approach is that it forces you to think about potential obstacles you might run into and can help make it easier for you to form precise google queries. For example, we want to write a shell. Well, what exactly does this shell need to be able to do? Let's say as a minimum prototype, I want to be able to: 

Show them that you're serious: grade the student's code reviews -- initially based on effort, then later based on correctness. This will definitely be a lot more work for you, but it does make sure that everybody is practicing and kills accusations that you're trying to avoid work. You may want to deliberately invent poor and buggy code samples to give to students if you're going to take this route (as opposed to having them grade each other's work). You should probably do this carefully to avoid overloading both you and your students. Incentivize code reviewing somehow. For example, one idea is to offer students the opportunity to code review each other's work before they submit it -- you then proceed to grade their code fairly harshly. Students are then incentivized to take code reviewing seriously because it's a way to help mutually ensure they get a higher grade. (After all, in humanities classes, you proofread each other's essays -- why not proofread each other's code as well?) Another idea is to tie it into regrades: if students want a regrade of a past assignment, they also need to conduct code reviews related to that assignment (and probably a retrospective). However, this would probably only really feel worth it if your assignments were on the harder end of the scale/you grade strictly. Set up situations to make code reviewing happen organically. For example, give group projects/pair projects. Tell them that you'll be grading them not only on correctness, but based on how sound their project's design is/how well they follow your in-class style guide. Students will then naturally be incentivized to at least check their partner's work. Incorporate code reviews into your exams. Give them short, invented code samples, and ask them to identify all of the style and correctness errors they can find. 

All of this usually takes about one hour-long lesson, assuming you've covered basic usage of maps and sets in a previous lesson. Finally, to help reinforce the point, we start mandating that students use foreach loops whenever possible on their homework, and start deducting points if they use for loops in places where it's not the best option. The very next homework assignment requires students to manipulate and iterate over sets and maps, so in practice it's almost impossible for students to lose points for this. 

tl;dr: having systems knowledge is useful. And if you're going to teach systems, I would imagine that you're basically obligated to teach at least some assembly. 

Absolutely. Merge conflicts are common in school settings, where students frequently need to work on the same, small, subset of files. 

Start by explaining how IP addresses are used to route packets. Explain that once a computer finally receives a packet, we're still not done: the operating system need to figure out which currently-running program to give it to, if at all. This might also be a good moment to ask your students to discuss and try coming up with a solution themselves -- hopefully, most of them will independently realize they need to include metadata of some kind. You can turn this into a mini-design lesson: an ideal solution should be simple, minimizes packet size, is future-proof, flexible, doesn't break the transport layer abstraction... Tell them about ports, and explain that was the solution people ended up coming up with. 

Get user input Run basic navigational commands like and Define basic environment variables Be able to run other programs 

Just to check, are you setting expectations correctly? For example, perhaps the reason why the students are focusing so much on the visual appearance is because they think that's the core "point" of the lesson (or the class). If so, that could perhaps be something you could clarify in your rubric or syllabus -- make it clear that you care more about the underlying functionality of their code, that you're ok if the final product looks a little visually unpolished, and that if they want to go above and beyond, they may have to do some independent studying. It might be worth setting these expectations explicitly whenever you release your first assignment/exercise, especially if you tend to get a lot of students like this. Or alternatively, you could perhaps do this implicitly by doing with Buffy suggests -- restructure your assignment so there are distinct divisions between the "frontend" and "backend" logic, and provide the student with assignment specifications that focus heavily on the underlying backend logic, give them a bunch of tests for the backend, etc... Or perhaps your students are restless and are doing extra work because they genuinely do want to make the best product that they can? In that case, something you could do is to redirect them by suggesting more productive extra enhancements, which they can perhaps do for some minor extra credit. That way, they're still learning, but are focused on topics you feel are more relevant to the course. 

I think the material you cover will vary depending on how much of Git you're trying to cover. If you're just trying to cover basic use of git, I think teaching , , , , , , and should be sufficient (if you're using the command line). Since you're using a GUI, I suppose you can prune some of these commands down (though I do think showing how to use Git from the command line is useful). I wouldn't even cover branching: it's not useful for basic usage. When doing this, be sure to remember that you do need to do a little initial setup before you can use git: you need to set your default name and email, set up an ssh key (which, note, you can do on both Windows and Linux -- no need for something like putty). I'm not sure how you're asked to do this setup when using the GUI, but it's certainly something you need to do when first using Git on the command line. You also should absolutely cover how to resolve merge conflicts here, and techniques for minimizing merge conflicts (e.g. commit before pulling). If you can, try and have students do an exercise where they deliberately cause merge conflicts and need to resolve them. Merge conflicts are inevitable, so you should prepare your students to deal with them. I try and demystify merge conflicts as much as possible: for example, I like straight-up showing students what a conflicted file looks like in their text editor to emphasize you don't need any special tools to resolve one, just their editor.