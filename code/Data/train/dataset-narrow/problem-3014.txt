When I have finished introducing my students to Objects (including Encapsulation, Inheritance, Polymorphism, and a healthy dose of philosophy), I would like to give them a lab with the following criteria: 

Your instinct are dead-on. Students, at least in grades k-12, are not terrifically motivated by what they will "need" in the working world. There are plenty of good reasons for this. First of all, what they will do for their work seems very abstract and far-off. Also, viewed from a vocational lens, there is a quite reasonable shot that they won't actually need the things we think they will. They might not be going into (or might not think they are going into) the careers we are thinking of, and in any case, jobs are so heterogeneous that to make almost almost any statement of what work requires nearly meaningless. Add into the mix the speed at which the world seems to be changing, and our predictive abilities just get worse and worse. But not everything is lost. People, including kids, are intrinsically motivated to learn when conditions are right. But we have to get a lot of different elements all moving in the same direction, and for some students, this is easier to manage than for others. Some students love school and think of it as a place where they can thrive, but some others are a little broken and burnt out, or feel unsafe either about approaching difficult topics, or about their surroundings, and these problems can make intrinsic motivation very hard to tap into. The end-goal is to help kids feel safe to try their best, that the ends are actually achievable, and that the material connects to their current world. -- Organizing the world for motivation -- Teacher Beliefs Let's start with a few ideas that have to come from the front of the room. Certain teacher attitudes permeate the classroom. These attitudes are not sufficient by themselves to motivate kids, but if they're not there, nothing else is going to go right. 

How can I illustrate the difference between $\lor$ and $\oplus$ in a way that isn't just boring? Are there fun ways to illustrate and provide practice for this small, yet key, distinction? 

There's one more reason I'd like to add to those here, less high-minded, but also a genuine consideration. One of the practical difficulties of teaching an introductory course is that the students come in at vastly different levels. Some are quite competent already, and some are brand new. It is rare for kids to come in with any experience outside of imperative labguages, though. By utilizing a functional language in your first course, you get to have a classroom full of kids who have a much more similar footing. And when you move on, later, to imperative programming, you no longer have any kids with no experience. It's a simple trick to keep your cohorts more on-level without wasting the time of the advanced students. 

Part 1 When I introduce the loop, I do it the context of a lecture on ArrayLists and wrapper classes. I first just kinda slip it in unannounced: 

When I created my course for Scheme (under not dissimilar circumstances from yours), I used The Little Schemer as my primary source. The book itself rapidly became too dense for my HS students, so I designed my lessons around each chapter. My course, then, like the book, took the students slowly through a very foreign landscape. We took no effort to translate imperative programming at all. Instead, we were ing and ing up a storm, playing with lists, playing with atoms, and creating tiny programs in this alien (elephant-ridden) landscape together. There was a downside to this, however: because it was presented in a truly functional paradigm, my students did not advance quickly, and did not become nearly as capable in Scheme as they were in Java, Javascript, or C. They just couldn't get the breadth and depth of experience within the functional idiom over the course of two months that they could with imperative programming in two years. Nevertheless, the work that they did truly was native Scheme. 

So far in my career, when I have a student who just doesn't seem to get it (and there is no obvious discernible cause) it very often comes down to one of two problems. The first is mutability, which I wrote a little piece about here. Kids who can't easily trace how values will change need explicit practice in this concept before they will really be able to follow what is going on in imperative languages, and it can take a surprising amount of practice to help them to really get it. The fact that it's so easy to describe is disarming, because we think they get it. And the kind of extremely simple code that we might use to determine understanding often doesn't trigger the kinds of incorrect responses that would naturally call teachers to action. However, as soon as the code itself starts gaining any complexity, having a cloudy notion of mutability is a game-stopper, pure and simple. The second is simple motivation. For the kids who aren't so quick with CS at the start, not being willing to put extra thought and effort into the topic halts their growth. I don't have a lot of generalized insight into how to fix this one. When I have unmotivated kids, they mostly just kind of muddle through. 

Is there an accepted core set of concepts that is discrete mathematics as it applies to the study of Computer Science? The math department in my school is thinking about creating a course, they asked for our input, and I wasn't sure what to point them to. 

Test every bit of code in an IDE or a live coding environment As much time as double-checking code takes, it still takes much less time than unanswerable questions that you ultimately can't count in the final grades. Create the answer keys directly in the examination file. This one actually saves me a lot of time. If you use Microsoft Office, simply color the lettering of any answers white. When you print to a standard black toner laser printer, these answers are not printed at all. This practice also helps you gauge how much space the students will need for a free response question. Create your rubrics for grading in the question space as well. Placing a rubric or grading guide into the exam (again, in white) both makes you reflect on the original question (thus helping to ensure quality) and makes it easier to grade later. Build a question bank over time. This combines particularly well with numbers 2 and 3. It allows you to slowly recycle questions from years past, keeping keys and rubrics intact as you go. 

I understand, as a model, how a researcher at a university can advance the entire field of CS Education. Less clear to me, however, are methods available to teachers in the field who do not have doctoral degrees, much less a publication history. Beyond posting on this website, what ways are available to advance the field of CS education? 

It is not unusual for the creation of a single test or quiz to take me 3-4 hours to design. I have to look over the curricular material and brainstorm problems that can get to the heart of the core issues. I then have to design the problems, test everything in an IDE (to make sure that there are, at least, no typos in the code examples), create grading rubrics and processes, and finish up with final formatting. I tend to use a mix of multiple choice, free-response (coding by hand), and short answer questions The first and second of these are what students will find on the AP Computer Science A test, so I need to give students practice with these kinds of activities. The short answer questions are an easy way to check for understanding of some particular little point. I have found that, between my various classes, I give an average of one quiz or test per week. If we assumed a 40 hour work-week (ha!), then designing each assessment fresh would be a commitment of 7.5%-10% of my entire work time. That doesn't count the time to administer or grade the thing, this is just for the design aspect. In reality, then, I mostly don't do this, and mostly give assessments from prior years. I want to change this practice, but I don't see how I realistically can. Are there strategies to speed up the design of written assessments without losing quality? Note: I don't want to give fewer assessments, because labs are suspect, and because of the tremendous cognitive benefits of testing. Instead, I would ideally like to be able to design a high-quality test or quiz in under an hour. This amount of time would make the entire enterprise more tenable. For the benefit of future visitors, I will also include my own answer, though given my times, it will (obviously) only be a partial answer. 

The good news is that, by breaking it down into these two steps instead of one, you can actually help to isolate the problem that your students are having. If you see your students frequently (as I do), here's a fix-up strategy that you can do in about 30 minutes of class time over three days. Create a worksheet with a series of word problems, and ask the students, as homework, to generate test cases for these hypothetical machines. They are not to create the grammars themselves, only create a series of test cases that should be accepted or not accepted. Emphasize that redundancy is not a goal; you want a minimal set of test cases that could guarantee that some grammar is entirely correct. The next day, spend about 15 minutes going over two of the problems, round-robin style, at the board. Ask a student to write a test case for the first problem. Turn to the second student, and ask them to write another test on the board that could potentially uncover new ground. On to the third student, fourth student, etc., until you are satisfied that you have a good testing set. Ask if anyone else has any important tests remaining. Do the same for the second problem, and then discuss the importance (in general) of creating good test sets upon encountering a word problem. Point out that they will receive word problems on their assessment at the end of the unit, and you expect them to be able to figure out a good set of test cases with which to design a grammar at that time. Their homework for that second day is to fix up their tests (if they need more work), and to create the appropriate grammars. I suspect that when you get this homework back on day 3, you'll have much stronger results. 1 - I am using "grammar" as a stand in for "grammars, regexes, FSAs, or whatever type of expression/machine you are trying to get them to create at some particular moment."