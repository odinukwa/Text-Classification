So, don't do any math then? Actually, I would not say that. I would touch on a some of the underlying mathematics, but briefly, and (because it is a summer workshop) with the simple goal of illustrating that there is important material that isn't too difficult to tackle if they eventually want to go further into the topic. 

He turns it in to the teacher, who says, "Boy, he sure understood this! That's one student that I don't need to give any extra attention to, because he is in great shape in my class!" The takeaway questions then are: 

Obviously, there is no way to definitively know the answer to this question. But my favorite theory has to do with the advent of the home PC, and the original marketing of computer games to boys. The strongest support for this theory is the timing, which means that I must now give the obligatory caveat that correlation is not causation. Basically, the theory goes like this: as the home PC started to sell, the good folks in marketing had to choose which groups they would target with their limited ad dollars. The earliest games that came out involved balls and shooting anyway, so young boys were chosen as the target market. And thus began a generation of young boys who logged hundreds or thousands of hours with computers, with no corresponding boost for the girls. As this generation of children reached university age, more boys signed up for computing majors, and professors began to tailor their classes towards this majority of people who already had some background. Girls who did come in often felt like fish out of water (and abandoned the major), leaving us where we are today. It does not have to be so. There are inroads being made into this problem, and I am hopeful that with the total infusion of computers into all of our lives that is going on now, the timing is right for this problem to begin to fix itself, as the experience differential has begun to level out. 

I've been teaching Objects for years now as part of AP Computer Science A (which means that I am teaching OOP in Java), and I have experimented with putting Interfaces in at different locations. In general, I currently teach in the following order: 

How things went down When the lab went live, it did not go at all as I expected. The students at my highly selective school were far, far more resistant to going on to the next section than I had anticipated, and preferred instead to work at a level that was inappropriately hard. Most students refused to go below 100% for any reason whatsoever, and the students who could really have benefited from the 80% section would not go past 94%. Some students never completed the lab at all, ironically garnering a zero in an attempt to avoid a 94%. More perturbing to me were assertions that there were other students who were cheating, since the sections you actually read were on your own honor. My protestations that my solution was, in fact, highly idiosyncratic (and therefore it would be easy to tell) did nothing to dispel this idea. Later, upon analysis, I did find at least one student who definitely did read beyond the section that he declared, but that was all I was able to find. This whole episode took a tremendous amount of class time, and ate substantially into the good will I had built over the last two years with the class. Innovation? Meet near-abject failure. The Request I have already made a pass at addressing some of the problems the kids identified for this next school year. First of all, I have integrated the coin problem far more tightly into the lecture materials. I have further added new hints and clarifications across the entire text of the lab, and I have changed the point values for the sections to: 105, 100, 96, and 90. With these modifications, the lab will be incrementally better on a number of fronts. However, I can't help but think that my approach is foundationally wrong here. I don't see how to entirely avoid many of the problems that I encountered the first time. How can I scaffold the lab more appropriately without retreating on the final product? I believe that the exercise has real value, and I don't want to simply retreat into lab material that is inherently less rich. 

All of these take practice. I do this in-class so that I can assist and guide, but I also have many hours of facetime with my students. In a more constrained timeline, I would give out homework assignments instead. 

They are safe in school. There are people who care about them, there are people who are their friends, and there are people that they can go to if they are down or get into some sort of trouble. (Particularly in the k-12 arena, this requires some active monitoring on the part of the teacher, and may necessitate some intervention as well. People don't thrive when they are frightened or lonely.) Intelligence is not fixed. Intelligence is more like a muscle, because you can flex it and make it more powerful over time with work. Improvement is always the goal, not just the end-product. 

In addition to all of the great answers here, one further tool to consider is MOSS (Measure of Software Similarity), which has been released for free to educators by Stanford: $URL$ It can currently analyze code in C, C++, Java, C#, Python, Visual Basic, Javascript, FORTRAN, ML, Haskell, Lisp, Scheme, Pascal, Modula2, Ada, Perl, TCL, Matlab, VHDL, Verilog, Spice, MIPS assembly, a8086 assembly, a8086 assembly, MIPS assembly, and HCL2. 

If your school does not have a code of conduct, then you need to write a set of understandings that you can give out to your classes. Ultimately, there are no fair responses without some kind of memorandum of understanding. In there, you will outline what you consider to be cheating, and where, exactly, the lines are. If you want to take a slightly different approach, the lack of a school policy also creates an interesting opportunity for you to get a lot of student buy-in for a strong policy on cheating. At the beginning of the year, show a few CS plagiarism policies to your students, and ask each student to write their own example of a policy that they would consider to be both fair and enforceable. During the next period, have each student pair and share, and debate each other for 3 minutes, and then rate the other student's policy on a few key metrics. Then have them switch to a new pairing and do the same. Once every kid has rated a few policies, have them rate their own. Collect all of the policies, and say that you will go over the top 3 policies along with some of your own comments the next day. On day 3, you now have the makings of a very healthy debate, and the setup for a class vote on a policy. You will need some sort of structure to facilitate (and vote on) document modifications, and an overall vote for adoption. What you will wind up with is a document that the students created democratically, that they can take ownership of, and that they will back. You've also started a very healthy relationship between your students and your course.