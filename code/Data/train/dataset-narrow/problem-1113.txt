I think using that form of the import will let you drop the line where you instantiate the Publisher. I like to put my mainline code in a main() routine right after the imports so it's clear where the work begins 

So display() keeps showing the menu as long as userInput() returns None. userInput() returns None if the user's input doesn't match a button, or the inputSel value if it does match. I think the way the Controller loops is fine. The program will always stop when it gets to raw_input() and read stdin until the user hits ENTER or RETURN. That's what raw_input() does. You're managing your buttons as a list, which means you have to scan the whole list until you find the navigation element the user selected. If you put them in a dict, you can simply use the user's input to index directly into the structure and select the correct button (or determine that the user's selection is invalid). However, you still want them as a list for display because you can't control the order in which entries are pulled from a dictionary and I think you want your menu to display in the same order every time. That needs a list. I would suggest the following for the constructor for the Display class. We're going to pass in a list so it's easy to define, and we'll keep the list, but we'll also have the class internally turn that list into a dict so it can more easily find the user's input on each selection. 

Loop The condition will be evaluated every cycle. You do not need to on each of the loop. The result can be cached : 

I don't understand, why you have 4 different classes with the same properties and copy-pasta comments, and, most importantly, shareing the same role of obstacle. Combine them into a single class, subclass if you had to keep the class name for distinction : 

I don't know if you have noticed the inconsistency. All units and tens are in title case, while the names of large number are in lower case. Consider making them all lower case. 

I'm going to assume the document is composed of hierarchical elements. If that is case, copying and merging the bytes array could get very costly, more as we get closer to the root element. Since you mentionned that you're working with a "very specific binary representation" and writing to a "stream", it would be best to write directly on the stream, rather than copying and merging the bytes, and holding them around. 

Actually, I agree with Quentin. For a first effort, your code looks pretty good. You have a hero class called Erdrick and an Enemy class instantiated as a Slime. A class structure like what I show below would allow you more flexibility with less repetition. See what you think... You might want to work out some way for specialized weapons to increase the damage a hero deals and for armor to reduce the damage suffered. 

So, let's say you build a website that uses this class for storing data. Then, one evening, you and I both visit the website at the same time. We both hit the button that opens the table and reads the data into memory. Now there are two copies of the data in memory -- one in the page you're looking at, one in the page I'm looking at. You add a record. The "insert" function adds your new record and writes the file to disk. Now I update a record. But the copy of the data in my window doesn't include the record you just added. So when my instance of the code hits the statement file_put_contents(...), what happens to the record you just inserted? This is the sort of reason it's recommended to use real database engines like sqlite or mysql. They're designed to serialize calls and protect users from each other so they can't overwrite or corrupt each other's data. 

RLE Formatting If we were to explain it in english, the sequence is joined by a space() where repeated elements a denoted in the format of . If we were to code it in C#, it is not much different: 

Throw an exception on negative numbers. This is covered in last section. Change the parameter to . Do a custom routine for negative numbers : 

There is various overloads of to accommodate different needs, like the one suggested by @t3chb0t. Feels free to add more, if it help you to keep the declarations as clean as possible. And, the rest of the code: 

Personally I prefer the C# 6 collection initializer the most, second by the method shown in first snippet, and lastly the older initializer. 

Do not use Hungarian notation for constants, keep it in PascalCase. If you like to differentiate the names from the properties you can name in form of , like . Do prefer .net aliases over the full type name, like -> , -> . Avoid repetition of word, like and . Unless you are worried about mixed up with the foreign key in your DTO, but it is not the case here. (if it is , that is fine)(you weren't really consistent with the code) should be renamed to : 

The idea is that rather than embedding your data in the code, you should structure it in a meaningful way, then use generic code to present the data from the structures in the way you want the player to see it. I think you're on the right track with your Creature and Item classes. I think maybe you want more classes like Place (or Room), Container (to represent boxes, chests, hidey holes, etc.). If you have to write specific logic for each step in the story, your game is going to be very linear and you'll be limited in how much branching and looping you can manage. On the other hand, if your game is just a network of Places connected to each other with Items, Containers, other Creatures and such scattered throughout for the Hero to encounter and either fight or befriend, and the Hero is free to wander from Place to Place backward and forward and in loops, then the game becomes much less predictable and more interesting. What would the code look like to process such a network of Places, Items, Containers, Creatures, and whatever else you can dream up? 

As you have already noticed, all 4 spawners' implementation are quite repetitive, namely the waiting part. However, each obstacle has its own spawn rotation and position. So, we will have to extract the former while isolating the latter : 

The method has been renamed to reflect more what it actually performs, and the return type has been changed to , since we only need to know if the file contains the search text. 

As you already noticed, all the methods have the same repeating pattern. We can extract this pattern and encapsulate it in a method for reuse : 

Consider switch the order of your parameter. is the key generic parameter in both method, yet its definition is unclear until the 2nd parameter is passed or unless you specify in or . By keep it on the 2nd place, you penalize yourself by not taking advantage of intellisense : 

You don't need "if not out:" at the top of this -- you're in a "while not out" loop and out hasn't had a chance to change since the top of the loop. The "for items" loop just scans through the inventory looking to see if you have the door key. That can be done in a single statement, as I show. Once you've opened the door, you're out, so we can just break out of the "while not out" loop and carry on from there. Several of your descriptions are hard-coded: 

One way to get the neighbor coordinates without checking for (a != 0) or (b != 0) on every iteration would be to use a generator. Something like this: 

Overall, it looks pretty good to me. I agree that you have good commenting and variable and function naming. I see just a few things to comment on.