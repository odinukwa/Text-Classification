The Pi cannot know. You have to make sure. The thing is, if you connect multiple extension boards, you will have to take care that signals lines are either not used more than once or implement a busing scheme that can work with multiple devices sharing some lines (as @goldilocks already suggested). To get a feeling how this could be done, I would recommend to read up on the old ISA bus. Something that could be implemented using GPIO as data and address lines (and if one is up for the pain). 

Yes, should be possible (While I don't understand whether those "displays" are supposed to show some kind of graphics output), it is possible for the Pi to source multiple different audio outputs. One simple approach is to use multiple USB sound cards. is perfectly capable to handle multiple cards (see here). Different software tools or multiple instances of the same should then be able to output different sound files to those cards. The information on the web is slightly inconsistent, some claim that both and support multiple instances running other say the don't. Example, Pi2, with running (controlled by a local instance of which essentialy uses no resources) while playing MP3 uses about 25% of total CPU load. So this could get you to roughly three or four independent sources of sound. At least from a resource perspective. 

Steve's answer covers the syntax error which prevents the program from running. However, I doubt it will do what you intend it to do after the fix. I am right now not sure what actually returns but that return value will be used to decide the conditional here. That is likely not what you want. Either way calling in this line will set this particular output to low. Which you do again in the next line, repeating ad infinitum. There is little point to that. If you want to read back the state of something you will have to turn a GPIO pin to input, i.e. like this: 

While there is a full schematics of the B, rev2 on Raspberrypi.org only some "Reduced Schematics" for the B+ are available. This is stripped down to the absolute minimum, but it is at least possible to figure out the pin numbering on the GPIO expansion header. Another nice spot to visit is elinux which is updated with information of the different pin numbering of the numerous headers of the different models of the Pi. 

Jivings answer holds true if you happen to have an image of Arch Linux around. As of now however such images are no longer issued by Arch Linux. Instead the full file system is provided as a .tar.gz and has to be installed to the SD card from scratch. After preparation of the partition table using and creation of the file systems the root and boot file system is populated with the files from the .tar.gz archive. Find the full installation procedures documented for Raspberry Pi and for Raspberry Pi 2. 

Well there are add-on boards (HATs) for that purpose, e.g. this or that. Such boards connect to the Pi via the GPIO connector. So pin ordering notwithstanding (e.g. HAT might be on top, so back-to-back might reverse the pin-order) it seems feasible to actually solder some hardware to the Pi to get Bluetooth functionality. While raspberrypi.org does not provide an official schematics for the Pi Zero there are some results from reverse engineering known. This site lists the following test pin functions: 

I do not know any reports about a Pi's USB port failing to power an USB flash drive (not an old school hard disc drive with spinning disc and all). You should be fine with any reasonable power supply, no powered USB hub required. 

Where to start? For one thing the GP in GPIO stands for General Purpose... and that is exactly what they're for. Just a few examples what to connect to them: 

With respect to the second point however an increased load (e.g. heavy use of GPIO to the max current and connecting the camera module) should lead to increased amount of failures with SD card access. Are there any reports about this behaviour? *) The used regulator NCP1117 is specified with an output current in excess of 1.0A. The raspberry's schematics denote however a heat sink copper area on the board according the a power dissipation design load of 800mW (unknown design temperature however). Given the necessary dropout voltage (supply voltage - 3.3V = 1.7V) this thermal load would be hit at about 470mA. Woo, that seems quite low but then again it is just a rough estimate according to a annotation in the schematics. 

To me that reads: connect anything between 3.3V and 12V and both the switch operates and the LED works fine. In my book that would include a current limiting resistor for the LED inside the switch, albeit one of the review suggests to have killed the LED while operating it without a resistor. Using 3.3V is also in the range of what the Pi's GPIO pins can handle. Yeah! The review furthermore explains how to wire the switch as follows: 

For clarification, the (additional) local database approach might be overkill here and only comes into play if connection losses are a possible issue as it allows local storage and later retrying of transfer. As suggested by ppumkins comment it is of course necessary to make the central Pi permanently addressable by all the other Pi's either by setting up a static IP or a proper name resolution scheme on the network. PS: I hope all those Pi's do more than just measure temperature... 

disconnect power try to remove the piece using tweezers (just as @Wilf's comment suggested) or even using toothpicks (fun fact: you wouldn't believe how useful toothpicks are in the lab for numerous applications) blow with dry air to remove small fragments visual inspection insert SD card, connect power, boot up, have fun (hopefully) 

The RPi is definitely not made to have the lowest power consumption making it not the best choice for mobile application. As is already pointed out there are a few minor tweaks (disabling the HDMI or if not needed USB) to save a little power. Replacing the linear voltage regulator with switching regulators also helps a little. But still there is no real power-down mode and the RPi will consume quite a bit even if halted this can by no means be compared to power-down or sleep modes of microcontrollers. 

Besides the given limits per pin a total limit for all GPIO pins of 50 mA is noteworthy and should be considered. The total current sourced or sinked from all GPIO together (the sum of all pins) should not exceed the limits of the 3.3V rail. Raspberrypi.org states: The GPIO pins can draw 50mA safely, distributed across all the pins; an individual GPIO pin can only safely draw 16mA. 

You cannot connect to the Pi 3 using the mirco-USB power port. The data lines of that connector are not attached to the Pi - it is just used to provide power. See the official schematics of the Pi3 (pdf), top left. An alternative would be to used the wired ethernet to connect to the Pi and set the WiFi configuration, depends on how tech-savvy the end user will be. Ultimately it might just boil down to you setting it up to a working condition on-site and/or to provide support after that. 

Backing joan's answer with a reference: the official schematics clearly show that the micro USB "power" port has no data lines connected. 

Win 10 IoT core differs quite much from "desktop" windows. It's highly likely that typical windows games will not run as is. Lets call that a reduced feature set. Linux applications can be run if their binaries are provided for the ARMv7 architecture or if you can obtain the source and compile it yourself on the Pi or cross-compile it for the Pi. Obviously the computational power of the Pi is less than that of a typical desktop PC which could diminish the fun for power hungry games (if that is an issue). 

Hoping that I understood the description correctly this is a circuit that should do the trick. Note the additional resistor (pull-up) compared to the way that is explained in the question. Without it the following happens: relays is open - Pi's input is "floating"; relays is closed - Pi's input is low. Which is why you are not detecting a proper change of state when the relays toggles. With the pull-up resistor a defined voltage level is applied to the input pin. See also: $URL$ (note that they propose another series resistor to limit the current in the case the GPIO pin is set to output). 

Not comming up with a complete answer but some thoughts on that matter. Let's have a look at the hardware side: schematics unfortunately not helpful for the Pi B+ and not even available for the Pi2, so we are stuck with B Rev 2.1 here for now. The audio output of the headphone jack is generated by PWM. Right from the BCM2835's GPIO pins 40 and 45 through a RC Low-pass filter. (See schematics, page 2.) Audio on the HDMI on the other hand is supposedly digitally transmitted. Wikipedia states: "For digital audio, if an HDMI device has audio, it is required to implement the baseline format: stereo (uncompressed) PCM." And indeed the before mentioned PWM-based analog audio is not feed to the HDMI connector. So now we've verified some old news: analog headphones jack vs. digital HDMI. From my point of view those two should be addressed separately and independently thus also (quasi-)simultaneously. Now should be able to stream from one source to multiple pieces of sound hardware. I still wonder why there's nothing to find on the web concerning this. 

A little more detail. This is how the current through the LED depends on the voltage across it. The right side of the I-V diagram is of interest here, forward bias, where the light emission that we expect happens. Increasing the voltage from 0V to near Vd (the listed forward voltage of the LED, look for that value in the data sheet) the current is close to zero. No current, no light. The current however increases with voltages greater than Vd, which will lead to destruction of the LED if the current is not limited, e.g. by means of a series resistor or a current source. 

There are two pins (2 and 4) on the gpio connector that carry the 5V supply voltage. See official schematics - look for J8 - or any of the gazillion websites showing Raspberry Pi pinouts. 

One thing to consider here are the requirements, that is: what is very accurate? Without a dedicated hardware clock (RTC) the Pi runs a STC as a clocksource derived from the GPU core clock. Once date and time are set - either manually or by means of they will be drifting off just a little as the frequency source is supposed to clock the chip not provide highest accuracy timing. Without regular resyncing with another source ( or an RTC) it will drift a few seconds a day. So, without adjustments or syncs with other sources, it will drift this many seconds in 24 hours 

is out of scope after leaving the -loop which is why you get the error with your imwrite. Check your intented program flow and indentation. 

Not sure about the monitor but if you want to fix the Pi to a wooden board I'd go with a non-conducting clearance spacer (e.g. Nylon, M3, see here: Harwin Clearance Spacer) and simple screws of appropriate diameter and length. 

Two cool tools simplify your life with respect to the issue of reconnecting to a session lost during a connection drop: gnu and . Those two also offer nice and useful features that come in handy and that is the multiplexing of several virtual consoles. This is especially helpful to control multiple programs on the command line interface from just a single terminal or via one remote terminal session. To add to portforwardpodcast's answer just another little advice to aid usability. Invoke to create a session called "apt" (or whatever you like). This way the session can be easily resumed by without the need to list all the existing sessions first.