I am currently using the default range of 0-255 and a frequency of 400Hz. int gpioSetPWMrange(unsigned user_gpio, unsigned range); from: $URL$ 

hdmi_force_unplug=1 Add or uncomment this line to force the raspberry pi to output at the HDMI port and not on the composite video output (3.5mm jack on the new pi/yellow jack on the old pi). hdmi_safe=1 Add or uncomment this line to force the pi to output at low resolution which is supported by most displays in the market. config_hdmi_boost=4 You can boost the hdmi signal by adding or uncommenting this line by changing the value from 0-7 (o-default 7-maximum). 

use raspi-config to disable Serial use stty -F/dev/ttyAMA0 100000# checked that the Tx and Rx are inter connected (Tx->Rx and Rx->Tx) 

I have been trying to debug this problem for 3 days now. I tried using the wiring-pi library and the pigpio library but both have the same problem. This is an example code with the same issue: 

The vcgencmd command is the more accurate one as the vcgencmd command takes the reading from the firmware and the cpuinfo_cur_freq takes the reading from the kernel. The problem with using cpuinfo_cur_freq is that when the cpu throttles due to too low load, undervoltage, or high temperature, it does not get reported back to the kernel. Source here and here I hope this helps :) 

This might be caused by some missing environment variables; namely the variable. It would explain why a command that doesn't use the display, e.g. , works while doesn't. Assuming that your display is numbered 0 (default), try adding this at the top of your python script: 

Basically your current relay setup (No back-EMF protection) To mitigate the problem, it's common practice to add a flyback diode across the terminals of the inductive load (in parallel from GND to the positive terminal). You have to insert it so the little ring/stripe on one end of the diode is closer to the positive terminal than GND. Be careful with the orientation of the diode; put it in the wrong way and you've created a very good connection (low resistance path) from the positive to the negative terminal, also referred to as a short circuit. 

If the data-sheet for the model B+ is correct, the APX803 is hooked up to the red PWR LED as the wiki states. I can't account for the blinking (could it be caused by C6? Is it actually the raw input power drops you're seeing? Is it a feature of the APX803?) but it certainly shows that the APX803 can make or break the ground connection of D1 (red LED) via Q1 (depletion-mode n-channel MOSFET): 

EDIT: I have found the culprit. It was an undervoltage problem due to what supply I used. The problem was solved by using a separate supply. An indicator of an undervoltage problem is the appeareance of a multicolored square at the upper right corner of the desktop as well as the simultaneous flickering/blinking of the red power led of the pi. Undervoltage automatically disables force turbo to protect from sd card corruption. 

Is it safe to set force turbo = 1 at the config.txt to force the cpu to run at Maximum frequency as long as the temperature does not exceed 85 degrees celsius? However this voids the warranty Also will the command temp_limit = 85, override the force turbo = 1 setting? May I also ask of using this command instead of force turbo by changing the default scaling governor in the /etc/conf.d/cpupower file can achieve a similar effect so as not to void warranty. START_OPTS="--governor ondemand" STOP_OPTS="--governor performance" I have read that using a raspberry pi B+ due to the more stable power supply, I do not have to worry about corrupt SD cards. Is this true? Thank you :) 

Since OP was getting an rather than an , something was clearly being imported correctly but simply didn't have the method . By calling from a script, not in IDLE, to get a list of all available module methods, we found out that he was actually importing a different, home-made script with the same name as the module (). It probably worked in IDLE because it runs from a different folder. So... Use when you get an and avoid using module names for your home-made scripts - it'll make things less confusing. 

It sounds like the power supply is failing to regulate and dropping out momentarily. The answer below seems to describe a similar scenario and the rpi wiki also mentions that the blinking PWR LED indicates an issue with the power supply. From this question: 

Sorry about your Pi - hope you got a new one :) You've probably seen the discussion between goldilocks♦ and I in the comments and have a pretty good idea about what my "post mortem" will say. However, we both missed the fact that the Pi wasn't powered which changes the scenario a bit. How was the screen powered anyway if it's meant to get juice via the Pi pin header? Since we're dealing with 26 * 2 pins that might also be inter-connected via the screen's internal circuitry, there's an awful lot of complexity here. However, important factors always are: 

Good day, I am currently working on an obstacle avoiding UAV using stereo vision to obtain depth maps. I noticed that the quadcopter would sometimes not steer to the correct direction. I am using the Raspberry Pi Compute Module IO board which comes with two CSI ports used with two v1 Pi Cameras. Issue I soon found out that due to the latency between the cameras, the left and the right images are not in sync thus the errors in the depth map result. Steps taken: I noticed the image blur when moving the cameras around so I adjusted the shutter speed by setting the UV4l/raspicam driver. With the shutter speed, I also tried to increase the framerate as I've read, it improves the latency issue. In my code which uses the opencv library, I used the grab() and retrieve() commands to replace the read() command so that the frames from both cameras is grabbed at the nearest time possible however it didn't help much. Does anyone know any possible solutions? 

I don't understand what is doing? It's typically used after a . Writing to stdout puts something in a buffer and flushing stdout takes the contents of that buffer and prints it to screen. I don't think you need it here. If you insist on doing this in python, here's an edited version of your script (but there's a simpler way below the script). 

How it could/should look (with back-EMF protection in the form of a flyback diode. The term "flyback" only refers to the application, not the diode itself. For your low current setup, use any regular diode capable of handling hundreds of volts. Eg. a 1N4001) Check the schematic above... Here you see a circuit with voltage spike/back-EMF protection added in the form of a diode. There's a DC power source (Vs) on the left, a coil (L1) at the top that could be your relay, a resistance (R1), a switch (SW1) and a diode (D) placed across the coil. See how the diode is "pointing towards" the positive terminal on the power supply? This means that no current can flow through it during normal DC operation. However, as soon as you turn off the relay the diode will ensure that the power stored in the coil will loop around in the coil itself until the resistance in the copper windings has "eaten up" all the energy; thus sparing your controlling circuit (SW1) from a nasty shock. The same solenoid setup as before but this time WITH a flyback diode across the load. See that nice, horisontal line? That's safety. $URL$ But wait, there's more! Instead of mucking about with individual transistors and diodes, I suggest you buy 10 trusty old ULN2803 ICs for ~£1 on ebay including free shipping. (I'm not affiliated with any vendors. I simply picked the cheapest product). The ULN2803 is a so-called Darlington transistor array. A single chip effectively gives you 8 individual NPN transistors in one small package (it actually contains 16 transistors but that's hidden away in the chip). They are perfect for your application since they have built-in flyback-diodes and each output can handle up to 500mA (~300mA when controlled from 3v3). They even have built-in input resistors of 2.7 K so you can and should connect them directly to the Pi's 3v3 GPIO. If you get these ICs, you can safely connect up to 8 relays/motors/whatever and control them via 8 GPIO pins. Providing that all the relays are powered from an external supply - not straight from the Pi - this is a safe, cheap and stable solution. It could be done like this. "Do you know of a way to trigger a "power cycle" for the pin without having to physically unplug the ground connection?" Yes! Let a semiconductor do the dirty work! Simply connect GND from your sensor to one of the outputs of your newest investment - the ULN2803 :) To reset your sensor, you simply write a low/0 to the GPIO pin, wait a few seconds and then write a high/1. 

Good day, I am currently working on a quadcopter project and am currently using the pigpio library for the PWM used to command the ESC's of the quadcopter motors. 

I remember editing the dtblob for the CMIO to reroute the I2C, is there a required way similar for UART set-up? I have been so stuck with this problem. Your help would be very appreciated. PS, I cannot use the ethernet port as the CMIO does not have one :) 

Good day, May I ask if it is true that if I activate turbo on the raspi-config, the pi doesn't always run at the maximum speed at 1Ghz. 

There are many converters out there in the market that offer means to convert an HDMI signal to VGA however some of those are said to not work with the Pi. I had the same issue with both Pi and Odroid boards and tried three different HDMI adaptors and got only two of those to work. Here is a list of some HDMI to VGA converters that are tested to work with the Pi: $URL$ For tweaks on the software side you may try editing the config.txt of the Pi located at /boot/config.txt