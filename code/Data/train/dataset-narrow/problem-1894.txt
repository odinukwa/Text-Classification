Your local tmux sends a C-b to the process running in the active pane (ssh). ssh forwards it (through sshd, etc.) to the process running on the remote end (remote tmux). Your remote tmux interprets it as the prefix key; nothing is sent to the processes running under the remote tmux. 

Alternatively, prior to running your command, you could just start a placeholder session that exists just to keep the server running: 

The mixed history of means its default operation varies from shell to shell. POSIX specifies that the result of is “implementation-defined” if the first argument is or any argument contains a backslash. It is more reliable to use (either as a built-in command or an external command) where the behavior is more well defined: the C-style backslash escapes and format specifiers are supported in the format string (the first argument). 

Vim 7.3 added “clipboard support in the Mac console” (see under ). The standard register is the system clipboard when running a tty-based instance of vim ( also works and is an alias for like most non-X11 systems). I am using Vim 7.3 from MacPorts. Paste: Copy 4 lines: Cut 4 lines: For Vim 7 versions before 7.3, you can use fakeclip. 

If the is not already part of the string before it gets to you, you could add if after using so that the shell will expand for you instead of Emacs: 

You can control the expansion of backslash escape sequences of bash’s built-in command with the shell option. Set it at the top of any bash script to make automatically expand backslash escapes without having to add to every echo command. 

Holding down Control to enter multiple Control-modified keys is fairly standard. I am not sure if there is any kind of standard that controls what a terminal will send when you hold Control+A while also typing Control+N. The ones I tried are all consistent though: once I press N they all act as if I had released A (if ^A was auto-repeating, it stops; if I continue to hold ^N, then it starts to auto-repeat). If the terminal under which you run tmux works similarly to the ones I tried, then you could use this (in your , or directly in tmux after (your prefix) then :): 

In bash, you can use to get all command completions generated to stdout (so you can use , etc. instead of just paging through the list). You can also add a prefix: 

If you just set this in an interactive shell, you will end up with an empty string for the current window’s name, but oh-my-zsh will stop updating the window before each prompt and command in that shell instance (it needs to be in your to affect all new shell instances). 

If you really want itself to use MacVim, then you can configure it like this (without any external script files): 

Arrange for the intermediate machine to have a copy of the public part of the desired key in a convenient location (e.g. ). From any machine that already has the public part of the key: 

The problem is that MacVim maps M-Right and M-Left (and several other key combinations) in its (i.e. ); this will override any mappings you have made on those key combinations in . If you examine this startup file (i.e. ), you will find that these particular mappings can be inhibited by setting the special variable (to any value) in your . 

You may have accidentally switched keyboard layouts. Check the “Input Sources” tab of the “Language & Text” preference pane of System Preferences (or try searching for “keyboard layout” in System Preferences). You can disable the layouts you do not need. If you enable the menu extra (mark the “Show Input menu in menu bar” checkbox), you can use it to see which keyboard layout is active and activate any of the enabled layouts. 

You could then type your Prefix and C-m in any client attached to any session in any server that has this binding and it will switch the session matching to its window at index 1. 

I suspect that you have initialized your home directory as a Git repository. You should be able to verify this by checking the output of in and (i.e. anywhere you are unexpectedly seeing master in your prompt). The results will likely tell you that Git is using as the GIT_DIR for those other directories. This will be the case for any (transitive) subdirectory of your home directory that is not itself another repository (or under one that is closer than your home directory). The same goes for having the root directory or initialized as a Git repository (the prompt would pickup its status for anything under them that is not its own Git repository (or under such another Git repository)). 

Vim will usually automatically set up its handling of these keys when TERM is -something, but it skips this since TERM is . You can manually configure these keys in your like this: 

It appears that dragging the status line to resize a split is not possible when the Vim option is ; it does work when the value is though. The latter value configures Vim to ask for an extended mouse reporting mode that (among other things) provides better dragging support. This extended mode only works with newer versions of xterm (and other compatible terminal emulators, including tmux), so it is not the default value. You could use something like the following in your to set the option: 

You can use fugitive’s command to replace the contents of a buffer with various alternate versions of the buffer’s file (i.e. this must be done from a file’s buffer, not from the buffer). 

Default OpenSSH just does not do what you want. The ssh program will use any key that is already loaded into the configured agent, but it never adds keys to the agent. The “add to the agent any password protected key used by ssh” behavior is due to Apple’s changes to the version of ssh it bundles with Mac OS X. 

Those options are window options, so you need (or if they have been customized for a particular window). 

1 Technically they are objects in Snow Leopard, which seem to work mostly like proper objects (though there may be some differences from true objects). 

This particular command is only effective if you put it in your , so the above lines should be placed there. The Mac OS X find dialog will still be displayed if you invoke the menu item itself (clicking on it or using ). Redefine the Menu Item An alternate approach is to redefine the menu items themselves. This would be inappropriate if you wanted to bind ⌘F to some different function (since the Edit > Find > Find… menu item would do something other than a search!), but it might be acceptable since you just want to start a different style of search. You can use variations on the command to redefine the menu item to be (more or less) equivalent to typing : 

If you can somehow convince PuTTY to send xterm-style modified arrow key sequences (i.e. for Control+Down Arrow), then tmux will generate the same sequences for its panes when is enabled. 

As Ignacio Vazquez-Abrams commented, this functionality comes from the bash completion feature. The compgen built-in command provides access to the functionality. You can access the command completion like this: 

Vim can be built to run in GUI environments and text-based terminals/consoles. It is fairly widely ported (i.e. it can be compiled and run on many platforms). The vim.org website provides links to download both the source code and pre-compiled versions that support text and/or GUI modes on many of the supported platforms. Vim can be used to automate certain tasks. Since it is primarily a text editor, tasks that consist of mostly making changes to text files are the most natural fit. It has its own scripting language. Vim can also embed one or more other general purpose languages (Lua, Perl, Python, Ruby, and Tcl) for use in “scripting” Vim. I suppose you could accomplish just about any automation task from inside Vim by using one of these languages as a bridge to a more general purpose automation system (COM/WMI on Windows, AppleScript on Mac OS X, shells and command-line tools on Unix-ish systems), but such use is probably not very common. Mac OS X comes with a text-based version of Vim () that can be used in Terminal windows. There are also two up-to-date GUI versions available: the Cocoa-based MacVim on code.google.com and the Carbon-based MacOSXVim on sourceforge.net. The older macvim.org site is apparently abandoned; it only has old versions (circa 2007). In general, Vim works the same way on each platform it supports. However, Vim has many optional features that can only be enabled when it is compiled, so exact compatibility between two “builds” (e.g. for two different platforms) will depend on the features that were enabled for each build. 

The directories listed in the PATH environment variable are searched from first to last (left to right) when running external programs. For your purpose you will want to have before (to the left of) . If your PATH value was constructed like this: 

† The “has in it” test is actually more like “ occurs after the last (or anywhere if there does not occur in the value)”. This means that a value like will not count as (despite the in ). 

It is not clear to me what you are describing. What does “ClrLn” mean? Which delete key are you talking about? In my Xcode 2.5, the ⌦ key (forward delete; on full keyboards, the one in the 2x3 keypad between the main set of keys and the numeric keypad) is bound to the Action Delete Forward (along with Control-D, shown as ^D). If you have somehow assigned the key forward delete to something else, just reassign it to Delete Forward and it will be removed from whatever action it is currently assigned. If you want to preserve the ^D binding, click the plus button that is displayed after double-clicking in the actions's Keys column. To exit key-assignment mode, just click on another line the Action/Keys table. If you are talking about the other delete key (⌫; backwards delete; the one immediately to the right of = on most US keyboards), then that is usually bound to Indent Friendly Delete Backward (in Xcode 2.5). There are several actions that might be your “ClrLn”: Delete to Beginning of Line, Delete to Beginning of Paragraph, Delete to End of Line, Delete to End of Paragraph. In these line means to the next/previous “soft” line break (wrap due to window width), paragraph means to the next/previous “hard” line break (CR/CRLF/LF sequence in the file). None of these are assigned a key in the default Xcode 2.5 configuration. 

The following is an aside regarding the implications of that single line of AppleScript code, it is not germane to the PATH problem. That line of code has another potential error, too (failure to properly quote the string value of into the shell code). The line itself is supposed to add backslashes before every space character in a string. The most likely reason to do this is so that the resulting string can be directly inserted into another bit shell code. The problem is that there are many other characters that need to be escaped in the same way if the shell code is going to work properly given any string. Both of these problems (really they are the same problem) can be easily solved by using the AppleScript's command. The fact that the script is not using is a sign of inexperience which makes me a nervous about what else the script might be doing incorrectly. 

When you use this mapping (Leader is backslash by default, see ), Vim will display the whole jump list without any pauses until it gets to the end (effectively, you will see the last “page” of the output). Note that , and have nothing to do with the backslashes used above; those are line continuations for d files (like ). 

To set the “Color Label” of the currently selected files, you can combine an AppleScript program (or a shell program that uses osascript) with any of the multitude of “launcher” applications (Quicksilver, FastScripts, etc.) that can run AppleScript programs (or shell programs) based on a shortcut key combination. For any of the scripts below, paste them into Script Editor / AppleScript Editor and save them in “script” format (or whatever format your chosen launcher uses). The usual place for such saved scripts would be ~/Library/Scripts/Applications/Finder, but, depending on your launcher, you could use other locations. Here is a simple version that you can hard-code to any one of the labels: 

If you want to use C-k C-j to send a C-k to the inner session (i.e. send a prefix to the tmux running on the other side of the the ssh session), then you probably want to omit the option when binding C-j. 

I do not know of a way to open the context menu for the current selection (which is what I think you really want) but you can “right click” whatever whatever is under the mouse pointer with only the keyboard. Turning Sticky Keys and Mouse Keys on or off Shortcuts for Mouse Keys 

In , after the menu items have been created, some commands are used to establish the default shortcut keys for the menu items and the GUI “actions” they trigger. However, unlike the menu definition commands in the same file, the commands that establish these bindings are not protected from being run multiple times. This means you can use commands in to establish bindings/actions for menu items that do not have default bindings/actions, but that you must use to modify the bindings/actions that are established in . This seems like a mild bug in the MacVim version of . So, the only (currently) valid place for command is in , after the final startup-time sourcing of . And again, some of the menu hierarchies are specific to MacVim, so the commands should be protected with . Placement of The key notation looks like it is valid in most builds of Vim (though it is probably only actually usable on “Mac” builds). So, you should be able to safely map Command keys in your without worrying about causing errors for other builds of Vim. Of course, in MacVim, if you are mapping a key that is usually a menu item shortcut, you will also have to unbind it from the menu item (which means an accompanying command in ). 

If you can stand to manually trigger the adaptation to the new size, then you can simply run the resize command () inside the “inner” pty. It will query the terminal emulator for the appropriate size using escape sequences and then set the pty to the correct dimensions. In your stated scenario, you could do from inside your Vim instance to resize the “inner” pty (which Vim will notice once the command has finished). If you want automatic resizing to work, then you will have to find a version of script that properly propagates pty dimension changes (by handling SIGWINCH and making the proper ioctls). Alternatively, you might be able to replace your invocation with an invocation of the following Expect program: 

You probably have the “flash the screen on alerts” hearing assistance feature turned on. Try searching for “flash screen” in System Preferences (it should be in the Universal Access preference pane, probably under Hearing). 

Assuming all the other machines are in the same broadcast domain as the one to which you have access, pinging the broadcast address will often suffice. It will not find machines that are asleep, nor those configured to not respond to pings, nor those that will respond to pings but not to broadcast pings. 

This will inhibit ten default MacVim mappings (Command and Option for each of Left, Right, Up, Down, and BS). Alternatively, you could just put your mappings in your (where they will override the default MacVim mappings even if you have not inhibited them with ).