It is always a good idea to seperate your business code and your logic code. The business code is the rules for your code. "Do A,B,C give me D, and Save to E" the logic code is the nitty gritty details of how to do A-E. Everyone calls it something different but the concept is always the same. Keep the two as seperate as possible it makes changing your code easier. Those are my tips. Other than that I don't see any problems with your code other than you don't have a way to escape the loop other than guessing the correct number. 

The code appears to be in good order. It is easy to read and easy to understand. My only issue (and it is debatable) is having the age part of the constructor. In this context it makes sense, but when i first introduce my self to someone I don't say, "Hi my name is Robert Snyder, I'm 30 years old". Instead I just introduce my self as "Robert" but judging by the context of your code it might be fair to have the age (such as in the case of the entrance to a liquor store, they want your id which has your name and age) 

(Note that you'll want to rename that method and class, but for now the content is what is important). You'll now have 2 compile errors. First is in GameGraphics it doesn't know about a variable named , and in it will complain that does not have a method that takes in a . Simple fix. Add a called pos in DrawBoard. Now you'll see that UnitTest1 complains that DrawBoard does not return a string. again Easy fix. Here is what I have now: 

I like this concept that you make it easy to get a count of either gender... but a string??? what would happen if you asked for or any other combination? What if the file itself is not standardized. This would have been much better as an Enum. then you can parse the file and know that you have a type safe version of it to group by. 

On all of your methods you test for a condition () do your business then get out. The problem with this is that I have read all the logic to find out that if it was empty you want to throw an exception. instead reduce the nesting of your methods and throw the exceptions up top or return a default answer. Then you can proceed with your normal flow. To me this just reads a lot easier 

ok, so now in roughly 0.015 seconds I can see if any changes I make to IntegerCalculator broke my logic. I also know exactly how to use it and can refer to my tests as a form of documentation. Ok, If you pasted that above test in, then you'll know that IntegerCalculator does not exist. Here it is (well, most of it) IntegerCalculator.java 

I don't know enough about ASP to know if i can further pull out the boolean in those, but as it sits right here it is easy enough to read this. The moral of all this is to stay consistent (which you did) but reduce as much duplication as you can without sacrificing readability. Thinking about it now I should have just passed in the required value from result instead of passing in result since it doesn't make sense in that context. So in the end I would end up with this. 

No. Never. Only in the higher levels do you want that to happen. This forces the user to use child classes. If your child classes are "dangerous" then people will either make their own, or not use yours. 

in this you count the line numbers. It isn't part of the requirements to know this, and you don't use it anywhere...so why? You also used to get a but you are really only concerned with each line in the file. so using the feature of Java 8 you could simplify reading the file and adding to your list like so 

There are three things I'm up in the air about. One is getting the Subscription by its primary key. I feel like I should pass in the POCO, then find by the primary key (I tried passing in the Dto in the find method but it said it needed a scaler object). The other is setting the initializer in the DataContext. I just don't know where to put it, and I need it because Entity was throwing an exception saying it couldn't change the table or something because I changed my Dto. Lastly I'm thinking I'm going to remove the Id because in the UI its not used, and in the Find method it isn't used. The UI relies on the name of the subscription so in my opinion 3 strikes and you are out. Thoughts? 

Industry standard rarely would restrict you to sending and receiving only primitive data. There are a few reasons for it, but mostly its so that the code can be read easier, and meaning can be associated with numbers. In your example instead of passing in a multi-dimensional array (which gives little in the way of meaning to numbers) you would instead pass in a collection of some class. It equates to the same in the end, but sure is easier to read. I know you said that it was part of the requirements, but I couldn't help but speak up to this. On to your code: I am not a big fan of having a class with only public static methods. There are reasons for it, but in general it's not good practice. I've been seeing more and more people starting to prefer constructor parameters for a class. The idea is that you give the class everything it requires to start work, then call a method to perform said calculation. How you get the calculation depends you could either return the value, or have the method set a field in your class that has a public getter. Here is basically what I'm saying in code Option one 

This is the sorta stuff that very desperatly needs to be in block and not anywhere else. So a quick rule change to and a getter added to degrees and we are set. Block and the changes to now look like 

Vertex.java having a list of neighbors and their colors (as a parallel list) is 2 parts wrong. 1 reason it is wrong is a parallel list. in other words you an array that depends on a very specific order. Should that order get disturbed some problems can arise. Usually you will want to encapsulate those values in another class and make a single list of those. the second part of why it is wrong is that I believe Vertex should simply be a data structure and nothing more. I can see your reasoning behind it but neighbor doesn't describe well enough that your line segment is a specific color. (Took me a little bit to figure that out) So to fix points one and two I believe if you make a LineSegment class that has 2 vertices and a single color your code will clean up nicely. Then you would just change Cube to have a list of LineSegments and update those when you rotate. Tests I'm a huge advocate of writing tests. First they act as a form of documentation, then also give you a safety net to change things around with less fear of breaking something. A good thing that should have tests around it is the rotate method for SceneObject. So for instance 

Really it comes down to it is a bad idea to manipulate/depend on another classes properties. As is the case here It would be better to have change it to something like Keyboard.cs this class can be a little tricky. But with the principle as before we want to make sure that we don't depend on another classes variables. Granted it may not feel like a variable in this case because you are calling GetKeyboardState from NativeMethods. (side note: I personally would move GetKeyboardState to Keyboard, and mark it as private, but there is nothing wrong with the way you have it now) Now making Keyboard a static class might not be the best idea here. In your GameForm you expressly ask for which keys are down. This might benefit from a queue working in the background and firing an event. Some pseudo code: 

Those tests all pass with your current code. However, because I have tests I can now easily change your code (fyi it took about 5ms to run all 3 of those tests) And here is a portion of the resulting new code. Granted it's not that much different... but it is testable. 

well this is nice. This bit of logic runs in 29ms and tells me that I did not make a mistake with my logic. I'll show you how I did it. 

Typical Conventions Parameters to methods and local variables have a lower case first letter. Methods normally have all words spelled out completly. (specially calling out ). S - Single Responsibility Principle With the very focused view point of the definition your classes adhear to the principle. Is it executed properly? No. for instance. The name suggests it is a collection of attributes pertaining to a database. I suppose things like size, file, database type, version would match that type of qualification. Instead you have two properties that are validating the connection string and command string. Having a single validation class could arguably violate SRP, but maybe with some rewording and architecting maybe it coudl change to and could be used kind of like On the point of that class I think reversing your test logic woudl be in order. example: 

Instead of typing in those values that he speaks of a the console window you can write a test to assume certain things. 

I would have made an event of type (or possibly decimal if i needed more precise calculations) that returns the result of a calculation. With this simple test in place I can see that I have a bug in the code as was suggested with Jakob, and I will also know very quickly when the bug gets fixed because this test will pass. (it takes on my machine including build time) about 500ms to run the above code. after it is built, though, I can run that test in less then 1ms. I have mixed feelings about the enum being declared in Calculator. On one hand it does read nicely... (With the minor exception of I would prefer to make it plural Functions instead)... On the other hand it is nested. A nice compromise maybe would be to extract it to its own file with the name The XAML of your code looks nice. There could be some minor tweaking to it to make it easier to scale to different resolutions and screen sizes, but this does look ok. 

I've never been too good at threading, but I do need this as a thread (I think I do atleast I am open to other ideas). So how should I really Enable and Disable? I used to just set run to true or false, but my monkey testing showed that this doesn't always work and sometimes Windows would cry that it can't start a running thread... SO I dunno what to do. Any thoughts? 

Good Names A hard task, but a worthwhile one, is giving names to everything. The hard part is that the names need to show what the purpose of it being there is. When we look at the properties of those are all good names. They explictly describe what each thing is. But the name and are not so nice. has me to believe that this is going to represent different a single Category of a movie. When I compare that thought with the Properties in my perception of it changes. I no longer think of it as a I think of it as . I recommend that you rethink the name of those two classes as they don't represent what they really are. Single Responsibility Principle This principle states that an object should be responsible for one thing, and one thing only. You can search for it and you'll find a never ending supply of articles, papers, and videos on it. I find the reason for so much information is because of the lack of people who use it. It is common for new programmers to break this principle. Lets consider a good example: (or what i'd rather call ) It shows some basic statistics of a list of Files. It does a good job of this, and the code is easily testable. Lets look at a not so good example: . Usually I'll find anything to break the SRP. Your main window does so many things I can't even keep it all straight, yet there are some very obvious things that could be pulled into another class that ONLY does that one thing. I'll point out the most obvious one the section. You conveniantly told me in your code that was doing too much by your Regions. When I look at the methods inside the section I can see that all of those can be moved out into a new class somewhat easily. Moving code out of one class into another is called encapsulation, and is a way of fixing violations of the SRP. I'll do a very easy one for you here. 

My turn: typeo in your class name <- you were missing the 'r' in Strategy. I also see that you are hung up on having a pricing strategy for every product. And although you could do this it doesn't make much sense in the market world. The old adage "Everything has a price" comes into play on this one. From a cash registers standpoint all SKUs have a price. That should be part of your struct. However, even struct is a poor choice IMO. Struct should be able to describe a value in the end. Instead a SKU and a price is closer to key value pair. What's more, and I'm sure all store owners would agree, I wouldn't want to be able to enter in a product into my database without giving it a price, yet by default you can, and you do as is shown in your test with Next up is that I feel with your improved idea about how to create strategies is still wrong. Why would you create a set price for items then attach a sku to each of those prices. It is like you are switching your key and your value around. Now your entire system is indexed off of the price instead of the Sku. TestCaseData. I know you are using MSTest, but you've preached about using that ability from NUnit a few times. Not using it with the way you wrote your tests was like holding one hand behind your back while coding. Why? Even if MSTest doesn't support it you can write you test in such a way that at least gets rid of the duplicate code. (just saw another typo .. should be ) So you could delete all your other methods and replace it with just this one. And if you wanted your error code to be more specific you could change the assert part to check for a "error string" 

You may notice that i took out the check for more than 0 files in the directory. Foreach does that for me because if the list is empty it just skips the foreach statement. 

well in part it helps, but you need to keep taking it a bit further. Think of it as a building blocks. Button_Click is the top most level and should be readable like a book. have the method state its intent. maybe this might have been a better idea