When I was thinking in the optimal way of getting components belonging to a specific entity I encounter the following main concern: Speed: constant time vs lookup. Now, this is game programming, if you game does not perform fast you have to address that somehow. My first attempt was to store components in a dictionary, the dictionary ordered components by type id, the type id was a 64 bit unsigned integer and it was obtained for each component by calculating hash of its class name string. The problem is that the getComponent method of the Entity class involved a look up, probably binary search, but still not optimal when comparing to constant time. Then to achieve constant time access to components, I did as Richard Lord suggests in his blog post about entity systems, I created nodes inside systems that permit access to components through static typing, no lookup. With this method I only called the getComponent method of the Entity when adding each entity to systems, to check if required component were there, and if they were then I created the node. The node is an structure/class made of pointers to components. I only did this for critical systems such as collision detection or rendering, not for AI for example, because AI may accept multiple components sets, and take different code paths depending of presence or state of components, so AI still used getComponent a lot. Later, I found this and this. Good optimizations, because if you can access components fast and in constant time, you don't need nodes at all. With the corresponding speed and memory benefits. Actually what I do is to store components in a vector. Each component has an unique index, not a type id like before. The assignation of index values for each type is sequential. I won't enter in details on how I achieved this, for now you can go with an enum (similar to what you are already doing). I have two versions of getComponent function, one check for inexistent components (used by systems that can act in a variety of entities even if not all have the same component set, like AI), the other, the fast one, allow memory violation if you try to access an inexistent component. System that access components this way, have an interface to get notified when an entity changes its component set (removal or addition of components) and then recheck the entity and if it has no more the required components by that system the entity get removed from the system, but these systems never check for components during game loop, because that would make them run slow. With my suggestion of use a vector and not a dictionary, you may run in cases where an entity only has lets say the Position component that has an index value of 0, and the CharacterStatus component that has and index value of 64 (actually less but let use a high number to illustrate this situation), as we are using a vector to store components ordered by index, then this mean that you end with a vector with 65 items, and item 1 to 63 are null pointers. To minimize this impact you will try to assign high index values to less used components. I have do some calculation (considering only the size of the entities internal vector) of the memory cost of the worst of cases (this is when you have all entities containing the last component, the one with the higher index value) and the number of entities that I can create is still in the tens of thousands and estimated memory used by entities is still acceptable comparing to the benefit of accessing components in constant time. You have to get rid of the dictionary because access to its items involves a look up. You have to make retrieval of components constant time, or use nodes as Richard Lord shows in his post. Note: I'm using C++, not C#, but all I have said is language agnostic. For example, I used std::map as dictionary in my first attempt. But you get the idea. In C# you can use List from System.Collections.Generic instead of std::vector, it will allow you to access components references in constant time. Finally: The first link from entity systems wiki suggests to store components in vectors, one for each component type. I think that this is not friendly to C#, because this 

You can have play calls everywhere but probably you will only need them during collision response, or, in some cases, during input handling. For other things not audio related. The idea of messaging and event handling was already proposed by another answer. To give an alternative, you can translate the concept of the play method to code that should run like tasks, for example: 

I have to calculate the level rectangle because I'm using a raw format to represent the level but you can use end of line characters (\n) to know where a line ends and avoid these calculations. Meaning of characters: x: enemies. Starts tile aligned, due to restriction of level format, but can move to any pixel latter during game. a: tile type 1. Actually blue boxes. b: tile type 2. Actually green boxes. Both a and b don't allow the player sprite to pass. Certain type of tiles are passable and certain ones are not. Your engine must know what ones are passable. The idea begin this is not to code a level editor if formats to represent level already exists. 

Brief: most of the time you cannot have a single design step followed of a single coding step. You will have to alternate them. As a general rule, try to respect what is already designed (not what is already coded). About not having an initial design (just a sketch or a mental image): if you do not have a design you do not have a design. You must do something to come with one. But as long as you start to build one, try to respect it, do not come with a new one every time. 

How can you represent the Canvas pixels? If using a DirectDraw Surface, or its equivalent in other APIs, you will use the DirectDraw functions to create the surface, and to present them to visible portion of the screen. You will have to pin some tabs in your web browsers containing the DirectDraw documentation. You can create the surface in the Canvas constructor or pass a pointer to a surface in one of the Canvas constructors. Some functionality, like drawing lines, you will have to implement yourself. Usually, this involves to lock on the surface, then access the pixels to apply your line drawing algorithm of choice, then unlock the surface. If using a pixel buffer in RAM, for a software renderer, just create a char array in the canvas constructor or pass a pointer to an already created one. Tip: as many APIs out there do, do not use multidimensional arrays, it is better to use a single dimensional array where all pixels are contiguous in memory, maybe with padding at the end of each scanline. If you want the commodity of a multidimensional array, you can add, to your Canvas interface, a function like this: 

When stream is true, the file should be big and you want it to be read in chunks and not all at once, or another option is to let the method decide it by examining the file size, and not having a stream parameter at all. Number of buffers are probably limited like in OpenAL, when streaming the code that checks if new buffers can be queued and read, and probably decodes to PCM, a new chunk of the file to a buffer, can be part of the main loop, something like SoundService.update() at the end of the main loop, or it can reside in a separate thread. Having a thread per audio resource playing is chaotic, better to have a single thread for all audio streaming. For example, during collision detection and response you will do something like this: 

(formula edited to make it more readable) I have to do some extra calculations because of the left, top, system. I hope this does not make it to look more complicated than it really is. What to do when colliding to another thing than a platform? Be creative. You can divide the penetration vector by 2 and displace both sprites but in opposite directions. Or simply destroy the player. Or think in something more complex. Articles for "friction" in games exists. Notes: To return absolute values in C++ use fabs() function. In javascript use Math.abs(). Other languages have their owns. I think that you don't need a vector library for this, as only basic operations were used. Depending how you iterate through objects in your scene, the player sprite will not always be at the left (currentSpr in the examples) and the platforms may not always be at the right (otherSpr) in the calculations, beware of not applying the penetration vector to a platform by mistake. Original answer: Save the previous position of the sprite before move to the next position is what I'm doing for my game and I see no shame on that. I like the solution. Now that you have previous position and current position, the vector giving you the direction of movement when colliding with other non movable objects (platforms, walls) has its tail in current position, and its head in previous position. The question that remains to be answered is how much the colliding object should retreat. You don't want it to move back to previous position in all cases, specially when the speed of a given movement is too high. You probably want the object to remain in contact to the platform without trespassing its borders. The SAT (Separating Axis Theorem) is what I would use in this case: 1 - Find penetration vector using SAT 2 - Move the penetrating sprite back by apply the penetration vector Please, see this: $URL$ For this specific problem read sections, 0, 1 and 2. Separating Axis Theorem for AABBs is what you need for this specific case. Note the case where two character sprites collide is another story. You can use SAT too for detect penetration vector, but you probably want some kind of physics acting in both sprites, and alter the position of both. Depending on the game, maybe destroy the player sprite is enough, in this case no penetration vector needed. 

I have only done minor experiments with Android so this answer will be platform agnostic. Ignore it if you want an Android specific solution. For specific case of the "Get ready" screen my laziest and favorite way is to load an image into the game window and outside the game main loop. Enter the resources loading code, the image will remain visible as nothing is refreshing the graphics. When resource loading finished and entering the main loop, the typical renderGraphics() call, or whatever you named it, at the end of the loop will get rid of the "Get ready" image during its first execution, as you probably are clearing all pixels to black before draw anything each frame. For sounds, the audio api calls probably do not block while playing. OpenSL? Your game only needs to be fast enough when queuing buffers to avoid artifacts. Then you only need a class with a play method that let you specify the sound to play by resource name or file name. Something like: 

What is Spiral of Death? Well, when you do thing like this: thisFrame = now - lastFrame; What happen when the player pauses the game for a lot of time and when resuming the delta between now and lastFrame is a really big number? because the game was not updating (consuming that time) for a lot of time and it accumulates. The result is that your while (thisFrame >= desiredTimeStep) will run hundreds or even thousands of iterations until thisFrame is less than desiredTimeStep (lees than 0. in your original code). This can cause all types of undesired effects, like an enemy that was far away come and kill the player without the player can do anything about it because the game is running hundreds of updates before render, and the player don't get and updated view of what is happening. Tip: you can implement this protection as a simple if statement. After calculation of thisFrame and before entering the inner while loop, check if thisFrame is more than your maximum allowed frame time, and if greater cap it to you maximum allowed. The reason to tell you to rename your maxFrameTime constant to desiredTimeStep is that maxFrameTime is a name more intuitive to implement protection again spiral of death, while desiredTimeStep is a more intuitive name to refer to the expected step between frames. Note that the maximum allowed frame time must be various times greater than desiredTimeStep, to allow resync when the game lagged for some reason but preventing hundreds of iterations of the inner loop. I'm happy with 250000000 nanoseconds. Note: pause by player may not be the better example of when spiral of death can occur, because your game may be stopping only the inner loop when paused and not the outer loop, allowing the thisFrame to continue being calculated even when paused. So you avoid spiral of death that way, but it still can occur if your game lag for some reason (you opened a heavy program while game still running in a machine that can run your game smoothly only if no other applications are running at the same time). If you want to improve your main loop even more, please, read this: $URL$