I'm confident that some of these techniques could be significantly faster than using the actual 3d modeling tools, at least to start off. Anyone have some killer ideas on how to utilize a 3d scanner to create assets? 

Once upon a time I was quite passionate about game development. About four years ago at the height of my game development aspirations, I was involved in a number of activities. I worked with a team of students at my college to build a game using XNA. I wrote a basic cross platform 3d engine using OpenGL/GLUT, and I wrote a simple tank game for Android using OpenGL ES 2.0. For better or worse, since that time I've been swept up in the winds of corporate profit, and for the past few years I've been mostly preoccupied with building corporate applications and websites and I've done very well by it. Even so, I've been trying to build games on the side, and one of the major limiting factors has always been the acquisition of quality resources (models, textures, sprites, audio) to support the game itself. Basically what I am trying to say is that given an individual whose greatest strength is the programming, and is mediocre at best at developing graphical and media assets, what do you think some techniques I could use in conjunction with a 3d scanner to help me produce realistic or at least decent 3d models and/or 2d renders of scanned objects? The catalyst for this thread is that I recently came across a kickstarter for a relatively affordable high quality scanner called 'Robocular'. Aside from being excited about the project as a huge nerd, I am quite frankly intrigued by the possibilities introduced by having the ability to cheaply manipulate a medium and subsequently scan it as a model. Although a device like this seems most suited to scanning terrain assets, I can't help but wonder whether it may be feasible to utilize multiple scanner runs to produce model animations, or perhaps scan individual body parts and cobble them together, applying animations later by manipulating the pieces in Blender. Or perhaps simply using a physical object as the initial base for the model manipulation. Either way it seems way to potentially save a huge amount of time compared to how long it would have taken me to produce a model myself. I know there are a lot of free or affordable resource packs online, but one problem I've always had with them is that they don't necessarily combine with each other well. I.E. That cheap pack of humanoid models just doesn't quite work with the vehicle pack I purchased, or the free weapon pack I found, etc. It's often the case that the art style or level of detail from one pack to another just doesn't match up... But like I said I haven't been very active in the game dev scene for a while, so I'm not sure if a 3d scanner is necessarily going to provide as much of a shortcut as simply purchasing model packs... It's just that the concept is so cool and open ended that it's difficult not to be excited about it. Basically I was hoping to spark a discussion on the practical applications of such a tool. Given the high precision of the scanner and the fact that it supports color, it seems like you could do a lot with it. Some of the initial ideas I had are: 

I think that's the correct syntax (been away from DirectX for a while, gradually easing myself back into it :P), but the concept is to ensure that it doesn't read the information before you've written the new information to it. That also might be causing your issue. I also don't believe that you need to tell the shader the offsets of the elements within the buffer, that should be figured out when you bring in your shader for compilation. Other than that I don't see any issues that could be causing your problem. But then, I'm currently an "untrained eye", so to speak, so if you still can't get it to work, then try looking at the tutorials from this guy's website, they seem to be fairly good, and provide a good starting ground to build off of (I find once I have a working concept down, building on top of it is much easier, and enjoyable). Hope this helps! :) 

Why have you defined your cbuffer as reading in from register ? That might be a potential cause of your problem (the device context is writing to a different register than the one your buffer is reading in from). Also, before writing to your buffer, you should use the function, as you need to prevent the GPU reading from it before you are ready to pass it. Try the following: Instead of this: 

Firstly, "best" is a rather subjective term, personally, I enjoy working with the Source engine (at least, the client and server which plug in to the base source engine, and determine your game play), making a MOD with a recent industry-standard engine is probably the closest you'll get to working within the confines of a restricted codebase in the industry. Others swear by the Quake engine for it's open-source qualities, and other's prefer various other engines. If you are looking for industry experience, then I would say that it would be extremely advisable to develop your own engine, to get an idea of the scale of development that goes into producing a marketable industry-quality game. You will learn how to handle graphics development, AI development, handling performance and optimization of your code, understanding what goes into making a game cross-platform, and hopefully, have an enjoyable time. If you do decide to go down this route, I would recommend OpenGL for it's cross-platform ability, however, most games are written for Windows, so DirectX with an OpenGL fallback is also a possibility (this also allows you to learn about dynamic linking of DLLs etc.) Although you may only be interested primarily in one field (AI Programming, Weapons programming, Physics programming etc.), building your own game-engine demonstrates to a potential employer that you are, firstly, passionate about game programming and dedicated enough to do something about it, and secondly, have a well-rounded understanding of game development, which is extremely desirable especially for a senior programmer). Personally, other than the Source engine, I've never used another's engine for an FPS, however, I have heard good things about the cafu engine, which is supposed to be cross-platform and relatively recent (and with good access to it's rendering process etc.) I hope this helps you to make a decision, and good luck with your future career in the gaming industry! :) EDIT: With regards to your edited question, I believe OGRE has a lot of commercial support, and has a regularly updated code-base (and fulfills all of your other criterion). However, I would still recommend writing your own engine, for the reasons highlighted above. :) 

It is important that I iterate, moving one edge at a time, because I will be doing some collision tests after moving each edge. Here is what I tried so far (simplified for clarity), which fails triumphantly: 

This makes my polygon start slowly rotating and sliding to the left, instead of what I need. Finally, the example shows a square, but the polygons in question could be anything. They will always be convex, and always with vertices in clockwise order. 

So, the top edge would be . I need to stretch this polygon by moving each edge away from the center of the polygon by one unit, along that edge's normal. The following example shows the first edge, the top, moved one unit up: 

The circle is the player, the black square is an obstacle, and the grey polygons with red borders are walk-able areas that will be used as a navigation mesh for enemies. Obstacles and grey polygons are always convex. The grey regions were defined using an algorithm when the world was generated at runtime. Notice the little white column. I need to figure out where any empty space like this is, if at all, after the algorithm builds the grey regions, so that I can fill the space with another region. Basically what I'm hoping for is an algorithm that can detect empty space next to a polygon. 

So I've grasped how to use A* for path-finding, and I am able to use it on a grid. However, my game world is huge and I have many enemies moving toward the player, which is a moving target, so a grid system is too slow for path-finding. I need to simplify my node graph by using a navigational mesh. I grasp the concept of "how" a mesh works (finding a path through nodes on the vertices and/or the centers of the edges of polygons). My game uses dynamic obstacles that are procedurally generated at run-time. I can't quite wrap my head around how to take a plane that has multiple obstacles in it and programatically divide the walkable area up into polygons for the navigation mesh, like the following image. 

Let's say I have a polygon class that is represented by a list of vector classes as vertices, like so: 

Where do I start? How do I know when a segment of walk-able area is already defined, or worse, when I realize I need to subdivide a previously defined walk-able area as the algorithm "walks" through the map? I'm using javascript in nodejs, if it matters. 

I'm making a game with nodejs in which many enemies must converge on the player as the player moves around a relatively open space (right now it is an open field with few obstacles, but eventually there may be some small buildings in the field with 1 or 2 rooms). It's a multiplayer game using websockets, so the server needs to keep track of enemies and players. I found this javascript A* library which I've modified to be used on the server as a nodejs module. The library utilizes a Binary Heap to track the nodes for the algorithm, so it should be pretty fast (and indeed, with a small grid, say 100x100 it is lightning fast). The problem is that my game is not really tile-based. As the player moves around the map, he is moving on a more or less 1-to-1 per-pixel coordinate system (the player can move in 8 directions, 1 or 2 pixels at a time). In preliminary tests, on an 800x600 field, the path-finding can take anywhere from 400 to 1000 ms. Multiply that by 10 enemies and the game starts to get pretty choppy. I have already set it up so that each enemy will only do a path-finding call once per second or even as slow as once every 2 seconds (they have to keep updating their path because the players can move freely). But even with this long interval, there are noticeable lag spikes or chops every couple of seconds as the enemies update their paths. I'm willing to approach the problem of path-finding differently, if there's another option. I'm assuming that the real problem is the enormous grid (800x600). It also occurs to me that maybe the large arrays are to blame, as I've read that V8 has trouble with large arrays.