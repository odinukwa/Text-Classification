You could confirm this by logging the value of somewhere, but I think it is probably not what you think it is. 

To summarize, the first case is not a possibility. Again, without explaining all the details that provide definitive evidence of why, I'll give you a simple real world scenario as a clue instead. Let's pretend that device #1 exists in a small, portable, inexpensive, easily available form (akin to the Raspberry Pi), and that there were some simple means by way of which such devices could either intentionally or (what would be much worse) simple user error, disable a wifi/local area network. Major news networks eat this stuff up: "TEENAGERS CRIPPLING SMALL SCALE WIFI HOTSPOTS CITY WIDE, USING TINY COMPUTERS IN BACKPACKS!! ", etc. Note at this point that your average cellphone today has considerably more processing power than most raspberry pis (the Pi 3 might give some current lower end models a competition) and would be much more suited to this role, and, with regard to ethernet, any laptop or netbook built in the last half decade would have at least the same level of advantage going that route (and wifi). Yet, despite that fact that your average populuous-western-world urban coffee shop, many many of which offer free wifi, probably contain more such devices than people, our friends in news broadcasting and other forms of journalism have yet to get their hands on such an exciting story! "But," you say, "those places have much different and more powerful equipment than I do at home". This is probably at best marginally true in many cases, but it does bring us to a much more likely explanation for your problem: your router. Why it would choose to do this just because of the pi, who can say, but it is obviously not supposed to do that (but almost certainly is anyway). If you do end up talking to your ISP about this, BTW, and the first flunkey you talk to tries to claim, "just don't use that device, we don't support everything," ask to talk to someone else until you get to someone who actually went to school because anyone who did understands what I've just explained. Considering at most three stories here in three years here that I can remember, this could all just be pure coincidence. That, "I can't find any other explanation" does not make it true, just like the fact that most people could not find the earth being flat an explanation for why the sky was up made that true. 

The you can remove once you are sure this works -- it will just help to confirm at boot this is being used. is whatever argument list is passed to the script. Call that script (no at the end) and put it in one of the first directories from (hopefully is first so you can just use that). Make sure to: 

to use all defined aliases in non-interactive shells. Doing that in general is probably not desirable, so one idea is to put all this together in a script: 

Either you misread the comment or the comment was miswritten. Current versions of Raspbian are armhf and have been for some time. There is also some potential confusion here because Debian and other major GNU/Linux distros use to refer to ARMv7+ versions, which will only work on the Pi 2/3, whereas Raspbian uses to refer to itself, which is compatible with some (probably, most existing) ARMv6 systems including all models of Pi, but not those without hardware floating point support (which all models of Pi have) The "hf" is for hard-float and refers to the fact that the binaries have been compiled for an arm architecture with hardware support for floating-point arithmetic, something you probably know is fundamental to a lot of software. Non-hf would mean the kernel and native runtime library do software operations instead (needed on hardware which doesn't provide such support). This is obviously not good for performance. As mentioned, there is more than one flavour of "arm". The A/B/+/0 pis are ARMv6 (more specifically, the "ARM1176JZ(F)-S" implementation, which includes hard-float capability); the 2 is ARMv7. ARMv7 is backward compatible with ARMv6 and therefore the same Raspbian userland can be used -- the only thing they changed for the 2 is the kernel. However, stuff compiled for ARMv6 will not include the improvements available in ARMv7, and therefore it may in theory not perform as well (although I have not seen any evidence of this, and my own experience running an ARMv7 distro on the Pi 2 leads me to believe the difference in practice is not significant). There are now various ARMv7 distros which target the Pi 2 and 3 specifically. The more recent Pi 3 is 64-bit ARMv8, but since this is again backward compatible the same old Raspbian works again. In this case, the same ARMv7 kernel as used on the Pi 2 is also viable, so there is no Pi 3 kernel; some hardware configuration difference are taken care of with a separate device tree overlay. 

ARM processors are mostly 32-bit, including the one in the pi. However, the major issue will be that the driver must be built from source; distributing 32 and 64 bit versions implies these are pre-compiled for x86. The .zip I checked does contain source and a makefile, so if you install the kernel source, you might be able to compile it on the pi. 

Because you are trying to use redirection there (), which is something that works via a shell (e.g., in a script or on the command line), but this is not something that is executed by a shell. To explain a bit: What that actually does is execute with two arguments, and , but those are not valid arguments to so it will fail, and any error it reports discarded. When you execute a command line like that normally via a shell, the shell parses it first, and it interprets the redirection and pipes the output of (with no arguments). But again: The command is not executed via a shell; as per this it is parsed as "the program name and following arguments...separated by spaces. Single quotes can be used to specify arguments with spaces." This means if you want to write to a file, you can't rely on a shell to do the redirection for you. Unless you use a shell wrapper -- so what you should try instead is to put that in a script with an appropriate shebang: 

If didn't exist, or these are substantially different, you need to build the kernel (again). Run if you have not yet, then: 

Either you do that by creating a wifi hotspot on your phone and connect to it with the Pi, or vice versa, create a hotspot on the Pi and connect to it with the phone. The latter is commonly done with . It will much harder than doing it with the phone, but potentially more flexible depending on the context of use. There are packages available for Raspbian (see ) and most other GNU/Linux distros. 

It should be mostly fine; instead of compiling for ARMv6 you are compiling for ARMv7. With regard to the first few lessons involving the LEDs, on the Pi 2 these are the same as the + models, which is slightly different than the earlier ones which those lessons look to target. I think the only significance that will have is that there are fewer LEDs -- but they're only using one or two, and the ACT light may well have the same control address. If not, it is easy to ask specifically about that here...someone knows. With regard to the graphics lessons, the GPU on all the pi's is the same. In other words, there may be some hex numbers to change and you'll have to find out their proper values, but otherwise it will all be the same. Part of learning stuff like this is learning how to do research effectively. When you need to ask other people for information, particularly if it is relatively esoteric (this is), make sure you include as much in the way of relevant details as you can but no irrelevant ones, that you ask in the right place, etc. Always worth at least a glance through is Eric Raymond's How To Ask Questions The Smart Way (this is not to imply anything about your current question, which is fine). I cannot emphasize enough that you cannot be smart enough when it comes to asking questions as it can make the difference between finding out what you need to know and not. 

As RPi Awesomeness points out, run and then before you do anything. is part of the Debian package management system used on, e.g., raspbian. Unless you are certain of what you want to install, it is usually a good idea to see exactly what is available first. will provide a list matching a string, for example; 

This would replace the . To explain: When the first command finishes (or forks to the background), the next command will execute. This will mean the terminal appears normal, with a bash shell prompt (the default invocation is really the equivalent of , where is ). If your backgrounded script produces output, it should still appear since the output device/tty is still the same. If that's the case though you probably want to look into a way to keeping the node process in the foreground.