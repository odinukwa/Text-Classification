You will need 1) for operation's like aligning your objects to each other, tiling or dragging with mouse in your map editor. It could be enough if you have a truly a game with solely tiles like chess. You will need 2) for all kind of (tile independent) animations, rotational velocities and simple accelerations, collision detection and distance calculations. You might need that one if you are interested to check if your mouse pointer is hoovering over your object etc. Chance is that you need these coordinates too and they should be updated only if necessary to ease some calculations. You will need 3) for when you apply forces for acceleration and/or your object's are able to rotate. Most likely not your cup of tea here. But if you are interested in creating a flexible game engine, keep this option viable. For example, I crated a user interface where a user can set a boundary box by dragging his mouse over an object and set optionally a mass center instead of the standard x/2, y/2. Edit: Truncation does matter and you need to account for this by storing it as a float point precision and update the position accordingly. If you don't do this, there is a good chance that your rectangles' sizes will vary +/- 1 pixel conditional on their position on screen which can look weird. That's why for tile based game's your idea of having topleft corner as standard coordinates is a reasonable choice. 

I don't see the entire game loop and how the positions are updated. But it appears that your player is still in jump mode and x velocity is set to 0 as the previous impulse of -mLinearVelocityX is overridden at some point and the input is not refreshed. As you probably have an algorithm to detect a collision, try something like that: if (contact_with_wall) x_case = 0; else {x_case=-mLinearVelocityX;} 

If you need further optimisation, consider dynamic spatial hashing if you have heterogeneous spatial spaces, e.g. one grid has 30 objects and many others less than 5. Segregate overpopulated grid spaces into a new spatial hash grid. Also, implement a probabilistic line collision detection. Mark the chage in distance between two frames. If distance is increasing, flag as "ignore". Only check again probabilistic collision detection if speed has changed. Set speed vector to 0 and flag as static if object is moving minimalist, e.g. less than abs(0.0001). Don't check, of course, collision between two static objects. Don't update position of static flagged objects. Use an preprocessed tables for squarerot distance calculations or use square distances instead of directly using square roots which can speed up your algorithm by up to 20%. You can do the same for trigonometric calculations. That's all what I could think of. I get good performance of 20000 objects with my implementations. Surely you can squeeze out even more, e.g. line of flight probabilistic collision, update collision detection every 2nd frame for less relevant objects or objects that are not being rendered. 

You should obtain a height terrain similar to the requested red line. You can tweak the line with a deterministic trend within a longer range, ensuring that there is a mountain building up or a dale for some while. 

Ask yourself these questions: Does your player get stuck on contact? Does your player on contact 'jitters' more into the wall and then gets stuck, or does your player get stuck when moving or jumping fast into the wall. If it gets smoothly stuck on contact, you need to improve your guard. Are you absolutely sure that the distance between center of your player and the edge of your foot is ? Try changing your inequality to > and < instead of >= and <=. Or offset your player a little bit more by one pixel or an easy way out, something like (0.51*player.FootRectangle.Width). If your player jitters into the wall, the other thing that I can think of when looking at your code is maybe you got the signs of the direction of the velocity vector mixed up. Check if it jitters into the wall. If yes, check that going left is indeed defined by a negative sign (and going up with a positive) as you otherwise move the player more into the wall. Change swap then + and - accordingly when before . (Btw. the way I do resolve stuck collisions is by storing the last known position before the collision and resetting the scene and implement the collision response if this response does not lead to being stuck again (forward check); otherwise set the velocity to the direction of the offset vector.) 

Store within your object class the top left corner as a vector, e.g. For most tile-independent game logic, use the object's center . For realistic movements and application of force on object's with mass, store the object's mass center . 

I didn't get the entire gist of all the functions you provided, but it seems to me that you are looking for something like a random walk or martingale algorithm, where you have an equal probability of the terrain height step to go up or down in comparison to the terrain one step ago. Doing this, your terrain remains random but essentially smooth and without crazy drops and most likely mean level in the long run.To illustrate, try something like this : 

The x-axis shows an increased complexity by adding more dots (and thus slowing down the loop). (For example, at 1000 randomly appearing point checks in a confided space with 20 rectangles, the loop iterates and calls the algorithm 20000 times.) The y-axis shows the time it take (ms) to complete the entire loop using a high resolution performance timer. More than 20 ms would be problematic for a decent game as it would not take advantage of the high fps to interpolate a smooth animation and the game may appear thus 'rugged' at times. Result 1: A pre-processed circular bound algorithm with a fast negative check within the loop improves the performance by 1900% compared to the regular algorithm (5% of the original loop time without a check). The result holds approximately proportional to the number of iterations within a loop, thus it does not matter if we check 10 or 10000 randomly appearing points. Thus, in this illustration one can increase the number of objects safely to 10k without feeling a performance loss. Result 2: It has been suggested by a previous comment that the algorithm may be faster but memory intensive. However, note that storing a float for the pre-processed circle size takes merely 4 bytes. This should pose no real issue unless the O.P. plans to run simultaneously 100000+ objects. An alternative and memory efficient approach is to calculate the circle maximum size on the stack within the loop and letting it go out of scope with every iteration and thus having practically no memory usage for some unknown price of speed. Indeed, the result shows that this approach is indeed slower than using a pre-processed circle size, but it still shows a considerable performance improvement of around 1150% (i.e. 8% of the original processing time). Result 3: I further improve the result 1 algorithm by using squared distances instead of actual distances and thus taking an computationally expensive square root operation. This only sligthtly boosts the performance (2400%). (Note: I also try hash tables for pre-processed arrays for square roots approximations with a similar but slightly worse result) Result 4: I further check moving/colliding the rectangles around; however, this does not change the basic results (as expected) as the logical check remains essentially the same. Result 5: I vary the number of rectangles and find that the algorithm becomes even more efficient the less crowdy the space is filled (not shown in demo). The result is also somewhat expected, as the probability decreases for a point to appear within tiny space between a circle and the object's boundaries. On the other extreme, I try to increase the number of rectangles too 100 within the same confined tiny space AND vary them dynamically in size at run time at within the loop (sin(iterator)). This still performs extremely well with increase in performance by 570% (or 15% of the original loop time). Result 6: I test alternative algorithms suggested on here and find a very slight but not significant difference in performance (2%). The interesting and more simple IsLeft algorithm performs very well with a boost of performance by 17% (85% of the original calculation time) but nowhere near the efficiency of a quick negative check algorithm. My point is to first consider lean design and game logic, especially when dealing with boundaries and collision events. The OPs current algorithm is already fairly efficient and a further optimization is not as critical as optimizing the underlying concept itself. Moreover, it is good to communicate the scope and purpose of the game, as the efficiency of an algorithm critically depends on them. I suggest to always attempt to benchmark any complex algorithm during the game design stage as merely looking at the plain code may not reveal the truth about actual run-time performance. The suggested algorithm may not be here even necessary, if, for example, one wishes to merely test if the mouse cursor lies within a rectangle or not, or, when the majority of objects are already touching. If the majority of points checks are within the rectangle, the algorithm will be less efficient. (However, then it would be possible to establish an 'inner circle' boundary as a secondary negative check.) Circle/sphere boundary checks are very useful for any decent collision detection of a large number of objects that have naturally some space in between them.