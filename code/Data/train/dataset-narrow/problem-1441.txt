Following the 18.06 Linear algebra course, I was curious to reinvent the matrix class and basic functionality, like \$PA=LU \$ decomposition, Gauss elimination, finding inverse matrix etc. Any comments about the code design, linear algebra and performance are welcome. 

You tried to implement a linear (\$\mathcal{O}(n)\$ time) solution, and this is the correct final aim, but, I think, you agree that the current solution is hard to understand especially without any comments. So let's start from something easy-to-understand and not very efficient. But this will allow us to check a correctness of your solution in a first place. Brute-force solution (\$\mathcal{O}(n^2)\$ time) It is clear that this task is related to the maximum subarray problem except the condition of replacing by . So let's make a loop through all positions of the original array; on every iteration let's replace the current element of the array by and find the largest sum by Kadane's algorithm. 

Better to avoid static not-readonly field I don't see any actual reason for you to keep variables Item1, Item2 and OperationString as private static fields - make them as local variables. In general, based on my experience, many nasty bugs (especially in multi-thread applications) happen because of an inappropriate usage of static fields. I know, this problem is far away from this simple calculator application, but anyway. 

For sure this task can be solved in \$\mathcal{O}(n)\$ time and \$\mathcal{O}(1)\$ additional memory, but extensive testing should be priority number one. 

In the book “Introduction to Linear Algebra”, that comes along with this course, the author highlights several times the advantages of finding L (low-triangle matrix) instead of E (elimination matrix). It becomes pretty clear by inspecting the code. 

First of all, your solution for this task looks pretty elegant, from my point of view. I would just provide minor comments to optimize this code. 

I would suggest to create enumerated list of those errors, return one enum element as output of your function. 

Binomial coefficient \$\binom{n}{k}\$ is growing too fast (with \$n\$) to keep a list of all combinations in memory. I would suggest to use instead. 

BTW: This would be the same (but the conversion is altered) in my own syntax, which you may find a bit familiar: 

Normal Class (not static) Read-only (getters and reaonly collections) Tiny objects if you really need to change the index - create helper class that can access the collections and return the indexed value. 

Usage example That was not part of the code for review, just and imperfect example. The real objects are a bit different. 

Hacky ways vs. BOARD_SIZE It appears that you have board of size 3x3 and never tested with bigger board, because this won't work for bigger board: 

Note: Maybe I did not get it right and BER is not designed for complex packets, but for simple tagged values. In that case, all could be done in constructor. Here you can see I have renamed your class from to , while using some method that would handle possible reallocation. The data is always encoded as big-endian (and packed), independent on the MCU architecture. (Note: Some prefer to use instead of , but the later is allowed within classes, forbidden in global space). The same could be done for reading, possibly creating two other classes: and , but you can have it both embedded in the (or ). The way you have it now, you have to create all the data at once (while handling the big/little endian) and pass to constructor: 

Code Styling Your code is very good at first look. Good structure, code-styling, new features used, clever trics. Functionality and Usability The message is for the user, the code is for you to debug it. Exceptions currently allow adding good message and naming properties won't help a bit (to the user, if it is designed to tell the user: "You did something wrong" like "Wrong Value Format"), but to diagnose problems, you'll need more than property/method name. And for that, you have the stack trace. To state it simple: the problem is not in the exception and what additional info it can carry (it already has the stack-trace), but in the way you present it. This is my own code I use: 

Split complex task on simpler ones - one logic per function Your function ParseInput is doing not just parsing, but also reading from standard input. So split this task - ParseInput will just do parsing. 

Another proposed solution is checking number of on-bits in \$2^{n}\$ numbers. By this, you are limiting your solution on \$n<=32\$ and doing \$2^{n}-\binom{n}{k}\$ checks for nothing. 

Another point, that you are loading whole matrix to the memory. It can be too expensive in certain circumstances. I can suggest one stream-based solution which will calculate a number of islands in dynamic manner. This method was discussed here. 

Be aware of the difference between || and | logic operations And without a need, do no mix up this two operators. So use 

And now you can merge this function with into one if you want. I guess you have read this, but I just want to remind you that all described optimizations are still applicable to your code. 

The main improvement which can be done here - not to use Recursion at all. Solution without recursion 

But I did not expect that the difference was going to be so huge. Just as an example, I implemented the Inverse function through finding matrix E and matrix L, and compare performance by BenchmarkDotNet with square random matrices (N = {5, 10, 20, 30, 40, 50}). 

Do not call variables by reserved names I mean, I was sweating to understand what is going on here the first time 

I would like also highlight an extremely small memory footprint, which was achieved thanks to usage. 

Let user know that calculation was successful or not Let's check which error can happen in your code: 

Your input data is a boolean matrix, so instead of keeping every value as a byte you can use just one bit. For that purpose you can use bitarray module. 

Yes, we are doing additional LowerGaussEliminationBackward, but it does not influence a lot on performance. Even EPA=U decomposition is better to be done through L matrix. This is the current state of the implementation. 

P.S. Not sure, what is the exact structure of the object from which you retrieve data. The assumption is that it looks somewhat similar to this: 

P.S. Notice that the same approach may be applied to . And, speaking more generally, Strategy design pattern is almost always a working alternative to an or . Of course, to get the benefits of the pattern, we need to write some boilerplate code ( + Rule registry), however it's a great trade of for the scenarios where there are a lot of rules, or the rules are frequently added/modified, or the rule selection strategy may change in run time. 

Step 2: applying the Strategy pattern [optional] In your particular case applying the Strategy design pattern would be an overkill. However, if your code had more branching, or had more complex branch selection logic, or had heavier logic in branch(es), or a combination of those, I'd consider using Strategy. This answer may be a good illustration of the pattern application in a situation similar to yours. Update 1 s are just very nasty code smell. They should be avoided when the things start being complicated. There's even a small anti-if movement. P.S. Let me know if you want to see some pseudo-code or more real code for the Step 2. 

First we declare fields to iterate on. Clear validation error indicators set on previous runs. the fields which fail validation. I am not sure what is the '?' that original code relies on, but I think you know better ;) If there list of filtered fields is empty, we know there are no validation errors and can return from here. Otherwise animate to the top of the screen, display UI errors for failed fields, and return false. 

It's better in a way it helps avoiding OBOE. And by the way, another thing you can do is define it as an extension method in a separate static class, and will be able to invoke it as : 

I wish there was a commonly known first-class concept of a Range in JavaScript... Naming Things The only thing that pokes my eyes is variable naming. IMHO, you can do better than , , or . For example, the following is more readable, since real words are being used and the function is more explanatory. 

Which you should try to avoid (if you plan to have good Queue) by using Circular Buffer. Use two indexes - one for writing, one for reading and reset them to zero when they reach which becomes your . Leave one slot empty to never have write_index == read_index for both empty and full queue. You could even enhance it to create Doubly-Ended Queue that you can add/remove to/from both ends. 

Interface Enhancement The is not enough for algorithmization. A way to call some (templated/universal) function (functor) is needed. For now, this was added: 

Beware that the comparision operators need some fine-tuning especially when you compare integral vs. floating-point (which to choose as common type) and that in conversion operator may be problematic (not sure). (Finally imagine , but I use my own header while explicitly using selected std features/classes in the namespace and then using the namespace). 

or you can rename them completely. Look at or for some inspiration, but the there in is considered unlucky choice (violates the common rules about containers). The problem is, that can be used for both return type (where it should be real reference) and as argument (where it should be in this case). proxyT I was at first worried if the code can even compile, having public base class which is private to the container, but it seems to work. Conversion should be fine and you can specialize it (or use SFINAE) if you wish to use for : 

First of all, you should use instead of and please don't use for template parameters ( is mostly for preprocessor, sometimes used for constants and/or static variables), rather use , e.g. . Your implementation looks good to me otherwise, but you know it can only be used with containers with member . If you want to create it from , then it would be something different (e.g. ). You may find some inspiration in . 

Load the value - all the threads will see the same value, e.g. 3 Do the math = decrement - all the threads will calculate 2 Store the value back - 2, but the result should be 0 if three threads were removing their callbacks! 

Your question is a bit too abstract. Both ways are okay in different scenarios. You may even have a mixture of two patterns in the same code base... Sorry, but yes, my answer is "it depends". I think, the key here is the intent and the way it's conveyed via code. If 's behavior is rigid, and "known in advance", you may want to declare it as a (as in first example). This will make sure that even when an instance is created NOT by using it still obeys the same behavior rules. If however, your entity is not rigid and you don't know all its possible usages in advance, it's probably better to start with an and a set of factory functions (as in second example). 

Unfortunately, this is also less functional on its own (notice that the code uses a variable...). Worse than that, you can only 

Functional vs imperative — hopefully not off topic Disclaimer I don't think that Codereview.StackExchange is the right place to ask questions of that sort. The answers may get extremely subjective (and result in a "holy war"). The issue is that there's no universally objective criteria which could be used to justify that functional code is by definition better than imperative ...or vice versa. I prefer functional... Still, I chose the functional code snippet you provided and improved it, rather than the imperative. Here's the reason why, but please take it as an opinion. In my experience, functional code is less buggy, so to speak. Now, I do not have any data to back this statement, and my guess is that the scientific studies on that subject are contradictory. Nevertheless, this is what I feel about it. Reasoning behind "functional is better" Here are a very few functional programming aspects and their possible effects: 

Design decisions and improvements (as in "better approach(es) performance- and memory-wise"). Code readability. JavaScript (ES6) language idioms. Whatever you find important to say that does not fall into three categories mentioned above. 

It is removing first handler (if multiple). Nothing bad about it, just to note that you can think about it. Using remove-erase could change that (removing all of them), I would not change the code in this way if you are fine with removing the first only (which makes sense, or possibly remove last not first). The remove will be taken in to account in next round (when you copy handlers), not immediatelly. That is something that may be a problem. Think about adding to if that is desired behaviour (to cancel-remove it as soon as possible). 

You should pass to your and terminate it, once you reach zero oxigen. Big map with low can cause TLE. You don't need the , you can reuse the array and just mark visited spots (e.g. with '*'). This would be wave algorithm (handle all nodes in the queue at the start of the step, reduce counter and proceed to next step, unless or zero reached). This is simplification of Dijkstra algorithm for graph with all weights=1. Your code is hard to read. You are on Code Review! You are using C++ but program like in old C. Use instead of when possible, avoid super-shortcuts like and , please. 

?? Again and again in the loop? You don't need the . And I would personally use instead of as type of the variable, in constructor, (or some readonly collection) as property type and some during the build phase. 

That looks like you plan to derive from while providing and in the constructor and overriding which should therefore be . Did I get it right? Await Response Unfortunatelly, I am forced to use .NET 3.5 and therefore don't understand / that much (use threads and events instead). I hope that some override in your or casting the result to appropriate type (as the original returns , not or ) will solve the problem with type and later usage: . What I don't like is the active waiting (or it at least seems to be active waiting):