Those paths do not exist as files in the filesystem. They are handled by your web application. But, you are not actually routing them there in . You instead are routing them to a 404 page. 

The line you are referring to allows all traffic on the interface (localhost). It is generally harmless, and removing it can cause problems. The interface columns are only visible after you add to your command. 

You're using Debian 7, and don't have access to LXC user namespaces (which should be available in jessie, and are available in stretch). So, "root" in a container is equivalent to root on the host. Thus when you call you are doing so as root for the whole system. (Containers on such older systems are not secure and cannot be made secure; you should be using a newer version of Debian, or preferably a Red Hat-based system, for any container work that requires even a moderate amount of security.) To kill a container, from outside the container use . 

You've trashed your system beyond repair, and will most likely need to reinstall from scratch. Next time, inspect the list of packages very carefully when using as it very often can and will remove critical system packages. 

The SELinux user is ignored in the default policy. It is fine to leave them as is, unless you plan to use the or policies, or use confined users. As for changing the context of a symbolic link, you need to use the option to so that it changes the context of the symlink, rather than the file to which it points. 

Two of these belong to GitHub, and one belongs to GoDaddy. Because DNS is round-robin, about 2/3 of the time you will go to the right place, and the rest of the time you end up at GoDaddy's parking page. To fix the problem, remove the GoDaddy IP address. 

You can set the type on files you want to be able to write to. You can set the boolean that was suggested. But this may have other side effects. 

So I speculate that something went wrong with the domain transfer, and you need to contact your registrar to have it fixed. 

Your file has a bunch of problems in it. First, isn't specified properly. Second, you're using the old way of aliasing, which doesn't really work anymore, and especially not with VLANs. Third, your route statement also uses the old style. Unfortunately, all of these are actually recommended in Debian's wiki and hundreds of old, outdated tutorials on the Internet. The relevant parts of your file should look something like this: 

By default (on Linux) the second directive binds to both IPv4 and IPv6, unless you explicitly request that it bind only to IPv6 with the option. There are two ways you can resolve this. Choose one (but not both): 

First off, you have run out of memory. Your VPS has 2GB of RAM and 4GB of swap. The 2GB of RAM is all used up, and the swap is maybe 3/4 full. At this point, on any system I manage, there is an alarm that repeats every five minutes until someone acknowledges the problem, it is that serious. So you need to figure out what's using all the memory. Unfortunately this may be difficult. I can see that a single Apache process alone is using nearly 1GB of memory. This is obviously an outlier, since most of the others use less than 22MB each. The reason this is difficult is that Apache lets you embed languages such as Perl or PHP directly into the process, and it is almost certainly such a script that has run away and eaten up all your RAM. All your system can do at this point is thrash in and out of swap (which is exactly what shows it doing) until someone shows it mercy with a well placed . So your next step is to try to figure out what script went haywire and ate all your RAM. 

Use the configuration directives , , and to set the user and group ID you want for newly created directories and files, respectively. 

The specification is needed to work around a bug in the EL5 backport where initcwnd would not be applied in all cases. (The bug is not present in the EL6 backport.) The example given is for WAN links; it should be much smaller (e.g. 100) for a LAN route. 

Time to check your disks.... Since it's a (most likely leased) VPS, you can't really check the server's disks, though. You may have to ask the hosting provider to look into it. 

The name of the process appears in the first column, . We can see from your output that two processes called are listening on this port (one on IPv4, and one on IPv6). And is most likely a Node.js application. 

While you're at it, you should also check to make sure you have the correct IP addresses for the incoming SIP traffic you're expecting. If the upstream provider ever changes them, you're in trouble. 

It's hard to be sure, since you obscured the relevant details, but it appears that one of your providers has two SPF records in their DNS, which is not allowed. You can validate your SPF records with the SPF Parser tool. 

Persistent block storage is handled by cinder, not nova (compute). If you set up cinder with its defaults, then it will use an LVM volume group named to store block device volumes for virtual machines. As a result, it's trivial to add storage space to this volume group; just to create an LVM PV on a physical disk or disk partition, then to extend the VG onto the new PV. For example: 

Looks like someone's abusing Google App Engine. Check your Apache access log for that IP address, and the user agent string should have their app ID. You can then report the abuse to Google. 

Yes, SELinux makes Red Hat (and any other Linux distribution that actually uses it) more secure, assuming it's actually in use. SELinux implements mandatory access control. Normal Unix permissions, ACLs, etc., implement discretionary access control. The two complement each other. In order to work, SELinux requires a policy, defining what actions on the system may be allowed. While it's possible to create an entire system policy from scratch, most Linux distributions ship a policy based on the so-called reference policy. This means, among other things, that configuring SELinux across distributions will be very similar. (Most Linux distributions make the SELinux reference policy available in their package repositories, though it may not be installed by default.) SELinux works by restricting users and processes to perform only the actions allowed to them in the policy. By default, the policy is to deny, so if the policy doesn't explicitly allow an action, then it doesn't happen. This is why you so often run into trouble with SELinux disallowing something you're trying to do. On the bright side, this also prevents exploits, even 0-day exploits, from getting out of hand. For instance, if your web server (Apache) gets exploited, the damage is limited to only those things that Apache can access. It wouldn't be able to read your file, for instance, even with a remote root exploit. While the Unix permissions (DAC) permit root to read the file, SELinux (MAC) does not permit the compromised process to step out of bounds. The big gotcha is that there must be an SELinux policy module loaded for the service. If you install a service on your box which doesn't include an SELinux policy module, then it will run unconfined and be able to do whatever it wants. SELinux won't apply to it. Another thing you should know is all about booleans. These tunable parameters are provided by SELinux policies to customize them for particular installations, and permit or deny access based on local configuration needs. For instance, you can give Apache access to Samba shares, enable Samba to share user home directories, and many other potentially useful things which are necessary for some setups but not others. The best guide to SELinux that I've seen currently is Red Hat's Security-Enhanced Linux User Guide. It will help you get up and running quickly as well as fill in the background details of what's going on. It also includes a comprehensive troubleshooting guide that helps you get your process running under SELinux. Is it useful? SELinux protects against processes (and users, if you've confined your users) doing unexpected things. It severely limits the damage that a remote exploit can do. If you've never suffered a remote compromise, you are (1) fortunate, and (2) probably new. If you have worked a remote compromise, you certainly don't want it to ever happen again. It's not as useful in a home setting, unless you happen to be running Internet-facing services at home (and some people do). In that case, everything said above applies. SELinux may be the last thing that stands between your data and an attacker with a 0-day exploit who really wants it. If you can use it, why wouldn't you?