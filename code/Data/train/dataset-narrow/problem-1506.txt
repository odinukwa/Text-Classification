would need to return 1 for to return . Therefore the last question is unlikely ever to be selected. For equi-probability (well as near as possible) use : 

Timer as a widget Your timer is essentially a widget. As such, it would be more easily invoked by passing in a single container element and having all the internal elements generated on view initialization. Hence, most of the statements would become statements (or their jQuery equivalents). 

Whenever you have repeated blocks of very similar code, you should always seek to merge them into one generalized block. Sometimes this exercise is hard, sometimes simple, depending on the nature of the algorithms/paradigms embodied in the code. Here, without changing the HTML or the CSS, the javascript will simplify to : 

The worst issues are cases of the same element being selected multiple times in order to apply various methods. Repeat selection of the same element should be avoided because selection of DOM element(s) is expensive. There are also are cases where multiple selections have the same method applied. This isn't so bad for performance, but leads to unnecessarily bulky source. The code can be improved with the following techniques : 

ps: I can't just do something like , because I need it to shrink as text is deleted. Also, I don't want to remember the previous count and just calculate the difference, because some changes will inevitably be missed and a differential script will never right itself. 

Zirak's answer is all the advice you need, but since he didn't actually write any code, here's how I might re-write it. 

I am writing a script to count the number of rows in a textarea, and as it will be called on every keypress I want to make sure it runs as fast as possible. I'm not aiming for a general solution: we can assume that the textarea has a monospace font and enough horizontal space for exactly 80 characters. I've probably solved this problem in 20 different ways, and this is by far the fastest solution I've come up with: 

The switch statement might be more legibly written as a series of if else-if statements (with nesting), but that's mostly a stylistic choice. 

Why is slower than ? Is there any way to optimize the regex in so the performance is comparable to the first two? Is there any other way to speed up this code? 

... and in general that is what we would write. However sometimes it's advantageous to start a promise chain with a resolved promise, even if it's not strictly necessary. For example, we might want a chain such as ... 

You should recognize much of your original code but it's been shuffled around - refactored. Refactoring is commonplace. Even very experienced programmers find they need to refactor, and it's is an important part of their skill-set. It's seldom necessary to restart from scratch. 

Automated tests would be fairly simple to code, though it's hard to envisage something flexible enough to handle any set of input elements. It's maybe more realistic to prepare a few sets of test cases, each comprising input HTML (a container full of elements) and an array representing the expected sort order. It would be a fairly minor challenge to run a sort and compare the resulting order of DOM elements with expectation. 

This is a good thing to do anyway as it puts just one member into the namespace. Then, will return an array of keys, which can be looped through : 

is, actually, the worst variable name there is. It is impossible to create a less specific name. I would suggest renaming it. 

If you know every element in is truthy (not 0, null, undefined, false, or ""), you can use this loop, which is shorter and more efficient, and in my opinion more legible. 

The solution you edited into your question can be improved upon (shortened and sped up) by using an object for instead of an array. After all, you're just using it as a lookup now - and an array is one of the worst ways to store a simple lookup. Here's a complete implementation. 

This looks like something you'd want to do server-side, mainly because you can cache the result. So for every request but the first one you're essentially just downloading a file. If you can't do it server-side, here are a few improvements: 

Here's a second solution, which is slightly faster in Firefox, but otherwise between a little and 5x slower: 

It is impossible to know the variable name without passing it separately because the name is not part of the object itself, but only one (of potentially many) signs pointing to that object. Expecting the object to know that variable name is like expecting a building to know which road you drove in on. Besides, specifying the localStorage key separately is a good thing - it allows you to refer to the same key using different names in different parts of the program. You can get around having your methods show up in for-in loops by using getters instead of properties or prototypes. If you're concerned about compatibility, you can fallback to . Here's what I came up with. 

OK, with just 15 minutes of 2015 left to go (GMT) and with some shameless cribbing of ideas from @cFreed's and @Sumurai8's answers ... 

Presumably statamic statements allow you to include/exclude statements within tags. If so, then you can write something like this in the document's : 

Due to the volume of code, I would be inclined not to touch it. Recoding and revalidating would be a lengthy exercise. I wonder if the way ahead might be to enhance the (already good) comments, to provide better guidance to the existing architecture. 

Performance-wise, hard to tell. May not be so bad. Would need to run tests. The worst feature is readability. It's not a standard approach to sorting. 

Macro Observations As written, is a jQuery static method, not a plugin. It seems more appropriate to write it a genuine plugin, and invoke it on DOM element(s) with . You will then need to purge hard-coded selectors and take great care to ensure the independence of multiple invocations. Strict mode will help avoid making certain mistakes. You may get error messages in your console. Try passing the code through jsLint to check for unused/undeclared vars and heaps of other stuff. Meso Observations is "ul li a", therefore will select all ul,li,a elements on the page, not just the ones you are interested in. Try constraining the selection with something like . Probably similar elsewhere for other selections. is an initialisation function and would more conventionally be named . Default tab: Typically with this kind of functionality, you would write initialisation function devoid of code that sets the initial condition. Then, as a final step when all other initialisation is complete, emulate user interaction by triggering a click event to select the default tab. This approach can save much time and many lines of code. Micro Observations should be declared in the main declaration block with a good explanatory comment. 's local variable appears to be unnecessary. At the point where it is tested, it will only ever be , won't it? can be initialised simply as , same as . is rather oddly named given that it is used for jQuery collection object, not a reference. !? Look for unnecessary operations, such as : 

That has the benefit of not creating properties you don't use. Also, did you strip out some code? Because it seems like all you're doing is storing a reference to an object. Why not just use the object? 

The performance doesn't make any sense to me - does the same thing as , except it doesn't create any unnecessary strings or arrays. Is with a start position just really slow, or is there some optimization only the first method is picking up on? Finally, here's one more method, which is much slower in every browser I've tested, but beautifully concise: 

Note that this code is optimized for arrays with at least 1 element; if the majority of its uses are on 0-length arrays, you'd see a performance boost if you added a short return. Alternatively you can use Array.prototype.reduce. I highly recommend that you not use this method - while it is more "unique", it is also much harder to understand and much less efficient. And good code strives to be readable and efficient (and robust), not unique.