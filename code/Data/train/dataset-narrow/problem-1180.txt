Is there a reason why they are in separate methods? The only overlapping part is that in two conditions can be the same as (1 and 3). If this is a mistake, you can place all the code in one method, if the checks are correct and you want to keep both methods, also fine. I'll base my answer on the correctness of your code and keep two methods. 

"Expression = True": You can leave out the part in your if conditions, since the methods return a boolean value. This is what the code now looks like: 

Idon't see why you would want to shorten that piece of code but here's the same result in one line and using a LinQ method-chain instead of query-syntax: 

If this is not the case, ignore this tip. LoadNewDataFromDatabase(): Generally this is not bad, but it can be improved. Naming tips will already be applied without further explanation, this is done in the previous part. Since you already know the loaded data in the method, you should not get all the items from the database and then check which ones you want to add to the main data list. Fetch only the items that are not already in the list. This makes more sense but more important: your SQL-task will be less heavy. 

This gives the same kind of situation like yours. Luckily there's the Func<T, TResult> Delegate. The method can now look like this: 

I don't know if it is for testing purposes but you shouldn't write ouput tot the console in the method itself. 

Get the enumerator Loop over the collection Calculate the difference between the previous and the current item 

First point, small but important: give your method a proper name. doesn't mean much and doesn't tell what it returns. Take a name like or . Secondly, did you test this method properly? I changed the code a bit to be able to test it, I removed the value and just use the parameter as value: 

Summary I'm not saying that my code is perfect in any way. Probably my code could be revised and corrected as well. I only want to show you the way how you decouple user-input from class-definitions, use proper variable names, bring a proper structure and logic in your code. Please feel free if to comment if anything's wrong with my code. Edit: Thanks to the valid comments I received, I edited the code. The posters of the comments were absolutely right. I've also rewritten the Initial()-method to a more correct logic. Here's the result in it's entirety: 

I'm not saying your code is wrong, only saying that you don't need delegates to achieve this. Also this: 

Constructor + overloading: Your constructor contains the values you use for the connectionstring. Don't place these values here as it makes the use of the constructor very limited. Create a separate method that will create the connection and call this method from the constructor. The default values you are using can be placed in a settings file or make them private constant fields: 

Also mentioned is that an entity should not actually containt any logic. Define another class specifically for validation on the properties. You can add validation methods to the class if you want but I'd keep them separated. This way the class can be used in other projects without having to modify them. Here's an example of a class: 

We're not seeing a method and we're not able to get all type information but OK. Your code doesn't look unreadable to me. The only thing I can suggest to clean up is the printing by extracting that part into a method and calling this. This is how the method looks: 

Note: I use the keyword, but you may choose to use instead. Due to the fact that I let my bool-variables begin with is or has, I always know it's a boolean. 

Exception handling for parsing? I don't think secretly throwing/catching exceptions for parsing numeric input is good practice. Use the Double.TryParse method to handle this: 

See how the other names make more sense? Try to avoid verbs as a classname. Methods can and most likely will be or contain verbs, but not classnames. Also, leaving the query out of the class leaves you the option to use the same code for other queries. Note that this is no perfect code, I was only suggesting what might be changed. Hope this helps! :) Edit: You call the function selectData() and pass the query-string as a parameter. This changes nothing, it gives the same result as your code. Only in my case you can pass other queries to the function whereas your function is limited to the embedded query. Now for the result. This has also to do with the decoupling of your connection-class and what will be shown to the user. I showed u the usage of the class, the code below is how you can process the result. Create a function (but not in the connection class!) that returns the result in a table: 

I went looking for a cause and it seems that has problems with nullable types. You have to use the underlying type of the nullable in order to make it work: 

Asking for input Now that we have valiadtion on the input, we need to keep asking the user until the input is correct. We need a loop-mechanism for this: the is very useful here: 

The only possible solution I can come up with, to shorten/simplify your code, is to extract the redundant code and place it in a separate method for example: 

You could create a new class in which you define all sorts of methods like these to process a result and return it to the view-file where you will show it on the screen. Hope this clarifies it. :) 

Haven't actually done any COM-stuff in later .NET versions so I don't know wether this will work for newer versions. Hope this can help. 

Useful property names: I find using names as bad practice. It doesn't give any info on the instance. Give it a useful name you, and others, easily understand. Casing of property names: Don't use PascalCase for local fields, use camelCase instead. Your will become . You had already done this correctly for . Redundant parentheses: Following: 

Since you're using the method, there's no need to throw an exception. You just have to notify the caller whether the conversion succeeded or not. Plus, throwing an exception in a get statement is bad practice. This results in following: 

Whenever you are performing operations that might throw an exception (SQL operations, File handling, Service calls, ...), it's more than recommended to implement Exception Handling. This way you can catch the exception and let your program handle it instead of letting the exception crash your program: 

String concatenation like that results in code that is not maintainable and looks ugly. You have other options to achieve the same: String.Format: Use the method to concatenate values, a small example: 

IP address: Perhaps the IP won't change that fast, or at all for that matter but when you want to write good code, you make it independent. Pass the IP address as a parameter to the method or get it from a config/resource file like the line that is commented out in your question. Static vs. Instance: Since this is kind of a utility class and you're nowhere creating instances and/or modyfying properties/fields in the class, you can leave it static. Also, static methods can be a little bit faster than instance methods. More reading on this from MSDN: CA1822: Mark members as static. Basically: 

Double code: Both the and method have a very similar structure. You could refactor the XML-handling in a separate method which you call from the other two. Both would return a double then. 

Coding/naming conventions: All the information about this can be found in folllowing article: Naming Guidelines. Straight from the documentation: 

Reason: placing selectors in variables is recommended, since overusing selectors can result in poor performance. Everytime you would call a function on , the whole DOM has to be parsed by the browser. This is not the case when you store it in a variable. Also, it's a general principle to not repeat yourself in code, also called the DRY principle (as mentioned by Peter Rader in the comments). 

Just out of curiosity, how would you do this without an if-statement? I wonder where you heard this. In code, the moment you need to check for a condition (of a variable or the result of a method), you have to use an if-statement. Spacing: Just for readability, leave spaces between assignments and checks in conditions: 

Now, to the question. In your code the second check for the variable to be equal to or is redundant. If you get to following line: 

You will have to adjust the maximum and minimum allowed change though, as for now you'll only allow very small moves. Hope this helps! 

Input Since the input is not mixed in the Person-class we have to declare it somewhere else. In this example I put the input-code in the KeyInput class. The method returns an instance of the Person-class and if the user enters "exit", null is returned. This way we can later on catch if the user wants to stop. 

Tip: new Constraint (C# Reference) I cannot reproduce your code and therefore cannot test the method. Please let me know if you got it to work using this method. Hope this helps! 

Even though the difference is minimal, there IS a difference. So you'll need to make a minimal distinction, depending on the button that was pressed. What you could do is create a general event for all the buttons and in that event you'll determine the index to be passed to the method. The code might look like this: 

Since you won't do anything further with those variables, the second if-statement should just read as: 

You should decide whether you want positive or negative evaluation on this. For example, only perform the method if the checks are positive or throw an argument exception if the checks are negative. That is up to you. Also, like Heslacher stated: what if the file already exists? As for now, the content of the file will be overwritten by the new content. statement: Following: 

Naming: Don't use variable names such as . They're not meaningful, not for you, not for others. In this case, use . Class names, public fields and method names use and not . So, will become . But then again, this is also not a meaningful name. Boolean methods or properties in C# will most likely start with or . An example for the name of your method would be . keyword: Use to declare your variables instead of declaring them explicitly. The compiler will determine the type for you and your code looks cleaner. The method: Your code looks good. You could however make it cleaner by using LinQ. Loops won't be avoided but it looks cleaner. I'm not saying this is a perfect solution but here goes: