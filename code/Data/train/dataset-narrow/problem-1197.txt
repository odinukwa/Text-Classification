You do not properly check for the edge conditions, i.e. when is or empty. You are setting members of your child's instances in the parent - you should move that to your constructor. Your code is not DRY, since you call twice. 

Mutable Long? I did not follow you explanation about , for one thing since I can't see that it even supports ... Also, when in each line you have numbers in the range of and , how big you expect the files to be? The max number is ... Magic Constants A constant like is not very useful. Using the literal is readable enough, and resolves any ambiguity it might have by hiding it in a constant: 

Don't use global variables Using as a holder for your AMQP connection is a bad idea. being such a generic name, it might be used somewhere else for something completely different, and you may end up breaking your code with someone else's. A better idea would be to use class variables - this way you get your namespace for free: 

Some notes about the code This is, of course a very elaborate design for a very simple assignment, and it is not optimal ( assumes that all you need is and , which might not be true to a lot of other shapes, and hold very little merit on its own - but I wanted to show some inheritance). Note though that each method does only what it is supposed to do: just creates a shape - it does not prompt the user, and it does not print anything; only draws the relevant shape, etc. This makes the code more readable and maintainable. Note also, that the class I don't want anyone to instantiate, I wrote as a rather than a . A cannot be instantiated, but can be or in other classes. Also, its class methods (the ones starting with ) can be called like class methods in classes, so it is an easy way to create singleton methods. 

Showing that is inside the function, and not after it. Playing with the idioms You can parse the string using the recursive method idioms, which would look like this: 

Naming conventions from time to time your code conventions slip - , , etc. if you write in java, adhere to its conventions - , , etc. When static methods scream 'refactor me!' - in your class you have many static classes. Even the name of the class hints ti the fact that it is not very object-oriented... When you look at all the methods in this class, you may note that all of them have one parameter in common, and they keep moving it around among themselves - . This suggests that it may be a good idea to refactor all of them into the class... Don't override member names - you use and to both the private members and their method getters. Better naming for the methods would be and - TL;DR - you might want to break this method to smaller ones. 

Edit To answer your question - this is not a good way to do this. The problem you encountered with the hints to circular dependency - calls , which uses on its creation. The correct resolution is to break this dependency by using my suggestion above, so the code will look like this: dialect/version.rb: 

Was that a result of an unfortunate copy+paste? Again - comment is not helpful, only confuses. I also believe the prompt will appear only after the user entered it, since you check before you print the prompt. 

This is Code Review, so I will not try to find where it doesn't support 2048 bit BigIntegers, but I will tell you what I see in your code: Naming Conventions You should choose your names according to your language's naming conventions: should be , should be (see also below regarding proper variable scopes), should be , etc... Also refrain from single letter names for anything that you use for more than one line of code - , , etc. Proper names Variable names should clearly state their purpose means the number 1/2, especially next to and . Actually it means half the input number. It is used as the max possible divisor, so call it that - . Same goes for - it should be (btw, what happens when you change its value to 2048?) When things don't change If you have data which does not change over time (like the number ) - making is is good, making it a constant () is better: 

Of course, as @chillworld suggested, both are wrong, as you should check that there is exactly one argument so: 

I'm not familiar with Umbraco, and I could not find any documentation on LinFu, I do, however, have some remarks on your code: Comments - your code is more than 40% comments, and un-useful comments at that - a comment that tells me that is is a waste of space and reduces readability of your code - I actually needed to copy your code locally and remove all the comments to read it. Static vs. instance scopes - you chose to put some of the state in the instance, and some in the class, but you manage both from the class. This means that if you create two instances of your class, their state will be unexpected, as they will change each-other's state. If you this class is meant to be a Singleton, make it a Singleton. Use locks properly - you chose to use as your lock object. That's OK, though I don't see why you would need a reader-writer lock. The problem is that you misuse it - the way you use it is as if it was just a regular object. Again, a simple lock object is fine, but declaring it as a fancy lock type, you confuse the code reader to look for (and assume) its use. 

Calculates interest or the new balance? Also, don't be lazy say - - there are no fines for long names. 

Your code looks very nice indeed, I only have some minor observations you code use to improve this code: Naming Use the imperative form of the verb ( instead of ) Implementation Hiding Use for methods which are not intended for external use. You might consider also renaming them to start with underscore to further differentiate them as internal. Multiple assignment in method signature To make you code more succinct, you can use multiple assignment - meaning that instead of: