But wait, there's more. We're going to take advantage of reflection and an array to clean this up another level. First we'll define an array which is the order of all the properties in the CSV: 

This is much more extensible, and allows you to unit test easier as well. Additionally, if you wish to support a lack of a : 

So I am working on an application (top-secret!) that I need settings for, these settings are pretty basic, but I don't want to make a single-row table with a bunch of serialized settings, or a single-row table with a bunch of columns, etc. So I made a class that's pretty handy: 

And our calls would happen outside this class. The class doesn't care where the input came from, it cares what input it got. Similarly, the should not appear, instead you should and let the caller decide what to do with it. This way you take the responsibility of acquiring input and delivering output away from the method, which can now be named to et. al. Next we are still in that same method, because it still does too many things. Let's break it down further: 

As you can see, it's still nice and short, and it's more robust than the original. :) This was an excellent start, and hopefully you take more out of this than just a bug fix. :) 

It won't help your big-O runtime (the version you posted with \$O(2n)\$ runtime reduces down to \$O(n)\$, so by big-O my version is just as fast) but it will help your actual runtime. Of course, this creates the problem of overflow (as does your solution). 

Overall: very solid code, excellent work and I'm glad to see another person experimenting with the language. :) Hopefully you learn more and more about it, and become another highly-qualified developer in C#. 

And it also sets us up for parsing things later on down the road. (Since we don't care about values, we only care about terms, a parser just has to define a term as it goes and supply them as arguments to the next term.) 

Now we safely default to when is not set, or when it's not numeric. Of course, we still have another bug: what happens if is ? That's probably unintended. So, we'll check for that as well: 

I've yet to test this, but in theory it should perform better. First: as stated in the other answer, you create a lot of objects immediately. Instead of doing that, you should rewrite to take a lambda: 

Absolutely no need for the there. Whether or not you keep it is up to you but the symbol eliminates the need for escape sequences in strings. It's mostly helpful with paths and Regex: as opposed to . 

Recently I was thinking about how Google, Microsoft Outlook on Windows Phone (and now many others) method of giving you a coloured icon with a letter in the centre of it works. Essentially, given some sort of name, they generate a colour based on that name. The kicker is that the same name always generates the same colour, the icon then generates with the 'initials' (dependent upon implementation) of the sender of the email within it. A sample is below. 

So I made a quick programme in F# to do FizzBuzz, I'm trying to learn more languages, so I figured I'd do something functional for a change. (Haskell is also on the list.) FizzBuzz is pretty self-explanatory: every third value print , every fifth print (possible both if it's a multiple of 3 and 5). 

Well this introduces our class, and really stands out here. Let's look at both of those: The class does some dirty things, and I'm not proud that it does them, but I think it does them well enough that, while we lack other options now, this will suffice. I built the the way I have to isolate the from the environment mostly. It can still access all the classes and such loaded, but at the very least it has no unwanted local variables, and won't leave any unwanted local variables in scope: 

Let's talk about SRP for the moment (I'm not going to cover anything else but this). SRP (or Single-Responsibility Principle) dictates that each and every component of code should have exactly one responsibility. So we're going to look at all your code top-to-bottom and determine what responsibilities we have in each method. We'll start with : 

Where is any alphabetical letter, is any number, and is any number . No result string should begin with , it should always begin with or , and all alphabet characters will always be capitalized. The input comes in a format similar to any of the following: 

You nailed tail-call recursion. I would be willing to bet that if you looked at the IL for this code you would see a beautiful call in there. Excellent work! 

A new tab will open with a lot of fun stuff, order everything by 'Object Type' and find . Double click your line. 

Using , and as a variable in this manner is frowned upon. These should only ever be used with local iterators. (I.e. where you have .) 

A not so obvious advantage of this approach is that it supports new API endpoints in addition to the existing ones. I don't have a lot of time to make this answer more exemplary, but this should get you started. 

Obviously we want to cut down on the work we do, always. I'm going to assume that is a class. In this case, we can immediately reduce a lot of the work we do right off the bat. 

Overall this is quite good, the logic is sound and I don't see any obvious errors that would make it painful to maintain. Hopefully this advice is helpful for this project and future projects as well. 

Welcome to the world of OOP â€” hopefully there are a few things we can teach you. ;) I'm going to show you an alternative implementation first, to help you see how OOP truly should be used, then I'll discuss your specific issues. 

Next, we'll get into some of the actual code and talk about things that can make life easier and whatnot. C# has implicit typing available through the use of the keyword (similar to in VB.NET or in F#. Something like the following: 

We initialize to because each iteration will add to , including the first iteration. (If you move the line to the end of the , you can remove .) This can have a performance impact with the significant number of iterations you are performing due to the lack of a multiplication operator. Instead, we reduced the code to a single addition instead of an addition and a multiplication. This also accesses fewer variables on the stack, which should also help. 

Unchecked There's no need for the context in . Bitwise operators never cause overflow, and as such has no effect on them. The context only affects certain arithmetic operators. $URL$ $URL$ $URL$ Constants (Debatable) Constants () are typically all uppercase with words separated by underscores. This is a best-practices rule more than anything. Note: as stated in the comments, this goes against the general naming conventions: 

Then I created an abstract class which implements some of the basic logic needed for the command, to save from having to repeat it regularly. (Just in case I create other commands for Windows Universal Apps.) 

You could get slightly closer with the command pair. It's actually quite trivial: Add an indexer to your class () and put your loop in there. The indexer would look like: 

Some changes I would make: Limit your use of whitespace. You shouldn't need whitespace after opening or before closing braces. I.e. start it as: 

Next, we'll talk about your output. You repeat certain statements excessively, let's find a better way to do that. We have and , as well as and . So how can we rewrite our methods to be more dynamic? Well, with the it's easy, right after the end brace for the we just write what each value was: 

Always, always, always use braces. Not using braces can definitely throw unexpected behaviour into our programme, and it doesn't really cost anything to add them: 

Much simpler. Of course, if the list is larger than , it will throw an exception. You can either keep it that way, or throw and explicit exception (which you should do to inform the user why their code failed). 

Never, never, never, never, never include if statements (without braces) and their action on the same line: 

You can also add other validation logic in there as you need, but this way it helps separate responsibilities further. To get rid of some of the other additional responsibilities has, we can consider a method which would return the filename, then would call or as appropriate. 

Alright, that doesn't do much but it does start pushing things into motion. You state in your question: 

Lastly, as for a bonus to this answer, you can also add alias operations. (What do I mean? Well what if I naturally use instead of for multiplication?) This is super easy: 

As you can see, the programme works just fine. I do hope you (and others) find this information helpful, and can learn more about VB.NET from it. :) Personally, I find VB.NET to be quite powerful, even though a lot of people act like it's not. 

All-in-all, very good start. Hopefully you learned a lot from this answer and can apply some of it to future applications. :) 

You don't use or after their respective loops, so don't define them as the first thing in the method. Instead, define them as: 

Because of the nature of our casting, we really only need to store the function which casts an individual item in one spot, since will return all items and will naturally filter them out. 

One note I will make on member naming: some developers (myself included) use the underscore notation instead of regular on members as this helps distinguish them from parameters in methods (which are also style). A little design note: if you find yourself giving the same variables, properties, parameters, fields, etc the same name prefix (as below), it's probably time for a new class: 

Now, ignoring the lack of a class that does this work, I'd love any suggestions. It would be a class in the real-world, and I understand that, I just didn't make it a class because (again) I'm lazy. Also note that this is probably a hell-of-a-lot-slower than the built-in decoding, and I make no claims for either case. This is just a really cool experiment that also demonstrates the self-synchronicity of UTF-8. Test case: 

That's just ugly. I get wanting to use expression-bodied members, they're really cool, but this just looks bad. Let's rewrite that as a non-expression-bodied method and create some intermediate variables, because I don't like seeing anywhere in my code. Back to this: 

Once you identify these, it's easy enough to rewrite for tail-call recursion. You can have as large or small an as you like, any state that changes between calls can be part of the . My example only has one, but technically the is also an for , if it helps visualize. I don't currently have time to write this for tail-call recursion for you, but I might do so tonight (so I wouldn't get disappointed too soon).