The table is the place where the MAC addresses are stored. It is used by the layer 2 control to forward incoming frames to their destination ports, something like this: 

Circuit switching networks as X.25 or Frame Relay use a mechanism that opens a virtual channel from transmitter to receiver before the data transmission begins. For example: If using Frame Relay you want to communicate from London to Paris, your communication device has to send a signal to its next Frame Relay switch indicating that you want to open a channel to Paris, and that switch sends the same signal to the following switch and so on until the signal gets to Paris switch. Now that the channel is stablished the communication begins. Each frame from London to Paris goes through the designated channel and when the communication ends the switches close the channel. Packet switching networks as TCP/IP don't open a predefined channel before sending the first frame of communication. In the same example using London and Paris, your device sends the first frame and the next switch will have to decide what is the best next hop for that frame and every network device will do the same until the frame gets to Paris. For each frame the switch decides the best next hop so sometimes the frames will go through one path and sometimes through another depending of traffic, congestion, availability, etc. Packet Switching networks are more flexible than Circuit switching networks because there is not a designated path from start to end. 

IP is a layer 3 protocol. It doesn't know anything about the physical media, it means that IP can travel through any media (for example: fiber optic, copper cable, air, etc). IP relies on a layer below (layer 2) that manages the access to the media. In the case of ethernet each device is connected to a common media (copper cable) and then the device has to identify itself to let know the others it is there, and that identification is the MAC address. Each device has a MAC address that is used by the layer 2 protocol to access the common copper cable and move frames from one device to the other. It seems to be enough to have communication, however layer 2 protocols doesn't scale well if you have hundreds of devices. Then it is needed a layer 3 protocol as IP. 

The SNR margin is the Signal to Noise Ratio margin. Signal to Noise Ratio is the relation between the and the . Even the most perfect cable absorbs some noise. This "noise" is electromagnetic interference produced by: 

If you are using static IP addreses there is not a single advantage of filtering by MAC because there is a one-to-one relationship among them, except if the device has a single interface and more than one IP address. In that case we're talking of a "one-to-many" relationship. In DHCP environments it could happen that an IP address is used by a device now and by another later. In that case is useful to filter by MAC so you can follow the behavior of the same device despite of the IP adddress changing behavior. Keep in mind that MAC addresses are local. IP packets coming from other LANs through a router, will have the original source MAC replaced with the router's MAC address. 

If station A needs to transmit, it tries to detect the presence of a carrier signal from another node before attempting it. If there is no carrier then it starts to transmit and this transmission starts to propagate. It means that while the first bit reach the farthest point of the media, station A is still transmitting. Let's suppose that station B needs to transmit, it detects a carrier in the media and then waits for the transmission in progress to end before initiating its own transmission. The propagation delay is not the same for each media (air, coaxial cable, UTP, fiber optic, etc.). That's why there is a distance limit for each media. To be sure that whenever a station needs to use the media every other station is aware of the state of it. Exceeding the recommended distance limit will cause late collisions: A type of collision that happens further than is allowed. It will decrease the throughput of the communication link because the data error will go up to the upper layers. 

I haven't found any reliable information on how to make multicast-over-WiFi work better, so what I did in order to work around the problem was write a multicast-simulator-layer that greatly reduces the amount of multicast traffic my system needs to send and receive over WiFi, without requiring a significant redesign of the application itself. On each node, the multicast-simulator-layer periodically sends out a very small multicast packet, simply to announce its presence to the world. Whenever another node receives one of these packets it adds the packet's source IP address to a list, and sends back a unicast reply to the sender (just to make sure the sender is aware of the receiver's existence also). Then whenever the application wants to "send a multicast packet" containing actual application-data, instead of just sending the packet directly via multicast, it hands the packet over to the multicast-simulator-layer, which "multicasts" the packet by sending a separate copy (via unicast) to each of the IP addresses in its list. This wouldn't scale up very well on a WiFi network with many participants, but for smaller WiFi-based systems this performs better than real multicast. There is also some keepalive/timeout logic so that nodes that haven't been heard from in a long time get dropped from everybody's nodes-list, but that's pretty much all there is to it. One other interesting "feature" I discovered during this process was that (on Mac laptops, anyway), the WiFi hardware is set to power itself down after about 250 milliseconds of inactivity, and once powered down it will take an indeterminate amount of time (anywhere from 30mS to 250mS) to make itself usable again so that the next packet can be sent. The upshot was, if I send a packet over WiFi every 300mS, the latency of the transmission would be all over the map due to the WiFi hardware constantly going to sleep and then waking up again. If I instead sent a packet every 150mS, the latency was much steadier as the WiFi hardware stayed online consistently (at the cost of increased energy consumption, of course) 

First, a little bit of background information: I'm working on some custom software that allows a group of computers on the same LAN to co-operate on a real-time task in a distributed, fault-tolerant manner. In particular, each of the computers sends out a multicast (IPv6/UDP) "heartbeat" packet several times a second, which the others receive, and based on their knowledge of who else is on-line at the time, they self-organize to divvy up a task amongst themselves. If any peers go offline, their parts of the task are automatically re-assigned to the remaining computers. In addition, a peer will sometimes use multicast to communicate a one-to-many data-update to the group. This all works nicely on a wired Ethernet network; but at some point I'd like to make it able to work well on a wireless network too, e.g. to allow for a self-organizing swarm of drones and other fun experiments like that. The problem is that Wi-Fi is notoriously bad at multicast -- in particular, multicast packets are usually transmitted at the AP's slowest and least efficient rate, and they are often delayed or dropped. That means that unless I dial my software's tolerances way back, running it over a Wi-Fi network means I occasionally get "false positives" where the system thinks a particular computer has gone away but actually it's just that the Wi-Fi network isn't delivering its heartbeats in a timely manner. The lack of timeliness also makes it difficult to co-ordinate behaviors precisely in time, since without a near-constant speed network, synchronizing clocks is difficult. My question is, is Wi-Fi simply not the right tool for this application? If it's not, is there some other wireless networking technology that I should be looking into using instead? (it seems that, in principle at least, radio ought to lend itself to efficient multicast/broadcast, since it's inherently a shared medium) Or if Wi-Fi really is the only game in town for wireless networking, how should I go about tweaking the Wi-Fi settings (on the AP and/or the clients) to get the best multicast performance possible?