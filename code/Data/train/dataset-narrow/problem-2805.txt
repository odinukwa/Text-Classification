Judging by your description of the problem, and from the following code, I bet you are storing the location of the particles as integers. 

The essence of the "host advantage" is having a low ping (round trip time to the server). If you are the server, you'd have no ping time, but even being really close to the server would result in a small ping and still have a large "host advantage", so I'm just going to call it a "low ping advantage" instead. It really depends on the game and how the networking code is written. Some games/engines will publish this information, but many more won't, so I'll take a few examples: First person shooters (FPS) are likely where the vast majority of low ping complaints come from because you always shoot first, right? Valve describes how the Source Engine handles networking (Counter-Strike:Source, Left 4 Dead, Titan Fall, etc.). The article goes into great depth, so I will attempt to gloss over some of the details: 

It might sound wasteful to store boundary objects like this, and you may get a number of these, but it's not that bad, and there's no choice if you want to store areas in your tree. You could store points in the tree, but then area-based queries break, and that's a more common use-case. 

I have an AI ship that stops approaching when it gets within firing range, and starts strafing around its target. The problem is that it doesn't circle its target very well. The following code attempts to do this, and for short periods of time, it's convincing, but as soon as you let it run for ~5-10 seconds, the AI ship drifts out of range of the target and is forced into the approach state again. 

So, once the clocks are in sync (roughly), the server can send out a command to start the game at some future time. Both clients should receive this message with ample time to spare, then start their timers at the same real-world time. 

The algorithm posted was correct, but in your example you are forgetting about the time it takes for the server packet to get to the client, so: 

I would imagine that creating a new batch for every drawable element of your game would cause a hit on performance because each call to Spritebatch.End() : 

You need to own at least 1 Source game before you are given access to the Source editing tools. I'm not quite sure what kind of demo you plan to make, or if that demo will require code changes or not, but I believe the Source SDK only provides you with Half-Life 2 mod tools, not Portal 2. You may be able to find more information on their website here: $URL$ You can however make very sophisticated maps using Valve's map editor called Hammer. And again, you will need to own any game you want to design maps for (otherwise how did yo plan to test them?). There are plenty of Hammer tutorials out there, although here is Valve's official level design page for Portal 2: $URL$ 

Some games let you record "demos". These demos are essentially recordings of everything that happened in the game and can be re-watched exactly as it was. Here are a couple games that I know do this: 

As far as I know, there is no way to do this automatically, even if you include the "primary output" of the Content project. 

How NTP works (roughly): One of your machines will act as the authoritative clock (likely your server). By clock, I simply mean some method to measure the passing of time, it does not have to be your wall clock. In games, "time" is often measured from the start of the game. The problem: If your server sends the current time to the clients, they will receive this information after some period of time (~RTT / 2) and the server's time will have moved forward already. It's impossible to know what the Round Trip Time (RTT) will be for any given packet. So how can the client's time ever match the servers exactly? The solution: It can't match exactly, but you can get it close by measuring how long it takes for packets to get between the server and client and use that to adjust the time sent from the server. So, the server will send the current time, then after some unknown delay the client will have what used to be the server's time. The client then sends an acknowledgement to the server, and when the server gets this, it calculates the RTT based on the amount of time that has passed since the first packet, then sends the RTT back to the client where it can be used to adjust the time. eg: 

And splits the SpriteDefinition from the SpriteAnimator because you can have multiple sprite animators working off the same sprite definition. This is just one way to think about 2D animations, but hopefully it will give you a place to start. 

The simplest way to handle rotating 2D collisions is to use circles instead of rectangles. For most practical purposes, circles are a good approximation, simple to implement, and nobody will be able to tell the difference anyway. Two objects are colliding if the distance between the centres (using Pythagorean theorem) is less than the sum of the radiuses. 

In effect, all clients are looking slightly into the past in order to help compensate for reasonable ping times. In theory, if clients are looking 100ms into the past, and if all players can get their actions to the server & other players within that time frame, then everyone should be looking at the same picture of the world at all times and everyone will be happy. But what happens when two players shoot within 100ms of each other? It will still take time for the shot information to reach the other clients, so both players may still see themselves shoot, even though there can only be one survivor. This likely creates a lot of false-positives. Since ping times aren't going anywhere anytime soon, there will always be "who shot first" arguments. This still leaves the question: is it better to have a low ping? In the case of the Source Engine, I would argue that there's no advantage to have pings lower than ~50ms (about half of the interpolation time with default settings), but it will vary by game and can be affected by many external factors like packet jitter. The answer gets a bit fuzzy when you start to consider high pings though. Those high ping players may not have an accurate view of the world, AND the other players may not have an accurate picture of the high-ping player. This can cause a variety of issues for everyone. Games handle this situation in various ways, and there is no clear solution. You can increase the interpolation time to make it more fluid for high-ping players, but then there will be more situations where one player thinks they did something before another. Decreasing the interpolation time will make it worse for high-pings, but fewer Hans shot first situations. Until ping times are non-existent, there will always real-time communication issues. Age of Empires uses a what I'll dub a "buffered lock-step approach" as described in this article. There is some debate, but StarCraft and other modern strategy games likely use a similar method. Again, it's quite detailed and technical, so I'll gloss over it. 

What if you treated a half of the screen like a virtual track ball where the position/speed of your character is directly tied to that of the ball? Swiping and releasing would set your character into constant motion (and cause the trackball to spin). Holding your finger on the screen would be like holding the trackball so that you could make small adjustments to your character's position, or stop your character from moving. I think this could work quite well for those frantic moments in Super Meat Boy where you're trying to run, jump, then stop on a dime. This would be an experimental approach because I haven't seen it done before, but anything is better than a virtual stick. Edit: The Steam Controller handles their trackpad like a simulated trackball, but I haven't experimented enough to find a game that treats it like one. 

That said, there are multi-threaded solutions that either avoid or minimize locking. One way is to use 1 thread for the core game and other threads for non-core game elements, like generating and animating trees and animals in Flight Sim X [ref]. An other way to do it is to have 2 copies of every game entity (wasteful, I know). One copy would be the , and the other would be the . The present copy is strictly write only, and the past copy is strictly read only. When you go to update, you assign ranges of your entity list to as many threads as you see fit. Each thread has write-access to the present copies in the assigned range and every thread has read-access to the all past copies of the entities, and thus can update the assigned present copies using data from the past copies with no locking. Between each frame, the present copy becomes the past copy, however you want to handle the swapping of roles. [citation needed] If you aren't noticing performance issues, I wouldn't change anything. Multi-threading issues can be tough to track down. 

Where the indicates the progress through the sequence. When the Animation changes, the Frame counter restarts at 0. When the Set or Orientation changes, the Animation and Frame counters do not change, the current animation just continues in the new set or orientation. Each Animation indicates which Animation should follow, once completed. For a looping animation, the animation will refer to itself. For a ping-pong animation, there will be a second animation that uses the same set of frames, only in reverse. And for animations continuing on to greater things, they point elsewhere. Whenever an animation completes, either a flag will be set to indicate this, or an event will get fired to allow the game to take any required actions (like start moving after standing up). This concept can work well for frame-based animations, but will require some more thought to be functional for skeleton animations. My SpriteLib project consumes XML that looks something like this: 

You need to manually include all of your content into the installer. In Visual Studio, right-click on the setup project, then click View, then File System. Under the "Application Folder", add a folder for Content and all of your XNBs, it should look something like this: 

I would highly recommend not using the MouseListener on the images for one main reason: The graphics should only be a visual representation of what's happening in the game. Using the graphics to control the game creates high coupling between the graphics and the game, which will make it hard to modify or improve later down the road. I would recommend using math to convert the mouse position to a game position like this article describes: $URL$ 

When I click with the above code, "ScreenToViewportPoint" and "ScreenToWorldPoint" print no matter where I click, and no others trigger. I suspect I need to transform the soundPanel somehow. Here is the Hierarchy, Scene, and Inspector. The selected rect is the soundPanel, and it is in the bottom-right of the UI Canvas: 

You'd be correct. The should only be used from within a method, and I'm guessing that is called from an method? You'll need to store some information in the method that can later be used in the method. Note that infinite loops and sleeps should not be used in XNA. XNA (and most other game frameworks) uses a Game Loop which will call followed by once per frame, over and over again. This gives a chance for everything to update and everything to draw. I would also avoid threads unless you really know what you're doing. Ralph has given you the codez. 

For sparser and larger worlds, I'd advocate the Quadtree, but I think for small and busy worlds, it is probably going to be slower than a Spatial hashing. 

Not your typical answer, but I think it's useful to add this for future googlers. Here's some snippets from our chat: 

Preventing almost any multi-threading gain. The other way would be to synchronize around each and every entity update call: 

I am working on a tutorial for my C# game right now. I'm separating the tutorial from the game by using events. In my game, I have a bunch of events that are triggered when the game state changes in a variety of ways: Entities moving, getting destroyed, being built, upgrade complete, etc. My tutorial listens to the events of interest and has the ability to manipulate the HUD. That's all you need. To make it perfectly clear, the game has no idea that the tutorial is happening. This may also be important: My Tutorial is a subclass of Scenario, where the Game is always executing a Scenario. Since I'm using C#, I could feasibly take any of my Scenarios and toss them in a C# script file, but right now, all of my Scenarios are compiled directly into the game. The class is a bit of a work in progress right now, but here's a slightly out of date version you can look at: $URL$ 

Quadtrees typically store and retrieve rectangles. A point is a specific case where width and height are zero. The following logic is used to find home for new rectangles in the tree, starting with the root node: 

You need to check for a mouse state change. Only trigger a mouse down event IF the mouse was up during the last frame, and mouse is down during this frame. In some frameworks, you may need to hold on to two mouse states, one for last frame and one for this frame. The same goes for keyboard states.