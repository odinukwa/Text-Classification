You could use a variable for that to tell what this condition is for. Or even create an extension for it. The same applies for many other s where the intentions is not clear. Besides you use the same condition twice (in both loops) so an extenstion would definitely help. 

Consider using a parameter rahter then using closures. That makes the usage even clearer. If you define it as 

Everything together The result of applying all suggestions and proper names would be a self-documenting code that no longer has to be commented. When you write comments you only should explain why you are doing something because the code already shows what. 

You didn't say which json serializer you use but I cannot imagine you use anything else then JSON.NET. With it you can specify the date-time serializer so you don't have to implement any hacks. 

I find a cleaner way for comparing objects is to implement is as a separate class with the interface. With it there is no confusion between the various methods and you separate the comparison logic from the object itself. Also instead of negating each condition you can chain them with and use positive ones: 

I think it would be better to provide a parameter for this one too. At least make it optional with a default value if you don't want to type it everythime but hardcoding it - well, I woudn't. It doesn't take long and you'll find another use for it but then you'll say if I only made a parameter for this :-) 

If the query does what you need and there aren't any performance problems then the only thing that can be improved is the formatting and naming. You know that you can split the select into multiple lines? You also don't need the becasue there is no extension attached to it like etc. One name is inconsitent with the others: should be . Will you know that is the user's name and not the product's name? The properties of the anonymous object should be PascalCase like all other property names. 

Implementing such types means a lot of work in terms of overriding all the equality methods. In order to save you some time you should have a base type or that already implements all the basic and mandatory logic and if necessary just override it in the derived class and add to it in your or . 

You can call this implementation insane but I find encapsulating nearly everything in it makes the algorithm very easy to follow even if you look a it in a few weeks and especially for someone who's never seen it before. But this does not only apply to this algorighm but every other one. Very often we think that an algorithm is so trivial that it does not need any encapsulation or helper variables or anything alike but all the questions and clarification and comments say the exact opposite. It's very difficult to get the idea of it if all you see are some mysterious comparisons or strange calculations. Luckily there is almost always a name we can give such operations or conditions. This is exactly what I did with it. I had a rather hard time to understand it at first but as I had a general idea of how it works I was able to guess what the particular line is for and as soon as I understood it, I give it a name. It's very likely that if I now showed this to anybody who does not know its exact purpose, he would probably be able to figure it out without debugging or running it first. I did not only named the core-logic but I also changed the order of the conditions to simpilfy them especially the and became to remove the repetition and to shorten the s. Additionaly to make it behave similar to the other split methods I added the that will allow you to ignore empty tokens that your original code can only do when the last token is a delimiter. 

This looks like a really bad idea. Why are you getting all data from the database first and not filter it before retrieving? 

Always dispose streams Another bad habit of yours is to not dispose streams. If you call this method a couple of time you'll be wasting a lot of memory. You should always do it at some point either with the statement or by calling in a block. 

You should create another method that parses/converts the into the property type and put the s there. 

You should try to encapsulate this logic otherwise if you need to change anything later you'll need to think to do it twice. 

Here you specify the scale and convert the size. It's not very intuitive how to use it with two different behaviours. How about a factory method instead? 

Sometimes reflection is very useful especially if you work with attributes. I guess the class is under your control, right? You can decorate its properties with a custom attribute. 

You may also use a different pattern if you want to process each task result right away by doing it as soon as any task is finished with and a loop: 

is a super weird way of passing arguments from method to another. I'm not sure if you know it but methods can take more then one parameter ;-) 

Yes, it does make sense because otherwise you have the same validation in several places. You could create a helper extension to validate the id so that you don't have to repeat yourself everywhere you need the validation. 

false - means arr1 is fully contained in arr2 The good thing about lookup is that you don't need the method because if the key does not exist it'll return an empty collection. 

You now have a calculator that works. The next step is to read from the console... but maybe you want to read the numbers until the input is correct? Currently it would crash if you enter a letter. So create a helper for it that will try to parse the input until it's a valid value. Instead of using for this job you could use to get more precision: 

It's not necessary to call the method two times. It's better to just check if the result has rows and then get the one and its or otherwise an empty , finally you turn it into an array and you're done: 

And the classic one (like the classic in c++). You don't want to block your thread with that. Instead, you should use and make your code 

This is what remains from your original class. I swithched the order of parameters form and name to and because I find this order more natural. I also suggest implementing the interface by redirecting it to a custom implementation of becuase it not only better encapsulates the logic but also has a nicer method taking two parameters for and rather then working with the invisible and . Usage examples: 

I don't see much value in splitting the exception handling here as both es do the same thing. The only difference are the comments. You should log them or put them in the message so know the reason later without looking at the code. argumentoutofrangeexception In C# we use for variable names and not . OpenFileDialog This is a console app so it might not really matter but the is . xManager Manager is not usually a good name. I'd call it . 

The has lost its helper but gained two default values and custom formatting. The array output now also contains an ellipsis and the max number of elements that is always displayed. This could be made more sophisticated but maybe another time... 

Why do you need an ? To be able to send notifications without knowing how they are going to be sent. You receive a notification-service and want to call the method to send a notification. But do you want to repeatedly send the same notification? I don't think so. Thus the method should probably require a message that you want to send. 

The method of the does not need to repeat the implementation of its strongly typed counterpart. You could use the new operator and redirect it like this: 

You call here the delegate via an expression (the setter does the same). This is like you've just called the delegate. Use can use the expression to call the property directly: 

Next we want to upgrade some buildings (I might have the condition for upgrading wrong but it should just demostrate the general idea) 

This will log the exception but also preserve the original stack-trace (which is what you actually always want). I think you should not have ommited the implementation because it currently needs more improvement then the design. 

Now after having found the fields you can parse them in another method, ignore the case and build the flags with linq's extension: 

it will still produce the same result but it's simply easier (should be) to do it via the builder. There is no pattern that enforces it. You write one (builder) because you want shorter, more natural code. 

Unfortunately there is no interface that defines the operators but you could define your own data type and with a litte over-engineering you get his: Base class for the argument: 

I'd like to use a buffered queue for logging via a WebAPI that handles multiple applications. This helper should reduce the blocking that occures due to logging. I've been experimenting with a producer/consumer pattern and the is what I've come up with. Internally it uses the and allows the user (me) to specify the handler action - it's going to be (with additional processing) used as fire-and-forget. Although currently its main purpose is to be used for logging I may use it in other scenarios too. 

In order to get rid of them you should start improving your code by moving parts of it into other smaller methods so that some of the nested loops will vanish because probably you would take them to somewhere else. 

It calls a resource at via GET. This example does not override anything but should I need it or add some query-string parameters, I can do it inside any extension for the rest-method just by changing the uri-builder of the configuration: 

I need a but unfortunatelly the one that the .NET provides didn't have the functionality I was looking for (not working with linq and the LinkedListNode is sealed). I created a replacement that works similar but is linq-compatible. The main class is a that might be used on it's own but is better suited to be used by composition and should provide all the functionality of a chain: 

For future use I define a couple of classes for each field. They're empty but later they will check the and validate if the has valid values. 

There's not even single curly brace ;-) I wouldn't complain if it was python but in C# you should always use them. Omitting them can cause a real headache. 

From the technical point of view you could implement both interfaces at the same time but you'd have to implement the method explicitly and without repeating yourself it would go like this: 

This is not very professional. You do however consistently use confusing names in all parts of the code: 

Later in your application you can reuse it everywhere which would result in a nice short and clear code ba also getting rid of this ugly condition: 

I'd like you take a look at these tests and tell me how good or bad they are and what would you improve if anything? Is their purpose and implementation clear? Did I pick the right names for everything? 

You nowhere handle the but you use it for csv generation. If any sentence contains a you won't be able to read it later. The cleaning methods does not trim it. I suggest adjusting the regex for this case: 

This is redundant. The converted value has already the target type. It just needs to be casted and because the boxes the value anyway, you might as well do it yourself like this: 

Usage Now that you have so many parts, you can assemble them and print the lines to whatever you want. 

As long as you know that there won't be other values it's ok but if you think some of them might change an array could help: 

I think this needs to be separated into multiple modules and functions. If you do this, you can even docode messages encoded in various ways starting at any corner or (counter)clockwise. This can be achieved by mixing functional and oo-programming. 

The last component is the class that provides even more helpers so that a data object can be validated more fluently or so that a failed validtion can throw an exception. Exeptions are generated dynamically and are made of the name of the type that failed the validation so there is no but for example a can be thrown. 

async/await In order for the to work you need to actually something but I couldn't find it in your code. Let's try to fix that and introduce few other changes that make your code look better. I start with the method... and you actually don't need it. Everything it does can be reduced to a single line: 

You call this method but there is nothing safe about it. I'd be really surprised if I found that a sorting function actually modified the objects I wanted to sort. 

This isn't really helpful as there is no information about what went wrong. Use at least the or for logging purposes . 

You should separate this loop from the other one. This means instead of getting all files and deleting reports and then skipping those file names in the second loop, you first delete the reports and then process the remaining files. This can be done by specifying a search pattern for the method