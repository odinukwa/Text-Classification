I think the real trick is in teaching the value of Functional Programming rather than trying to teach the value of Functional Programming Languages. The latter will fail the pragmatic approach in almost all cases. Why? Because functional programming languages intentionally restrict themselves in the name of purity, and then try to demonstrate that they can be just as effective as other languages. Meanwhile, the other languages have sought to be productive as goal #1. It should be expected that the languages which strive for productivity first will be more productive than those which put productivity second. If not, those other languages have truly failed. The mere fact that C, C++, Python, PHP, etc. are all alive and well suggest that even the most staunch supporter of Haskell has to admit that these languages are good at doing what they strive to do. That thing they do may not be exactly what the Haskell developer wants to do in their programs, but they have to admit that the other languages do what the other people want them to do. Instead of trying to promote the languages themselves, I would try to build a niche for these functional programing languages by building interest in functional programming in general. You mention that several students already have picked up that functional programming has been working it's way into "mainstream" languages like Java or Python, or even C++11. Don't fight that. Leverage that. Teach them that functional programming, itself, has value. Use whatever language it takes to teach that. Once they start getting interested in functional programming itself, that is the time to start encouraging them to approach languages like Haskell. Once the students realize that there's another way to solve some of these problems, the functional way, then languages like Haskell can start to sell the argument that everything can be done functionally. In fact, the typical battle cry of Haskell lovers is that it can even be done efficiently and functionally! This battle cry falls flat if students are currently content with their tools, but if you have demonstrated to them that there is power to this new way of thinking, the battle cry sounds different. The message should not be "learn Haskell, it's a great language." The message should be "Learn functional programming. It's a powerful tool that you can apply in many languages, and it's easy to hone your skills at it using Haskell." Or substitute your academic language. You should be selling the technique, not the language. Teach them to find a balance between the procedural styles and the functional styles. That balance will differ at every business that eventually employs your students. There is no one "right" balance, so teaching them how to strike the best balance for the moment is a great job skill. I learn martial arts. In my martial arts class, I do lots of things that I will never find a need to do in real life. Why do I do them? Because they teach me skills I will use in my day to day life, and the most efficient way to learn them is to spend the hours in a pure environment dedicated to honing those skills. Likewise, I have learned functional programming languages. In learning those languages, I do a lot of things that I will never do in my day-to-day career. Why do I do them? Because they teach me the set of skills I do use in my career, and the most efficient way to learn them was to spend the hours in a pure environment dedicated to honing those skills. 

The biggest issue I see is that you are taking your curriculum and trying to approach it using SCRUM terms. The result is a lot of "almost SCRUM" behaviors which could be tremendously damaging. I've seen many SCRUM teams fail because a Product Owner or Scrum Master forced "almost SCRUM" mentalities on the team. Instead of taking your curriculum and trying to approach it with SCRUM terms, I recommend starting with the SCRUM process, and trying to apply it to your curriculum. The reason I think this will work better is because SCRUM is designed to produce a product, such as the learning of your curriculum. Your curriculum is not necessarily designed to operate in SCRUM. Let SCRUM take charge, and do what it's good at. One key aspect of this application is that you are going to wear three hats: Product Owner, Scrum Master, and Manager. Manager is not actually a SCRUM role, but it is essential for stability. If a real life SCRUM team refuses to build sprints which support the Product Owner sufficiently, That PO will have a talk with the functional management of the team and everyone will be receiving bad performance reviews for the year. The school-house equivalent for that is being given a bad grade. Thus, "support of the SCRUM process" should be a line item in your grades for the students. Maybe you tell the students that the first 10-20% of their grade is "free" unless they disrupt the SCRUM process enough to force you (as the PO) to have a talk with yourself (as the manager). If you coach it right, they'll think of it as a free A on a test or something like that. With that ugly manager hat out of the way, we can look at the other ones. Product Owner will be the most interesting. Like an industry PO, you have an obligation to produce a product for your customer: your administration and these children's parents expect learning. Explain to the students that, when you're wearing the PO hat, your job is to deliver the curriculum to the expectations of these customers. I would expect two major styles of behavior here. If the students are on-pace with the curriculum, the PO should operate like any real-life product owner would: egging the team on to produce more product faster, and maybe giving them more freedom to craft the backlog the way they want to see it. However, if the students are falling behind (i.e. the PO may not be able to deliver the "learning" to the customer), and the students aren't ameliorating this in their sprints, the PO should start tightening the reins offering less agility, and instead picking sure-fire ways to cover the material (which are probably more boring), and you will be talking with yourself (as Manager) about those SCRUM grades. The students should understand this up front. If they start to fall behind, there should be a desire on their part to resolve the issue before the PO comes in and takes away their freedoms. It should be easy enough for them to understand, but knowing how the game works up-front is key. Then there's the Scrum Master. The SM is known as the "servant-leader" of the team. They are there to facilitate the team in any way needed to make the SCRUM team successful. Note how different that job description is from the PO. You are going to need to make it very clear when you are acting as SM and when you are acting as PO. This might actually involve funny headgear, or it might just involve some metacommunicating to tell people who you are acting as. As an example, let's recognize that this SCRUM effort is an experiment. It might not actually fit well into the school model. What happens if it's a bad match? The first thing that you'll notice is that you (as PO), start to get unhappy because you're not delivering "learning" on-time. You're falling behind schedule. The PO is then going to push on the team to produce more. As SM, you then need to work with them to try to plan better sprints to meet the PO's needs. Now in this case, we're looking at the case where this fails. Now the PO is extremely unhappy and is ready to talk to the Manager about how bad the team is performing (and take away their SCRUM support grade). At this point, you might need to do some metacommunication to recover: 

Tl/Dr: Interact with each student individually. Also, I wrote this answer mostly because I wanted to have fun with the list of students at the end. It probably shows, but hopefully it's useful! So I haven't seen your interaction style with your students. I don't know where the challenges exist. However, one thing I have found to be generally true is that the phrase "take criticism constructively" is a tricky one. It's so easy to put all the onus on the receiver of the criticism, insisting that they take it "constructively." I think some of what makes it hard is that the phrase doesn't include the provider of the criticism. It, instead, focuses on the "criticism," like it's already out in the open. Now the ability to take criticism like this and turn it into something constructive is an important life skill, but the thing about life skills is that they take a lifetime to develop. You might have a few hours with the students for a year, if that. You can show them the path towards how to take criticism constructively, but you can't expect them to walk all that far down it in a year. The key, like anything else in teaching or the rest of life, is individual attention to the students. You have to look at what's going on in their minds. And, of course, I strive to say this with the utmost humility: for me, this is a life skill that's going to take a lifetime... and sometimes it feels like it'll take two or three. But that's okay. I still feel like I can say the phrase and have the phrase be true, even when I strugle with doing it. What I have found very effective is to take the word "constructively" literally and see how far I can run with it. Consider the "stationary" points in the mind of a young student -- the things which are moving slow enough to be worth directing. Some of them are already constructed. They're stationary things like facts and beliefs which are already there. You can't constructively criticize those, because they're already constructed. They're done. All you can do to change them is be destructive. All you can do is tear them down and then try to show them what they should build up in its place. Doing so is certainly part of teaching, but it's not "constructive criticism." The other stationary point is more interesting, and far harder to see. These are the energetic holes in their lives where something could be constructed. These happen during growing up, and they also happen when an individual decides one of their beliefs shouldn't be so solid and tears it up. They then hold onto that potential looking for something to build in its place. This is where constructive criticism is tremendously powerful. If you can resolve something in their mind just by suggesting somewhere to put their load, the students will rapidly accept your offer. Note that this version of constructive criticism requires something in their mind already -- a desire to construct. You have to look for where they want to construct things, and make it happen. Consider the following students: 

As he described it, the process for modern physics operated as a loop. On the bottom, we have the experiences we have in life. The arrow sweeping off to the left is intuition. From these experiences in life we distill highly abstract concepts of what the "laws of physics" might be, which are the axioms of science. From those, we deduce very specific testable statements which then encourage us to go out and actually run the tests and make the results part of our experience. The cycle then continues. I think this is very similar to how a programmer builds up a program. They start from the sum of their experience as a developer, and use that to fuel an intuitive leap to a set of axioms that one thinks can solve the problem at hand. One then builds more concrete statements which suggest ways you can test these axioms to see if they're right. When we actually test it, we experience what really happens, and that fuels the next intuitive leap. Of course, the challenge as a young developer such as yourself is that you haven't developed that intuition to make the first leap. This is not unusual. Most students get through college without developing this intuition because it's not what school teaches. Instead, you develop that intuition very rapidly once you get out in the field. Don't worry, you're not alone! To jump start the process, we in the field of computer programming rely on something called "requirements." These are axioms which someone else gives you and says "your project must fit to these axioms." If you're lucky, these requirements were developed by someone who knows something about the problem at hand, so they're pretty close to the correct ones. You then simply have to develop the deduced statements and test them out, developing your own experience. If you have a very good team lead, they'll give you requirements that are just right enough to keep you productive, but have just enough flaws that you can start developing your own intuition. Often there is something wrong with the requirements, and when you realize this, you are often the only person with the experience required to make the intuitive leap to the new axioms. To give a concrete example, if your team lead has only ever worked on Windows, they may have the Windows axioms in their head, which assume there is a function. If your product needs to work on Linux, their requirements may end up being wrong. So what happens at this point? Well, you have requirements to find the function on Linux. You deduce that such a function should appear in the Linux API documentation, so you go test that theory. You look through the documentation, and don't find it. Now you have an experience that your team lead didn't have -- your team lead hasn't gone through the documentation like you just did! Now you know you can reject one of the axioms as "not correct." So what was it's purpose? This is where your intuition comes in. You read the documentation on on Windows, you study what your product (the shell) is supposed to do, and make the intuitive leap that what your team lead really wanted was process management. Now you have an axiom that you've invented. Nobody told you to do "process management." You were told to use . You intuitively theorized the reasons for why they wanted you to do that. Next comes the development of deduced statements. You have an axiom stating that your job as a developer is to figure out how to do process management. You need to develop a few specific statements which can test this axiom. This might mean making a few statements which you may ask your team lead about. You might tell your team lead that there is no function on Linux, and ask for clarification to see if what he's really looking for is general-purpose process management. Or you might deduce "this sounds like something people have done before, I bet there's an answer on StackExchange." (If it's not on stack exchange, it's probably not worth doing!). Or you might have to take the long route. You might have to say "I understand that Linux has functions to create processes. Which functions are capable of creating new processes?" This would then lead you to go look through the documentation again, and find . At this point, you can fork your process, but obviously that isn't exactly what you want. You want to execute a new program. Another intuitive leap: "given that people execute programs on Linux, there's probably a way to do it." Combining "fork is the way we spawn new processes" with "there's a way to spawn other programs on Linux," you can deduce the idea that there's probably a function which turns one program into another. This will lead you to find . Now all of this is dependent on a balance. Your team lead has to give you enough requirements that your fresh-out-of-school intuition is capable of filling in the gaps, but they also need to be able to listen to you when you come up with new axioms which might change the requirements. Team leads generally have experience. They have the skill to do this (most of them, at lest). And what if you're on your own? What if you're just sitting at home honing your skills without a team lead to direct you? Well then, you are your own team lead! I recommend starting small. As a general principle, we learn the most when we pick a program that is within our reach, but just outside of our grasp. I wouldn't pick a shell as my first test program, because they're rather hard. However, if you just finished a course on how processes are managed by the operating system, that task may be right up your alley! And remember to always have fun! It's so much harder to develop intuition when you're not having fun!