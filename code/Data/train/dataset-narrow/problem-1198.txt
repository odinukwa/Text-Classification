So, all in all, a lot of refactoring to be done here. Well done for using and prepared statements though. 

For an example implementation of this, check out Doctrine ORM. The Repository is the the object that uses a data mapper to save data to the relevant data source. Change the data source, the repository object-api (how you save / retrieve data) stays the same, but how the data is saved changes. Pretty basic concept but really powerful, and not just limited to ORMs or PHP, either. Imagine entities in JavaScript with a data mapper for local/session storage, for example. The data mapper would have get, update, delete (etc) methods, and the repository would call the underlying data mapper (relying on an interface) to actually perform the saving / retrieving of data, which you can swap out at any time. Also, our vote needs to have it's own (unique, primary key) completely separate from every other attribute so it can be uniquely identified. Aside from that, all lowercase, underscores for spaces and prepared statements is a good thing. I'm not going to write your code for you, but effectively, you need to take a look at doing the following: 

Somewhere in the , it would call to actually make a object. Don't expect the user to remember to call followed by . If one can't be run before the other, then it looks like you're trying to implement the builder creational pattern (which is for optional parameters). Your method should return a object. In the context of routing itself, you'll likely want something called a Resolver. That is, something you pass a to, and it instantiates the thing you are routing to. In an 'MVC' framework, you have a - so you would create a , call and that would contain the logic to decide what controller to create based on the contents of the object (so it'd do things like etc. It looks like you're trying to design some generic router, but it is doing too many things. Focus on making the following seperately: 

The above notes should give you an overall improvement on your form validation, leading to a valid code and a better solution for future maintenance. I haven't tested any of it, but it should be working. 

Validating Code: This links should prove useful as to validate your code and warn you about common mistakes: 

PHP Your PHP code falls under the same issues as the jQuery code, that is, repeating several chunks of code that latter on will prove difficult to maintain. 

JQUERY Your jQuery currently uses the same code over and over, the best option is always to make scripts as generic as possible, to minimize the amount of code that as to be downloaded and interpreted by the browser. Also, in future maintenance, you'll find it easy to deal with a small generic code then a large element specific one. 

elements don't accept fields as direct childâ€™s, so you should place your submit button inside a wrapper element. I don't know about your visual aspect, but you should use CSS to format your elements and keep HTML to a minimum. Your password field should have the type password as to allow the browser to obfuscate the characters being typed. If you're using jQuery, you're better of going with the .blur() event instead of giving attribute to all elements subjected to validation. 

is always guaranteed to return a single number so the exception handler for is a dead code and should be removed. If you're just checking for existence there's no point to count beyond 1, thus enter . This also guarantees the returns either or . This might or might not help your query performance (check explain plan). It's a bit questionable if such an utility subprogram should record the exception or not but more information about your error handling implementation would be required to comment further. I usually don't but I'll let the exception propagate to the caller context and then record the full stack trace there. The good thing is that you (I just assume that from the name of ). 

As bonus I also introduced you to standard SQL datetime-literal syntax. Let's create some data to play with: 

Use analytic function (you might also consider using or functions instead) to assign an unique number in ordered sequence to each row. This is the standard way to implement top-N, bottom-N and inner-N queries in Oracle. Note that this example doesn't resolve ties. 

I'd solve the problem by providing a PL/SQL procedure that knows the "split"-logic. In the example below I assume that non-splitted rows are not inserted into the table at all but all inserts should be done with the procedure. This is a rather common pattern when there's data manipulations but it is not clear from your problem statement if this is an acceptable solution in your case. I used regular expressions as it's a very handy tool for pattern matching with superior expressiveness and clarity compared to spaghetti. I didn't used triggers as it's not possible to modify the table trigger is attached to. The solution can be easily applied even if you need to read the input data (i.e. non-splitted) from the same table. Example 

Separate the actions out that you want to do, contextually, and you'll achieve better SoC. Also, you shouldn't be accessing any superglobals () within this class, you should pass them in instead. This means that during testing you fake (or 'mock') the data you pass in with relative ease and test that your object still functions as you expect over different scenarios. 

A should not have access to the database. It should be a dumb 'entity' with setters, getters and a constructor to make the required object a valid one. You should take a look at the Repository and Data Mapper patterns. The point is, the object you want to save should not know how it is saved - meaning that you can change where you want to save it's data in the future without touching the underlying entity. 

You need to decide on the Domain Objects that represent concepts in your current model. A object should encapsulate the data to do with a route. If you look at Symfony's Route you'll see that it is simply an object with some properties, getters and setters, and that's about it (apart from a few select helper functions). This is also known as an Entity, the end object that you get back. So, now you know that you want to get back some entities ( in phpdoc), you should: 

As mentioned above, with the jQuery function, you can bind the event to all inputs inside the target form and start creating a more generic validation solution. Instead of having an statement to ascertain the element subject to validation, send to the PHP file the field collected and its value. No need for specific error elements for each input subjected to validation, use classes and target then thru the attribute, that in conjunction with a generic class for messages gives your the target element for the user messages. If you are appending the element to the form, you should also remove it when not needed. If the user keeps triggering the in the same field, the element keeps being added and you end up with tons of them. 

If you're using a method, check for it and the specific variables necessary to execute the script, otherwise, bailout. Perform some cleanup to the values before using them. Since you're querying the same table, having the field passed along with the value, proves useful to have a single database line to maintain instead of several across the script. You can choose to mascaraed the field name if your really want to obfuscate what's being done. When using many statements, the best option is to migrate to a statement. Easy to maintain, read and "upgrade". If the HTML that this script is outputting is the same, changing only the text and a class, best is to make use of variables to store the desirable values and have one single like with the script output. Will prove useful when dealing with problems, having to "upgrade" the script, etc.