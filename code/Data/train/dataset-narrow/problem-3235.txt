WARNING THERE BE DRAGONS HERE You need to be very careful about running a webpage that includes system manipulation. Make sure you're familiar with the concept of injection attacks. Python is slightly safer in this regard than SQL, but be extremely wary of any input that comes from user space. Just because your website doesn't have the option, doesn't mean they can't access a public API directly. 

I would start with It will tell you everything you could possibly need to know about cron. Once you've familiarized yourself a little bit, the command will open your user's crontab configuration for editing. At the very bottom of the file will be a commented out line reminding you of the order for years, months, days, hours, etc. 

There is currently no library to use PHP to manipulate the GPIO in that manner. I've seen one basic library, but it doesn't support using callbacks. I would recommend using Python for this portion of your backend. 

Write early, write often. Log information as soon as you can. Don't hold onto things in RAM and plan on writing it later. It's a fairly common practice to append data to a file, and then process it later in a more secure environment. Write simply. Don't waste time formatting the output. So long as you can read it without data loss in the future, cleaning and pretty formatting can happen later Don't trust that your language is writing exactly as your expect. uses a buffer. If the power gets pulled before , you may not actually see anything get written. I would include a after each write, or disable the buffer storage entirely by changing your call to . Don't constantly call and . System calls are expensive. Open the file once before the loop, and close it after. The less time you spend opening the file, the more time you have to write to the disk. 

In my opinion, one of the biggest advantages of using HDMI or DVI out is compatibility. Screens sold for the RPi that use a GPIO connector usually ship with a special image, and you're stuck using that image if you want to continue using their screen. Since their drivers are bound to a specific version of the kernel, you are often at their mercy when it comes time to upgrade the RPi's software. The official screen uses the RPi's DVI output, and then the GPIO just for touch input. Other similar screens are more likely to use the HDMI port + USB. The primary benefit to the official screen is that the connector type is pretty compact. The last thing that comes to mind is that GPIO controlled screens tend to stay on the small side. The only largeish screen I've seen that connects via GPIO wasn't very responsive when moving objects around the screen. 

As is currently implemented, the Raspberry Pi will suffer the fate of the listed bug, if no changes in software are made. Most modern machines are making the jump to 64bit processors, but I wouldn't be surprised at all to still see 32bit mainstreamed processors at that point. There are software solutions that could and will have to solve the problem. It seems to me that the most likely fix would be to update Epoch time to start at something like January 1st, 2000. While this wouldn't delay the bug, it would certainly reset it for the foreseeable future. 

If you're less interested in the additional details may be slightly simpler to parse. It gives the current name of connected device. Example: 

The Sony Xperia is on the low side if you'll be using any wireless addons or external HDDs with the RPi 3. The power output of the S5 charger is in the correct range, but it may have a different problem. Ever since the S4, the Galaxy devices have all come with Fast Charge power adapters. I can't say for certainty (outside my scope of experience), but they may do weird and unpredictable things to the RPi. 

I had this problem with the first cable I used on my Pi. Turns out the problem was me using an old cable. Original micro USB had the securing pins built into the plug, not the cable. If you're not using a cable with pins built onto it, try a cable that does. If you are, try another cable anyway. I've seen several different Pi's used with a variety of cables and have only ever had that one issue. 

It sounds like a power issue. Your RPi might be giving them enough power once the drives are started, but remember, the initial start is what requires the biggest power draw. If you're going to run both drives at the same time, they should be connected through an externally powered USB hub. 

Try running all the build steps as sudo. I've often found that without that things often don't compile correctly. Other than that, my next guess would be that you're missing somekind of dependency. 

The PiUi interface is written and controlled in Python. This could be used to control your C program, but such interactivity won't happen magically. You will need to build some kind of listening interface into your C application. That could be done using message queues, shared memory, pipes, ports, or a number of other things. It looks like PiUi is simply a framework for creating a local webpage. It may be simpler to just create one yourself as @SteveRobillard has suggested in the comments. 

NOOBS is probably going to be the easiest thing to just setup and go. It ships with gcc/g++ for writing in C and C++ and you could install gfortran by typing in the command line. For lighter programming, if he's interested, he could try scripting languages. Python comes with NOOBS and ruby is a personal favorite. Edit: I forgot to mention you'll want to select raspbian on install with NOOBS. 

Your RPi isn't powerful enough for the task. Emulating an x86 processor on ARM is incredibly resource intensive. Add a game (even an older game) on top of that, and your RPi just won't be able to keep up. You mention you're using 25% of your processor. That means that qemu instance is taking up 100% of one of the available four cores. Since games (especially older games) tend to be designed for single core (CPU wise) utilization, adding cores to QEMU won't really help you any. 

The answer to your question is simple from a high level, but gets very complicated, very quickly. For a high level of understanding, you'll want to go for something that has words like, "For Raspberry Pi". If you want to dig into it a little more, an OS will have to meet a few requirements. They sound trivial, but are not. 

You could probably clone the old computer, and run it as a VM in a newer computer. It doesn't even need to be a dedicated computer. (See: VirtualBox) You might be able to use an x86 development board if you really want to stick with a setup of this style. Minnowboards are significantly more expensive, but run on the correct architecture. I believe you could get an image of your current system running on it.