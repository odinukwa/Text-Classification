One cool perk of this approach is that because mouse look uses relative movements while you're leaving the absolute Y position untouched, cursor movement still functions as before. If you wish to make further modifications or need to debug your changes, add statements, rebuild, and rerun. 

The only two arguments that provides are host IP and port. If you require running on a single Raspberry Pi, this practically rules out using the first one. Tip: You can use to get a log of all files that the program touches on startup. Apparently it does touch like other Minecraft editions. can be used to find possible options, but there do not appear to be any to control the port number. So if we resort to modifying the executable: 

Unfortunately Minecraft Pi Edition's Python API is rather limited. Per the documentation there are only three fields to set via or , and you can confirm this by running and inspecting the output. You may have considered using and . Whether this works could depend on your particular mouse hardware, but from what I can tell changing the coordinate transform matrix would only affect the 2D cursor position, not mouse look (controlled instead by delta movements). Update: There's Phirel's patch to enable survival mode. It also happens to enable basic options in the GUI, including "Invert X-axis" (confusing terminology: invert Y direction ~= flip about X axis) You can read below for my other approach using SDL. 

The USB port on the Pi Zero tends to supply less power than that of a full Pi--regardless of how you are powering the Pi Zero--so expect compatibility with fewer USB devices. One way to get around common USB power issues is to connect through an externally powered USB hub. That failing, with a serial debug console run and see if there are any errors preventing the keyboard from enumerating properly. 

As your question is specific to Ubuntu MATE, I have confirmed a workaround but it won't work on anything older than a Pi 3. You can take advantage of Ubuntu's support for MultiArch. 

I don't have Lite, but it sounds like this is the same situation as when I press Ctrl+Alt+F1 to get a pure console session on full Raspbian Stretch. That is, by default I cannot scroll up more than a full screen at 1080p resolution. For me, it worked when I resolved this by editing /boot/cmdline.txt and appending After rebooting, this increases the scrollback buffer maximum size from its default 32 kB to 1 MB. Source: link 

If it then gives a message about a third dependency that is "not going to be installed", you can extend the command further with even more required packages. What often eventually happens it that it'll turn out that installing the set will require removing something else, indicated clearly by the message "The following packages will be REMOVED". As long as you don't run with the flag you need not worry about doing damage until you decide to select yes or no depending on whether the resulting packages are expendable. As Steve suggested it is possible to be in a state such that your packages are truly broken, but the majority of the time the "not going to be installed" error is conveniently resolvable and certainly worth investigating. As for building from source, that could still work too. Per your error messages and the tmux README you need to install at a minimum: 

One thing to add coming up lately is that Firefox 57 Quantum only works as arm64. Another: Recently the /r/raspberry_pi subreddit highlighted significant speedups specific to elliptic curve cryptography. However, likewise you'll lose out on other features or programs that may be less-supported with a 64-bit kernel (e.g. gaming with brcmEGL + dispmanx). 

You could try turning the verbosity up to level 9, not sure if that makes a difference. After running you should see messages going into . I don't have an RPi camera module to confirm with, but this procedure worked with UVC. However, logs may or may not help you resolve this crash. uv4l can be especially difficult to troubleshoot being closed-source. As Raspbian has a kernel-mode V4L2 driver and other tools available, I have suggested users in your boat try webrtc-streamer which is open-source and was updated as recently as last week. 

Lastly, on Windows keep an eye out for enumerated disks that may be unreadable. In addition to watching Device Manager, open up Computer Management and select the Disk Management pane. 

It would be hard to do justice here for 650 pages of the USB 2.0 spec. Broadly speaking, both drivers implement everything up to the protocol layer (enumeration, control/bulk/isochronous/interrupt transfers) for USB 1.1 and USB 2.0. The source code for dwc_otg with FIQ enhancements is more than 45000 lines. Apparently the source code for dwc2 is only about 22000 lines, despite also providing working support for gadgets (OTG). USB device driver code such as (where usb_serial_generic_read_bulk_callback() is implemented) is abstracted at a higher level, and not tied to Synopsys DWC or any particular USB IP. 

Caveat: that last approach may result in a toolchain that defaults to ARMv7 code, which works for the Pi 2 and 3, but not Pi classic/B+/Zero. 

Or if you have enabled full OpenGL with KMS, you may have to avoid the script at overriding with its own setting. More complicated, but you can inject the Mesa wrapper alongside like so: 

One workaround on Raspbian Stretch is to edit and comment out dtoverlay=vc4-kms-v3d. This will not only enable the examples, but also Quake 3 and other applications known to encounter this issue. While you could look into mesa-demos, it's understandable that those are not perfect replacements. Mesa has some support for VC4, but being a software renderer with compatibility as its main priority, it's not as fast as the legacy closed-source driver just yet. Links: 

A summary of what we learned via troubleshooting in the comments section: Although Chrome has automatic updating on Windows and macOS, Chromium does not auto-update on Raspbian nor any flavor of Linux. To force an update of Chromium, run: 

The source lines that are printing the error are here in libav Digging further, you can see that -12 corresponds to , returned here in lavfilters-ffmpeg i.e. it practically does Given this happens after 30 to 60 minutes and you're executing this on a Pi, is it possible you are actually running out of memory? What do you see if you run while streaming? 

(Caveat that this may interfere with other graphical applications.) In fact, the above isn't even sufficient for the PiSNES release binary which assumes the two libs in the wrong location. For that you'll have to redirect 's library search like so: 

Because that does not say VID=0525 PID=a4a5, it is probably some other device on your Windows 10 system and unrelated. 

In both scenarios you might run into errors attempting to unload the module if it's busy. Sometimes this can be addressed by terminating an associated user process, unloading another module that was implicitly loaded (), or other approaches found by trial and error. 

That means although the program requests a single buffer, V4L2 is insisting on three buffers! Perhaps the code was originally designed for a different camera, one like my own that permits as is. This revised program creates a loop to prepare all three buffers. To allocate and queue each one, we do VIDIOC_QUERYBUF, mmap(), then VIDIOC_QBUF. Once all buffers are set up, we can start the loop that pulls camera images from the circular buffer. Another way of looking at the revised code: it runs a sequence very similar to what's found in the strace log for . Comparing the strace logs did initially bring red herrings such as extra linked libraries or . Fortunately once those were ruled out, the ordering of and other system calls provided a useful reference implementation. 

It seems you've skipped the key step of actually copying in the 64-bit kernel and its modules. That eLinux article may also be out-of-date as the default Raspbian Stretch bootloader will automatically boot kernel8.img if present. If you aren't building a 64-bit kernel from source, you can download a working version from the original author of this article, here on GitHub. His image is based on Debian arm64, but if you intend to use this kernel with Raspbian make sure to copy in and from the Pi64 image. Some Raspbian functionality will most likely break, so back up your existing 32-bit kernel configuration prior. Back to part of your other question: 

So this driver expects all buffers to have been allocated by the time is called. That wasn't the case in the original code, while you'll see that comes before in the strace log for which does work. However, there's an additional mismatch in 's strace log: 

Second, if you have a 3-pin UART cable or ssh access over WiFi you can make changes in rapid succession without rebooting your Pi Zero, e.g.: 

In the CMake configuration you'll see missing variables like PYTHON2_LIBRARY. In order to link OpenCV for Python you'd need a cross-compiled as well! This is do-able and you could even pull the binaries off your Pi and use the mount trick for pointing CMake at the appropriate paths. Before we go down that route, may I suggest an alternative. On your Pi, you can install the appropriate Python bindings via: 

It appears the ZTE MF831 acts much like a router+modem, assigning your Pi the LAN address of in one instance. I'm assuming that your 4G connection is working in at least one direction. That is, with the stick your Pi can currently access outside web pages even with no ethernet connection and WiFi disabled. The next step is to get it working in the other direction. From webGUI ($URL$ a first straightforward troubleshooting step could be to put your Pi in the DMZ, like in this screenshot: 

To speed up your troubleshooting cycle in the future I have some recommendations. First, to rule out any image creation issues start off by mounting the boot partition directly e.g. 

and start a game, you can connect to that instance on port 4712 while the existing still listens on port 4711. (Note: If the new binary gives you a "failed to add service" error, it likely requires the wrapper. See the helper script at ) 

(Use 192.168.0.182 or whatever your cdc_ether (USB) IP address comes out to.) Note that this will expose all ports to the outside web, so if you happen to have activated SSH be sure to change your default password to something other than . Once configured, try accessing your Apache server on the static IP from outside. Just in case selective ports are blocked or the webGUI server conflicts on port 80, you can also troubleshoot with other ports. For example you could enable SSH () and try to from outside, or test Apache on a different port. After the simple DMZ approach has been verified, you should turn it off and go for the Port Forwarding tab to forward only selective traffic rather than the less secure DMZ forwarding all traffic. Forward port 80 for HTTP, port 443 for HTTPS if Nextcloud if it supports that. This may have been what @Deepesh was trying to say, just he mentioned the wrong port. Edit (to summarize as far as we got to in the discussion comments): Although the screenshot shows there exists a full-featured firmware for MF831 from 2016 or newer, some providers use older firmware or have removed features from webGUI. If so, it still might be possible to access hidden options via explicit commands. For setting the DMZ: 

This was not possible at the time of the original question, but the full Java-based Minecraft can run on the Raspberry Pi 3 today. With improvements to OpenGL on Raspbian over the years, LWJGL now just uses full OpenGL via the Mesa library. Instructions with video tutorials: 

Error 28 (ENOSPC) is "No space left on device". Grepping the kernel, the code flagging this error is in bcm2835/mmal-vchiq.cpp: 

where in place of 192.168.0.182 put your local IP address as revealed by . If successful, the command should print out: 

Looks like you resolved the problem by upgrading and doing a clean build? This Qt 5.9 bug sounds strikingly similar and appeared to affect all cross-compilation targets including Raspberry Pi. However, the fix was merged into the branch on August 15th, a week before your post. One explanation could be that you had cloned the repo earlier and while troubleshooting over the course of a week had not been doing a corresponding after each . Note that requires that you pass the flag if the submodules have already been init once. 

It's then straightforward to make a selection script similar to , which works by checking Caveat: Now that it's evident this path doesn't actually run the old closed-source driver, rendering performance won't be any better than if these examples were fully ported to use standard headers. The remaining benefits are that we can build applications with runtime support for both modes (like MCPI), and Raspbian's built-in GLES examples become a little more usable. 

Can be turned on again afterward via I have not tested this myself. If you don't find a better way and then rebuilding the kernel justifies the effort, let me know what issues you encounter. There might be trouble loading the driver after boot time or disabling while it is in use. Ideally there would already be a way to do this from userspace alone. You might be aware of this thread. Unfortunately, although you can disable USB power (not what you want), for data does not immediately work as expected. I have confirmed the same issue on my Pi 3.