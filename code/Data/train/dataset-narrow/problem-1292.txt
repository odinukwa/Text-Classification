but that results in a compile error because structs can't be null! which means that by you checking for null you are wasting cycles. so delete your null checks and cast the as a leaving you with 

I'm going to go out on a limb and assume you come from a java world based on your comments over your methods, and the use of your fields instead of properties. Neither of these things are bad, just not what we are used to seeing in the C# world. If you are using Visual Studio you can type a triple forwards slash and it will make a xml style comment that intellisense can and will use. example use would be 

this test takes 0.394 seconds to run and tells me that rotating a horizontal line on the x axis does nothing. Which is correct. So what happens if I rotate 1 degree on the z axis. (Which I can visualize easily in my head) I would expect the following test to pass (look at ) 

With this code you will not have to add more and more Lists to your collection class to add or remove properties. You'll only have to change the AdministratorGroup class to adjust those properties. Last point I want to point out is the confusing basis for your SQL method. By the name of it I get the impression that you are returning a single user and not a collection of users. but your code says that you are returning a collection of users. Don't let your names and methods lie about their intent. If you only intend to return a single user then return a class that is not a collection. If your intent is to get a group or a collection of things then you will return a list. Otherwise you are just making it hard for others (others can mean you in the future) to know how to use your code. Although I would break this method up some more to make it a little bit easier to read it serves its purpose. This is how I interpreted your code, and how I would have fixed it. 

still not the best test in the world, but it would serve its purpose very well. I could now change SerializeDemo and DeserializeDemo to work differently and as often as I wanted. As long as that test still passed I know that it works as I want it to. Also that test is fast. The test above runs in 37ms. It would be impossible for you to load up your program and test that that quickly. 

Now for the section is bothers me. The "LED" on the device is actually a RGB LED. So to get White i have to make 3 api calls to turn on Red Green and Blue. Same goes with any other color I want. Below is the code. I took out the boring non-relevant code. 

So I'm not going to show you what a interface is (since I am at work) but I can show you a small blurb of what i'm talking about. Note that the number I put into this are not meant to be accurate, they are just to get you started. 

I'll leave it to you to make that test pass. If you get stuck there is a big hint in the UnitTest shown above. What i love about unit tests is that they are fast and tell you very easily if all your tests pass. Example your test should say this if you run it: 

sorry for spelling and grammar i'm on a tablet. As for your unit tests you should always do your tests first. think of it like a school test. does your teacher give you a blank paper and tell you you have thirty minutes to finish. your unit tests are the questions on a test. your production code is the answer. asserts is your teacher checking your answers. so with your tests think to your self, how do i want to save my users, how do i want to load my users into memory, how should i add more users to my collection...etc once you get those questions written then write your code to do that. now in the future if you forget how a method works you can just go back to your unit test and see how you implemented it. i hope this illustration gives you a small step in the right direction 

Think small, Think one What I mean is that breaking up things into smaller chunks that all do one thing and do it well helps in so many ways. Now granted it can be taken too far, but for the most part if you break things down into something sort of vague and build from there. For instance if you think of uno as a few things such as "Game Rules", "Cards", "Players", "Deck" then you would at a bare minimum start with 4 classes. Those 4 things would do one thing and do it well. Like lets take Game Rules. You could have started with it calling each player in order and asking them to take their turn. It could have kept track of the deck and gave a player a card when it was requested. It could have also shuffled the deck of predefined cards (like it sorta would have been if you buy the game). After each player it could have checked if said player won or not. This would have made the class kind of big, but now maybe you could have seen that the user input is what is bloating the class. So you could have pulled it out in a user input class of sorts.. so on and so forth. The point is that if you think of the individual moving parts of a system and start there and work your way down while keeping in the back of your mind that you want things to stay small, and they should be responsible for one thing and one thing only then your code would look very different than it does now and potentially easier to understand at first glance Magic Numbers Magic numbers are numbers or string literals (for example: ) make a person wonder. "What does 12 mean?" or "What does 13/14 do?". You asked that question to your self at one time because you put a comment in to tell yourself that 12 means that the card is a Draw 2. So instead of putting 12 why not make a class (abstract class if you want, or maybe an enum) that contains some these magic numbers it takes the guess work and the comments out of your code. I imagine it looking somethign like this in one case