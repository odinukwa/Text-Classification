So the Z index is not a "true" z index which represents the depth, but the index of the children in the parent's children array. So if you try to put a child at position 3 in the array when there are only 2, it will be put at the end. Same when you try to put it at position 2. If you want a correct ordering, you will then have to put them at positions 0 and 1, no more, no less, or else the results will be counter-intuitive. EDIT: To apply this to your problem, then you put an actor at index 2, libGDX tries to put the actor at position 2 in the array. 2 being too big for the array, it puts it at the end. Same for 3. So that is why it is always the last one to call setZIndex that will be put last, and drawn in front. If you use 0 and 1, like I said, everything will work expectingly. EDIT 2: Summary: It is not a conventional Z-Index, it is the index in the ArrayList. If you try to place B or C in a cell that does not exist, like 2, 3, -1, etc., then the results will not be what you want. To put it more simply, you have to understand how ArrayLists work. ArrayList are indexed just like arrays, starting at index 0 and incrementing by one each time a value is added. In your case, You have a group A that contains a ArrayList of children containing B and C. B is (probably) the first one in the list, placing it at index 0. C is at index 1. If you call setZIndex(0) on C, then A will replace index 0 by C and push B at index 1. Simple as that. B will then be drawn on top of C. But if you call setZIndex(3) on B, A cannot place B at index 3 because it is too far in the list, there is no cell 3. Instead, it places it at the end of the list, at index 1. Then you call setZIndex(2) on C and the same thing happens. A will, in the end, place C at index 1, pushing B at index 0. C will be drawn on top of B. Source: $URL$ OLD ANSWER Simply because Z index is depth. The more depth, the further it is. An instance with less depth will be drawn on top of one with more depth. EDIT: Look at it like this. Your screen is index 0. Past your screen, behind it, is positive depth. In front of it, it is negative. If you put your hand in front of your screen, it has a smaller depth, but it renders in front. 

Since your game is 2D, I will assume, as I read in your comments, that there is no "camera". I will assume that you have a view rotation around the player called viewRot. Your player is the center of rotation as well as the center of the bullet. We will first rotate the bullet around itself because it seems logic to me to apply self transformations before others. To do so you will need the following (written in pseudo-code): 

Your problem is your translation matrices. You are not translating enough. Your quad starts at position (50, 50) and is of size (200, 200). That means we have 4 vertices: 

If you are doing something like this and dt starts getting out of hand (that is, higher than 10), you want to have some sort of mechanism to stop that. The simplest one is to change the line 

This will add a check whether or not the loop is going out of control and will bottleneck the entire engine. 

Looking at your example, the best way to go would be to have one script with a switch case. The example case you gave is simple and I don't really see the need to put it in another file. This would only cause the code to be difficult to maintain, mainly because each case would be in it's own file of 7 lines. For simple cases, keep them in a switch case. You can, however, put some of your cases in seperate files if they take too much space and harm readability. The switch case would then call the said script. Keep this in mind: concise code is ofter better, especially when programming video games. Yes, there are good things about OOP but making a class for one line of code is just absurd. KISS (Keep it stupid simple). 

This will test if the ratio is the same as the original image. The division will always return an integer value because both modulos returned 0. How can I render these sizes without them being blurry in my viewport? NOTE: This only needs to be applied if your camera viewport is not alreay pixel-perfect. Let's say you have a viewport with the following attributes: 

Please take note that the question was unclear and changed meaning 3 times, hence the 3 answers in one How can I verify that a given size is a multiple of another? This is a very good case to use the Modulo operator. Let's say you have a texture with size . Now you want to render the texture with size on the screen. You can verify that the draw size is a multiple of the original texture size using the following test: 

Source: $URL$ EDIT: Make sure your mutex is class or file-wide, as in the link given, or else each thread will create its own mutex and you will not achieve anything. The first thread to lock the mutex will have access to the code inside. If a second thread tries to call the lock() function, it will block until the first thread unlocks it. So a mutex is a blocing function, unlike a while loop. Blocking functions will not put stress on the CPU. 

We need to test if and are not 0 because 0 modulo anything will return 0. The Modulo operator returns the remainder of an integer division. So let's say your texture is 64x64, like in your question, and you want to render it with size 127x234: 

Games will not benefit that much by having 4 cores instead of two. Here's why. Basic Game Engine: 1 Thread The problem with graphics API like DirectX and OpenGL is that it must be runned on one thread, and one thread only. So a basic game engine will run all of the logic and render logic into a single thread. These engines will often use a time delta to synchronize the updating of the game world accordingly to the render FPS. Ex.: libGDX, SDL Update and Render Loops Game Engines: 2 Threads These engines pose a clear separation between the update of the game world and its rendering. They will sometimes separate these 2 logics into 2 threads to gain a small performance gain but mainly asynchronous rendering. This means that the game can render at 400 FPS and the logic will still update at 60 FPS. Ex.: Most high-end game engines, like Unreal, CryEngine or Frostbite Physics thread: +1 to X Thread Some games will like to put physics calculation in another thread so it doesn't mess with the updating or the rendering. Networking: +1 to X Thread Game with online gameplay will often use a separate thread because most networking engines are blocking, which means the thread will block until data is received. Disk IO operations: +1 to X Thread File management on large files can block a thread for a small amount of time, so most game engine will put disk IO operations on another thread. Summary Basicaly, most game engines will use 1 or 2 threads for the game's frame and will add some threads for other operations. But mostly, a game will only use 1 or 2 cores. If the game has heavy physics, like Frostbite engine for the BattleField series, then the game will start using more than 2 cores. CPU thread optimisation Mostly, a CPU will run different threads on different cores. But that may not always be the case. Like Joe Swindell said in the comments, games are not actually written to use cores, but when you write threads, you hope that they will run so that the CPU will distribute them to different cores. Conclusion What matters in the end is chosing the right CPU for the games you want to play or make. For small to medium games like Minecraft, then it is useless to buy a 4, 6 or 8 cores CPU. For high-end games, then 4 cores becomes the better option. If you want to program games, the more cores the better for compiling (depends on the compiler) but for the actual game, 2 cores is more than enough. Cache P.S. Yes, 4MB cache on 2 cores will be better than 6MB cache on 4 cores. But this is not the most important thing to look for on a CPU. It really comes down to the clock speed.