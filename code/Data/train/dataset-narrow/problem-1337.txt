If is a for example, you will get a error when trying to assign to (the names here are troubling as well). Let's explicitly raise an error if someone passes a value we don't currently support: 

I made some changes to improve your code overall. This wont improve performance, but these changes are worth noting nonetheless: 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

The code below is in two parts. I have pasted code with your old code commented out, and then additional comments for clarity. I have also posted a cleaner version with just comments. Note: From reading the code, it likely wont run properly. I was unable to figure out exactly what your loop is doing, and as a result there are still some bugs. Be sure to fully debug this code before using it. Full Version 

If I interpret this bit correctly, you're just testing whether there is a second dimension within the array, and if there is, you're looping through the array as a 2d array. Otherwise, you're looping through as a one-dimensional array. Wouldnt it be nice if we could explicitly say that in VBA? 

It compiles, since á’¿ != 2. But it won't work for every digit - see $URL$ if you want to try. Even if it did, I wouldn't recommend doing this in production code :) All in all it's a fun thought exercise, trying to find a workaround and kind of trick C# into doing something it's designed not to. But the truly elegant way is to embrace the language the way it is, and not try to hammer square pegs into round holes. If you were hell-bent on using extension methods, at the cost of being unable to rule out illegal values in compile-time, here's make take on it - more heavy-weight, but providing type and conversion safety. I did it for the heck of it, I know it's not the perfect solution. It resembles @radarbob's answer in that it puts extension methods to use. Let's define the basics (it can all go into one static class): 

We're kind of emulating Java's enums here (one of few features where Java actually happens to be superior to C#). And a little bit of help (so that we don't use reflection etc.): 

Again, is it worth it? Sometimes the clever thing is not to be too clever, and keeping it simple beats trying to make it pretty. 

Use existing functions/code where possible. This not only reduces the risk of bugs, but it can, at times, be more efficient. For example, denotes a and can be used instead of introducing an entirely new variable. This also makes your code easy to read. When I, as a reader, see I know what it is, whereas if I see I have to look for its meaning. Indent your code properly. I don't think this point can be over-stressed yet it doesn't always sink in properly. If you ever have code that is touching the window, aside from the Sub/Function declarations and Line Labels, something is wrong. For example: 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

How do you know the method you're looking for will always come up first on the list returned by ? If you only expect one, use . But indicates you consider the possibility that more than one method matches your given criteria. So, do we have some guarantee it would always be the first one in our way, or are we just "feeling lucky"? :) This looks pretty fragile to me. This is subjective of course, but I have to say that since this method is actually less functional than and the implementation is rather brittle, I would personally veto this extension in a peer review, since I don't believe whatever readability improvement it brings to the table justifies the trade-offs. I think this is a textbook example of what Jon Skeet calls evil code. It's not wrong as in "doesn't work", it's sort of clever, its "magic" can even have some appeal to it, but it's fundamentally unclear and dangerous. I highly recommend this talk: $URL$ If you really want such syntactic sugar, I'd ditch generics and reflection-based approach, and replace it with hardcoded extensions for , , - come on, it's not like there's dozens of use-cases anyway. Oh, and have them return a to distinguish between input actually converted to the default value, and not converted at all. Like so: 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

I've done my best to get you pointed in the right direction, but your code is difficult to follow as is. Here is what I have: 

This allows me to convert a range to an array, and then use those values more efficiently. Variants do have their place when used properly, but they shouldn't be used out of laziness. For example, in your code, (which should be ) and (which should be ) are used as numerics (and as such, should be Longs) but are declared as Variants. I assume, it is because they are then implicitly (without explicit direction) converted to strings, but even this doesn't justify the use of variants. You could do something like: 

Initial Notes The first thing that struck me about your code was that you literally have no variable declarations. Lines like : 

Again, this is a very simplified version. Usually I am extracting more data than just a few simple scores. The worst I've had was Day-Over-Day tracking of roughly 40 students on an assignment level basis. This is what led to the need for a dictionary over an array. 

without the constants and the converting them to their respective classes? What value do you feel this additional abstraction layer adds to the code? (If you got rid of it, you'd only need implemented as follows: 

Shouldn't this be a , or ? And why is it defined in ? It feels wrong if a parent class knows about its child class. 

Thanks to this pattern any new formats can be added as separate classes (supporting the interface), so the system is open for extension, and they can be registered within the factory. The base routine () is closed, which is what we want. The factory only carries one responsibility, which is to match any given file type to respective behavior, or file processing strategy. This means there is only one ever one reason to modify the factory: when this logic needs to be enhanced, or modified. 

What's the point of catching a ? When do you expect it to happen? I don't really like that this method mutates the list passed in as a parameter - and then also returns it, even though the returned value is actually redundant as the calling code already has a hold of the now modified list. You're kind of sharing the result of the operation in two ways at once, which feels redundant. And I know it's often done that way, but I think it's bad practice nevertheless, and can lead to confusion. Personally I'd prefer to be more explicit about what's going on, and either a) make a deep copy of the original list, and return an independent version of it (with entries removed), without affecting the original one - or b) make this method , like Collections.sort(). See command-query separation principle. Making a method look like a query can lead me to believe it's a pure function, with no side effects, whereas it actually does cause side effects, mutating the input data. The name is very vague - "remove", remove what? Is the blacklisted data ("FIRST", "SECOND", "THIRD") likely to ever change? In the spirit of making this code more modular I would consider extracting that list to a separate parameter. Single responsibility principle indicates that a method should have one clear responsibility, and one could argue that filtering out certain entries and knowing the blacklist are two responsibilities. Your mileage may vary though, depending on the cnotext - which I don't know. Not a biggie, but whitespace is out of control (, ), not to mention it's , not . Depending on how class is implemented, which I can't see - if it's a light-weight object and if its method would compare instances by their value ()... then we could leverage Collections.removeAll and save ourselves writing the iterative removal by hand. 

Finally, making these few small changes has a huge impact on the readability/maintainability of the code. Here is the finished product (identical in function): 

Option Explicit I cannot stress the importance of this being at the top of ALL of your code modules. What does is it causes a compile-time error when a variable is undeclared. This prevents run-time errors when you try to use variables that aren't set properly, and it will save you countless hours of debugging time. Go To Tools > Options Editor > Require Variable Declaration. You'll thank yourself later. Variable Naming Not to be a jerk here, but your variable names are horrible and difficult to understand. You have rng, rng2, rg, q, s, r, cell and the worst part is that you don't need all of them. I declared four variables total (and one of those you didnt even have a variable for, but you did need). Here's a tip, make sure your variables make sense. You should be able to look at them and have a pretty good idea of what they do. is easy to understand: it is the range we are searching in. is just as easy to understand: it is the cell we are currently searching in. Finally, , you guessed it, is the cell we found using our criteria. It is pretty much bulletproof when you start to code like this (actually, not really. You'll learn that bulletproof coding takes a lot more work than a handful of good variables.) and it makes your code easy to maintain. Additionally, there is no need to declare two variables if you need one. In other words, if is used only for the first loop, and never needed after that, I dont have to make a for the second loop. I can just use . General Names Just as Variables need good names, so do subroutines. It is all too easy to take the that the recorder gives us, and to leave it this way. When you have larger projects, and become undistinguishable, and god forbid you have a and as well. Name everything. That's pretty much my mantra. From Worksheets to Tables, and PivotTables, and Workbooks, to code modules, subs, functions, etc., give it a proper name. The sooner you get in the habit, the more time you'll save. Implicit Object References You'll likely hear this one a lot, so it is important to learn. Whenever you are working on an object, you must consider the scope of that object. While looks fine to the untrained eye, anyone worth their salt in the VBA community will point out that it is a unqualified Range reference. Even worse, is if we have and one step further is this nasty bit: 

Correctness Does it even work? Did you write unit tests for it? For example I can't see where the method makes any use of argument (other than to assert it's not null). 

Because the last two lines of code are the same for both cases. Then there's the loop iterating over the nodes sort of repeats in and . It's a bit of an awkward construct... which you already implemented once as . Why not reuse it? The class can just iterate over itself: . The clunkiness of traversing the list node by node gets abstracted away. The main takeaway in my opinion is that you should start writing unit tests for your code. It not only helps to catch out bugs, but also implementation inconsistencies, as it forces you to think about the contract and all the edge cases. I'd also put more emphasis on making code documentation actually useful for a hypothetical developer who'd want to use your code. Try to put yourself in their shoes: would you be happy having these comments to figure out how to use the class? 

But why would you assume that whatever time passed between opening the connection and disposing of the entire object, was consumed by query execution? Especially since you do this at the very end, after disposing of the connection, params object, transaction and command objects :) and the object is apparently supposed to be reusable (). Disposing 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

The only difference between the two is that the second is at least explicit about wanting a variant. The first is implicit. First bit of advice avoid implicit commands as much as possible. The reason for this is quite simple, there is a tendency to think that the computer is magically doing something it shouldnt be, but really you told it to do exactly what it is doing and as a result, you have a bug that can be nearly invisible. Consider for example :