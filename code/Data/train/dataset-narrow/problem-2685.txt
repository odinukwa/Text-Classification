I'm not familiar with iOS specifically. For my Android game, I tried the "make big images and sample it down" thing people usually say. It looked quite odd. For my current iOS/Android game, I'm using vector images instead; I create them in Flash (CS3), then rasterize them in-game depending on the size of the size of the device's display surface. It works quite well, but you need to rethink how you lay things out. An alternative method I tried in the past is keeping multiple sets of assets, and dynamically picking the right set at compile time -- so making an HD build and a non-HD build. You can try all three methods and see what works best for you. It's not just about graphics, it's about sustainably maintaining your workflow with your tool chain. 

Forget all that expensive software. Either it's expensive, and you take a hit, or you get used to high-end software, and can't use anything else. Like I said in my comments, just start learning Blender 3D. It's actually not that bad, the interface just takes a little while to get used to. If you already know concepts like materials, textures, spot lighting, lofting, etc. then you'll feel right at home. 

If you want to force the player down a path, just create one path and let them go at it! Any other paths must logically end in dead-ends or else route back to the main path. It depends a lot on the type of game, too. In a rogue-like, for example, you can generate a single path of rooms leading to the exit, and just branch out dead-end rooms. In an RPG, you can (as is typically done) block wrong routes with objects/people/etc. so that the user can't take them. 

When I'm creating games, I really love the coding part -- designing, developing the main functionality and "core" part of the game. However, most of my games are reasonably small/easy in terms of coding, but require a lot of content -- whether graphics, levels, sounds, puzzles, story narrative, etc. I find development speeds through the coding parts, but nearly halts when it comes to content creation -- it's tough, sometimes boring work. What can I do to make content creation quicker and more interesting/fun? I'm already integrating content into a working game, and building/using tools as much as possible to quickly assemble my content. Edit: my question is not about learning any particular labor-/time-intensive skills like drawing assets or picking out sound effects; it's about that psychological hurdle when you have to just sit down and grind out the rest of your game, even if it's not the most fun thing in the world to do. 

I'm not sure where the problem is that you're asking about. If you need the data, you have to load it. I would personally keep NPCs in a separate list, and track them separately from all the actual tile data. That's how I make these kinds of games. Because you only need to draw the tiles on-screen; but entities (NPCs) may have collision logic, events, etc. and should always be tracked, regardless of their position. If you're worried about performance, then I say, don't; just code it, and if problems arise, you have working code to profile and optimize. Edit: The way that I would code it would be to have a 2D array of tiles; each tile has the XY coordinates of the image that it displays, a "walkable" attribute, etc. NPCs/entities would be kept in a separate list, and they would either hold a tile XY coordinates for the tile they're stepping on, or hold a reference to a Tile object with an X and Y. 

They usually handle this through spatial partitioning. The theory is simple: would a bullet in the top-left corner of the screen need to check against the ship, in the bottom-middle of the screen? Not really; they're too far apart to possibly collide this frame. How do we solve the problem of "figure out what objects are close enough to collide with other objects?" Simply, with a grid: 

Flash SWFs are small because graphics are vector and only animation diffs are stored. What this means is that you should recreate your animation in your platform. Anything else will requier redundant storage and a huge file-size. 

Ultimately, it's your game, and you decide how you want it to play out. I like the explanation given by some games (like Epic Fantasy Battle) that "a resistance of more than 100% is absorption." For example, a fire resistance of 100% means you take 0 damage; 200% means you absorb the full damage and are healed by that amount. Or alternatively, you can choose to model your game without resistances over 100%. 

Then a.RightLine and b.LeftLine both point to the same reference. Or, if it's a boolean, when the user clicks on the line, make sure you update both A and B to keep track of that fact. Another solution might be to keep a hash-map of lines, where the key is the indicies of both boxes plus the line side. So the above example would be something like: 

I'm interested in using Ruby for 2D games. I have to pick between Ruby/SDL and RUDL, both of which are Ruby SDL wrappers. Which is better? Better means "less bugs" and "more usable," although the latter is a matter of taste. I notice that Ruby/SDL was last updated in 2012 (according to SourceForge), and RUDL in 2010; other than that, I don't know much about either. Please share your experiences, good and bad. 

I ran into the same problem as you. Thankfully, I had an existing XNA project that already used a .spritefont file, and generated the XNB file. I just compiled it, and copied the XNB into my MonoGame project, and I can use it without any problems. (Disclaimer: I tried building the XNA content pipeline for MonoGame 3.0 beta as per instructions, and after a few hours, I gave up; it wouldn't include the project properly in Visual Studio.) 

Copyright expiry depends where you live. The simple answer is that they are copyright, and you can get sued. (More likely you'll get a cease-and-desist shutting down development of your game and threatening legal action.) If you really want a pokemon-style game, create your own unique game world and characters and use those. 

I used FlatRedBall, which has an amazing concept of Screens. Instead of worrying about loading/unloading textures, you instead write code like: 

What do I need to do to tint them, and make them look good, during different times of the day? Are there any "known" formulas for any of these times, like "delete the green blue component and tint heavily red+green for a sunrise effect"? Ideally, I have just the original sprites, with no additional information or images (like spot-highlights or shadows separated out). Finally, I'm using Silverlight/FlatRedBall for this, so I do have access to per-pixel information, as well as RGB tinting (adding, subtracting, multiplying, etc.) 

First, a comment: it doesn't sound like you're using an entity/component model. I highly suggest that, because it will help you with your design, and it will also address this problem. The "core" problem is not "the current representation of the player (on the map) now needs to go into battle." The problem is sprites, etc. are all specific to your current "view" (let's say the map view, as opposed to the battle view). What I suggest is this: distil your Player class down to the core, permanent attributes that are there regardless of which view you're looking at. This will likely include: 

If you're using A* path-finding (or something else which is pretty quick), and you're detecting the paths multiple times (not just once on startup/creation of your map), simply mark any locations which have units in them as non-walkable and let the path-finder work around them. This will require pretty much constant recalculation of your paths, so make sure your performance doesn't sink if you decide to do it this way. 

I'm using RPG-Maker-XP-like sprites (any 2D adventure/RPG style sprites). I would like to tint them so that they look different at different times of day. Times of the day are the set of: 

C#/XNA doesn't matter too much. I assume you want to build a (2D?) RPG, with events, and a map/event editor. If that's the case, you need to create an event API, and tools to create/consume it. For example, you will probably create a "show message" method (takes a string to display when you talk to someone); your map editor will allow you to place this event somewhere, specifying the text; and the game engine shows it when you step on that location. Scripting languages are good (you might be making your own mini-language), but anyway, that won't prevent you from having to write your own "event API." This is how I do it, and this is also what RPG Maker XP does.