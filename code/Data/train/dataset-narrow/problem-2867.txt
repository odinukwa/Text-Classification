Finally, (leaving out a few layers of abstraction), here's an excerpt from my main loop (EDIT: I've made changes based on @Roy T.'s suggestions, as well as the well-known GafferOnGames article): 

You may want to double check the string manipulation code, although I highly recommend where possible with since you won't be using it in a very performance sensitive area. I've also used which is better because you don't have to pick their max length before compiling the code (amongst other things). Don't forget to include and at the top of each file if you use them as follows: 

Generally, normal mapping works great, but there are subtle lighting errors on parts of the mesh after the incorrect tangent space transformation. Hopefully this is all of the information needed to get to the bottom of this. 

The easiest way to do this is to use String.split to find out the different parts of the date. The following is pseudo-java but it should give you the idea. 

You close your font with at the end of your constructor. Remove that, and then the rendering should work. You want to move the closing code to the destructor. Also, you release your first at the end of the -classes constructor, and then you do that again in the beginning of . You're essentially trying to delete already deleted memory, which obviously is something that might crash. You don't really even need the -member, it could just be replaced with a locally scoped variable. 

I've managed to get it working, thanks to @UnholySheep for convincing me that I was on the right track which helped me through some head scratching. Things move smoothly now, and the balls don't stick together either. I've changed my function to return a if there is still a collision/overlap so that my main game loop will iterate again, up to a specified limit. (EDIT: I've made it a lot simpler, and more accurate - the balls are pushed by the penetration depth, which works in 1 step for several balls) I've also changed the function to push the balls by a tiny amount instead of placing at the edge of the other ball, because even though that worked for two balls, it causes multiple colliding balls to 'jump' to the next empty space instead of moving naturally. Here is the changed function: 

According to this thread it seems that creating OpenGL contexts from foreign windows isn't currently supported in SDL. 

Remove the from the other conditions, as only the first condition triggers. That is because something greater than or equal to three is also greater than two. 

For some reason the tween library requires you to update the tween inside your function, and calculate the time using something like the following: 

According to various different threads it seems that there is no OpenGL initialization code in , so OpenGL context initialization won't work with that method. If you are building your own SDL binaries, you might want to consider modifying the function by adding the correct flag to the correct place in that method. It seems to be what people experiencing this same problem have done. Why are you not using SDL for window creation? Letting SDL handle the windowing makes it easier for you to develop, and it will also make your project more cross-platform. When you create the window using , just remember to pass in the flag to the creation, and then you should be able to create your OpenGL context just fine. 

I am trying to implement Exponential Shadow Maps and I've got it almost working. The part I am stuck on is the "optional" separable Gaussian blur of the depth map to give soft-looking shadows. I am using an OpenGL Framebuffer Object attached to a temporary depth map, and I am trying to use a screen quad (two triangles) with the original depth map as an input texture. Then, I am doing the same for the second stage of the blur, with the input and output reversed. Unfortunately, this results in a depth buffer filled with 1.0 which suggests to me that nothing is being drawn. In this example code I've found, they are using a color and depth attachment in order to draw to a screen quad with a blur shader. (unfortunately the only OpenGL example I could find) I want to know if this is necessary or that they are only attaching and blurring the color buffer because they are storing their depth values in it. In other words, I would like to know if it is actually possible to only use a depth buffer Framebuffer Object attachment in this scenario. 

You need to add an event loop for your window. The following code is directly from a pyglet quickstart tutorial. You basically need a function that gets called periodically. After that you can then just ask pyglet to run the application. Here's a basic draw function: 

It means that all existing textures are freed. I checked the SDL source and inside the function they do this: 

I think your problem is the fact that SDL_SetPaletteColors wants an array of s as an argument instead of pointer to a single color. I cannot guarantee that this is the problem as you didn't post the code where you initialize the code, and you haven't told if returns an error message. Otherwise, make sure to always check what returns on a SDL function you think might be the cause of the problem. 

Using a dummy 1x1 texture with the color (128, 128, 255) - this will lose Phong interpolation. Switching shader programs for normal mapped and non-normal mapped surfaces - I get the feeling that I'd end up duplicating a lot of code this way, especially when I start implementing specular maps, parallax displacement maps, etc. 

Some things to consider: Do you really need to draw millions of points? Perhaps you could get away with only drawing the points on the surface, in which case you check to see if , and only draw it if it's true. Secondly, depending on how you're generating the points, you could generate them at initialization and sort them once before any rendering is done. Ensure your vertex array is sorted back to front and the frontmost will overwrite the ones back further back. 

Here's a small pseudocode example of something kinda similar to the system I'm using for my game. Basically the important trick here is to check both the topleft of your player, and the bottomright of your player, which is enough as your player is rectangular and of the fitting size. If the player character would be bigger than two tiles, you would have to check more tiles. 

One obvious issue I see in your code is in the event loop of your method. You're using where the common pattern for event looping in SDL is . Without more code it's hard to say if something else might cause the problem, but that one line might just be your problem. Even if it isn't it's better to process more than one event per frame, otherwise the user might experience annoying input lag. Just making a wild guess here, but I guess it also might be a problem with your class, perhaps not reseting some variables. 

I have normal mapping working in my game, but I want to only use normal mapping for some surfaces, and not others. Right now, as far as I can tell, my shader is applying an incorrect normal of (0, 0, 0) in tangent space to my non normal mapped surfaces, since no textures are bound to the sampler. Is there a suitable way of detecting that nothing is bound to a sampler in GLSL and then using a flat normal instead? I've also found old posts around the web recommending the following: 

Changing the working directory worked for me recently: Go to -> -> . Then click on the left hand panel and then finally enter the path of the files under . All of your paths are then relative to the path you entered. 

EDIT: The following only works when executed before calling . Seems like SDL has made a simple and trivial task quite hard. SDL wiki suggests that calling should do the trick. You might also want to try SDL_SetHintWithPriority, which will override any possible environment variables that have been set that could prevent that value passed in to to have an effect. 

Colouring SDL textures might be a little tricky. The following code should outline the main points of colouring a texture. The key is to fetch all required data from SDL before starting to alter the texture. 

This assumes that you already have created an called with the correct viewport size. Awesomium then offers an utility method that you can use to put the pixel data to the texture. You're right on the fact that the texture needs to be created with the flag. I also used the flag on the texture. Anyways I find that this approach is somewhat cleaner atleast for someone who's not familiar with Awesomium's class design, as it's mostly using SDL calls and then just a simple call to an Awesomium method. After that you're just free to render your texture to the screen. Oh, and if you would like to use the Awesomium custom class structure, I'm sure you can figure out how to adapt this example code to put into use there. 

To find the normal, you can use the cross product of three of the points in the polygon. Create two vectors from those three points and find the cross product of those. To find the intersection of the ray with the polygon, you will first need to ensure it intersects with the plane of the polygon. To do this, you will need to do some algebraic manipulation of the equation of the plane as seen here. Your ray should be defined as R0 + tV = P, where R0 is the origin of the ray, V is the direction of the ray, P is an arbitrary point on the ray and t is an arbitrary parameter. The plane has the equation P . N + d = 0, where P is an arbitrary point on the plane, N is the normal of the plane (calculated earlier) and d is the vector offset from the origin. We want to substitute the ray equation into the plane equation (replacing P) to get: (P0 + tV) . N + d = 0 and find the value of t: t = -(P0 . N + d) / (V . N) then you substitute that value of t back into your ray equation to get the value of P: R0 + tV = P. Finally, you want to go around each adjacent pair of points in the polygon checking that P is inside the polygon, which is done by checking that P is to the same side of each line made by the points. When the instructions say to check that the point "to the left of every edge", imagine that you rotating the polygon and testing the edge that is the right-most. That might help you understand why we test that the point is always on the left of the edge.