The reflection workaround assumes that the system class loader is an URLClassLoader and that you have the privileges to call its method. That's not necessarily true, especially for a server environment. And, uh, I don't think it really needs saying, but the error handling is... less than optimal. ;-) 

If you expect repeated lookups for codes—and that is probably why you have codes—consider a lookup map: 

Also be wary that is subclass of , as distinct from . If you rely on interrupts to abort, you may have to handle both exception types. 

The use of s also helps you impose time constraints and handle exceptions thrown during execution. (Note that you'll typically want to use or as is a minimalistic interface.) To paraphrase your example: 

Assuming that users manually edit the records you serve them, you have the risk that someone opens a connection, finds out she's out of coffee, and heads off for ten minutes (or lunch for an hour). That leaves a connection stuck until she returns or it times out. If we move the user interaction to be offline, we limit chances of hogging your worker pool: 

Bubble or Insert? #1 and #2 are both implementations of insertion sort (*). The way you insert the element is not so important: whether you copy one by one, use , or bubble it down is up to implementation. I'd imagine to be the best for larger inputs. #3 would be closer to selection sort, a relative of insertion sort, though there's no advantage in allocating a new array. (Or maybe I misunderstand.) Both build a sorted part in the array, guaranteeing that at step , is sorted. Both do their sorting in-line, not requiring extra array allocations. And both select an element from the unsorted part and then insert it. The difference between insertion and selection is in how they select the next element to be inserted. Insertion sort doesn't care which element is next, so it selects whichever. Selection sort specifically select the littlest element from the rest of the array. This makes it more costly, but adds the additional guarantee that not only is in order, but it also contains the littlest elements of the entire array. (*) Though #1 is related to bubble sort in a way his parents won't talk about. Optimise? A strong point of insertion sort is that it performs very well for input that is already (mostly) sorted. #1 unconditionally runs in quadratic time: , which is in the order of steps. #2 is smarter about it, and doesn't run back comparing if it won't need to. This means it has the potential to run in close to linear time. Specifically, it will be in the order of steps, with being the number of elements out of order. #1 can be 'fixed' with a simple addition: 

Access to is unguarded. It should be marked as volatile, or wrapped in an AtomicReference, or accessed only through a lock or synchronized block. The executor is created from within the class, but there doesn't appear to be a way to shut it down. Consider passing an existing, externally managed executor through the constructor. If the executor is to be created and managed internally, and you'd like to lazy-load it, consider using a holder class, like this: 

I see no clear algorithmic reason why the time limit is exceeded. Ralf Kleberhoff points to the probable culprit : 

Yes. It's commonly thought that thread safety relates only to read-write cycles, but the only assumption you can reliably make without synchronisation is that a thread can at least see its own changes; everything else is maybe-sorta-possibly at best and a politician's promise at worst. Processor cores may--and often do--take copies of data from main memory to work on. Even if a thread does decide to write through to main memory, the other threads need to catch on that something has changed, and reload it when needed. Otherwise, the other cores will happily chug on with their local copy. So access should still be controlled, though it doesn't need to be via the keyword. A field that is either written independently of its previous value, or written only by the same thread, can be safely guarded by . I'd say there are three main ways to accomplish what you want, in varying degrees of features and safety: 

The other code in your method takes care to take only a single step and check power levels each time. This part, however, does not seem to do so. There's a different level of abstraction here, and that's a good place to start looking for implicit assumptions and/or incompatibilities. Log those exceptions. You never know what is hidden there! 

(*) Because the set of possible combinations is enumerable, you can assign a unique number to a combination, given an alphabet and a pattern length. Meaning you can have a mapping function, i → combination(alphabet, k), as the base of an (spl)iterator or even a java.util.List implementation with a very efficient operation. But that may be beyond the scope of this answer. 

This is it for data, but what about the code / behavior? We'll go back to the problem statement and refine it: Quarantine simulates the passage of time. When time passes, (a) treatments applied to patients take effect, and (b) patients are affected by their ailments; some ailments, when untreated when time passes, will kill patients. Treatment is applied to patients. Some treatments include medication. When medication is applied to a patient, it may cure them, have no effect, or kill them, depending on (a) the ailments of the patient, and (b) other medication applied to the patient. Some behavior looks straightforward. Quarantine controls the passage of time. Time passing is when effects take hold. The rest is trickier. Medicines may interact with each other and affect the patient. Medicines and ailments may interact and affect the patient. Who gets to decide what? 

I'm not sure how strict the requirements are. Right now, your code gets two words on two different lines, while the example gets two words from the same line. I've used in the suggestion below, but will work as well. Some comments will help with eyeball scanning. ;-) 

Documentation Auto-generated getter and setter comments are not useful as documentation: they simply repeat the name of the function. Remove these to reclaim some vertical space. Document what things like mean in your method parameters. Does it make sense ever not to pass a boolean in there? 

Your user has finished editing a record and sends it over. Your user is freshly starting and wants a new record to edit. 

You are a more patient person than I am. There are two ways to deal with scenario's like this, depending on the relation of your data to your application: 

Using BigDecimal essentially guarantees we'll follow the specs laid out here. That makes the code a lot easier on us (stripped the comments for brevity): 

With many more activities than time slots, most of our time is spent checking for conflicts. We can ease that out by using a bit set to represent used times: 

Good candidates for enhancing performance in algorithms like this is to reduce the number of objects you use. In this case, that primarily means limiting the use of wrapper objects in favour of primitives. I pre-generated 500 vertices randomly to use as a consistent stress test, which your implementation managed to solve in about 8700ms (give or take 100ms) on my laptop. I'll use that as baseline. L106: -- Declaring k as an cut running time by about 10%, down to 7800ms. L62: -- Changing adj to be an with simplistic array-copy-and-add operations took another 40% cut out of running time, down to 4800ms. I imagine some smart sizing could do more, but will add complexity. Defining your constants as tweaked performance by another 5%, down to 4550ms. (There were some other minor tweaks I've tried, but nothing that gave an appreciable performance increase for the additional code complexity / bug odds.) Total savings: about 45%. Speaking of complexity, I found the code a bit hard to follow—s, t, pi[] ?—without studying the underlying algorithm, so I haven't really hunted for algorithmic or implementation shortcuts. On an API usage note: maybe is a better choice than for reading your vertices: 

This is good code, because it does what it says on the tin. I do have two remarks: The in isn't necessary. Some people swear by adding it anyway, so it's a matter of style. The other remark is that you loop over twice as many elements as needed because you set to before looping. You can hold off until after: 

It writes to rather than using the result set as a local. It then loops over these results, but returns only the last row. You appear to use as a type; consider making a separate, named type for it. 

We'll also need a way to get such an axis. Since the axis represents an axis in our tile map, that feels like the place to provide them: 

If you're wondering about the performance of HashMap : it is the same as HashSet. In fact, HashSet uses a HashMap under the hood. 

Ideally, remove the field. If you have a clear and compelling use case that can not be reasonably solved otherwise, keep the field for now, but clearly document the why and the how (and use the pseudo-tag), and consider adding it to your project's to-do list. This really feels like a bug waiting to happen. It should not be a factory's duty to keep track of what type you are currently interested in. Either the container (configuration) or the client code should know what it wants/needs (and pass it into the factory method): factories are middle men. 

The code looks okay, and it passed the test, so it is good enough as far as the test is concerned. That said, the code is a bit fragile on input, and it can be further optimised. Fragile: Pattern creation Because you create a pattern from an input string, you can end up with an invalid pattern, or a pattern that doesn't work as advertised. A line of will trip up this program. This doesn't appear to be a problem in the tests your code was submitted to, so it may be valid to assume input is alphanumerical us-ascii. Performance I've found two alternatives to perform better (with my own randomised data-set(1); your mileage may vary): 

Yes, if you supply the alphabet/element set as input to your function, and treat your output as indices into that alphabet. Right now, your output is a list of numbers per combination (rather, a string, but see later). This makes them feasible to use as an index into an arbitrary list. In the least intrusive form, without modifying existing code, you can add this function that will do what you want. (It's not efficient, though.) 

Reconsidering the Design The basic principle behind object-oriented design is, put bluntly, to stuff the code where the data is. Store the (source) code with the data it operates on, so that people that reason about the code (that includes the designer!) have to keep fewer things in mind at the same time. Ideally, this leads to robuster and/or simpler code. If OO is all about putting the code with the data, then how do we decide which code to put with which data? A good short-hand is to think of objects as having responsibilities. Think of it of asking questions such as: "Who gets to decide what happens?" (who has the code) and "Who knows this?" (who has the data). Examples: 

flips the bits on as it increments digits. It looks at the difference of prime factors between the digit it comes from, and the digit it is setting (always one higher, except with nine), and flips the relevant bits if their difference is odd. For instance, going from 2 to 3 means flipping 2 and flipping 3. Going from 4 to 5 means just flipping 5, because 4 = 2² , an even power. Here's an example implementation: 

You're right in sensing there has to be a better way to do this. Right now, you're setting static fields from within instance methods, which is rarely a good idea. Luckily, your code is already sufficiently structured that fixing this requires very little work. Explicitly pass an instance containing a and as a parameter in the method. This keeps your algorithm as it is, but it limits the scope of changes so that they stay within local execution: 

(*) This is purely in terms of processing speed. LinkedList has the better algorithmic complexity for these operations. ArrayList has the speed advantage in these circumstances. 

This will be a pretty significant part of your implementation. I'll take it at face value and assume it's just looping on , but this is going to be the meat of your stuff. Correctness of code 

Once you have potentially valid types, it's time to figure out how to instantiate and present them. Reflecting on what you found So suppose you have a list of classes that extend and we may or may not be able to accommodate. Unfortunately, won't help us here: to be overridable, it needs to be an instance method; to use an instance method, we need an instance. Egg, meet Chicken. Much like we'd do with JavaBeans, we can gleam some information from your classes using reflection and convention: 

I'll freely admit that my following suggestions are hunches. I hope they make some difference, but they may be negligible. 

try-with-resources guarantees that the local variables are available and defined over the scope of the try block, and that they are closed before leaving the try block. In the uncommon case that acquirable resources do not implement , you can fall back on try-finally, available since the old days of yore: 

Additionally, and have the requirement that they should throw when the stopwatch is not a compatible state. Our stopwatch will need a notion of running to do this. Let's look how we can modify the stopwatch class to adopt this behavior. I've annotated some below: