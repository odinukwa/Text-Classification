This was too long to post as a comment (in response to your comment), so I'm posting it as an answer. Turing's proof of the Halting Problem is not mathematically fallacious. Here is the paragraph in which you explain why the proof bothers you: 

It follows from Rice's theorem that you cannot determine whether or not two Turing machines decide the same language. My question is: Does this also apply in descriptive complexity settings, particularly when it comes to testing a pair of SO-Horn queries to see if they describe the same language? I'm not aware of any descriptive complexity version of Rice's theorem, and I could conceivably see that it might not be all that difficult to test two second-order formulas for equivalence. 

Again, my question is whether or not this is a reasonable proposal. Obviously, I have no ability to cause experts to adopt what I suggest; however, I'm hoping that experts will read what I've written and decide that it's reasonable. 

Suppose that P = NP is true. Would there then be any practical application to building a quantum computer such as solving certain problems faster, or would any such improvement be irrelevant based on the fact that P = NP is true? How would you characterize the improvement in efficiency that would come about if a quantum computer could be built in a world where P = NP, as opposed to a world in which P != NP? Here's a made-up example of about what I'm looking for: 

This is not an answer. It is an elaboration of the question, that looks interesting to me and maybe should deserve more attention than it actually received. First of all, let me say that there is an important condition in Barendregt's definition that has been omitted by Brennan, namely the fact that $\lceil M \rceil$ must be in normal form, that immediately rules out the identity function as an adequate encoding. Now, the question can be more precisely formulated following Cody's suggestion. Given two encodings, are they recursively isomorphic? In other words, suppose to have two encodings such that $$_1 \lceil M \rceil_1 =_\beta M \hspace{1cm} and \hspace{1cm}_2 \lceil M \rceil_2 =_\beta M$$ does it exists a lambda term $F$ such that for any term $M$ $$E_2 (F \lceil M \rceil_1) =_\beta M$$ and vice-versa? If the answer is not, what are the "minimal" abstract requirements that must be added to ensure it? 

The semantics of a large subset of Ocaml, called OCamllight, was formalized in HOL by Owens several years ago. More recently, a type theoretical semantics of a smaller subset of Ocaml was implemented in NUPRL by Kreitz, Hayden and Hickey. Is there any similar development in COQ? 

This is a derandomized construction of a non-uniform $AC^0$ isomorphism theorem due to Allender, Agrawal & Rudich [2]. I am curious if any work has been done regarding isomorphism with respect to $AC^0[\oplus]$ reductions. The only strategy we have to construct an isomorphism (that I've seen) essentially employs a resource-bounded Schroder-Bernstein argument, which requires that completeness of a problem $A$ for $\mathcal{C}$ under, say, $r$ reductions (where $r$ is a complexity measure) implies completeness of $A$ for $\mathcal{C}$ under 1-1, length-increasing, invertible $r$ reductions. So I'd be specifically interested in results of the following form: 

Manindra Agrawal, The First-Order Isomorphism Theorem. FSTTCS 2001, LNCS 2245: 70-82. Manindra Agrawal, Eric Allender, Steven Rudich, Reductions in Circuit Complexity: An Isomorphism Theorem and a Gap Theorem. JCSS 57: 127-143, 1999. 

This is only a partial answer (to the $PSPACE$ characterization), but I don't have the reputation to comment. $PSPACE$ has the following (equivalent) descriptive characterizations: 

$FO[2^{n^{O(1)}}]$, first-order logic with exponentially iterated quantifier blocks. $SO[n^{O(1)}]$, second-order logic with polynomially iterated quantifier blocks. $SO[TC]$, second-order logic with a transitive closure operator. $FO[PFP]$, first-order logic with a partial fixed point operator. $CRAM$-$PROC[2^{n^{O(1)}}, n^{O(1)}]$, concurrent-read concurrent-write random access machine with exponential time and polynomial hardware. $CRAM$-$PROC[n^{O(1)}, 2^{n^{O(1)}}]$, concurrent-read concurrent-write with polynomial time and exponential hardware. 

In a system where Type:Type, the typing rule for the product would be trivial: $$\frac{\Gamma \vdash A:Type\hspace{1cm} \Gamma, x:A \vdash B:Type} {\Gamma \vdash \forall x\!:\!A.B : Type}$$ Unfortunately, Type:Type is known to be inconsistent, and Type must inhabit some different sort, say Type:BigType. Then, the following case of the product becomes problematic: $$\Gamma \vdash A:BigType\hspace{1cm} \Gamma, x:A \vdash B:Type$$ You may either conclude that $$ (*)\;\;\Gamma \vdash \forall x:A.B : BigType$$ or $$ (**)\;\; \Gamma \vdash \forall x:A.B : Type $$ The first approach, where you take the maximum among the type of A and B is the so called predicative approach, giving rise to a strictly stratified type theory. This is indeed consistent with our intuition of types as data structures. The second approach is "impredicative": since Type:BigType, if B:Type, we get $$ \forall X\!:\!Type.B: Type$$ but this expression is quantifying over a collection of items (Type) comprising the product type we are defining as one of its elements. Note however that is not so unreasonable in case you are interpreting Types as propositions: if $B:Prop$, then $\forall X\!:\!Prop.B$ looks like a legitimate, higher order proposition, hence it looks quite "natural" (for everybody who is not a constructivist) to conclude that $\forall X\!:\!Prop.B : Prop$ In fact, (**) is not inconsistent (system F adopts this rule). The only price you have to pay is that you must renounce to have strong elimination rules. In Coq terms, you cannot extract from a proposition anything but a proof of some other proposition. As a corollary, you have no way in Coq to prove that two proofs of a same proposition are different from each other. 

First, a streaming algorithm running in space $s(n)$ for a problem $C$ implies a communication protocol for $C$ using $s(n)$ bits of communication: Alice, on input $x$, runs the streaming algorithm on $x$ and then hands the configuration of the machine at the end of the stream to Bob ($s(n)$ bits), and then Bob, who has input $y$, runs the streaming algorithm starting from the provided configuration, and returns the result. Therefore, communication lower bounds imply streaming lower bounds. Second, consider the following problem, called INDEX: Alice gets an $n$-bit string $x$ and Bob gets an integer $i \in [n]$, and they want to determine value of the $i$th bit of $x$, $x_i$. I'll quote the following result, which can be proved using an information statistics argument. Claim 1: Any randomized (1/3-error, say) protocol for INDEX requires $\Omega(n)$ communication. Now we can reduce from INDEX to the triangle-free problem. In particular, given and instance $(x, i)$ of INDEX we can build edge sets $E_A$ and $E_B$ over $V = L \cup R \cup \{s\}$ where $L = \{y_1, ..., y_{\sqrt{n}}\}$, $R = \{z_1, ..., z_{\sqrt{n}}\}$, and $s$ some constant node (so $2\sqrt{n} + 1 = O(\sqrt{n})$ nodes) with the property that the resulting graph $G$ is triangle-free iff $x_i = 1$. Additionally, Alice can compute $E_A$ herself and Bob can compute $E_B$ himself. To do this, pick some pairing function $p: [n] \to [\sqrt{n}] \times [\sqrt{n}]$ and say $p_L(k)$ is the first element in the pair corresponding to $p(k)$ and $p_R(k)$ is the second. We'll use this to map bit positions to edges. Then let $E_A = \{(y_{p_L(k)}, z_{p_R(k)})\ |\ x_k = 1\}$. Note that this is a bipartite graph. Now let $E_B = \{(s, y_{p_L(i)}), (s, z_{p_R(i)})\}$. $E_A$ has no triangles, and $E_B$ forms a triangle with $E_A$ only when theres an edge between $y_{p_L(i)}$ and $z_{p_R(i)}$, which only happens when $x_i = 1$. An $o(n^2)$ communication-protocol for determining if a graph is triangle-free readily contradicts the INDEX lower bound: Alice gets $x$ and Bob gets $i$. Alice and Bob compute $E_A$ and $E_B$ respectively with no communication. They use the triangle-free protocol as a subroutine, using $o(\sqrt{n}^2) = o(n)$ communication. 

The problem was also solved in my article "The intensional content of Rice's Theorem" POPL'2008, where I prove that no "complexity clique" is decidable. A complexity clique is a class of programs closed w.r.t. programs with similar behavior and complexity. I also provides necessary conditions for semi-decidable properties. Programs running in O(n^k) are a complexity clique in the above sense, hence the set is not decidable. The result has also been recently extended to subrecursive settings (such as P) by Mathieu Hoyrup: The decidable properties of subrecursive functions (ICALP 2016). 

It is well known that a set of numbers enumerable in nondecreasing order is decidable. However, the typical proof, by cases on the finiteness of the enumerated set, is not constructive. In general, it does not seem possible to effectively derive the decider from the enumeration function (and its properties): can this be proved? Here is a possible formalization of the problem. Let $\varphi$ be an effective enumeration of all computable functions. Let $c_A$ be the characteristic function of $A$, Let $f$ be a function such that $$\varphi_{f(i)} = \begin{cases} c_{cod{(\varphi_i})} & \mbox{if $\varphi_i$ is total and non decreasing}\\ \mbox{arbitrary} & \mbox{otherwise} \end{cases} $$ Prove that no such $f$ is computable (or that it is indeed computable).