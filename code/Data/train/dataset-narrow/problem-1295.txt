Dabbling around with Roslyn and made a small analyzer just now. This one will show a warning in Visual Studio when you have a try-catch statement that only has a . I realize the working code () is rather small, but I'm looking for feedback on best-practices (insofar there are already best practices established) and general remarks on scenarios that I might have overlooked. I have also been looking for a way to unit test this, but haven't come up with a good solution yet. Is there an elegant way to test these analyzers instead of looking over them by hand? Or perhaps an API that exposes some crude methods which I could provide a wrapper for? Analyzer 

Compare case-sensitive strings using . Imagine if that method is called 500.000 times with strings over 5000 characters long: each call would create a new string object. 

and are aliases -- you can use either one but stick to that. Since you've already used and others like I would suggest you stick to . 

99% of the time you think you need a Tuple, you don't. First look into whether this can be turned into 3 methods. If that isn't possible, return a simple object that holds these 3 collections as properties. 

Given this setup, does it make sense to do the call? If throws the exception, the call will never be evaluated. 

Although you could, for clarity purposes, also store the two conditions into variables (my variable names are examples). 

Notice how I've assigned initial values of int.min and int.max. You have to provide a default value and this basically allows any value to immediately replace it (unless you add int.min/max yourself). As Tunaki commented: you should use an instead of so in the case of a single value you end up with both min and max the same (and hence: 0 difference). There is no array of values to be stored now and we don't have to sort it either. I won't bother with a benchmark but it is definitely faster than what you had before (which might not have been benchmarked properly anyway). 

I see this pattern from time to time but I don't like it: or . That's what overloads and perhaps named arguments are for: all you care about is the part, everything else is just one specific way of retrieving the data but does not have to actually be a separate method rather than an overload. I would change it to and call it like this (and considering your variables are aptly named it can stay like this): . If for some reason you don't like this, you can always do but that doesn't add anything so use it when the variable actually isn't clear (like ). 

All things considered, I believe inline initializing to be better. There is no functional difference but it doesn't have the possibility of the constructor chaining overlook. Aside from that, it also keeps the declaration and the initialization together which improves readability. Comments When I look at a variable called , a comment that says factory of powershell runtimes doesn't add any value. Comments like this are a lot more important: 

You are sacrificing C#'s strongly typed model by allowing everything to be passed in. Afterwards you cast it to the expected type but you use which means the value will be if it happened to be the wrong type. This will cause on the next lines which call methods on this object. The solution is easy: make each method accept an object of type and embrace the strongly typed nature of C#. 

When I read this, I ask myself the question "Why did the location of that score get changed?". This is an excellent opportunity for you to add a comment why that is: 

Your code makes it look as if you're testing some helper method inside your tests. What exactly is going on? Make sure that you are actually testing your application and aren't extracting all the effort into a "helper" method in your tests. That being said I'll assume that your method is actually the application. If it isn't then you are doing it wrong because you should use input in your tests that represents input which you will actually receive in the live application. 

I am not a PHP developer so I can't give you an expect implementation but I do notice some things that will make handling the API easier. 

Not that I'm aware of but it's okay -- IDs are supposed to be unique anyway. You might want to add a prefix of your own though to indicate it's a diagnostic part of your own library (and thus avoid collisions with other libraries). An example is the "CS" prefix used by Microsoft themselves. 

The main reason for doing this is because I don't like the 0-based array index with the 1-based cameras: refers to camera 4 instead of 3, thus losing some expressiveness even for people familiar with this. Using an enum also takes care of you having to choose a place to create those boundary values and passing them around: the enum is created once, stores its values in a central place and can be used anywhere you want. Usage is easy: 

Which brings me to this: by using at the start you no longer have a collection on which you perform but a single object. This makes sure you can drop the remaining since the will already return a single object. 

I don't believe a Semaphore is needed in the first place. Remove it, register an event handler and continue your "act" and "assert" phase inside it. Something like this: 

Don't do any (useless?) output from your calculator. That's a job for whatever classes consumes your calculator. 

With a limited set as this, you might as well skip the entirely and just keep the statements. Exceptions are expensive, statements not so much and there are only 4 options anyway. Furthermore you could reduce the semi-repeating a little by providing a unified version of the input to compare against (all characters in lower/uppercase). In fact, I would change it to use a simple lookup table. This results in something like this: 

The comment doesn't tell me anything I don't know yet. Comments should explain why I do something, not what I'm doing. Naming Your class is named , which isn't very descriptive of what it means. would be a lot better and clarifies that it is a game we're talking about. Spacing Add a space before and after your binary operators like , , , etc. Right now the code gives a very compressed feeling. Braces I see this line of code: 

This is some messy code. First of all: declare and initialize on the same line unless there's a good reason not to. Secondly: is there an option for you to return something other than ? No generic variant? Thirdly: Don't do an intermediate when it is not asserting the end-goal of the test. Just let it throw an exception because that means the test did its job well: it throws on unexpected results. Lastly: Don't use . You expect it to parse so you want to force it to either parse or die. In your scenario, if would have value 0 then the test would fail when it shouldn't because you use such a brittle way of checking if the parse succeeds. 

If something went wrong so badly it throws an exception, we'll just pretend they're the same? This is logically incorrect and will cause very hard to track down bugs. 

Errors should never be caught in Java, only exceptions. An error differs from an exception in the sense that an error is the kind of problem that means something went really wrong and not just something was faulty handled in your application. Take another look at the first one you catch: . This literally means your app has ran out of memory. By definition, you can't do anything anymore which includes error handling. Maybe the official documentation speaks for itself here: 

Conclusion Overall the code is very well written and easy to follow. Some styling remarks that can be solved by following the conventions and some code that can be written less verbose but I couldn't find anything that struck me as potentially performance hindering so you're good on that aspect. It's fine to use the parameters, nothing wrong with it. The naming of your methods are all in the form of whereas convention dictates . This results in "IfSubscriptionExpired" vs "DisplayRenewSubscriptionDialog". I can see where you're coming from with the scheme since you are basically building a flowchart so I would be okay with it if it makes things easier in your case. 

Layoutmanagers You're using absolute positioning for all your elements which won't scale well when you enlarge or shrink the application. For this reason you should use a layoutmanager that will handle the resizing for you (and it's a lot easier to extend your application with new elements). For more information I'll refer you to the documentation. Comments 

I don't know why this is being done so this would be a good place to put a comment detailing why this is done. Usually an undercore is used to indicate that the variable will not be used. Since you do use it, use something more descriptive like annd . 

Your code is indeed confusing, primarily because of the naming: should be , should be and should be or (it depends on whether there are other "speeds" to distinguish from). Another remark: properties are UpperCamelCase so this 

Conclusion Overall the code seems pretty nice. There's still quite a bit of duplication and I think abstracting a few concepts in classes and interfaces might be a solution to remove some duplication, but overall it is good. The main remarks are style-wise. 

I've written another diagnostic for VSDiagnostics that adds compile-time security for your formatting specified in a call. The exact scenario it guards against is when you have something like this: 

It is hard to deduct that PowerCLI must be installed if you omit it, so that's actually adding valuable information. 

This seems a little redundant. I suggest either removing the entire first line or, if you really want to keep it, to remove the "y/n". But people know by now what "y/n" means so I'd prefer to simply remove the first line. Boolean is boolean When I look at a variable named , I expect it to tell me "yes" or "no". I don't expect it to possibly tell me "b". Therefore I suggest changing it to this: 

Do you really want to insert the item when there might be argument exceptions possible? If you catch the exception, you will have a partially executed method; if you don't catch the exception your program will have crashed anyway. 

since the evaluation of that is a boolean by itself and thus there is no need for the additional ternary operation. I would suspect that this is the same in PHP. 

I don't think it's likely for race conditions to pop up here but it's still a nice habit to take with you: what would happen if changed its value between line 2 and 3? You would load the wrong data! I would suggest re-using the variable. 

Note that this returns you a string value like , which is the representation of a binary number. In your code you store them as string representations and in separate entries in your collection, which is not the way a number should be stored. It's like creating an array with values "1" and "2" to represent the number 12. If this is your intention then you can always work towards that of course but it might be an indication that something else is wrong for needing it like that. 

I'd avoid throwing because it will make it impossible later on to distinguish between an exception you've thrown and an unknown exception caused by code, should you wrap all this around a general to make sure nothing slips through the cracks. Often this is worked around by creating a custom class and throwing your selfdefined errors with that. 

First a general remark: EWWW. You're creating HTML as a string and returning that to the client. That's not how we do it in a backend (at least, that what I assume I'm looking at). The proper approach would be to send data back (so in your case: an array of integers) and inject that clientside inside HTML. 

I feel like there's room for an optimization here: what if you have 100.000 pages? Or even just 100? You will load all your items each time someone visits the frontpage and you're only doing this to show the user how many pages of items there are. In fact you're not even doing that: you won't show them past 10 pages anyway! I would argue that maybe you should just use two queries: 

Unless I'm mistaking, you don't actually need it as an interface. Note that I also removed the explicit type parameter since that should be inferred from the argument passed to it. 

You're constantly locking the result set. It's probably faster to just omit the parallellism altogether since we're not doing that much work anyway but if you really want to have it, I would suggest looking into splitting the to-generate dataset beforehand, computing the data and storing it in separate collections and at the end combining those collections. Though that might be slightly overdoing things. 

is not an appropriate boolean naming. It should , or something similar which indicates what exactly that solution means. 

No. No no no no no. We count from 0 to 2, and that is the order I expect the format to adhere. Don't introduce subtle bugs by switching them around. 

If you push these two changes through to the several places they manifest, you'll find that your code has shrunk a lot and is a lot more readable. 

StringBuffer The first thing that comes to mind is the fact that you're using a instead of a . A is synchronized which means it has the additional overhead that comes with it. Unless you are doing this in a multithreaded environment that affects this piece of code, switching to a will be a good improvement. ToString Inside your loop you do . Since you never do anything with the that it returns, you are essentially needlessly creating a each time it is hit. Strongly typed collections You have the collection defined as : there is no type specified. Proper handling would be so you're working with objects instead of general . 

There, I clarified what this section was about. Well, actually I didn't because the title already conveyed that entire meaning. Which is exactly what you're doing with 

Any particular reason you're using this alias? Most people I see that use aliases (including me) have these as part of an automatic re-formatting of the document. 

This implies that if neither of the two conditions are true, will have its current value. I can't know from the code whether that is intended but if you never set elsewhere, this means it will have the default value of . In that case I would incorporate this in your code by making it explicit: 

Num is not an an acceptable combination in Scrabble thus we don't allow it here either. Write it in full. 

I would suggest an : they're made to encapsulate a set of distinct values known at compile time. For example, this might be the code you have as a result: 

Enums Your mins and maxes (and difficulties) are all over the place. Consider grouping them into an like this: 

If you want to make it easy for your user, you can hardcode these different methods into properties: 

If you make it you can never the call because there is no to wait for. Instead, make it return (which is essentially a method, but then in an asynchronous context). 

You shouldn't have to use this outside of the class so make it private. Furthermore I would turn it into a property and set it from the static constructor -- that way you avoid having to query your configuration each time you want to make a new call. This is assuming you don't do it deliberately like this so you can change the connectionstring without halting the application. 

Your code doesn't work; executing it will return and , not . This happens because you don't set the property of the nodes that are passed in to the constructor. 

You're creating a new task, starting it and then you synchronously block the current thread by calling . A new thread isn't created just by creating a object, that's what async/await is for. Instead, change your method as such (omitting cursor and try/catch for clarity): 

Note that you can also use a direct cast instead of since it is guaranteed to be a possible cast, but I like to read myself (the performance impact is minimal and not relevant in our scenario). Note that I also use instead of because from your description I can assume it is either a or a . If it isn't, I'm throwing an exception anyway at the end so I don't feel compelled to use . 

I'm not a fan of intermediate variables that have a short declaration and are only used once. I'd change 

Asynchronous methods should return or , the former being for traditional methods and the latter being for methods with return type. The reason for this is that a method cannot be awaited (since it doesn't return a ) and will in effect be a fire-and-forget kind of thing: it will start executing your asynchronous code on a separate thread and continue doing business as normal. However once the main thread reaches its end, the application will exit regardless of whether or not your asynchronous code has finished as well. This obviously leads to nasty bugs. You won't notice this in this case because you're using a GUI which means there will always be a main thread active (as long as the application runs). However in case you ever want to re-use this code for a console application or just in a class library where you don't know the client, I would suggest making it just for good measure. The only exception to this are asynchronous event handlers since they have to adhere to the convention that event handlers return . This also explains why events are "dangerous" to use in asynchronous code.