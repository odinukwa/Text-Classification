Are you running 64-bit Windows? When you say "stop working" do you mean the program just continues, or does the debugger terminate itself and your process? If you answered "yes," this is what may be biting you: In 64-bit Windows, the kernel will eat any exceptions that reach a managed/native transition. This often presents itself in managed applications and a failure for exceptions to propagate out of delegates for events on forms and such (but of course, since an exception was raised, not all code in the delegate body was executed). You can find more on this issue here. Your tileset PNG probably can't be loaded by the bitmap loader somehow. One way to see if this is the case may be to move the code out of the load event execution path (just shove it in your main function for a moment) and try to run it, possibly with "Break on Throw" enabled for all exceptions. 

The proper way to determine if you can create a device of a particular type (hardware / software) with particular feature levels is to attempt to create a device with the options you want, and if that fails, fall back to a less-featured device. The documentation demonstrates this technique for feature level fallbacks, and you can apply a similar one for trying hardware versus WARP devices. Note that this is not an "abuse of exceptions as flow control," per your comment, because D3D does not throw (C++) exceptions (being a COM API, which needs to run in C, it cannot). Failure to construct a device just returns a result code indicating that failure, and this is mechanically no different than checking the result of a "do I support hardware devices?" function. Further, this technique is actually better since it eliminates a potential (although rare in practice in D3D's case) race condition: if you have a pair of functions, one for querying the available functionality and another for initializing said functionality, there is a period of time between the query call and the initialize call when the functionality could, for some reason, become unavailable. So you need to be checking the result of the initialize call anyway, therefore the first call is just redundant. 

Hiring somebody to do your PR sounds very "non-indie." And it's certainly not likely to be good from a budgetary standpoint -- most indie games do not sell nearly as well as, say, Minecraft has. For an indie developer with a small (or nonexistent) budget, you probably have to work the grass roots angle more than anything else. Promoting your game on Twitter/Facebook/whatever is an option but probably will not see great results unless you already have a ton of followers or friends or connections, et cetera, from previous successes. Otherwise the handful of people who follow you on Twitter are probably the ones who are pretty likely to buy your game anyhow. First, make sure your game is reasonably stable and polished (at least in some areas) and then assemble some marketing material -- good, interesting screenshots and some compelling descriptive text to go along with them. Check out what other indie developers, like Jeff Vogel of Spiderweb Software do for their game splash pages. Then start trying to talk to people -- basically cold-calling them. Useful demographics to target are smaller-scale publications that have a track record of dealing with or promoting indie titles (TIGSource is great, but IGN, not so much for example). See if you can entice them to review your game, or do a preview feature. You might consider suggesting that in exchange for a preview you could offer some promotional codes for the game that the site could give away, and then you have something of a cross-promotion that could be mutually beneficial. Other indie game developers are a good market to focus on as well: some of them are actually professionals by day, and most of them will have a higher tolerance for some of the rougher edges indie games usually sport and be more willing to give the game a shot and discover its potential. Many game development sites focusing on indies, such as GameDev.Net, also have showcase and announcement forums where you can promote your project. Set up Google alerts for your products and reach out to people who promote your product without you actually asking them too -- the random bloggers who stumble across it and post about some cool game they found (or about some bug they found with it). This doesn't have to involve offering them registration codes or anything, just a simple email with a thanks or an assurance that the bug has been fixed or is being looked in to -- that can go pretty far in terms of making an impact on people. Hopefully it will be an impact they tell their friends about. This should go without saying, but make sure your game is easy to get, install, and get into. Struggling to even be able to launch a game is probably the biggest reason many indie games go untouched. It's difficult, not having as many resources, but try to get as many testers for your game as possible so you can ensure it's as rock-solid as possible. No amount of marketing savvy will save a broken product. 

Seems like a decent idea to me; I've done a very similar thing in a few projects (although with different APIs). If functionality and performance is acceptable, and it saves you from having to write all that boring collision detection code and focus instead on something that makes your game unique and cool, then I'd say go for it. 

That seems like a good approach, you can utilize the separating axis theorem to perform your collision detection. 

It's basically an isometric projection. Your second image is closer to a dimetric projection. Both projections are kinds of axonometric projections. The differentiating factor between them is the mainly the angle between the projected axes. 

If your system can deserialize the data on the other end regardless of the field order, you don't need to enforce that order. But you probably want to anyway, because it's better. If you have any dependency on that ordering (as in, you enumerate the results of on the receiving end and deserialize each field in succession), you had best make sure you have control over it, or you will end up tracking down a very subtle-looking bug a long way in the future. Then you'll really kick yourself. This is the most important reason to order the fields, but it will also be useful for a programmer to know the expected ordering when he or she works on the system, or its data. There are a few downsides to some ordering methods. They have the potential to introduce diffs within the middle of the serialized data, which can make versioning a chore (append-only versioning is much easier to deal with). If you can guarantee that you won't interoperate data between versions, this is less of a concern. It's usually hard to get reflection APIs to return results in code-declaration order. So any ordering method (alphabetical, size, name hash, whatever) will have some disconnect with the layout of the structure as read by a programmer. At least with a defined, enforced ordering you know what that disconnect will be. The ordering of shouldn't be relied on and could potentially change underneath you when you least expect it. 

The API in question is, I believe, the MSN Games GDK for developing games for the MSN Games portal (or Live Messenger). The SDK itself is not readily available to the public; I believe you need to contact developer support to get it. Check out this page at the MS Casual Games portal. 

That code looks okay to me -- but I don't know Java very well. You may want to post another more-specific question should you elect to go the route of resizing at runtime if you still can't get it working, however: 

Your shader, vertex structure, and calls do not agree. This tends to cause unusual behavior because you're mapping unexpected values to the GPU pipeline. Your vertex structure says you have a 3-vector for position, a 2-vector for for texture coordinates, and a 3-vector for the normal (a total of eight floats per vertex). Your calls say that attribute 0 is nonexistant (which means it defaults to a four-component float that is tightly-packed; this is obviously very wrong in your case). It also says that attribute 1 is a 2-vector (okay) and that attribute 2 is a 2-vector (but your structure has a 3-vector). I'm unclear what exactly the result of saying attribute 0 is tightly-packed but the other two aren't is, in this case, but almost certainly it's going to lead you to getting totally bogus values in the shader by the time it gets run. Your shader takes 2-vectors for everything, which agrees with neither your structure or what you've mapped to the pipeline via . Even if you ignore the problems you have with your attribute mapping, this would smear the values of your vertex buffer into various mismatched components of your shader inputs depending on how far along in the stream you were reading (because the stride of a vertex defined in the shader is six floats and the size of one in the buffer is eight). You should make all three of those agree. If you choose to do so based on the structure, that might mean: 

That depends. To do specifically what you are describing, you will probably need to create a mod for a new block type. Here's a tutorial on doing so -- it's not terribly complex and you primarily just need to create one additional source file (for the block itself). The code for the block itself may be more involved, however. You can see an example of this kind of cellular automaton block mod on YouTube here. You can, of course, just build the simulation you want using redstone circuits. It might be a bit involved, and it won't function exactly the way you want (toggling block types), but it's doable without a mod.