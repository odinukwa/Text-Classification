Coding style aside - your code is very hard to follow, you didn't show us any sample data and you didn't show us how to run it - your code is quite long and without being able to run it don't expect wonders - here are the reasons why: class You use global fields like , or (and the others GE, GS....) that you initialize somewhere and modify in other places. They don't have to be global at all. You could use them only where you really need them. should be a local variable in the method. performance class You probably cannot reduce calls to but what you can do is to when you create this class you should split all fields by the delimiter and put them into an array so you don't have to search through the line every time you read a data-field. Just get it from the array by index. This way you won't have to call each time you get a field. If you do this then you can reduce the to simple: 

If you made the method an extension too, the method could then be reduced to just a few lines of code of mostly LINQ: 

Save and rename? Why would I want to do that? If I save something then either I save it or I save something as. 

It concatenates the results of and and returns them as . In order to get the relative path, we neither use the nor the methods but instead the : 

It depends on how you define the right way. Is your goal short and small code or is your goal testability and maintainability? These two goals are mutualy exclusive. 

You don't need to pass the object around. It's actaully static so if you make the propertey static too then you're done. 

Part 2 - Diamond generator The diamond generator requires an oscillator to work. You specify one with dependency incjection by an abstraction layer . This part can use the oscillator to generate lines for the diamond. It also validate the size which has to be an odd number. 

Because I don't like writing the same useless exeption messages all the time ;-) I thought I create a better exception that would make this for me. This is what I came up with: 

In my application I first create a default header customization and use it to initialize the client: 

You can indeed improve the query by changing the strategy. If you first file extension and them inside the element selector you can remove and the query will be executed on the server and it won't be necessary to download all the data to group it later on your machine. You will then only get a few groups and their number of elements. Now for the few file extensions it's very easy and quick to get the category names: 

Next, if you want to provide a base implementation for such a downloader then it should be an and the name should be like the interface but without the . 

For this job you should have a dedicated service that knows how to handle it. Currently it looks like the logic is within the popup-message. I used these models for testing: 

A pattern that suggests using optional arguments instead of implementing a Strategy Pattern doesn't look like a real pattern, rather a bad advice from a lazy programmer. Even the telescopic constructor problem does not introduce optional arguments. It just uses default values. They are still required to construct the object. Implementing the Strategy Pattern in your case was the only right choice. 

I cannot reason about this part. It's too confusing. You should rethink it and also change the names to full words instead of abbreviations. 

This really needs a better name. It's netiher an index nor a . I suggest something like as this looks like one. 

IMO you should also check the repository to see whether the API correctly added the new user to it. I don't know what interfaces the might implement but for this 

Access modifiers Although not requried for private fields, it's a good habit to use them anyway to avoid any confusion. Edges property 

I sometimes need to enumerate the same collection multiple times so I wrote an extension that does this for me. I call it . It takes one optional parameter which allows it to start at an offset. 

static classes like the are difficult to test. I suggest making it instantiabale and try to use Dependency Injection and an interface to pass its instance to controls that need to interact with it so that they are not dependant on it directly. But I think you're reinventing the wheel with the . Check out the NavigationService Class - it might be exactly what you need. 

Search algorithms I see that your search algorithms share one method: . If you don't want to repeat it in each algorithm you can as well create an abstract class that already implements it and derive the search algorithms from it: 

I have still another version of my validation extensions. I've reworked it and added some new features. It doesn't relay on expression trees any more but as a compensation the same extensions can be used for unit testing. 

This implementation is a working proof-of-concept and it lacks null checks everywhere. I'll be adding them after implementing any improvements later. Do you think this code can still be improved? Or is there anything terribly wrong with it? 

They are always bad. Even if something appears to be obvious now, it won't probably be that easy to understand in few weeks. 

If someone tries to include and excluded id you should throw the which is more appropriate in this situation because the argument is valid but the operation is not so it's not a argument exception. 

There might be. If the type is under your control then you could implement the interface on it and return the sub-image collections: 

This might be slightly slower but the difference is merely noticable even with 100.000.000 iterations. If you have a three of this length/depth you'll run into StackOverflowException long before you notice how slow it is anyway. 

After the parsing the data is stored in a few classes derived from . They mainly provide the valid range for a field. The base class also implements the method that requries a date-time-part that the derived classes need to provide. (In future some of them will additionaly evaluate the cron-expression extensions but I don't need them yet so they are "missing".) 

As far as your code is concerned I'm not happy with the method because it modifies the that belongs to the instead of creating a new result. You actually don't need it because already has a such a method that you could use like this: 

I also prefer the PLINQ solution showed by @CharlesNRice but as far as clean-code is concerned you could change a couple things. 

What it does is cutting-off the from the name of the exception type and appending the properties to the message together with all inner exceptions. 

You use ids here to get matching elements from the other collection so most probably a join like this would be more efficient and easier to read. 

This is not very pretty. The check-box should enable/disable the timer via its property and not prevent it from doint its job like that. 

You are asking about the algorithm but how should anyone understand it when he first needs to answer such questions as: 

Don't put everything in a single class. Extract the method into a new one that you could call and rename the old one to just . 

You should also be more specific when naming your methods. means you sort descriptions and not something else by description which is what you are actually doing. 

I have some unit-tests that must be executed against a real database. This requires populating the database with test-data. In order to simplify this process I created the . It uses the internally to insert the data from the specified . Optionally it truncates the target table first. The reason why I picked the is because certain queries need to be tested for performance and I'll be creating data-tables with a couple of millions of rows. 

and are too similar. You need a better name at least for one of them besides sound like an action so maybe ? 

This should be splitted into smaller pieces to improve its testability however I wouldn't go with a full currency class/interfaces for this yet because I think it's not necessasry. Instead I would try to make it more LINQ friendly thus I'm going to suggest an extension that I call , just like the but this one is for decimals. 

but keep in mind that in some critical situations a peformance hit might be noticeable. However usualy you just want to use some convenience functions to get the work done. 

Sometimes when designing a fluent-api it's important to build an object in a specific way/sequence. I tried to create such a guided builder and came-up with this: 

You can greatly simplify your code by implementing generics. If you make your base class you can remove all boilerplate code from the derived class to the new generic . The compiler will generate fields and properties for each separately so you don't have to write them yourself anymore. Here's a short example. (I removed all interfaces or other helpers like and or operators for simplicity but they should be included in the actual implementaion later.) 

Most of the parsing work is done in the class by the methods. They build the regexes and try to match the values either numeric or literal. 

You could already use them in multiple scenarios. But let's go one step further and encapsulate your logic in two more extensions: 

I want to replace it with my own extension that I currently name as throwing two different exceptions. 

There are lot libraries for creating/parsing CSV but how about not using any of them and instead use Windows own tools like PowerShell? 

Another possibility would be to use named groups and catch the expressions there so that you can just use them without looking them up in the collections. 

You already know that you cannot test this extension because is hardcoded so tests will yield different results each time. To overcome this problem you can make it a extension instead an all problems with testing will disappear because the only calculation that you need is to add the number of days and the time to the date. Then you take the advantage of the method for counting how many dates you'll get. With this you only need a single test that checks if the two additions work correctly. 

You now want to list all categories together with their listing-counts. If you keep it simple you can achieve this with a join. I assume you have these two tables: 

I think even the simplest solutions can and should be made modular and SOLID. Let's try to refactor your game to give you an idea how to begin... We start with a city. A city can have different squares where a square is just a simple character/symbol.