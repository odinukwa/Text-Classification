`CurrentDb` is a function used like an object is a function that returns a pointer to a . It's a member of the Application class, but note this text from an old KB article: 

Be careful with properties matching built-in control names is the name of a built-in type, but you're using it to return a . That might be confusing for users of the property. Accessing the `Forms` object The Forms object extends the names of open forms at run-time. That means you're using late-bound code and you're not getting any Intellisense. Worse still, if the form isn't open, or it's in the wrong state, the call will fail. At the very least, you should have some error handling. Using the default instance of the form Access creates a default predeclared instance of a form (much like VBA creates a default predeclared instance of a UserForm), but Access only does this if the form is open. However, it is also possible to create instances of the Access form (and, I'd argue, is the preferable way to deal with Forms and UserForms). Your code is intimately tied to the default instance, and should perhaps be made capable of handling any instance of the form. See this example to see how a form with a default caption of "foo" is handled by VBA: 

If sorting the data doesn't help move the blanks to the end of the data range, and deleting the rows is a better solution, given your data, then you can try this approach. If you know a column will always have data (and never be blank) for a valid row, then you can achieve the deletions without a loop. 

Hex to String - Preserving the leading 0 Hmm, I think I can use a bit trick to make the Hex conversion more efficient. 

EDIT One important point I did miss on the first glance. You do sort optionally on conversion or by default on representation. the second one is a bad idea, as you cannot sort comparable objects by their built in comparison functions. instead you force str representation which in terms of sorting is useless. So you shall not force but have the identity function . might be a third option to sort for. To your changed code - let's assume we have to write a function like this. if we have a look at 

When writing library classes you should follow the python guidelines to enable generic duck typed interfacing. have a look at the python datamodel and try to make e. g. the following tests work by implementing and . 

it is clear and readable and tells all and shall not be done any other way. Now about sorting a . You rely on a 3.6 implementation detail that will be guaranteed in 3.7 when released. whenever you do such a version-stunt you shall check the version and either raise an error or implement a fallback (e.g. ). However when 3.7 will be released there might be a sort for implemented as well. Your solution is most likely becoming obsolete when becoming legal. About coding You define an inner function for no reason introducing a lot of complexity. In your inner function you check the existence of an outer to decide on returning a , that's awful. You mix and exception handling in for control flow. your clause is a completely regular case. You shall not implement a silent fallback to sort by string (or whatever the type is) when the user requested sorting via . this is a complete fail, hiding a user error and presenting false data as regular result. 

explicit loops python has list slicing and list comprehension. in you use comprehension but could use the more dense slicing 

I've sacrificed a few features of Collection (like being able to add a Widget before or after an existing collection key), and I haven't honored the CompareMethod of a Dictionary, but these are easily added. Have I missed anything? Am I missing some performance tweaks? 

But the would ideally be defined as a constant instead of as a magic number in inline code. Check bounds before using 

Properties in Standard Modules Standard modules can have Properties, but as @Rubberduck pointed out, they're not necessarily intuitive (although they do force you to qualify a call with the module name, so there's that as a redeeming quality). You could write public methods instead, but you could also create a class, and if you wanted to avoid the need to it up, you could give that class a attribute. A class would better reflect the stateful nature of the settings, and would give you the flexibility of abstracting the persistence of settings from the retrieval and usage of settings. Right now, your approach looks up the value from the underlying table every time, and writes it to the table every time. That's time consuming disk access and page locking. It might be better to load the settings on demand, use/change the settings, and then save them on exit. Variable Names is presumably short for . Why not use the full name, or better still, something like ? could be confused for the statistical term , or a user might infer that the is Hungarian notation, but guess at what type that notation represents. SQL Injection Kudos for using the (presumably from @Mat'sMug's CR question), but you're building a SQL statement on the fly, and a malicious user, or inadvertent user could cause an error, or worse, by providing a parameter with a single-quote in the . What happens if the user supplied ? At the very least, sanitize your inputs. Better still, parameterize your queries and leave a sign up saying that Johnny DropTables isn't welcome. LateBound `PageFrame` property You're explicitly returning an , which forces usage of the property to be late-bound. You probably know the type of the return value, why not use it? If you know the return-type will always be an instance of , then return that type: 

the first definitely do not belong there, this shall be done in main or in a UI. for the latter if no user interaction is required this could be logging. if requred it should be done on the dedicated UI. getting the message there could be via return values or more pythonic via raised exceptions. so we remove the print from 

You already got some advice on coding style. however there is a big flaw in your algorithm which is not addressed by the accepted answer. you try to iterate downward to get an effective implementation but you got the inner loop wrong. while you expect the outer loop to do few iterations your inner loop does check relatively low numbers early. you tried to limit that by stopping the iteration at 900, a magic value without reasoning. so your implementation may give wrong results as a pair of 901*901 is much smaller than a lot of untested pairs. you need at least a check if your product is bigger than the biggest untested one 999*900. on the other hand if we do the inner loop right all problems are gone. we use the outer loop for the lower value and the inner loop for the greater one. we do not need an arbitrary limit any more and we are quite efficient. 

so any other variable referencing a node or even the root node will possibly reference something old. 

Problem definition it is not clearly defined whether shall result in. your implementation suggests as desired result. other possibilites include 

comments and docstrings in you use a parameter choice which is one-based. this is not common and not mentioned in the docstring. so while there is a 6 line docstring one of the most important facts for correct usage is not mentioned. While your parameters and return values are listed by name there is no hint about the correct type nor the value range. 

I assume you're working with a 40MB file instead of a 40GB file. The performance will vary greatly depending upon: 

Render the Frames Define a sprite of random numbers between 1 and 3, and a sprite the same size of all zeros. 

The file has nearly all duplicated records, so I'm pushing the limits on the unique key approach. A file with all unique values will perform differently. Using your code against the 5MB file, it runs in 6.18s. If I only read the file, it reads in 0.11s. If I only read the file, split each line and build a key, it runs in 0.76s. So approximately 5.42s, or 88% of the duration is related to dictionary manipulation. So, what can we do in VBA, to improve your code Option Explicit You haven't included it in your code, so I assume it isn't declared. Declare As String The variable isn't declared, although you may have declared it at global scope. Option Explicit shows e this right away. 

If the subform is set dynamically, and you only know the return type will be a Form, then return that base type: 

Also, you're using some nice concise bit-shifting, and you'll have noticed that VBA doesn't have any shifting operators, but you might consider using some bit-shifting functions to make the code slightly clearer (and you can re-use them everywhere else that you need to shift bits. And finally, unless you're certain that will always be a single celled reference, the color will default to if there are more than 2 cells in the range and they have different colors. 

Collect all the Widgets Then we need a class to hold all of the widgets. The all important method for enumerating the collection is which has a special attribute set. The class also has a factory method for creating a Widget (Without actually adding it to the collection). 

(and so does ) does not handle the 'not found' case. this went unnoticed as you did not write a test. So the main point is - if you write a library class/function it is mandatory to do good tests. full code coverage and all regular and edge cases you can think of. python provides a unit test framework, use it. 

we also fix all the column indices in (where we find 9 winning cases which is one to many). Do not repeat yourself now we have a close look at as it looks now. 

If you want to design a class you have to remove the from it. then you notice there is a little problem with the which forces you to expose internal implementation details to the main loop by requiring a call to as well. by the way does the job correctly, one input resulting in one call to the board. ensure functions/methods do what the name promises does not rotate the board, but a matrix only. it would make a perfect name for a method of a matrix class. a board method should do the complete job and apply the gravity as well. reuse what you have you could insert tokens on the top only and use to let it fall down. not only this resembles physics, but also there is less code to test. shows high complexity and repeated code. handle errors your does detect an error if a column is full. however it does not forward this to the loop, so the player is turned over. separate I/O from core do not do I/O from core functions, but from main loop only. this requires providing state and error information to the loop by return values or raising exceptions. or by providing getters for state. this will immediately lead to better design and testable functions. there shall be no magic numbers in the code, define constants when you decide to go for a 9x9 instead of a 7x7 board, there shall be only two edits. you make it worse by having those numbers as attributes, but you do use them only for drawing. when checking for wins, applying gravity or handling input you have raw numbers in the code. this is the worst possible combination, pretend to handle your constants properly in the but ignoring these later on. seriously, this is an absolute fail. also have a definition for and write correct expressions for all the dependent values subtracting it from or . some python sugar 

That can be confusing to read, and difficult to debug. Consider using independent variables Magic error numbers You've done half the work of creating custom error numbers: 

Hijacking the predeclared instance's fields In the factory method , I temporarily set the state and X/Y fields of the default instance, and then in the event of the new instance, I read those fields though the default instance's getters. As such, I've relaxed the conditions around being able to access the default instance's getters, but this could easily be re-added. The default will always have X and Y's getters return 0, in much the same way that the default will always have default value 0. 

And, I'll use an Enum for setting the state of the predeclareed instance. It's either ready, or it's Initializing a new Point. Note the use of a leading to make the non-default enum member hidden, and the use of square-brackets to make the syntax valid. 

Waking this one up... ExecuteNonQuery Return value never assigned never has its return value assigned. Return value type You have an opportunity here to return a richer value than a . Very often when executing a command, you're interested in the number of records affected. You can return the number of records affected, or -1 if there is an error. Execution Options You're not explicitly setting any on the . As per MSDN: 

I have an XML stream that looks like the following (attribute and node quantity , and node depth reduced for demonstration purposes.) 

There is a trailing blank line, but CR MarkDown isn't showing it. Edit: With Excel working again, I imported the file, and I do get the extra header line, and if it is exported with a header line, and reimported, there are then 2 header lines, so I'm getting the same behaviour as you. You won't be able to rely on the position/order of VB_Attributes, so you'll have to parse the file. You're also assuming a user won't have intentionally placed a blank line at the top of the module. And what happens if the user has more than one blank line at the top of the module? The safest approach would probably be to count the blank lines at the top of the code module, before the export, and then adjust the number of blank lines found after the last VB_Attribute but before the actual code begins. That would potentially deal with any fix that might come to VBE.