Are you sure that this does the right thing, by the way? I would have expected either should be the asymmetric difference (), or the condition to be . You define , but you don't seem to use it. I'm guessing that you'll be expanding the script later and you plan to use it then, but it's better to leave it out until you are ready to write that code. Instead of doing: 

That would mean the total number of solutions would be , and the unique solutions would be (which is slightly unfortunate, but not too bad). In the loop, comparing against is always odd, and with these changes you don't need to anymore - you can now do: 

Also think about what should happen if fails to find the set. As written, it will fall off the end and impliiclty return , which will almost certaintly lead to errors in short order. Instead, you should probably immediately with an appropriate error message. You may also want to use to help with this. You could then add that case to your unit tests. is the name of a builtin function, so calling your arguments by that name shadows it. A better name might be , for example. You may also want to document whether it should be a set, a list or a tuple, especially if that ends up mattering to any of the optimisations you write later. In , this looks like a typo: 

In either case, I am assuming that you have one header for each variable. If that's a bad assumption, you may need to adjust this code. As an aside, as a matter of commonly-accepted Python style (and in accordance with PEP 8), I have placed all of the code for each branch of the in indented blocks, even if it is only one line. At most, you should only put it immediately after the if there is only one branch to the (no or s), and even then, consider an indented block anyway. I would change to also be a DataFrame. You could change how you currently build it, or you could just pass the whole dictionary you have at the moment into . Once you've done that, you can use numpy to do your LA work. As written, your entire strange product becomes this: 

You've passed a long list as the first argument to , and then a single string value as a second - but the way you've set it out, it could be mistaken as sending many arguments to . Better to do it this way: 

You can also eliminate that : Python allows negative indices to all builtin sequences, which are defined to count from the back. So the above line is just: 

All the files you're dealing with are already context managers, including and . Delegating to them instead of reinventing the wheel, your class becomes a trivial function: 

As you apparently suspect already, having a class full of static methods isn't really Pythonic. The only reason to ever do that is for namespacing, but this should all go into a module anyway, so wrapping all the functions in a class is just unnecessary. Flat is better than nested. You use the abbreviation a lot in the function names. Don't. The only time you should use abbreviations like that is if they are more recognisable than spelling out what they stand for (the canonical example is "do use "). A lot of them probably don't need to mention datetime at all in the name, given they're in a module called dateutil and their only argument is a datetime object. Similarly, you use the abbreviation "microtimestamp", which is a little opaque. It looks like you mean "Like a Posix timestamp but measured in microseconds", so a more explicit thing to call it is or . With those considerations in mind, and with a view to emphasising what the functions do, I would rename them thus: 

should be 'expected'. Finally, you say that this class models disjoint sets, but you never enforce that. Indeed, this would work: 

looks unneeded and possibly buggy. If the conjecture is true, you will find a pair, return it, and this will not be tested again. If you find a counter-example disproving the conjecture, then this would just do the whole search again giving you an infinite loop instead of fame and fortune. If you change it to each pair instead of returning the first one, this will repeat the full sequence indefinitely unless the very last pair tested happens to work. I would just drop it. 

This emphasises that you don't do any work in that case. You might want to add a short comment about why you don't need to. From your title, it sounds like you might want to treat this as an error condition and do this: 

First, this should be , because of the same comparison sequence above. But more importantly, this is the default behavior for , so you might as well omit it. 

If you are assuming clients won't do things like that, that is OK (although it may make your class less useful), but you should document that. In fact, some docstrings in general wouldn't go astray. 

This will noticeably fail tests like - this definition of local will return , while you want . But if you can come up with a succinct, Pythonic definition of 'local', this might be an approach to consider. 

The rest of your code assumes that we will be working on the original, but the easiest fix for that is to make a copy at the earliest opportunity. If you do that early (and with an appropriate comment), and you don't need the original list anymore (you don't), then you can reuse the name without losing clarity. Unfortunately, copying the list is bad for performance, but readability needs to come first. But way down the bottom, I will point out a bigger improvement that will mean we don't actually have to choose between performance and readability here. 

Use string formatting instead of concatenation: birthday = "You were born on {}/{}/{}, which was a {}{}".format(day, month+2, century, year) 

In Python 3, will not raise a , because someone realised that that was a little odd. Encoding to utf8 should not raise a , because there are no unicode codepoints that utf8 can't encode. If you're happy with the raw bytes in whatever encoding they happen to be, do this: 

I've also line wrapped the second print, since it was very long. Finally, you can omit the numbers inside the braces in the format strings, like this: 

It seems odd to ask to work something out for you, and then immediately assign exactly that result back to an attribute on . It would make more sense if you could come up with a flow that the grid can modify it's own attributes appropriately. I think it might make sense for to have a method to place a single ship at a particular start location, and going in a particular direction - perhaps raising an exception if it would go past the end (possibly taking a flag to say that that's ok sometimes). It looks like you already have a method called - why aren't you using it here? Your coordinates here are strings. Instead, leave them as (x, y) tuples so you don't have to keep parsing them every time you want to do stuff with them. Drop the word "determine" from various method names. It's just noise. We know that a function either does something or calculates something - ie, functions usually (although there are occasionally good reasons to have exceptions) follow the principle of command-query separation. So if its name is a noun phrase, we already know that it must calculate whatever that phrase refers to. You might consider making some of them into s so that you can use them as attributes. 

This will behave identically - Python functions can see variables from the scope they are defined in, even if that scope no longer 'exists' when they are executed. is a bit of an unwieldy name, and doesn't tell us anything we don't already know (it's.. internal to the function it's defined in. Wow, amazing). A more usual name for this type of function is something like . isn't a great name either, especially since it's actually misleading (it isn't ever ed). Since it's a value from a mapping, call it after what those values conceptually are - might be a good option. Finally, consider adding a short comment to document why you need a helper function in the first place, like: 

Only reason to initialise these to 0 is to pass them into , but, as I said above, it never uses the zero values. So, you don't need this. 

For reposts, you gradually build a string message to send to someone. It would be better (and probably a little faster) to build a list of the pertinent information: 

Consider putting spaces around the ; but more importantly, there's no need to call here - bools work fine as sequence indexes (in fact, bool is a subclass of int - you can even add and multiply them). 

Use modern versions of things The most obvious thing here is use Python 3. This will help massively with your Unicode problems, because Python 3 maintains a stricter separation between things that Python 2 conflated. In some cases, your errors will just be artifacts of Python 2's way of doing things, and will just go away. In others, you'll get errors that give you a much better idea of what the problem is. In general, the only reason to use Python 2 for new code these days is if you have to use one of an increasingly small number of libraries that hasn't been ported. You use three non-stdlib packages: and both support Python 3. Which leaves: BeautifulSoup. The fact that you are importing it as implies you're using bs3, which only works on Python 2.x and hasn't had an update since 2012. Upgrade to BeautifulSoup 4 - it is actively maintained (at the time of this post, the last release was just shy of 4 weeks ago), and supports all current versions of Python. Use requests You import requests, but you also import and . Of those, the easiest to use for what you want is , and the only one you actually use is . General Pythonisms