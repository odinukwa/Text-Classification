Some engines, like Havok, let you implement your own handling. Havok has 2 main types of collision bodies. For rigid bodies, Havok sends a callback for each unique collision point that happens. For "phantoms" which are convex shapes (or a list of convex shapes), you can listen for either per-point collision, or register for a broadphase AABB callback, which means you will get a callback any time something enters the smallest AABB that encompasses your other physics body. The system we setup at my last project for the per-point collision was each frame to create a collision map, when a collision occurred between two bodies, if those two bodies were already in the map then we skipped it, and by the end of the collision step we had a map of every object that was colliding with something, and what it had collided with. We kept the map from the previous frame, and by comparing last frame to this frame we know which collisions were new (occurred this frame but not last frame), and which collisions were no longer happening (occurred last frame but not this frame). Based on this we sent messages for new collisions, and collisions that had ended to each object that cared about collision checks. JigLib and JigLibX have an almost identical system to Havok's in terms of sending collision points every frame (or every physics step). Other physics engines likely do something similar to this. By doing things this way you have all the information you need for each collision contact, which can be used for other things than collision response events, but because you do have each contact event you have enough information to setup your own response system as well. 

And we're done, now you can see all 5 bullets were removed. By iterating through the bullets in reverse you're able to alter the contents of the container without affecting your loop. Some languages, like C#, will throw an exception when a container is altered while you're looping through from begin to end, for reasons like what you're experiencing here, reversing through the container should almost always be what you want to do when altering the container as you go through it. There may very well be other leaks in your program as well. As others have mentioned already, a profiler might help you catch these leaks. Also, in every game I've made I always create a display UI that will show me the number of objects I have in certain containers, this way I can see in real-time if the number continues to rise and never go down. For example, if your method wasn't working properly, and was considering some bullets to always be on screen, they may never get erased. Having a UI to display the bullet count might help you spot this more quickly and easily. 

If your game is going to remain a game with just a 3D plane, you could simplify by using a quad-tree instead of an octree. However, an octree will cover all the bases, in case you decide to have things that fly, or decide not to have only a 3D plane for the ground. An octree will almost certainly make things faster if you have 512 of those objects in existence all at one time (unless they're all very close to each other), especially if you're not batching your drawing of those objects, 512 draw calls is quite a bit for most devices. Since you've not asked, I'll assume you understand how an octree works and won't explain the details. Long story short, you should be able to check the camera frustum against the root of the octree, and then against that node's child nodes, and through recursion keep going until you reach the leaf nodes (nodes with no children of their own). One thing to keep in mind is the size you want the smallest nodes to be. Too many subdivisions will use more memory and will result in too many frustum<->AABB checks which will end up being slower than the 512 draw calls would. For example I use a quad-tree in my engine, and in a 4096x4096 map I found that 512x512 was the optimal smallest size. This resulted, in my case, in a tree that had a depth of 4. I would recommend tweaking the minimum size until you find the sweet spot for performance. 

I don't have time currently to give a complete answer here, because it's fairly in-depth and I'm short on time, but the information I do have time to give is too much to fit in a comment, so I'll give what I can, for whatever it's worth. First of all, it appears that Rot X, Y, and Z are in euler angles (degrees rotated around an axis). It would depend on which way that rotation goes (clockwise or counterclockwise). And it depends if Maya represents the degrees between 0 and 360, or -180 and 180, if it's -180 to 180 then just add 180 to whatever output Maya gives. You'll need to convert degrees to radians for each of them by multiplying them by PI / 360. Then convert the radians to an euler angle to determine the rotation's fwd, up, and right vector's. The forward will be represented by Z in most coordinate systems, right represented by X, and up represented by Y, although if you're exporting for a different coordinate system this may differ. Once rotation is represented by three vectors, it becomes the first three columns (or rows in some systems) or your 4x4 matrix. The 4th column is the position/translation vector. Depending on the system using the matrix, I believe the entire matrix's diagonal can be used for scale, or sometimes just the Translation's W coordinate. An identity matrix would look something like below, giving a rotation in which an object's forward is along Z, its right is along X, and its up is along Y, and it's at position (0, 0, 0). 

If you don't have a class for your camera, I would write a static utility method to call anytime you moved your camera: 

You could take the real difference, and then add/subtract a random amount or percentage from it. Pardon the pseudocode, I barely know Java: 

This is a rough description of how an MMO that I worked on chose how to generate IDs: For any object that will exist on both the client and server, allow the server to generate the ID, these are IDs. Any time that a client needs to know about that object it should be serialized down to them along with any other data about that object. For objects that will not need to be networked, there are two categories of IDs: , and . Some objects that are not networked are still known by both the client and server, for example, a tree in the world that was placed in a level editor, these objects can have IDs, generated however you wish, maybe based on the order they are placed in the map. And then there are objects that are created on the fly for server-only or client-only use, and are not networked, these can have unique IDs. So you have: 

The entity could register for either method, and if it did then the engine would put that entity into a list of entities to update, otherwise it was never updated. My entity manager class would then have the list of all entities, and a list of entities that receive updates, which is always a sub-set of the full list of entities. It is certainly the case that many engines will have entities that can update every frame. This can be expensive, but only if you let it get out of hand. I've easily had a couple hundred entities updating every frame with no performance problems in some cases, but it will depend on how optimized your solution is and the platform you're running on. How to architect a system to update entities (bear with me, I don't know Javascript, this is based on what I could learn in about 5 minutes, just now...): 

Your current method is never going to work 100% of the time, because you're stepping in increments that could occasionally miss the edges of blocks. You should probably be using a form of raycasting. Because you're creating a Minecraft clone that means all of your blocks are axis-aligned boxes, which makes it extremely easy to determine which blocks are lie along a line in front of the camera. 

I would also recommend not having so many loops within loops like this, the above sample was just so you got the idea, I would break it up into multiple functions that give you the same functionality as something like what is shown above. Also, make sure not to alter the AABBNodes container while looping through it, as that could mean missed collision checks. This may sound like common sense, but you would be surprised how easy it is to have things reacting to collisions cause changes you wouldn't anticipate. For example if a collision caused one of the colliding objects to change position enough to remove them from the AABB of the Octree node you were checking then it could alter that container. To solve this I recommend keeping a list of all collision events that occur during the checks, and then after all checks are complete run through the list and send out any collision events. 

Something like this would work provided your rectangles are Axis-Aligned (which you've indicated they are in your comment (below your question). And to make one move towards the other (using pseudo-code, I don't know what engine you're using so I can't write exactly what you'll need to compile): 

Depends on what information they are already expected to have. For example, if they have the map already on their client, then you only need to send information about non-static things within the map. If they don't have the map then you should try and only send them map data for the area that they're in, and, when sending them information about non-static objects, only send those for the area that they're in as well. For a 2D game I would have an axis-aligned rectangular/square region (on the server) that represents the area that encompasses everything they would need to know about based on their location. Send them information about objects when they enter the region, and then send them updates on those objects whenever the state of that object changes, then you can send them a small packet when something leaves that area so that they know to delete it from their client. By doing this on the server the server will have a list for each player of the objects that the player cares about and has loaded on their client, and so whenever any object's state changes in a way that a client may care about, have that object call a method on the server that checks if any player currently has that object in range, and if so then you can prepare a packet for that player. I've seen this architecture work on a shipped and successful MMO, I'm sure it could be done for a 2D game as well.