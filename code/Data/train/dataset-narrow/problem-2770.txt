My question is how to extend this to work for rotated cuboids. For instance if I have two rotated cuboids, if I follow the logic above it would not work as intended as the cuboids may not collide but they could still be intersected on the view plane. An example is below: 

I am wondering about how time manipulation mechanisms in games are typically designed. I am particularly interested in time reversing (sort of like in the latest SSX or Prince of Persia). The game is a 2D top down shooter. The mechanism I am trying to design/implement has the following requirements: 1) Actions of entities apart from the player character are completely deterministic. 

This code was mostly copied from the MSDN tutorial except I am intersection with a plane at height 1000f. 

Instead of drawing to this position you could use it in your update logic. The values aren't perfect but they should get you on the right track. Edit: If in fullscreen you'll want to find the current resolution of the user's monitor. You can find it using: 

You can get a position relative to the screen resolution, then it's just a matter of tweaking the values to find what works. From $URL$ : 

It's a fair system as long as everyone is constantly clicking to shoot near the end of the reload but if you were to manage it client side the effect would only slow the time for the shot to fire and not the reload time itself (which would trigger instantly). In the above example every reload loses a few milliseconds which will build up until entire shots worth of time have been missed. If the shot is sent to the server and the reload is local then the shot might be late but the reload will always be on time. The initial problem with slow/fast clocks is probably still a thing however. Depending on the language/framework you're using it might be possible to get a better measure of time. Beyond that I'm afraid I can't help much. 

with the method running the scripts calling resume in turn on each script. I could potentially have up to 300 scripts running at once which would mean 300 threads to handle. Am I taking the correct approach to solving this problem? I am programming this in C# XNA. 

As an example: Frames 0-50: Player moves foward 20 units over this time Enemy 1 spawns at frame 20 Enemy 1 moves left 10 units during frame 30-40 Player shoots bullet at frame 45 Bullet travels 5 foward (45-50) and kills Enemy 1 at frame 50 Reversing this would play back in realtime: Player moves backwards 20 units during this time Enemy 1 revives at frame 50 Bullet reappears at frame 50 Bullet moves backwards 5 and disappears (50-45) Enemy moves left 10 (40-30) Enemy removed at frame 20. Just looking at movement I had some ideas about how to achieve this, I thought of having a interface that changed behavior for when time was advancing or reversing. Instead of doing something like this: 

Where graphics is the GraphicsDeviceManager (declared in the game's constructor when creating a new XNA game). Depending on the scaling of the game one or the other of these should work. 

I'd like to come up with an abstract object rather than putting random conditionals into other methods. I've solved some relatively complex problems before but I don't even know where to begin with this one. Any help would be appreciated - Java, pseudocode or general concepts are all great. 

I've been making small 2D games for about 3 years now (XNA and more recently LWJGL/Slick2D). My latest idea would involve some form of "talent tree" system in a real time game. I've been wracking my brain but can't think of a structure to hold a talent. Something like 

I am working on a top down 2.5D game. In the game anything that overlaps on the screen should be 'colliding' with each other regardless of whether they are on the same plane in the 3D world. This is illustrated below from a side-ways view: 

In the example above the cuboids are overlapping from the view of the player, but not colliding when they should be. Is there a way to project a cuboid that would be aligned with the plane? Would it be a valid cuboid for all rotations if I did this? EDIT: Corrected the images, before they were incorrectly projecting onto the y=0 plane at 0 rotation, not the plane parallel to the viewport plane. 

The above is one way to solve the problem, there are many many other ways but in general you should break up the code and make things reusable if it makes sense. Your bullet pool logic is horribly inefficient as well, you shouldn't loop through every bullet everytime you need to find a new one that you can use. There are ways to do pools with all operations being constant time. This is a very simple to understand implementation: $URL$ There are better ones that don't affect the GC at all but the above one should suffice. 

Is it totally necessary to manage reload times server side? Often the simplest way to do this is on the client side for both fairness and responsiveness. I'm no expert but what I would predict is that the current system encourages spamming and the server has to check whether each request is valid before discarding it, taking up more processing power. Drawing up a basic model (ignoring processing times etc) of a client with 60ms ping we get: 

Just put this in place of resolution in the above code and you should be good to go. If this doesn't work try: 

For your second question, there are plenty of free resources out there. $URL$ has some good stuff, though some of it may have attribution licenses etc. Here's a list of places for free art someone compiled, it seems to have something for everyone: $URL$ 

I have been implementing behavior for enemies in my game and so far I have been doing it sort of like below: 

The orange and green circles are spheres floating in the 3D world. They are projected onto a plane parallel to the viewport plane (y = 0 in the image) and if they overlap there is a collision event between them. These spheres are attached to other meshes to represent the sphere bounding boxes for collisions. The way I plan to implement this at the moment is the following: 

Have your bullet pool inside this singleton service, the service should also handle stuff like updating the bullets during the update loop, managing the bullet pool e.t.c. Your gun object can then call call it as follows: