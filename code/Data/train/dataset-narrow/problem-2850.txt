In the normal case, the ball's velocity is positive (downward), it hits the top of the pedal, and becomes negative (upward). But if the ball hits the side of the pedal, it might bounce back upward and immediately collide with the pedal again. In fact, it might do this multiple times (once per frame) within a second, and you would only see the final velocity when it's released. The real fix for this is to look at where the ball hit the pedal (eg. sides) and adjust the velocity accordingly (eg. bounce sideways but retain downward velocity). A common solution to this is separating axis theory, which is usually good (but fails in some cases with really high velocity objects). 

You can get the latest version from Maven for your maven/gradle builds. Also, note: Greenlight is not some magic marketing machine. You have to market your game really, really well to get it greenlit. 

I'm in the planning phases of a mobile-based game that depends heavily on tracking your location (think FourSquare). The main problem I have is storing and tracing location. If a user has a phone with a data plan, I can simply ask them to turn it on at the target location to allow me to save that information (that they visited location X). But what about if they don't have a data plan? FourSquare allows you to use some sort of SMS system to "check in" to locations, but implementing that is beyond me. What I probably need is some way to just figure out and temporarily store the user's location, and when they next connect online, they can upload all the "visited locations" information. I know this is vague; I'm looking for general solutions. If you want specifics, I will be using MonoGame and supporting iPhone and Android phones. 

There are often lots of items in a game that can be used in varying ways. One generic way to do this is to implement an interface such as the following: 

What I prefer about all these approaches is that if you simply double buffer the command queue between the render thread and the logic thread, you can render as fast as possible, you can update on a set interval and you can manage all the above multi-threading goodness with nearly little to no need for locks, making the execution speed as robust as possible. 

Whenever a keyboard press/release occurs, your input system can then create a , populate it with information and then iterate the listeners and dispatch it. Polling There are often other times where it can be just as easy and perhaps cleaner to poll for the current state rather than trying to react to it using a listener. For example, in a , it may make more sense to simply do something like this in it's update method rather than trying to implement it as a listener. 

I would follow Sean's advice and consider a separate entity for this type of renderable effect. You simply attach this new entity as a child to the avatar entity when a selection occurs and remove it when the selection stops. We do similar things like this for highlight/hover effects as well. In fact since you can only highlight/target a single object at a time in gameplay mode, we preallocate those special entities when the world gets initialized. They are merely hidden until needed. Once needed, they get attached to the right parent, visibility flag toggled. To remove, just detach, set not visible. 

...is "all the code that isn't a function call." In this case the "culprit" is probably the loop itself. This doesn't mean the loop is slow, it means a large part of the cost of that function is the loop it contains, which contains a (gated) inner loop and a bunch of non-function call computations. That inner loop is also where you call another high-cost function () You should probably focus your optimization efforts on: - reducing the number of times the outer loop has to iterate - reducing the number of times the inner loop has to iterate or increasing the number of times the inner loop can be skipped entirely - reducing calls to or or optimizing . 

This looks like an issue with the working directory; likely when running under MUnit, your working directory isn't the same as when running your primarily applicable and thus the paths do not correctly resolve (it's also possible for some reason that file IO methods are disallowed under test, but that seems egregious). Consider using embedding the resources in your test assemblies, or determining how to alter the working directory for MUnit's test execution. 

Find or write a different exporter, or perhaps (since Collada files are just XML) use [XSLT][1] to transform the undesired data away or in to a more generalized form? 

Why don't you just use normal A*, and model locked doors as impassable regions; once you pick up the key (walk on the key tile?), that changes that particular locked door into a passable region. What this means is that your path-finder will go for the shortest keyless route, and if it finds keys along the way, it will incorporate that into its path if that helps. That seems pretty reasonable to me. It's not perfect, but it's a simple solution to the problem. 

I created an awesome rogue-like game in Ruby. For the GUI, I used NCurses. Since I'm using FlatRedBall as my engine of choice for Silverlight game development, I want to port this game over. What is the best way to efficiently doing this, and what are the pitfalls I should expect? For example, Ruby is object-oriented, like C#, and I should be able to just convert (rewrite) classes one by one. However, I will run into issues like: 

I just discovered Haxe and NME. It claims to be a cross-platform app that supports all major desktops and mobile devices, and Flash, from one code-base. Worth a look. 

This was going to be a comment, but it's really long enough to be an answer. The answer is (unfortunately) you can't avoid or minimize low-level work. It's just impossible. Why? Because high-level is built on low-level. There are layers of abstractions upon abstractions; but at some point, somewhere, abstractions leak or are imperfect, and you need to dig down. How far down depends on the problem. You may find CLR bugs through some third-party's application on top of another third-party's library. Let me give you an example. You might have a web app which uses ActiveRecord, which in turn uses NHibernate, which in turn uses C#. It's possible to find issues that depend on the way the CLR was implemented on a particular architecture (eg. x64). Plus, most likely as a developer, if there' s a low-level bug, you will need to trouble-shoot and fix it, because it will impede your high-level work. You can't just say "here, ask X to fix this" because you're a "high-level" developer. YOu have to get the job done, whether it's your code or some other layer of the cake that has the problem. If I were you, I would pick a fairly high-level platform to specialize in (like XNA, or even XNA specific to X platform) and focus on improving your debugging skills. That will carry you very, very far. Sorry if this is not the answer you want to hear! This is just the (sometimes sad) reality of code. It's layers, and imperfect abstractions. 

You write the player position to the file. For example, if you identify every player with a unique number (or a GUID), you could use that as the file name. In the file, simply write the position data out in a format you can parse later. For example, might contain if player #467239 is at that (x, y, z) location. This is not that different from what you would do with a database, however -- a database should not be "slow" at this operation, it should be very fast (probably faster than files, because you have more disk IO overhead or IO locking contention -- if you stored multiple positions per file -- in a filesystem-based approach). Perhaps you were trying to use the DB or filesystem to store the player position at runtime? You should not do this at all. At runtime, in your server, player positions should be kept in-memory and updated there, as you would do with any other kind of game. Periodically they can be saved to disk or other persistent storage -- for example, when the player rests, saves, or logs out. But writing every players position to storage every update is unnecessary and extremely inefficient; it will never be fast enough to handle anything resembling "massive" player scales. 

The usual way to prevent this (as far as I understand) is to have a concept of "collide and move." This means that if two objects collide, "backtrack" them until they're just touching at the moment of collision. In your case, you may need to redo your algorithm to calculate when two objects will collide (instead of waiting for it to happen after the fact). Or, if they do collide, reverse the position of the ball according to the opposite direction of its velocity until it's on top of the paddle, and then bounce it. I don't know if that makes sense, but basically, you want to tell when they just start to collide and THEN bounce. 

Does OpenTK exist anymore, or is it abandonware now? Edit: Some people have expressed concern at my use of "ambiguous" and "loaded terms" like "dead," "abandonware," and others. What I'm asking is this: software projects comprise of many pieces: 

Tweak your formulas and parameters accordingly until it seems right. Then playtest it and see if it feels right. 

Then in a later iteration, I got smarter and went with a more "machiney," grungy look-and-feel, which resulted in this (final UI): 

Yes, you can. I have made a few games like this; you may even be surprised to learn that RPG Maker can be used to make non-RPG games; see this blog post on the RPG Maker blog. Games people have made include: 

Fur is usually implemented as a render effect -- there isn't a 1:1 correspondence with geometry, although geometry may be used to achieve the effect (textured polygonal strips, for example, or the newer and better looking 'shells and fins' methods), so there isn't really anything to export unless you were you convert the fur representation to 3D geometry. This would almost certainly result in extremely poor performance in your game. The solution you probably want to is abandon using Maya to generate the foliage and employ a rendering effect in your game code to achieve the desired results instead. The article I linked to before provides one possible implementation; here is another example, using XNA. However, since you said you are using Maya's fur rendering to produce plants, you may instead want to consider rendering algorithms designed for exactly that effect. Game Rendering has a whole section on "vegetation." There's quite a few options for grass rendering, for example: 

I know you mentioned being CPU limited, but you didn't specify exactly how much so, or what the GPU resources you have available are. It should be reasonable these days to implement some level of these techniques with reasonable scalability back to older hardware and without too much CPU strain. If that fails, you can always fall back to using simple polygonal billboard strips and "exporting" your fur out of Maya by rendering it as a texture you eventually apply to the billboards in your game. But actually exporting the fur as geometry is almost certainly not the approach you want. 

It's generated by carving out random circles in a filled space. I have one main problem with it: several circles are completely unconnected. I cna't quite figure out what algorithm to use to connect them. I tried "for each circle, find the nearest circle, and tunnel to its center (horizontally then vertically)," but I get something horrible instead (same map as above): 

Me too. Since I love XNA so much, I ditched the Microsoft version, and went with an open-source implementation of XNA, aka MonoGame. Try it, and see for yourself. And by the way, it supports Android and iOS via MonoTouch and MonoDroid. It also supports Windows (and Windows 8) out of the box. 

( can easily be ; as 100% alpha, I think; can be a real angle (small in the image) or zero (the orb itself). 

The main problem you want to solve is strong, powerful players pick on weak, new players after their protection ends. There are quite a few social solutions to this: 

After using several entity-component systems, especially CraftyJS, I more or less got the answer to my question: yes, you can reuse components (especially sprites or images and mouse-click handlers in 2D games) for the GUI. Much of the time, you only have access to the ECS, and not the underlying systems (eg. drawing system). In this case, it's okay to use components, since you have no other choice. If you do have access to the underlying system (eg. Ruby roguelike with direct access to Curses), you may find that drawing/rendering directly on that system is more effective (less code, less fragile, more natural) than using a bunch of entities and components. 

While you may find it useful to cache your entity's position in your , it's primary purpose should be to supply physical characteristics about the entity such as mass, volume, rigid properties, etc. Your would be responsible for obtaining the current position from your , the velocity/accelleration from your component and using those in conjunction with the physics library to force the entity to move appropriately. After the simulation, the system in turn updates the position and orientation appropriately as well as notifies objects of collisions. The benefit here is that if you replace your physics library, the remainder of your code should continue to work and only the needs to be adjusted to work with the new library. This doesn't conform to any of your points exactly, but does lend itself to being very compartmentalized and decoupled to permit ease in refactoring as needed. 

It's really a matter of whether you want to learn high-level, abstract concepts to games or whether you'd rather get down and dirty with a lot of the code basics that make up games. I usually consider game development to be focused on the design and implementation of tools and platform solutions that aid designers in creating games. Game development isn't as much about creating the game as it is to creating the foundation that games can be built and managed. This is essentially your programmers. Game design is on the receiving end of this foundation & tools. This group is often what drives requirements to the programmers and this is the group that takes those tools and creates an virtual world filled with interaction and fun packed adventure. These are often the creative types, ones who may have some minimal technical skills to write simple scripts in UnrealScript, Lua, Mono, etc. But these guys aren't the ones programming in C++ and concerned with engine code, network code, and how all the nodes of an MMO process hierarchy communicate in a distributed fashion. Both have advantages & disadvantages to going into one or the other first, as with any choice in life. What drove me to development was the fact I enjoy programming, and so the choice was clear. If you're on the fense, then consider which avenue appeals to you more and start there. 

I'm assuming you're either using some sort of entity-component system, or else you have in-game classes that represent your objects. Either way, you have some reference to your in-game objects (players, walls, enemies, etc.) At a minimum, these objects should have: 

I have a theory on AI that I would like to write a "whitepaper" about. The distinction I want to explore in AI is learning vs. strategizing. My question is, where can I read other material about this subject? Let me give a chess example. Let's look at a chess AI as a max-tree, where capturing an enemy unit adds that unit's value to the "move score" for that decision (and likewise losing a piece subtracts that value to the score). Capturing a pawn might net 1 point, a knight 4 points, a rook 5 points, etc. Strategizing would be AI to apply these points and determine the next move; eg. given ten possible moves, pick the best (max score) at the end of three moves. Learning would be applying statistical observation to determine those values. If you play 100 games, the AI might decide that capturing a pawn is 2 points, and a knight is worth 7 points, while a rook is only worth 3 points (based on 100 gameplays). Does this distinction already exist in literature, and if so, where can I read about it? Edit: Does anyone know a Chess game (with source-code preferably) that utilizes this approach? Maybe Chess960@Home?