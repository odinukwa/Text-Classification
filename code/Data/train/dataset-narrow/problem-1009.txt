Now you get more type checking and have less repetitive typing to do ( instead of ). I did not capitalize because it is not a macro-ish constant anymore. A side effect of this is that you cannot do anymore because does not decay into an like does. Instead you can define addition and subtraction operations such as this: 

Note that this is a free function, not a member function of . Prefer free functions, because they work in more cases (like multiplying an to a ) and are thus more consistent. This allows you to do this: 

Some of your member functions should not exist. You don't want algorithms and containers to result in implementations, because that number becomes rather big. Also people tend to forget to add all algorithms to their containers, especially when new ones appear. Instead you are supposed to implement algorithms and containers separately to only need implementations. This applies does not apply to , and that have a non-member function , and because the member functions are more efficient than the free standing functions. Also only moves elements while actually erases them. Unfortunately it doesn't apply to because requires random access iterators which you don't have. Your implementation seems to make a lot of copies. If you can't find a clever efficient way you can just create a and that and then apply the positioning to your list. I would expect a linked list to work with move-only types such as , but it doesn't because you copy s in various functions. I am getting compilation errors with both gcc and clang. It looks like you only tested with VS's compiler which tends to be a bit lenient. Avoid functions. That is what the destructor is for. Also you already have . Your does bad things when . For example you can do 

Why do you pass the arguments to straight on to ? In my opinion, it would be better to only have do what the name suggests (which is getting/opening a file) and leave handling and to or another helper function (something like ). Also, you state that you have to check whether the program is called with too many arguments, but currently you only check for too few. Finally. the comment 

Just don't. Don't do this. This is not the C++ way to do things, and can lead to all sorts of trouble down the road. For example, what about this: 

Use or include guards, not both. They serve the same purpose. If you really care about being standard conforming, stick with the include guards. In most other cases, is also fine. Do not write out default constructors if they don't do anything special, or anything at all. The compiler is nice enough to generate them automatically for you when your don't define any other constructors, which you currently don't. is a big class, in terms of object size. One reason for this is that all those s you define there are part of every object you create and are carried around everywhere your object goes, which is totally unnecessary since those are all constants. You would likely want to make those at the very least, or, since they are private and inaccessible anyway, even remove them from the class and put them solely into the implementation file as constants. The other reason is that you carry an around when you don't need to. In fact, you treat almost like a local variable: In every method you open the underlying file anew, just to close it before returning. Well, if you do that already, then you don't need to have it as a member variable because there is nothing to preserve here. Just create a new every time, which, as an added benefit, will also allow you to get rid of those ugly and calls and rely on RAII instead. Your longest line is currently 422 characters long. That is way, way too much. There is no safe and steady rule to what people consider appropriate line lengths, but most programmers agree that lines longer than 100 and a few characters are too long (I personally am a disciple of the traditional 80 columns doctrine). Overly long lines are usually really awkward to work with (just look at the code boxes in your question!), can mess up your terminal, and are generally bothersome when performing actions such as looking at code diffs or merging commits. Pay attention to correctness. should be (assuming that you also implement the hint about I gave in point 3). should be , or even . Looking at point 3 and point 5, you can do away with as a class altogether. You don't need to preserve any state, so your class is effectively empty. Putting and as standalone functions would do the job just fine. If you would still like to keep this "these functions belong together"-relation, you could put them in their own namespace. I don't know whether you care about this or not, but your code is doing no error checking whatsoever. In my opinion, you should at least verify that the file you are reading from or writing to is open and otherwise O.K. Turn the order of your header includes around. Always include headers from the project you are working on first, then all other headers, including those part of the standard library. This serves the purpose of header verification: If any of your headers are missing an include, your compiler will tell you. If you happen to include any of those missing headers before, however, the code will compile just fine, hiding a bug. 

After having criticized a lot let me say this: I would probably hire you. You show a good understanding of C++ and should be easy to shape into a good software developer. Good luck! 

This implementation uses a second array for the merged list. It is probably possible to do it in-place, but that requires some more effort. My solution reduced the complexity from O(n*log(n)) to O(n), but changed the space complexity from O(1) to O(n), which is not strictly necessary. I would probably favor your solution because it is easy unless it is proven by profiling that the small efficiency deficit is a significant problem. 

To print a matrix we would simply do this: . What you did is combine a container (holding multiple objects) together with input/output and the actual functionality of matrix operations. You should try to make each class only have a single purpose. The only purpose that should have is to do matrix operations. Instead of writing an example by hand I'll refer you to eigen where they did all of this plus some other neat tricks. Now imagine I did and my output said "The sum of 1 and 2 is 3". That would suck. Your shouldn't do that either. 

This is a follow-up question to Sorting algorithms - Bubble sort Again, for practice purposes only, I took on an implementation of the well known insertion sort as a method to be used similarly to . As expected, the code lives inside a header file called insertion_sort.h: 

As part of a project where I will be rewriting the most common GNU coreutils for practice purposes, I wrote a simple command line option parser in C. The parser works by categorizing entries into either flag or argument by comparing them to a list of possible flags specified by the user and grouping them together in pairs where applicable. Currently, only the standard encoding is supported (i.e. ASCII in most moderncases, no UTF-8 or other extended charsets). Nearly all of the work is done in a function named . The Files: options.h 

Code Style and General Issues I will get straight to the main point of this answer: What you wrote is basically C. You use basically nothing of the things C++ offers you. While that is generally a valid thing to do, you posted your question with regards to C++ coding improvements, so a big part of my answer will focus on making your code more C++-like. In addition, there are some other issues which have nothing to do with whether you are working in C or C++ that should be addressed as well. Let's get started! 

is a user defined data type and C++ gives you a lot of freedom to make it the way you want. However, if you make it overly complicated people cannot use it effectively. As a rule of thumb you should aim to make your data types behave roughly like an because screwing up the usage of an is pretty hard. To add 2 s you write something like this: 

That way you can also leave out the constructor. I dislike the name . The return value tells me if it searched or not? I would prefer so that the return value fits to the name. Your leaks memory. It creates s with but doesn't them unless you manually call for every single item. You have 2 options here: Insert a destructor that deletes all the nodes or just make , and s, which will delete the nodes automatically. If you go the route you will have to change the implementation code a bit, because you cannot copy a (then it wouldn't be unique anymore) and instead or them. Your can be copied but the copy does the wrong thing. Instead of a copy I get 2 trees using the same nodes (because it just makes a copy of the pointer). If I change one tree the other also changes. Instead you should write your own copy constructor that deep-copies the nodes. Same goes for the assignment operator. Also your would benefit from moving, so you should add a move-constructor and move-assignment, too. prints stuff. As a user of your class I don't want that. Or at least let me specify an where you should print it to. should be a function. Right now I cannot search for a value in a , but I should be able to. In you keep the , but it is not used for anything. You could simplify that function to something like this: 

Prefer over ; it is more idiomatic and easier to read. However, having an explicit condition in your loop head is preferred to ing out of the body in most cases. Use and other integer data types where appropriate. As an example, is an in your -method. This allows the user to input a negative number as well, which your program handles gracefully by doing nothing and exiting. Still, it makes no sense to have -5 Ghouls, so should at the very least be . Prefer pre-increment (and -decrement) over post-increment (-decrement) (i.e. over ). The reason for this is that, while it does not matter for integral types, it can incur a performance cost for types which overload both operators (this is because post-increment might need to make a copy, increment and then return said copy). So while it does not matter here, you should make it a habit to avoid unnecessary performance losses in different circumstances. 

Well, you could make this work using . However, since you are implementing a quite low-level memory structure, I'm not sure I would suggest it here. In general, smart pointer usage is preferable to raw pointers; however, in a case like this where you have to manipulate the pointers themselves a lot (as opposed to the data they are pointing to), smart pointers tend to be somewhat clumsy and ill fitted. However, you should definitely make sure that you are doing memory management correctly (using static analysis as well as runtime analyzers such as valgrind, asan, msan etc.). There's nothing inherently bad about using recursion in a constructor. There are two different approaches to the copy problem. One is to treat as a dumb, struct-like class that does not much more than combining a piece of data with a pointer to the next node. In that case, it is fine to make copying nodes correctly the responsibility of . The other approach is treating s more like "smart" objects which have some ingrained behavior, in which case copying should be defined through the class. I personally prefer the latter, because it plays well with the C++ approach to OOP, and lifts some responsibility from . However, I would not say that the other approach is wrong, I just don't like it as much because it makes the overall burden on heavier. 

I don't like that you use to set the function. suggests that I can append a bunch of functions and they all get called when the event happens, which is not the case. would be better. It would make sense to take advantage of move semantics. The lambda that gets passed into is moved into and then copied into , when 2 moves would have been enough: 

It is a bit annoying to do all those things from the linked documentation, especially when you realize that you need to follow more links because it says "The type satisfies " which has yet another list of requirements and that one links to more requirements. On the upside once you did all of it the standard algorithms work with your iterator and you can delete a bit of code. Also algorithms from other libraries like boost tend to work when you have standard iterators. You can initialize members in the class declaration, for example 

There are good reasons why existing binary trees are so complicated. If you want lots of performance with lots of flexibility in lots of cases it costs you a lot of effort implementing the tree. Or you just use and don't worry about it. 

Do not use , it is considered bad practice as it can lead to subtle name resolution errors and makes the code (in my opinion) more difficult to read because you now have globals, for example and in your program which are not easily recognizable. You do not need to define all variables at the top of each function, and, in fact, should favor to declare your variables as locally as possible, because this helps people keep track of what is currently important while reading your code. Nobody wants to keep track of several different, obscure variables whose meaning and usage is only introduced several lines deeper down. It is completely unclear to me why you wrote which is equivalent to but very obscure. Even more obscure, why do you even have a variable named if you never use it? Remove it. Rethink operator spacing. Ultimately, this issue comes don to personal preference, but please consider adding a space before and after each binary operator. Lines such as are much harder to parse quickly and correctly than . Do not use unless you have a good reason to, as it not only creates a line break but also flushes the stream, which can be detrimental to performance. Although it is unlikely to matter in your case, you might find yourself working with situations where it does matter, so you should make a habit out of preferring . Concatenate adjacent string literals when writing to . You could get away with fewer calls to if you wrote instead of . Omit . The compiler automatically inserts it for you (although only in ). You do no input checking at all. If a user enters anything that can not be parsed as a double by you will be running into undefined behavior because of uninitialized variables. Depending on your use case, this might be fine, but if you ever intend to have somebody else use this program, you should add some checks to make sure you actually receive valid input. You should consider letting the user input all three values of a vector on the same line, not only to make your code a little more succinct, but also to make it a little more user-friendly. 

Your is not balanced. If I insert numbers from 1 to 1000 I effectively get an inefficient linked list. is indeed a bit tricky. I would just replace the deleted node with the left node and insert the right node into the left node. You could trivially replace with and put above your tree to make it not only work with s, but with any data type. In that case you should make 2 versions of functions that now take an : One that takes a and one that takes a that is then perfect forwarded. 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

There are a few things here that could improve your code (whether the code becomes more succinct or not is a matter of debate, but it will definitely become more readable): 

invoke undefined behavior. The Single Responsibility Principle This principle, which is one of the foundations of good object oriented programming, states that each class should only have a single responsibility to fulfill. In your case, however, both and seem to violate this: In addition to doing their duties as observer and subject, they also log all their actions to , which should be the job of another part of your program. Performance Issues Currently, you pass everything by value. However, what if your template parameter is not cheap to copy (imagine a with millions of elements)? In that case, you're wasting time and resources by making a copy too much. Instead, you should always pass by (if you need more advice on when to pass by reference and when to pass by value, I suggest you take a look at the Cpp Core Guidelines). Don't use You usually don't need to flush the underlying output buffer, which does besides inserting a new line, and if you do, there is . will do in almost all cases. 

If your constructor initializes members the class initialization is treated as not existing (so no loss in performance for double-initializing), but if you forget or leave it out you get sane defaults. I would like to see and in the part of for encapsulation. If you let users access those types they will use them which I think is not intended. 

Your solution If I wanted to do the obvious solution of squaring the array and sorting it it would look something like this: 

You get somewhat worse error messages but most likely better performance. Same goes for , it should take a variadic template argument that gets perfect forwarded into the call for efficiency. Speaking of efficiency, the flexibility of comes at a price. It is known at compile time what types can be, so should be exactly the same type without type erasure and virtual function calls. You can make that work with a style function to get the type of the function and create an with the appropriate template parameters, but you lose the ability to specify the function later. There are extra parenthesis in the call . Maybe it is a style thing, but I would write instead. Oh, and is not very C++y, but it was just an example.