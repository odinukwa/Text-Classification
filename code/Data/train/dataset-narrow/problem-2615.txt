EDIT: Some examples and explenation supporting my comment. In my comment I mentioned a . You mentioned that nothing happened. A guess I could make for why nothing is happening is that you might miss the calls to the base class in your game class. Example below. 

The calls I made in both and make sure that XNA will call the of each and the of each (including ). Then your HealthPickup should have the following: 

To add a bit to Rokk's answer. Chances are, since you say you are new to XNA, that you use the , in the class, known as . If so, then the solution is simple. Just make sure you can reach that list from your collision code and use . Your game will now stop drawing it and the garbage collector will (if you aren't referencing it from some other spot) clean it up for you. If you are not using that Component list I was talking about, then it depends on your code. This is also where I refer you back to Rokk's answer. 

Personally I would do the same as what the book does, removing nodes from the list you receive. But this should align well with your current code. Hope it helps! :) 

Can't comment so I have to do this as an answer. Tried your code and it worked perfectly for me. Is the sprite you want to draw really 60x60? If not then that is the problem. Your program is taking rectangles of 60x60. If your sprite is smaller than that then your rectangle will also draw a piece of the next sprite. If your sprites are bigger than 60x60 then your sprite will not fit into the rectangle and the part that didn't fit into the rectangle will be in the next currentFrame. If you don't know how to check your sprite size, then upload your spritesheet somewhere so someone can check for you. If the above is not the case then I'm wondering if you are using XNA or MonoGame. Or how show how you call the draw (including the spriteBatch.Begin() function). 

Try this approach: Spawn a object on the X and Y position of the player, then apply a very strong gravity force, and check for collisions (just like you do with the real player) Then on the next frame update the coordinates of the shadow object with the new X and Y cooordinates of the player (I.E. place it on the same coordinates of the player) Then apply again gravity, etc. It is important that you set a strong enough gravity, so that you're sure that your shadow does not float mid-air. 

Ok, so I tried executing these 2 pieces of code: (camera is , and the 2 texture regions are of size 64*64, from the same textureAtlas) Code 1: rendering on-screen 

Notice how the two are identical except for the method, which in code 2 is offset by 200 pixels, and is therefore off screen) Result: On PC, code 1 was at 10 to 30 fps. code 2 was at 50 to 60 fps. On android code 1 was at 3-4 fps, code 2 was at 60. So, I'd conclude that yes, libgdx does check if a texture is offscreen before rendering it. If there are any flaws in my test that may have caused it to give the wrong result, I'd be glad if someone could point them out. 

Then if you need to check wether a certain position in the grid is free, say [8,2] (the position corresponding to the piece of meat in your picture) you can use a method like Then, to see if an object will fit in a particular position: I used this in my tetris game, I think it will do for your inventory too :) 

Store the position of the top left square of your item in Then add to each object an array of couples of ints representing the occupied coordinates of the grid, relative to the position of the top left square. For example, a 1x1 object will have A 1x3 object (1 square wide and 4 squares tall) will have An object shaped like the T piece in Tetris will have 

Space partitioning would be useless for A* in an established graph. Spatial partitioning speeds collision checking, which is useful when constructing a graph that you navigate with A*. In a static environment, you should be pre-calculating the graph. In a dynamic environment, you will need to do some collision-checking on-the-fly to, at the very least, discover when edges have been broken by changes, and to find new paths. 

The general problem: determine which of all the possible combinations of objects has a nonzero intersect volume. The naive, general approach is simple: For each possible pair of objects, compute the volume of intersect. This is usually not practical, since it requires O(n^2) relatively expensive intersect operations. Hence, practical implementations are often specialized, making certain assumptions to allow the avoidance of intersect checks, or reduction of their cost. Spatial partitioning takes advantage of the fact that objects are typically small relative to the total volume, and will typically reduce the number of comparisons to O(n log n). Axis-aligned bounding boxes and bounding spheres provide inexpensive coarse intersect checks, as long as objects obey certain compactness assumptions. And so on. 

If you want to continue to move the camera in the way you are now, here's what I would recommend doing. Be careful to ensure that the flame co-ordinate system is rotated before it is translated. Remember, matrix multiplication is not communtative, so rotating and then translating is not at all the same as translating and then rotating. First, compute the rotation axis and angle. Given a unit vector pointing in the camera view direction, V, and another unit vector pointing in the direction of the flame, F, you can compute the required axis of rotation as A = (F cross V). The rotation angle is given by theta = acos(F dot V). Recalling that GL right-multiplies matrices, call glTranslatef before glRotatef. So you'll get something along the lines of: 

I always thought that pixels were square... it turns out i'm wrong, and I am quite worried by this. This means that if I draw a circle, it will be round on my screen but it could be an ellipse on someone else's. My first question is: How common is that? Should I bother to take this in consideration when I draw my graphics/ scale my bitmaps? Or are such weird pixel shapes only used in not-intended-for-gaming screens like hi-tech washing machines? And my second question is: How can i programmatically get the exact screen size in millimeters (both width and height) of my custom SurfaceView? 

I've already implemented collision detection in my game loosely following this tutorial, which works great, but I realized there's one major flaw. The player and the enemies are circles, while the obstacles can be either segments or polygons or circles. Now, let's say I have from to and from to , which means they form an acute angle, and player has it center in , with a radius of 25. If player starts moving right, it will eventually collide against segment B. My method will return a vector, but if I apply that vector on player, it will be moved up and left, and will overlap segment A. If I call a second time, player will be pushed down and collide again with segment B, so recursive invocations aren't a solution. Any ideas? Here's a picture to explain: The g->n vector direction is along the bisector of the two little vectors, but how do I find the length? 

My question is: should I write my code so that it checks everytime the coordinates of what I am trying to draw, detects if it's offscreen, and in that case skips it (to spped up the rendering), or does Libgdx already do that for me? 

Tradition says new scores on top. No idea why, though... now that I think about it, it makes more sense the other way around, you should award a player for achieving an equal score in less time. But that's just my personal opinion, in the end the choiche is up to you :)