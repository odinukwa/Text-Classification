I am trying to come up with a system to measure or estimate the skill of a player at a single player game (so no head-to-head rating system help here). Specifically, it is a pinball game, but I do believe it is similar to most point-based single player games. I have thought of 3 approaches: 

A user keeps a game on his mobile phone on average 20 days. So for the most part, adding ads is not going to be noticed much after launch. However, it is going to affect your biggest fan the most, which is the segment you don't really want to piss off. There are ways to mitigate the effect however. #1 is to only show ads to people who downloaded the game after version X, so old player won't see any ads. Also, do not show ads to players who purchased something (so no ads in premium games and no ads to a user who dropped $5 on virtual goods). I have retroactively added ads into a popular game. The effect was some bad reviews, but for the most part people expect ads - as long as they are not over the top annoying. The rating didn't really drop when I added the ads. Maybe 0.1 points, but that's it. Also you can let the users know that you need the money to make another game... lots of people are quite understanding of the plea of the indie developer. 

I am having what is probably a newbie problem with Unity, but for the life of me, I can't find a decent solution to it. In short: my rigid bodies collide, but sometimes, they interpenetrate and stay stuck. I am looking for a solution that would either 1- stop the interpenetration from even happening 2- or at least eject the bodies to 'unstuck' the collision. By making the physics fixed step 0.01 instead of the default 0.02, I can avoid some of the interpenetration. However, that hardly sound like the proper way to fix this problem. Here is a screen shot of the bodies colliding. The car on the right is shown completely and you can notice that the ones behind have penetrated the others to some extent. 

It wasn't specified if you want to do a game professionally or as a hobby. For a professional game, you need professional graphics. Minecraft is a great counter example, but an exception to the rule. As a programmer making games for a living, I get the graphics from a paid artist and from online websites that sells 3d models, images and sound. For a hobby, there are free online resources as well as doing your own art. However, if you are anything like me, my art sucks, takes too long to do and I don't like the end result of the game. That means I lose my mojo doing stuff I don't like vs stuff I do like and I am not motivated by my results... which means: I get it from good sources. Get at least decent looking placeholder for your graphics. Then figure out how to get a better version, if you reach the point when you are ready to release, etc.. Don't force yourself to do stuff that will demotivate you - whatever it is. Motivation is the only thing that will make you finish your game and finishing the game will be the most important thing for you to accomplish. Do not squander motivation on graphics if it is not your thing, but realize that a nice looking UI will motivate you. 

What is billboarding, and can or should it be used to create special effects for 3D games on weapon blasting effects? 

I found the problem, it needs to be run from a web server to bypass the security policy, then it can access the local files as they are set up in the server. 

INVALID_VALUE: texImage2D: invalid image (index):101 WebGL: drawArrays: texture bound to texture unit 0 is not renderable. It maybe non-power-of-2 and have incompatible texture filtering or is not 'texture complete'. Or the texture is Float or Half Float type with linear filtering while OES_float_linear or OES_half_float_linear extension is not enabled. 

Long story short, I know my coordinates are off and I believe my indices might be off. I'm trying to render a simple 2d rectangle with a texture in webgl here's the code I have for the vbo/ibo: 

I'm having a problem texturing a simple rectangle in my WebGL program, I have the parameters set as follows: 

I've been studying opengl es and an example I saw was using a "Pool" class to keep track of touch and keyboard events. Could someone please explain how and why a pool class is needed. From what I was reading it had something to do with garbage collection and limiting the number of input classes that are made. This all seems a little abstract to me, so if someone could please explain what is going on, I'd appreciate it, I'll pasted some code here: 

How can I add graphics to some control, perhaps a picturebox, on Form1 that could potentially show my game as in a level editor? Thanks. 

Is there an easy way to re-render dynamic vertices in OpenGL ES 2.0 so that one could, for example, make a modeling program? I understand how to make a dynamic vertex array, but what I don't understand is how to re-render a dynamic array, I've only seen examples where you have to re-compile a shader each time you make an array. I did find the function: 

So, I guess I need to know the origins, but the triangle strip looks way off. I am doing this as well: 

I'm using this image: On the properties of this image it says it's 32 bit depth, so that should take care of the gl.UNSIGNED_BYTE, and I've tried both gl.RGBA and gl.RGB to see if it's not reading the transparency. It is a 32x32 pixel image, so it's power of 2. And I've tried almost all the combinations of formats and types, but I'm not sure if this is the answer or not. I'm getting these two errors in the chrome console: 

I've researched it and it is a CORS error a "Cross-origin resource sharing" error, but it's a local file! I can't figure out what's wrong. I did make the picture using gimp, and I'm not sure the coding was right on the export, but I eliminated a previous error using "gl.OES_TEXTURE_FLOAT_LINEAR". 

The object you instanciate, does it have some scripts attached to it? The instanciated object doesn't run its awake()/start() until the next chance it gets and not when you call Instanciate(). In the following code 

I don't think HTML5 is there yet for cross platform... maybe one day. I have the additional requirements that my games must work on the Blackberry as well... 

I'm in a bit of crunch time and I find myself spending way too much time tinkering with an algo, so I would like some help. In the game I am working on, there are some old-style, pixelated minigames. One of the minigame is a spaceship in a cavern. The caverns curves and narrows down over time until the ship crashes in a wall. I want them to be generated at random during runtime. I'm having a problem creating the walls of the cavern and narrowing them while keeping a smooth curve on them. For the narrowing, I keep track of it with a variable that decreases over time, but how about the curving and how to keep it natural? I've though of a keeping a target point that goes up and down randomly and have the wall try to reach for it, therefore smoothing the randomized number but it is not working great. Any ideas/algo? 

} To go back to your code, you should be able to simplify it in the following way. The loop is gone, otherwise, if you have other contraints that you didn't mention, you can always add it back. It works by tracking which pointer id is used for which control (move/shoot) when DOWN is triggered and reseting them on UP. Since you don't use gestures, you can restrict your switch() to DOWN, UP, MOVE and OUTSIDE. 

To stay motivated, keep telling yourself that you are making a game, not a game engine -- well, unless that's your thing. And that's cool, game engines are great, but they too often get in the way of making games. To illustrate my point, I can tell you how things often go: at first you create a few sprites, move them on the screen with your proto-framework and you are thrilled! You can see your progress and it is going well; you can show your friends. Then, once you have played with your concept a bit you realize that you need to make your framework (or game engine) more flexible. Or that you should re-factor some class that are not following the latest patterns. And from there, you embark on a spiral of death: you stop working on a game and you start working on a game engine. And game engines are not nearly as fun to make. You can spend hours refactoring and have nothing to show for it - in the game. And then, you lose interest. So, remember: make games, not game engines. Only refactor when you need to. Don't be too flexible - just the bare minimum.* *: of course refactoring and flexibility are important. But not as important as actually having a finished game. 

I second what Tom Gullen said about Construct 2. It's an awesome little tool that offers everything people who choose to go the HTML5 route could possibly want. It's fast, portable, easy to use and interfaces with a lot of great APIs. Including Awesomium, which wraps your HTML5 game into a Windows executable. 

In case of such a simple game design idea, I'd use Unity3D if I were you. Alternatively, it might be worth checking out Panda3D or a game development focused programming language such as Blitz3D or Dark Basic Pro. All of them are pretty good in terms of flexibility, performance and development speed. 

I'd go with the first approach. It's not only easier to pull of but also more elegant. While this kind of overhead on the GPU mustn't necessarily be avoided (it's not fatal to go with your second approach), I'd rather save it up for something more worthwhile. Now if the question was about whether to use a high-poly mesh or tessellate/displace a low-poly one in realtime, I'd definitely say go for the later. Such would be a case in which utilizing a shader rather than a pre-baked asset would be most advisable, as you'd otherwise waste a lot of good bandwidth. 

It's a matter of preference. On the one hand, Andengine is a lot more beginner friendly. On the other, libgdx is quite powerful and offers bindings for OpenGL 1.0, 1.1 and 2.0. libgdx, while being really lightweight compared to Andengine, is also capable of delivering a fully 3D experience while Andengine caters for developers and game designers interested in it's 2D capabilities. See here for a more thorough comparison: $URL$ 

From a team-support standpoint: Definitely UDK, since it integrates with Perforce (if that's really that important to you) As far as eyecandy goes: CryEngine 3. No questions asked. It allows for vast, lush terrains based on marching cubes and therefore not only looks really nice but is probably the best tool for outdoor levels. From a purely technological standpoint: id tech 4 (CDK). It comes with full source access, so it's easy to modify (if you have a talented programmer well versed in C++, that is) and the CDK (more commonly known as the Dreaded Engine) even comes with a ptex based virtual texturing approach as well as Autodesk Beast (a pretty awesome lightmapping tool) Disclaimer: Unity3D and UDK are, by far, the easiest and most thoroughly documented of the bunch. What they lack in flexibility they make up for in efficiency. With Unity3D you can easily develop a prototype in just a few days. 

Programming languages are, in a sense, just tools. Use the one you're most proficient with and the one that makes the most sense for your project. You obviously don't want to write a video game in COBOL. While you obviously can program anything in any programming language, it's more painful in some than others. But yea. C# should be fine. Depending on the codebase (engines like Panda3D or the Dreaded engine -- the later formerly known as the id tech 4 CDK -- are written in C++, despite what language people code their games in) you should get performance close to or exactly the same as some of the fastest C++ game engines.