Note that this is a free function, not a member function of . Prefer free functions, because they work in more cases (like multiplying an to a ) and are thus more consistent. This allows you to do this: 

is a user defined data type and C++ gives you a lot of freedom to make it the way you want. However, if you make it overly complicated people cannot use it effectively. As a rule of thumb you should aim to make your data types behave roughly like an because screwing up the usage of an is pretty hard. To add 2 s you write something like this: 

Don't put into a header, because everyone using your tree now also has the whole standard library in their namespace. Put the public parts above the private parts. People are only interested in what they can actually use, not the implementation details. should be since it cannot be used in a meaningful way anyways. Don't use , use instead. is just a macro for (in theory it could be something else, but in practice it never is). Nonsensical things like and compile even though they are clearly errors. doesn't have that issue. Prefer initializing in the class directly instead of writing a constructor. 

I don't like that you use to set the function. suggests that I can append a bunch of functions and they all get called when the event happens, which is not the case. would be better. It would make sense to take advantage of move semantics. The lambda that gets passed into is moved into and then copied into , when 2 moves would have been enough: 

Now what? What can I do with that? Do I need that? Is this ... important? I would have chosen 'getMessageKeyPrefix' or something like that. Why must this be exposed anyway? 

This is just useless. It's not only useless, I have no idea what I have to do with that information. And it's wrong. The first line after that comment is the serialVersionUID. And it's not parameters. Just get rid of all those comments, it's just clutter and misleading. serialVersionUID Disable the eclipse warning for the serialVersionUID. And delete all of those uids. When I'm pair programming with my apprentices, I forbid them to use quick fix. Because they don't know what the error/warning is, and what the quick fix does. public variables Don't explose implementation detail: public GeomVectorField roads = new GeomVectorField(); See information hiding another comment Okay, I withdraw my previous statement, THIS is the worst: 

Extract the code, which does read in the FZ3 file in a separate method and call it . And get rid of the comment. 

, and instead of putting the listener and the consumer to the map, I use the consumer as key and value, wouldn't I achieve the same thing? If yes, I think you should be able to use this one: $URL$ 

The code looks very nice! However, here my small complaints: Tests The tests are good, but you're testing the implicitly, when you test the . The itself does only the following things: stream, filter with the given predicate, and count. The static methods im should be tested separately, as should the logic of the . The problem is, if the test fails, you don't know if the problem is the or the . The more "implicit" things you test, the harder is it to find the bug. You're testing with too many values. The logic itself should be the same with two values (one is a palindrome, one is not) as with four values (two palindromes, two not). If the behaviour for two or four values is different, then it's two different test cases. The lists to count/filter can have a better name. To make a test case more readable, it's usually split in the three blocks given/when/then, separated by an empty line. Setup the test data / perform the action / assertion. Also, I recommend, but that's personal preference, to static import static methods, at least the assertion methods, so it looks a bit more clean. What's missing (at least what I couldn't find): 

After having criticized a lot let me say this: I would probably hire you. You show a good understanding of C++ and should be easy to shape into a good software developer. Good luck! 

This implementation uses a second array for the merged list. It is probably possible to do it in-place, but that requires some more effort. My solution reduced the complexity from O(n*log(n)) to O(n), but changed the space complexity from O(1) to O(n), which is not strictly necessary. I would probably favor your solution because it is easy unless it is proven by profiling that the small efficiency deficit is a significant problem. 

Some of your member functions should not exist. You don't want algorithms and containers to result in implementations, because that number becomes rather big. Also people tend to forget to add all algorithms to their containers, especially when new ones appear. Instead you are supposed to implement algorithms and containers separately to only need implementations. This applies does not apply to , and that have a non-member function , and because the member functions are more efficient than the free standing functions. Also only moves elements while actually erases them. Unfortunately it doesn't apply to because requires random access iterators which you don't have. Your implementation seems to make a lot of copies. If you can't find a clever efficient way you can just create a and that and then apply the positioning to your list. I would expect a linked list to work with move-only types such as , but it doesn't because you copy s in various functions. I am getting compilation errors with both gcc and clang. It looks like you only tested with VS's compiler which tends to be a bit lenient. Avoid functions. That is what the destructor is for. Also you already have . Your does bad things when . For example you can do 

Gzipping may take some cpu time, but transfering bytes is often way more expensive than gzipping Strings. Of course, this has to be measured, too. 

It makes perfectly sense to make that not cachable. You want the result based on the actual exchange rate, and this changes every second. What I really don't like: Your interface has a HttpClient and is therefore coupled to implementation. This should be moved to the actualy implementation. The next thing: You're caching is also coupled to the technology. So if the backend changes, let's say you get it from a database, the caching mechanism is not reusable. I think it's okay for your case, and I wouldn't bother too much,... but, if you consider testing, you actually can't unit test the caching. 

Oh and why are you declaring (Coordinate of what, btw?) and (Point of what, btw?) not within the while loop? main() method 

Change behaviour during runtime Decorators provide a flexible alternative to subclassing for extending functionality. 

Be more clear about what you read. And if you read something into something, make the method name clear. And why does the start() method read data? Is it because the comment (Model Initialisation) is more correct than the method name? 

My two cents Abstraction / inherticance I always try to avoid abstraction and inheritance. In general, it's really hard, to achieve a high cohesion when working with abstraction, because it's very tempting to mix abstraction and implementation. Beside that, it's not possible to (unit) test abstraction without implementation, the other way round, often you will test abstraction/logic from the super class implicitly when testing implementation. Also: The more inheritance is present, the more complex it gets - if you pass another parameter in the constructor in the base class, have fun changing all your subclasses. Some subclasses override methods, some don't, some call abstract methods, some don't. A very confusing part of your code is: A Player is a hand. The Dealer is a hand. They both should have a Hand, don't they? overcomplicating things I don't see any need for your interfaces, for instances the and interfaces - nowhere in the code you declare anything as one of those types. If anyone teached you, to make your application "future proof", by this sort of "over-engineering", don't listen to him: in most of the cases, it's not needed. I used to do that, too, but I just ended up with way too much unnecessary and harder to maintain code. Or sometimes even worse, what I thought, what will help in the future, had to be dismantled, because, well, I ain't no fortune teller and the requirements went the complete opposite way. separation of concerns A class should do one thing, also called single responsibility principle. Your class is a , does calculate the score, prints the status and does some initialization. Since a Dealer should not be a Hand anyway and should be a state of the Dealer, some responsibilites will be moved to the correct place. Printing/displaying objects is something I see often at the wrong place. Objects shouldn't display itself, there should be a separate type which does that job. Other things Noone seems to call ? I only find it in the interface and in the implementation. And I think there's other unused methods, too. The IDE should usually show unused code, if not, try to figure out how to activate that. Dead code is something like a deadly sin. Also: Sometimes you work with arrays, sometimes with Lists, I think you don't need to work with arrays. 

Your solution If I wanted to do the obvious solution of squaring the array and sorting it it would look something like this: 

Now you get more type checking and have less repetitive typing to do ( instead of ). I did not capitalize because it is not a macro-ish constant anymore. A side effect of this is that you cannot do anymore because does not decay into an like does. Instead you can define addition and subtraction operations such as this: 

That last line should not compile, but it does. Blame the that should not be there. Unfortunately you need to write 2 classes to get this right in C++, typically and . Looking at the list of things required to make a bidirectional iterator it seems like you are missing some, for example everything around std::iterator_traits which also explains 

It is a bit annoying to do all those things from the linked documentation, especially when you realize that you need to follow more links because it says "The type satisfies " which has yet another list of requirements and that one links to more requirements. On the upside once you did all of it the standard algorithms work with your iterator and you can delete a bit of code. Also algorithms from other libraries like boost tend to work when you have standard iterators. You can initialize members in the class declaration, for example 

There are good reasons why existing binary trees are so complicated. If you want lots of performance with lots of flexibility in lots of cases it costs you a lot of effort implementing the tree. Or you just use and don't worry about it.