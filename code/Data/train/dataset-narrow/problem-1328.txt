When performing a chi-squared test, one takes the square of the differences of the expected counts per bin and observed counts per bin, and divides these per-bin differences by the expected counts per bin, as seen in the formula below. 

I am trying to write an algorithm that can find user-specified nearest neighbors. By user-specified, I mean that the user can specify whether it's a general nearest neighbor, a forward-nearest neighbor, or a backward-nearest neighbor. The idea for this code was inspired from this SO post. While it isn't ideal to search the entire array (perhaps use searchsorted as an alternative), I want to find all occurrences of the user-specified nearest value in the given data array. While there are other techniques that can be used to achieve the same goal (such as using the cumulative sum of differences of argsorted values), I feel the code below is easier to read/understand and is likely quicker since it performs less operations that require traversing the entire data array. That said, I would like to know if there are better approaches (in terms of speed) to achieve the same output, as this code will be applied to a dataset of at least ~70,000 data points. More than the value itself, I am concerned with the indices at which the values occur. 

For this application, I do not care about the order that my objects are added to (in fact, I do explicit ordering later on). My question is whether I could get into trouble here with both functions attempting to add objects at the same time. My motivation for playing around with this is simply to try to speed up this sequence of events, and when I tried using a instead, my timings, obviously slowed down to the point that there was hardly any difference between doing these two operations in parallel versus the old, serial way. When I use a simple then I do see impressive speed-ups. So, considering I am just adding objects to a collection in a parallel fashion, is using a non-thread safe collection asking for trouble here? My real-world experience with multi-threaded/parallel programming is very sparse, hence the uncertainty here. 

Additionally, depending on the size of your data set, why do five different Count() executions on ages when you could just group that data before hand like this: 

This works fine, but I'm asking here as a fishing expedition to figure out if there are any clever ways to implement this functionality without either: 

My situation only included static methods on non-static classes, but it should work just the same for your situation. 

Since the sum changes with each iteration through your dictionary values of , I don't know of a way to pre-compute the right-side sums before-hand. This would be a little easier if you could use external modules. That said, you might see a slight speed-up if you use more comprehensions. For example, you can get via . Also, use (not ) to check zero equality and use (not ) to check . Also, you are iterating through all possible combinations. In the case of using and , you know that and . So you know that your lower bound is cut-off at 76. Those are 76 permutations that you do not need to use. You can include a statement at the lower bound since you are incrementing downward (), but I would instead use this lower bound as the starting point and iterate by incrementing upward as you may find some other way to restrict the sums in the upper limit. Lastly, the use of globals and non-descriptive variable names makes it hard to edit the code. For example, instead of , instead of , etc. Also, you can pass into . I personally prefer iterating over lists instead of dictionaries since you can use zip. I don't have a full solution for your problem, but it may help as a start. 

I agree with Raj that you are probably best off not trying to unit test your WCF services themselves, but I have a suggestion specifically around your concerns regarding your static class/methods, assuming you are using VS2012 or later. I recently had to write some unit tests for some classes that themselves called some static methods that I could not modify. What I ended up doing after some research was utilizing shims. Here's a simple example: 

Why bother with having table be a two dimensional array when it is just a stop-gap collection to get you to ages and districts? Why not just do something like this: 

I'm playing around with switching some code to using and I have a question about whether I need to be concerned about the effects of concurrency here. Here's a simplified version of what I'm doing: 

I don't know how I feel about this implementation. It certainly is better than what was there before, but I have a strong sense this could be improved some how. So now, in the relevant pages, I can simply do this: 

I'm refactoring some code around a couple of ASP.NET Web Forms pages and decided to try out a variation of the Abstract Factory pattern of my own design. I need to create an implementer of an abstract class based on what query string value is available. Here's (a simplified version of) what I have right now: