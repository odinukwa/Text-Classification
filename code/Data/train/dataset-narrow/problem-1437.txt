Comments Your comments are part English and part French. Pick a language and stick to it, don't alternate between languages. Hard-coded values There are a lot of hard-coded values in your code. For example: 

Book name: 122 characters. File name (incl. extension): 160 characters. There can be a lot of authors: 

HackerRank currently has '7 days of JavaScript' going, a quick intro into the JavaScript language. Every day a couple of challenges will be made available. One of the challenges of today was this: 

All dots must be clicked in a specific sequence. If a dot is clicked and allowed to switch, it will light up if not already lit up. If it was already lit up it will darken again. The sequence to light up the 8th dot looks like this: 

If you aren't sure whether you replaced them all, works in pretty much all editors. Often there's even a search and replace :-) 

Notice the underscores make your function easier to read. The comment above the call to is quite useless: 

Right? Because your code isn't exactly structured. Part of that is due to incredibly large functions like these containing abominations like these: 

I noticed your commenting style and decided it's worthy of it's own answer. You admit the comma is not always a comma. So don't call it a comma. I went for separator, which is as neutral as it gets. If you think of something better, go for it. Also, I think your comments would fit better as a docstring than as comments. 

I have implemented the "Sum All Numbers in a Range" challenge from Free Code Camp quoted below. The code works like a charm, but I don't think it's idiomatic. The challenge hints imply I should be using , and . In addition I used the spread operator from ES6 to simplify both calls. I'm looking for a more idiomatic way to solve this. I think it can be done in a one-liner, something like: 

I've rewritten as , easier on the eyes. And you made a good start by putting it in a variable (which, according to the PEP8, should be since they're pseudo-constants). So why didn't you put the others in variables as well? Look at how the functions you call have named their arguments and use this as inspiration for your variable names. Keep in mind you're using spectograms as input. Spectrograms have some downsides, since they only measure intensity of frequencies and not the phase. You may have heard this problem described as the phase problem. This means every spectrogram has broadband noise, impacting the overall effectiveness of your output. The measured effectiveness might not even be the real effectiveness, since it probably assumes you actually like the noise. So, not only could you use more data to achieve a higher accuracy, you may eventually need more complete data. As in, less noise and with phase information. As for performance, there's not much you can do. Your code runs significantly faster on my laptop than on your Mac (original set-up in under 15 minutes), even without using a GPU as acceleration. Tensorflow is pretty well optimized to use multiple cores. Keep in mind the X-axis displays steps. The time it takes to reach a certain amount of steps can vary wildly depending on the arguments you provide. 0TWRK8 took 3 times as long to reach step 500 than H57Z4I, while the latter appears to be scoring better. Figure out which arguments are 'worth their weight' and which simply slow you down for little to no gain. My advice? Experiment! After a couple hundred epochs the data will just about flatline, so going above 200 isn't particularly useful when going for sample runs. Fidgeting with the input reminded me of a game I played a long while back: foldit There's the early game, the mid game and the end game. In the early game, you're looking for the big changes. The later you get, the more your focus shifts to different aspects to fine-tune your approach. However, if you had an inefficient start, you couldn't fine-tune enough to reach the score you wanted. The score would flat-line. Consider developing this machine in the same manner. Don't rush the development to make it go fast if that will hurt it's accuracy in the end. After all, nothing is as annoying as speech recognition that only works half the time. If you need certain functions to keep your output in good quality, don't optimize it away only to regret it later. Something else your dataset doesn't take into account, is combinations of characters. isn't exactly pronounced as a combination of and . The same goes for , and other combinations. Keep this in mind when you start field testing your network. 

You really don't want to name a variable . It's ambiguous. So how about a containing all the relevant information of a ? 

The writing style gives away they're supposed to be constants, so the only comment on it is unhelpful. Why is there a blank line between and , but not between and the loop? Why are the constants being defined inconsistently? Whatever you do, be consistent. That entire for loop is usually replaced by a generator expression in modern Python. Although might be even faster, I'm not sure. But say you want to keep the loop around, is there anything to improve? Plenty. 

Way too much code indeed. Java is verbose, but it doesn't have to be this verbose. There are also too many magic numbers. Code should be self-documenting and yours isn't. The variable naming is iffy at best and the case switch should've been a map, or at least an array, of sorts. You have created a , but it's unclear what you mean with this. Magnitude is about relative size. That's good. Roman numerals are a relative system. But your is a mess and extending it with only makes it worse. I'm going to be harsh here, but if you'd present this in an interview, you would not get the job. That's ok, you simply weren't familiar with the in-built constructs of the language. But those exist for a reason and you should show at an interview you grasp their basics. That's one of the things an interview-question asks of you: to show you know how to get something simple small done using the tools the language already provides for you. Don't re-invent the wheel unless specifically asked to. Now you've tackled the problem, consider looking at how other people have solved this problem. Their approaches and the answers provided can teach you alternative methods to familiarize yourself with. 

Basically, it works like a charm, the result looks like a charm, but the code itself could use some serious clean-up. 

Those produce the same output. The proper way would be turning into a proper data format and parsing it on request or reading it from somewhere else. You really shouldn't have hard-coded strings that long in your code anyway. 

For one, did you notice the list of is an exact copy of the list of ? Did you also notice how there's exactly 26 letters in the alphabet and this is not likely to change? Did you also notice the location of the letter in the alphabet is not likely to change? So why don't we simply write those lists into more lists? 

Disclaimer: No actual kittens were harmed while writing this program. The number of iterations is held in the variable . I know is a more fitting name, but that's already claimed as a type. The above is compiled using the latest lci using the 1.3 specification (thanks to Pimgd for the link). Since the 1.3 specification doesn't contain every feature of the language, see the 1.2 specification as well. I don't think LOLCODE has templates or the likes, so getting all the output on screen is a bit tedious. Output: 

Which doesn't do what you think it does. If you'd make a Player class, that class could have a function which is only allowed to move the current Player. 

Your menu could be replaced by a switch instead. Switches are more readable, faster, easier to maintain/expand and the idiomatic way of doing such things: 

Maintainable code has proper naming. Single letter variables are only acceptable for indexes in loops. contains a bunch of strings. Although I understand why it's called , it's a counter-intuitive name. is in a place where no actual generating takes place. The appropriate place would be a function which actually generates something, not right before a statement. 

Variable naming Your variable names could use some love. You may think is a good name for a position, but is also an already existing function in Pascal. Your variable has nothing to do with the function, so avoid the confusion. is according to the standard. isn't. Result I've fixed the above (except part of the naming, I'm not too good at that either). The result: 

Explanation: The print statement in Brainfuck is . The resulting Brainfuck prints the original string character-by-character, so there will be as much as there are characters to print. Between those there will be either if the ASCII is higher than the previous character and if it's lower. The Brainfuck doesn't think. It increments, decrements or prints. Example usage: Input: 

That's 3 counts of per call. It's obvious you're translating something, but the rest is vague. Afar from that, are you familiar with the Python Enhancement Proposals? Some of them include style suggestions, most notably the PEP 8. You might want to take at least a good look at it. The most notable violation of your code against the PEP 8 is your lines are too long. Long lines are hard to read, hard to parse by humans. The readability of your code will improve if you split them up logically. The ugly way of breaking-up lines is with line continuations: 

With half of the code it takes me too long to figure out why it's there. Code should either be properly commented or self documenting. Large parts of your code are neither. On top of that, there are scope issues which will lead to iffy maintainability later on. Let's walk through it, top-to-bottom. Although I'll be skipping large parts to prevent this from getting even longer than the code itself. 

"But let's assume that the entered three numbers have to be summed up and that one has to use xor in some way." Read the instructions again. You're explicitly not allowed to actually sum the numbers. This can be done using XOR as suggested. Your first part of the solution uses , disqualifying your code. The keyword to the actual solution would be checking for parity. Keep in mind you don't have to add the numbers to know whether the result of a sum would be odd or even: 

Yes, this will lead to somewhat longer calls. turns into and turns into . But the moment you get multiple statements in your code, you got a problem. 

Poof! No more . But wait, this still doesn't solve your TLE problem! No, I'm afraid not and I'm going to tell you why. The author of the problem has made the constraints so narrow that the only acceptable solutions are those which use the Convex hull trick. It basically boils down to checking whether a value is instead of . I'll leave the actual implementation of said trick to you. Feel free to post a follow-up question once you've implemented it. 

If you dive deeper into Python, you'll start encountering special variables like . In this case, allows us to see whether a piece of code was included from somewhere else or executed directly. Now, everything inside will only be executed whenever you call the function directly and not when it's included in a different file. Now, assuming I have 2 scripts, and . is the cleaned-up version of your code. could look like this: 

Does it matter when you only have 2 import lines? No. Does it keep things easier when you have 20 of them? Definitely. 

No, we're going somewhere. No waiting involved. So what's that comment doing in that location? Now we're at comments anyway, a bunch of trailing after a brace or on their own line are seldom useful. If you use them, let them indicate blocks. In this case extra white lines are used as well. Like: 

Don't be discouraged by the length of the review. Most of the points mentioned in section 2 and 3 are only there because they'll hurt when you start writing larger programs. At the end of the review a partially fixed piece of code is included to illustrate some of the points. I'll leave it up to you to find the differences and implement the rest of the points mentioned. 

No. is a plural, while it will only take one thing at a time. That this one thing is a collection of other things is irrelevant. Perhaps or is better. Now nobody has a clue what's going on in the following. 

The following pascal script needs a bit of context for it's purpose to be understood. For those who don't give about purpose, feel free to skip ahead. Background A game I'm terribly fond of has a couple of levels which have nothing to do with the rest of the game. One of those is a puzzle: When you open the game, it looks like this: