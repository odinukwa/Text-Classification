OK. I read your question more carefully and I think I've worked out what's going on. Your bridge and everything is working fine. What's not working is that nothing on the bridge is talking to the internet. Which it can't do because it's not actually connected. On your Pi, two completely separate networks exist. The network, and the network to your router. The simple thing to do would be just to glue them together, by changing the interfaces file. 

The linear regulator is definitely the sticking point here. A switched mode regulator is much more efficient and therefore won't take a chunk out of your battery life in and of itself. The MoPi board provides one in an easy interface for connecting batteries like yours to the Pi, and also lets you know about charge status so that the Pi shuts down nicely. I'd estimate a 12 V, 2 Ah battery to run for around 12 hours. 

If for some reason it is actually using 6 to open the file, you can probably use the "Open with..." entry to specify the command line necessary to run a jar file, e.g. java -jar file.jar if I recall correctly, and specify that as the default run command. (You may need to hunt down the correct location for the Java 1.8 binary though first, not just the environment link.) 

That's off my 16 GB SD card. The sdd1 is the boot partition, which you can see is listed as FAT32. Windows reads this no problem. The second partition, sdd2 is Linux (ext4) formatted, which Windows has a problem with. As a result usually it just hides it. You can see this a bit better under Windows if you go to Control Panel, Admistrative Toosl, Computer Management, Disk Management. You'll see Disk X for your SD card. You can right-click on the second partition, select Change Drive Letter or Path, and Remove the current drive letter to hide it. 

Search around the internet for some tutorials to find out how to install drivers and such and how to connect to the dongles and then route traffic the way you would like it. 

I have several of these modules. The problem with the slow ping is a bit strange? It should be less than 1 second, even more like 100ms. The other problem is this module only supports GPRS (115kbs) if your GSM supports dual band GPRS (or 2.5G). Most networks do not support this any more (or are deliberately switched off because it affects voice) so your speed is only going to be a max of (57.5kbps) and even that is optimistic. I would say you are getting about ~36.6kbs. Ping should be good at these speeds but browsing modern websites is fatal. It doesn't matter if you have 3G/4G or better in the area. The reason is that GPRS extends the GSM Circuit switch and the more people logged on within the area the slower things become. So what is this module for then? Well, at 8 bucks a piece its great for sending compressed JSON to servers for logging data. 

The multiplexer works by setting the digital pin combination, to set the Analogue channel you would like to measure. So you cant have real-time measure of all 16 sensors at once, but you can switch between them pretty fast anyway and get possibly all 16 reading within 1 second, maybe faster. 

If you want something internal to a program, the next best bet is accessing /dev/mem directly to control the GPIO. Frank Bu√ü has written some demo code for this. It's quite complex, so unless you really need something stand-alone, I'd recommend the Servoblaster approach. 

Yes, you can direct connect! The first set of inputs you mention, the "Yellow-White-Red" is called composite or RCA video. The Raspberry Pi supports this, it's the matching little Yellow RCA connector on the Pi, next to the headphone jack (see diagram). Connect this with an RCA cable to the matching Yellow connector on the TV and you're set. The White and Red jacks are left and right channel audio respectively. You need a 1/8" stereo to RCA, or phono when it's audio, cable if you want audio through the TV as well. On the Pi you'll also have to enable audio out over the 1/8" jack by editing the config.txt file, by setting . When Linux boots you'll also need to run . That's one option. Without knowing more about your TV, what I'm about to write about is a bit speculative. Generally the Y/Cb/Cr is a higher quality video input called component video. It's analogous to VGA like computer monitors originally used. It's what the original fat Xbox 360s used for connecting, for example. The Raspberry Pi doesn't support this, but the Pi does do HDMI, and there are lots of conversion boxes to go from HDMI to Component video. This is a bit sketchier though, so you're probably best off using the composite video until you get used to things and want to experiment. 

The most stable settings for me are is to use a script file, fifo and the psips script to dump mpegts video over udp 

The official Raspberry Pi Camera does not support 4K, so No - If that is what you wanted. If you have a USB 2.0 4K camera1 that can dump encoded data then yes. As long as the driver is picked up you can use any software you like to capture the stream, even UV4L userspace driver. I do not think USB 2.0 has enough bandwidth for RAW2 capture but possibly if the camera encodes it for you with h.2653 it should be fine. You just save the stream to your drive. 1 - Something like the PanaCast Panoramic 4K Resolution USB Camera - But Linux compatibility may be limited 2 - 4K at 24fps RAW - 4096 x 2304 x 24 x 12 / 8 / 1024 / 1024 = 324MB/s 3 - $URL$ 

Then just clean the solder off and you have a nice clean un populate port. I would suggest using a new LAN port. but if you managed to get yours out without hassle then re use it. For SMD's you can skip applying the normal solder. Just apply Flux and Chipquick solder using the drag technique across all pins. Chip quick cannot be used to remove BGA/LGA (where the pins are under the IC) --Notes 

Its got a heavy python dependency but is very reliable and easy to setup via SSH. You can connect to the networks you need and it will always stay connected to the best one in range. With some more advanced config file editting I am sure you can add custom rules. Another way is to try WPA-SUPPLICANT but I always found that very unstable, and I tried various WiFi and power and all sorts. 

The joy of electronics questions like this is one of the reasons I love the Pi. Unfortunately wall chargers pretty much everywhere in the world work on AC current, which they turn into DC current that powers the Pi. One letter difference how had can it be? Well, alternating vs. direct as it turns out matters somewhat. In alternating current, the electrons in the wire bump back and forth, back and forth in the same position. Each electron knocking its neighbour and vice-versa is what carries the power. The fact the electronics essentially never move is what makes it great for transmission over long distances, like from the power plant to your house. However, because the electrons go back and forth, trying to power a car with an AC engine would be like watching it go forwards and backwards repeatedly. (Not to say that you can't power a car with an AC engine, but I'm using it as a metaphor here.) In direct current, the electrons travel the full distance. This makes the car with that same motor move in one direction only. If we move the car metaphor, where powering of an AC motor is actually trivial, to most consumer electronics, powering them with AC is non-trivial. Hence DC. Why not use DC for everything? The fact that all the electrons are moving means the experience resistance (think friction) which causes them to heat up (hot wires) which further increases resistance (you slow down on a hot day) which means you have to put more power in. In room temperatures it's a loosing proposition. (In near absolute zero conditions it works amazingly well---that's where the super conductors of fabled sci-fi enter in.) Anyway, the difference between AC and DC is why using the wall wort from DC power won't work. They use clever bits of electronics (previously transformers, now switched mode regulators) to make the transition. But there are such things DC to DC convertors. Switched mode regulators do that too. The MoPi board has one, will take any input voltage from around 8 to 25 V (so basically as many AAs as you can find, or any whacky old laptop battery) and make it so that the Pi can use it. It will then also tell you when the battery is about dead. Nifty! 

I just put a class 10 SD card and burned wheezy and updated everything. As time went on and I played around with settings I noticed that when I do a install now it can take about 10 minutes to build the dependency tree. This is every single time I need to install something trivial. The actual install time is fast and painless. It driving me nuts? Why is it so slow? Does anybody know how to fix this? 

This site is another hackerspace shop that has some interesting custom solutions and tags that also work on the 125Khz spectrum, but still up to 15cm maximum range. UHF ~900 Mega Hertz - Long Range These are more pricey and need dedicated hardware and use various kinds of antennas. Short range ones for about 8USD for up to 50 centimetres (this is what you want) and long range ones up to 6 metres that costs up to 250USD. The tags them selves are very cheap in bulk about 0.10USD at 1000 units. Here is a system that can read certain RFID UHF (~900Mhz) tags up to 4 metres. There is no price so I assume its darn expensive and it doesnt support all tags and uses some kind of proprietary SDK, over USB and is supported on Linux. These are typically used in Toll Gate systems where cars have E-Tags This is a USB receiver for 177 USD but still needs an antenna. The initial investment might be expensive but from there on after the tags are cheap. 

It seems like a very cool project, but I don't think you actually want a browser in a browser. I think you want something like Coherent, which essentially lets you construct an HTML5 user interface. (In which you can embed a proper browser window as part of it's framework... I think.) The problem with this is that Coherent's not free, open-source, and probably doesn't support ARM or OpenGL ES. But I think it's the sort of thing you'd need to create the user experience your mock-ups suggest. You might be able to instead of using frames, as part of a UI toolkit have multiple browser instances, sort of like tiling windows in a window manager. I think Qt might let you do it. In that scenario something like a full screen application with a few browser instances inside of it. This is really quite speculative on my part. Overall thoughts: very cool project, probably doable, but very tricky. 

I've had this problem before and although not with a RaspberryPi, the solution is still valid. Because of the high electrical requirements of a relay and the low power output of the GPIO pins, you need to step up the current to power the relay with a transistor. The GPIO pin gets connected to a resistor, which connects to the transistor. I've previously used a 2N2222A to good effect with a 1.5 Kohm resistor. The emitter gets connected to ground and the collector gets connected to the - of the relay. (The + is connected to a sufficiently high current/voltage source to drive the relay. Max 40 V.) Source, page 329. 

You can SFTP into the Pi's - Because SSH on the Pi by default has SFTP enabled. If you are on a public network, SFTP would be good option as its encrypted but you should create new users with keys rather than passwords. 

Low/High Voltage (Grey Area) This is where your brain (MCU) and muscle (Transistor/Relay) come into a critical compromise. You turn on the relay by driving a transistor, like 2N3904 or 2N2222 on the This ensures that low voltage and low amperage are used to switch a high loads . Here you can use normal core wire since you are only driving the relay and not the lights yet. You take 12v+ from battery (1A/2A FUSED! But one is enough to drive several relays) and connect it to the relay/s, the output form the relay goes to the of the transistor, and the goes to - Which ground? Well in this case the cars ground is fine, since you are powering the Pi with a power adapter connected to the same ground essentially. What you want to avoid is a floating ground. Say powering the Pi separately, from a separate battery, that is another problem. The diode is across the INPUT and the OUTPUT of the Relay. This is essentail to stop fly back current produced by the magnetic coil in the relay. The symbol of the arrow is important, as you know. The yellow zone is your high voltage high power, with cables suitable for the lights you are driving. 5A / 10A / 15A. Also, all fused (separately) as close to the battery as possible and GND as close to the chassis as possible (or common GND on cars with lots of electronics) You repeat this as many times as you need. You may want to put all the elements on a bread board, the transistors and relay output. Basically, when you drive the GPIO HIGH, the transistor will allow the 12volts to "flow" to GND, turning on the relay, which turns on your lights. Even with 5volt relays, you need this, because the GPIO is not supposed to do heavy lifting of any sort.