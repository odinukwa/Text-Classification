Calculating padding Storing your results as an means that you are also doing integer divisions for . You will need to add 1 more whitespace (start? end?) to fulfill your requirements, or can it be assumed that will always be an odd number? Validation You also do not validate whether \$number < 0\$, it'll be nice if you have done so. :) 

Generic type declaration Your s are missing the type parameter, i.e. in your case . This ensures they can only contain objects. vs instance fields is the only instance field used in the only method of your class. This means it is likely better to exist as a method variable, and in turn your class becomes an utility class where is now a utility method. Primitive unboxing On a related note to the first point, you are implicitly relying on primitive unboxing, i.e. converting an to when you do this: 

You can also consider removing the temporary variable inside , since the repeated method call is likely to be optimal enough. There's also another approach you may want to consider, which is to pre-shuffle your first (using Fisher-Yates perhaps, or one of the two available method?), and then simply take from either the head or tail of your . This would be more optimal in cases where you use an implementation that lets you perform an item removal without having to resize/shift its internal state, but then this is a minor point to consider for a simple 40-element . 

Input validation It looks like if is not , then you will be overwriting with the contents of an empty . -based processing If the file sizes you are dealing with are relatively small enough to fit contents in memory, you can consider reading them in as a , do the required processing, then write it out via . This avoids having to concatenate repetitively while using the . For example: 

In this case, your type is no longer used as a 'flag', instead given an arguably better usage for performing the calculation. 

P.S.: I usually prefer using TestNG's annotations for parameterized testing, but I figured that telling TestNG to iterate through all the dates since 1st January 1 AD may be too much... hence the manual looping in each test method here. P.P.S.: One very minor point, if I were you I will also consider putting the two validation statements in their own validation method. 

First, you can use to convert a of to . Next, you just need suitable implementations to sum all the quantities per product ID, and group by that... Putting it all together: 

Based on the name, I will prefer validation to be done within . Oh, and it should have getter methods that your implementations can use, and I'm guessing that's already the case as the fields are private. On a related note, how else will be used by , besides the method? 

(Pro-pro-tip: The can be a field...) For the method, you can check for a valid format first before validating the entire string: 

UX In my opinion, your prompts shouldn't be SHOUTING AT the user. Also, you shouldn't be enforcing negativity by suggesting . I will suggest something more encouraging like "Please try harder the next time". Java 8 In Java 8, getting statistics for a set of integers can be easily done via . Hence, instead of looping through your inputs twice to perform the calculations manually, you can have something similar to: 

A non-Guava-based approach With Java 8, one can also learn to apply the new -based processing techniques that can simplify most of the explicit looping. For example, to read a file in as a of lines using : 

This uses the to map (used as a method reference here too) to a of the returned by , by them . With this , we can then iterate through its entries to call your sending methods via . Putting it altogether: 

If should be used only by , consider making them . Ok, so even if you prefer not to use regex (fair point), how about ? I feel that it's easier to read than the condition you have, short of the one-liner regex: 

Error handling Since this is going to be a public utility method, you should pay closer attention to error handling (unless you're told likewise in this... assignment?): 

Small tip: Since you are pushing a new value to the end of the array, you may want to consider reordering the method parameters so that the incoming value is indeed to the right of the array. 

Now, I must say this is totally untested as I don't have Lombok... maybe the method reference way of declaration might not work. 

I have taken the liberty to declare your file paths as constants outside of the method, again as a good practice. Also, I have opted to use a , which is buffered, so that I can make use of its method. Determining the student's details and ranking You are creating only one instance, and then repopulating its details for each input. Ideally, you should be creating a new one each time, so that they can all go into a in the future for further processing. Right now, you probably can settle for temporary variables in order to print them afterwards. Assuming we are sticking with your approach, you can hide the creation within its own method, e.g. . The idea is that given a instance, student details can be retrieved and a instance is returned: 

Your log output shouldn't also be detailing the code that failed, because the JVM is going to generate a more detailed stacktrace, and you should print that instead. 

This can be simplified to ... Wait, that's not the right advice. Why do you even need a when you can simply count? 

That doesn't mean you have to declare them as . :) Declaration by interface () is recommended as it lets you abstract away implementation details from users of the field - they only need to know they are interfacing with a instance, and you are free to replace with different implementations down the road as you deem fit. 

is not a constructor, and you have one private and public constructors each. Better to remove. Your tests, at first glance, seem to imply that is actually splitting the list up into lists containing even and odd numbers. This is because the method name simply said and . Furthermore, I get it that your implementation is simply doing a modulus with 2, hence the concept of 'odd' and 'even', but a layperson will simply read your test data as "0 is the first element, 1 is the second, etc." This gets even more confusing, since now they will be concluding that getting the odd elements should be . Perhaps renaming the method as will be marginally better, and to use pseudo-random integers to minimize any confusion as to what the method is returning.