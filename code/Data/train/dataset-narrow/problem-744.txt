The primary importance of first normal form is not that it eliminates redundancy, but rather, it's that it eliminates repeating groups. Instead of having multiple columns of the same kind of data in a record, (0NF) you remove the repeated information into a separate relation and represent them as rows. This is what constitutes 1NF. Tables that have columns like: , , or that contain list-oriented data like: violate 1NF. 1NF is important because it is much more flexible than 0NF while being much easier to use when inserting, updating and reading data. This is because every type of data element (e.g. customer phone number) has exactly one column in which to find it and that column has only one piece of data for each record. This means that you can use simple SQL statements to read or write individual data elements without having to parse delimited strings or use constructions like: and so forth. Regarding 1NF vs 3NF, the normal forms are cumulative. A table in 3NF is also in 1NF, so it is just as true to say that "Every table in a relational database should be in 1NF" as it is to say that "Every table in a relational database should be in 3NF." I would say both of these are true, but I would add "unless you have a really good, well considered reason to denormalize". 

For your date ranges, always use the max collating value (typically 9999-12-31) for the end time to represent "current" or "until further notice". This means that your queries for finding a record that is current at a particular point in time (including ) will be consistent. See also my answer to a similar question on Stack Overflow, with additional details and tips. 

The relationship between and is not important to your system! At first this seems a little bit counterintuitive, but think about this: Does your boss care who actually owns a car? No! What they care about is who (PERSON) signed a contract to pay to have which CAR parked in his garage. Therefore the relationships that are actually important are between CONTRACT and CAR, and CONTRACT and OWNER. The relationship between CAR and OWNER is not directly significant to your system, unless you have a business rule somewhere that says something about how contracts stay with cars, not owners when people sell their cars. That is probably dicey from a legal perspective. 

EDIT: In response to OP's quesiton in comments: This is a query that would tell you whether or not one column may have a functional dependency on another column: 

Track the facts that drive your ranking system in normalized tables according to what makes sense for those facts without regard to how it drives your ranking system. Then have a separate table or tables that converts your basic facts into a points system that allows you to do simple sorts for ranking. The reason to keep these things separate is that your basic facts are driven by some kind of usage of your system, whatever that may be. You want the code for tracking this usage to be clean and maintainable. Even if you didn't have a ranking system, these facts would exist. The logic to maintain these facts is independent of the logic to calculate rankings. The ranking rules are an extra layer on top of the facts. Also, your rules for ranking could (easily) change over time, so you don't want to tangle up your basic facts with less stable rules. 

Note that depending on how you key your table, you can also include physical inventory adjustment records to make allowance for correcting your balance on hand. Depending on how much data you have and how much (and what kind of) reporting you need, it might make sense to pre-calculate some of these values and store them in a second table in a data warehouse type of scheme, but don't pre-calculate data unless you're pretty sure you need to. Having two copies of the same data (raw transactions and data warehouse) means that you have potential discrepancies to manage. 

The only sure answer to this question is "it depends". This is a business rule and the organization will set this business rule. Here is how you can go about thinking about what the business rule might be and how you can determine the best way to model this relationship. Think first about cardinality. Is course related to only a single department? If a course can be multidisciplinary and offered jointly by two departments then you know right away that course is a strong entity. Second, think about functional dependencies. What are your candidate keys for course? Do you have a candidate key that does not make reference to department? If so, then you have good reason to presume that course is a strong entity. Do all of the candidate keys of course reference the department that offers it? That may be a strong indication that course is a weak entity. Third, think about the future. Let's assume that you determine from the above that course seems to be a weak entity. Is it even remotely conceivable that the factors that led you to this conclusion might change? If so, you might want to consider promoting course to a strong entity and inventing a candidate key that does not rely on department. This is a matter of opinion and people may have different philosophies about this. On the one hand, some people feel that making key changes in the database is a big, painful process to be avoided if at all possible. On the other hand, some people feel strongly that your data model should reflect your current business rules as closely as possible. 

The way it works is you have three tangible things: Users, Allowable Actions (the access that is being controlled) and Roles. Roles are groups of both users and allowable actions, therefore there are two intersection tables which record the people in each role and the actions that role permits. Some people include additional information in the ROLE MEMBERSHIP and PERMISSION intersection tables, like when the record was created and by whom. Some people keep that kind of audit log information in a separate table. In this model every type of user is stored in your table. The rules that you have stated for cardinality of users (one owner, one assistant) are frankly very brittle if you ask me. I don't like to cast rules into my data model which are almost certainly going to change. It seems unreasonable to me that a business will use your system if it doesn't allow a manager to delegate their responsibilities for when they are off duty, on vacation or away from the business. Your cardinality rules should be enforced in application logic or with additional tables related to USER if you really feel they need to be in the data model somehow. 

Note that the table allows you to keep two or more versions of a price for a given time of day range. Note also that the table uses effective and expiry dates to link parking lots to a price table by date range. This allows you to set up a price change in advance so you don't need to load new data in the middle of the night when a price change takes effect. You're queries for pricing are going to have to find the version of the price that applies based on the minimum stay length, which is much more complicated than just "What is the price right now?" since it will depend on how long a stay is and which is the best price that the customer qualifies for. Also, the price a customer pays will depend on how long their stay is and it may cross one or more price point boundaries. 

Your table looks to me like an invoice detail table to me. This means that if you know what invoice and which line on the invoice, you know which distinct record you're looking at. If that's the case, what do each of the non-key columns depend on? Let's look at each in turn: 

Why most of the time yes? The most fundamental answer to that question is that it is pure hell if you ever need to modify a primary key value on any table. Since almost anything a user can see or touch is conceivably subject to an update at some point, using a visible key value is inviting pure hell. Using a surrogate key will keep you from falling into this trap. Having said that, remember that there is room for YAGNI in applying this concept. You don't need to go forcing code tables with IDENTITY keys into every nook and cranny of your schema, just in case someone decides that the symbol for male gender in your employee table needs to change from M to X or something silly. 

First off, your table doesn't appear to be in third normal form (3NF) because you have attributes that depend on only part of one of your unique keys. You should really have a minimum of three tables: 

The issue is that the rules state that if a card has a sub-type, that sub-type must be valid for the given (super)type. Since not all types have sub-types in this model, you need to have a many to many association between the list of types and individual cards. At the same time, you need to have a many to many association between the list of possible sub-types and individual cards. You are in a bit of a relational model rock and hard place. It depends on how you want to optimize your model. You can optimize for storage or you can optimize for retrieval. Optimizing for Storage: You can eliminate the redundancy by linking types without sub-types directly to cards. When you have a type that has sub-types, don't link the type, link the sub-type instead. This avoids redundancy and the potential inconsistency of parents and children contradicting each other. It sucks for data retrieval, however. Optimizing for Retrieval: You could instead link all types and sub-types (when applicable) to cards and then you have redundancy to manage - either with triggers or some other kind of application logic. There is one more option you could try, which is a kind of combination approach and which manages to push the complexity into a more rarely used corner of your application. In the third way, you collapse type and sub-type into a single table with an involuted relationship (self-reference). Now when you assign a type or sub-type it automatically implies any parents of that thing. Given the rules requirement for enforcing membership in the type before allowing membership in a sub-type, I would be inclined to just live with the redundancy. You need a business rule that says you can't have the sub-type if you don't have the type. That's the kind of business rule that needs to be in code anyway. 

This makes it clear which column in the child table is the foreign key to the parent table. Indicating primary key status can be done by underlining the attribute in question. What may be more useful than this is a naming convention that makes it clear what is the primary key of a table (easily done if you use surrogate keys by convention) and what is a foreign key column. Some relational model diagrams also include a key participation label to the left of the column names in the list of columns (e.g. "PK", "FK1", "FK2",...) which can help especially if you have composite keys. 

I think you want to go with your first option. Here's why: You should design your database with a primary goal of maintaining data integrity. Subtle data corruptions can be harder to debug than source code logic errors. This is because corrupted data may only cause a detectable problem when a series of conditions occur at runtime. Often you can't repeat these reliably. The best way to focus on data integrity is to create a properly structured database. If your data is going to be edited at any time, then you're best to start with a design that's in Third Normal Form (3NF) at least. In general, you should have a table for each distinct type of thing that you have data about. Sometimes, you may have two or more different types of things with similar attributes (data items). This puts you in the position of deciding where you make your trade off. Combining the facts about your things into one table means fewer tables. Fewer tables will mean less code as long as the different types of things are and continue to be similar. If you need to start moving in the direction of each type of thing having its own distinct set of attributes, then your code will become more complex and hard to maintain, with lots of branching logic. It's important to remember that two different tables having the same set of attributes might be coincidental to your system or it might be consequential to your system. Database structure design is not optimized in the same way as code reuse. Cramming logically distinct but structurally similar data into the same table is not a good practice. If you have two or more semantically distinct tables with very similar or even identical structure and your programmer's spidey-senses are tingling too much, then satisfy your urge for code reuse by subclassing in your code, but leave your apples and oranges in their own tables, rather than cramming them into a "fruit" table. In a case where your two (or more) types of things are different from one another, then having one table for each type of thing is probably an excellent place to start. This will keep your logic simple and your data clean, which makes for a high quality system. 

EDIT: In and Out OP says there are two lanes, one for coming in and one for going out. If each lane has a camera and both capture transactions to the same table, you can catch the situation where a car leaves and comes back without any different cars coming in the meantime. If we change the column names to be more generic ( instead of etc.) and add a column which says "in" or "out", then you can change the query like so: 

This would give you a normalized schema with no redundancy and very little risk of data corruption due to insert, update and delete anomalies. 

The PK of your department table is not . The column is an attribute of a table that you have not defined, since it is functionally dependent on the . The PK of your department table is . Primary keys don't have to be integers. Note: If your HR department creates departments with the same name, that is going to land you back in hot water. You might need to create a composite primary key of and . This could still lead to trouble if your HR department can't be trained to keep department names unique within managers. Excel is not a good data source for being able to enforce constraints. 

The traditional way to model this is using a pattern called Role-Based Security. The idea is not just to have groups of users, but also groups of permissions. Here is how the pattern looks: