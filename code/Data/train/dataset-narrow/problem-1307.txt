TL;DR I wasn't going to review this, but I couldn't stop reading it again and again. So, here I am reviewing it. I'm going to go down line by line, but first let me address your question. Would creating a data service class be overkill? Right now, I think it would be. Overall this is a pretty clean implementation. Yes, the presenter is technically doing two things, but adding a data service just adds to the complexity. Add it when it makes sense to add it. YAGNI. Another thing I would like to mention is that you're using a number of custom classes. Which is good. Developers should have a tool box. BUT.. the average VBA developer is not an actual developer. So, take into consideration who will be maintaining this after you've moved on. Will it be a business person who thinks they know how to program, or will it be a legitimate developer who has somehow been suckered into playing Mr. Maintainer for the project. (Let's face it, someone must have blackmailed him or her into it.) I think it makes a big difference on how much you rely on your toolbox that lets you program in a more C# type style. Ok, on to the review... Form's Code Behind 

I love comments like this. Awesome. Well done!, but MS is notorious for killing urls on a whim with no redirect. It would help to leave the title of the article so it can be searched for if the link goes dead. 

So, you're going to your file system object to get the current directory twice in rapid succession and sharing a variable between these two methods. That's smelly to me. should take in a full file path as an argument. Then, doesn't need to be scoped outside of . Actually, I don't see a need for that constant at all in this case. You can keep it if you want, but I've removed it below. 

tells me almost nothing about what that class is. It's enough to guess that's it's serialized from an file, but that's about it. Even then, it's a name that tells me about implementation details instead of what the object represents. 

This looks like a very nice implementation. An iterative solution (without linq) would only serve to obfuscate the code in my opinion. I've found that when working with trees, recursion is a much cleaner and understandable method. At first I thought about suggesting that you change the method from to returning a list, but I think that would be less efficient than this. The only thing I can really note is that you should always use braces. It will prevent future bugs. 

Don't want to actually create these dependencies outside of the class? Fine. Use a poor man's IoC container. 

And now you have it. Of course, no harm would have been done without the guard clause in your particular case, but I find it good to just implement the same boiler plate every time. It kind of burns into your brain after a while. This allows us to follow another bullet point from the doc. 

One thing to note is that anytime you're creating an instance of Excel, you need to wrap that code in a . You take in a string file path, but what if it's not a valid file? Then this line 

Which reminds me... There are a lot of functions that should be private. It doesn't appear that Google Apps Script will let me actually make them private, but I can hide them from the spreadsheet and the function list drop down in the IDE by postfixing them with an underscore. 

But, it's kind of hard to remember what all those numbers represent. I'd define a couple of enums too. Create one for , , and maybe even create one for your cards too. An enum for your cards isn't the best way to go, but it's a good first step in the right direction. One last note: sounds like a Boolean, but has at least 3 distinct states. I'm reminded of What is truth?. Consider finding a better name for that variable. 

It's good that you defined variables for these, but if would probably be a good idea to leave a few comments explaining why you chose these initial values. It's also interesting to note that C#6 supports auto property initializers. If/when you move to it, you could greatly simplify the way you're defining your properties. 

You're mixing responsibilities pretty badly. From the Univeristy of Washington document you linked to: 

The vast majority of time in your program will be spent opening the workbooks. It's a terribly slow operation. If you can avoid that, you'll see massive performance gains. 

It's a touch convoluted because I would expect to be a member of , but it's not. It's the method'd argument. I think some careful renaming and perhaps a comment will help here. 

My standard answer to "how do I do this faster?" in VBA is to use the ADODB library to execute a SQL query against the Excel sheet. It's orders of magnitude faster than accessing the sheet directly, with the added benefit that you don't even have to open the worksheet up in an instance of Excel. It's a technique well worth learning. 

Even though it matches the spec, isn't a very good name for what this function does. would be a better name. gets called in this code a lot. It happens more than enough to declare a variable for it. All of the parameters are being implicitly passed which isn't nice. (And you have no excuse. The add-in you're using warns you about this.) The optional parameter for is okay, but it exposes implementation details to the client. It would be better to create a private function that does all of the heavy lifting. It can require that the midpoint be specified. 

It's hard to say exactly how this will be implemented without seeing the entire sub/function, but what you need is a statement and a loop. Pseudo code to get you started: 

These are all implicitly , which explains the , but should they be? These are the kinds of static members that usually get exposed to the outside world, particularly when creating structs. Client code is going to need these. Never mind. After much digging through the code, I see that you are exposing them to the outside world through getters... 

Of course, this means we have to use the stricter syntax. I think it's worth the time though. A couple of other notes about the creation of the table. 

Yes! I'm a huge fan of this kind of defensive coding. Plus you gave a meaningful message! Awesome! There is a problem though, you should use an and pass it the parameter that failed to muster. It's more semantically correct and provides even more information back to the developer. I encourage you to look up the documentation on the two different exceptions to see more about when each is appropriate. 

Returning a out from your view tightly couples your presenter to this particular view and architecture. All in all, not too bad, but leaking the details into your presenter is much worse. Returning a won't stop you from creating a WebForms web page that uses the same presenter, but leaking the into your presenter will. One of the big benefits of MVP (other than test-ability, which I'll get to) is the ability to use the same business logic on desktop & web. You can't do that because you've leaked details of your UI layer into the business logic. I don't have to time to figure out how exactly to encapsulate the tree view logic in your case, but it is a view concern and should stay in your view. The issue is typically fixed by using a of [your data model] in the view interface definition. Like I was saying before, one of the other benefits we get from MVP is test-ability or, at least, we should get those benefits, but you're not at the moment. This is because you're accessing UI elements directly () and writing to the file system directly from your presenter. I would take a bit of time to create a new class and interface for writing/reading from the file system. This would decouple you enough that you could write automated tests against your presenter. Bonus, it would let you swap out implementations so you could write to a database instead, if you choose to later. Which brings me back to 

I understand that this is an educational exercise, but naming is important. One and two letter names are highly discouraged. When Mr. Maintainer has to map letters to meanings it becomes difficult for him to focus on what's actually happening, because he has to constantly remember that means element and is a . I'm not even going to mention how terrible and are. Oops, I just did. =;)- It's also standard in C# to put opening braces on a new line instead of using Java style Egyptian braces. A dev who swims in C# on a regular basis may have a hard time reading this code as it is. You were consistent though, so I can't complain a whole lot about it. I question the use of a statement in . Typically, switch is used when there are multiple cases to test. I think an statement would work just fine there.