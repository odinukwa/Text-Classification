Several people and I explored this back then in a Flow-Based-Programming implementation for JS: $URL$ I'd consider the approach valid for small environments, but would prefer a different way on the global layer, e.g. 

Interesting use case! The core functionality reminds me a bit of my own AsyncQueue implementation. I admittedly did not have too much of a look at your business logic, though. I hope the following notes are still of use for you. 

This is not quite right since JavaScript (i.e. ECMAScript) is not multi-threaded. Simply speaking, the VM executing the code has a queue from which it dequeues an action (e.g. "run this file") and executes it. This is done ad infinitum. It runs every dequeued element either to completion, to a (in generator functions), an (in async functions) or an (on a generator function). The only way your code can be interfered with (preempted) is using these statements. But even then no parallelism is created, the VM just switches the current queue item it is processing, e.g. to the caller of when the generator function just ed a value. I recommend you to read Concurrency model and Event Loop on MDN, which explains it in more detail and formally better than I can off the top of my head :) The effects of the execution model Endless loops cannot be avoided The following code will print and then hang in the endless loop. 

Benchmarking this, you'll see that this algorithm is about 2-3 times slower than standard sort. Considering the simplicity, that's quite good, and I'd consider it quite acceptable. 

To me, this is asking for an iterative implementation of merge sort, and IMHO even though you made some attempt by doing 2 top level merges, you failed miserably here, as you use the standard on 25 million values. So, let's go back to how merge sort works: 

As Austin Hastings correctly pointed out, the trick is to use vectorized operations provided by numpy: 

To perform this iteratively, we take the bottom-up approach. We can conceptually treat our vector of integers as a sequence of sorted sub-sequences (initially of length 1, and with the possibility of the last sub-sequence being shorter than the rest). We perform a number of merge passes, merging pairs of adjacent sub-sequences: 

Now, one option is to use conditional indexing to modify . Since it's a 3 channel image (represented as 3 dimensional array), and our mask is only 1 channel (represented as 2 dimensional array) there are two possibilities: 

Then again, inside a thread or a process, you can employ the green threads/fibers/JS-esque multithreading approach again - if you feel the need for it, e.g. because of easy reasoning about concurrency issues. 

Your will call , which will iterate the array's elements one-by-one and apply (i.e. call, not await!) the passed function on it. It is now useful to mentally desugar your passed function from the aync/await syntactic sugar: 

I am writing a couple of functions accepting tables as input parameters. These tables constitute a range of options, which should either be given or inferred from default tables. Concrete use cases can be found in the unit tests below. The main question: Is the code idiomatic Lua â€“ especially the use of metatables? Code 

Exactly! guarantees that will be called and completed in-order on the array elements. In contrast, guarantees as well that will be called in-order on the array elements, but not that they complete in-order, too! 

Now we are storing the with the stack values, so when we one we get the new immediately. This turns the () command into an \$O(1)\$ operation. (Your version is likely \$O(n)\$.) 

The idea is to allow a derived class to implement it's own method which will be run by the method. To use it, an has to simply do the following: 

Overall, excellent work here. It's always nice to see your questions as they tend to be very good code-wise to begin with, the worst I can find here is a few nitpicks. :) 

So it's been a while. I present you with a somewhat basic PowerShell script that is designed to deploy our staging environment to production, on a nightly basis. I've designed this to be robust, and also log information relating to the deployment of staging to production. The idea where was to build it simple enough to maintain, but robust enough to support the use-case I had. (In my case, I want to specify a relative path instead of an absolute path.) As a result, I have a lot of boilerplate, but it does what I want, and looks clean-enough to me. I'm open for any and all critiques, as this is something we'll be using a lot. The goal here is to read everything from the staging directory (default to ), update anything in the production directory (default to ), and create a backup log of anything replaced (default to ). It should create a in the backup directory, just in case things need reviewed later and for tracking purposes, with a consistent format. (Actual format isn't important, but we plan to automate processing of the file at a later date.) 

Both classes use , which I also built using Promises. For the sake of brevity, I would like to restrain this question to the queue implementations. Usage example Excerpt from $URL$ 

After desugaring, it is now apparent that this is the reason why will hang on the second iteration. forEachParallel vs. forEachSequential 

This looks like a very good fit for JSONPath (initial specification, list of libraries). Of course, if you only have this single code part which has to do traversing/modifying in a JSONPath-like fashion, embedding an extra library is overkill. If you use a transpiler which supports ES2017, you can make use of the latest Object.values() method: 

Elaborating on the PSR-0 specification The spec defines mandatory requirements your autoloader must fulfill. They provide example inputs your autoloader must accept: 

Quiz: forEachParallel with timeouts Will the following code hang? If yes, where does it happen (in , in , in neither)? What does it print? 

Here I would expect to see at least a function which performs a single merge pass using given sub-sequence length, along with the main sort function which iterates the passes. Using would seem a legitimate approach -- if not, then I'm sure the implementation has already been discussed sufficiently, so there's no need to get into that. I think a decent implementation of a single merge pass could look something like 

This lacks some details, but we can assume it's text, with average 10 characters per number. At least one character being a separator, that gives us average 9 digits per number, so it seems quite safe to assume they're in range of a 32bit integer. So far so good, although your input code could have some better error handling and provide meaningful error messages when the input fails to meet your expectations. However I think you're being overly pessimistic with having to merge files -- as mentioned in another answer, 100 million 32bit integers take ~380 MiB, so it shouldn't be much of an issue fitting this along with a temporary buffer in the address space on much of current hardware. That being the case, I'd keep things simple, and stick with a 3 step process -- input, sorting, output. As such, I would expect to see at the least 3 functions, one for each of those steps. 

Then we create a simple method that will find the method that fits and call it, then return the result as an . You can then pass that directly to a serializer which should be able to serialize it appropriate. 

This is a great start, and hopefully you learned something from this answer. I implore you to find other ways to clean it up (there are two that I see right now) and get you thinking about how to use properties in C# more effectively. Good job, and good luck! :) 

Well, we don't care about that. We really don't. We're going to convert the to a before it even gets there. We're going to work right here: 

I built this wrapper over the System.Security.Cryptography.Aes encryption/decryption so that one need only instance the class and call the appropriate methods. This makes it much simpler to work with AES encryption so that developers don't need to reuse the same AES code everywhere they need encryption. Any and all comments are much appreciated.