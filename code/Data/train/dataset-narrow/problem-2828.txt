This makes instantiating and deleting the event somewhat more tedious, but at least it allows me to use specific types for every event handler. What is the conventional approach to solving this problem? Even better, what is your own ingenious solution? Thanks. 

But that can't be right because just rearranging the pointers doesn't change how the memory is organized. So the author must be talking about something I don't understand about memory management. My question is: Have I misunderstood what the author meant? If not, then please explain how the author is suggesting the rearrangement is supposed to be done. 

It's verbose, but gets the job done. is the agents current coordinate position, and as you might guess is the next step in the list of waypoints which makes up an agents path. The problem is that using the same function for determining which sprite should be used when attacking another agent does not look very good at all. For example, if the target is down, but only one pixel to the right, we would want to show the 'down' sprite, but this function returns 'downright' instead. How can we change it to appropriately return the fitting sprite? 

The strength of this is that I can scroll the map by changing the map surface x and y. Also all the ingame coordinates are conveniently set in relation to the map rather than the screen. However I can no longer use pygame, and I'm trying to switch to pyglet instead. As far as I can tell pyglet doesn't have an equivalent class built in, and therefore I need to build my own, this is what I need help with. I've used pygame.Surface extensively without really understanding how it works (python programmers these days huh). So I'm hoping you can offer some insight on how to get started. I know it needs a width and height, as well as some kind of list of the sprites which have been 'blitted' to it, and that moving the surface itself moves all the contained sprites, so surfaces blitted to it are somehow anchored to the surface rather than the screen. How is this stuff done in pygame, and how do we create a pyglet friendly version? 

Long-winded answer follows. tl;dr, it's a LOT OF WORK. I've used iPi Soft and found that it works fairly well, but unsurprisingly you need to do a decent amount of clean-up on the resulting animations, especially if you're using props and such. I've also used Kinect (albeit a year ago when the available free software was less polished), and you get the same thing there, but are very limited in what motions you can do, especially from the waist down. Expect any of these free or low-cost motion capture systems to be a massive time sink. Assuming you have a large enough room to do it in, you're going to spend literally days working out the kinks to get a workflow going, and expect upwards of an hour for every couple of seconds of animation in order to "fiddle with it" on the PC to make it smooth and believable as an animation for a game--unless you are an experienced animator with good middleware for this purpose. If you require relatively few animations and fairly ubiquitous actions (jump, slash, tumble, run, climb, etc), you're honestly better off spending the money for someone else's work. If you're wanting to do something more interesting, just expect to spend loads of time getting rolling. Also keep in mind that being an actor for motion capture actually takes a certain amount of traditional acting skill and a lot of dexterity and stamina. Much like voice acting, it's more demanding than you might think. If you're wanting a presentable final animation for a game, I would recommend you at least do the trial and then spend the money on iPi Soft or a similar product. In my opinion, for a non-trival motion, a decent animator can rig a model and keyframe the animation orders of magnitude faster than you can get a similar result from single unit Kinect-based solutions. All of that having been said, if you have the time, doing it this way gives you a lot of appreciation for the animation side of development, and you'll certainly learn a lot. 

I want to determine which sprite to use when one agent is "facing" another agent. My game is 2d, and uses 8-directional movement. Deciding which sprite to use for movement is easy enough since there are only 8 options when moving form one square to another. 

My plan has been to use RSA to exchange AES session-keys with a client, which is then used for all the usual in-game stuff. Clients never connect with each other, all communication is client to server only. The question is: Would I be wasting my time by encrypting the communication? How are big AAA multiplayer games doing it? If I do do encryption, is the basic scheme I mentioned a good start? 

And so on, this seems really tedious and if possible I want to avoid loops and just define everything in the simplest, and shortest manner. I'm interested in how you would do this, or if you've already made a similar system, how you solved it in your own code. 

This would cut down on the amount of parameters because all types are condensed into the same few fields. However from a user point of view this approach is much worse because now I have to remember what each parameter was supposed to represent every time; was the radius or the damage in an explosion? To fix this maybe the parameters could live in a , but that still makes handling obnoxious: 

In the above code, you can see that you can pass scaled time along to the things you want to slow down (animations and such, and if your game operates in "real time", any effects like buffs that are designed to last a certain amount of time in-game), but use the unscaled time for things that you wouldn't expect to be affected, like a pop-up in your UI and such. 

If it were me, I'd build it from the ground up with sockets. The amount of data to send is very small, and the turn-based nature makes a little latency unnoticeable. The real question, in my opinion, is what additional features you need on it. Are the game sessions persistent (can someone drop out and rejoin, can the game be saved, etc)? If you're doing a Civilization style save you probably want to push out the save data to all clients, or have the save done client side with a server-provided key embedded for verification. Do you need any sort of between-turn reporting, e.g. "Player 2 is moving a unit" or "Your opponent may be AFK"? If so you may end up wanting to keep the socket connections open. Generally speaking, unless there's some compelling reason to deviate, I'd keep the server as dumb and simple as possible. Leaves less to debug. I also kind of like using plain text protocols, as I can test my servers using telnet without an actual game client (which may be suspect in a given problem), but this does sort of encourage Wireshark manipulation of the data (which you probably will check for anyway). Edit: If the game only supports 1-on-1 games, peer-to-peer connections may be worth looking at. 

I can't concretely prove a bug by using this, but it kind of looks and feels like it should at least be undefined behaviour. So is it OK? If not, what is a common practice for dealing with this situation? 

I'm trying to understand what kind of operation the author is talking about. If I'm getting the overall point correctly, it's that accessing elements that are closer together in memory is faster, so therefor it's desirable to reorder the array such that there aren't any holes left when a game object is deleted. If that is what the author means, then how is it possible to implement? This is what I'm imagining: 

I'm learning C++ and openGL and have this program as a result from tutorials and playing around. The problem is that the main loop is running at "full speed", making the program unnecessarily cpu intensive. I have managed to make it only perform rendering every 16.7 ms or so, but the outside loop that is waiting to render still is iterating as fast as my computer can handle. This is the full main.cpp: $URL$ This is the main loop at line 95: 

That would make the type very bloated, and the handling gets tedious quickly. I considered having fewer parameters, but they would remain unspecified: 

I considered making the event hold some kind of general data field that can be cast to the appropriate type: