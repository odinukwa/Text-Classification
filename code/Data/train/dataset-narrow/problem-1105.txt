Initial Notes The first thing that struck me about your code was that you literally have no variable declarations. Lines like : 

This would then be called by creating a new instance of the class, and then usually by calling the 'Add_TableItem' routine. EDIT: As a side note, I am a super noob when it comes to classes. I know the basic ideas about how they work, but when it comes to terms like immutable, or encapsulation, etc I have no clue what I am doing. I have been working on improving my class knowledge, but putting it into practice is the more difficult part. EDIT: Very simple example of the kind of data that would be loaded in and used (the tables usually are about 100-200 columns with 30k-60k rows): 

Again, this is a very simplified version. Usually I am extracting more data than just a few simple scores. The worst I've had was Day-Over-Day tracking of roughly 40 students on an assignment level basis. This is what led to the need for a dictionary over an array. 

This class uses a code pattern I learned from Mat's Mug. Declare the for the class as a , then declare a private that refers to that type. As a result, you have an organized to hold your variables, and you get intellisense. Once you do that, you just need to open up the property accessors. In this case, I made everything public. This isnt good practice, but I am avoiding teaching you too much at once (I would prefer not to use a class as is, but it is the best approach at this point). This Code Goes in Your Module 

and both fail, but they are valid. passes, but it is, in fact, invalid.* You probably missed the idea to confirm your knowledge with the relevant RFCs, as a conforming implementation should abide by the rules described therein. While Wikipedia is quite reliable nowadays, it is by no means a normative source.   *RFC 5322 describes as follows: 

FWS means "folding white space" and is a construct containing an optional sequence made up of whitespaces that are followed by a single ; that sequence (if present) preceding a mandatory part that consists of a single whitespace. While an address' local part can legally begin and end with a space, both spaces need to be separated by at least one character forming . 

At first, all I had was and so on, each token being assigned a unique, successive number. That wasn't really useful, as stack traces would display the number and I'd have to either remember the type or look it up in the code. I thought that string equivalents would be much more useful, and, to automate the task, I used a call here. The strings are identical to the keys of , so one could think I could stick to strings only and never use variables for that. I think that would get out of control quickly, so, to keep things in place, I assigned the string values as 's properties. I'd like to know if this is a good idea. Once the number of characters to drop in the beginning (calculated in earlier calls to , initially ) is known, slice the string. This variable is used in the following statements and serves two purposes — it keeps the result of the regex match, but also passes on to the statement if there is no match. Is this clever, or "too clever"? The actual regexes ensure that any whitespace preceding the expected token is dropped. The second part of the tutorial mentioned above uses separate tokens for both the and signs. My code unifies all the basic arithmetic operators and uses the token's value to determine the operation to be performed. This is what I would like to see criticized as well. I know that in the future I would have to take operator precedence into account, but I think I could solve it sticking to this way. Currently this is the only way to pass input to the interpreter. Once it gets more complex, I will ensure that the input can be supplied in a user-friendly way. 

This declares a myRange (which the reader expects to be a Range) and converts the range to an array. This in itself is confusing, but, even worse, I can still do : 

We get rid of all of those counter variables (opting instead for i and j which are pretty standard). Our other variables are quite clearly named, and everything is what you would expect. As a result if you (however many years from now) come back to the function to add something new, or if it breaks, you can quickly find the source instead of trying to remember what and were and why you set or to and so on so forth. Again, highly recommend picking up a copy of . The idea of levels of abstraction, functions, classes, etc all can be difficult to understand at first but once you get going your code will become much easier to read. 

Admittedly, this is uglier than Mat's Mug's approach, but this is the approach I use because it suits my style and needs a bit more. The benefit here is that you can choose your approach to handling the error. So, for example, handling an error in the routine can be different than handling an error in the routine. I also avoid statements as much as a possibly can. There isn't anything wrong with them when used well, but I try to anticipate errors if I can. On that note, and as others have noted, some of your subroutines need some cleanup. Someone in the RD group recently reminded me of the 'Single Responsibility Principle'. Everything should be responsible for one thing, and in turn, that thing should align with it's own intent. Along these lines, I would argue, that one unique thing should only ever be returned by one owner of sorts. For example: 

: You are computing a dictionary on the fly, then looking up a tuple in that dictionary and returning the result. If you ever make the same call again, you'll recompute the dictionary and repeat the lookup. Why not cache the results? Build a dictionary of dictionaries, one time at startup, and then just look up values: 

By creating a mechanism for dealing with abstract direction vectors, the code above can be used to compute a score in any direction. So you would only need one function - "what's the score from this point in this direction" instead of your many functions (score up/down, score diagonally, score horizontally, etc.). Block the other player Your "AI" function seems to focus on trying to make a simple pattern, without focusing on what the other player will do. You can probably improve your score by evaluating what the other player is likely to do, and biasing your own moves to counter that. For example, suppose you determine that you have two moves of equal benefit to you: there are two cells adjacent and you can append a third cell to either end of the line. If one of those cells is "important" to the other player, and the other is not, then you should prioritize blocking the important cell before the unimportant cell. Both of them help you equally, but one hinders the other player at the same time. To this end, I encourage you to design a "scoring" system for cells. Each cell can be rated for its value to a particular player - the cell has two scores! You will want to pick the cell that scores highest for you while also scoring highest for the opponent. There are various ways to do this. One obvious approach might be to compute the number of winning configurations that a cell could participate in. A cell in a corner would have fewer than a cell in the middle of the board, and this number would go down when opposing cells were positioned. However, it wouldn't go up when own-side cells were positioned, so an additional metric would be needed... 

Aside from the couple of instances of a single ratio being matched to two different aspects, they are fairly consistent. So then I checked each of the original aspects and their results: 

That was the first step I took in making your code make a little bit more sense. By extracting the two loops, and the dimension check, the main routine becomes much cleaner, and gets to rely on a few s to do the work it needs to do. The beauty of this is that your code now explicitly says what it is doing (anyone could read the code, regardless of whether they have been coding for days or years). The next step I took was explicitly checking for the supported types. For example: 

If is a for example, you will get a error when trying to assign to (the names here are troubling as well). Let's explicitly raise an error if someone passes a value we don't currently support: 

To get you started, you have a number of unqualified references within your code. This is particularly puzzling to me since you declare and pass worksheet objects, but you never use this object when determining a reference. For example: 

I recently found an interesting series that describes the specifics of how interpreters and compilers work, explaining each step (with code) and encouraging the reader to do exercises. My code is mostly based on the boilerplate provided in the first tutorial. The description didn't really seem clear enough to me, so I went on to consult the actual code. That was probably the best idea in my case, as it helped me grasp the very basics of lexical analysis. Once I'd had the code working, I reread the article and by then I felt confident enough to approach the exercises. I had no problem with getting my code to satisfy the conditions in the exercises. However, I'm not sure whether my approach was good. I used regular expressions to tokenize the input and remove whitespaces at the same time. That kind of solution seemed robust; the code worked, but I felt a bit uneasy about it (though I couldn't really explain to myself why the use of regular expressions here was wrong). I then looked at the code in the second tutorial that solved all the exercises, and it didn't use regular expressions at all — instead, it iterated over each character (including whitespaces). I coded my lexer in JavaScript and run it in Node.js (though it can be run in virtually every environment that supports ES6 classes). What kind of feedback do I expect? I would like to see my doubts about regular expressions explained (does any lexer do that? If not, why?), but there are probably many things about the code that can be done better — and I will really appreciate the answers which suggest improvements. There are also a few more questions at the bottom of this post. Note: The script does not yet respond to user input, the input sequence needs to be hardcoded as a string. See below for explanations on certain parts of the code. 

Option Explicit I cannot stress the importance of this being at the top of ALL of your code modules. What does is it causes a compile-time error when a variable is undeclared. This prevents run-time errors when you try to use variables that aren't set properly, and it will save you countless hours of debugging time. Go To Tools > Options Editor > Require Variable Declaration. You'll thank yourself later. Variable Naming Not to be a jerk here, but your variable names are horrible and difficult to understand. You have rng, rng2, rg, q, s, r, cell and the worst part is that you don't need all of them. I declared four variables total (and one of those you didnt even have a variable for, but you did need). Here's a tip, make sure your variables make sense. You should be able to look at them and have a pretty good idea of what they do. is easy to understand: it is the range we are searching in. is just as easy to understand: it is the cell we are currently searching in. Finally, , you guessed it, is the cell we found using our criteria. It is pretty much bulletproof when you start to code like this (actually, not really. You'll learn that bulletproof coding takes a lot more work than a handful of good variables.) and it makes your code easy to maintain. Additionally, there is no need to declare two variables if you need one. In other words, if is used only for the first loop, and never needed after that, I dont have to make a for the second loop. I can just use . General Names Just as Variables need good names, so do subroutines. It is all too easy to take the that the recorder gives us, and to leave it this way. When you have larger projects, and become undistinguishable, and god forbid you have a and as well. Name everything. That's pretty much my mantra. From Worksheets to Tables, and PivotTables, and Workbooks, to code modules, subs, functions, etc., give it a proper name. The sooner you get in the habit, the more time you'll save. Implicit Object References You'll likely hear this one a lot, so it is important to learn. Whenever you are working on an object, you must consider the scope of that object. While looks fine to the untrained eye, anyone worth their salt in the VBA community will point out that it is a unqualified Range reference. Even worse, is if we have and one step further is this nasty bit: