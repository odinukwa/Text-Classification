Type Coercion is not readable! Don't use implicit Boolean coercion of numbers in code which you claim to be "readable" - it isn't. Use proper comparisons in readable code, and leave the cool weak-typing hackery for the golfed version. How much does writing out the actual condition improve the readability of the code? Everything else seems to be fine - naming, indentation, and all. 

All in all, functional programming is about composing functions together to write programs; immutability and stuff is good to have but it isn't primary. You have some repetition, as in the check - see if you can get rid of it (Hint - you might want a function which can iterate over the values of the enum and check if any of them have won). Also, this 

For speed comparison, I did an example sheet with ~ 16000 rows, I read two cells, added them together and wrote them into another... it took about 4 seconds (Excel VBA). When I convert using the mentioned array method it completed in far less than a second... To show it using com, here is an example using python, the set each 'cell' method takes about 27 seconds on my machine, the set a 'range' method takes about 5.3 seconds, ignoring the 5 second wait so you can see the sheet, the 'range' method is many times faster: 

Applying those changes to the code make it about twice as fast. Here is what I end up with for the function: 

The keyword before the method parameter - which I named , because that makes more sense than : it signifies to the method which called that it will not change . Note that this modifier will also prevent any reassignments to , which is OK as you don't reassign it anyway. The spacing, bracing and indentation illustrates my above points. 

You have an unrolled loop, which is good for performance (especially because in Java the size of an is fixed to be 32 bits). However, you could consider turning it into a loop if this performance is not required, that would reduce code duplication. Which means that you could also try: 

I took a little time and wrote the following code to produce enigma encryption. I don't normally write code in C so I would like to get feedback on the way it has been structured and any issues a more experienced C programmer might spot in the way I used structs, command line parsing, and the indexing around the strings to replicate the turning of rotors. I did not create a separate header file since the code is so short I thought it would be best to just have a single file. 

The second part is a little trickier, what it does is uses math.log10 which gives a count of the digits, then it does a mod 10 to get the right most digit, looks up that power to add to the total and then finally does integer division to divide by 10 effectively moving the decimal place 1 position to the left (dropping the right most digit we just dealt with). This is probably a little different between Python 2/3 due to changes in int/float division. It is basically doing what you are using to do but without converting to string and adding the power of 5 dict lookup as it goes along: 

Style Naming: You name your side-effect-free functions in a way which makes users think that they have side-effects. Instead of naming them with present-tense verbs, name them with past-tense verbs, like instead of , instead of , etc. Your indentation and bracket usage are spot-on unless otherwise noted. Errors 

Now, you feel like you've probably lost all your beautiful formatting! Not to worry - to the rescue! It'll get you a containing the representations of all the elements in the , separated by commas and spaces with the whole thing enclosed in square brackets. So now we get to . Why hard-code ? I'll show how you can get the maximum number up to which to check for perfect numbers as a command line argument, and improve usability while at it! 

That limits the change in the field called "sort" as it alternates each time as the "group" changes. I have looked around and did not see a standard way to accomplish this without rolling my own. I think the code is fairly straight forward but curious if I might be missing something or an easier/faster way. Any comments would be appreciated. 

I have had significant speedups when doing those from inside Excel using VBA and outside over COM using python. Here are a few snippets on how it is done, I used the Excel VBA syntax although you would want to adjust them for your code. 

This version of rotates the passed array in-place, so you can just print out the elements in a loop later. For printing, hoping you are on JDK 5 or greater, use the for-each loop: 

What you do is very inefficient. You check if the elements of the list are similar from the outside in, and that too utilising both very unintuitive pattern matching and guard clauses. Note: You do not need to specify the type parameter in the recursive call to , as the compiler can infer that. Your code, on simple singly linked lists, is O(n2), thanks to the repeated O(n) calls to . The code that I explain and provide below runs in O(n), as reversing a list is O(n) and subsequently checking for equality is also O(n). What is the definition of a palindrome? While what you have mentioned is absolutely correct, there's an easier way to think about it. A sequence is a palindrome whenever it is equal in every way to a sequence that contains the elements of the first sequence in reverse order. That is, a list is a palindrome if and only if it is equal to its reverse. I think that as your code already uses enough library functions, why not try this: 

As was already mentioned, I also am not crazy about -1 return, I would rather see it raise the exception rather than an odd exception later about integer subscript so I removed the try/except negative 1 return. Here is the code I came up with after applying the changes mentioned above: 

There is quite a bit of code there. I would start with PEP8 formatting as it makes it much easier to read. The other thing that came to mind is using namedtuple() rather than using the indexing all the time, this may help with readability. As far as performance goes, the best way to confirm may be to do some profiling.... Since I went through much of the PEP8 formatting just to try and see what was going on, I have inlined it here along with the profiling setup at the bottom: 

ing source files A very big issue - especially if you're planning on writing a library: You include a C source file to use . You shouldn't do that to avoid possible name collisions between the ing file and the d file, as all of the advantages you had from the header guards are absent when you import the source file itself instead of the header. The header represents the public interface of the code, so always include that to avoid name collision issues and not depend on implementation details, like internal functions (not that you do that now, but for the future). The problem with doing this right now would be that you have not put your function declarations in the header. Declare in the header (I guess you already know how to do this, as you've already done it for ), and you're ready to use it from your main source - just include instead of . Weird and missing s What is that doing in ? as far as I could find out, it's for the compression library , which you don't seem to be using. Also, you should in to get standards-compliant behavior and compiler portability for the macros you use in . You should in your main file too, as you're using . The header guard is in to save you from the multiple-include problem. Style and Convention 

The other part is a little trickier but in my experience is extremely fast when doing it inside Excel. Perhaps this concept could be applied to your code. 

Once you have that you can look to see if any of the parts in "main" need to be broken out into functions. On the PEP 8 side, here is an example of some of your code with Pep 8 type formatting applied so you can see the difference in how it visually looks. 

Turn off screen updating in excel. Set the calculation mode to manual if you have other formulas and you are changing range values. If possible load all the data into an array and only write it to the sheet once.