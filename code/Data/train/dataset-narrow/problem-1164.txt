for brevity, readability and to not have redundant checks. is not that expensive, still no point in calling it more times than necessary. I'd advice against having HTML in your classes, as you do in . Simplest solution would be to create an array of your database results, return the array and construct the table when it's absolutely necessary - at the script you actually show it. Moving on to , is called every time is called, and that's absolutely unnecessary. Not really an expensive database call, still redundant, you can safely move it into , it's a call that only needs be done once, just after you connect. In general, avoid functions, they are essentially obsolete, kept around only for legacy reasons. Their use is discouraged in the manual: 

If is empty, is set to "no" (can't read the author's mind, but my choice would be , not a string). From the naming we can assume that holds (or not) the keyword(s) of a search. Now if that is not empty: 

and avoid the costly call to . And do return something, tell the user if the operation succeeded or not, regardless of what the Java interface does. 

Consider all of the above as extreme nitpicking, your code is way past the point of obvious flaws. The real value of the answer, if any, was to point you towards the SPL. If you did consider it and rejected it, would you care to share why? 

This is not a Controller. The purpose of MVC is separation of concerns, more specifically the separation of domain logic from the user interface. Let's see where it fails: 

The first clause, essentially checks if there's an "old_keyword" index in the array (and whether it's or not), that's a pretty typical check for arrays. The second check, that executes if and only if the first one passes, checks whether what's in is not the same as what's in . I'm assuming that the author had some reason for that, but can't imagine what that reason is. Summarizing what happens here, if: 

When deleting an item, search through the list to find the previous item, then do the unlink. Have a "deleted" flag for each item. When traversing the list for some other reason, check the "deleted" flag on each node. If a "deleted" node is encountered, unlink it from the previously-visited node. 

Of these, perhaps the first would be most justifiable if one says that degree-polar objects are unequal to any xy object except when the angle is a multiple of 90 degrees, and radian-polar objects are unequal to any other object except when the angle is zero. Even though the closest to the polar-degree object's x coordinate is 1.4142135623730951, the actual x coordinate is closer to 1.4142135623730950488016887242097, so it won't quite match any point whose xy coordinates are specified using a . Unless there's some particular reason for using polar coordinates, I'd suggest having the type explicitly encapsulate an and , both of type . Use fields for those and set them in a private constructor. Even if you have other methods which can construct a point for a given radius and angle, or report the radius and angle associated with a point, make it clear that reported values are not inherent properties of the object, but simply calculations based upon its x and y. 

Such an approach would allow the property to simply return a wrapper object, without having to do any real "work". Code which needs a detached copy of the list could use use , but code which will need it only briefly need not bother. 

one would then be able to infer that because at least one of the 4's was correct, at most one of the other numbers could be correct. 

Implementing a precise atof function is surprisingly difficult since there is no limit to the number of digits code may need to read to ensure correct rounding. Consider, for example, the following two values: 

I was trying to explain the mediator pattern to a new developer, and ended up writing a simple event mediator. Thoughts? EventMediator 

Since , you should consider using interfaces instead of classes, for object dependencies. And as the "hidden" dependency of : It highly depends of what the framework is for. You've gone for the common practical approach instead of the academic one (injection). There's no right or wrong here, it highly depends on the framework's purpose and audience, the academic approach may not always be the educative approach. 

The code is equivalent, and will work (?) if you replace it in your script. Hope it clarifies things a bit. The overall quality of the code is bad, there are some hints of an amateur developer there, and you shouldn't really worry that you didn't grasp what the code does, since you are unfamiliar with the language. It's an incomplete and mostly poorly written piece of code, good luck with it ;) 

Why reinvent the wheel and not build upon the Traversable, ArrayAccess and Serializable SPL interfaces, or more realistically upon one of their concrete children? On similar requirements I would have possibly build my upon an ArrayObject. 

Well, more of a factory method now, which is silly. But not as silly as . If you absolutely need to keep the class's signature as it is, go for it. If not, a PDO wrapper would be the better approach. 

Don't know if this is just poor question formatting, or your style, but please indent properly, this isn't really good: 

checks whether the value is an integer and whether it's a string that only contains digits (thus a integer in string form), any of the two is acceptable for the following check, . I've also moved out of the check, I'm initializing it to zero and will override if and only if there's a need. But let's see what happens if the check is true: 

In the original PongÂ® brand video game, there were two bats which were confined to move vertically. A collision would be detected if ball circuit was triggered at the same time as one of the bat circuits, and if the ball was not already moving in the proper direction for that bat. The ball's vertical speed would be set to an odd number in the range -15 to +15 based upon the number of scan lines of bat that were displayed before the collision was detected (basically the difference between the ball's Y position and the bat's position). What exact bounce behavior are you looking for in your game? 

Note that in a garbage-collected system, it's possible to add items to the start of the list, or perform the #2 style of deletion, in a lock-free thread-safe manner. Nodes which are deleted may get unlinked in one thread and accidentally relinked in another, but the delete flag will cause the node to be unlinked again on the next pass. In a multi-threaded system requiring explicit deallocation, such an unlink and relink sequence could be disastrous, since a node could be unlinked, deallocated, and relinked; locks would thus be necessary to avoid problems. 

Contrary to what some people say, there is nothing fundamentally wrong with having an inheritable immutable class provided that the inheritance contract dictates that if two or more instances are ever regarded as equivalent, they must always and forevermore be regarded as equivalent; further, the class must work correctly without complaint or visibly altered behavior if some or all references to an object are replaced with references to a object which is considered "equivalent". A class won't be able to prevent the definition of illegitimate derived classes that violate its inheritance contract if its methods aren't declared , but since it won't be able to prevent the definition of illegitimate derived classes even if its methods are , so making the methods doesn't particularly matter. What does matter is that the inheritance contract specifies that all derived classes must be fully immutable not only in their inherited fields, but also in all observable characteristics, inherited and otherwise. If a derived class doesn't abide by that contract, code which uses the derived class might malfunction, but the fault will lie entirely with the derived class that violates the contract. It is probably a good idea to make immutable types if one doesn't want to specify exactly what will be required and may be expected of any derived types. There are, however, many situations where it may be helpful to have an abstract base class or interface which specifies that all legitimate derived classes or implementations will be immutable. For example, one might define a class or interface with members to get the dimensions or read the cell at any (row,column) coordinate. Although the most common implementation might use a 2d array as a backing store, there are many different ways that derived classes might store information. If were a class which used an array as a backing store, then all objects that were usable as type would have to have a backing-store element for every cell even if 99% [or for that matter 100%] were blank. Making it a non-final class would make it possible to define derivatives like which could use a much simpler backing store. 

mysqli is a drop in replacement, all you need to do is add that extra i to all your functions (yes, it's that easy ;), but I'd strongly advice exploring PDO. You don't do any kind of validation on the stuff you throw at the database, your code is vulnerable to all sorts of trouble, the scariest one being SQL injection, and the simplest solution would be to use prepared statements. For example, how can you be certain is an integer when you call ? In you also have some HTML, ideally you should move it out of the class, still given the class' nature, don't make it a top priority. As is, your class isn't reusable, if you want to have a different looking pagination somewhere you'd have to change the HTML in the class (and then your first pagination would look weird ;). Read up on separation of presentation and content. Architecturally, there's a bit of a mess with , as it's declared static when it's not really static, as it depends on having been instantiated (for the database connection to be established). That's more PHP's fault than your own, the way utilizes the global namespace always made me chuckle a bit. Now, since it's not really static, there's no point in declaring it as such, just make it a normal public function and feed your object where it's needed. Read up on dependency injection and try to avoid static functions if they are not absolutely necessary. You could just pass the object as a parameter in and , and replace with . Your index file is indeed messy. Start by breaking it up into smaller files, as appropriate. And... good luck ;) Overall, your code is good for a starter, you're in a good path. If you significantly alter your code, don't forget to post another question here, there's always room for improvement, that's just the nature of code reviews (but don't over-engineer, done is better than perfect ;) 

I would suggest using an immutable class rather than a structure or, if you'd like something whose default value is rather than , use a structure which wraps a reference to an immutable class object (and say that it's undefined if the reference is null). Although this will entail some object-creation overhead when performing math on rational numbers, it will allow the code to avoid having to call after every operation. Suppose, for example, that one wants to add together the fractions (1/12)+(1/12)+(1/12)+(1/12) and output the result. Although it will be necessary to simplify the result before it can be displayed, simplifying the partial sums will be not only useless but counterproductive. Since all the denominators match, adding all the above numbers should require three additions and zero multiplications or divisions to yield 4/12. If the first sum is simplified to 1/6, it will have to be converted back to 2/12 before the next addition. If that's simplified 1/4, it will have to be converted back to 3/12 before the last addition. A lot of extra work. I would suggest using an externally-immutable class with fields for "originalNumerator", "originalDenominator", "reducedNumerator", and "reducedDenominator"; the latter two would be initially zero, but could be lazily computed from the first two when required. I do not recommend overwriting the original numerator and denominator, since immutable classes are generally expected to be thread-safe; if the object had held 3/12 before simplify was called, and another thread examined it at that moment, it might erroneously see 3/4 or 1/12 depending upon whether the numerator or denominator was updated first. Having separate fields for the reduced value would mean that if a thread which sees either field as zero (when originalNumerator and originalDenominator aren't) calls , then two threads which examine the same non-reduced value might call simutaneously and end up doing redundant work, but everything would still behave correctly. An advantage of using a class object over a structure is that if repeatedly performs operations on a non-reduced structure, the code performing each operation would likely receive a copy of the non-reduced structure, reduce it, act upon it, and then discard the reduced copy. By contrast, if each operation is performed on a class object, the first operation would perform the reduction and subsequent operations would then be able to use the reduced form. 

You need to add another css class to any of your paragraphs You need to change a css class to any of your paragraphs You need to convert a paragraph to anything else You need to change the text of a paragraph blah blah blah (there are a lot of other likely scenarios, but I think the first 4 are enough to illustrate my point) 

This is my first foray into the wild world of jQuery plugin development. The plugin "ajaxifies" forms, which isn't particularly spectacular: 

Doesn't really belong to the Controller as well. The easiest approach would be to have all your database specific functionality in functions in a separate file: 

Obviously, what's more important right now is to minimize that glorious readability mess, hopefully the (small) performance gain might be just the incentive you needed. Cache your jQuery objects You are using in and twice in . That's three times jQuery traverses the DOM to find , what you need to do is: 

The clause is very similar to the one discussed previously, only this time other than checking if has a index, the author also checks that the value is larger than zero. That's an unsafe check, because at this point we don't now what the type of the value in is, and if it's anything other than a number, there will be automatic type juggling involved, and the check is completely unreliable. From the name and context, I'm assuming the variable should hold an integer (if anything) that limits the search. If the variable doesn't hold anything, the limit is set to zero (), curiously using a string form of zero. I'd rewrite that check as: 

This way a function to get cabin information is available to all your controllers, you don't have to rewrite it every time you need it. Don't repeat yourself. If there's any HTML / CSS or any other presentation logic in your Controller, and of course any persistent data logic, you are doing it wrong (in MVC terms). But MVC for small sites may be an overkill. It's a correct approach conceptually, but you will have to decide for yourself if it's the right one for your application. But if you decide it is, you should follow it as is. A very easy approach to separate presentation from logic would be to use a template engine. There are quite a few of them out there, and there isn't one that's better than the others. Using one is more important than which one. And of course it wouldn't hurt if you didn't try to reinvent the wheel and started using an MVC framework. Or if that feels too much, a micro framework. There's is an often quoted article by Rasmus Lerdorf that some people perceive as advocating against template engines and frameworks. It's not, the only point of the article is that you don't have to use them. In the article there's a very nice and tidy approach on how to get an MVC kind of structure out of the box, without the added complexity of any third library. If you really don't want to use any third library, you should copy Rasmus' style.