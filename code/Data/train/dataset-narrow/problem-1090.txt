Do you understand that is already of type ? It is pointless and strange to compare against or . Converting a value to an integer produces 0 or 1. So you don’t even need that test in the first place! 

and then processing just runs whatever is in that function object. There are variations on what gets passed to the lambda when it is run vs. what is captured. But in general, a to the object of interest can be captured and the lambda is completely self contained, not needing any support from the class itself. I hope that makes sense to you and gives you some ideas. In one project, I replaced such command structs with a single template. The point there, IIRC, was to run the code on the proper thread. So, the lambda was the code you really wanted to do, queued it to the thread handling that object, using the same queue that was used for the polymorphic command objects before. Before, the class needed a function for the real thing to do, and a second function to respond to the matching command object, and the command object, and code to pack up params into it. Now, it just needs the function for the real thing to do. 

draws my attention: storing raw pointers? What are you doing with them. So looking closer at the code, 

Writing identifiers with a leading underscore is a bad idea, and is generally dissuaded as a style. Note that it is legal for member names if (and only if) the next character is not a capital letter or another underscore. 

The default constructor simply allows the default data initializers to apply, so it is not necessary (and can be worse) to write it explicitly. You can use if you need to mention it, but leaving it off completely is best. OTOH, you did not define a copy constructor etc. What happens when an instance is copied? The pointer members get shallow copied, which generally is not right. Raw pointers? what is the ownership/relationship/lifetime of these data members? A member? Don’t do that. There are safe ways to do type erasure in C++, or templates to customize the payload type, , etc. 

First, show your teacher the C++ Core Guidelines and various videos from conferences saying that you should not use naked or anymore. 

Don’t use naked (and ). Make your vector of instead. The srand48 is not a standard function. And the old C rand/srand are infamous for poor quality random numbers. See the header file. Why does one location use (funny way to write , a ) and the other use as an ? You don’t need to put at the top of the class; that is assumed. Does modify the object? You did not make it . Also, use the keyword in the derived version! That is very important in real code for maintainability as well as error checking. 

⧺ES.10: Declare one name (only) per declaration. Meanwhile, you can declare just where it is needed, not ahead of time. 

Don’t use “out” parameters. Return values (⧺F.20). I can see the appeal here of getting template argument deduction on the return value, but that does not make up for the lack of composibility. You can add a default type to the template parameter, which is handy for the case where the user doesn’t care. 

You will need to define in one CPP file; you should move the huge initialization stuff to there, too. 

This is called double dispatch because you are using virtual calls twice to resolve two different polymorphic aspects of the call. The first call to is a virtual call so it recovers the correct type of the message object naturally. Then the body of that function uses overloading to call the proper function of the set. But, to allow for different commands, that requires a virtual dispatch too. You also see that my sketch did not provide additional arguments to the call. If you had commands with different signatures, this gets repetitive. 

This is a race condition as the is not going to prevent the on the next line from failing. The state may change between these two lines. You should write the test on the result of the call to . 

Don’t write . Read through and bookmark the C++ Standard Guidelines. Numbers I note later are citations from this. 

I suppose you are doing this as an exercise for various reasons. But if you really just wanted a queue, just write: 

Your function does nothing more than call on every member. So don’t write it! will work just fine. The template is constrained to being move-constructable and move-assignable. That is, in C++17 is generated for you in terms of move construction and move assignment. So don’t write . Write the move ctor and move assignment operator as primitives and swap calls them; you wrote it the other way around. 

Yes, it is perfectly good. In fact, if something can be written using only the public interface, it should be written as a non-member. Yes, functions used only in one CPP file should be . In general, use an anonymous namespace for anything (including templates) used only in the one file. Header 

or something like that, modulo typos. Then, instead of having the indirection in the code where you want to find something, hide that in a smart find function. You are exposing the conditional mechanism to the caller and at the same time limiting it to just this pair of functions. That is, write two versions of your own as a non-member, and they forward to the member or the as determined. (Or if in C++17, one function with in the body.) Then you are doing what you hope the standard library vendor had already done for you: provide optimal special implementations for specific containers. Only it works for your own collections now, presuming the existence of a member means the right thing. 

Now how do you write ? You can include a virtual function in the class hierarchy that does this. This is a classic approach, but it has the drawback that the has to inherit from an interface class and all the individual functions have to be virtual. 

The four nested loops seem awkward and a lot of text for what it does. But, hiding that would not be easy without sacrificing precious speed. To make it faster: First, sort the vector of available terms. This way, once your sum exceeds you can quit and not try the rest of the terms at that level of the loop! Instead of looking up all four terms and summing them in the very center of the inner loop, keep track of partial progress. 

Multiplying each digit by a different power has the same number of multiplications as multiplying each partial sum by 10. But if you look at the generated code, as I found in this post (see function ) that multiplying by 10 was done with two simple instructions: multiply by 5 is adding via the addressing generator port by using scaled indexing and the index and offset being the same register; then multiplying by 2 is folded into the += with a similar trick. Multiplying by the various other values will probably not use such tricks, but will need the regular instruction or a longer sequence of adds. Another thing I found (in that article) is that using 16-bit ints is slowest! The x86 is especially slow for some operations in 16 bits. Using 32 or 64 (in a x64 build) is the fastest. So, I suggest simply changing your data type and running the timing again, to see what happens. I’ve also found (see this post) that some operations have different speed for signed and unsigned of the same length. Meanwhile, I see presentations that show examples of how unsigned generates worse code with less room for optimization. So, explore different types and chart the results. 

Your constructor taking will have issues with negative numbers. Also, it iterates the mask shifting over the , and that may be larger than 32! Besides being extra work, the shifting off the end of the word will not give you a meaningful test. 

Don’t explicitly test against . Use the the truth value of the pointer’s value, which might (in the case of smart pointers) be an efficient in the class. 

So just what is it you’re trying to achieve? I did not understand the paragraph at the beginning of your post. Let’s decode the code: For each block in A, For every block in B that is different from the current block in A, copy it to . For each block in B that matches the current block in A, output “both vectors are not equal”. That doesn’t make sense to me. You will print this if the vectors are in fact equal, but more generally will print many times, each time a portion of the vectors are equal. The is incremented in both branches, rather than in common code as part of the loop. The will contain multiple copies of blocks of B, each time it does not match one of the blocks in A. What is the point of that? 

Don’t use the macro. Forget it ever existed! In this case, your initializer is . The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. 

Why the ? Don’t do that. Don’t put extra parens around the return expression. This has always been a point of note, but now with return type deduction etc. it matters rather than being a matter of "style". 

Be sure you use the real name of the struct, not the all-caps typedef, when you derive from it. I assume is a C function, so I kept it as-is. In C++, you do not use the macro. Given that the work is done automatically, you can then (just) report an error as part of your set-up. 

At its simplest, it’s just a number assigned per-object. But I’ve also made systems where this was an RAII object and destroying the ticket would revoke the callback. 

Prefer prefix over postfix — it doesn’t matter for when you don’t use the value of the expression, but more generally you will do this with iterators and “smart” objects of some kind, so don’t do things differently with just because it doesn’t matter for this one. 

Frank has addressed the larger design issues as to whether you should in fact have a . You might get what you want from or some code based on that implementation. But I want to address the question 

Your input argument will be able to take of any character type, but only using the default . You might do that on purpose, if Traits are never used other than the defaults? A will take a , , or C-style lexical string. 

You know already returns a . You do not need to check that against again. In fact, it’s rather silly. 

Why are you making everything ? I don’t see any derived classes. How is different from ? I assume something is rather different for you to not be using standard types! Likewise, , etc. Especially since you are casting to (using C-style casts) rather than having a suitable overload. 

Just adds noise — is that a thing someone actually recommends? I would say don’t list all the things that are taken care of on their own. 

(BTW, good for using and for using uniform initialization syntax for some things.) The is a sink parameter, so you can take by value (which you are) but also use . 

Don’t use naked /. You have a pointer and a sz; why not just use a ? Or in general, use (which works with arrays now) rather than a raw pointer. 

Don’t make explicit comparisons against . Use the contextual conversion to bool as a truth value. This will be more important with smart pointers! And should be a smart pointer, as noted earlier. 

Again, why is it a when it does not need special access to the internals? Why are you XORing every array element, instead of just letting on the bytearray do its thing? In a real library of custom number type, I would expect to work between versions of different SIZE. Likewise, a generalized version of the copy constructor that can convert numbers of a different SIZE. 

The main problem with your code is repetition. The idea of using a variable for each rotor and hooking them up in order by assigning to them is a sound idea (though they should be instances rather than functions). I call this out because it is a place where you did think abstractly, using variables to refer to different things at different times; the rest of your code is characterized by repetition rather than applying different data to a common piece of code. Repetition: I see 

Continuing, I see the same issues. loops, writing by hand instead of knowing the library, etc. You don’t need a bare return at the end of a function. Various print-out functions that don’t change the object should be . 

Good! I see you used an anonomous namespace for the helpers in the CPP file. Using for reading the text: most people just use a string. 

Using the same syntax to serialize or deserialize the common header, as you have it in your code, is intuitive and easy to understand. The key is to make it one thing, as you have already done by having a single base member. If there were more data members there, you would group them in a struct or have a base class function to call with straightforward syntax. 

The style in C++ is to put the or with the type, not the identifier. This is called out specifically near the beginning of Stroustrup’s first book, and is an intentional difference from C style. And, don’t define more than one symbol at a time. But really, as noted above, it should be 

you are missing . Member functions that are accessors should always be declared . This HexDouble class seems like a lot of work over just using the union in your code. Since it’s a local class used in one place, just use the union. But, technically this is undefined behavior. There is a long history of using unions and casts in just this way, and real compilers go to some trouble to recognize this and not optimize it away to nonsense. But really, the compiler is allowed to see that you’re reading from a variant of the union that was never set, and assume that this path in the code is never taken. 

Huh? That is a (non-static) member, so why is it taking two additional parameters? Skipping down to look at the implementation: you wrote it as a non-member. So it should be a free (template) function swap. As for how/whether it should be implemented, I’ll get back to that. 

Again, very good for thinking about narrowing issues. It is said that “ is the new ”. So use it for here. BTW, just what will the promotion rules do if is the same size as (e.g. 4 bytes)? You should get a compiler warning here, so I suspect this is a lesson for you: as mentioned earlier, pay attention and eliminate warnings at level 3 (on MSVC). 

This may be beyond the scope of the review, but I wonder how the T=void case is different from , and the constrained case different from a normal base-class pointer. How is “related in a way that can be resolved by the reflection system” different from ?