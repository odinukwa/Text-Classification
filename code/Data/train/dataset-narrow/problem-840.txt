Now, you don't have any mean to know whether is a simple or a "smart" one though. The name was confusing, and since there is already such a trait in the standard, your class should reflect its behaviour. Now, we want another mean to differenciate simple enums from smart ones. I propose to add another constant in , along the lines of . This constant would tell whether is specialized for a given type, and the name is less ambiguous than the previous one. 

While this algorithm is actually generally slower than the previous one because of branching, it permits to realize some interesting things: one of the branches always sets to and cannot be executed when . The other branch does not update which means that the loop can be uderstood as "do stuff while ", so we can rewrite the original second loop (not the new transformed second loop) as follows: 

And yet another small error: if you want damages to remain from one turn to another, should return a and not a . Otherwise, you are merely trying to kill a temporary monster; in other words, a monster that heals between turns. You probably just introduced this error with your last edit. 

Of course, since this is not a macro solution, you will have to add another parameter if you want to inject the information into the handler: 

More than an in-depth review of your algorithms, this answer was more about good pratices when writing algorithms. Basically, here is what you should keep in mind: 

I have a few tidbits that could help. Nothing big, but things that you can improve as you code without having to overthink them: 

To access the functions contained in the global struct, I use the following macros (some also provide extra features): 

Use strongly typed s For your function, the return type is at best misleading since the values only represent abstract concepts. You should drop the and replace it by a dedicated type , implemented as a strongly typed or : 

Anybody who knows how Python dictionaries work will know what this lign is doing, the code is explicit by itself. Instead of always repeating what your is doing, you should just explain once what it does when you declare it; the code will tell the rest. You should only explain once at the beginning how your algorithm work and let your code tell the rest. Honestly, you could remove almost all of your comments. Python is designed to be readable and it is. Second point, avoid to name a variable : it is already the name of a built-in type. It's bad pratice and can be confusing for people who will try to read your code. Also, you open your file once, but never close it. You should close it once you have filled your . You could use the construct to have your file closed automatically at the end of the block, therefore, you won't even have to remember to close it. Also, , like is also the name of a built-in type in Python, find another name :) 

In Python, try to use indices-based loops (with ) only if you have to, only if you do need the index. Otherwise, try to always use element-based loops. 

Don't use While easy to use, is not the best tool to generate random numbers. For a simple game like this, it may not matter that much, but the C++11 header provides better alternatives to generate pseudo-random numbers. That's not critical for your application, but you should have a look at it. Use the free functions and Once again it won't change anything for you, but since C++11, it is good practice to use the free functions and instead of the container's methods. The reason if that they will also work with C-style arrays and . This is a good habit to take, because it ensures that your code will still work if you change the container. Of course, the real advantage of these functions is that they make template code more generic. 

In order for it to work, you would have to declare to be an instance of (fixed size types are not provided for atomics). 

Since you often pass as the template parameter, that means that in your class, (and it seems that the problem is propagated in the children types). I think that this is never the case in the standard library and I would totally expect and to be equivalent. You don't seem to be using directly, so I will assume that this is an error that you didn't spot. From the other s, I also assume that you are interested in exposing to the user of your class and that you don't want it to know that much how your class resembles a mapping type. Therefore, you should change to: 

From a style point of view, your code could use more braces to avoid a potential Apple bug and to let it breathe a bit more. Also, when you have to comment almost every line, it's almost always better to put the full explanation along the algorithm and not into it. You also seemed to be concerned about the performance of your algorithm. I tested it with several patterns and compared it to several stable sorting algorithms that I had in a library. It always sorts an with \$10^6\$ elements. Here are the results (Stable sort is , yours is the natural mergesort, the other algorithms are not in the standard library): 

Computationally speaking, I don't have anything to add what has already been said. @amon did a really comprehensive review of your code. However, there are some serious sociological and/or ethical flaws in your code. I would say that, genderly speaking, it could be made more generic: 

Avoid raw pointers. Instead, use a which will manage the memory alone. It's by far safer. Since the modified portion of the code is quite huge for this modification, I won't include it in this section. However, you can find the modified code at the end of my post :) Constructor inheritance Do not bother creating specialized constructors to forward your results to from its derived classes. You can use constructor inheritance: