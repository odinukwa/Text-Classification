Sure, but then you'd need the equipment for it, since the pi does not have an internal splitter (and most likely your router does not provide PoE). It would be cheaper to just buy an extension cord. 

Since pis are inexpensive and I buy them to use them, if that use included a desire to do intensive calculations all night I'd say whatever temperature it plateaus at. There's a related question about overclocking, since that will increase the temperature, and the question becomes largely subjective. Personally, if it plateaued over 70C I would reduce the overclocking. This is mostly because laptops I've owned that ended up with overheating problems (because I let too much dust pack in) would get that hot repeatedly without damage, and my current laptop core temp seems to have the same idle temperature as a pi (45C). I think people who do a lot of desktop gaming will run systems with a lower idle temp (30-35C) at 70-80C for hours at a time. This is something you might want to explore by searching overclocker and gamer forums. 

Your application should not be hogging an entire core; notice the amalgamated figures (the average of four cores) are 20-25% and the listing in top is 99% (top can show individual threads, so this is the usage of one core). While if nothing much else is going on this may work out okay (the task will hopefully rotate from core to core), it is unnecessary, particularly since you are probably begging for it not to work out okay at some point. This is not a very robust methodology. The problem is here: 

To emulate foreign hardware so you can test/develop/run software built for that hardware. To emulate native hardware in a bare metal state so you can run software which requires bare metal to operate (such as an operating system). As a sandbox for security purposes. 

Within a short period of time, init will nix it. And you can't usefully put anything after that, because is the end. The can be a little confusing because the same character is used in redirection, as you are doing. You're also using to background, but you've made a mistake by putting them in the wrong order. 

VirtualBox is operating system level (aka. paravirtualization) software designed exclusively for x86(-64) systems and as such cannot run on any model of Raspberry Pi. Since Pi operating systems all target ARM, VirtualBox cannot be used to run Raspbian directly. I think you are aware of this. WRT setting up a 3G connection the fundamentals are the same since this is kernel driven. How you configure and interface with this depends upon the software you use, but it should be possible to do in a more-or-less identical way. 

Takes one or two arguments. The first is the 2 digit hexadecimal address you are looking for, and the second is the i2c-dev bus number (defaults to 1). Remember, running has some warnings attached to it. I'm actually not sure how seriously they apply on the pi though. 

X doesn't have a theme because it's not responsible for how anything looks. Well -- that's not quite true; cosmetic preferences can be set for very old school X apps using a configuration file, but themes are not a concept there. Global themes are commonly implemented independently by: 

Your problem is you do not have enough (or perhaps, any) experience in network programming. The fundamental entity of network programming is the socket. If you have done much of anything at all with the ESP, you probably have used these already. A fundamental concept of network programming is the client - server relationship. A server is an application that waits on an internet port1 and answers requests from clients, a client being an application that connects to a server and initiates two-way communication. An obvious example of this is web browers and web servers. The central point is that servers do not connect to clients, clients connect to them. It is possible for one application to act as both a client and a server. For example, a web server may connect as a client to a database server to retrieve information, but in that context the program is acting as a client, likely in parallel to its role as a server to web clients. If all this is new to you, you could do some tutorials and experiments with the ESP, although working with a regular OS based computer (such as a Raspberry Pi) is probably easier. You have to decide whether you want the ESP to act as a server or a client. If the latter, then it will connect to a server on the pi. If the former, a client on the pi will have to connect to it. It probably makes the most sense for the ESP to be the server (unless you want to use SSL/TLS for privacy, since I believe there are some issues with running a TLS server on the ESP). You also need to decide whether to use UDP or TCP; if you do not know the difference, read up on that. Note that UDP obscures the server/client distinction a bit since for every message back and forth the parties switch roles (i.e., a UDP message is always from a client to a server, whereas with TCP once the connection is established, each party maintains the role it had to start with but either one may send or receive a message, hence TCP is considered persistent). The last major piece would be deciding on a protocol to use. In this case, if the ESP passes text messages straight on from the Arduino, you could use a terminator based protocol, that is, one in which a single message is terminated by a special character or sequence of characters. or are commonly used with text. 

1. You can kill X from the inside with , but if you are using a display manager, you'll go back to the GUI login. That's okay. 

No. Most likely the pi is still running, but has gone offline. As Steve points out, this may be because of insufficient power for the wifi adapter. Problems like this will not necessarily show up in an either/or manner. 

is essentially a diagnostic/debugging/reverse engineering tool. If you were using an equivalent "usbdump" program, you could use that to get information about a USB mouse that is attached. However, you could not use it to actually make the mouse work as a mouse, at least not without piping it through something else. 

I'm presuming you are just trying to do this as fast as possible, and you aren't using any kind of (passive) delay. If so, don't do this with a granularity finer than 10 ms because you will not get predictable results otherwise. The issue is that during the sleep the scheduler may run something else, and a normal kernel can't prevent that from taking <= 10 ms (as in, it may be less, but it won't be more).1 If you are not using a delay, try combining your writes together. Userspace <-> kernel space context switches are expensive. 1 That's a number I've seen repeated but can't find any current references to. If you do some tests with timing timers (e.g., by using to check how much time has actually passed), you'll probably notice pauses with a granularity of 10 ms are accurate to the millsecond, but finer ones aren't. I.e., a sleep of 10 ms will be 10 ms, but a sleep of 5 ms may be 7 or 9, etc. Busy looping (e.g., by just polling ) might improve upon that, but it means your program will max the processor, which makes it kind of infeasible for most things. 

Then reboot. Without this, these models will have the power to the USB port limited and it is not enough for most external drives. 

There's already a go compiler in, e.g., raspbian, which you can find with . This looks to be version 1.0.2. The site you linked has pre-compiled tarballs of 1.3.3 available for the pi. You just need to download the appropriate one -- it is clearly indicated. Put the tarball in and: 

Yes it is. Look at the first line of your output. That "free space" isn't part of any partition. This is the same as if you had formatted a 16 GB card with one 8 GB partition. 

The most straightforward way would be to use the pi's own firewall (on raspbian, ) to block traffic to or from any address that is not part of the LAN. Iptables rules are assessed in order, so if you set these two first: 

Boost::interprocess is a C++ IPC library. It is "header only", so you will not find a for it; it would be built into something statically (template heavy C++ libs suffer this limitation). That's really unlikely to be the shell (presuming the shell is ) or the loader, since those are written in plain C. They do link to some esoteric base libraries on the pi (raspbian seems to have some specific pieces unique to it), however, since those don't link to the C++ library either, it is again very very unlikely to be anything in that chain since the whole thing would then need to have been compiled in. Since "boost::interprocess" is an IPC library, it could easily be that the pid in the error is not the culprit. If not, then it's almost certainly something that does link to libstdc++, which on raspbian is located in ; is a symlink but will follow that, so: 

Enabling a service with systemd is really about creating symlinks, as it is for SysV, so it is easy to disable something with the system offline by modifying the filesystem. In this case we have to take care of both set of symlinks. That means deleting: 

The first bit are the permissions, indicating the owner/user () and any one in the owning group () have read-write access to the node. Anyone else ( = other) have no permission to do anything. The owning user is and the owning group is . If apache executes your program as the apache user, it will have apache's profile: 

You should see a negotiation ending with you getting an IP address. If so and you still cannot connect, add to : 

Using a browser, there probably is no GPU hardware acceleration regardless of distro. So, with regard to youtube, you might want to try youtube-dl to download them and then use -- which was written for the pi's GPU -- to watch them. It's pre-installed in Raspbian but may not be available in Snappy Core Ubuntu. Omxplayer uses the framebuffer outside of the GUI desktop; I'm not sure if it can be run from the GUI, but you should be able to find a free console via Ctrl-Alt-F1-6 (just try the F-keys in order, when you get to a console log in). Then: 

I have a short script which is executed by a system daemon for particular events. I know the event is occurring and the script is executing, but it does not do what I intend. Strangely, it does when I run it manually, so I am very confused. How can I figure out what is going on? The script is basically a series of commands like this: 

The I2C bus is master only. You cannot connect it as a slave, hence it does not have an address to find. The relationship between a master and a slave device is that the master may read from or write to the slave but not vice versa (which is why an address for the master is not meaningful). 

These are not necessarily up to date though and "fully work" is ambiguous. Try and see if anything shows up. If not, try . 

So, should do what you want [see comments]. The man page is a little brief and mysterious, perhaps because tasksel is mostly intended for debian maintainers. If this works let us know ;) 

This is an educated guess, and not based on any analysis of schematics, but: A hardware reset is equivalent to flipping the power on and off; it is intended to force components to restart as if just turned on. So holding the board in that state might easily mean there is no power to major components such as the SoC itself. By contrast a halted state (note "halted" and "powered off" are actually the same thing on the Pi) simply means the system is no longer active and may have powered off some peripherals (I don't know about that either) -- but some part of the SoC is still on, doing nothing. 

SD card reads on the pi max out at 20 MB/s; most cards will supply close to this regardless of class. Write speed is generally much less significant. You should be able to get faster reads (and writes) from an external drive. However, that probably won't speed performance unless your RAM is always maxed out, since the system uses free RAM as a file cache for frequently accessed things. If your system does have its RAM maxed out all the time, you will notice a performance gain if you can free 50-100 MB up regardless of whether or not you use an external drive. If you cannot free this up, using an external drive still won't make much difference on a media center; storage I/O is inevitably a bottleneck sometimes, but not often enough to make it significant if the major activity is streaming media (which occurs at much less than 20 MB/s anyway). On a database or file server, where large amounts of data are being frequently accessed as fast as possible this would be meaningful. 

As Milliways points out, on normal DHCP equipped networks there's no need to do this. However, if you still want to, your nameservers are listed in . Beware that when you do connect as a DHCP client, this will get overwritten, so if you want to have several versions, name them something else and copy them in when you want to use them. The effect is immediate, there is no need to reboot or restart anything. 

ARM's own site refers to SIMD functionality for armv6, which is the instruction set for the pi's processor. It also claims if the platform doesn't support something, you should get a compiler error if you try. I don't use asm, but this makes sense. So there should not be any ambiguity. If you confirm this one way or another for yourself, please come back and provide a better answer to your question! 

Sorry, Stijnb, but there is ABSOLUTELY AND COMPLETELY no possibility of a raspbian system working at all -- not even a little bit, not anything, no login, no init, nothing -- without the folder. It is exactly as feasible as someone saying, "I was driving my car and someone said to look for the wheels, but I looked and there are no wheels!" If you got in the car and managed to drive it, IT HAS WHEELS. Period. End of story. So you are somehow mistaken. Add the output of to your post if possible. I doubt very much any of the tutorial information you have read has instructed you to replace , either. That would be (again, pure and simple) malicious, since the most basic and essential components of the system, beyond the kernel, are in . There is no possible reason for replacing the whole directory. Most likely you were to add a directory for your new kernel to , or replace an existing one. If it is the latter, move the old folder to somewhere you can get it back from again (e.g., just rename it). The subdirectories contain kernel modules such as hardware drivers. Whatever you've done, if you've removed stuff willy-nilly from and now have serious problems, you're screwed (unless of course you have a previous backup) -- you might as well just start from scratch with a fresh image on the card. 

Another issue in play here are spaces in filenames. They're fine, but you have to take them into account. 

I believe those are the default names used by depending on the value of the option. In short, you can either add explicitly, or make sure the key paths are as indicated above. There is a further caveat: It may not work unless the keys are set mode 600 (i.e., read-write by owner, no access to anyone else). This is how they are when created, but you may want to double check with . Note that there are other methods to accomplish the goal here besides what you are doing -- although I admit to doing something vaguely similar: I have little UDP services that run and respond to broadcast requests with an arbitrary hostname; the corresponding clients add the hostname and IP to their local file. That's a sort of simplified version of zeroconf, but it's a bit silly in that there's already a proper zeroconf implementation that runs by default on Raspbian, . You can find documentation around for it, and it is possible to use an arbitrary hostname (as in, one that is different from the one in or comes from the command) with that too, and all common operating systems including those on smartphones have simple clients that will pick it up (although with, e.g. Android, this means literally a port scanner as described below, but those will probably deploy zeroconf as well and list the hostname sent back). Simply add: 

This will create that file with that content. This will be detected at boot and force a run of on the root filesystem. It's then erased, which is why it must be replaced via . If the filesystem is fine, that will add about 10-20 seconds to your boot time, depending on the size of the filesystem.