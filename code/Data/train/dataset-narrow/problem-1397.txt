You don't have any performance metrics, so there is no telling whether this will have a significant effect, but one of the things you could do is combine your queries. Take this one: 

Somewhere else you use . Here your comment says "if non-indented line". Why are you not using your own utility function? 

Your algorithm seems fine. It doesn't reveal any special tricks to me, but I also don't see any unnecessary steps. I think I'd have written it myself that way. The only part that I might have done differently is the regex; I'm not sure that one is fully correct. So on an algorithmic level you're doing perfectly fine. However, the implementation suffers from spelling issues. Comments First, you have some comments. 

That said, usually one registers a listener. So you'd have a somewhere, and then in this method you'd call a method , which iterates over the list and calls for each of them. This is called the Observer pattern (you can google that if you want to know more), and it decouples the reporting class from the observing class. I also think you should move the parsing of and , and to their own methods. That would greatly simplify this method. 

Pretty close to the perfect implementation. However... Consider the Transitive relation of the multiplication operation: 5 times 2 is 10. 2 times 5 is 10. It doesn't matter in which order you multiply things. So when you multiply, say, 3 by 2, you're just multiplying 2 by 3 again. And the same goes for 5 by 2, 7 by 2, 11 by 2... but also 5 by 3, 7 by 3, 7 by 5, etc. What you'd do in this case is start off at the value of . This solves the issue where you're multiplying 2 with 3 and 3 with 2, thus checking the same thing twice. There's another issue: Now that we're effectively checking in the inner loop on the first iteration, it doesn't make sense for the outer loop to check for on . Instead, you'd want to check for there as well. 

But maybe you want to include some text like "You equip the x" or "you keep wearing your y". It's useful to give feedback to players like that, I think. 

You have on your of the Calculator, but you don't actually read from it until the thread has finished. You could remove it, that way the synchronization on the variable would be removed. 

Lastly, I don't know what you're doing with that user-agent string, but I don't think you're 4 browsers at once and it probably needs a comment. 

This could have been in your getter - there is no real need to store this in memory. What does it mean if you have a of "A1234" with the letter "A" and the number 2345? It'd be inconsistent. Your design doesn't allow this inconsistency to occur (through the use of a single constructor and ), so it's a minor point, but I don't see the need to have this variable. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

What's the purpose of here, if you're just going to nearly-directly write to anyway? Why not do it like this? 

This seems like the best option. But it's hard to do. In a functional programming language, this would be the best option. You could return a delayed function call and execute the whole timestep IN SYNC. It's the best option because it simulates real life. Nay, it's the best option because it simulates the reality you wish to achieve. ... but we're not using a functional programming language, so new values are a better option. Because I opt for both a mesh network and new values, I decide to make a 2D array so I can set the Cell values properly. I also need the array to iterate over the Cells, since all options require iteration. If you read back up, you'll see that I define the array last. That's because I'm the least sure of this part. Now that I think about it, I don't think needs a at all. I only added it because your had a . The final result? 

This comment doesn't say what the function does. It's also contradictory to the function name - "game start up" and "start player turn"... When I start up a game, I grab a deck, maybe shuffle it and give people cards. Your IDE generates things like and . These are for documenting your arguments or "parameters" and your return value. So a comment like this... 

Another reason for this is that if you were to get a question like, "how do we add mountains, where the dragon can wander, but the player can't?", you'd be stumped. Or at least I would be, if I had to add mountains into your display code. It's all about clever tricks with multiplying strings. You'd have to alter ALL your cases. Or if there were two dragons, because, you know, hard mode. Again, it would take you a major overhaul. I'd just make a simple change: 

But what you've made is a quick app. You've got the right level of time spent to code quality out, in my opinion. ... Well, I don't know how long you spent on this, but basically, this is clean enough. Add more features and then clean as necessary whenever duplicated code pops up. 

You're a bit inconsistent with how you handle large argument lists. The large argument lists also make your code unreadable (or at least hard to read). I have trouble discerning the parts where your code does actual work and the parts where checks and logging happens. 

This line is hard to understand without the context of the problem statement. I'd recommend you pick a better name for - might be a good indication. Similarly, you say that you spotted that you can solve this problem with a pair sum. I think you should put that in the method name - contrast with . Another thing that bothers me, but now we're getting in pretty subjective territory, is the inconsistency in the placing of the array type. 

Okay, and now a more serious answer: A LinkedList, no matter if it's doubly linked or not, always is gonna require two things for : The object to insert, and some means of specifying where it goes. There's no way to circumvent this. Best you can do is take a Node (or , in your case) and give it an method. 

I think that could be part of the enumeration. Right now, the Pizza acts as a size-to-inches converter, which is kinda like ordering a personal sized pizza and then only once you receive it, finding out it's kinda tiny. You don't want a tiny pizza. If you make part of the Size enumeration, you could display the inches and words in a menu: 

This seems like a place where you would have to add new functionality all the time. Is there any way you could implement a strategy pattern here? 

I had tagged your question reinventing-the-wheel, because you're recreating a , and Java already has one. @200_success has removed this tag for some reason, allowing me to post this answer: Use Java's built-in LinkedList. There's no reason for you to be writing your own implementation. Using Java's own (full classified name: ), you can use to remove a node. If you only have a reference to an object that is contained in the list, you can use . As it stands right now, you expose your nodes to the user of your class. You make THEM manage the LinkedList, whereas the LinkedList itself is nothing but a wrapper. If the user messes up and accidentally points the last node to another node, then makes a clone and compares them with or , the program will get into an infinite loop. If someone inserts a LinkedList which has the last node point to another node into something like a , the program will get into an infinite loop. Searching for an element in the list requires the user to built their own implementation of a search function. In fact, doing anything with the list (other than removing an element) requires the user to get their hands dirty. But lets say I wanted to use this LinkedList for a valid purpose. I can't even remove the last node from the LinkedList. That could significantly limit my options. Actually, removing itself is rather dirty because you've called it . This gives me certain assumptions - namely, that the object won't exist anymore after I have called the function. I call and surprise surprise... the node still exists! Except it has different values now. This means you're altering the objects I'm holding in my hands. You're even altering the objects you're holding in your own hands - in the and fields. There's another bug related to that: When I make a list of 2 Nodes, and I remove the first one, you end up having a LinkedList that contains 1 node... double! And if I were to add another node with a different item in it, wouldn't even point to the proper node! When you combine all these reasons, you should see that it is a bad idea to reinvent the wheel. Just use Java's and the methods they provide. That way you don't have as much bugs, you don't force the user to make their hands dirty, you don't have to test whether your list works, and you give your user more freedom in how they can use the list. 

Binary search is blazingly fast. 10000 elements can be searched through in 13-14 array accesses. 100000 elements - 17 array accesses. Consider stopping binary search when your scope size is less than 128 (your code should go blazingly fast at that point anyway). Your code 

You could out of the for loop here. No need to go over the rest of the providers once you've found a match. 

What you ought to do is make a copy constructor, then have the "clone" method return a or . That way both internal state is preserved, but simulations are possible. 

I just added new lines, see? The purpose of these new lines is to show that there are different parts to your code, so that if you come back to it later, it will read better. When you don't have time, goal is to both get the product out; but also make sure you can still clean it up later. Keep it salvageable. 

Some of these might be subclasses and thus require removing. But there's no need to have the same line of code 6 times. 

I don't think I can provide any meaningful commentary regarding the purpose and usage of this class. It seems to hide several VERY BIG assumptions, and it's very likely that you'll get bitten by them somewhere down the road. If I inherited this as-is, and there were no other pressing needs, I'd try to rewrite the whole thing from scratch in a simpler way, even sacrificing performance. I would personally prefer slower code over code that I couldn't understand. A final comment: 

Now, I don't know if has any sideeffects like clearing input buffers, but if all you're gonna do is set , then clearly we don't need to enter this loop if is already false. And setting it to true only it set it to false some time later in the same section of code is a waste of cycles. So do it like this: 

This is still silly, of course, there is no need to keep track of internal state of , it is trivially derivable: 

Next, transform comments into code if they're explaining what the code does. Specifically, this bit: 

I didn't look at the specific performance issue you described. However, my general review: Readability 

There's 4 parameters here that can give you a . And all of them look the same. The only difference given will be the line number. You could save programmers a lot of effort by including a description of what is null. There's many ways to dress it up, and I don't know which one is best, but here's what you ought to do at minimum: 

can take a as argument. Doing so would allow you to remove your call, shortening the code, making it more readable (and potentially speeding things up slightly as you need 1 function call less, but that's negligible). 

Extract to , and use a while loop to make sure that the move counter () doesn't go up if you make a bad move. Encapsulate conditionals by putting checks like into either a function (naming is hard) or just a temporary variable of some sorts. 

Seems like this could get wrapped into a method called . I'm worried about a single pipe though - Isn't it ? 

If we just had to add a set for this key, make a new cached empty set... and add the key to the priority queue. Pretty clear. 

needs a more descriptive name. Specifically as a class member variable, it deserves the few extra characters it would take to be called . Additionally, you have extended , but do not use any of 's functions. Does Point even provide functions? (Yes, it does.) I'd have gone with a class that contains a , not it. You pointed this out yourself in a comment as well. 

Don't declare variables if you don't need them. Move the declarations of and below that if statement. Try to keep all your variable declarations close to where you need them. 

It seems this was already pointed out to you, but still, I would say that this is a positive change - it's a simplification and the old situation doesn't make more sense from a semantic view point. It really is "and now, the next item needs to go in the other list" rather than "if we added the item to the left list, it now needs to go in the right list, and if we added the item to the right list, it now needs to go in the left list". 

Hmmh.... and ... they're both derived from the same variables... What if... we set new values for left and right at the END of the for-loop? 

As far as I know, there's nothing substantial to improve. It's clear, and the program is of trivial size. So any ideas about future extensibility are irrelevant. Nitpicks: 100 is a magic number explained only by a comment, use or whatever the case convention for fortran is. The write function looks weird (Disclaimer: I am not a fortran programmer), maybe wrap it in a helper function (do you even have those in fortran?) so your code reads cleaner. 

This is hard to read. On one occasion you've opted for no braces, same line, on another occasion you opted for no braces, multi-line, and later again you go for braces, multi-line. Be consistent with the placement of your braces. It makes it easier to read the code. 

This line, , when do you think it's being executed? I dunno, let's apply OTBS (from the same wikipedia page)! 

You've got a flag variable in there. But from what I see, you don't need it. I've labeled all the usages with . The only line that sets to true is inside the if statement . is triggered by or some other condition earlier. is set to at the top of your do-while loop. So every iteration, it's set to false. Because of this, the flag variable cannot be changed from false until the stepback if-statement. So we can do this: 

I wish I could do something about it, but as you'll see, I get stuck. The original check, I get it. Something like "if ticket reassigned". But after that, you're pretty much interested in only one task: get a person object, change note status, maybe give it a message depending on situation... So maybe we can do something about that... First, extract case into boolean. 

A minor bug: You get an for an empty list in . You don't have a comment stating you need to input a list containing at least something. Consider returning and adding a comment. 

I'm calling it Magic Numbers because without the image, I'd be left wondering which index is which. They're magic in that if they change, the code stops working. But why it has to be those numbers exactly is unknown... to the reader, at least. Difference so far 

Either strictfp cascades, and you calculate the variance twice, but in different ways for , or it doesn't, and in that case, no math is being done in this method and the keyword can go. 

Right now? No. But that's more because programming skill is not really the thing an employer is looking for when it comes to entry level developers. Entry level developers are supposed to be able to learn how to program and quickly at that. I guess that from a knowledge perspective, there's.... some issues with the design here.