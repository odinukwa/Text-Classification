This looks like the kind of code that would be in a function to print out multiple strings in array. However, since you only have one message that is in an array, this seems kind of overkill, especially since there are only three lines. It would be a lot easier just to print out the message as it is: 

Now, all you have to do when you add a new form element is create a new object and add it to the array. If you encounter any bugs with this code, notify me. 

Now, let's simplify the conditions. All the ones with arrows next to them can be removed either entirely or partially because, if the conditionals are checked in this order top-to-bottom, then they are redundant and unnecessary. 

And, to take it step further and get rid of an extra function call, put this message inside the call: 

Remove all the extra comments in your code (the ones with old code in them). They are just cluttering up your code. 

Well, that doesn't make much sense; if there's an error, the code needs to return a non-zero number to indicate failure. Other than that, the environment in which this program was run will not be able to tell that there was an error. 

No. That is very bad JavaScript practice. The better way to do it would be to write it like a normal for loop: 

This will help us later because, rather than hard coding these into the code like you did, while we are looping we can just grab these values from the array. Now, let's create the loop. 

Public versus private fields In Java, it is a custom to make all your fields private, unless they must be explicitly accessed by other sources. I believe this custom also applies to JavaScript. Instead of having the be a public () field, why don't you make it a private () field? There doesn't really seem to be another place you use it. And, if there is another place that on using it in, why don't you create a ter? This would be a function that returns the field, and it might be named something like . This is up to you. Defining the functions with You did exactly this, and that is perfect. Keep that up, it is a great practice. versus This is a matter of efficiency versus readability - whatever you chose to have. It would be more efficient to use in place of in the field, as the function doesn't have to do checks on the argument provided(whether or not the argument is a class, an id, a tag name, or a mixture); it knows it's looking for a one class and one class only. It is slightly more readable having , as the syntax for it's arguments is the same syntax for CSS; it's a "universal" syntax. Indentation With only 2 spaces for an indent, your code looks fairly cramped. I recommend using tabs or 4 spaces as an indent. 

There's some really strange and bad practices going on here, especially with the field. Here, you are relying on the fact that the string passed in will correspond with some variable on the global scope that is hopefully of the type . That's not the right way to do things. Instead, objects should be instantiated with the actual pokemon object itself: 

You are using the registers incorrectly. According to this page, the registers , , and are for the table of contents pointer, the return of a function/subroutine, and (commonly) a function/subroutine argument, respectively. I think you should be using the register through because, since you are not using a subroutine, these registers can now be used for general purpose. You might be okay with using , but you definitely should not be using . 

Where is the ? Without this, you are making this function "global" and that is bad practice. If you want to intentionally make this global, do: 

You don't need a at the end of the function event listener (); where is that false going to get returned to? 

Consistent return values You've done a good job doing type checking so your functions don't receive invalid inputs. But, sometimes your return values don't make sense (I only found one case). Here: your returns if isn't a valid number, but an entirely different type - an array - if it is valid. It's best to be consistent with your return types. Here, it might be best to throw an error. I'm not 100% sure about this. 

Like above, you'll have to call this function twice for each boolean. As shown above, the only changes really made were to the first argument of the two calls to 

Note: I chose to name the identifiers using for the object name and for the property names because most enumerated types are named like this. Now, you can easily access a type like this: 

You have a lot of code here, and you are repeating yourself in a lot of places just like you did in the example above. I recommend you take this idea that I showed you above and apply it to rest of your code. 

To answer your question about exceptions, I think that you should only use if you know that there will be errors. It is always good to catch and stop an error, but there is no point in trying if there will be no error. Also, knowing that there will be errors helps because then you can catch the right kind of error, rather than just catching . You did a good job catching the error here and differing between using and : 

There is no point in storing because you never use it again (other than in the next line). I recommend just inserting into the next line without storing it first in . This is what I mean: 

Not only is this simpler (and probably faster), it is also more idiomatic and easier to understand what is being done here. Now that the native sort method is being used, there is no need for recursive placement. Just use a loop: 

can be shortened. First off, you should be setting the new value of display separately. Then, you can create a simple and small ternary to set the style property of to that new value. Here is what that looks like: 

Your code is very clean and simplistic, which is a good thing. There is just one glaring problem that I see. 

Diagonals are diagonals no matter how you cross them You are right again: your diagonals-checking function is also pretty darn wet. This time, the only major difference is what parameter you are passing into a function. This can be solved just like it was done above: 

where, for each inner array, you put the three board array-indexes needed to complete a win. For example, if your board array is 0-based, the first win combination would be - the top row. Then, you could easily iterate over this array and check each combination all in a single loop. Sorry if this isn't clear; you can ask for clarification in a comment, and/or check some of my other tic tac toe answers for more detail. 

That middle line is very, very weird. Commonly, an method initializes an object with some data that it will need. However, in this case, you are treating as a class that you are instantiating. It looks to me that should be the instantiated object here. It looks even weirder when you do type checking. Here is an example console window: 

The variable is equal to the attribute of . And, the calling on returns the attribute of so of course they are going to be equal. I may be missing something here, but I think this is unnecessary. 

Note: This assumes that r0 was 0 to being with, which I think it was. The above will put the value into . You can do this same thing for when you are putting the size of the memory segment into , and when you are putting the bit pattern into . It didn't look like you specifically needed to actually use the instruction, which seems unnecessarily complicated for simply putting a value into a register. However, if you did, just change the instruction to: 

0X vs 0x This isn't the biggest thing, but most people have a lower-case 'x' when defining a number as a hexadecimal number. The code now: 

where you are making a lot of calls to , it would be best to store the return of in a variable and then to just access that variable. 

What if the user makes a mistake in their typing and accidently enters invalid input? Instead of exiting the program, you should just run the loop and ask for input again. 

There are probably tons of API's on the internet that will serve as a dictionary for your program. Pro: You don't have to download anything; just make a simple call to an API. Con: APIs have limits such as calls per day. Also, sometimes your code can get hung up on an API call. 

Is not very flexible. What if you decide to add more suffixes? As you add more and more s, this construct just gets more and more ugly. I recommend creating an object where the values are the number to check the exponent against, and the keys are the suffixes to add. That would look like this: