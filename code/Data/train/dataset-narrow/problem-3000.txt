The learning of the students is based more upon the knowledge passed on from the teacher to the students. The language, and its libraries and examples, are mere tools. How they are used, and presented, by the instructor can remove any associated ambiguity that might result from the chosen names if they were encountered "in the wild." On the other hand, helping the students to handle situations where a symbol's name does not match what they "expect" that it should indicate is a worthwhile goal. There will be many occasions in their future career, if they pursue such, where they will encounter many "names" that don't match what they think they should. The, likely minor, disconnect between expectations and reality of names in languages and libraries should be a good learning tool for when they encounter much larger disconnects in code written by others that they either have to maintain, or interact with in future projects. 

If the students are still needing real "objects" to connect metally with the concept of object you could resort to using transportation as a system. Another user, G. Ann - SonarSource Team, gave a good break down you could follow in answer to another question. On the other hand, if you are looking for a more practical use-case, then you can use lists. There is the Node, which in its simplest form is nothing more than a data encapsulation, and the List which implements the process of accessing the nodes. The List and Node can both be inherited as you expand from array-based lists to linked lists, and into doubly linked lists. Then you can switch to stacks and queues, maybe even moving into binary, and n-ary, trees. 

General Purpose Programming Skills General purpose programming skills can also be called Computational Thinking. Computational thinking has four cornerstonesÂ¹: 

If we consider the top-left as post "A" (the source post), the top-right as post "B" (the target post), and the bottom-center as post "C" (the working post), then the setup rule is: 

If you have taught, and used, the singleton pattern, then they should have a decent change of coming to the conclusion that such is what you want. Still, other solutions are possible, such as a wrapper class that tests for how many there are already, or some kind of internal test for prior instances. The more specific you can be to eliminate alternative "fixes" the better. My opinion is that in a testing environment it is unwise to ask for evaluation of designs in search of improvements. As I covered earlier, this will not offer any reliable insight into the abilities or thinking patterns of the tested students, but rather it might offer insights into their test-taking patterns. Since I doubt the latter is your objective, the tools used might be better replaced. It might be better to tell them to use a pattern to change (or even create) something, and the skeleton of that can even be bare bones. To determine that they understand the singleton pattern, as you taught it, you could instruct them to convert the following skeleton into a singleton class: 

The names of symbols in the language, or library, that is being used in the classroom should not have any effect upon student learning. 

The primary drive behind the open/close principle was to avoid having to update programs that used a library when changes were made to that library. Or, in other words, to enforce backward compatibility for old programs that used a library. By not modifying the object (the close half) any code that uses the object according to the documented API, will always work. By allowing extension of the object (the open half) new features, data, methods, etc., can be added to the functionality of the object to handle new uses for the object, or its subclasses. Combining both means that the existing object, that almost fits the needs, can be enhanced to be useful in a new program, and still be used by the old programs, without needing to recode the old programs. A common API that most high school students are familiar with is the telephone. It is going to be a very rare high school student who has never used a push-button telephone, including the "buttons" on the screen of a smart phone. So it is something that's well within the prior experience for those students. The twelve standard buttons on the push-button telephone haven't been changed since the Western Electric model 2500 was introduced in 1968. The latest model smart phone still uses the same layout, and it still works the same (from the user's perspective), even if it's now a touch-sensitive screen rather than twelve physical buttons. They way on made a phone call in 1968 using a push-button phone, and they way one makes a phone call now with a smart phone is the same. It has not been modified. What you can do with those same twelve buttons, or simulated buttons on the smart phone, has been greatly extended. Sending text messages is only one change of many. There's no guessing what else those buttons might be extended to do, using new methods or new data. No matter what new extensions are added, the original will not be modified. 

I want to set up a fully functional web server in the classroom. I will be using a separate computer provisioned with Apache, MySQL, Tomcat, PHP, Perl, etc. I want to have each student in the class able to have their own working directory. I also want to have a pair of sharing directories. One where they can access, without changing, lesson-based material, and one where they can upload content for others to access, and where collaborative projects can be built. I intend that each student's personal directory will migrate with them as they progress through the courses, for those that do continue. Situation: 

Coursera (AP CS A): The students are provided the finished algorithms and expected to apply them properly to solve some larger problem. The emphasis is on solving the problem with the given tools, not creation of the tools. All the coding, by the student and supplied to the student, is done in Java. 

That way you are not presenting an "empty" loop, but one that is planned for a purpose, and that purpose just happens to be "to be determined." Don't leave it that way either, but fill it with something real before executing the program. The comment line is showing the development process of changing the first version into a useful version. The next step is to then put something there, even if it just flashes the LED as the robot advances to the target. vs Some programming languages have an control statement, others do not. Many of those which have both a and an separate their usage by having the test the condition before the loop executes, and the tests its condition after the loop executes. In hypothetical syntax they are commonly like this: 

If you don't want the students to get hung up on the language quirks for the language you are teaching, there are probably many ways to "work around" them. If you don't want the students to get hung up on the language quirks for the next language they have to use, either in school or out, and when you are not there to help, then you've really only got one choice. Teach them to understand why the quirks exist, and what is happening "behind the scenes" that makes them "work." The Embrace option given in the answer by Ben I. is a good example of how to do that. Show the "unexpected" behavior, then lead them on a path of discovery to explain the anomaly just observed. By discovering it they will own it, and be better able to discover the reasons for other anomalies when they are encountered elsewhere. By taking the Embrace route you are not only teaching the language in use at the time, you are also helping the students to develop reasoning skills. Skills that will help them reach their potential in whatever direction life takes them. A good Computer Science program can teach programming, in one language or another, as well as other computer science pathways. It can also teach, and hone, reasoning and analytic skills that are useful in many fields that are totally unrelated to computers, or even science. This is one of the common reasons (not the only, nor necessarily the main reason) that many schools, and school systems, have introduced Computer Science programs to their curriculum. Don't waste the opportunity to help your students develop those valuable skills by side-stepping, or hand-waving away, the quirks, which make such wonderful "teaching moments." 

Limited prior programming exposure All the above, absent the motor and sensor parts, really applies to any programming related course. It can even help prepare students for what they will encounter "in the wild" with other languages not covered by the course. The specifics of this question, however, with its short duration and unknown, but probably limited, prior programming by the students, creates extra concerns. As made clear in one comment in chat, the students may not even understand the concept of statement block and there is precious little time to explain all the details of programming, let along all the possible variations. With the objectives of awareness/excitement about career paths in mind, planning ahead and having some of the desired variations pre-built might be helpful. For example, the first two code segments could be saved, and quickly "built" with the students. A third variation, which might be attractive to the students, is to have the LED flash faster as the distance closes with the target. Using guessed numbers for examples here, with numbers found to be useful in the lab replacing mine, the original line could be replaced with something like this: 

That will give a duty-cycle of 60% and an initial frequency of 2 flashes per second, and a final frequency of 50Hz. Another chance to reinforce some math and science, increase the engagement with the robot, and not introduce new programming concepts. In consideration of the limited time and limited programming exposure before this segment, I think that introducing the empty loop 

The given rules offer no guidance for the next move, and computers must have rules to follow. There is another iterative approach, which does work for creating an algorithm. It has a setup rule, a movement rule and a cycle to repeat. The puzzle usually does not give the arrangement of the posts, only that there are three of them. It is commonly displayed, or presented, with the posts being in a straight line. It can, however, be presented as an arrangement of three posts in a triangular formation, like the image below. In either case, working this iterative approach needs to treat the set of posts as a wrap-around collection, being able to move between the posts infinitely in either direction. The triangular formation makes that easier to visualize than the linear formation. 

Source RobotC Wiki: Control Structures That still leaves the as an issue, however. Based on the English usage, from which most programming languages derive their meaning, "while" and "until" are opposites. "While" implies that something is not done unless the test is true. "Until" implies that something is done unless the test is true. The loop exits when the test condition is false (fails), the loop exits when the test condition is true (passes). Using that, for a language which lacks the control statement, the same functionality can be created by using a negative test. Thus becomes , or if the language uses this syntax, . Thus 's usage can be created when needed. In the case of RobotC it's even possible to create the common version of a tail-test by using Note: Perl has taken the vs concept and extended it into the realm of the statement by creating an test: 

Any solution will be "technical" in nature since the problem involves technology anyway. However, for the "access" issue, you can create a solution which puts more work on you than on the technology. (Since tech is supposed to make human work easier, that's kind of an anti-tech concept, right?) Required environment is a publicly (relative to the classroom computers) accessible file storage in which you (the instructor) can create password-protected directories. [This can still be a closed environment relative to the wider network, including other parts of the LAN, and the Internet as a whole, so long as it is a location that the students can access during class.] Out-of-class access could be an issue, either because it is desirable and making it happen is not easy on the school's system, or because it is undesirable, yet hard to prevent on the school's system. As mentioned in another answer, the students can always print a copy, or email a copy to themselves, for out-of-class review and planning. For the project, create a directory for each pair, or team of any size, with a unique (per directory) password. Provide that password to each of the team members. When one is absent, for any reason, the other (rest) can still access the directory. If you have the need to reassign team membership, you change the password(s) in the affected directories and give them to the reorganized teams. This provides each team a space to work, and share, including a place to make related notes, trials, documents, etc. You, as the instructor, will have access to all the directories, and can check the work at any time. The solution works equally well for program coding, research paper writing, and even graphic design. The hard part for the instructor is creating, and maintaining, the collection of directories and passwords. Especially if there are overlapping project time-frames, requiring that there be multiple sets of directories available at one time (along with remembering who has access to which one) with each directory needing a unique, yet easily used, password. This solution does not scale well at all, and is unworkable in a workplace environment, yet is simple enough to set up and use in the controlled environment of an educational arena. At the end of the term you can merely delete/clean the parent directory and you're ready to start the next term. Of course, the underlying principle may be enhanced, or modified, using ACLs, Apache user names, SSH with PGP keys, and many other "technological" variations; but, non-technological was the target. 

Simple demonstration: Presenting this and asking, "What do you see?" is sure to get a variety of answers. Most might be along the line of a bird feeding baby birds. Not all will be, however. Possible answers include "A bunch of birds," "A birds' nest," "Tiny leaves," "A pretty picture," and even "A fuzzy background." None are wrong, and all will show what the answerer first focused on as an answer to the question. None of the answers reflect what else they might have noticed, given more time, or what else they could say, if asked in detail about it. The fact that you wanted to know the species of the bird is not in the question, so not necessarily in the answers. 

As a self-learner you have the extra burdens of resource selection and course design. You can lighten the load by sharing in the work of others. Find universities doing courses and research in the subject and review their course materials and source selections. For the cutting edge things, find papers that have been subjected to peer review, and are sufficiently current to maintain their relevance to current methods. While I support open data and open science, this may be a case where you need to access the material behind a pay-wall, and the expense might be justified. If, after all methods have failed to help you select the best resources you might have simply attempt to implement the different suggestions and evaluate them for correctness, completeness and relevance to your situation. 

Two answers are possible: a direct answer to the explicit question(s), and a response to the implications for education hinted at by the excerpt.