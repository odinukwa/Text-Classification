The operation would be slightly faster using instead of and . Other than that I don't see obvious problems (which doesn't mean much). I guess other data structures could help a lot (e.g. I think some vector implementation would be much faster as board representation). The biggest problem is the algorithm: You definitely want to fill the fields with the least possibilities first. So the best way would be to calculate all candidates for the open fields in the beginning, start backtracking from a field with just a few possibilities (often the choice will be unique) and update the candidates in the same row, column and square accordingly. 

You tagged the question with "array", but I think this is the wrong data structure if you want speed: You need to cycle only over a and b, if you can find cÂ² quickly, and this is difficult with arrays, while s or s provide typically O(log n) access time. I used a here in order to being able to look up the squares quickly, but to recover the original values as well. Note that having the method is crucial for avoiding overhead and duplicates. 

If you don't use such tools, you clutter your code, and after some code changes you might even end up measuring something you didn't intend. Further it is much easier to change behavior afterwards (e.g. printing the timings immediately, or log the timings instead) if you have only one piece of code dedicated to that task. 

If you add a running sum to the formal parameters of , you'll have a truly iterative piece of code. As-is, every time through is called, you leave a "1+ ??" waiting on the stack, which will lead to a recursion depth exceeded error on larger inputs. 

Since lists are built last to first and you want output to read first to last, we need to reverse the inputs. We will also need two accumulator (one for the permutation and one for results so far and some sort of recursion. Given that it's just a matter of messaging the logic into place. 

The sub-definition of is what is being asked for in the 1.12 exercise. However it's entirely unsuited for calculating the entire triangle of X rows. Without a proper data structure (list of lists, vector, hash table...) poor has to do all the work (and absent memiozation must to it many more times than is really necessary) Not having the data structure also forces you to mix the printing logic with the step by step calculation of the triangle, which while clever makes it a bit hard to follow, and difficult to use either separately down the line. My advice is to keep moving along in the book, at which point most of this will be more clear. 

The best case as for time in any complete tree traversal is O(N log(N)) as is yours. The big problem is that it's memory overhead is O(N) 

Depends on the context. If you are unsure about the name, just explain the function with a comment. Depends if you would ever need unfiltered output. In this case that looks pretty unlikely, so I would include the filtering. See above. 

I see some problems with your code: It is not DRY, you calculate results that you never use, and you do "too much" in the -cases. Also, try to find expressive names for your variables (not based on the type, but on the function). I know you're just a beginner, but maybe this is a good opportunity to learn about lambdas. There is an interface for the kind of "operation" you need here, which is called . You can easily create instances by using lambdas, pass these instances around, and call them later. This split between creating some kind of operation, and actually using (or reusing) it is an incredible powerful tool. Have a look: 

I strongly recommend to have an explicit subclass for the empty list (possibly a singleton) and to prohibit null for _cdr. 

However, all versions so far are in the same ballpark and won't change something substantial, because dominates the performance. [Edit 2] The algorithm really doesn't matter much, the impact is too heavy. Collection everything in a and calling doesn't help either. However, quite surprisingly my profiler tells me that this simple recursive version performs best: 

There is a serious flaw in your handling of the empty list. A user would expect that these definitions are equivalent, but they ain't: 

And can thus handle a calculation like though it may take several minutes to do so. ;Value: 76915410 

Here's a small refinement on the technique. Wherin instead of looking for odd multiples and removing them, you keep an extra reference in the incomplete sieve and look those specific multiples of the next prime. The first step is the same, looking for 3* (3, 5, 7, 9, ...,) but the second step you only look for 5*(5, 7, 11, 13, 17, 19, 23 , 25, ...) Overall a small speedup, but the upside is you will never be looking for a multiple that isn't either in the partial sieve or beyond it's range. 

The last bit is the hard part to explain. When asked for the in-order permutation of lefts and rights, you can start forming the next permutation with either the car of lefts or the car of rights. In the nested s here the inner is evaluated first because the scheme interpreter does eager evaluation. The value returned by examining the permutations that involve picking the left side is going to be one or more permutations tacked onto the existing known permutation at that point in the calculation. This returned value is used as the accumulator when examining the permutations that involve picking the car of the right side instead. As far as effeciency, this loop executes once for every element in every permutation. Nothing fancy there, but it will do it in a memory stack no deeper than the sum of the length of the inputs. 

Even if this solution isn't appropriate in your setting, it's useful to know this "search from both ends" technique. Obviously this approach would be much simpler if you can assume an already sorted array. 

I don't really understand why you use tuples when you have already a class for doing exactly such kind of math, namely . The code could be more functional by using immutable case classes for s (but it depends on the problem if this is the right thing to do): 

Not an answer to your questions, but a correction for your first, looping attempt for Q3: Things get much easier if you initially have at least one prime number in your list. You could ensure this by a separate case in , but why not cheat a little bit, and add it directly? 

This might be a little bit over-the-top, but how about a more object oriented approach? Assume this little helper enum: 

Eliminating the while loop isn't that straight-forward, maybe someone else has an idea how to avoid that Iterator train-wreck. [Edit] I asked in another forum for a better solution for , and got this answer: 

As Daniel Fisher already mentioned, you're using a Stack. The most basic implementation of this is a single linked list. The down side is that it consumes more memory than an array based implementation. The up side is that it is much easier to implement: You don't have to juggle with indexes, you don't have to copy the array content etc. 

The advantage of this design is that you'd quickly find that you don't really need much inheritance at all. I would aim to have at most a single pure abstract base class, and implementations for the different abilities. Any time you need to share some code, just make a new class, and have the other classes own one. LEAKY ENCAPSULATION Make everything private. If something needs to be public, check to see where it's used. If it's only used somewhere else, move it. Never use public fields - anything public should be a property. Never set data on another class instance - all setters should be at most private, but better, simply non-existent (i.e. either set in the constructor or implicit functions). That's it for now. Two general points to always bear in mind: 

Your code is going to log an awful lot of "GameObject is not null" items, for very few non-null game objects. Basically, you've made an O(n * m * p * q) algorithm, where all you needed was (at most) an O(n + m + p + q) algorithm. This would achieve the same effect - beyond the fact that you'll get fewer logs of the same non-null combination over and over again. This code assumes that the library requires an enumerator. 

Inheritance is the devil. Never implement an "is-a" relationship with inheritance. Any time you reach for inheritance, you need to cultivate an instinct to stop and do something different. Note this is different from abstract definition and sealed implementation - that's just a strategy pattern, which is absolutely fine. Make more classes, that do fewer things. 

This works as any multiple of n still in the partial sieve must also be coprime with all primes less than N. (of which the partial sieve is a complete list) Now while not purely functional instead of keeping the result and reversing it in the end on your second iteration, you could implement it as a tail-modulo cons. While not stickly functional on the inside, it is functional from the outside. Another optimization would be to pass the maximum canidate to the remover of multiples and just return the xs when i is smaller than the last search. 

Overall the shape of how I would approach it is very similar to your second attempt. Just a few critiques. Generally is the way to build lists. Secondly by mapping up from prior results you are keeping quite a bit extra of data on the stack. 

So either a is the minimum of the list in which case b and c or it's not and it's one of the numbers you want to keep. The other is the max of b and c. 

Within the for loop you should assign sum to zero and break whenever is zero as continuing through the loop is pointless (the product of zero and anything is zero). Bonus points if you can assign so the loop it's nested in doesn't waste time with a bunch of sums that will also turn out to be zero