Can someone provide a code review (particularity on my OOP skills)? Also, what would be the most object oriented way to implement "crazy cards"? 

As you can tell, it's meant to represent John Conway's Game of Life on a JFrame. It's my first project using animation and graphics, so I expect there to be a few bad practices. Could anyone provide an honest, critical code review? Thanks 

You might have read my question on shortening my code to a one-liner for Problem 1. So, I was wondering, is there any more tricks of the trade to shorten my Problem 2 solution: 

This is my first ever game in Pygame, so I'm asuming there's a few bad practices. Can anyone improve my code and find those bad practices? 

Which is supposed to replicate the classic game of hangman visually. Is the code fully optimized? Is there an other way I could improve it? 

I would like to find a way to keep everything in this python code to as little number of lines as possible (maybe even a one liner??), and possibly improve the speed (it's currently around 12 ms). By the way, this is the problem: Find the sum of all the multiples of 3 or 5 below 1000.Suggestions?Thanks. 

which takes a file containing match results, and creates a file containing a ranking based on the Elo Ranking System. However, I feel like my method could've been implemented in a better way, so I came here to see for some pointers as to how I can better implement it or pick up any other good practices. EDIT: Here's an example of the input file: 

Your code goes over all the non-negative integers, and takes counts how many of them result in a prime, until the first non-prime. "All the non-negative integers" can be expressed in ruby as , so we can write: 

Optimizations Since you don't give any background, it is hard to give you feedback on your algorithm - are you trying to implement a specific sorting algorithm on your own? are you simply not familiar with java's own solution to sorting ()? Optimal solutions for sorting an array are with complexity of \$O(n \cdot log(n))\$, your solution is \$O(n^2)\$, so there is room for improvement there... you can find a myriad of sorting algorithms here. You could further optimize your code by making a few quick checks on your data before doing the heavy lifting. For example: if not all the strings have the same length, you can immediately determine that they are not all an anagram of one another, and save yourself the sorting. 

Changes is will be similar, I'm leaving this as an exercise for the OP. Another small observation - your does not have a , which might prove problematic... 

and all the helper methods are no longer needed. Indentation and readability When parsing the time string you've got a piping block which looks like this: 

How is it better than your current code? It is not more expressive, nor is it more succinct, nor DRY. Also, these associations are similar to some extent, but they look as DRY as you can make them - one is , while the others are , one uses the default idiom, while the others have names different than the associated class, conditions are different (and though one might argue you can predict the filter by the association name, one is singular, and the other is plural...) In short, I think your current code is good enough - any change will only harm readability. 

I realise that in CR we are encouraged to review the code rather than suggest alternatives but in this case there are good reviews so I hope I can be forgiven for posting alternative methods. How about this? 

The first regex only accepts some of these - only the second accepts all. See here for a very good narrative on the subject. 

My problem is that sometimes (unpredictably but after at least 1 hour of idle time - which is how long the cache pill takes to expire) the code passes through this mechanism, does not rebuild the cache but retrieves a . I know that the thing was added to the cache in the last rebuild so my logic follows that something unexpected is happening but I cannot think what. Any ideas? Notes 

Will this do what I want it to do - i.e. handle multiple threads waiting for a resource without consuming unnecessary CPU. Is the necessary? Logic suggests that the head of the queue at that point must be me but is there a scenario where it may not be? 

This seems to work fine under normal load - however, a recent high-load period caused everything to fall apart. We even interfered with other hosted apps. Not sure what caused the interference but I want to be sure this side of it is done right. The exceptions I saw were: 

I would recode the list of s into a list of tests and implement them as an . There are other techniques but s offer a nice succinct way of doing this. 

Your problem is not with the loop construct - nor is it with GOTOs. Your problem is you are avoiding some tools that can make your code better. Here's an example. 

Non-static static classes Your inner classes (, , etc.) don't seem to have any use-case where their instances have independent meaning - their state is "hard-coded" on instantiation, and are read-only. Why don't you just declare them as static, just like their parent? Instead of: 

Class per test vs Class per Method Also, your code example implies that each class contains a single test, which loses all meaning for the class. The post talks about a class per method tested, which mean that it may contain more than one test, but all tests are relevant to the same method. 

Naming Class names in general should be singular - , . If you have a constructor which sets coordinates and , call the parameters it gets and , not and ... Also, I would refrain from single letter names, although, in this case, and seem ok, since they represent coordinates. Scoping You declared members, and implemented getters to them which is fine (although you used the wrong idiom for ), but you failed to declare the members as . This means that these members are , and can be accessed outside the class: 

This is looking more and more like a getter function, and really, since it calls for the state of the instance, you don't need to imply there is ever a calculation, simply call it : 

The line in the first file means that ruby runs the second file before the first file, which is before the method is declared... Doing it the other way around will work, since only when is called is the module is required. dialect/dialect.rb: 

There are many edge cases to e-mail address structure that you will exclude if you try the simplest approach. One I use that accepts most of the reasonably acceptable e-mail address looks like: 

I realize we are supposed to keep our comments about the code posted in the question. I am breaking a little from that because this is less a what's wrong with my code than a why did the interviewer not like my code. Here is my take on a FizzBuzz - see how simple it is? 

See how I can now call in what used to be a spin-lock around . What I like most about this is that the method is truly simple and that it will only wake up the thread that has been waiting longest. I have some questions though: 

Your lazy method is not thread safe. If two threads check for the key at the same time they will both find it absent and both create a new object. Wrapping your in a will get around this. 

See that by refactoring properly you can now add more validations steps without affecting the main code, each one will only add to the quality. You have now transformed brittle code that is comparably difficult to understand and enhance into something clear and flexible. This encourages you to focus on the fact that you are trying to mix validation with parsing. If you let your worries guide you properly you will see that the validation is a separate process and your attempt to mix the validation into the parsing process is making your code smell. Validate first - then parse. Do not pre-optimise and merge them into one until you have a good measured reason to do so - and even then measure again. Added Just for the joy of it - here's what it might look like in Java 8 

I don't see anything wrong with your implementation - if it works for you, and does not interfere with the system - go for it! I will even go further and claim that the guard conditions in your internal constructor are redundant because the constructor will only be used by the single public constructor, or by a test which: 

Naming, naming, naming... Your code is very hard to read - , , , (?!?). I understand (hope?) that some of these names are part of your business nomenclature, but, especially when asking strangers to read your code for optimization, giving meaningful names can go a long way. Asking me to figure out how to optimize a loop with would be hard enough if the names there meant something to me... Break it down Your methods are very long ( is 67 lines long...) this is a code smell, which also makes your code hard to read, as well as hides the structure of your flow, and possible complexity issues. Refactor your methods to be shorter, with expressive names, that will make your code more readable, more testable, and more optimizeable. Distribute the load As @Dan suggested in his comments - you should consider spreading the load on several threads/CPUs/machines... As far as I could see, your calculations are independent of each other, so you could simply arbitrarily split the load on several instances (let's say take over 9 of your friends' machines, and give each machine all the run ids ending with a specific digit...). This should give you linear scale (up to the point where writing to the DB is your bottleneck). Optimizations for one-time code Perhaps I misunderstood your explanation, but it seems that this code is meant to run once. If that is the case, why do you care if it runs 15 minutes, or 8 hours? Just run it and get on with your life! 

Note also the and methods that avoid your manual creation of the lists. Note also how I calculate the carry rather than explicitly set it to or . It is calculated to be the value remaining after the digit has been extracted from the divided by . Finally, see how using s allows you to interrogate each list to see if it is exhausted and, if it is, use . This way we don't need to special case one being longer or shorter than the other. 

I post full code in the hope that you will learn. If this is homework please try to understand all the changes I have made instead of just copying it. 

I was just playing with this and came up with this rather neat (IMHO) solution so I thought I should post. Essentially, I let the hold a of the that link to them. You then do your query on the sub types. 

Once you realised that you were permuting the characters you should have stopped there and worked out how to do that in a general way. Here is a base class for permutations iteration: 

If (as suggested by @h.j.k) you are not able to adjust you could still achieve the same functionality with something like: 

Note the use of instead of . What was happening was that every time I checked to see if the cache had expired I was resetting the access time of the pill - and therefore not expiring the cache. 

and it all still works in exactly the way you would expect. This is essentially coding the algorithm and the data separately.