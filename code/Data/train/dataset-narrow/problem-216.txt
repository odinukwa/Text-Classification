Even then it still might not work. Apple never designed Airplay to work across different subnets. However, it still may be possible to get it to work. Most enterprise wireless vendors have "special" support for Bonjour (or it's official name: Multicast Domain Name Service - MDNS). I believe Ruckus does have support for this, again you will have to consult your documentation. -Neil 

The router (the switch appears to be acting as a router) is not configured to forward multicast traffic between the wired and wireless networks. If you enable multicast, be sure to enable igmp snooping on the switch as well, or you will be flooding the multicast traffic out all of the wired switch ports in that network. A lot of enterprise wireless Access Points are configured by default to not transmit multicast traffic out to the air because it can consume valuable airtime and degrade the performance of the wireless network. It is possible to enable multicast if needed, but be aware multicast traffic is transmitted at the lowest data rate the wireless network is configured to support. Some enterprise AP's can be configured to optimize Multicast traffic by converting it to Unicast, check your documentation. 

We have been running 802.11k (and 802.11v) on our campus network (~9200 AP's) for close to a year. We are using a controller based Wi-Fi infrastructure (Aruba Networks). Our wired network infrastructure is Cisco. We did have to disable the advertisement of 802.11k "Quiet IE"s to prevent some compatibility issues with older clients. While we have CDP and LLDP enabled on our wired infrastructure, they are not necessary. Everything is handled by the wireless controller(s). 

To answer your first question, Yes someone with a wireless sniffer will be able to find your "hidden" SSID by examining probe requests from clients that are already configured to connect to that SSID. Implementing 802.1x can provide the security you are looking for IF it is configured correctly. At the very least you will want to configure your clients to verify the RADIUS server's TLS certificate and server name to prevent the attack you are concerned about (I believe it's referred to as an "evil-twin" attack). Implementing 802.1x is not easy. It requires setting up, configuring, and maintaining a RADIUS server as well as TLS Certificates. It will require end user education and training. Without understanding more about your infrastructure and risk profile that's the best answer I can give. 

In cases where common configure mode is unavailable, like when the chassis are clustered, you can use the following method. After executing a , JunOS checks the config and creates the file . The running config database is locked until the commit at time, so other users won't be able to commit interim changes. Other users can delete pending changes with the command. This will unlock the running config database and allow for other commits; however, the original user may be a bit upset at his or her changes not going in. If you want to see what the differences between the pending config file and the current running config, perform the following: 

If an engineer configures some changes in a JunOS box and then set them to go live later, that effectively locks the config database with a configure exclusive. How can I see the changes that he or she has committed? 

JunOS will output the patch-style text of the changes in the pending commit. After doing whatever work you need to complete during the pending commit, you can paste that back in with a (or pipe to another file), and the original user will be much happier. Edit: If you seem to be forced into a private edit mode, as might be the case in a chassis cluster: 

That seems to work just fine and skirts that nasty issue of being forced into private config mode. is a hidden commmand 

Long ago, I read (I don't recall where now) that one may test a link's throughput by copying a file from a remote source to a local Cisco router's null: file system. I thought it was a great suggestion but never really had the chance to use it. REcently, I've been troubleshooting a link where the customer has been complaining of slow connectivity. I dusted off this nugget stored in my brain and tried it out. I'm slightly concerned about the results, however. Truly, the connection was slow, but it was FAR slower than I expected it to be, slower even than the customer's report of a similarly-sized file. The command I used was something like: 

The Message Age field in STP is similar to a TTL field in IP packet and is supposed to —prevent BPDUs being forwarded between STP-aware switches endlessly —define a maximum lifetime for a particular BPDU to prevent processing old and possibly outdated information The Message Age is set to 0 at the root bridge. Every other non-root switch will increase the Message Age field by one in the received BPDU when relaying it via its own ports. Moreover, on each non-root switch, the BPDU itself will age out in (Max Age - Message Age). This makes sure that the more hops this BPDU has traversed from the root, the sooner it will expire. 

You can judge it by the LEDS signal light. If laptop says UNPLUGGED then you don't have a connection, and this can also be verified by the tinny LED by the RJ45. So OK, some laptops may not have LEDs but certainly the RJ45 by the switch port have LEDs? Surely, there is ANOTHER device you can try. TV? DVD player with network? SOMETHING. RJ45 to RJ45, the LEDs should light up. Hope this would help! 

A fiber optic transmitter is a device which includes a LED or laser source and signal conditioning electronics that is used to inject a signal into fiber. Fiber optic receivers capture the light from a fiber optic cable, decode the binary data it is sending and then convert into an electrical signal. Information is sent from a source to a transmitter by means of an electrical signal. The transmitter then takes that binary data and transfers it to a light signal. The light signal is passed through fiber optic cables and connectors until it reaches the receiver. The receiver then takes that light signal, translates it back to an electrical signal allowing the binary data to be read by the user. A transceiver is a device which combines the functions of both the transmitter and receiver. Loopbacks are used for testing and some other applications. They feed data back to the same unit so that the original transmitted data can be compared to that received, thus identifiying transmission errors. Hope this would help!