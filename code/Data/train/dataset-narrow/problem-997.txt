Also C++11 allows you to construct the stream object with a std::string so you don't need to call if you really want to use the variable name. I don't see the point of opening and closing the file to truncate it. 

You need to add constructors for moving the data object into the node (look up move semantics). Also building the data object in-place is another useful technique (but more advanced). As I mentioned above: 

Design Your main issue is design. Without looking at the rest of your code to understand how it works this is a bit of a guess. But it feels like you have a design issue with your larger algorithm. There are much better ways to solve this without scanning way ahead in the input stream. As pointed out by @JerryCoffin above in the comments shunting yard or recursive descent are things you should look into. Personally I think the algorithm would give you the most benefit at this point. Review of Code Iterators are supposed to be very simple object that carry little state. So passing them by value should not be an issue. Also is there a need to limit this to ? 

Note you are assuming there are at least 6 characters in the string. I would not do that (especially since people are likely to throw all kinds of crap at it). A badly formed UTF-8 string is going to cause undefined behavior. Standard warning about: 

Personally I like to align the function names (this makes it easier to read). This is purely personal. Some like it some don't. 

Sentinels You create your list with an initial 'Sentinel' value. This is a common technique to remove the need to check for NULL pointers in your code and can make the other functions easier to write (as you don't need to check for NULL). BUT to use it usefully the list needs to be circular (last element points at first) and you must always have this unused 'Sentinael' node. When you use this technique you should never use the sentinel as a value holding node. You should always skip over it. Your loop then is always from (as the first node) until begin (when you reach begin again you have gone one past the last node (hence the need for a circle). Unfortunately your code is a mix of using sentinel and using NULL terminated list. You need to pick one and stick with it. Using a sentinel makes the code much easier to write (as you don't need to check for NULL and special case the empty list). Need a tail pointer You currently only have a head pointer. This means when you insert into the list you always chain all the way to the end before inserting. This makes an operation that could be O(1) be O(n). Most list implementations use head/tail pointer or use a doubly linked list (one chain for each direction). This makes finding the tail trivial and maintaining the extra pointer has practically no cost. Other comments: The rest of the code assumes you were trying to use a sentential value to make the use of the list more efficient. If you want to use NULL to indicate the end of a list rather than a sentinel the comments will change slightly (but using sentinels is the better solution so I will move ahead from there). Not all types have a default value (or are default constructable). So you need two versions of your node class. One to use as the sentinel and one to use that holds the data payload. Let us assume that Node is the version that holds the payload and inherits from the base class that just contains pointer information: When construing Nodes: 

Naming should describe operation I have no idea what this code is trying to achieve (that's a bad sign). Naming types A1 and A2 when they have some deterministic meaning (that I don't understand) is confusing. Normal I go for very short types names myself ('T' for example). But only when the type does not matter. Here I feel the type does matter. But this code definitely needs some heavy commenting on what it is trying to achieve. As written this is un-maintainable because any maintainer will struggle to work out what is happening. std is sacrosanct This is illegal: 

Encapsulation: My first question is why are you exposing ? Would the class that implemented a tree not be represented by class? The is an internal data structure that is completely private to the tree. Interface My second question is what are you trying to achieve with the tree. What you are trying to achieve defines your public interface to the tree. Currently your public interface to the tree is the which allows a user to directly manipulate the tree. This is not a good interface. User of your tree don't want to maintain a tree (that is why they are using your class so your class can maintain the tree and they don't need to worry about it). So what is your tree going to be used for, once you answer that you can define the user interface to the tree. Implementation Why are you using . Is there really going to be shared ownership of nodes? A tree has a very well defined structure and there is no sharing of nodes each node has children (that are not shared but are owned) and a parent (which is shared but not owned). So there is no need for shared pointers in the tree. Are you exposing the to the user of the class? That breaks encapsulation (exposing internal details of the tree). So that's not a good idea. Also your need to use is a result of sharing the structure externally (exposing implementation details). If you don't allow accesses to the internal structure you don't need to track if a node has references after it is deleted. So at worst these pointers should be ; but personally I would make them all simple pointers (as long as you wrap up the interface and hide the from external users). Code Review Copy Issues (Move?) Currently your tree is not copyable or movable. Copy I think is an issue. 

By the point you execute: it has already decided what needs to be re-built (if you change the dependencies from last time this will not be picked up until your next run now). Looks relatively good. Here is a link to my generic makefile: $URL$ One thing I hate about C++ compilation is seeing all the command line arguments. So my Makefile hides all that and you just see the basics info: 

Because is a named variable it will hit the version that uses . To try and get the alternative version that engages the move constructor add 

Here we have calls to functions that will need to be evaluated even if they are never used (specifically may be expensive (or even the streaming of )). If the check passes you are still obliged to call it here but its value are simply discarded. I would prefer that the function is never called if no error message is going to be produced. What you really want is a short cut operator that prevents subsequent operations from happening. Note overloading and on a class does not yield short-cut operators. Or alternatively any functions should be passed as callbacks to and only evaluated if there output is required. 

Like other situations you need to check the reference count. You are not changing all the other shared pointers if you change this one (if this is your use case then you need to call it something else and give some good documentation). There is a reason that does not have the methods . If you release a pointer from a shared pointer then all shared pointers need to reset there pointer to nullptr so that the shared pointer will never delete it. 

Had to refactor to read. But the static assert is checking that and exist and are members. But if is not a member of then you will get a compiler error above. So I think the static assert is a waste. Also in C++14 we added , and in C++17 we added for exactly this situation. If the parameter supports the method it will work but it also works for C-Arrays. So I would replace with: 

If you are going to write print_array at least write it so that it can use alternative stream (not just std::cout). Then write the output operator. 

8: Learn to use the tools for building makefiles. I like my tools because they build stuff the way I want. BUT they are very brittle to changes in the environment. They need to be plugged into a or some other tool for creating makefiles so that they become more cross platform. 

Any well constructed C++ class should behave just like a normal built in type (and everything in the standard is well constructed). As long as you don't use new/delete it should feel no different to you than using a built in type. 

Use the copy and swap idiom to provide strong exception guarantee. This will also solve the problems in the last two points. Provide Move Semantics. This interface provides the standard copy semantics. 

Initialization of the random number generator should be done once in the application. So best to do it just after main() has been entered. 

It always worries my bare statement inside an if. Especially with function calls that potentially look like macros. 

No point in defining destructor the default version will work perfectly. (As a side note: since it is not virtual there can be no derived types with alternative behaviors so making things symmetric is doubly useless). 

There is currently no error checking to validate that this is valid UTF-8. If this is deliberate it should be documented. You are testing the 1's at the top of a UTF-8 encoded string. But not correctly validating the trailing 0. 

Yo be honest there is so much manipulation of the object outside the context of the functions its hard to see if your invariants are maintained. So the code is really hard to read and even harder to verify if it is correct. SkipList Design I find it hard to follow your code so I can't really tell if you implemented a skip list. BUT this is not the structure I would expect from a skip list. 

That's fine for integers. But you have to consider that somebody can come along behind you and modify your types sometime in the future. If I changed the type of grade to float (not an unreasonable change). Then a grade of becomes valid. I would change this to be: grade >= 0 && grade <= 100 

The C++ compiler is named CXX What you call RESULT is usually named TARGET In addition to SRC you probably need OBJ Commands are usually replaced by uppercase version varaiable names that name themselves. 

Unless you have some sort of massive raid. I don't think you have storage space foe all those numbers. Even if your system uses a smaller number of bits for an unsigned long than mine (say 32 bit). This is still a large file (though doable on modern systems). 

Here the compiler sees that it has as a parameter. But the only version of the function it has requires but that is easily achieved by constructing the directly in place and it will do so. In this case this is very dangerous as the pointer was not dynamically allocated but is going to be deleted. So make your single argument constructor explicit (especially if they are taking ownership). 

DRY Is the += operator not basically the same as the -= operator? I am sure you can reuse about 90% of that code. Operator ! If you have this pattern 

Basically you should not change the state of your object until you have guranteed that there are no expceptions can be thrown and leave your object in an incosistent state. This means your assignemnt should proceed in three stages. 

Now your main program looks at your current location. Looks that location up in the object and can print out the description and options for that location. When your user types in one of the available actions you look that up in linked and update the current location. Then you start the loop again. 

See man send: If returns -1 as an error you need to check to check the actual error. Not all errors need to be terminal. Eg is not a problem. Don't wait for the server to close the conection. 

The problem with allocating pools like this (via char array). Is that the language gives you no guarantees about the alignment of . If on the other hand you used a then the language guarantees that the is aligned for all types of size or smaller (see requirements for dynamically allocated memory). The maximum size of the pool is so this can be represented by 2 bytes. So every block will keep a two byte prefix of its length so that when we de-allocate it we know how many bytes have been added back into the system. Note: We need this prefix size even when the block is allocated. Also this means there is a two byte additional overhead when allocating blocks. Also each free block has to know the next block. Again the next free block has a number of in the range so it can be represented as two bytes. Note: This data is only used when the object has been freed. So it can be used by the application as part of the data space. But it means that that the minimum block size that will be allocated is 2 (so 0/1 sized blocks will not be optimal). 

Design I would put the inside as a private class. Its an implementation detail that nobody needs to know about apart from your class. I would look up how to use a sentinel object. A sentinel is a fake object in your list that truly simplifies the code as you never have to deal with head/tail being null. Have a look at this: $URL$ The interface is not very standard for a list. You may want to look at the design of the standard containers to see what the standard methods are. Naming conventions. It is more traditional to use an uppercase first letter for user defined types. Then lower case letter for functions and objects. 

I don't think so. The main thing about C++ is its strong typing. But you also need to worry about the compilers ability to change types (compiler inserted casts (float => int etc), or use of single argument constructor to convert). Personally I use specific types wherever I need a specific type; but I use auto when I don't care about the type (Iterators are a great example here; I don't care about the actual type I care about the behavior).