I would actually avoid the attempt to mimic C++ syntax. It makes things more complex and exposes unnecessary details. For me it would be equally object-oriented with the following C interface: 

This avoids the higher coupling (inheritance) between the dictionary and its subclass, which is there only to help with initializing the dictionary. 

I would actually recommend you to use the (Constructor) Builder pattern if you are only doing this for easier object initialization: 

The main reason for this reordering of the parts is readability of the test names; I think it reads more naturally when in this order. Try comparing these two variations of naming the same test by reading their names out loud: 

I like to use something very similar to what is here referred to as Roy Osherove's test naming convention, the difference being the order of the parts: 

Start with writing unit and/or feature tests that capture the current behaviour. Then begin refactoring while making sure that the tests pass all the time. If you are not an experienced developer "refactoring" might be a bit vague; I'd then suggest to simply start with removing duplication in whatever form there is. Aleksi had a couple of examples of extracting methods. Start there. As you move stuff to methods you will soon see that there are different categories of methods that are used together. This is an indication that these should be moved to a separate classes to encapsulate that behaviour. Then read about the SOLID principles and continue from there. Practice, practice, practice and think about what you are doing at all times. Good luck! 

This is a simple boolean comparison, so you can literally just return the result of the comparison and not have to make a bulky if-statement. I think that Janos did a good job touching on making your class a simple static method. I agree with him about your use of tests also. You put in a lot of code (more than your actual list and program) to do some really basic tests. I would honestly just keep it to one method. 

This can be placed into it's own method so that you don't have to repetitively type it throughout the code:': 

Room_Carpet Class Once again, the class is designed pretty well, but the copy constructor is not implemented. 

If this method doesn't actually do anything, it shouldn't be in the code. I would say that having copy constructors can be very helpful... If the method is properly implemented. The point of a copy constructor is that you can pass an object, which is already instantiated, to another object of the same type to instantiate it. The benefit to this is that you don't have to worry about passing a bunch of values to the object manually. You literally create the copy of the object with the values that it contains. 

Also, you should always use brackets in your statements, even if it's just one line. Not using brackets makes things harder for other programmers to read your code and increases the probability that unintended bugs arise. 

Declare the calculator instance as a field in the fixture instead, and initialize in a method. There's also the duplication of . In this specific case I might go as far as to get rid of entirely: 

Try reading the code out loud for yourself for each of the samples above. Further adding a few line breaks to the latest version makes it a bit easier to visually separate what you're testing from the expected result, but that's a very personal opinion. See refactored example below. Don't use SUT literally As others have already said, don't use as a variable name. Sure, you might know the context and be familiar with the acronym but I still consider to be more expressive than . One circumstance where you could use e.g. as a variable name is where you have a very generic test suite that can be reused for many implementations. However, even then I would strongly suggest that you name the variable referring to the SUT according to what kind of capabilities being tested within that specific suite. A short example: 

The above interface hides the details while allowing polymorphism; you could e.g. keep the "vtable" implementation (but hidden) and provide different init-functions. I really don't follow all that macro voodoo but having a mutable shared state - the "pointer to current class" - seems susceptible to race conditions. 

There nothing wrong with the code per se. I'd still prefer to have the error return statement inside the catch block to keep it close to where the condition is detected. I would also move the success return statement to the end of the method: 

I encourage you to consider writing unit tests (I recommend ). It'll make your tests easier to write and read. The above tests are ok, but I would definitely add tests to check that you get when you expect to. Overall: Your code is overall quite clean and easy to follow. It's not quite production-level, but it is good for a Java course. Nice job! Regarding returning : There is a large discussion around this issue. I think most people believe something along these lines: 1.) should not be used in place of an error. This is because in general, methods should enforce their contracts loudly, i.e. if a method's job is to take a number greater than zero and return it times two, and it gets a number less than zero, it should complain. By returning , you force programmers who use your code (if they're responsible) to write in code to handle the possible null case, because otherwise there's no guarantee that they will be aware of the error that made your method return . And 2.) can be used as "no results", but it might be better to return an or an empty data structure instead. For more, check out this question Is it better to return NULL or empty values from functions/methods where the return value is not present? For a class assignment, though, it may well be the case that using is "ok" because its fast - and it doesn't require you to shift focus from whatever the point of this assignment is to spend time writing exception throwing code. Avoiding using as an error, and instead throwing an exception, is a best practice, though, and as you grow as a programmer you may want to do so even if it's not required. Be careful though - if your code is auto-graded and it is expected that it will return for a given input, an exception will probably cause it to be marked wrong. In this case I suggest writing code to your assignment's specification, and being content with knowing that were you writing code in the "real world", you'd do it differently