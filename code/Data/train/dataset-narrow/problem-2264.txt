This implies that $G_1$ has only trivial automorphisms. In other words, I'm assuming the existence of some BPP algorithm, which works as follows: 

Before concluding, allow me to mention that there are actually several definitions for PoKs, some of which are cited below: 1) Early attempts: Feige, Fiat and Shamir (J. Cryptology, 1988), Tompa and Woll (FOCS 1987), and Feige and Shamir (STOC 1990). 2) De facto standard: Bellare and Goldreich (CRYPTO '92). This paper surveys the early attempts at defining PoKs, observes their shortcomings, and suggests a new definition which can be considered as "the" definition of PoK. This definition has a black-box nature (the knowledge extractor has black-box access to the cheating prover). 3) Conservative PoKs: Defined by Halevi and Micali (ePrint Archive: Report 1998/015), this definition augments the previous definition to guarantee prover feasibility. It also gives a definition for the knowledge of a single prover, which is good when answering the question "what does it mean to say that P knows something?" 4) Arguments of Knowledge with Non Black-Box Extraction: As mentioned above, the standard definition of PoKs is black box, which makes it impossible to have resettable zero-knowledge proofs (or arguments) of knowledge for non-trivial languages. Barak et al. (FOCS 2001) provide a non-black-box definition, which is based on (but differs from) the definition of Feige and Shamir (STOC 1990) cited above. 

Question Could you please illustrate the flaw in the BR95 via an example, where disallowing the TEST attack in the middle of execution can result in a false proof of security? 

Thus, the reason for using several games is that in each game, we simplify the computation of some unknown probability, without altering it in a significant way. This continues until we reach a game in which the computation of the probability is easy enough. 

The time-complexity of entities is limited to $2^{80}$ operations. Entities can perform up to $2^{30}$ operations per second. The best algorithm for factoring an integer is GNFS. Given this assumption, factoring a carefully chosen $1024$-bit integer requires about $2^{86}$ operations, which is infeasible according to assumption 1. In the identification protocol, there is a $30$-second time-out. The adversary can take its time to perform any preprocessing, but when engaged in protocol execution, he must reply within $30$ seconds, or time-out occurs and he fails. (This is in contrast to signature schemes, where the adversary is not faced with such restriction.) During the lifetime of the system, the adversary may engage in at most $10^8$ identification sessions. He is successful if he can impersonate in at least one session, and he fails otherwise. In other words, a successful adversary is one whose success probability is at least $10^{-8}$. 

$k \gets \mathsf{Gen}(1^n)$. $(m,t) \gets A^{\mathsf{MAC}_k(\cdot)}(1^n)$. Let $Q$ denote the set of all queries that $A$ asked to its oracle. The output of the experiment is defined to be 1 if and only if: 

Let $\Pi = \{\Pi_1, \ldots, \Pi_n\}$ be the finite partition of problem $\Pi$. Let $M_1, \ldots, M_n$ be the poly-time machines which decide the corresponding partition. Since the partition is finite, we can construct a poly-time machine $M$ which incorporates the code of $M_1, \ldots, M_n$. On input $x \in \Pi_i$, $M$ determines the corresponding partition $\Pi_i$, and calls the respective machine $M_i$ to decide it. This shows that $\Pi$ can be decided in poly-time, which is impossible unless $P = NP$. Edit: The above approach is incorrect in that $M$ may not be able to determine the correct partition. The right approach is given by Antonio in a comment bellow. It does not need to recognize the partition; instead, it just runs all $M_i$'s on $x$ an accepts if and only if at least one of them accepts. 

This is called the known-plaintext attack. Any cipher algorithm which is prone to this type of attack is considered very weak. Therefore, AFAIK, no present-day cipher (e.g. AES) has this weakness. Even DES needs 243 known plaintexts to be broken under linear cryptanalysis. (see this topic on Wikipedia). On the other hand, all hope is not lost. Weak ciphers or bad implementation of strong ciphers are still commonplace. One noticeable case is with the (old) implementations of ZIP. More info is available here: $URL$ 

Let $E$ be the (randomized) estimator algorithm. Assume that $E$ has black-box access to $f$. We denote this by $E^f$. There are two conditions: 1) Estimator's running time: There exists a single polynomial $p(\cdot)$ such that for all $n$ and all $f$, the running time of the $E^f(1^n)$ is bounded by $\frac{p(n)}{\mathbb{E}[f(n)]}$. 2) Estimator's precision with confidence $\delta$: There exists a single polynomial $q(\cdot)$, such that for all $n$ and all $f$, we have ${1 \over {q(n)}} < \frac{E^f(1^n)}{\mathbb{E}[f(n)]} < q(n)$ with probability at least $\delta$. 

What you are asking is no longer called "Stable Marriage Problem." In contrast, it's called "Stable Roommates Problem." According to Wikipedia: 

They are somehow unique, and look random. They can take part in algebraic operations repeatedly; i.e. even after applying some specific operation (say multiplication or exponentiation) many times, the "magic" value is still able to generate new values. 

Edit 2: You may combine the above results with the following results on hierarchies for classes with advice: 

The problem can be summarized as follows: Let $\mathcal{A}$ be an algorithm which solves the INTEGER-MULT problem with non-negligible probability. Let this probability be at least $n^{-c}$, for some constant $c \in \mathbb{N}$ (when the size of input is $n$). Prove that there exists a PPT (probabilistic polynomial-time) algorithm $\mathcal{A}'$ which, uses $\mathcal{A}$ as subroutine, and solves an instance of the FACTORING problem of size $n$ with probability at least $n^{-d}$, for some constant $d \in \mathbb{N}$. Consider an algorithm $\mathcal{A}^*$ which solves the INTEGER-MULT problem if and only if the input $N$ has the special from $N = PQR$, where $P$ and $Q$ are primes of size $n/4$ and $R$ is a prime of size $n/2$, and otherwise fails. Moreover, on input an integer $N$ of the above form, it outputs $PQ$ and $R$. We first show that $\mathcal{A}^*$ has a non-negligible probability of solving the INTEGER-MULT problem. To this end, it suffices to find the fraction of $n$-bit integers of the special form, as this fraction bounds the success probability of $\mathcal{A}^*$ from below. By prime number theorem, the number of primes whose size is $k$-bits is: $2^k / \ln(2^k) - 2^{k-1} / \ln(2^{k-1}) = \Theta(2^k / k)$ Therefore, the fraction of $n$-bit integers of the special form is: $\frac{\Theta(2^{n/4} / (n/4))^2 \cdot \Theta(2^{n/2} / (n/2))}{2^{n-1}} = \Theta(n^{-3})$ which is non-negligible in $n$. Therefore, one should be able to prove the existence of a PPT algorithm $\mathcal{A}'$ which, uses $\mathcal{A}^*$ as subroutine, and solves an instance of the FACTORING problem of size $n$ with probability at least $n^{-d}$, for some constant $d \in \mathbb{N}$. IMHO, this seems a very difficult task, since $\mathcal{A}^*$ only (partially) decomposes integers of the special form, and there does not seem to be a way to use it to decompose integers of the form $PQ$. 

The session key of the party on which the TEST attack is mounted; or A random string of the same length as the session key. 

Well, your edited version of the question revealed a reference to the following paper: Rafael Pass. 2003. Simulation in quasi-polynomial time, and its application to protocol composition. In Proceedings of the 22nd international conference on Theory and applications of cryptographic techniques (EUROCRYPT'03), Eli Biham (Ed.). Springer-Verlag, Berlin, Heidelberg, 160-176. (See also this version.) The paper discusses and justifies the need for such simulators. The abstract reads: 

I was reading a paper titled Random Oracles with(out) Programmability. The last paragraph of section 2.3 reads: 

I don't know if these are the best option, but you can give them a try: CiteSeer has some BibTeX entries. Moreover, specific publishers (such as Springer or ScienceDirect) offer an "Export Citation" option, in which you may choose different formats (BibTeX, EndNote, etc.) to export the citation. Here's an example: $URL$ One more note: Google Scholar does not let you to export the citation by default. You have to set the option in the Google Scholar preferences. 

Wikipedia discusses the answer to your question. It says the stable case cannot be always found, yet, there exists an efficient algorithm, due Irving (1985), which will find such matching if there's one. 

Background One issue with modern security proofs is that they are usually asymptotic. In other words, such proofs are usually formulated as follows: For any polynomial-time adversary $\mathcal A$, we can select a large enough security parameter $n$, such that the probability that $\mathcal A$ breaks the system is a negligible function of $n$. Unfortunately, concrete values for parameters of the protocol cannot be readily deduced from such asymptotic proofs. For instance, the size of RSA modulus for a secure signature scheme may not be obtained from an asymptotic proof of security for the given scheme. This issue was first formalized by Bellare and Rogaway, in their famous paper "The exact security of digital signatures: How to sign with RSA and Rabin." They provided a new type of analyzing and proving the security of some scheme, which they termed exact security. Soon after, numerous papers considered this notion, and gave various results on the exact security of signature schemes. 

Here, is meant to generate magic values; which are unique, random-looking, and can work for a lot of 's. (Actually, ranges in 0..63). Edit: Reading the original paper on TEA, one understands that the answer given by "Steven Stadnicki" is correct. Note that the magic constant is name delta: