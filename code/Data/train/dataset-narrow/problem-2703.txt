This will allow you to have multiple cell types, and have a global Texture2D for better memory usage. 

While working on my 2D tile based game, I encountered a problem. I use Perlin Noise to generate the terrain. Some biomes (Desert, Forest, etc) have different flatness values depending on terrain, which causes the end/start of a new biome to have a big cliff because the terrain is different. When 2 biomes have the same flatness, they are fine, but if they are different, this can happen. Is there any way to keep this from happening? Example (In programmer art) 

I stumbled upon the same question today, from your message type, read the first byte of the message and cast it to . After that, check if it is a status message. If it is, read the string from the message, which is the disconnect reason. 

This way you can just do and have a nice object oriented approach to accessing it (, , etc) and will probably help you later in the long run. One of the bigest mistakes that will hurt you later is not applying elapsed time. If your FPS drops (different computer, running alot of programs, etc) or rises then your sprite will move faster, since it is depending on the update rate. You can solve this by applying elapsed time. 

Each tile can contain a mass of 0 to 255 values of liquid, stored in a byte. I do not use , the old water system I had did, however it added complications and had a performance hit. Each water tile updates itself with a simple set of rules: 1. If the tile below has space in it, move as much as possible from the current tile to the bottom one (Flow Down) 2. If the 2 sides aren't the same and aren't zero and both are passable, we get the sum of the 3 tiles (left + current + right) and divide it by 3 leaving the rest on the middle (current) tile 3. If the rule above gived a number of 2 as sum, we should divide the tiles into the two sides (1, 0, 1) 4. If rule 2 gave 1 as the sum, choose a random side to flow into 5. If rule 2 failed, we should check if one side is passable and the other isn't. If that is true, we split the current tile in half for the 2 tiles How can I expand this logic to include pressure? Pressure will make liquids rise over "U-Bends" and fill in air pockets. Example on how this is currently fails: 

The problem with games is they need things to be done in a specific order. Physics must be done before graphics because otherwise what would be the point of drawing the picture if nothing changed. Scripting needs to be done before physics since if you move an object the physic engine needs to process it. The only alternative I could think of would be a distributed Actor model. Basically each object is given control of it's own resources and everything must talk to it through some communication channel such as a message que. It could be done with shared memory across threads, over IPC for separate processes or networked for separate systems. It can be massively parallel (each object could potentially have it's own thread). There is all kinds of fancy shenanigans you can pull, your objects could be on different servers, with IPv6 you could even give each object it's own ip address, of course it makes sense to keep objects likely to interact together on a thread to cut out overhead but maybe each level/chunk has it's own server process and the player is transferred from process to process. That would result in a lot of overhead. But for some game types it might be ok, a SNES style MMO JRPG might be fine but not a FPS. Physics might be kind of complex in such a situation. It would be non-deterministic since you can guarantee the order of operations, that would make saving/loading/replays unstable and mean more network overhead since you can't just transfer the state and let the client simulate it. But not everything needs physics other than basic collisions. Although even that can still have issues, if you step into a space at the same time as another character, who gets right of way? Different systems might see a different result depending on where they are located. Rendering the graphics would be a pain since it would have to 'ask' each object to report its position each time (or request a subscription to be told when the location of any visible objects is changed and also request to be informed when a object becomes visible to the camera or is created). This could end up with a lot of chatter. Another idea is an event loop. Probably not as a replacement for a main game loop but more for things like resource management. Rather than loading a directory of textures you could spawn a thread and tell it to 'watch' that directory. Any time it sees a file that hasn't been loaded it can spawn off another thread to handle the I/O. It can return 'dummy' objects for placeholders that then load the real object into place when ready. A nice feature is your game can be edited live. It can watch the filesystem for changes and when you edit a texture the game can pull it in straight away. You could also have things 'pop' into existence which might be useful for something like a virtual world (ie Second Life). Or you could have low detail ones that then resolve into clearer images. 

I have a 2D grid based water system in my XNA game, we have a method using cellular automata to simulate water falling and spreading. Example of water flowing down a slope: 

I am developing an open source game that uses a client-server scheme similar to Minecraft. We will control the central authentication server that verifies an account is valid, while players will run their own servers. Authenticating the client is simple, but how can the server know that the user is valid, without having any access to is credentials or session token? For example: 

So for my tile based platformer, It has a grid of tiles Occupying 1x1 block for each one. However, What if I want larger tiles? Maybe doors, tables, etc. They wouldnt fit in a 1x1 tile, so what I need is a way to let any method trying to access my tile array, know that a tile could be occupying a larger space. I can already render larger objects correctly, But I simply am looking for a method to let evrything else know a larger tile is there, So I can perform collision on it, and so other tiles cant be placed on it. 

Using 2 keyboard states is the best way in my mind, and I would say you are correct. I wouldn't even use a class, I would just make a method and call it and check each key with that 

Another possibility in addition to the boundingbox/sphere techniques given above is to use an occlusion query. Basically how it works is you render a low quality version (unshaded, untextured, possibly just a bounding box itself) and you check to see if there where any fragments actually written. If there where you go ahead and render the full mesh otherwise you can toss out the mesh. The advantage to this is that if you have a mesh behind an object but still in your fov then it wont get rendered. Of course in order for that to be really effective you need depth-last sorting of your objects (except the transparent ones which are depth-first unless your using some kind of order independent transparency). Transparency ordering is vastly helped by decent spacial data structures. OpenGL has dedicated occlusion query api functions. I'm not sure about XNA/Direct3D. In addition to that if you have your meshes stored in a decent spacial data structure (ie BSPs or Octrees) you will probably find that there are quick ways to throw out entire chunks of areas. For example the regions behind your camera can be pruned. In an Octree you could render the entire cube region as just a cube in an occlusion query and see if that entire region needs to be processed at all which would let you skip even bothering to check bounding boxes. Finally be careful that very large meshes or ones that cross boundaries don't get cut. You could find that you need to calculate the bounding box of the region itself as being bigger than the actual region if you have a large mesh that's half off the region. A simple hack would be to just add the largest bounding box to the regions size. So basically you can combine all of the above into the following steps: 

I've been thinking about this for a while. I have a 2D tile bases platformer in XNA with a large array of tile data, I've been running into memory problems with large maps. (I will add chunks soon!) Currently, Each tile contains an along with other properties like how its rotated, if it has forground / background, etc. An is static and has properties like the name, tooltip, type of item, how much light it emits, the collision it does to player, etc. Examples: 

In my 2D tile based platformer I have added plants to be able to farm such as the simplest, grass, to other things like corn. Now each of these speacial tiles must be updated to show how much it has grown (Simple states such as 0 = New, 1 = Mature, 2=Blooming) My question is, what would be the best way to do this? So far I belive I could: 

As Tpastor had a great answer on why, here is how to convert it from the hard to read 1D array, to a simple 2D array for easy access to each pixel. 

Then, the client can connect to the server, but the server has no way of verifying is the client is who it says. These servers are ran by players, which make it easy for them to modify the server and collect the user data. (Only the central auth server can be trusted) The authentication server could accept TCP connections, but I wonder if HTTPS would be easier in this case, as getting a response is easier than establishing a listener on each side, especially for only a few requests. 

Cull entire regions from BSP/Octree/Quadtree. Perform quick bound checking for more stuff to drop. Render scene depth sorted with occlusion tests and drop anything not rendered. 

There are 2 ways of doing it. One is called 'polling' that is where you check for events continuously in a loop. The other is where you specify a function to fire when an event happens and is refereed to as a 'callback'. Most Windowing/widget systems will have some kind of callback system in place where you define a function that executes whenever an event like a mouse is clicked, a key pressed, a window is resized, etc... rather than polling it yourself. If you are designing your own 3D Max grabbing a widget system like Qt would be a good idea (It refers to them as Signals and Slots rather than callbacks though). All the main windowsing systems, Qt, GLFW, GLUT, SFML, also have callback sytems. (SDL might not, but it does have a function to wait for events that you might be able to setup in it's own thread to simulate the same thing, but I'm not sure how threadsafe SDL is so tread carefully, the wiki page says it needs to be the same thread that set the video mode). DirectX (or rather XInput/DirectInput will probably also have a callback system). Otherwise if your looking at doing it yourself it will probably be specific to the platform that you are running on. At the real low level there are things called interrupts which are done on the hardware level, basically the processor puts your program to sleep until it receives a hardware interrupt but it's unlikely you will need to bother with anything that low level (even if your on an embedded device like a console/phone there is probably a library for that). The main issue with callbacks would be ensuring that your program is threadsafe. You might receive a callback at the same time your already half way through updating the screen. 

The water should flow and equalize on each side of the U-Bend. Additionally, I have created methods to find out how far down a water block is, and therefore how much pressure it is experiencing. Now I need to be able to take these numbers and apply them to the other areas to equalize the pressure 

As suggested, There is a page on MSDN. EDIT: I see you have another definition of "Toggled". I suggest you make a dictionary of bools or something, and do after you check if its been pressed. 

Additionaly, I would recommend creating a sprite class to hold your Texture, Position, Rotation, Velocity, etc. 

Now, Most would probably use an enum, or a form of ID to identify blocks. Well my system is really nice just to find out about an item. I can simply do To get the name for example. I realized my Item property of the tile is over 1000 Bytes! Wow! What I'm looking for is a way to use an ID ( or depending on how many items) instead of an but still have a method for retreiving data about the type of item a tile contains. 

Now the timeframe for the updates would be something like, a flower blooms every game day (10 minutes in real life), grass spreads every in game hour, etc Thanks for your help, I think I could do this, I'd just like a little advice if any of these are the right path. 

Then when you render, just run though the list. I have used references above but they could be smart pointers, raw pointers, object handles and so on. EDIT: 

It depends if you want to produce finished games or just learn. If you actually want to make a game, making your own game engine from scratch just isn't feasible in any real timeframe unless you have an very narrow, simplified game and even then your still looking at quite a while. Making a 3D game engine from scratch is a huge undertaking. They have heaps of stuff and most of it is complex. Here is a bunch of stuff that a 'game' might contain: 

The short answer is it depends, or use a bit of both. Now days I don't think you even really do textures on objects, instead you do 'materials' or 'effects' on objects. A material can have multiple textures (1 or more basic image textures possibly with transparency, another for normals/bump mapping, another for specular reflections (The shiny part of metal will reflect light more than the scratched dirty bits) another texture for parts that should 'glow'. Another for ambient light (although that will often be the glow texture). They will have inputs (so you can swap between multiple different textures for the 1 material, modify the colour (maybe depending on the team the model is on), change animation speeds. You're likely to use bother depending on what kind of object you are dealing with. And you can also do hybrids between 1 texture over the whole object and individual textures and so on. If you are talking about limited hardware (mobile/web). Or a game with simpler graphics (although in that case optimizing is less important then anyway), I think it really depends. Firstly, how close are you going to get to the object. Something like a house will need multiple textures if you are going to be walking up close to the walls, standing on the ceiling etc... but if it's a top down game where the house never gets closer than a specific distance then it's fine to use 1 texture. Maybe you use both methods depending on which LOD model is loaded. It will depend on the kinds of objects you are going to be using. Some more 'organic' things can only really be done with 1 big texture (think of a tree trunk). Of course something like a face will It will also depend on how many objects you are going to be seeing on the screen at once. If you have a RTS with armies of people vs a smaller number. For the point of view of which is easiest to implement programmer wise, there about the same. In fact if you implement the multiple texture system, that will implement the single texture option. It should also be possible for you to use multiple different materials/textures on one continuous mesh via extra vertex attributes. One of those can be a texture id. This is much easier on modern OpenGL where you can share uniform variables between shaders (I don't know about DirectX but I assume it's possible there too). Of course if you have different properties for your shaders then this will be harder. It also takes more memory. And you have to make the meshes have that metadata (although that can be done automatically). It's also about the content creation pipeline rather than the programming side of things. Are you (or your artist) happier making a model, unwrapping the mesh then paining on it. This will mean each model is individually textured and unique, kind of hand crafted. A Blizzard game might do something like this, it allows fast creation of simple content, that's low performance, just knock together single mesh models then paint on them with a tablet. They use a simple cartoonish painting style. Or are you likely to share textures between various models. A game that uses tiles might want the stone brick texture on 90% of them but mix in a few extra bits on most of them. And unwrapping tile objects is going to be harder in may ways due to the geometry.