Firmware image contains couple of components. There are couple files that creates bootloader (start.elf, bootcode.bin, loader.bin) and couple of kernel images (normal, emergency and cutdown). There is no source available to bootloader files so every Linux distribution is using the same files. They may differ in which versions are they using. Kernel, on the other hand, is distributed both in binary form (compiled) and source form (you can compile and modify it yourself). Binary kernel should be compatible with all distributions but some features that particular distribution is using may not be enabled in it. This is why some distributions build their own version of kernel (with modified config, some patches added etc), based on the official source files and use it instead. Some of them may be even using some other kernel version that has enabled support for RaspberryPi basing on this official sources. So it's up to distribution maintainers to decide if this is needed or not. For example raspbian distribution (and most of the others) is using official kernel without any modifications. You can download the image from github and boot from it (just remember to download modules too). And if you are using rpi-update tool, you are using this kernel/bootloader files too. 

kernel.img file When using Linux kernel, file is just a renamed . It should also be possible (or at least it was possible last time I checked) to use compressed version of this file - . It can contain integrated (ramdisk) but it is not required. For example, stock file does not contain while does. Note: Official kernel compilation guide on eLinux wiki suggest that you should use tool to prepare file. It was necessary in early days of RaspberyPi but nowadays bootloader can handle regular and files. Kernel sources issue What is very important is that when building kernel for RaspberryPi, you can't just use any version of it. Only special version that is ported to RaspberryPi will work. Unfortunately, current upstream version (found on site) is not compatible with RaspberryPi. Also, is not good for RaspberryPi, you should use instead (found on RaspberryPi compatible kernel sources) or if your plan on using buildin . Kernel building instructions The best place to grab kernel sources for RaspberryPi is on foundation github. You can also find some useful explaination on how to get it and how to compile it on official RasbperryPi wiki. Here's my little simplified version of the steps involved (NOTE: I assume you want to crosscompile the kernel. It is much faster and should create the same results but building kernel natively on RaspberryPi is also possible): 

Unfortunately, this is the expected behaviour. At least in newer RaspberryPi revisions, where USB polyfuses are removed (2.0 revision and some boards from revision 1.0). Since now there is (almost) no resistance on USB ports (to eliminate voltage drop), if you hot plug high power USB device, there will be sudden spike in current demand which may cause the reboot. There are couple of things that could be done to prevent this but most of them involves hardware changes - bypassing F3 polyfuse, replacing capacitor, replacing 0R resistors at USB output, etc. There is, however, one simple solution (besides connecting USB devices before running Pi) - use powered USB hub and hot plug your devices to this hub instead of directly to RaspberryPi. 

First question means how many databits that the sensor sends is going to be read and stored (note that acording to the datasheet, it should send 40 bits in response). In order to understand this, you have to first understand how is sending it's data to the host computer. It uses one wire, where host sends start signal: 

RTC operation What RaspberryPi lack is a battery backed RTC (Real Time Clock). It's device that can work independently from main computer and keep track of a passing time even when it's off (this is why it has its own battery). It may work in very simple way - it has a known frequency oscillator connected and on every pulse of the oscillator, it will increment its internal timer/counter. Since the frequency is know, it's easy to calculate the time passed based on the counter. The device will also have a battery so that it can continue working even when external power is off. Some RTC devices may be more sophisticated. They can, for example, create an interrupt in programmable frequency or in alarm mode (set to a certain time in the future or to certain time each day etc). It is not relevant to keeping system time and is optional. How RTC is used A computer can ask RTC what time it is (or more precisely - what is its counter value) at boot time and set its internal date/time based on this value. From now on, however, a computer won't ask RTC for time every second/milisecond/microsecond. Instead, it will run its own clock (called system time), usually using its own timers/counters. Just like in RTC, timer/counter is clocked with a known frequency so it's easy to calculate the time passed. You may force your system to synchronize its clock with RTC device (in both directions) but it won't happen until requested. Some systems are configured to store system time in RTC when shutting down or after NTP synchronization, for example. Lack of RTC RaspberryPi, like many cheap single board computers, does not have external RTC device. This means that it can't ask for current time on boot. But as already mentioned - this is not a problem if we can get date/time from other source (like NTP). The only disadvantage is that unlike RTC, you can't ask NTP on early boot (since you first need network connection). So to directly answer your question - no matter if RaspberryPi (or any other computer) has RTC or not, it will keep track of time using internal timer/counter device which is available in almost every computer system and is required to run almost any kind of operating system. Time in Linux Userspace applications in Linux can determinate so called (which is a time in real world) using function which then calls system call. What happens now is a little bit complicated due to many advanced features that Linux kernel has (like namespaces etc). But the basics is that kernel maintains its time based on . Its actually just a variable inside of the kernel (usually 64bit wide) that counting number of ticks since the system started. Ticks are generated by hardware timer by means of . value is incremented on each such interrupt. Hardware timer is configured to produce such interrupts at regular intervals. The interval is configured at boot time according to a value of kernel config parameter. At any given time, kernel knows how many ticks where generated from boot ( variable), it knows how many such ticks are generated each second ( config option) so it can easily calculate how much time passed from the last boot. So to sum up - kernel asks about (also called ) on boot so it knows what was the actual time when system started. It then adds value to this each time a userspace application asks what time it is using system call. Hardware timer/counter device Hardware timer/counter is a very simple device. It has a counter register that counts its clock ticks. Clock ticks are usually created by some external (an electronic circuit that produces repetitive signal) and are of known frequency (usually ranging from couple of kHz to hundreds MHz). This means that we can easily calculate how much time passed by dividing the counter value by the frequency of oscillator. Timer device can be programmed to do various things - it can count upwards and downwards, compare counter register to some value. For example it can create an external signal and start counting from beginning when counter register is at some value. This way you can configure timer device to create such external signal at constant interval that is much lower frequency than oscillator. This signal can be then used as an interrupt event for a CPU. Note that oscillator could be used directly instead of timer device. What differentiates timer/counter device from oscillator is that it can be programmed. So you can think of timer/counter device as a much more sophisticated oscillator. 

and then your host starts listening. Now the sensor will be transmitting it's data by changing the value from low to high to low and so on. If the bit to be transmitted is , the high state of the pin will be longer, if it's , it will be shorter. So what your code is doing is to probe the value in a loop and watch if the signal level changes, counting number of loops that the signal did not change. This way you know for how long it was in the last known state ( variable). This counter is then used to check if the bit that was send is or (check answer to 3rd question). If the counter value get's to 1000, however, the loop will brake and data reading will be finished. This should happen before bits where transmitted but this value is a safeguard if something went wrong. Second question is a base address of memory mapped peripherals in family of chips. is part of this family and it is the used in RaspberryPi. So this is an address of memory where hardware registers that are responsible for controlling peripherals (like GPIO) can be found. You can find this information in the datasheet ( section). is an offset to a specific peripheral of your interest - the controller. Third question The code is quite simple but it is strangely written: 

There was a change in the firmware/kernel recently, that enabled kernel CPU frequency scaling. Now, you don't set static CPU frequency in config.txt, you set maximum frequency. If your system is on load, it will change CPU frequency to higher value (it is called , you can see the setting in your log line) but if your system is idle, it will lower the frequency to the minimal value (by default it's RaspberryPi default values - 700MHz for ARM, 250MHz for core, 400MHz for SDRAM). It will also lower voltage if you are using overvoltage settings. By default frequency governor is used. You can change default values (used when idle) with , , , and options in . You can also disable this behaviour and return to what it was working before this change was introduced to firmware with in your config.txt file. This way CPU frequency scaling will be disabled. There are also two more changes when (which is default default): 

Debian distribution only contains version and this is the one that you have installed using command. Now is trying to import which only exist in version of the library. And indeed, website states that it need's 1.0 version of pyusb. This is why you're having the problems. So in order to use you need 1.0.x which is not available in Debian so you can't install it using apt-get. The easiest solution to this problem is what @Stevelrwin sugested - using will install 1.0.x branch of pyusb. You might want to use if you don't want to pollute your system with some libraries not coming from Debian packages. 

If you do this, bootloader will ignore the file (except from option which can be used to disable this feature) and will try to boot (if available) instead of . Default has special emergency build in and it will boot to this busybox based OS so that you can fix the problems in your OS manually (or change kernel boot parameters to run runlevel 1 at next boot). Remember to run before powering down since or commands may not work. 

First of all, remember that software for RaspberryPi is in early state of development and there are a lot of problems with it. They are worked on all the time but still, it's not yet as polished as it could be. Currently RaspberryPi is more oriented to developers than to normal users. It was never designed to be media center it just happens to be possible to use it like that. So a lot of people are running raspberrypi as media center with success. However here are a couple of glitches you may encounter: 

The only problem is getting command working on ARM. And unfortunately this is not that trivial. You can read about how to do this (and download a binary that should work) on XDA forum. 

Run and answer some questions (it should be ok to hit enter in each question leaving default answer): 

Most of the issues mentioned above will be invalid after some time as it will probably be fixed. But this may take some time to get there. To sum up - you asked if it's powerful enough. I believe it's not a good question because it's not really power issue here. Hardware is powerful enough (if you can transcode everything to h264) but software is not mature enough and has some glitches. It may not be simple enough to get it working without problem and this is what you are looking for. So my suggestion is - if you plan on learning something about Linux, embedded devices, multimedia etc and are willing to spend some time reading about that and experimenting and having working multimedia device is only a bonus, Raspberrypi will be good choice. if all you need is multimedia player, buy something else, some finished product designed for this purpose. 

Now the pins should not be used by the system and you can use them I²C pins I²C pins have on-board 1.8k pull-up resistors installed. They can't be disabled. This limits those pins usage in some situations (but can be handy in others). Additional solutions If running low on GPIO pins, you can sometimes easily extend it's number by using some additional (but simple) hardware. For output for example, you can use or (also called `I²C bus expanders), both easily to buy and use. You can find example of it's usage here. (or similar from this family) are so popular that there is a ready to use kernel module that handles all the communication for you (it's not enabled in the official RaspberryPi kernel, you will need to compile your own kernel to use it). The module is called , providing that you loaded it with (along with I²C drivers) and that you have the chip connected to bus, you can activate it like this: 

AFAIK there is no driver in Linux. There is, however, directory, which makes very similar case. But that's only one way to interface with GPIO on RaspberryPi. The other one is to bypass Linux kernel drivers and talk to memory mapped hardware registers directly. Some libraries/applications can only use one of this methods while others can be configured to use either of them. Let's consider both cases. Linux driver As already mentioned, Linux driver exports directory where you can find couple of files and sub directories that you can use to control . By default the directory and it's content are all owned by and and only root can write to them. This default setting is reasonable since if you have direct access to GPIO pins, you are able to directly interface with external hardware connected to them. In Linux, the usual way to talk to hardware is using kernel provided drivers instead. So it could be a security hole if someone could use GPIO pins directly (for example before the driver is loaded). Also it is sometimes possible to break the system when directly using GPIO pins - on RaspberryPi it is possible to disconnect Ethernet card this way, for example. That being said, there is nothing that stops you from configuring you system so that this directory is writable by some trusted users. You can also pre-export some individual GPIO pins and allow them to be writable by any user. It's just not enabled by default because of the reasons I already explained. Directly interfacing hardware registers You can also use GPIO using it's hardware registers (this is what kernel driver is doing for you) which are mapped into memory. In order to do this, you need raw access to whole RaspberryPi's memory. There is a driver for that in Linux - it exposes the memory by file. If you have access to this file, you have access to whole memory, including every memory mapped peripheral in your system. It is also only available for root by default since it is very insecure to give access to the memory to any nontrusted user. Having access to the memory means you can access to all kernel data structures so one can easily bypass any system security. Again, you can configure your system to allow other users to access this file but it is much more insecure than giving access to the directory.