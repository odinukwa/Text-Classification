You are building a lot of intermediate sorage that you don't really need, as you could simply iterate over both dictionaries simultaneously. Using the method of dictionaries (or if you are using Python 2.x will also save you a bunch of dictionary look-ups: 

That was tricky... Actually, your blocks are pretty irrelevant, apart from getting the right slice of to do the with the corresponding , so I went the easy route of creating an array as follows: 

and that subsequent rows can be filled out by initializing them to all zeros, and then use the adjacency graph to add the values at a given column of the previous row, to all the columns that are successors of that one in the graph. Once the array is fully filled out, the sum of the last row is the total number of numbers that can be created. Because we only care about the sum of this last row, and each row only depends on the previous one, we only need to keep two rows of the array in memory at a time. Putting it all together into code: 

You should profile your code, to figure out what exactly is it that is slowing your code down. It's hard to tell without some actual measurements, but my bet is on your calls to and , as the method is notoriously (very) slow. For some operations there is really no alternative, but for addition/subtraction you can use . The transformed code would look something like: 

This implementation may be semantically wrong to your example BUT it does not hide important information. Doesn't matter if my guess was wrong or not. The missing type information makes it hard for others to really help you. The only artefact I was able to use to identify your intention was the variable name "this.variables". Any other suggestion would be reformulating the statement without knowing about any general design issues. 

My advice is to make rare use of the Optional-construct. It may make the code look "cleaner" and surly "shorter" but it brings a false sense of safety. BTW less code is no metric to follow. I would come from the other side and ask questions like: 

... have a look at the state pattern: $URL$ This is a perfect example for usage. Avoid enumerations for state representation in the sense of a state machine ... think about the transitions and start conceptional with a state chart ... avoid redundant and overlapping code fragments like booleans that can be derived from the TaskState itself ... to keep the state CREATED as an indicator for what the name stands for and make the difference clear to the state READY 

Object scope You should introduce object scope. Your source code gains flexibility through the possibility to to apply abstraction, polymorphy, inheritance (Open Closed Principle). Your code will be testable much more easy. Furthermore in JAVA 8 you can make use of functional interfaces. That would not be possible in a static context. Constants As "bracketMap" is a constant you should declare it "static final". Then you will get rid of instantiating the HashMap every time you call "validateBracketPairs". break, multiple return (and continue) Avoid those statements. Using them you hinder yourself to make use of applying refactorings like "extract method". Within a loop you spread your breaking conditions all over the place. That makes the code less readable an maintainable. All breaking conditions for a loop should be at one place, the loop header/footer. For methods that have to have a return value try to have only ONE return statement at the end. for-loop The for-each-loop is not the appropriate loop for this case. Consider a loop type that allows breaking conditions to have a proper place to put your go-on (breaking) conditions: As long as there are characters to process OR you not found a validation error. switch-case The switch case statement can be simplified through the standard if-then-else. Use the keys() and values()-method of the bracketMap to check if they contain a character. Now you are able to extends bracket pairs through putting them into the bracketMap without touching the if statement anymore. (Single Responsibility Principle). Naming Because bracketStack only contains open brackets it should be mentioned in the name: openBracketStack. Code So I would end up with something like this: 

There are some major issues with your approach, the major one being that it is going to terribly break down for really large numbers. But if you want to go with it, here are a couple of improvements: 

Note how the initialization of and spares us from having to check if we are at the first row or column, which I think makes the logic cleaner. I am also a big fan of over iterating over a range and extracting the entry via indexing, but YMMV. 

Notice especially how the magic number (which would be in your code), gets named for the code reader's benefit. Also, since you are looking for the largest possible value, it is better to iterate from large to small values, and break out of loops early: 

If you wanted to really streamline things, you could get rid of the list altogether and keep a running sum while building the sequence: 

Before streamlining the code, it almost always pays off to streamline the math. The you calculate is the dot product of two vectors, and , so we can rewrite it as 

Memoization is one of the poster childs of function decorators in Python, so an alternative approach would be something like: 

You still have three nested loops, so this is unlikely to be very fast, but it should improve over your code, both in performance and memory use. 

As I said, you'll need to test it, but I wouldn't be surprised if this little change makes your code 5-10x faster. 

... separate the technologies (Spring service, Spring DI, Spring task scheduling) ... ... introduce a model ... ... make the services depend on the model (observer mechanism) and not on each other ... 

You have to consider that using Spring is like playing with lego bricks. Spring will force you into a corset of for most usecases "well-defined" interfaces and dependencies if you want to reuse already existing functionality. Your task is to chose the right elements out of the toolbox and use predefined implementations or provide custom implementations under Spring interface contracts where you need them. Finally you configure the implementations to use in the predefined dependency graph as Spring provides it. All I mentioned you have done. Everything is adapted to the interfaces Spring forces you to use in a minimal way. Following suggestions I have, but that are small concerns: 

Documentation Documentation is overestimated. The only truth lies in the executable parts of your source code. The way code emerges the same way documention has to emerge and that is an experienced problem. Often these elements diverge when development goes on so documentation begins to lie about the things happening in the executable parts so it confuses more than it helps. Documentation often becomes an alibi for bad code. My suggestion is as soon as you are dealing with interfaces you should learn how to write JavaDoc for central interfaces that define the development responsibility borders or system borders. So source code should consequently be documented at those borders. Sometimes it is necessary to give an inline hint what is the intention. But most of the time your code should express exactly the requirement so no further documentation is neccessary. But why I am talking so much? It is because you should not create comments like "This loop prompts user to give a value for 'x', time in minutes" if the following loop prompts user to give a value for 'x', time in minutes. Naming We have several mechanisms to make complex things more ascertainable without falling into a delusion of documentation. One very important thing is "Naming". From some occuring names you are not able to evaluate a meaning. If you translate "x" for the user during output to "time In minutes" why not simply name the variable "timeInMinutes". Another problem is the abstraction level of names. Often abstraction levels are mixed. That relates to control flow and names as well. Your "validReply" can be evaluate to a lot of meanings as reply is not very concrete. But you are handling a concrete case: a (maybe very optimistic) validation if a "time in minutes" was successfully entered: "hasGotValidTimeInMinutes" for example would be a variable name of the current abstraction level. Modularization To make a developers life easier you should not flood your brain with information. Keep your stack "small". Your main-method is NOT small. Asking for "timeInMinutes" is one part. Asking for "Are you sure?" another. Those things can be viewed separately with "timeInMinutes" as the only connection to "Are you sure?" Modularization can take place variously. In your case I would start to "extract" a method. This is a typical IDE supported operation but you also can do it by hand. You should watch a video on youtube how to do this for the IDE you use. For your "timeInMinutes"-loop where you get the time in minutes you should mark the whole loop and perform an "extract method" refactoring operation either with the help of the IDE or by hand. The name of the new method should be something like "getTimeInMinutes". You should slice the main-method into several other methods each method doing on well-defined thing. What we are doing here is applying the so called single responsibility principle (SRP) in a very basic way. The main task in SRP is to achieve a 1 to 1 relationship from a code fragment to a responsibility. Things that belong together should be together. Things that do not belong together should be separated. You should continue to extract methods and separate the responsibilities. Method local variables Currently you are using the variable "validReply" only within the new method "getTimeInMinutes". So why removing it from the global scope and declaring it locally in the method. Why should we do that? Currently you know that the variable "validReply" is only used by this code fragment. But other developers hav to evaluate that Their mind have to process much more information to identify this relationship between the variable and the algorithm. Their mind has to hide other global variables and consider them as not relevant. In those small scenarios it is less a problem. But in professional software development with thousands of classes maximal neccessary scope of ANYTHING is the Holy Grail. So put your variables in the scope they are needed but keep them as hidden as possible. The "validReply" variable should be declared within the new extracted method. Encapsulation Here we mean that things have an inner state and an outer state and the inner state is totally hidden to us and our efforts to directly modify it. If we take the new extracted method as an example. It is currently not well encapsulated. The variable "x" or now "timeInMinutes" can be easily modifed by other algorithms which is called "side effect". We should introduce a variable with the same name (timeInMinutes) in the new method "getTimeInMinutes". Furthermore we will introduce a return value and assign the returned value to the gobal scope variable "timeInMinutes". We now successfully improved the encapsulation of the method. It is not perfect but it will do the job. Now I want to show the final result of our refactorings: 

Your code doesn't actually work for some tricky corner cases. Take e.g. . It should be pretty obvious that is the proper answer, but your code returns . To build a working solution, let's leave the circularity out, you have already figured how to get the result for a circular array running twice over a linear array. As ususal with DP we will consider the array incrementally, and in an array we will store the value of the maximum donation from the first neighbors when the -th neighbor is one of the donors. It is relatively straightforward to see that then: 

At the heart of your problem you are trying to solve a single linear Diophantine equation. Because 3 and 5 are coprime, their greatest common divisor is 1, and hence your equation, \$3a + 5b = n\$, will always have an integer solution. It is easy to check that \$a = 7n\$, \$b = -4n\$ is indeed one such solution. Of course you want both \$a\$ and \$b\$ to be positive, so if we take the more general solution to your equation, \$a = 7n - 5k\$, \$b = -4n + 3k\$, and impose \$b \ge 0\$, we get \$k = \lceil 4n / 3 \rceil\$. Let's put this into a Python function: 

What your code is doing is typically described as merging both lists. The word union sounds like the set operation, where repeated values should appear only once. Assuming your interpretation is correct, you typically want to minimize the amount of work done in the inner loop of any algorithm. In your case, this is typically done by not handling the items of one list once the other is exhausted inside that loop, but afterwards. Also, the typical way of merging is that, in case of a tie, the value from the first list goes into the final list first. This is mostly irrelevant for your case, but it is a good habit to write these things conforming to that norm, so that if you ever find yourself writing code for an indirect mergesort, you willt be less likely to make it non-stable by mistake. 

The builder pattern has only one assertion: It doesn't matter how many arguments you passed in, it will always build a consistent object. Avoid multiple return-statements Return-statements are structural identical to goto-statements although they are a formalized version. What all goto-alike-statements (return, continue, break) hav in common: They are not refactoring-stable. They hinder you to apply reforings like "extract method". If you have to insert a new case in an algorithm that uses break, continue and return-statements you may have to overthink the whole algorithm so that your change will not break it. Avoid inexpressive return values You may see return values like true/false to indicate something has been processed well or not. These return values may be sufficient for trivial cases in trivial environments where less exceptional cases occur. In complex environment a method execution may fail due to several reasons. A connection to the server was lost, an inconsistency on the database-side was recognized, the execution failed because of security reasons... to name only the tip of the iceberg. There modern languages introduce a concept for "exceptional" cases: Exceptions. E.g. you have following signature: 

Simply said: You mastered the decorator pattern. But: You have a misleading semantic. The application may be proper, but the usage ist not beneficial. Any pattern identified has its inherent semantic and you have to analyze if the pattern matches the semantic you want to apply it on. It can even be, that there is nothing like a pattern. In your case I would consider not to use a decorator pattern. I Think you have only simple associations.