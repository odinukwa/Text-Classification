Avoid repetitions of code Whenever you repeat your code you need to look into whether it can simplified. The key thing to look for is where does the copied code blocks differ, and can you extract those differences into variables or similar. In your case this should be rather simple, as what varies is the major loop counter, i.e. , or . In addition you need to know which day of the week you're starting on, and when to add the newlines. The latter can be approached using the modulo operator, , with a proper offset related to the day of week. Some style comments Here are also some style comments related to your code: 

Do however note that I don't recommed the variable naming, and the lack of comments on this code. According to Rosetta code this should be faster than a version based on , but I currently don't have time to run time verification on that. 

Your questions Pushing is not possible You are correct, and this is a good reason why you shouldn't use magic numbers like . Some options exists to fix this issue: 

Some new(?) constructs I'm not sure if you know these already, but there are a few new constructs I would like to show you: 

Here is the code modified for running a given number of times, and as it turns out only around 3000 times is adequate to get a similar figure. How many times you need to run it does depend on the velocity of the different object and turning rate (like when ship sling shots around the moon or earth). The timings gets quite a lot better, of course, when reducing from 2.5 millions steps to 3000 steps... The and files are as in my other answer. File: 

And if using Python 2.x you should use as it doesn't generate the list, but uses a generator, which in turn will save you some memory and gain a little performance for large \$n\$'s. Code review You don't need a list comprehension to initialise all the off-diagonals values, you simply multiply it. With new variable names, and a docstring your function could look like: 

Lets have a little style review, before some code refactoring, and finish off with some performance comparison. Style and code review I suggest you read up on PEP8, which is the official style guide for Python. 

I'll end this hasty review with a very useful construct which could cleanup your code (when you've created functions): 

The code looks OK. Linq can be somewhat tricky to debug, as there is some magic happening behind the scenes. In my world that still doesn't warrant to rebuild it into somehting else just for debugging for a random case which you don't experience just now. Don't worry too much for problems which hasn't occured yet. Some say that worrying beforehand is double trouble. Firstly you worry before you've got a reason to worry, which is unneccessary. Then secondly, if you don't experience the problem, you've worried without a cause, and if it actually happens you get to worry all over again. In short, don't worry until it happens. That does not say that you shouldn't write readable and maintable code, with good tests to test the various cases which might trigger variants of your query. I.e. you should make tests with various counts of parameters, to possibly trigger the RDBMS/database driver. A test destined to fail in a predictable manner, can still be a good test. And you should have tests displaying that the partioning is working as you expect. 

Another similar optimisation is that you change the array, , and then join it at the end, this complicates matters also. If possible, try to use list comprehensions, i.e. . This makes use of a function to encode a given character. The encryption and decryption are quite similar, so I suggest joining these into one. You'll also have a bug in your code, related to how to find the key (or offset) to use when decrypting. Trusting that is the most common character is at best dangerous. It is better either to include it somehow in the file, or let it be a shared secret between encoder and decoder what the offset is supposed to be. One safer option, if you don't want to have a shared secret, could be to use the length of the first word, or to insert the key as first/last character of file. But depending on frequency of a given character is not a good solution. Using better variable names is also good practice. Avoid single character names for anything but loop indexes like (and possibly for a character). Making use of predefined tables are also a benefit you can take advantage off. The final note, as some other have commented, is to make use of the syntax for opening of files to help encapsualte file reads and writes in a nice way. Revamped code Here is my revamped version of your code, complete with an example of encryption, decryption and comparison of the file. Has left a commented statement, if you want to see the line read, and encrypted version of it. Just for the fun it, I also added in the character classes of digits and punctuation, to further scramble the encrypted file, and if a character is not in any of the character classes it is kept as is. Here is the code: 

Let us start with some code review, before improving the performance, and finish off with a comparision against the original code. Code review As a gesture to us reviewing your code, it would have been nice to know which modules where external to a default installation, as I had to plunder a little to install the and module. However I got thing up and running, and then I looked at code and found the following: 

In your update you state that also updates other properties, in other words you are causing a ripple effect if updating this property. That is bad! The best way to handle this, in my opinion, is to use some variation of letting dependent properties subscribe to change notifications. This could be the same as the externals get access to, or you could make an internal variant in addition. Another way of handling it is to reconsider your properties, as properties are commonly supposed to be independent of each other, or a calculated version of other properties. That is you might need to change the getter of the other property thusly removing the need of as it now is a calculated property, or you could remove the dependency by refactoring your properties. In essence, No, it is not good to call methods which has side effects unrelated to the specific property of your setter! 

So this is not the typical code review, as the code in question is pretty basic in terms of what it does. It is a given algorithm, and you need to do the given operations. The one possible varying factor is the lines. Can this affects times? Let us test the random generation of some numbers using various random generators: 

The mod-version is your code, but using . The org-version is your code, modified to use . And the last one is mine version. Notice how the time of my version doesn't grow as fast as your version due to not testing each and every number. Also do note that it could probably be even faster, if I implemented some memoisation (or similar) to avoid retesting whether all rotations are prime numbers. This effect would increase the more digits in the candidates there are. 

In python it is common to name variables and functions using , so I would suggest calling your variables stuff like and . Your solution is destructive in the sense that it modifies the original lists, which usually is not a good option. So here is a solution which firstly as long as both lists has elements it picks the lower element. This accounts for the part of the first condition in the code below. Secondly when either list empties out, we need to empty the list with more elements. This accounts for the of the condition. If only has values, the is also , and it enters the first part, if however, it goes to the part. Just as expected. The resulting code, which doesn't modify the original lists: 

You can choose between having on separate lines or not, but I reckon you see how much easier it is too read this last example, compared to your original code. In general, when you see repeated statements consider simplifications In , , and you do exactly the same: 

My first focus is on one method in this answer, and that is the last of the class. I'm leaving the rest for others to review. Let me present an alternate solution based upon your code, and then discuss it afterwards related to your code: 

Don't split reading from same file into different processes I haven't used my self, but it seems like you're a splitting the file read over 30 different processes, where each reads 30 lines each? If that is correct, you should seriously consider a different split tactic, as that will throttle your IO seriously. You'll have 30 different processess trying to read from 30 different places in the file at the same time. A better tactic would be to send each file to a different process, and then let that process handle that file completely. Choose number of processes wisely Another caveat would be the number of processes you use. You create 30 processes, but as long as you don't have a 30 actual processors available you wont see any major performance gain using this number of processes. Back in the days using various Unix based operating systems, we did compilations in batches and the general rule was that we would aim for approx 4 times the number of processors we had available. In other words on a quad-processor, we would aim for 16 processes. Any more and we started seeing congestion due to interprocess issues and IO related performance bottlenecks. Shorten the distance from file to server Another speedup can be found if you are able to avoid network traffic. That is if you are able to run this script directly on the server, so that you can use addresses and local connections instead of using the IP network. Establish a baseline Not so much a performance suggestion, but do you have good baselines for how long it takes to do a typical run using only a single process? This can be helpful, when you start dividing the load according to other metrics, to compare when you reach a threshold regarding what each server/client should do. 

If modifiying to include the opacity suggested by Gabor, one can use the concept of a base color, and with some slight justification to the base rotation, and implementation of the down-and-up scheme, one gets the following snippet: 

This would enforce a default cleanup at end of script, unless abnormally terminated, and still allows for the use of or the decorator . And final recommendation, is to use class encapsulation for a larger project to hide the actual pinout allowing for a better focus on the higher level functions of your script. 

Extend to translate both ways A natural extension now is to extend it so that it can translate both ways. In addition to the function, I would also make a function so that you can make functions which can choose which way you want to translate. Look into unit testing and/or doctest Another possible extension is to add testing of your methods, to ensure proper translation and handling of different cases. Loads of alternatives exists, but I'm going to point you towards unittest and doctest. Both of these are included in vanilla Python. The former can be useful for slightly more complex cases, but I've opted for doctest in my review, as it has a nice side effect of displaying with the docstrings how to use the different functions. Doctest can be invoked on your module in a variety of ways, but the two versions I've been using the most are either to call it direcly from the command line using or through calling a simple function from the main code. The former doesn't require anything besides the actual docstrings, and if you use you get to see every test it performs (and not only failing tests) and the summary. Try it out with code below, and change some of the stuff related to lines, and response on following line. Make useful I know I was the one proposing the function you're using, but now that it is maturing, I would make it into a loop asking for which language to translate to and text to translate. This way you'll get a meaning full script to run, in addition to a meaningful module to use. Note how I used a little trick to 'alias' if in Python 2, so I wouldn't need to do the all over my script. Consider also looking into an extra module handling Python 2 and Python 3 like the six module. Revamped code Here is my version implementing all of the above suggestions: 

I do break standard naming conventions here, to add a little more readability to my names. In the class names I use double underscores to separate class name from method name. And in the test names I use double underscores to separate input conditions vs expected output result. Usually I would also run my unittests with increased verbosity so that I'm able to see all the succeeding tests as well as the failing. This could be a matter of personal preferences though. Comments to implementation 

Your code doesn't handle names with spaces within, nor names with characters that are illegal for URL's. To accomodate these two issues, you could use something like: 

I'm agreeing that it is bad practice, and that you should use exceptions to indicate error situations. Letting exceptions propagate including other levels of detailing sub exceptions, seems like something you'll loose control over quite soon. I would rather extend the different functions to return the needed information either directly through function returning result objects which could hold the detailed information needed at the top level to determine the causes. You would then collate, and keep on returning more information up the chain. Or you could implement a message queue where the delegates publishes messages regarding discrepancies onto the queue, and you have a central subscriber collating all those into some sensible report to present at the end. This would be especially useful if you are talking about higher level parallell algorithms, but might be overkill for a simpler system. It does however have the advantage that code at any level, could post a message and it's kind of separate from the code logic elsewise. 

Using a table here is the right choice, however I would put the total into a group where you can address its formatting needs specifically. In addition do use to collapse columns in the total, as well. 

I'm not surprised it is slow. You should really reconsider how you are processing your files. You would most likely get a major speedup if you could switch the loops around and have the -loop as the main loop and not read it entirely into memory. This would allow for the rest of your code to accelerate. And at the same time move the blocking rules to the inner most looping level. Simplifying your immense structure would also most likely help, as you actually seem to do about the same in all of the branches. Ugly restructure attempt I started copying out similar blocks out of your original code, into make-shift functions (which won't work due to variable scoping and such). Doing this I found the following make shift functions to exist: 

Lots of alternative and partial rewrites have been given already. In this answer I'm going to try to focus on the strange mix of static vs non-static methods and variables, and badly named methods and variables, in addition to proper signature of methods. At the end I'm going to present an alternative version, which might not be optimal with regards to using streams and other new-fashioned stuff, but it should work, and hopefully will illustrate some of the stuff I'm commenting upon. Code smells in current code When reading your code I react to the following code smells: