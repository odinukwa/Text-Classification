If you're looking for spherical to cubic projection, this site seems to have an answer. It looks like HDR Shop has some panoramic transformations that will work for this. Additionally there is at least one Photoshop plugin that will do this. 

Most perlin noise algorithms will allow you to retrieve the noise value at any given location, with something like . This makes it fairly trivial to generate noise on a chunk by chunk basis. All you need to do is pass the global position, instead of the chunk position. 

This is simple, create a object for each chunk, using that chunk's position as the seed. If you think of as a really (really) long series of numbers, the seed is just where to start iterating through. So, if you always set the seed before generating the chunk, you'll always get the same integers, in the same order. EDIT 

Here, , , and make up the four corners of a single line segment, just like the green dots in the image above. These vertices would be added to the mesh, and you'd also add the indices to make the four vertices into two triangles (so, six indices would be added, a-b-c and b-d-c). This can obviously get rather complex. I believe another reason Unity implemented their LineRenderer the way they did was because doing it that way avoids another problem, corners. When you start drawing each line segment you'll start to see where the two line segments come together and form an ugly joint. There are ways to deal with this by calculating the shared normal between both lines and updating their vertices to the shared normal, but this only partially solves the problem, since you can still easily end up with pinched lines. The most robust solution is to generate additional vertices at the joints to act as corners. 

Assuming Pluto for the "edge" of the solar system (though some say it's as far as 3 light years out). Pluto, at it's maximum orbit is about 7,376,000,000 kilometers from the sun. That's 7.37600 × 10^14 centimeters. Double that to get the diameter and you'll get 1,475,200,000,000,000 centimeters. That's well within the maximum size of a 64 bit long. Since the height of the solar system is negligible compared to its diameter, we can ignore that. So yes, you could use a long to represent your position in the solar system. In fact, you could have positions out as far as 9.75 light years with an signed long (double for unsigned). Note that this is not the case for finding distances. The maximum distance you can find is the square root of the maximum distance you can travel to. This can be overcome by using a level of detail system for finding distances. You can do some simple checks to guess how far away the distances are (compare their x values and y values), then use 1,000,000 kilometer increments for large distances down to centimeter increments for small distances. Of course there's the question of, do you really want to? 99.999% of the solar system is totally uninteresting empty space. If you're accurately representing the solar system, I sure hope you're not accurately representing the physics. It takes a long time to get around the solar system. Way too long for most people to stay interested. And why even have such fine accuracy unless you're also going to model the objects in the solar system with that accuracy? That's where you'll get into trouble. The volume of the sun is 1.40900 × 10^18 cubic kilometers. On the cubic centimeter scale, using a single bit to represent that that space is "occupied" takes up 1.4 × 10^33 bits or 1.6 × 10^23 gigabytes. I think you don't have that much RAM. 

Place a breakpoint on . When it breaks check the values of , , , and . See which one is the problem. Is ? Does ? When the debugger breaks, you can see the call stack. The call stack will show you all the function calls that have lead to this function being called. The debugger is just about the programmers best friend. The sooner you learn to use it the better. See this post I wrote for more details about debuggers. I'm assuming that is null, since I see from your code that the other values are correct. Look in the code an see where gets set, then you'll know what you need to do to set it properly. 

And use these inside the while loops of the Translation and Rotation methods. For example, inside the Rotation method: 

Take a look at the pawn events, specifically the event. These are very similar to the actor events. So you can extend the pawn and override to do what you want. Also, I believe you can access it through the UI as a pre-compiled event in Kismet. 

There are a multitude of ways to represent and implement entity component systems, but here is an explanation of one way. Keep in mind there is no concrete definition of entity/component/system architectures, so this is just one implementation. I'm going to introduce an analogy for entity/component/system architectures that might help. Let's think of an entity like a key. The Entity 

Now to add more precision, simply add the values to the direction enum. The algorithm works by checking increasing values around the compass to see if our angle lays somewhere between where we last checked and the new position. That's why we start at -PI + increment/2. We want to offset our checks to include equal space around each direction. Something like this: 

The only downside to this is pressing the backspace key, still causes the input caret to move backwards. This is a fairly minor downside though. 

As for making a difficulty curve, there's really no correct answer. It's going to take a lot of playtesting and tweaking to get it right. It'll depend on how long the game is supposed to last and how difficult you want it to be. I suggest you use Excel or a site like WolframAlpha and see what kind of curve different functions create. Try exponential increases, linear increases, etc. Find one that works for you. 

There are a number of approaches to marketing and getting your game more widely known. There isn't any evidence (as far as I know) of any strategies that effectively convert pirates into paying customers. So, if your intention of doing this is for marketing, then sure, it's worth a try, but if it's solely an attempt to convert pirates, you're not likely to have much success. 

Then you set by dragging the object from the hierarchy into the inspector for your trigger object, specifically the field of the script. Or, you can set in the method with the method, but I'd recommend against it. Setting the in the editor is a cleaner way of dealing with this and doesn't hard code strings into your scripts.