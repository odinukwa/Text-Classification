I have a SpriteFont in XNA, which has the standard 126 characters that are usable. However i would like to use the "à² " symbol in the game. So is there anyway of adding just a few more symbols that the spritefont accepts? Cheers, Randomman159 

OpenGL stores its model matrix and view matrix together. As far as i know, you can't separate them once they are together. To solve this, i simply ended up storing my own model matrix, which i then used GL.MultMatrix() to combine with the view matrix when it came time to draw. To access coordinates all i had to do then was to get M41, M42 and M43 (x, y and z) from the model matrix, and to get offset coordinates for a box, creating a translation of the offset of each vertex gave me the new coordinates of each respective vertex. 

The left is wireframe, the right is the finished image. For some reason a bunch of the triangles aren't being shown. The project is in C#, using OpenGL (OpenTK). I'll provide more information if neccessary (such as code), but there's a lot of code, so i'd rather check if anyone has a simple solution first... Please comment if you need more info though. EDIT: Here's the buffer code if it helps... 

Sorry codeless answer here, though hopefully you will find quite useful if you can bothered writing the simple code to accompany the technique. This is a technique i use quite a bit in platformers to handle slopes. I call it the "5 Point Collision" technique. 

Checked the .obj loader, there was a flaw in it so that it didn't correctly load in quads and split them into triangles... It split quad ABCD into ABC and BCA instead of ABC and ACD Sorry, thanks for all the attempted help though! next time... I'm writing my own importer :P 

I end up with the teeth of the model way out from the body, and the eyes expanded so large they stick out the sides of the model. Could someone tell me what i am doing wrong? Or is the model the issue? 

This really depends on two things. One - Is your box axially aligned? (ie. Is there a face pointing up, down, left, right, forward and back, or is it rotated ?) Two - Are your points at all sorted? If you are using an axially aligned box, you can skip this first step. Work out a Quaternion which defines the rotation of the box. From now on, when I refer to a point, I am talking about the point after being rotated by this Quaternion. If you have any difficulties with this step, google it, Quaternions are a big topic which I'd rather not go into unless you need more info. Next it's pretty straight forward. Loop through the items and work out if their x is more than the box.minX and less than box.maxX (as with Y and Z). If this is true, then it is within the box. There are a few ways you could speed these up, if your points are sorted in such a way that allows you to conclude at some point, that no more of them will be within the box, you can skip out. For example, if the box is at the origin (0, 0, 0) and your points are sorted in distance from the origin, it will reach a stage where you can conclude that all points left in the list are too far to even both doing checks, and therefore can break out of the loop. Really there's no extremely fast ways of solving this problem when the points are stored in simply a List. TLDR; minx <= x <= maxX && miny <= y <= maxY && minz <= z <= maxZ. Google Matricies and Quaternions, possibly Octrees too. 

Try the game maker community, gmc.yoyogames.com They have quite a few good pixel artists there, quite a few who also will animate. The downfall is that you have to be very selective about who you pay, because the range of people who say they are "good" ranges all the way down to 8 year old noobs. However one major benefit, is that for individual pieces of art, you can tend to post a request and get half a dozen to choose from, and payment is very rarely required. 

Yes, this is extremely common. A major problem a lot of people face is an unbound texture being applied to a line accidentally, or having GL_TEXTURE_2D enabled, but without a texture, in which case the line is always drawn black (no texture = black = 0, (black(0) * given color = black(0)) There is nothing inefficient as such with your code, though it is usually a wise choice to try to avoid switching unnecessarily. (eg. if you were to have to draw another line as well, don't constantly enable/disable, instead do it all in between one disable and enable). Hope this helped. 

As jhocking said in the comment, FOW is unknown areas. Computers can't draw infinite terrain. The lag would be incredible. Fog is used to blend in the edge of the render distance, which doesn't need to be close to the camera, nor does there need to be a large blend range. You sound like you are thinking of a very short view range. Increasing your view range to a large number (this is set in your projection matrix), and sticking fog at the end, makes it seem like an endlessly shown terrain. And the fog isn't really that noticable. However if you still want a precise answer to your question, Weather, such as rain, snow, wind, etc. can help obscure the out of range area. Terrain which reaches the clouds... Having mountains in your terrain, then having clouds at the top of the world, means that in the distance, you will find the edge of the world hidden by mountains, (or if your high up, clouds). Finally, if your really desperate you could stick a curve onto your world, so that it appears that things in the difference are disappearing over the horizon. However i still suggest you use fog, as it is simply a blending for the out of range area. 

I've created a map editor for a game I've been developing. The maps (planets) are made using a form of meta ball editing. Basically, in the end the Marching Cubes algorithm is used to get my final model. Here's an example: 

In the game however, when planets are or a largish size, as you would expect, i start having quite a lot of lag. So what i was wondering, is are there any good libraries out there that could be used to remove clusters or triangles that are basically flat and turn them into a single triangle? I'm not after simply reducing the count, I want the same amount of detail, but to merge triangles where their normal is practically the same. Also curious, as to how you would go about having more/less detail as you approach/leave areas of a planet. Obviously chunks isn't the easiest method when the world's a sphere. The project is in C#. 

Generally OpenGL and DirectX are the two most supported graphics libraries. Of course XNA is built over DirectX, however it was not adopted to the expected extent. Now if you are being smart in your development, you should be able to isolate your graphics handling in such a way that by changing only a select few of your files, you can completely migrate from one graphics library to another. I can't remember which Sims game it was, (Medieval i think), but the game was developed with DirectX for PC and Xbox, but then they replaced it with OpenGL for the Mac, Linux builds. I recommend sticking to the more commonly accepted libraries, as to have the largest amount of support. XNA is greatly accepted here at gamedev, however OpenGL and DirectX are both supported as well, both here and at overflow. I was making the same decision around a year or two ago and concluded I would head into OpenGL (OpenTK for C#) grounds rather than staying with XNA for the following reasons: