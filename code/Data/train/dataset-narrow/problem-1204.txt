Use right type names Don't use where other type names are more appropriate. You can use to avoid such issues. I would recommend replacing 

Use instead of just The standard include file is guaranteed to declare . Some also declare but in order to make the code portable, use . Improve implementation You have the loop 

Then, in GameManager.cc, you can define as a or even a . You add member functions that capture distinct functionality and don't have to worry about whether a function needs to be or The implementation of can be: 

Adding as a unit When the time is ready for adding as a unit, all you need to do is create a file with the following contents: inch.hpp 

This resolves both issues. Suggestion 2 The member function seems a misnomer to me. What's being "added" in the function? A better name would be . I would go further and create two functions and . 

Using vs hand crafted function to reverse a string You can reverse a string or part of the string using like you have in your code: 

Other suggestions: Add functions instead of This may be a matter of stylistic preference but I think it is better to use: 

Now, you can reverse regular s as well as temporary s, i.e. s, while paying the cost of making copies only for s. 

is executed no matter what. Also, as has already been pointed out by the other answer, you need to use 

Does not use . Does not use dynamic memory allocation. Does not use virtual member functions. Uses class templates for and . Defines the units in an extensible manner. 

If you have to modify every time a new type of is introduced to your program, it violates the Open/Closed Principle and is a symptom of sub-optimal design. My suggestion will be to make -specific functions external functions and not member functions of . 

in the global scope. I would create a that holds these together and pass the around, starting from . That would remove the need for them to be in global scope. Use an instead of strings for direction Instead of using strings "UP", "DOWN", "LEFT", and "RIGHT" for directions, use an . 

There are more sophisticated ways to handle the bytes and endianess, but I've deliberately kept it simple here. 

Outputs: " and ProdUsers = aaa and ProdFullyOnline = 'bbb' and ProdPrice <= ddd" I had to add some boilerplate code to make the example work, but I think one gets the idea... 

Make the base class meaningful Right now you've declared as a base class, but all it really does is set up your two variables. One way to utilize it more would be to assign a unit of some sort to the class (I've chosen Kelvin, but it could have been anything). In my version, stores everything as Kelvin. Any class that inherits from it only has to know how to convert back and forth to Kelvin (So Celsius<->Kelvin and Fahrenheit<->Kelvin). Later, if I wanted to add operators to add/subtract/compare temperatures, since the base units are all kelvin, everything is easy. You'll also notice that I've moved to the base class and the threshold temperature is in Kelvin. This gives all sub-classes the functionality without having to know anything about where the theshold is, and likewise the base class will always work without needing to know the details of a particular unit of measure. Finally, while I've used Kelvin as the unit for , the base class could have just as easily been called . 

Some Notes The RunWorkerCompleted event may run on the background thread (or you may get errors about it) and we don't want that. First, any updates to the UI, like updating the progress after a block is written, have to happen on the main UI thread. Secondly, we don't want multiple threads trying to write to the output file at the same time. There is a simple trick to get the RunWorkCompleted event to run on the main UI thread. 

My Thoughts I haven't profiled any of these, but I'm going to assume speed is not a priority. I like #2 the best. It is clean and simple, and easy to understand what the code is doing at a glance. I think #1 is ugly, and the sequential array slicing makes me nervous and seems easy to break. If your number sizes change at some point in the future, this one would be the hardest to modify. I think #3 is better, but not as clear or concise as #2. 

Don't assume file IO succeeded Always check status of file IO operations. It's never safe to assume that they succeeded. Change the lines that read the input to: 

Make a base class You can simplify the code in a few places by making a base class and creating two sub-classes: and . Refactored Program 

in yet all the functions to which you are passing those values -- , , -- have arguments of type . I suggest changing all of those to be of same type. A better type for them would be . Then you don't have to worry about dealing with negative numbers. It is possible that a user will enter numbers too large for the purposes of this program. To deal with that eventuality, provide the users with appropriate feedback about the maximum admissible values. For example: 

you allow multiplication of matrices that don't result in a square matrix. However, if you multiply the following matrices with just that change, 

This will work only if you declare the function a friend of the class. Move parts of the class to the bottom The users of the class care only about the section of a class. Hence, it makes sense to put them first in the class. The section of a class are, to a large extent, implementation details. It is better to put them last in a class definition. 

is not right. can be executed first, last, or anywhere in between. The standard does not specify the order of evaluation of arguments. Also, you are incrementing in that statement followed by: 

That produces a compiler warning from g++: warning: comparison between signed and unsigned integer expressions [-Wsign-compare] I suggest changing that to: 

That will also allow you to print a to any . Use manipulator in the spirit of the standard library Instead of using 

The other point is that you need to move this check inside the subsequent loop. Otherwise, the conditional will always evaluate to false since has been initialized to . Updating Inside the loop, you have: 

Similaly, is traditionally used for C compiler flags and is used for C++ compiler flags. I would recommend changing 

P.S. I have left out the code dealing with angles since they can be updated in a manner similar to distance. Here are the files and their contents: length_unit.hpp 

Don't Repeat Yourself (DRY) Your IsSimilar() function consists of the same code block, twice. Anytime you have duplicate code you should usually either break it into it's own function or find another way of eliminating the duplication. An example implementation removing duplicate code: 

Dom2 was the fastest because it has the fewest number of operations by far. As a weak rule of thumb, when optimizing math, try to avoid BigNum and Float when feasible. Also try to avoid things like converting numbers to strings and then back to numbers. Conclusion Know that more often though, that your slowdown will usually come from lots of branching and flow control, and being inefficient (like calculating the same things over and over rather than caching them), and those are the places to optimize. If this problem were part of a larger, more complicated task, I can practically guarantee that your bottleneck would not be ANY of these functions, but something else entirely. 

already has a mechanism for passing and retrieving arguments. The has a property for a passed in method argument and a property for the DoWork result. The has a property for retrieving the result. No sub-classing is necessary, although you may need to make a custom container if you need to pass/return more than one object. 

Put the workers in a list of available threads. In the main thread, check if there is a free worker in the list. 

On a personal note, I wouldn't necessarily use inheritance as my go-to solution for this problem without a lot more knowledge and thought about the use-cases; I only followed your initial design. Temperatures themselves are fairly trivial, but perhaps for a more complicated scenario this implementation would have advantages. 

Update It occurs to me that there is a little more flexibility in this situation. I have a function, that accepts a the code submission as a string and alters it. Mostly I've been using it to swap out the value of some variables using regular expressions. Here is an example implementation: 

I think you can add functionality to to make the common ancestor search more ruby like. (I can add a search by value later, if you want.) I've added a parent member that is set automatically, and I've added and enumerators to enable easy traversal up or down the tree. Note: Thinking about it, the search function needs a little more work in case node 2 is higher in the tree than node 1, but I am out of time right now. Let me know what you think. Testing indicates that this is not an issue. 

It is inefficient since you can avoid half the work by realizing that if the number is not even, it will never be divisible by 2, 4, 6, etc. Here's my suggestion for an improved version: 

I'll leave the implementation of as a detail. Avoid I would recommend using an overload of . That makes usable with all kinds of objects. It also makes the task of outputting objects of the class more idiomatic. 

In addition to the excellent suggestions by @Jamal... Physical Layout of class The section of a class should appear first, followed by the section, and section should appear last. The reason for that is that to the users of the class, the section of a class is its most visible interface, the section is the next visible interface, and the section is the least visible interface. 

Since these functions are recursive, the check for whether the tree is empty should not be added here. Instead, they should be added in the functions of the same name. 

I understand that the reason for your post is to find a method that will be faster than the one you already have. However, the posted code has the potential to access memory that is beyond the valid limits. For the sake of making a point, let's say that on your platform, is . Your input strings are and . Given that, evaluating will end up accessing memory past the terminating null character of . In theory, that is cause for undefined behavior. Here's my updated version of your function to make sure that you always access memory within the valid limits. 

Suggestion 2: Remove redundant data You are using to keep track of whether a slot is open for placing a marker. You can just as easily use to keep track of that information. If is , it is open for placing a marker. Otherwise, it is not. Suggestion 3: Make a array You are using an array for board simply for the convenience of printing the . The true state of the board is a array. Hence, I would suggesting using: 

Use a better name than I would prefer to use something like or . Update The functions will be problem when is . If you like to use the functions for all types, it will be better to change to a different function, such as . 

Additional Thoughts As janos mentioned, your program has several usability issues. While I've cleaned it up some a little and added better input validation, there is still a lot to be desired. Making the user enter coordinates, especially without adding row and column headers is hard on the user. It would be better to either add headers, or even better, add a guide with numbers and letters off to the side. For example: 

Shorthand if/elseif syntax You can use the keyword in conjunction with and to cut down on the whitespace of your if-eslif chain. The syntax would look like: 

This is built assuming you want no duplicates in the results, since the goal is a little unclear. Quickly Finding Combinations The function you should be using is , which generates an enumerator that yields all combinations of size from the array. Once you have that it is a trivial matter to only select the combinations that sum to the target value. My function here finds all combinations of size 2 to size and then selects only the combinations with the correct sum. 

Break out of loops sooner This applies specifically to your spaceship and to a lesser extent to asteroids and torpedoes. Once the spaceship is destroyed, return. Any other collision checks are wasted processing time. For torpedoes and asteroids, once a torpedo has destroyed an asteroid, break out and move on to the next torpedo. This leaves a small edge case where a torpedo might perfectly hit two asteroids at once, so this decision is up to you. 

Copying the array You are over-complicating the array copy. will copy the objects of the array (but not the object's objects). Using it on array of objects might be problematical, but an array of ints will be fine. 

Some style comments: First, you don't need to put in a class, you can simply declare it and use it directly. Additionally, the ruby preferred style is to use snake_case and if the function is a predicate (a function that takes a value and returns true/false) you should add a question mark to the end: 

They are syntactically equivalent, so choose whichever you prefer, however the second one is more idiomatic than the first. As Paparazzi mentioned, you should use lower case for the first letter on your variable; in idiomatic C#, only classes, property names, names of structs, and enums should start with an upper case letter. Updated: added additional notes on what should be capitalized