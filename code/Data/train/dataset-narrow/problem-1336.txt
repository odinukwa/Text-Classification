So throwing errors is the most flexible method to report errors to the caller. How you throw errors and what information these errors contain can be improved in your code. Let's take the following example: 

otherwise the result is not correct for ranges not starting at 1. With respect to performance: Your function counts all divisors of a number, but 

Your function expects that the passed string buffer has space for characters. A better design is to pass the buffer size as an additional parameter: 

As you already noticed, your code will loop forever if all array elements are , so you have to check first if at least one element is true. If the array has \$ N \$ elements with \$ t \$ of them being , then the probability that a random number in the range \$ 0 ... N-1 \$ is "valid" is \$ t/N \$. This means that the expected number of iterations is \$ N/t \$. For example, if half of the possible directions are valid, you'll need 2 iterations in average. If only 1% are valid, you'll need 100 iterations in average. Here is a possible alternative which needs only a single random number. As I am not so familiar with C#, I'm describing the algorithm only. 

Your code looks correct to me, it does produce prime numbers in the given range. PEP8 Online reports some code style violations with respect to whitespace and line length, but it is not too bad. But: This is not the Sieve of Eratosthenes. The Sieve of Eratosthenes keeps a (single) list of all candidate numbers, and computes multiples of each found prime to mark subsequent composite numbers in the list. Your algorithm computes the remainder of all remaining candidates instead, and creates new lists in each step. As a simple benchmark I ran 

instead of nested for loops and an chain. This makes also the deep copy (and thus the ) unnecessary. The same list comprehension can be used when generating the initial table: 

But what I don't like is that the calculation of the fractional digits is mixed with the conversion to a string. If we define a dedicated class then the two tasks can be separated clearly: 

Performance improvements: Computing the square digit sum can be made slightly faster by using integer arithmetic only, without string conversions: 

Another option would be to attach the segues directly to the buttons and remove the button action methods. Then the logic has to be put into , depending on the segue's identifier. 

On my MacBook, this computes the practical numbers up to 1,000 in 0.003 seconds, and up to 10,000 in 0.1 seconds. 

The first thing you can do is to store the intermediate objects in variables, in order to get rid of the repeated and deeply nested chains like 

There is an error in your function, the result is one too large for a perfect square, i.e. returns 4 instead of 3. Also the loop variable should be a to avoid an integer overflow when testing . A correct version would be 

Note another advantage of the separate function: You can "early-return", and that makes the "state variable" from your code obsolete. If the program is run with a large number of test cases, then a further improvement would be to pre-compute all prime numbers in the given range, for example with the Sieve of Eratosthenes. 

Using a property for the boolean attribute is fine. Properties have many advantages: they encapsulate an objects value (i.e. the actual implementation is hidden from the outside, it need not be an instance variable), they are public (instance variables are by default not visible from other classes), they can be observed (via Key-Value Observing). In the ancient times of Manual Reference Counting they made the memory management easier. In the case of a "simple" attribute that is only used within the implementation the difference is small and (in my opinion) a matter of taste. But if you use a property then you should use the property accessor methods consequently. 

instead of converting the to and searching that as a substring. (But using instead of your own splitting function as suggested in @milos' answer is probably the better way to go.) 

If you decide to use Xcode 7 and the latest OS X SDK at some point then you can use the Objective-C "Lightweight Generics" to specify that the returned array contains objects: 

Your code produces a "plain" PPM file where all sample values are represented as ASCII decimal numbers (separated by white space). As a consequence, a substantial amount of time is spent with formatting and writing the data. An alternative is to write a "binary" PPM file. It has the magic "P6" instead of "P3", and all sample values are represented as a single byte. (See PPM Format Specification for the details.) So you would create the file and write the header with (using a more descriptive variable name for the file stream): 

Yes, that will crash if the function is called with an error code that does not correspond to one of the enumeration values. Better use optional binding with : 

The input lines can contain up to 1,000,010 integers, which means that many temporary string are created. An alternative is to use from the Foundation framework to read integers directly from the string. And since the number of integers is known, we can call to avoid reallocations while the array grows: 

So we need to determine if in the prime factorization $$ c = p_1^{e_1} p_2^{e_2} \cdots p_n^{e_n} $$ there is a term \$ p_j^{e_j} \$ such that \$ p_i = 3 \bmod 4 \$ and \$ e_j \$ is odd. This is more code, but very efficient for for large numbers, because 

This would remove to code duplication completely. Some more thoughts: Creating a date formatter is “expensive,” it is better to create it once and reuse it (compare e.g. the “Re-Using Formatter Instances” section in NSFormatter on NSHipster. This can be done with a static property (which is computed lazily and only once): 

Back to the protocols: Defining a protocol for "Stack" makes only sense if it contains all required methods: 

The next improvement is to use only one counted set: Add the elements from B and subtract the elements from A. Then check which elements have a positive count in the end: 

Note that is not necessary to access instance members. Or use image literals, a feature introduced in Xcode 8. You can simply type the name of an image resource in the asset catalog. This will be autocompleted to , but displayed as the image itself 

This is extremely useful to check the correctness if you changed the implementation. Performance Poor. Your code checks every number in the range if it is a perfect square or not. It is far more efficient to iterate over the possible square roots: 

Here we know what the function is about, what does it do? Compute a happy number, check for happy number, ...? Code structure: The global variable is not used at all and can be removed. A global variable is used to "remember" the argument of the inital call to the recursive function, and the function (as a "side effect") appends to the global array. This is error-prone and not very elegant. I'd suggest to define a function instead, which takes a number and recursion limit, and returns True or False. The default recursion limit can be defined as a default parameter value: 

will loop forever, because incrementing never reaches . So intersecting ranges makes only sense if both ranges refer to the same sequence. I don't know if that can be ensured at compile time with a suitable restriction, I assume that it is not possible. It should at least be documented (similar to the above mentioned requirements of ). You could restrict the method to ranges of integer elements 

There seems to be no way to use a conditional cast with CoreFoundation types. You can do a forced cast to with an optional binding to check if the value exists at all in the dictionary: 

To generate or not to generate ... I don't think there is much difference with respect to efficiency. Your second “non-generator” version does not occupy more space because each product is immediately compared against the current maximum, and not stored in a list. The advantage of the generator-based version is that the two tasks 

Strictly speaking, your output is not correct, as the problem asks only for the first 10 digits of the sum. This would be done with 

Spacing The usage of (horizontal) space is not consistent, you have a space after and , but not after and . I would generally use more whitespace to increase the readability, in particular after keywords, around operators, etc. For example 

This would also come in handy when you start to define operations on the vector type, e.g. an addition of integer vectors: 

Instead of completely re-creating all gradient layers in it might be more efficient to create them once (when the view is initialized), and only update the frame and mask layer when the layout changes. Then your class would look like this: