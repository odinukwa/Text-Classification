An improvement on this approach is to use this input as an "interrupt" for the cpu. Instead of checking every micro-second we can use the fact that the signal changes to issue an interrupt, and use the hardware to measure the time between interrupts. Prototype Event Handler 

Current Loop Analog Industrial Controls using control, is reliable for many Kilometers. And is the professional way of solving this control problem in the analog regime. Instead of using voltage you use current sources and sinks, which will compensate for any cabling resistance. The range is an industry standard and you will find many thousands of devices that support this signaling mode. 

, in C, only allows jumps to labels in the same function. So you will not be able to do that. Even if you could it would be a bad idea, Interrupt Handlers must return from their function to end the interrupt, a GOTO is not a function call You can in principle call the redraw method directly, however this will have the side-effect that you describe - multiple interrupts may "clobber" each other or some other system thrashing. Interrupt handler should be as small as possible, In this case a simple handler would 

It's the same language, just a new version/revision of the standard and specification.The differences are subtle enough that you likely won't notice. Languages are very formal, standardized things, like dictionaries, maps, or laws. When the standard changes or a feature is added - usually after a long period of debate and discussion - this formal document is updated. Which triggers a new version number. Python3 was a significant update to the existing standard so they went as far as to change the first number in the version field to indicate its significance. However, its "still python" From the python.org page on 2vs3 

The author of this library is on so I was hesitant to answer. This is my understanding of the code. I believe there is a generic worker thread that is running on a tight loop and calling (at least once per sample) every cycle. Expired Watchdogs are checked there Lines 5796-5825 and trigger the callback you register 

Practically None. For systems engineering perspective (larger embedded projects), there are a few features in Python3 that make it a more suitable language for designing large systems. 

Create a custom adapter board or HAT Consider creating a custom board or hat that has the appropriate connector and routes the connections to correct GPIO pins. Alternative to a custom adapter cable. 

Yes, absolutely possible. However, it must be a switching mode DC-DC converter, linear regulators like the hearty have too much loss for this application 

This type of problem is actually quite difficult for an embedded device to do. Decoding and multiplexing audio streams in real time is the realm of a dedicated Digital Signal Processor (DSP). Using 8 Output Devices will list the available audio devices You best bet is to write your audio data to a raw audio file Using 8 separate sound cards, you would start each file with a script 

The steps below are confirmed to work using Spyder 3.1.4 IDE on a Debian Jessie or Ubuntu Xenial, to connect on a Raspberry Pi 2, using Raspbian Jessie, to run Python 2.7 scripts - however, I think they can work in any similar situation. Prerequisites: 

As it is stated in the instructions in the iPython console, you can paste the above info in a local json file and use this (see next step), so the existence of the server's json file is of little importance. By experience, however, it saves a lot of effort if this file and, more important, the (path to the) Python code you'll be creating on the server is mounted locally. In the client side: 

Using any means at hand (ssh, vnc, Teamviewer, physical access) start an iPython console on the server (Pi), using or Pi's GUI. This will output something like: 

I use the above solution very often, to connect my Ubuntu box with tons of resources and a big monitor to my Pi. For the time being I have no security concerns in this environment. However, mounting the entire pi's home locally screams for caution - perhaps it would be wiser to mount only the necessary subdirs. That's it - enjoy! PS: While the above solution uses local resources to run Spyder, there is another approach to the task: Install Spyder on the Pi, issue an locally and type - this will open Spyder's GUI locally, but Spyder itself will be running on the Pi (there will be big performance degradation). 

Since you arrive at the password prompt, DDNS's part is over - the ball is in your court. Can you copy-paste here a verbatim example of what you are doing in the terminal? 

From Spyder's "Consoles" menu, choose "Connect to an existing kernel" Use the browse button to the right of "Path to connection file or kernel id" and navigate to the locally mounted json file (since we have mounted pi's home in our /home/pi in step 3, the paths are identical, no matter if you call the json from the server or the local box - in my case: /home/pi/.ipython/profile_default/security/kernel-23143.json) Check "This is a remote kernel" checkbox - this will enable the following three fields In the "Host name" field input the ssh connection you use to connect to the server - eg pi@server_IP. You'll need to append :server_port only if the server listens to a non-default port. For the "Path to the ssh key file", browse to your local ssh key - mine is the /home/local_username/.ssh/id_rsa.pub (You may need to 'show hidden files' and select files of all types - spyder is by default looking for .pem files) If you have set a passphrase for your key, enter it in the last field "Password..." - otherwise just leave it blank. When you hit OK, it will take a few seconds and a new iPython console will open inside spyder which, instead of being labeled something like Console 1/A, it will show server_user@server_IP. 

Designing Home Wiring with Boxes for a PLC is something an Electrician would understand and be able to do the work for you, perhaps even assist you in planning/designing. 

The Raspbian Approach is as follows, I would duplicate this approach. provides a resize script that uses (a command line utility) to resize the filesystem on boot. This script is located in 

The Raspberry PI Zero has no protection circuit on the input, therefore it is safe to power directly to GPIO Header Pins (physical pin number) aka . More accurately, as safe as using USB Connector for power. The USB Connector is directly connected to that "net" as shown in these schematic excerpts 

No, there is no reason to. is used by to track all computers you have ever logged in to, that way if the key of the remote server changes, ssh will complain that someone is trying to intercept your communication. There is at least one circumstance where it may be necessary, often on LAN you get a dynamic IP that changes day to day, if you have two pis and and then tomorrow they switch places, your laptop will complain that the key for has changed, even though it has simply moved. In this case you may simply delete the offending line in . It would also be necessary after a clean reinstall of the raspberry pi/remote server (sshd generates new keys during system install) 

The problem here is that uses a from the data line. This means there is a limit, or max number of devices on the bus that is determined by the total current draw of your devices and proportional the pull-up resistor and the supply voltage. In this case, your system has a maximum fanout of 7 devices (calculated below), and you are powering 9, the best solution is to decrease the value of the pull-up resistor to say, Additionally, it is prefered with 1-wire to use a daisy chain and not long parallel wires. Using 3m cables to distant sensors adds significant capacitance to the line. To compensate this, a smaller pull-up resistor can be used as well. How to calculate the fanout of 1-wire bus Each device, during phantom power phase, will draw a maximum of 15uA. Therefore for our estimates, the total current draw is the number of devices times . The the maximum fanout is when the total current reduces the supply voltage to through our Pull-Up resistor. 

You can persue an FPGA solution to bridge a SATA controller soft-core to your raspberry pi host using the interface of your choice. But this is not for the faint of heart and requires capital resources. 

Thinking in terms of electron current will get you nowhere closer to understanding electronics. In the end, however, it really doesn't matter. Everything works out even if you reverse conventional current. In electronics current flows from positive to negative, this is a rule of thumb observed world-wide to keep everyone sane. You can reverse this if you like, it won't change anything in your analysis, but you will confuse everyone you ask for information. So, to answer your question, it doesn't matter what you consider "out" (source) and what is "in" (sink) in terms of current. A diode still needs a positive voltage across it for current to flow, conventional or otherwise. 

When I login to PI (SSH via Putty)from multiple machines using same account (PI/Raspberry) will memory be shared among the different login's ? I assume some memory overhead will be required to maintain the connection to multiple machines but the memory required for the login session will be shared (which includes any running programs for that session) ? Update : I require minimizing memory usage of PI, so want to ensure memory is not wasted managing multiple user sessions 

I'm awaiting delivery of RaspBerry PI2 and have created an SD card with Noobs by extracting : Version:1.4.0 Release date:2015-02-18 from $URL$ So top level SD card folder structure appears like : 

How can this folder be shared between other PI's on network, so it can be written to / read from other machines on network ? Machines includes Windows and other Raspberry PI's but I'm not too worried about Windows if that is too much hassle. I could perhaps use Tomcat server with simple form but this seems overkill for this task. Update : Thanks to @Joseph suggestion samba did the trick. However after running initial samba installation I received error : The following NEW packages will be installed: samba samba-common-bin tdb-tools 0 upgraded, 3 newly installed, 0 to remove and 0 not upgraded. Need to get 6,081 kB of archives. After this operation, 36.1 MB of additional disk space will be used. Do you want to continue [Y/n]? y Err $URL$ wheezy/main samba armhf 2:3.6.6-6+deb7u4 404 Not Found Err $URL$ wheezy/main samba-common-bin armhf 2:3.6.6-6+deb7u4 404 Not Found Get:1 $URL$ wheezy/main tdb-tools armhf 1.2.10-2 [25.9 kB] Fetched 25.9 kB in 0s (52.3 kB/s) Failed to fetch $URL$ 404 Not Found Failed to fetch $URL$ 404 Not Found E: Unable to fetch some archives, maybe run apt-get update or try with --fix-missing? After running "apt-get update" and re-running installer everything worked fine. What operation does "apt-get update" perform in order to allow installation to complete correctly ? Also I found this tutorial helpful, (mentions mapping network drive). As I have multiple PI's on network I connect using custom hostname rather than one specified (raspberrypi) $URL$ 

I'm imaged sd card with latest version of Raspbian : $URL$ This comes with version of iptables. However there are no rules configured. Do I need to add a rule in order enable connectivity between multiple pi's on network on non standard ports such as 7077, 6066 ? 

I;'ve just purchased a raspberry pi b+ and the Noobs card. I've inserted the card into the slot on device and heard it click. But I'm able to remove the card easily without re-pressing the card into its slot (which ejects the card). Is this is expected or should the card be locked into place until pressure is applied to eject it ? 

I've tried allowing all traffic via iptables. But not sure what else I can try ? I can connect to service on PI1 from PI2 running on port 8080 :