I'm tempted to use the Pi for controlling an autonomous robot that could be subjected to harsh conditions - mud, water, the lot. (It's theoretical at this point, but the concept remains the same!) Because of this I'd either like to build or buy (relatively cheaply) a completely waterproof case, preferably one rated for submersion up to 1m to be safe. What would be the best way of obtaining such a case, and how could I safely route cables through it whilst still maintaining its waterproofing? 

Not really for fully featured dev work, unless you really do love command line based IDEs and editors rather than graphical ones. Simple messing around with text editors / compilation will be fine though. The major problem is the speed of the interface. At present, with X not having GPU acceleration, even relatively simple applications such as the web browser run pretty slowly for me. Fully featured graphical IDEs would be unusable, even if they did run (which I'm unsure about due to memory requirements.) Some of these issues may be mitigated when X gets GPU acceleration. Speed of compilation can also be an issue for some languages such as C++, though is less of an issue with others (C / Java.) To all practical intents and purposes, the stuff you compile on the Pi will only run on the Pi (well technically other ARMv6 platforms.) You technically could cross compile, but I'd argue whether that's really worth it! In short, if you want to play around with a bit of development work with standard editors then it will do, but you'll probably find yourself getting frustrated quite quickly if you move onto anything more serious. 

Either close the port in python or kill the python process Wait for the device to reconnect Reopen the port or restart the python process 

In short The problem comes from the python script which does not close the serial port after the Android device has disconnected. One can implement a mechanism (doesn't matter how exactly you want to achieve it) that reacts to a message received by . Namely, when the disconnection occurs, you want to 

This works like a charm provided that the order between the different actions is as follow: > > However, if you change that order or if my Android disconnects for some reason (rebooting, restarting the application, out of range, etc.) and tries to reconnect to the Pi after some time, the communication is lost. That is, the instruction in the above script raises a 

Another possibility I came across is that I didn't get any display unless the HDMI cable was plugged in before the Pi was switched on. Should be a relatively quick one to fault-find, but worth documenting here nonetheless. 

The easiest thing to do would be to try another SD card, and then perhaps potentially another Pi if you can get your hands on one. Until that, it's quite difficult to say which one of those issues it likely is. 

Not necessarily. The big "but" is that the drivers have to be compiled for ARMv6, which isn't always the case. Less likely to be an issue, but still possible, is the power draw from the adapter - it's possible that if it's too much, the Pi won't supply enough current and therefore it won't work. 

This starts a Webserver on port 8000 and you can access the image from the second pi via if you want to start the server at boot, put this in /etc/rc.local: 

Mac's SD-Card reader usually is connected via PCIe, which some programs fail to detect as a valid Drive. (VMWare fusion for example assumes a USB SD-Card reader) Furthermore, the Partition on your SD Card is ext3/4, which can not be read by native OSX. MacFuse CAN read those File Systems, but maybe not from the SD Card because of mentioned bus connection. you can try Paragons "ExtFS for Mac", they also offer a 30day trial: $URL$ And if you tell us more of what you'd like to achieve in the first place (why mount it on OSX?), maybe i can help you with a workaround. 

Is this a problem that can be fixed with a later firmware update, or will it likely require the purchase of a new device? 

It's technically possible that if a future "model C" were to be released (I'm just speculating) the hardware requirements may be good enough, alleviating some of the above issues - but from a practical perspective I don't think running Windows is ever going to be hugely feasible. 

I'm going to be bold and just say no! While it's true some big capacitors can retain their charge and shock you, there's none nearly big enough on the Pi for this to happen, and I don't believe there's anything on the Pi that runs much above 5V anyway. Definitely not at a voltage that could shock you! 

This is one area where I believe the Pi could really shine - suddenly we're at the point where, in terms of cost, you can feasibly hand a computer with your software on as a sample, all set up and ready to go (rather than say a USB stick.) I think in the future this will be a great use case for them - a year or two from now perhaps. At the moment it's not really viable due to limited availability, but in the not too distant future, I'd say definitely. 

You can get in performance trouble with the wifi access point, depends on what your clients transfer. Maybe start without encyrption and then try and see what happens when you use WEP or even WPA... I'd suggest using a fast SD card with only the base system on it and a usb stick/hdd with your hosted files, maybe even boot from a fast usb stick. And if you overclock: make yourself a backup from time to time! Corruption can and will happen, even when not overclocked! 

But if it's a heavy motor you'll need to consider a opto isolated relay. (the modern version of closing a curcuit with a electro magnet, still the same technique) 

Probably not the solution you're looking for, but have a look at booting the pis from a NFS share over ethernet. see here for example: $URL$ the main steps include creating a NFS share on your server, copying your SD's content over to the share and then configure your cmdline.txt: 

Nope, because Windows isn't compiled for ARM (and not being open source, you can't do it yourself.) Yes, Windows 8 is apparently going to have an ARM version, though I seriously doubt it will work for a few main reasons: 

The video codecs actually fall into three categories - those supported and enabled by the GPU, those supported by the GPU but not enabled due to licensing restrictions, and those not supported at all. As for details of what goes where, this blog post gives the info: 

(*) I say a limited lifespan, but as per discussion in the comments this is unlikely to be a problem with a decent SD card in practice unless very heavy usage is going on, in which case an external hard drive may be a better alternative. All in all I'd say that with the proper testing and stable software the Pi is suited to 24/7 operation for certain tasks, as long as those tasks don't make heavy usage of the SD card. I wouldn't however use it as a device that needed to be up 24/7 for some form of critical operation. 

more examples here OR you can just set up a http server with python: go to your directory where the picture is saved and run this command: 

you need to set your GPU and RAM splitting, without it it may not get all the needed ressources to successfully play back. e.g. put this in your config.txt and reboot afterwards: 

Yes this is possible, I've used tvheadend in combination with a USB DVB-s receiver, works fine. $URL$ for a list of supported adapters look here: $URL$ There's basically no processing power required, TvHeadend just passes the MPEG TS/mp4 stream from your DVB capture device to the network... The pi gets into trouble when watching 2 or 3 HD streams (720p) at the same time. I guess it's because of the Bandwidth needed and the Ethernet and USB are on the same BUS on the Pi, the data pretty much travels back and forth in the pi multiple times. 

I don't care about Bluetooth, I can disable it to somehow "redirect" its UART to a USB port. I'm just not sure how to do that. 

otherwise the Android device is unable to connect (because there is no serial port abstraction available for the communication) and is never created. Once is runnning, the Android device is able to establish the connection and appears. I can start my python script to send data from the Pi to the Android device: 

and no longer exists, although the Android device says it is connected to the Pi. The same problem occurs both with and . Trying to reset the object in python (namely, calling again) does not help. How do I ensure a smooth, robust (re)connection behaviour between my Android device and the RPi 3? 

simply because the port hasn't been properly closed by the python script when the Android device first left. To circumvent the problem, one can implement a mechanism (does not matter how exactly you want to achieve it) that reacts to a message received by . Namely, when the disconnection occurs, you want to 

This is just a guess, but I think your connecting User has no rights to write to . Netatalk needs the connecting user to be able to r/w to which is a folder where files metadata/resource forks are kept. 

Taken the info from this site: $URL$ When I use this command, I don't get any output with the Logitech C922. VLC fails to get the h264 stream and says that it only gets the YUYV Stream, which is not compliant to the resulting ts stream. (The h264 stream seems to be transported inside the mjpeg stream) The Problem is also covered in this recent Blog Post: $URL$ Is there some way around that? I already have audio working with 

You may get best results in using something like Airparrot in combination with rplay This solution uses Apples Display Mirroring feature and delivers (in my opinion) the best experience (smooth & easy to set up for beginners, a license key for the beta can be obtained in their forums for free) The second possible way would be to just Install a VNC Server on the Win7 Machine and start a client on the Pi (ssvnc for example) The VNC solution is probably quite laggy, but still pretty easy to setup. A third option would be to capture the desktop on the pc with VLC and play the stream with the pi 

Either close the port in python by calling or kill the python process Wait for the device to reconnect Reopen the port or restart the python process 

I have got a RPi 3 loaded with Raspbian GNU/Linux 8.0 (jessie) and I use to send data over Bluetooth to an Android application. Pairing the Pi with the Android device works fine. For my Android device to connect to the Pi, I need to run 

I would like to send data from a RPI3 to another device through a standard USB cable. Is it possible to use one of the RPI3 USB ports as a serial port to that end? FYI I am already using on pins 14 and 15 of the GPIO as a serial port for a sensor. Graphically, here is what I want to achieve