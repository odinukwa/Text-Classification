Whether or not a "Weapon", a "Character", or the "World" (or some other more global concept) should contain a collection of bullets fired depends largely on how you want the bullets (or, generally, any object/concept) to be considered in your game. Questions to ask: 

Complexity largely depends on the specifics of implementation. However, all else being equal, a freeform system is far more complex as the potential number of results are significantly higher. Yes, the traditional usage of the two is for lists to be atomic actions (such as Elder Scrolls' system) while trees are used for "Perks" or "Abilities" to simulate a focus on developing enhanced skills in a specific domain. However, this is hardly a requirement. Much changed between Morrowind and Skyrim, largely due to a number of decisions far too complex to attribute simply to "using a list-based skill system". 

Can I use copyrighted material if I give credit? Under most licenses, absolutely not. There are licenses that allow use which include creative commons licenses, as Mr Beast stated in his answer. Can I use copyrighted material? If you obtain a license to do so. This can be done by contacting the copyright owner, or abiding by the license that currently exists for the work, such as the case of a CC license. You can also use such material if it falls under fair use. In your case, it probably does not, but doing research on it might provide more insight into fair use precedent. However, if you decide to pursue this route, know that this is decided on a case-by-case basis. In court. Contacting the copyright owner is much simpler. Are there other options? Yes, actually. As IMX answered, despite the downvotes on his/her answer, cover versions are not covered by copyright law in the same manner. You don't need owner permission, but you will need to pay royalties to the owner through a mechanical license. Please note that, with the exclusion of fair use, all the answers involve a license in some manner. Mechanical licenses, contacting owners to license, utilizing the current license. There is no answer (beyond fair use, which is very limited and probably not useful in your situation) in which you can use a work without a license. 

The simplest solution is to simply use the ratio of the two forces as the probability of success/defeat. If you want a method that does not happen instantly, simply implement this method one unit at a time, with a variable speed and output threshold. For example, 57 vs 89 troops would mean that, for the first step, one side has a chance of 57/146 (39%) to lower the other side by 1, the other has an 89/146 (61%) chance to lower the first side by 1. Each step proceeds until one side wins. The speed can be variable, the number of units lost per step can be variable, and it's a fairly safe way of showing a realistic simulation. 

I'm unfamiliar with Unity, so I cannot help you with specifics, but it sounds like what you need is to implement a GUI means of fine-tuning those values during run-time with, say, a set of sliders or numeric fields. It would be fairly simple to implement fields to alter whatever values you're determining (scale, speed, etc) during run-time which gives you immediate feedback. For placement, you could use either fields or manual placement with click-dragging (which might be slightly harder to implement, but much more intuitive). This gives you complete control without compiling and running the code for every small fraction of a change. When you finally arrive at a look and feel with which you're happy, use those values in your list of constants. If this is too daunting because of the number of variables you're editing (say, numerous sprite locations in numerous levels), you would want to implement it in a level editor, I imagine, with the same functionality of manual adjustment but with the result of creating and storing the data adjusted. 

Summary: Lists provide more agency, while trees provide more easily anticipated results that are simpler to balance and utilize in design. To be as concise as possible, the difference between lists and trees of decisions is the level of freedom the individual making the choices has. When speaking of skills and character progression specifically, lists such as found in Elder Scrolls provide freeform decision making. Trees provide a more guided approach, usually representing classes or sub-classes of some form. There is less freedom in character progression/creation, as the concept of a tree necessitates requirements to unlock latter levels/branches. The freeform list provides a greater sense of agency for the player, allowing a greater number of options. The more guided tree provides a simpler system to consider and anticipate as a designer, resulting in a system easier to balance. So, the end result is that you have a choice for a potentially more balanced system versus a system that provides more agency. To answer your edit questions: 

The simplest means of determining if there is contact after your touches finish is to alter the category of the "ball" to a category that registers contacts with the "bucket". That is to say, your ball would have a category that ignores the bucket until the ball is dragged and the touches end (touchesEnd method), at which point the category of the SKPhysicsBody of the ball will be changed to a category that no longer ignores the bucket. A simple didBeginContact method executes your desired behavior for the ball being dropped in the bucket. 

If not going with HSL or a similar method, and staying with RGB, it helps to understand the relationship. As white is [255, 255, 255], lowering the G and B values similarly will result in a very light red color (shades of pink). When the color becomes [255, 0, 0], the color is a stark, bright, primary red. As that red value is lowered, the red becomes darker until black at 0, 0, 0. Lowering the red before the G and B values reach 0 (i.e. r > g == b) creates a desaturated "greyish" red. This same process is true for any hue. Green is simply the G value being higher than the R and B values, yellow is the combination of R and G values overwhelming the B. [255, 255, x] where x is 0 to 255 is a bright to light yellow. [x, x, 0] where x is 0 to 255 is a dark to bright yellow. [x, x, z], where x is variable and z is less than x results in varying brightness of a desaturated yellow. Thus, hue is essentially the proportion of the two highest of the three RGB values. Saturation is essentially the proportion of that hue to the third value. If the hue is high, the color is bright. If the third color is also high, the color is light. If the hue is low, the color is darker. If the third color is high and the hue is low, the color is a murkier or greyer color. 

Ensure, for the "tight circle" to be the effect, to keep the forward velocity/force applied throughout the duration. 

This answer still ignores the attempt to use matrix rotation, but I realized that there was a simple yet general solution. First, assuming that the shape is encoded as coordinates of blocks in a grid, you have an arbitrary shape containing blocks with coordinates in the X and Y axes from 0 to n, where n+1 is the maximum size of a block (traditional Tetris shapes would fit a 4x4 grid). The classic Tetris bar (vertical) would be (1,0), (1,1), (1,2) (1, 3). To rotate this shape, no matter what the form or size, you simply swap and invert axes. 

Summary: Depict differing world-views and perspectives in a value-neutral, non-judgmental way In order to deal with prejudices, biases, and bigotry, I would focus away from artificial "This is a minority in the galaxy. It's wrong to hurt them!" style methods. It's not that it's inappropriate, but that it would be ineffective at doing anything but "preaching to the choir". Instead, the root cause of prejudices is unfamiliarity with different perspectives. Showing multiple perspectives in a neutral light would be the most effective means of actual change. The best reference for this would be Alpha Centauri. A Firaxis/Civilization sci-fi game. It plays much like its sister game, Civilization. However, the civilizations that oppose each other have distinct personalities, and the leaders have equally distinct personalities. These leaders are quoted for every "Great Project/Wonder" and "Tech" that is built/researched. These quotes, more than any other fiction I've read/experienced, have driven a brilliant means of insight into differing perspectives. The industrialist is often quoted giving justifications for a focus on capitalism. The autocrat has a quote giving a logical justification for his government's oppression. It's not the focus of the game by any means (they are simply quotes you needn't ever read), yet they repeatedly offer different perspectives to the player without judging. This, I think, is the key to moving beyond "lecturing/moralizing" and moving towards "enlightening". Offering non-judgmental windows into other world-views. By doing so, by being as neutral as possible, anyone who is more likely to identify with the traditionally villainous character(s) will not be off-put by authorial attempts to cast what the player sees as the most identifiable character in a negative, sometimes wholly demonized, light. This means the common defensiveness that occurs, which is more or less a cognitive bias called the backfire effect, is not as strong, so the player remains more open to the experience. It is this openness that leads to a higher chance of real change in perspectives, which should be the ultimate goal in any "socially conscious" fiction. I'm not technically suggesting that you should utilize "quotes" like Alpha Centauri. Rather, utilize the general methodology, that of non-judgmental depiction of differing world perspectives. This, of course, works best when told in the fictional universe with a consideration for relatability given the culture of the viewers/players (e.g. sci-fi versions of current social ills such as prejudices against Islam and homosexuality). Source: Is a Licensed Counselor with cultural-change-focused master's 

The best way to handle asynchronous play with fun/engagement would be similar to designing any feature in any game: allow for interesting meaningful choices. Specifically, allow both players to make decisions, which means the "defending" play must be making preparatory decisions. In order to prepare for attacks of unknown variables, either allow the defender to prepare a challenge for an attacker to overcome, or allow the defender to offer more than one defense setup for possible attacks. For example, either allow the defender to prepare a defended "base" that is attacked or allow the defender to respond to, say, three different attack scenarios with defense scenarios. This methodology allows for both attackers and defenders to have more active participation and make more meaningful choices, which you'll often find results in more fun despite the asynchronous nature of the fighting. 

First, you shouldn't be hard-coding numbers like your acceleration. Numbers like these, which need to be fine tuned, should be variables that can be easily tweaked, either in one-place or dynamically using a slider or somesuch during testing. Second, from what I understand (of your comment to MagiSun), your problem with the acceleration giving you odd behavior is that your acceleration value is far too small. Even at 60 updates per second, you're accelerating at 0.06/s, and unless your velocities and positions are also in similarly small measurements (which I assume they aren't by your description of the resultant behavior), this will result in a very slow deceleration. If you're keeping the "Down" key pressed the entire time, by the time you reverse course (and travel in negative velocity), your negative acceleration will be very noticeable, giving you the "uncontrollable speeds". Try raising your acceleration value, but take note that you might also want to increment acceleration at a slower rate than your updates-per-second/fps. Another concern is that you might want a maximum acceleration, even if it might be unrealistic, simply for the sake of a good "feel". 

iOS 9 actually introduces a GameplayKit framework that includes State objects. This link shows you the implementation of their GKState class. It inherits from NSObject, but not from any SpriteKit node class, or any SpriteKit class at all. The thing to remember is that SpriteKit is all about drawing and physics simulation. SpriteKit tends to confuse the logic and rendering of objects, but nothing outside of physics or rendering is inherent to the framework. Nodes are great for anything in a scene that needs a position, or a physics body, or somehow organizes rendered or physics objects. States, however, are purely logical, do not need positions or velocities or physics, and can therefore be purely separate from SpriteKit, SKNodes, and SKScenes. 

If you have any weird bugs from SpriteKit's physics engine, you might try placing a node with a physicsBody that's affect by gravity with that same constraint, and constraining the character to that node. You could place an additional rotational constraint on the character if you want the character to only rotate a certain angle while "climbing hills" or if you want your character to be "upright" constantly while not colliding with the ground. 

I don't have an answer to your specific question, mostly because I don't believe there is an answer. The simplest application of fuzzy logic in an FSM would be allowing multiple states, rather than a single state, and using probability to determine behavior. In this light, it's a question of whether or not an extra level of AI sophistication is appropriate. Simpler applications can suffice at times, while more sophistication in architectures provide enhanced perceived intelligence at the cost of complexity (in coding, debugging, design). Allowing multiple states of an FSM which are executed randomly would allow for more seemingly random, yet still reasonable and "intelligent", behavior. This would have the result of seeming more human, as humans often seem random and "unpredictable". For an individual agent, the agent might seem to do something less obvious, making it seem "foolish" or "unpredicable" or even "unexpectedly clever" depending on the situation. For groups of agents, fuzzy states might lend players to perceive the groups as "disorganized", or "unable to agree", etc. Again, though, it's less "Which is better for individuals/groups?" and more "What level of sophistication of AI is appropriate for my game?"