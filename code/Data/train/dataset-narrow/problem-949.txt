And for the rest, we just have to check the return of every time. Note that there's no reason to copy the full list of every time! That's expensive. You can just append to the end before the call to solve and pop afterwards: 

min You wrote your own version of that is the smallest of 3 arguments. But there is already one: . Use it: 

And we have no repetition and no unnecessary extra case for empty map. Know Your Interface There are several different overloads for . You are using the wrong one. This is the one you want: 

That has meaning. This gets steadily more important as the number of elements in you use increases. Refactoring Rather than one monolith, you should break each formula up into its own piece: 

It'd be easier to separate this into two parts. First, we can do all the word transformations using and a single word switcher: 

Otherwise, you would get something weird like being true. Iterators An important part of writing a container is writing iterators for it. You may just provide general iterators that just go over the whole array front to end. Or you may want to support arrays that iterate over a single dimension and provide a proxy object to a multi-dimensional array of one dimension less. Either would be good to have. 

Don't think there's a Scheme equivalent unfortunately, so maybe this is more of a tease than an answer. 

A Path != Best Path Depth-first search (what you're doing) will definitely find a path if it exists. But it won't necessary find the shortest one. Try out a few of the other path-finding algorithms. The direct corollary to DFS is Breadth-first search (which does exactly what it sounds like). And then there is a lot of room for optimization. 

This does all the same thing that you're doing, but once you split it up, there's less logic to have to reason about. You can even move into directly: 

And so on. , , and The first function takes the average of ALL times, but the next two take the average of the TOP times for some number. That number should be an argument and the function should be named differently. In any event, should probably return the average, not just print it: 

And it's confusing since you increment in the middle. Which happens to work, but I had to stop and really think about it to convince myself that it does. You could simply shift the into the : 

It takes no arguments, and returns nothing. But it does a LOT. And the signature should make that clear: 

Know what's in the standard Your function's job is to pick some character (either or ) and return a string with that character times, followed by a period. You do not need a loop for this. There is a constructor for that takes a count and a character and constructs a with that character that many times. Thus: 

There are two reasons for this. The goal of a heap is to make it as efficient as possible to grab the top element. As you wrote it, is logarithmic (because is). So that sort of defeats the purpose. Secondly, because you're extracting at the same time, you're requiring an additional copy (you can't return a reference because it would dangle). So that's less efficient too. This way, you can have a constant time zero-copy implementation: 

I question the validity of this exercise. I wouldn't really expect the percentages to line up for a long, long, long time. Possibly never. Running a few times I got anywhere from 290k to nearly 8 million. That's a lot of die rolls, and a pretty wide range. 

The Algorithm We want the largest prime factor. We don't care about any other factors, so all the logic around keeping a list (and then going through it again? I don't know what that's about) is unnecessary extra work. Furthermore, you're checking if the number is prime and then going through all the rigmarole of checking all the divisors again. You definitely want to check every divisor at most one time. And even better, divide as you go: 

Naming, naming, naming Real estate has location, programming has naming. Can you, going back to this code in a few months (or even days), tell me what these arguments mean? 

That'll also reduce the code duplication on your copy and move construction. Unnecessary Mutex You have a , let's take advantage of it. There's a function called with which we can do: 

Your program actually gives the wrong output for every number. You're forgetting that is a factor of ! The easy fix is to simply initialize to 1. Even better to initialize to 2 and start your loop at . Once you fix that, your program is fine. It's just that you can just do a lot better performance-wise. Let's start with the general formula. Any number can be expressed as the product of primes raised to some power: \$n = \prod_i p_i^{k_i}\$. The number of factors of \$n\$ in this case is \$\prod_i(1+k_i)\$. So what we need to do is find all the prime factors. How do we do that? We can actually reduce as we go. Everytime we find a factor, if we do it right, we can be sure it's prime, so we reduce it as far as possible: 

Minor optimization Rewriting the way I did it above allows for a minor optimization. Every time through the loop, we know that we just put the "largest" number at the end. It "bubbled" up! At that point, we don't need to do anything else with it, so we can decrement the pointer: 

In Python2.7, replace with . Basically, we're turning our tree into an iterable. Then, we can just pairwise iterate over this with some recipes: 

That'll happen in the case where is divisible by one of our primes, but we somehow haven't seen yet. But we are iterating in order, so you're guaranteed that for all . So you can simplify that block to: 

You could add SFINAE on that if you want. Equality Also overcomplicated with here. Just convert the second type to the first type. If that doesn't work, you won't be able to do this anyway: 

This has several benefits. It will reduce multiple layers of indentation. It will give you two functions with focused criteria. And it will make it clear that is doing just a filter and a transformation on the input list. 

Parenting A node in a tree either has a parent or does not have a parent. It is never its own parent. You default your values to: 

If the user doesn't care, they can always the items in and avoid the copy. Naming Typically, naming are used for classes (e.g. ). Functions and variables are typically either (with the first letter lower) or . So I'd prefer 

The reason being that is a fairly commonly used idiom to get a pointer to the first element... which would fail to compile now. I don't think that's something we should prematurely disallow, so let's make it work. Obviously make it (and not ) since you want to keep it immutable. 

Ok, now that we have our results, we need to compare against . Rather than doing a list copy, division, round on every element - let's go one at a time. After all, if the percentage for doesn't line up, why even calculate the percentage for ? The percentage for any one roll is: 

Pick a good return type A deque is a Double Ended QUEue. Deques are great for when you have to insert and erase from the front as well as the back. You never need this for your problem - all you ever need is to insert at the end. You just need a normal list. Generate when you can Rather than necessarily giving the entire result all at once, it's better to just the next element as you go. This is a simple change in your algorithm (just instead of ), but could have serious performance implications down the line if you have lots of large iterables. If the caller wants a full list, then can always explicitly write . Use the standard when you can There is a function that already merges sorted inputs into a single sorted output: . It will give you duplicates, but that seems like a much better starting point than writing everything from scratch: 

You can get around that by making a linear inheritance list of all your optional bases. I'm not sure if it's worth it, but I'll present the idea just as an option. At its core, we have which will inherit from all the optional bases and provide a getter so that the derived class can actually use them: 

Factoring is hard. It's a difficult problem in the best of cases. You are taking a difficult problem and making it harder. You are starting with - that is already a partial factorization. You are then throwing out that information and factoring the whole number. It is much easier to factor than it is to factor , but you are choosing to do the latter. It would be much more efficient to do something like: 

but doesn't actually modify anything in , which still retains . This would be very surprising to your users. You definitely want to make sure that you give back a tuple of references. Forwarding isn't really supported Your main function is: 

It doesn't matter which you put on - it means the same thing either way, I just think it's more expressive this way. 

Pointer to vector? You have two members: a pointer to a vector (which you , but never , which leads to several other problems) and its size. But you're already using a , so just do it twice: 

is super useful. So are its close relatives and . The way you wrote is fine and works, but doesn't make it easier to write the other two. A good way of writing these out is to use @Columbo's trick: 

Use the right loops Don't use with iterators - just use a range-based for-expression. It'll save on the typing and add to clarity. Improved solution 

Once you fix those, there are other issues with your code: Limits on Types When you construct like this: 

First, you're taking your by value. That's incurring an extra copy, which you don't want to do. Secondly, your resize policy is increasing capacity by one. This means that your is expected \$O(n)\$. There's an easy explanation for this too: once we reach our capacity, we will have to on every subsequent , which means we're copying \$n\$ elements every time. The right thing to do is to increase capacity by a constant factor. The next issue comes from indexing: 

SIX arguments! That's a lot of arguments. But conceptually, we're painting the grid based on a single selection, so shouldn't there be just two arguments? What are all the others for? What is the return type? It's difficult to understand this function. The Algorithm You are using depth-first search. But we want the minimum number of steps, which calls for breadth-first search. Because you picked the wrong algorithm to start with, you are doing far more searching than is strictly necessary. Furthermore, we can even use with a simple heuristic (# of colors remaining) as a future optimization exercise. This switch will save you a huge amount of time, but in order to do that, we have to structure your code into bite-size units. This is a job for... Functional Programming Let's get back to key principles. We have a . We need to do one of three things to it. We need to know if it's monochrome. We need to know what colors are left in it. We need to paint a color. That calls for three functions that do three different things: 

This will additionally fix your bug where for subtraction you're really adding. List Comprehensions It's more direct to simply initialize your numbers directly: 

Should be 4. Coding style The Python style guide recommends over . Also, many of your names are just WAY too long. You're taking up too much space without providing new information. There's also a lot of repetitiveness. and shouldn't be separate functions. You should have one function prompting for a value, and then separately assert . Finding the most divisors is extremely verbose. We can do much better. The function takes a keyword argument named that gives you a function. So as a first go, it's as easy as: 

Where is something you should provide to meet the expected interface of C++ containers. What if I wanted to do something like... print all the elements of your tree? Can't do it. 

Those aren't independent checks, which suggests that the second should at least be an . But since the body is the same, I'd suggest just combining them: 

That is much shorter, and no longer repetitive. Declare Variables where you use them This is a very C-style list of variable declarations. Instead of putting them all up top, just define them inline. And prefer to : 

That's inefficient (you're copy constructing a pair instead of in-place constructing it) and just a bunch of extra typing. Also is , so the above line is logically exactly equivalent to: 

When you need a comment to describe what your variable name names, that's a good indicator that you should just change your variable name. Once you do that, that doc string becomes pointless: 

As a first go, gates should know their inputs and be able to perform logic to determine their outputs: 

Firstly, it's an odd name, since we're never copying. We're either referring or moving. But secondly, it's bigger than it needs to be, and incurs allocation overhead. We can hugely simplify this changing: 

Additionally, the argument should probably be named - since that's the one that doesn't change. Avoid code that looks like: That's an extremely verbose way of writing Altogether, this becomes: 

Format Your Code It's extremely difficult to follow your logic with inconsistent indenting. 4-spaces after each brace please. Stop When You Know The Answer Here is your function to find out if a number is prime. Which you don't actually need for this problem (more on that in a bit), but I wanted to talk about it anyway: 

Also, you don't need to explictly provide the types to this function. Let the compiler deduce your types for you: 

That loop will iterate 10 times, all in one line of code. Repetition, repetition, repetition You have 

Converting constructor There's a lot of usage going on here and I don't think you need it. We can introduce the divided ratio as a separate defaulted template argument so that we only have to call it once. Note that you're using to ... and then casting it back to anyway. There's no need for that intermediate cast. There's definitely no need to cast or . Just use it directly to delegate to the value constructor: 

It's a couple more characters than your solution, while also not having to be a macro. I think that's worth it. Also, let's use some C++11 features, which are way easier to use with the introductions of and and . , as a function If you wrote it as a function, it would look like: 

The cast isn't necessary. You can simply compare . Secondly, this is different behavior than your other operations which allow for overflow. This should simply be: 

However, this is pretty inefficient - we have to make another copy of just to check if it's reversible? We can do that directly in one go. Just compare the th element to the th element and make sure they all line up: 

That should do it. Implementation Details is confusingly implemented. I have trouble following the loop since you're trying to do too many things on one line. First, the inner loop: 

For more gratuitousness, we could even drop the mod operator, and take advantage of some itertools recipes with: 

That builds up the whole list before we then print them one by one. We don't need the whole list in one go, so we can just return a generator: 

As the name suggests, is not move constructible. Your metafunction says it is. Also, is move constructible but your metafunction says no. The correct implementation would be to simply use the standard type trait . Secondly, the alias there is questionable. Typically, we'd use aliases to avoid having to write the cruft. You're not doing that, and the resulting call isn't that much more concise. Compare: