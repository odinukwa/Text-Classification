This is a problem from computer vision and the keywords your want to search are "pattern recognition". If you would like to make it fully automated, try OpenCV library. You basically want to define the arc and then look for it. I am quite sure the library can provide this functionality, but it doesn't have a port to Actionscript. You can look into the source codes, but the algorithms are not easy. 

If you just want to use the built in Media Player in Android, you can't play AVI files. See the list of all supported formats. If for some reason you can't convert the video to any of the supported formats, you will have to implement your own media player which has codecs etc. You can take a look at FFmpeg. It is possible to compile for Android. 

Blue body is moved using MouseJoint (yellow) towards the Red body. Red body has another MouseJoint - Blue can push Red, but Red will try to return to the start point thanks to the MouseJoint - this works just fine. Both bodies correctly rotate along the middle. This is still as I want. I change the MouseJoint to move the Blue away. What I need is both bodies return to their initial rotation (green arrows) Desired positions and rotations 

It looks to me that you want your animated sprite to be driven by the physics body (you register the connector) but then you are setting its position to some and . The physics body might be jumping, but the Sprite is drawn always at [pX, pY] due to this code. 

A simple web search bring this shader up $URL$ which looks like what you're looking for. I'm not an expert on WebGL, but according to this page, it looks like it uses the regular GLSL language (this is the C-Like language used by graphic cards to program shaders). This means you will probably have little to no changes to do to make it work. You may however try to start with a more basic shader to understand how it works. This blog page lists all the steps to implement a shader in WebGL. That seems a good place to start. Another good place to find wonderful shader examples is $URL$ 

If the players cannot modify the world, you may be able to just save your seed, and rebuild the world later. If they can modify the world, it will be very tricky to rebuild the world (especially if their modifications depends of the RNG at the moment they take the action). If your world is highly procedural (you generate a lot of data) and modifiable you may try to save both the seed and a "delta" of the differences between the generated world and the "actual" world. One way to do that (not the most efficient but it should work) would be: 

Well, developing a very crude level editor from scratch would take you at least a couple of weeks, and the result would be a lot less productive than using Tiled. If you really want to get rid of TMX files (that's something I do most of the time), you can write a script which convert a TMX file into whatever format you'll be using (in your case, the script could output a list of SQL's INSERT statements that will add the new level to your DB). This way, you can have the better of the two worlds (Great tilemap editor to design your levels (Tiled) and the data structure you want for your game). If you're using some kind of Makefile, you can even treat your TMX files as source files (this way, whenever you want to change a level, you just have to save the file and rebuild your game (or at least the DB in your case; you may use a specific build target for the DB so the game itself won't have to be recompiled everytime you edit a level)). 

I have two long Box2D bodies, that can collide while moving one of them around with MouseJoint. I want them to try to hold their position and rotation. 

This happened to me in AndEngine when I loaded the texture but forgot to unload it. If I load it too many times, then the memory is full, new texture doesn't get loaded and this happens - the texture regions point to some garbage. If it happens only after some time, it might be the case. To debug it, write a message to log on each load and each unload and make sure you load and unload the same number of times. Also it can be another texture that fills the memory. In your example, you are loading but you are not unloading it. It might have filled your memory and there is no more space for the font. 

You have probably published your APK as Alpha or Beta. This is a known bug and Google Play store will incorrectly show "Requires Android: 1.6 and up". When you deploy your APK as production, it will show the correct number. You can check your apk's minSdkVersion by the command-line tool (inside sdk/platform-tools) 

You are using Tiled map editor, but not using the TMX file format, right? I believe the comes from the first tile GID in the given tileset. Just save the tilemap as TMX and you should see something like: 

This is one way how you can do it: What you need is to parametrize the trajectory. This will be your parametrized line: 

This approach also allows you to prioritize your messages; if instead of having only one waiting messages list you have many, you can dispatch message depending of their priority. That will allow you to process most important messages first, even if some less-important message has been received before them (i.e. if you have a lot of mobs attacking your player, you may delay for a second or two the chat related messages, or information stuffs like "xyzz has join the game" or "dfghf is now level 41"). If you don't enforce a constant framerate... well, I really think you should; the framerate perception will look better at a constant reasonable value (i.e. 30 fps) than if it varies depending of where you are or how many players are around you. Another pointer to optimize may be to reduce the number of messages sent to clients. i.e. for non-critical events (like chat or informative messages), instead of sending a message every time someone says something you may consider limiting those to 1 message/second/player. The idea is when you have a message of such to send, you just wait for one second before sending it, and if another message of the same kind arrives during this second, you just add its contain to the first message payload. Same thing for server issued world updates: Instead of sending one message with new coordinates for each player/actor, you may consider packing many of them (all if possible) in the same message. That shouldn't have any perceptible effect if you have a fixed framerate; you just have to send your world update message at the same rate (i.e. every 33ms if you have a 30 fps framerate on the client). If possible, and assuming you use TCP (so no packet should be lost) you may keep on the server the last "world state" send for each client. That will allow you to only send what have changed since the last update. This will also reduce network bandwidth you use which is always a good thing. Bottom line: It's all about prioritization. You just cannot do everything at once, so you have to compromise and to process first what you think is the more important. 

I am working with AndEngine with Box2d extension, but general answer or a concept idea will be appreciated too. I have feather-like objects in a 2D side view world that I want to be part of the physics simulation. I am using linear damping to make the "feather" fall slowly. This might not be a good idea, maybe I should rather apply force in each update, but nevertheless, this works and it makes the object look "light" and it feels like there is air with resistance. Now how can I make the objects actually look like feathers falling through air? Specifically I am looking for two types of objects: Long with low density, that should move down in a slow swinging motion and square objects that would just randomly change trajectory. It would be great if this could be one simulation and length would be a parameter - the longer the object is, the more it would swing. Right now I want to simulate feathers, leaves and snowflakes in a cartoon world. 

Create your own thread that will be checking the array of enemies and adding them to the game. Also sort the enemies by time they are supposed to arrive and stop on the first enemy that in not supposed to arrive yet - then you don't need to check all of them. You can implement this by using stack. Push the enemies to the stack in the opposite order and pop() them when needed. How to do this in cocos2d, I don't know, but this should be the general idea. 

It looks pretty close (it's hard to tell without the base image) but you can tweak the parameters. You may see it in action there: $URL$ Some remarks: 

From your example, I assume you are making a 2D horizontal scrolling game. If I assume your game scrolls from right to left (player moves toward the right edge of the screen), and that the CameraX value is 0 at the start of the game and increase when the player moves right, then your rendering code should be: 

I assume that when your network data arrives, its processing diverts enough CPU power to slow down your rendering process. Are you enforcing a constant framerate or are you just rendering frames as fast as you can? Assuming you have a constant framerate, you may chose when your network packets are processed. I mean by that that your websocket event should do nothing except adding incoming messages into a waiting list, and somewhere in your game's main loop you process them. It could go like that (very rough algorithm) : 

Extra thought: you may even make the game procedural with a few changes: - Just create all your levels without any trap. Whenever the user starts a level, your game engine would have to: - add a bunch of traps (you may have various difficulty level with more or less traps) - run in the background an AI run of the level which delete the traps in the way - display the level and let the player trying to pass the level Or you could script the game entirely, like in "I wanna be the guy" but then it's closer from "movie making" than "video game design". [*] this is for level design only but you may consider leaving it in the final game since players which successfully finish the level will be very happy to brag about it by sharing the video :o) 

I've added the aura effect. Also the image has transparent background, if you are interested to see it on different color backgrounds. 

Typically you want to have a thread pool. Each thread from the pool services one request, then gets recycled. When you don't have enough threads, you can consider blocking or allocation of more threads. 

Do not draw the same Sprite to represent the image at multiple locations. Holding the coordinates somewhere else - this defeats the purpose of object-oriented programming. The most memory is taken by the texture (or texture region) itself, the overhead of your custom class is negligible. Unless you will be making millions of Quads, do not worry about memory. It will grow as needed. Premature optimization is the root of all evil, however there is one performance consideration you can make. If you are going to create a lot of objects and immediately throw them away, you can use Object Pool Pattern to reuse these objects, especially if there is any CPU intesive initialization and clean up taking place. The performance is also affected later during garbage collection, which can create peaks in CPU usage. Using Object Pool prevents that, but one must be very careful to recycle the objects properly. I'd recommend your option 1) and don't bother with the Object Pool unless you hit the CPU usage spikes. Also the modern Java Garbage Collector is very well optimized for short-lived small objects, make use of it. 

The complete answer to make this fully automatic FOR ONE BODY is a combination of efforts of Byte56, NauticalMile and me. You will need: 

Depending of the specific details of your game, you can probably optimize this further. Just a bit of warning: If your procedural process is using floating numbers AND you want the saved games to be useable on another computer than the one which saved it, it will likely not work the way you're expecting it unless you take extra precautions (see this article about the issue if you plan to do it: $URL$ 

Here is a way to do that on a platformer; this is probably possible on other kind of games, but I won't develop here. 

Now, if you want just a couple of hard passages in your games, you can do that by hand but if you want an almost impossible to play game from start to end you may want to automatize the process: You may do that by writing a modified replay engine that will not kill the player when he hit a trap but instead delete the trap from the level 

I don't think displaying an outline of your character will be CPU intensive (unless you have thousands of players to display). You just need to have 2 sets of images for your characters: 1 with only the outline (O sprite) and one with the rest of the character (C sprite). If you're having high tiles, you probably already draw them in the correct order (using z-order, the tiles in the background first, and the ones in the foreground last). You just have to draw the C sprite in the correct z-order (which means it may be hidden by a high tile in front of it), and the O sprite after you have drawn all the tiles (which means it will always be visible). You mention doing this in PHP; I take it that you're working in a turn based game, and you're generating an image on the server every time something changes. While it's not critical, you may consider rendering the scene in Javascript on the client side; that will greatly reduce the bandwidth used by your game (each tile is only sent once) and displaying an isometric world in Javascript is not that difficult.