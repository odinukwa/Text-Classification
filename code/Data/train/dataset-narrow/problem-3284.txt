You could create a watchdog script that runs in crontab every minute. This will also restart the stream if for some reason it crashed. 

Connection refused in combination with port 22 not showing up in a port scan generally means that SSH is not enabled on the system. Reinstalling SSH probably won't help you, but you could try to re-enable it. If you don't want to connect a screen, you can power down the pi, take the SD card out and mount in on a pc, put a file called in the directory and put it back in your Pi. This should enable the SSH server. 

From what I understand you want to be able to switch the light to the desired status with your relay at any time. Someone switching the manual switch in this setup, would mess up your knowledge of the lights current status. The only other setup I can think of is one I have in place myself, but it requires replacing your existing switch from a toggle switch to a momentary switch: Your relay setup would be the same in the image in your post. The momentary switch would however also need to be connected to a GPIO and GND on the Raspberry Pi. You could use your current (normal) toggle switch as a momentary switch by briefly switching it on and off, but that requires user behavior. Your program would require a variable to know the status of the relay so you can have multiple ways to toggle it. 

In your case, you need to consider your relay as the first switch, and your pre-existing switch as the second one. Image taken from : $URL$ 

Indeed, your calculus seems legitimate. Of course, it doesn't care about the fact that the RPi power consumption is not linear, as it depends of the CPU and external device usage, but your result will be enough to estimate how long your RPi will run on different batteries. 

We can see that one battery is already not powerful enough for the raspberry (1.75A instead of 2.5A), so powering a motor on the same battery won't just work. I don't know how other people solve this case, but you can look for lighter hardware that would limit the need of power (arduino ? rpi zero w?), or for bigger batteries. 

If you need to write datas on the SD card, you can remount it in read-write mode with this command : 

You can't run an ARM Raspbian image on an x86 system. If you want to run the Raspbian Pixel Desktop you can download the x86 iso at raspberrypi.org 

Make sure you're using the correct pins. The 5V pins are on a rail shared with the power supply port. If you can't power them via these GPIO pins, your rail is broken. 

There shouldn't be a colon after gateway. Apart from that, you might be bothered by case sensitivity. You're connecting to hadoopmaster, but specified hadoopMaster. 

If you want a desktop you're better off installing "RASPBIAN STRETCH WITH DESKTOP" instead of "RASPBIAN STRETCH LITE". The Lite image doesn't include a desktop by default, it is a minimal image. This makes it suitable for smaller SD cards and is perfect for pi's that don't need to be running a desktop. If you want a desktop install "RASPBIAN STRETCH WITH DESKTOP". 

After your comment on Technico.top's answer I think I understand what you want. Normally this would be done with a dual switch setup like the one below, where one of the switches would be your relay. 

You must also check that your hostname doen'nt contain invalid characters. Try to use one with only alphanumerics characters. You may also try these commands, made for live hostname edition : 

Wich demonstrate that our previous command as correctly worked, and that the camera will output MJPG instead of YUYV. If you see that your camera is back in YUYV format, it may be because you ask for an unsupported format (see ). Launch your video client, and then run again. If you see that your camera is back in YUYV format, it's because VLC rewrite camera parameters, and then it's command-line options should be tweaked to ask for MJPG format. If your camera is still in MPEG, that means that VLC should have correctly received MJPG stream, and struggle with the h264 decoding part. Edit : As pointed in your link, "H264 is still there, but is muxed into MJPEG stream (meaning MJPEG is a container with both still frames and H264 encoded video)". So having your camera in MJPG mode seems to be a prerequite. Now, following w2017's advice, let's try to create a named pipe (is this really different from command-line pipe ? I don't know !): 

Your pi has 2 default routes: 0.0.0.0 (= default gw) with metric 0 (highest priority) to the interface. default with metric (202) to interface. Since the default gateway to has the highest priority, your pi will route every (unknown) route to . I can't make up your complete setup from your post, but I think this might be your issue. 

Yes, you could use the 5V pins. It's not recommended since your are bypassing the polyfuse, but it's possible. Using both 5V pins will only increase the carrying capacity of the cable. They are on the same single 5v rail on the pi. To understand how to keep two pins at 5V and not create 10V, I suggest to try to learn some basic electronics, especially learn about series and parallel circuits. Do not use the 3.3V pins for anything other than powering peripherals. Buy a decent power supply and forget this. You will not overload the Pi's, but it's just not a fashionable way of powering anything. Dual power supplies are often used for redundancy, not for generating the needed capacity. 

I doubt this would work without rewriting a (large part of) it. You can see that this library includes "arduino.h", wich refer to a lot of arduino specific hardware implementation. What you can do is downloading the python library : 

Using the RPi GPIO, you can access many communication protocols and use them to transfer raw data : Serial Communication You can send datas from the RPi with the serial protocol to the android USB port. Transfert rate will be at best around 250kbps. Here is a sample of implementation : Android side : $URL$ RPi side : $URL$ I2C communication If your android device has a I2C interface, you can use also use this protocol, wich allows a transfert rate up to 3.2Mbits/s. As this protocol is not specially designed for data transfer, you may face some unexpected hardware limitation. Here a sample implementation : Android side : $URL$ Rpi side : $URL$ SPI communication If your android device has an SPI interface, this may be your best option. This protocol will work only with short cable in order to enjoy the very high transfer rate, from 25 to 50 Mbps. Here is the sample implementation : Android side : $URL$ RPi side : $URL$ 

This is often related to SD cards, I've had some "bad" ones in the past. These cards worked just fine for extra storage in a smartphone, but couldn't provide a stable disk for the Pi. You can check this Wiki for (community) tested cards, my experience is that these are correct: RPi_SD_cards 

If you're on the command line use . Specifically for CLI: Go to "Localization options" and "Change Locale". If you are on the desktop raspi-config is also available as an application. This is the default Raspberry Pi way to change the keyboard lay-out. 

If your wire coloring scheme is right, you connected the plus (red) to ground and vice versa. I see a red wire on GND (pin 6) and a black wire on pin 12. 

This might be a power supply that is just barely good enough. The APX803 gets triggered the first time, but not the second time. Probably a power supply that is just around the threshold. 

The point your are looking for is the difference between arduino pins (5V) and rapsberry GPIO (3,3V). With this in mind, we can deduce that every passive components (switchs, potentiometer) will be compatible, and most part of the active modules won't be compatible. For more details, you need to look at each module specification, and check for the component operating voltage range. By exemple, the datasheet of this gaz sensor show that the circuit has to be in 5V, so not compatible. Edit : a convenient way of solving this point is to actually use a arduino, powered and driven from the RPI USB port. This solution may also lower the RPI CPU usage, as some part of the signal processing may be put on the arduino part. 

Bonus tips : I'd rather use instead of . It's 4 times slower, but avoid some compilation errors (course scenario). You still can try . In cases of errors just use to remove previously compiled stuff, then run . I had some difficulties when downloading opencv and opencv-contrib. Instead of cloning the git, you can download the source in tar.gz format here : $URL$