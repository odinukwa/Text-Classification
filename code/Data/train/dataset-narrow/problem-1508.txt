Mains in classes I don't like having methods in non-application classes, which is what you've done in both your linked list and stack classes. Having a main method in the class blurs the boundary of what the class is responsible for. At a minimum it's responsible for being a 'stack' and being an application entry point, it feels wrong. Public interface Think about what it is you're trying to model and what that means for the interface to your classes and what the classes are responsible for. When I think of a stack class, I think of something that is going to let me push objects onto it and pop them back off. So for me, a Stack would at minimum have public and methods. Yours doesn't, the methods are private. I suspect this is because you're only using them from your which is in the same class. Separation of Concerns You linked list is asking the user to supply data, then using that to create nodes and add them to the list. This is too much responsibility for the one class and it makes it difficult for you to reuse the list in other ways. If you had a list builder that was responsible for driving the process of collecting input from the user in order to construct the list via it's public interface, this would lead to a more focused implementation of the list. This would for example allow you to reuse the list in order to construct the stack class. A linked list is an easy structure for implementing a stack. To achieve stack like behaviour, you always add new elements to the head of the list (push) and only allow the first element to be removed from the list (pop). You can't currently implement stack like this however because of the user interaction embedded in your linked list class. Bounds Checking Currently your push method on your stack doesn't check if it's going to overflow the internal array. This is OK at the moment, because the method is private, however as I've said it's odd for a stack class not to have public push/pop methods. If they do become public then they need to start doing bounds checking to prevent an overflow. Only implement what you need As far as I can tell, you don't use your method on the class. Try to avoid creating extra work for yourself by creating methods that you're not calling. It just gives your more friction if you decide you need to refactor the way your code works. 

Stack is a black hole from other code The first impression I get is you can't get anything back once you put it in the . and both return , so once you've put your value in with that's the end of it. I know your methods output to the console, but that's pretty useless to the rest of your program. When you're writing things like data structures try to put the user interaction outside of the class you're modelling. Both for input and output. This will encourage you to define methods that actually allow you to use the data structure in the way that you would in a normal program. With that in mind, at least should return a value. should return a bool. Depending on your approach, could also return the value popped, or it could simply remove the item (however if you go down this approach I would expect it to throw a exception if you pop from an empty stack). I would also be expecting to throw an exception if the stack is full. At the moment, the client has no idea that their value hasn't been added to the stack. 

The Interface You've done some good centralisation of the interface with some of the board elements , centralise the interaction so that you could replace these methods and maintain the core logic of the game. However, your interaction with the Serial interface permeates your entire code. If you centralised this interaction, then it would be easier to remove the dependency (for example to run it on a computer, or if you wanted to use different components in the future). Consider using function pointers There are various points in your code where you are calling different methods based on an index like this: 

As far as testing goes, you're sending to the same IP address so should be pretty safe but some things to try are: 

The first method is called from the Challenge class and the second is called from your test classes. This duplication is caused by knowing how to read information from the user. It would be better to only expose a single method, possibly or and have another class responsible (or the main method) for constructing the array from user input. This prevents the need the class to differentiate between when it's being called properly and when it's being called under test. This also removes one of the confusing aspects of your unit tests where you do this: 

Formatting The first impression your code makes is not a good one. The formatting is very inconsistent, which makes it difficult to follow and is likely to introduce bugs. If it looks like this in your IDE, then you really should expend some effort in fixing the formatting (any version of visual studio will significantly help with this). Copying and pasting the code into your questions, then selecting it and pressing Ctrl+k will format the block. Nested using statements Looking at this code below, which I've formatted: 

Initialise isn't protected When you start introducing threads to your code, you need to think about them being used in a multi-threaded environment. If the client application calls initialize from two different threads, it is possible for your class to have multiple initialisations. The second thread can enter the if statement while the first is still between the marked sections below: 

This would allow you to remove the assignments from the split clauses above to make it more concise. Copy to end You stop merging the lists after you've identified that one of the input streams is empty. At which point you copy the rest of the list across like this: 

Clean up after yourself Commented out code creates noise that distracts the reader. When you've got your code working, remove any commented out code. If you feel the need to retain it, use source control to maintain different versions of the source. You've also got an unused field declared . Again, if you're not using it, get rid of it. Be descriptive isn't a very descriptive name. It's a wrapper method for getting the calculation variables, so maybe would be better. is really checking for . Avoid over nesting Overly nested code gets distracting. One of the easy ways to avoid it is if it's possible to return early. So for example, your could look more like this: 

Next steps Consider allowing the user to set the difficulty (and varying the number of mines in the minefield accordingly), rather than having it hard coded. 

It checks for either or . The brackets define capture groups for each of those elements (?:) groups elements but doesn't capture the group. Using the above regex, along with , I wrote a little method to demonstrate an alternate approach to parsing the input: 

From the line grouping, it appears that lines 2 & 3 are supposed to be within the block, however only line 2 is actually in the dependant on the . Generally speaking it's better to always include the braces for statements, even if initially you only need one line, that way when you introduce the second line you don't introduce a bug. Magic Numbers Some people really hate the use of raw/magic numbers in code. I'm generally OK with them when they make sense in context, or if there's no better name for the value. If there is a better name, use a constant, however for things like the armor effect of items this might not be necessary (a constant is no better than using for example). That said, lets look at this code: 

Again, this suggests that there's scope for extracting a method here, that has parameters for the various variables (enemy name / health). Classes As well as extracting functionality into functions, you can also look at collecting data and functionality together in classes. Just looking at the line: 

Suddenly you're setting to ' ' instead of 'Y'. There's obvious duplication in your code, which will expand if you start reading more items / add more flexible parsing and error checking into the read. I would tend to write a function for splitting the input into two parts, the option name and the option value. I'd then write a function for parsing each type of option value (string, number, character). This would allow error checking to be done once, rather than for each specific value read. Whether or not this is needed depends on how much you trust your users to edit the file correctly. 

You could then have different implementations, for different types of user input/output. numberOfMines You're setting numberOfMines so that it's easier to use from your loop instantiations, however it's confusing. 

Any feedback's welcome. I'm particularly interested in feedback around any scalability issues this approach is likely to encounter, or if there is a more modern approach with C# for handling multiple clients. 

You can see that the using statement that you're initialising in is within the statement that you're initialising , however neither of them is within the using where you initialise . This inconsistency suggests that it is a bug, which is harder to spot because of the code formatting. Numbered variable names Adding numbers to variable names to differentiate between them isn't a great naming strategy. In your case, it could actually work as a way of pairing the variable with the COM port that it's associated with. However, you're assigning m_port1 to COM3 etc, which is just confusing. Disposing & member variables To answer your specific concern, disposing the SerialPort should be enough to clean up after it's resources, however the way you're using it is odd (and I'm surprised it is working). Your ports are member variables, but you're wrapping your constructor calls in statements. This should mean that the SerialPort is being disposed of in your constructor, and isn't in an appropriate state for usage from that point on, certainly not without opening it again. It would be better to either hold the serial port open (and have implement ), or not have the serial port as member variables, so that you can wrap calls in using statements. The right approach really depends on your usage and expectations, however it's worth noting that you shouldn't immediately be calling open again on a closed port because there is an expectation that it may take some time to close. 

Double checking You're checking that sample hasn't been updated at the end of your test. Do you really need to do that? Putting it together Putting all of that together, you end up with an actual test method that looks more like this: 

Means that the type has to provide a default constructor. This limitation is not imposed on you if you use the STL queue. As an aside, when you're comparing performance of two different systems and you want to use random numbers as part of it, you're better off not seeding the random number generator. This: 

If is null, then no bytes are added to the buffer, however the tail is still incremented as if data had been written. So effectively, whatever is already in the buffer is added instead. Having default to null suggests this might be expected behaviour but it seems very odd. print may be a debug method, however its output is confusing. As you pop from the buffer, you're reducing the number of characters from the buffer that are displayed however you're still printing from the start of the buffer. This gives the impression that is actually removing from the tail, rather than the head. You should probably be printing from the head instead: 

You don't seem to need the handle after you've performed the marshalling, so it could be as simple as updating the function to: 

This isn't a complete review, it's just a few thoughts from glancing over the code... Unnecessary casting on malloc You don't need to cast the returned value from . Adding unnecessary casts, adds noise to the code as well as creating potential problems with future refactoring. Clean up your comments Code for review should be presented in as close to its complete state as possible. With this in mind, commented out print statements that have helped you with your debugging should be removed. They add nothing but noise to the code and impair readability. Naming & Grouping Most of your operations that function on the linked list have prefixes which groups the methods together. Two of them don't and . If these methods are part of the same conceptual block of functionality, they should have the same prefix to complete the grouping. If they aren't, then in the header they should be declared below all of the methods, not in the middle of them (with below them). You also want to try to be consistent with your naming for functions. Pick a style and stick to it. Are you starting methods with capital letters , or lower case , are you using capitalisation to separate words or underscores . When you mix and match styles, it makes the code harder to read and predict if you're changing it. tmp or tail In , you're creating a variable, which you then assign to . 

This creates a layer of nesting for the else statement. You don't need the else. When the condition is matched, you return from the function. The only way you get past the statement is if the condition didn't match, so the else is redundant. Redundant checks In enqueue you perform: 

is never used again and is only ever used as an equality check to detect that you've reached the end of the list. Generally, it's better to name things so that they can be recognised, so isn't a great name. Particularly in this case, where you already have a variable that contains the value and has a better name . Lose and just do: 

Unless you want to release the capture from a different thread, in which case it seems like you're more likely to run into the 'Released by wrong thing` problem. Why do you need to know if it's captured? Try to capture the lock and if it fails, you know that it's captured... What purpose does the property really serve? 

I haven't finished looking at your code, particularly the guts of the actual 'telephone_book.c'. So far, overall the code looks good. It's easy to read and you have clearly put a reasonable amount of work into the code. That said, here are some thoughts I had whilst reading the code. Return values should indicate one thing Think carefully out what information you're hiding / returning. I'm running on Windows, and I don't have a environment variable set. When I run the program, rather than getting told something useful to help me diagnose the problem I get told: