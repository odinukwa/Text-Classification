Why do you pass the arguments to straight on to ? In my opinion, it would be better to only have do what the name suggests (which is getting/opening a file) and leave handling and to or another helper function (something like ). Also, you state that you have to check whether the program is called with too many arguments, but currently you only check for too few. Finally. the comment 

Well, you could make this work using . However, since you are implementing a quite low-level memory structure, I'm not sure I would suggest it here. In general, smart pointer usage is preferable to raw pointers; however, in a case like this where you have to manipulate the pointers themselves a lot (as opposed to the data they are pointing to), smart pointers tend to be somewhat clumsy and ill fitted. However, you should definitely make sure that you are doing memory management correctly (using static analysis as well as runtime analyzers such as valgrind, asan, msan etc.). There's nothing inherently bad about using recursion in a constructor. There are two different approaches to the copy problem. One is to treat as a dumb, struct-like class that does not much more than combining a piece of data with a pointer to the next node. In that case, it is fine to make copying nodes correctly the responsibility of . The other approach is treating s more like "smart" objects which have some ingrained behavior, in which case copying should be defined through the class. I personally prefer the latter, because it plays well with the C++ approach to OOP, and lifts some responsibility from . However, I would not say that the other approach is wrong, I just don't like it as much because it makes the overall burden on heavier. 

Language It's better to stick to English for all your class/method/variable names too, instead of a mix. This is to promote better understanding of your code by others who may not understand your native written language. 

The check before calling the method is redundant, as a will contain unique elements. Also, since Java 7, you can rely on generic type inference for object creation, i.e. a instead of a . 

You do not have to iterate through ... Alternative suggestion relying on the utility method from the class: 

Generic type inference Since Java 7, you do not need to make the duplicate specification of the generic type on the new object: 

You can even opt to daisy-chain the entire thing, from to calling . Just two more things to highlight from my code above: 

BTW, you can also rely on the method for to get the numeric values they represent, instead of having the extra field . Inside , you can also consider inlining the results: 

I'm guess there's an implied range of inputs such as all must be positive right? Because your calculation will yield the same hash codes when equals to , and having a bunch of negative and positive integers (or just ) will 'break' this easily. You may want to update your question with any assumptions on the range of inputs. How to reverse a I think that you can move your method into the class itself as such: 

Parts of this answer were written before Martin York posted his answer. Thus, there may be some points which overlap. If you find any of those points appealing, please give the credit to Martin York as he was faster than me. 

Design issues Apart from your program having undefined behavior currently, the thing that I most dislike about it is that your queue offers basically no usable interface. First of all, if I wanted to extract the size of a queue, I'd currently need an ugly template hack to get the second template parameter, whereas you actually should provide a getter. Secondly, the mechanism you devised of "get a single pointer to an element, then increment the position of an internal offset to the next element" is about as clunky an interface as I have ever seen. Neither can I get more than one element at once, nor can I go backwards, nor can I do random accesses, although the underlying container supplies all of this functionality. For a start, you should offer an iterator interface. Iterators are one of the core mechanisms of the STL, and enable your queue to work with most of the algorithms it provides (you'd likely need two different iterator types, though, one for read-only and one for write-only). Another feature that I'd really like to see is an interface separation. Basically, your class offers two different interfaces: One is read-only, the other is write-only. However, these interfaces are mixed together in a single class, which potentially allows somebody to do illegal actions, such as writing from a read-only thread. To prevent this, and enforce separation of concerns, it would be really nice if you had two interface-like classes (i.e. and ) which only export their corresponding half of the whole interface. Another point I want to touch on is the whole issue of copying and moving. As is, you simply deleted move constructor and move assignment operator, but this is lazy interface design in my opinion. There is no reason why copy should be forbidden (unless you can provide one), and even much less reasons why move should be forbidden. Neither of those two things seems particularly hard to implement for a data structure like this. Finally, I can not really come to peace with the design decision to force a double pointer indirection for the sake of avoiding copies. Of course, there are cases in which this is totally fine and appropriate, but in those cases you'd simply make the content type of the container and would have basically the same solution to the issue as you have right now. Since you seem to be very focused on performance, here is a point that might convince you: Forcing a pointer means forcing another level of indirection. Chances are, all those objects you create with are living in different parts of the heap, which makes it nearly impossible for the cpu and data prefetcher to get all those values into cache in time, meaning you are probably going to end up waiting a lot of cycles on memory. The more your data structure is fragmented, the bigger the chance that you will completely kill your cache and end up taking more time just waiting for data than it would actually have taken to copy all of those bytes over. In addition, if you consider move semantics, you can actually avoid a lot (if not all) of those copies and turn them into (comparatively) cheap moves. (Disclaimer: I haven't done any benchmarks on this. This is how the situation might pan out on a modern x86_64 processor, but I don't guarantee that any of the possible effects I've listed will be observable.) 

Variables assignment You have declared right at the start, but it's actually redundant as you can simply from the method directly in the places where you use them: 

And if you will like to make it even more 'generic' and cater for non- types, you can specify a to do so: 

Convert into an (or not do the conversion if you started out as an ). Consider if you need to apply installments or not. Math. 

In this case, if the last index of the character at position is indeed , that means we have found our unique character. 

I'm going to build upon the two answers provided by @wei2912 and @Heslacher and attempt to flatten the statements. Let's assume we have the method in @Heslacher's answer. Looking at the somewhat simplified logic: 

A step further is to combine it with , I'll leave that as an exercise for the reader. Finally, a small nitpick: is spelled wrongly... it should be . edit Further review on and the actual 'program'... The other weird things about are that you are repeating your decoding across two different loops, and carefully interpreting and handling for when (which isn't 'documented'). Also, since you mentioned that you prefer a more -like solution, perhaps you can consider the following too so that you can even not depend on and : 

corresponds somewhat to and takes the underlying character type as a template argument. Your former classes and are now only aliases for certain template specializations, just as and are. (In my code, is kind of hidden away inside an namespace. If it serves your need, however, you could also make it part of the public interface of your program library, allowing further specifications such as ) 

Yes, there is. In fact, a very nice way to solve this code redundancy issue comes to mind if you consider that is a just type alias for and an alias for . Likewise, and are also just aliases for and , respectively. This allows for an easy template-based approach to the problem. What really suggests itself to me is keeping this alias-of-template-base-type pattern from the STL (although there may be other valid approaches as well), an implementation of which could look something like this: 

What is the purpose of shortening the term "Prime(s)" to Prim in your method names? IMO and are more readable. The same is true for etc. can simply be Your spacing is inconsistent. Generally, it is recommended to leave a space between a control structure (, , etc.) and its following open paren, which you adhere to exactly once in , but not elsewhere. The same applies to operators: Write instead of . Your method is grossly overcomplicated. First of all, you check every number up to for divisibility, while it should be obvious that there can be no divisor greater than . Still, if you think about the problem, you will soon arrive at another conclusion, which is that you only need to check numbers up to , because you can write (with and being positive integers), which is to say that and are divisors of . Now, letting , and by thinking about how multiplication behaves, we can conclude that either or must always be lesser or equal to while the other must be greater or equal to , because when either or is smaller than the total product would shrink unless the other one grows to counteract this fact. The next problem is your use of a array, which is completely redundant. You do not need to store the result of the division test for each number separately, but you only have to keep track of whether you have found a divisor for (=> is not prime) or not (=> is prime). All in all, I would rewrite the method to something like this: