You have a list of quesitons in the table. Each question can have two or more possible options for answers in the table. For each option there are one or more category score changes which are noted in . When a takes the quiz their answers (i.e. choices of options) are recorded in . Note that with this design you can change someone's score in multiple categories with a single answer (such as in your example of reading WIRED magazine) and you also have the option of changing someone's score in a category by an increment other than 1 (as in your example of not having taken an art class). You could even change someones score by more than 1, for example in your question 1 you could score +10 in the science category for prefering to read Philosophical Transactions of the Royal Society! 

There are two ways to look at this, the informal way and the formal, theoretical way. The Informal Way: If something is of so much interest to your system that you want to record attributes about it, then it probably belongs in its own table. If the only thing you care about Social Security Number is what digits it contains (i.e. what the number is) then this number is best modelled as an attribute of something else (e.g. PERSON). If, on the other hand, your system cares about other facts that pertain to SSID, like maybe when it was issued, which office issued it and whatever else you might know and care about an SSID, then you probably want to split everything you know about the SSID into its own table and then relate that table to PERSON. The Formal Way: If the rules of normalization demand that you split your multiple facts (attributes) about an SSID into a separate relation (table) - of which the social security number is the primary key, then SSID is a box and not a circle. Specifically, if you have attributes which depend solely on the SSID then you would want to remove these from a PERSON table because they would have only a transitive dependency on the ID of PERSON and therefore 3NF demands that these attributes be removed to a separate table. 

Relational databases are not built to handle this situation perfectly. You have to decide what is most important to you and then make your trade-offs. You have several goals: 

Do you have a reason to store the searches as individual events or are you only interested in recording which terms were used how many times on any given day? If you just need to record how many times each search term is used on any particular day, then the most compact schema would be: 

The answer is a little bit like the old joke: "Doctor, doctor! It hurts when I do this." If you want a foreign key to an entity then that entity needs to have a unique key defined to be referenced. The fact that your table has a unique candidate key in should not prevent you from defining another candidate key that combines ExpectationId and BranchId. This seems like a violation of third normal form, and technically it is. However, that is only true because you happen to define ExpectationId as unique. You could have defined ExpectationId as a sequence within BranchId, such that ExpectationId is not unique on its own. As it is, you can think of it as the table defining the combination of two unique values as being the fact of interest. In any case, if you want to define a foreign key to that is the combination of and then there is no way around it but to define the primary key that way. 

I have a few observations and suggestions: Do not create a table when all you need is an element (column) for the date of the . Generally speaking, a table with nothing but a meaningless ID and one other column is a good indication that you need to look hard at whether all you really need is the non-key column. Consider , this also has just its ID and the category description. Is this a good candidate for an independent table? There are two things to think about: 

I think you should model it as "door number three" - something else. While from a vehicle sale perspective you have a trade-in allowance (dollar figure), that is not where the interest in the event ends. Each item taken in trade becomes an inventory item that has to be stored and eventually disposed of. Although it is rare, it could happen that more than one item is taken in trade. I would model a trade-in as a separate table (optionally?) linked to a sale. This gives you something to link other events and/or items to, such as inventory, valuations, work-orders for repairs and any other activity relating to accepting and disposing of the traded vehicle. 

Here the columns of the table are just the two primary key columns from and . These two columns will jointly form the primary key of the intersecting table and will also each individually be foreign keys to their respective tables. NOTE: Don't add any other columns to the table, unless those columns can reasonably be expected to vary row by row for the same paper and for the same author. For example, it would be a bad idea to add a date to the submission table unless a single paper is submitted at various times by multiple authors. If you need to track information about the event of an author or group of authors submitting a paper, then you need to normalize out the extra information to avoid creating update anomalies. Consider the following: 

There's no single right answer for any performance question. The answer is always that query optimizers are very smart, to a point. So the most efficient design or query will depend on the number of records, what kind of indexes you have, how selective they are, and many, many more factors. If you want to avoid keeping both bounds of your ranges, you can search using TOP 1 and order by lower_bound but I wouldn't expect this to be efficient necessarily. I'd suggest profiling it this way to see if the performance is acceptable. Having an index on will probably help, depending on the number of records in your table.