There are a few things you can improve here. Unless all your classes are in separate files, you do not need to do around each class. This is most unnecessary: 

is bound to the selected item in my display ListBox with two-way binding, and the is bound to . Please note that this is the Windows Store subsection of WPF, so I cannot just use a TreeView - that is why my submenus are prefixed with spaces: 

is the last line of code in both blocks, and can be moved to immediately after the block. It does not appear that the duplication of can be removed without reformatting the output, so that is OK. Use more functions As already mentioned by TheCoffeeCup, you have huge, poorly formatted methods. You may be able to split these up into smaller methods controlling a smaller section of the program. For example, in the above mentioned code block, you could split that into a method for the win condition and a method for the lose condition, making your methods smaller and responsible for less. That block comes from a function named , but it gives status updates as well as checking. Naming I don't remember ever seeing snake_camelCase used before, as in . You should probably name that with just snake_case, as in , instead. 

I don't know PHP, so this won't be a comprehensive review. However, this statement really jumps out at me: 

Tunaki makes a very good point that your and groupings should not be part of a card instance. However, I disagree that they should be kept as strings. I would make these groups into an . 

That has a lot less duplicated code. You should consider splitting it up into a couple methods as well, instead of having everything in one method. Third, never delay your program like this. Consider if you were marketing this project, and I built an identical one, except I didn't delay - which would you pick as the consumer? Probably the one that was faster. Fourth, I would probably merge these two s: 

For your XAML, you do not need to put each property on its own individual line. I typically only break them up when they do not fit on my screen all at once, more like this 

Also, I'd make that (and most of your other s) a guard clause and remove the extra level of indentation: 

That assignment only assigns , is unassigned. As I mentioned earlier, these are redundant anyway, but you should know about this behavior. If you want assigned too, you have to do . 

I really hate that humongous in . Should that be a // series, or is there a better way to do it entirely? 

The VB.NET version handles more diagnostics because the two compilers have a different set of diagnostics they report for different cases: 

I needed to find whether any image's width at or higher than a certain directory folder exceeds a limit. Is this code a good way of doing this, or is there a way in which it can be improved? I ran it over at least a couple hundred images and several hundred other files contained in the main directory (not , but I don't want to show my user name), and it completed so fast the time is irrelevant. 

There is similar code for each setting, but this is a good representation of it. It doesn't feel right to use an to represent my theme; should this be an ? Please tell me all the problems now so I don't have to refactor again later. 

Also, use the correct indentation, fix your braces, and you should add braces to your / block like this: 

You should use the method. This will assign the value to the if possible (an argument must be assigned in the method), and return a Boolean value for success: 

My first FizzBuzz question (well, I asked, then deleted, one previously), and my very first VB.NET question. 

But wait a second - there is a built-in way to do this in a single statement! This method is in the namespace, and can be written like: 

The check in the is unneeded because you check it in the above. If it is false, your logic will never get past the first . 

I also have this version, which also runs in 0 milliseconds. In fact, running both methods in the same timer together results in 0 milliseconds: 

Is this a good way to implement this, or is there are different way? Is there a way I could call and override the equality operator used to check it? I already tried overriding the operator, and that did not work. I will have a second soon as I finish implementing my ViewModel, so I would like to know a generic solution, but if I have to write a second method to get the value from that collection, that is OK too. 

The indentation on your CSS and JS is also erratic. One excellent thing is that your HTML and CSS validates to the W3C validators: 

It is just easier to read this way. Also, you should have each element have its own line, not put many on the same line like this: 

Now, you can't accidentally break your code by typing instead of , and it is immediately clear that you want each flag to be its own bit. For more information, you can read this blog post by our own @nhgrif. 

My views are all either static information or a simple iteration over a list of data; here is my view for the above model class: 

Finally, it is not good practice to always include because sometimes names inside namespaces overlap, which causes compiler errors or undefined behavior; instead, you should specifically specify which namespace you are using by placing in front of the name. 

I have this set up with a very basic algorithm for the computer to play (random-selection, hence the title--you'd have pretty bad luck to be fully sunk). Next, my plan is to create a interface with two classes implementing it ( and ). This will help clean some of the muddle of the module up, and will make it easier to implement a better algorithm for the computer, and may make it easier to let the user choose to play the computer or another person. Some of my specific concerns about this is that I may have implemented this in either a too-C# or too-OOP manner. I'm not really familiar with functional programming or F#, so feel free to comment on anything that should be done differently. 

You iterate the list and create a new list based on the action, but return the original list and do nothing with the new list. Unless has side effects somehow, in which case you should the result of the . Given the name of the function, it looks as if you really just want a result, so you can return a , which is essentially the same. The literal in F# is , but you can also get it by returning a from another expression. Give these assumptions, I would write it as: 

I don't think those will ever return any results because you only have and . Later, you filter out the ones for your loops. Just don't include those in the first place, because they are never used anyway. 

Overall, your naming is pretty good. is an excellent name, but , , , and in aren't so good. I assume the and stand for and ? Why not name them that directly? 

The model is any supporting methods and other objects, such as enums, that you use. Now you can also write unit tests to make sure everything works (you may want/need to use Moq or another unit testing framework with this). 

It takes a little bit more room since I wrote the loop body on its own lines, but it is easy to understand, and there are no assignments in the loop condition. However, this is still not the way I would write this algorithm. When you think about how works, it iterates the string with a loop from the specified starting index until it reaches the first instance of the requested character, which it returns. We can write similar behavior, but just keep track of which index we are at: 

Edit: The above is for FireFox, I didn't see the Chrome only section; however, it displays correctly in both FF and Chrome, so you may want to consider using it. It also displays almost correctly in IE, but you should make the track as tall as you want the button to be in this case because the thumb is designed to be no taller than the bar. To get rid of the properties in Chrome, you should change the class to this: 

According to the HTML validator at W3C, you have only one other problem. You should not use a closing tag; you should just leave that element open. 

Working on VSDiagnostics, I implemented a tool that adds the default access modifiers to C# code. An example use would be starting with this: 

This is the skeleton code for for reference. This is not the main focus of this post, but this also has a similar problem, so suggestions to solve this also are welcome - preferably if they kill both with one stone: 

Notice that if you have a function that takes a single parameter and returns a new result, you can just place it inline like the way I did above. Another way to write it would be using tail recursion: