I'm completely lost on how to go about masking it, so it does not show up past the bounds of the box. The code I used to generate it is heavily based off of Unity's, it's a bit long and kind of hacked together at the moment, I'm including it for references sake. The method that generates the verts for the highlight in the .gif is 

The gist of it, is it creates a new gameobject. Adds a canvas renderer, and rect transform. Calls the appropriate method that generates the vertices, and then assigns those to the `CanvasRenderer. 

I'm trying to make a simple chat system for our games lobby, however I am having issues making a text box that allows for text-highlighting. The Text component does not have interactible text, and the Inputfield allows for interaction, but I don't want the text to be editable in any way. How would I go about doing this? 

I just got Vectrosity for Unity and need to make a line of all the destinations for an object. Issue is that I need to use a single list of vector3's to create the line (as far as I'm aware). I have a list of vector3's that is the objects queued destinations. I then need to insert the objects current location at index [0] in the list so that the first line point is at the objects location. Issue is that no matter how I try and accomplish this I'm still referencing the original destinations list, and inserting something at [0] on the list for the lines changes the original destinations list as well. How do I go about creating a single List from a list of vector3's and an extra point without changing the original list that is being referenced? Do I need to clone it? 

I'm trying to figure out how I can make a custom UI element identify when it has been selected or deselected. Classes such as inherit from the and and their methods and are called whenever I click inside the element and click outside of it. From my understanding, inheriting from the appropriate handler interface and implementing it's required method will allow your class to handle events from the . As an example if I have: 

Turns out that I had pixel perfect enabled, without it enabled this solved the problem I was having. 

After coming to the realization that some things I wish to do in a 2D RTS are easier to do on the X-Z plane instead of the default X-Y plane, I'm considering moving my game over to the other plane. What I am wondering, past the scripting changes to accommodate the different plane, is what specific challenges will this cause for a 2D game (using 3d physics, not 2d physics)? I did a test and flipped some assets to the X-Z plane and things seemed to work just fine, though I am not sure what unique challenges I will end up facing are. All our objects will have a 90 degree X-Axis rotation so that their sprites display. 

Right now I run a quick check against all nearby units to determine their distance from a turret on the friendly unit. I was thinking raycasts, but I imagine raycasts every frame for up to 10 detected enemies per unit (Each unit will at max hold onto references of 10 nearby enemies. I could have 100 friendly units within range of 100 enemies) would chew up a fair bit more CPU than just checking their cached transforms. Suggestions, ideas, or comments? Edit: More Detail Currently a Unit has a trigger spherical collider that defines it's view range. Any enemy unit within this view range is added to a collection based on priority, with a maximum of 10 objects referenced per collection (each Unit can only be aware of 10 enemy objects). From there, each turret on ship checks the distance from itself to each of the enemies within that collection. When the distance is <= it's attack range, it will fire upon whichever enemy object gets within it's attack range first. I used to use spherical colliders for each turret, which of course would detect the enemy as soon as any part of the enemy entered the trigger collider. The issue was the massive performance loss due to OnTriggerStay() begin called by hundreds of units, tens of thousands of times per frame when I have no need for the method. So I discarded the extra trigger colliders for a more performance friendly approach. The issue is that the range check is that is checks the transform.position of the enemy. This does not take into account the collider that makes up the enemies shape, and will only trigger when the center of the object enters within range. 

As I'm developing our game I have asked myself a couple times "When we have more than 1 player, how will I ensure events from player A do not crossover to player B?" As an example, lets say player A clicks on a unit. This publishes an event with data on the click location, the type of object it is, and the player that clicked. This can be received by lets say a selection manager script that just keeps track of what is currently selected for that player. The problem now, is that this event is received by every player. Every player will receive this event and try and select that object, and perform various tasks along the way. Is there a method of programming in unity to ensure that an event is only subscribed to by classes that have the same player component referenced (only the appropriate players methods will be added to the invocation list of delegates under the player)? Or will I just need to create a check at the subscribers to these events to only accept the event data if it's the same player? ie. 

I use raycasts to determine hit objects and object selection in our game. I want these to be blocked by UI elements. Before I had a crude form of that where I just excluded rects of the screen, though with a non-rectangle shaped UI that's pretty difficult. I want to have physics raycasts NOT go through UI objects, can this be done? My initial thought it adding colliders to the UI objects, though I'm not sure if the colliders will scale with elements based on screen size. Note: Canvas Group does not apply to physics.raycast 

I need some conditions for submitting the text inside of an Inputfield, however I cannot find a way to do this via code. I was expecting something simple like with WPF or WinForms, but I cannot find any method I can use to actually submit an Inputfield via code. How can I submit an Inputfield through code so that I can add some sort of conditions to when it can be submitted by the user other than just the enter button. Thanks! Edit, some clarification: Submitting an input field is submitting it's text, firing an event which can be listened to by the OnSubmit method which then fires an onEndEdit event (I think event) which you can add listeners to so that specific methods of your own get called when it fires. Right now I am unable to identify a reasonable way to change the keys or combination of keys that control when the form is submitted (Default ie "Enter" or "Return" in the Input Manager) (Can't use Shift-Enter for a new line since enter submits the form). Instead I want to manually submit the form through code when the appropriate keys are pressed. 

Edit: This exact code will present a bug if your fire delay, and the delay for your animation are exactly the same (say you want to shoot every 2 seconds and you want the animation to change every 2 seconds at the exact time of the shot, which would probably work against what I believe you are trying to accomplish). You can fix that by replacing with that will casue the animation to change back from firing to not firing 1/2 way between shots. 

I managed to figure this out. You need to manually tell the that the object has been selected. On a method such as you need to call the method and pass in the event data and your gameobject. 

So, I'm starting to introduce attacking to our 2D space RTS (This is in Unity, so it's component driven). Initially it was as simple as "enemy in range, damage applied". However there will be multiple "types" of weapons/attacks that are associated with their particular ship or structure. As well as other factors involved past just raw damage such as the damage type, and possibly inertia in the future. Would you guys have each unit and structure type have it's own attacking type. Meaning you make a script for each unit/structure that defines it's attack type, damage, effects, range, particles, sprites...etc And attach that as a component? Or make a script that defines an attack type, a script for the projectile type associated with that...etc And then extend those and modify those for each unit, attaching each script to the unit/structure. 

I'm trying to create a quad at runtime and I'm encountering an issue where the mesh does not show up in the scene where it's vertices where set. In the following picture you can see the ship, and to the far right the mesh. The 4 white dots around the ship where drawn after the mesh was made using the 4 vertices of the mesh. 

I've been trying to get my head around how to create a selection box for a selected unit in a 2D top-down type game. When you click on a unit, a small box would appear around that unit based on some sort of box-size. 

I've been puzzling over how to do spatial awareness for units and buildings. I've asked a few questions and the final conclusion was spatial partitioning in the same manner used for collision detection. So an object knows if something is close to it and can react appropriately (such as attacking an enemy) I'm making sure this is what I expect it is, so that my monetary and time investment in reading materials is not a waste for the purpose of completing this game. 

When the mouse enters and exits the element the and methods are sucessfully called. However selecting/De-selecting the element does not cause the or methods to be called. Though if you look in (which inherits from ), the method does successfully get called when the input field is selected. I'm trying to replicate this within my own element without having to inherit from , and since Unity's event system is publicly accessible this should be possible. Are there other requirements that will enable those events to fire and call my methods? 

If you have inherited from and the method will be called, and if you click off of your UI element onto the background or another UI element the method will be called.