You are iterating over key ("kee"?)/values of a dictionnary but ignoring the actual key. The convention is to use as the variable name for throw-away values so you could write : . However, it would probably be better to just iterate over the values using , or . 

This seems to be working better but can be improved. Indeed, the pythonic way to loop over containers is not to used indices. You can make your code safer, faster, clearer and shorter by writing : 

Be lazy At the moment, you get the elements of each tag only to see ignore it in most cases. You could move that logic behind your . 

Clearer algorithm You don't need to handle arrays to know whether a number divides or not anyther number. You can just use the modulo operator. 

Code organisation You've tried to split your logic into smallish functions which is a good idea but you could go further. You should try to write a function that handles the input/output part and a function which takes a well defined input (with the most relevant data types as an argument) and computes whatever needs to be computed before returning it (such a function should not do any input parsing or print anything except for debug purposes). In you case, the most logical input such a function would take is the queue. The corresponding data type would be a of and the return type would be an integer (or None). If you do so, you have smaller independant logical parts which are easier to understand, to maintain and to tests. Among other things, you can write unit tests based on the examples provided to ensure the computation works well. In you case, moving the different pieces of logic around, you get something like: 

This could also be applied to but I do not quite understand what you were trying to do. List comprehension (again) It would probably be worth extracting the conversion from in a function on its own and then use it in a list comprehension. 

Now for the algorithm itself, I must confess that I have troubles understanding what you want to do as you seem to be calling "pandigital" two different things. In any case, I have the feeling that something is wrong in your code, it seems like : 

I am not sure it is very clear to you what your different functions are returning as you seem to be trying to print their return value even though they do not return anything special. You do not need to change your variable names in each function without special reason. and are decent names in your case, you don't need to use and later and then and as there is no way to get confused anyway. The way you use your variable is pretty cryptic to me. I guess this is just some testing/debugging but it would help if you could submit a clean version of your code for reviewing. Most of what happens in your function is (pretty much) the same from one to another. A good thing to do is to try to avoid repetition whenever you can and to abstract common behaviors. The quick and dirty way I've used to avoid such a repetition was to notice that you ask the user for 2 numbers anyway so it doesn't really matter which operator we will use them for. My minimalist solution stores things in a dictionary (you could improve the content of the dictionary if you wanted to have more things changing from one operator to another such as user prompts). 

Now, the first check begs to be rewritten as a range check too. A cool thing to notice is that cases such as as properly handled by because the second term will correspond to "". For that reason, we can simply write : . Then successive range checks do not make that much sense : it is probably not interesting checking if is bigger than 21 if we know it is stricly bigger than 20. Similarly for 100. Then, the whole logic can be rewritten (adding some logs you might find useful): 

Tests Before trying to make things faster, it is a good idea to write automatic tests. At the moment, your code relies on input, output so it is not really easy to tests. It could be nice to separate the concerns: the input/output on one hand, the logic on the other hand. Let's write a function to perform the logic. Now, we can reuse data from the problem to write a few tests : 

A last remark Your "sieve" considers 1 as a prime number and for that number, you added a hack to change 1 into 2 in the inputs. This is not required anymore and once it's removed, everything can be included in a single list comprehension. The code becomes : 

Just like in other quite similar question, I find the already existing code slightly weird but I'll comment only on the code you have written. find_closest_state 

Single value provided to Instead of builting a tuple with a single value via , you could directly write . Loop like a native again Instead of writing a to loop over integers, you could use . 

Diclaimer: the comments in this answer will be in a fairly random order. Also, because of the random AND interactive aspects of your code, my comments are not very well tested. Iterable unpacking The functions return multiple elements. You always store these in a variable, then access each member individually using the syntax. A more concise way to do so is to use iterable unpacking and write something like: 

Other ideas At the moment, we have the snakes represented in 2 ways : as a list of body parts (which makes sense given how convenient it is to make the snake go forward) and as a drawing on a grid (which makes sense because it is our input and our output). Also, for every step forward, we need to update both representations. Maybe, it would make sense to keep the listy-snake (and other data you might need) during the computations of the different steps and only generate the output grid at the very end. As an exercice, I've tried to do this. I went for an object approach to store the different data needed and interact easily with them. I've tried to keep as much as possible from your code: