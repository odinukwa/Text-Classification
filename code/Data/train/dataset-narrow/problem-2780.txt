An array on the enemy that keeps track of what fire ball has hit it and check against it every time there is a collision. As you have already suggested: an array of identifiers of enemies that have been hit by the fireball. 

In your situation, having states within states is perfectly acceptable and is often the expected architecture. Here is something to think about: generally, during development, you could start your game directly in the "play" state (you set up a bunch of parameters that would normally be set up by the previous state), and you make the game end instead of it going to the next state (the one after "play", e.g. leader boards display, share on your social networks, etc.). This makes your "play" state a self contained activity. Making the play states member of the game state machine would break the encapsulation of the game logic, and force you to use unclean code in state transition. 

Now, this is assuming that the copyright holder has not released their material to public domain. I guess that if they said "We're done with the franchise, here are the assets, do what you want with it, good luck and have fun", you probably could use the sprites. 

For that kind of behaviour you generally Rotate about the origin, then Translate, then Scale. Since you want to rotate from the center bottom of your quad, from the origin you'd: 1. Translate the image to have its center at the origin () 2. Rotate 3. Translate to the desired location I'm not familiar with the inner works of OpenGL (I work with a rendering engine), but your first translate ( does nothing, it does not translate anything because of the values are zero. I think your intention was to "set the origin at (0, 0, 0)"; to achieve that, I think you need to set the current matrix to identity instead (). So in the end it would look like: 

The best way to gain intuition about how a matrix behaves is by determining its effect on the standard basis vectors: 

Ease of use: simply switch each frame to animate a sprite. There are already many tools developed for generating sprite sheets and animating them, many of them available from the Unity Asset Store. Doing so opens up a huge amount of productivity for a simple game. Easy collision detection: Since each sprite is defined by a frame, it is trivial to use that frame as a bounding box in your world. If your sprites have alpha, it's not too difficult to preprocess the non-transparent pixels to use as bounds. Comparing collision against bounding boxes is very fast as well. 

What you're looking for is something called "seamless" textures. Here are some tutorials for popular image editing programs: 

Model Space: Also known as "Object Space". This is the coordinate system local to any object in your game. If I had a character, then his model space would not change regardless of where the character was or what direction they're facing. The best way to think about model space is "The character always knows what is three units in front of him" World Space: The world space is the relative location of all objects in the world. When a character moves, his position in world space changes (unlike his position in model space). Usually when you need to deal with physics or other game logic, world space coordinates will be the best way to determine relationships between your objects. View Space: Also known as "Camera Space" or "Eye Space". This is the coordinate system relative to the camera. In this space, the camera is at the position (0, 0, 0), and the direction of the camera is the z-axis of the coordinate system. This is the space in which culling takes place. (For example, we don't need to render anything with a negative Z value, since it would be behind the camera). Screen Space: This is the (X, Y) coordinate system of whatever screen you're displaying your graphics on. Your mouse coordinates, for example, are given in this space. 

One way you could achieve what you need is to add a "priority" attribute to your GameObjectComponent; then add a mComponentsInOrder vector to your GameOjbect and keep ordered references in order, and sort it when you add new components. 

This is not morse code. You don't need a library to do this. You could achieve the same effect by having a sound file that has different lengths of beeps interleaved with silences. The sound file must be loopable. When the text starts to be written to the screen, you start the looping sound. And when the text is done being 'typed' to the screen, you stop the sound. I would suggest you find a web site that offers free to use sound effects, load it in your favourite audio editor (Audacity could do the trick) and modify it until it fits your needs. 

I would keep track only of the things that the player has modified. For example, if your player starts at position , you know how to generate the radius around him, so, for instance, tiles through are generated as pink tiles and displayed. Now, since the player only went on tile , you make it as a white tile and keep only this information in a data container (for instance a or a ). If he places an item, you also keep that information in another container. (Or you could have your data able to keep track of both.) Then, as your player travels, you add your data about the tiles he travelled. At the same time, when you "create" a new row or a new column, in fact, you just show temporary information that is easy to generate "on the fly" (the pink tiles), and then you query your data containers to check if he's already been into the "generated" tiles, and modify them accordingly. For instance, your player goes from tile to tile . This creates 4 white tiles in your data container. When he steps back on tile , the column 0 has to be re-generated. Which you do: all the generated tiles will be white tiles, but since you know you'll display tiles through (the whole column the player can now see), you'll query your data container and see that you have to put the tile at as a white tile. You'll also query you items container to see if he placed an item on one of these tiles. Here is why I'd do it like that: 

First, if you've set freeze position on the rail tracks, why do you have them set to react to gravity? Second, make sure that your train and tracks are not positioned so that they are initially colliding. The way you can do this is to keep moving the train up until it simply falls to the tracks. Third, I'm not sure that metal is the material that you want here. I would suggest making your own physics material and experimenting with the properties. In general, your objects should have a very high coefficient of static friction, and a not so high coefficient of dynamic friction. Play around with the settings to see what feels right. 

Hence, we see that gets scaled by , gets scaled by , and stays the same. Since we don't know whether or not equals , or even if they are equal to one, this is a skew matrix. If we perform a similar analysis to the matrix 

The key takeaways from this are: Your serialization code should always write the most up to date version of your game state, regardless of what that is. However, it must also write what the most up to date version is so that future (and current) versions of the game are able to know how to read the file. The deserialization code gets a little bit messy with this technique. It takes a very defensive approach to reading save game files. There are security reasons (i.e. buffer overflow) for why this is a good idea. It also reduces the risk of reading a corrupt save game file and loading bad data and crashing (or worse, not crashing). For debugging purposes, however, you should make sure to be as verbose as possible for why a saved game could not be read. This will save you many headaches in future versions where you thought a thing should be a certain way but it isn't. This system proved to not only be very effective, but I had a very easy time maintaining it. 

This is only to show you why you should throttle the frame-rate yourself with one of the other methods that you've seen. 

Keeping in mind that in a perfect market, one has to know everything about the market (this includes of course price and quantities available): With a local market: 

What is could give you an idea on the fitting. A distance of 0 would mean the user was straight on the line all the time. Now you'd have to do some tests to see how it behaves in your context. And you might want to amplify the value returned by by squaring it to penalize more the large distances away from the line. I'm not familiar with unity, but the code in here may go in a function. And you might want to add somewhere in there some code to prevent registering a point if it's the same as the last one registered. You don't want to register stuff when the user does not move. 

Generally, if you know your object will not be displayed, you should not send it to the graphics card. Culling on the CPU removes some work to be done by the GPU. For a few polygons, it's ok to send them (as Krom Stern suggests), but in my experience, if you start to do some few polygons here, and few polygons there, you can end up sending uselessly many polygons to the GPU, which will have to take the time to realize it does not need to work on it. A good habit is thus to not send them. 

You can use your texture coordinates, and set a uniform that tells you the aspect ratio of your rect, and the desired width of your border. Then, you can just check to see if your pixel falls within the bounds of your rectangle. 

I'm sure there are many more, but the moral of the story is that you need to measure how much impact a specific rendering algorithm has rather than trying to analytically find a solution. The non-determinism of GPUs is going to throw any calculations you make out the window anyway. 

For each agent, assuming that it is stationary, calculate all of the velocities that would cause it to collide at any point in the future with any of the other moving agents. This can be represented in "velocity space" as a set of of intersecting half-planes (also known as a velocity obstacle). Determine the point in this space closest to , this is the new velocity of the unit. 

Development: You need a separate skill set to properly implement animated skeletal models. This is something that is sometimes hard for people that are used to sprite animation to handle, but with enough practice everything works out. Implementation: Although Unity will handle most of the heavy lifting for you, if you want to implement skeletal animation, you have to figure out how to specify which animations will blend with which other animations and integrate that into your game and event system. This isn't a trivial programming task, but again, Unity should take care of that. 

Instead of having long segments, you could try to alleviate the issue by using circle shapes. You'd have to reduce the angle of freedom for your joints, but since you'll have more, you'll end up with the same result. The third option I see is instead of using rectangle sprites, try and make 'capsule' sprites: a rectangle with half circle on each end. This would still have "angle-ish" joints, but at least, you won't see the rectangle separations. 

Your issue seems to be coming from the fact that you are using degrees to calculate your rotation instead of radians. Here would be a way to fix your issue: 

I'm not familiar with flash/as3. This said, I fail to see what instance would be the parent to the child you're adding with in a method. Here is the description from the documentation 

In this example, is assumed to be in seconds. In Unity, the seems to be fetched by using . Also, note that the score is now a floating point value (because everything else is calculated in floating point values). You'll have to convert that to int before displaying to the user. Everything in your game that happens over time should be done in that fashion. 

I know a game team who used free audio music; I'm not sure what was the name of the site, but the idea was that you had to say where the music came from in the credits. As for the sounds, you can find free audio effects online. Or you can learn the basis of a software like audacity and create sounds using your imagination (and use audacity to achieve what you need). I remember some sounds in a game I worked on are originating from hmm, my mouth, or a tap of a spoon on my work book. Music composition is really not an activity you should invest time in, but learning how to modify and tweak sounds in a free sound manipulation program like audacity is a skill I would say is a good "rope to your bow". P.S. If you really need precise music for your game, I'd suggest you try and partner with a free/cheap music composer and get something exactly suited for your needs. 

To answer your first question, yes it's quite possible to load an ETC2 texture on any OpenGL ES 3.0 device. In fact, it's required by the standard. In order to do so, you replace the function call with . For more details, read the documentation. Currently there aren't that many texture compression tools that support ETC2. Off the top of my head I can only think of one. That compressor uses the stock ETC2 compressor that Ericsson released a while back. I believe that the tool can output textures in a KTX file that comes with a codec implementation. If you want to do compression online in the app, you may be out of luck. A preliminary search on the internet shows that ports of etcpack exist but I've never tried them. In any case you should be able to expect a decent quality compression of a 1024x1024 sized bitmap within 60 seconds of any codec worth it's salt. 

Shrink your texture by one pixel in all directions Manually add a red border Set the texture wrapping mode to clamp 

I wrote the save game system for Disney's Guilty Party. I can give you a high level overview of how it was done. Although it was shipped as a Wii game, for debugging purposes we needed a save game system that worked both on the Wii and on the PC. Disclaimer: this is the only time I've written such a system, and by no means can I claim that it is The Standard Way(tm) to write a save game system. It is more of a case study. From a purely design standpoint, binary files are always a hassle. For one thing, they are extremely hard to debug since you have to open the save game files in a hex editor. Second, you cannot download a save game file generated on the console and open it on the PC without making sure that your endianness is correct, which requires you either to A) have duplicate serialization code for big and little endian machines or B) wrap your serialization code in swapBytes() calls that switch things based on the endianness of your machine. Both are clunky. Hence, we were looking for a save game system that had the ability to 

Make sure the amount of doors in your level is even. Put all your rooms in the not-door'd set Pick two rooms from the not-door'd set Connect them through one of their doors If those rooms still have a door that has no corridor, put them in a partially-door'd set While the not-door'd set is not empty, pick one room from the partially-door'd set and one from the not-door'd and repeat from step 4, otherwise, proceed to next step While the partially-door'd set is not empty, pick two rooms from the partially-door'd and repeat from step 4, otherwise, your done 

Edit: I'm not sure you'd want to write a whole physics engine from scratch, as it's one of the most complex parts of a game. I would suggest you to learn and use one that is already written for your target platform if you need that. Re-writing the wheel is often a waste of time when it's not required. You can take a look here to find one that seems like a good start. You have only vaguely stated your requirements so the question how do I resolve collisions in a semi-realistic way? is too vague to be given a good answer. 

The way to "look around" in a 3d environment is to "rotate your camera". Your assumption to "move the objects around the camera" probably comes from the fact that when you render your scene, the MVP (model-view-projection) matrix stack transforms all your objects. Human beings like to think in what they figure out. And their world is in 3d, and when they move a camera, they like to think that they actually move the camera. So 3d engines mimics real world objects, with their "real" positions and orientations. So when you use/program a 3d engine, you have to make the camera as if it were an actual real world camera. Then under the hood, if your graphics pipeline requires it (like OpenGL) you do the transformation at that level. 

Now, both and should be between and . We call the parametric representation of the point in the space of the rectangle, or unprojected soccer field, in this case. We know exactly where any point is by using two coordinates between and . I still haven't mentioned how to go to the projected space. Once you have your parameterization, going to any shape that has four corners is easy. You have to map the four corners of your new shape to the four corners of your old shape. In this case, you have the parameterization for your old shape, so you simply need to remap it to the new projected trapezoid. Let's say that your trapezoid has corners labeled: 

There are a billion different things that can impact performance in your app. It's silly to ask "what can I expect from the performance" of an architecture, since generally people aren't going to be able to say anything more than a repeat of the spec sheet. What you're going to need to do is write whatever game you plan on writing, profile, and then fix bottlenecks. That being said, from the small amount of iPad programming that I've done, the most expensive things to look out for are translucent (not transparent) alpha blending and fill-rate. In other words... try to avoid writing any single pixel more than once.