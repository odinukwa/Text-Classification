A couple of things that jump out... Constructors I'm not a huge fan of passing Node's into linked lists. Besides exposing the list implementation it opens you up to confusion. Consider these two methods: 

If you can't get a socket, your application is in trouble. Don't just write to the log, throw an exception so that the caller is aware that there has been a problem and they can stop processing. Callbacks It's often useful to pass an additional piece of data into a callback method (for example a pointer to an instance of a collection to add the new socket to). With that in mind, I'd consider adding an extra parameter (usually a void*) to the callback. You also might want to consider typedefing the callback to make it easier to update in one place (if you decide to in the future). Something like: 

So, you want to avoid performing processing twice, but do you have to avoid performing the processing twice in all cases? You're using a , but it's not clear if you'll have multiple threads adding to the stack. If you're using multiple threads and can't do the processing twice, then you may have an issue. You're not explicitly doing anything to protect your , you're relying on its internal protection to make sure it doesn't get into an inconsistent state. This is fine, but it doesn't have any context of what you're doing. As a consequence, it's possible to add the same item to the from different threads in such a way that the will be run twice. This can be demonstrated with the following code: 

doesn't tell me what the callback is for. might be more appropriate. Shutdown There's no obvious way to shutdown your server. You just allow the object to be destroyed and hope for the best. I'd usually add a shutdown to a class like this so that the listen thread can be shutdown cleanly. The accept thread itself has a loop which is a condition that is always true. You may as well be saying . Startup Since the class has no concept of state it doesn't know whether or not it's running. This means you can't check if it's running when startup is called, so you get a strange error 'can't bind to socket' if you try to start the server on two different ports. Usually you'd encounter this error if the port was already in use. However, since the server port is an instance variable you get it because the SOCKET itself is already in use. Constructor errors This is a critical error: 

I've done similar things in the past, although never with a scripting language and I haven't used Pascal in a really long time, so this is more of an approach review than a code review. The action happens in : 

If the number of mines is 1, it should be 1, adjust the number when you need to for accessing the mine array. 

Naming As an aside, if you haven't already you might want to read some of the C# naming conventions. Although they generally only apply properties/methods, it's fairly unusual to see even private methods that don't use Pascal casing for their names. 

In this scenario, the first ace should be treated as 1 (giving a total of 15), not 11. A better strategy would be to sum all the values (using 1 for ace) and increment the ace variable you aren't using whenever an ace is encountered. After adding all values, you can then add 10 if ace > 0. Player1 and Player2 As far as the global players go, you've imposed unnecessary restrictions on your program by having hard coded player variables like . You've gone to the effort of creating a class for a to hold the cards, adding a class to hold the state would make it easier for you to make changes going forward. For example you could easily add a configurable name to the players, or work from a player collection so that you can have 1-n players instead of always 2. 

Testing more than one thing Looking at some of your tests, you you are testing more than one thing. You are also testing contradictory things. This makes the purpose of your tests less obvious. Consider: 

Alternately, you could rewrite the line that is being sanitized in place, rather than creating a new destination to copy the sanitized input into, or pass in a second buffer to receive the output so you would end up with a function signature like this: 

One of the things you've indicated is that you don't like the idea of the nested try/finally blocks to ensure that all captured items are released. You could consider writing some utility functions to help make this cleaner. Something like this: 

On the whole your code seems pretty concise and clean. I've just got a couple of side points. Scope creep This is a real problem in production code, where developers implement stuff that isn't really needed. Your specification you've posted says 'take an exact string and an exact filename'. You've allowed a regular expression to be passed. The original requirements could have been met by just using which would have made the code quite a bit smaller. You've used extra time and added extra complexity, is there a real benefit? The scope creep also means that I can't pass the basic string "\n" into your parser and have it find it as the '\n' is interpretted by the regex parser. So, with grep I can do: 

So, you're accessing as . X is typically the horizontal axis, which I'd associate with width, as opposed to the vertical axis, which I'd associate with height and is usually represented by Y. Again, how much of this is because it's an academic example is unclear. There's no way to test option 2? If you can't test behaviour through the public interface of your class, then it is a good sign that you need to consider refactoring the structure. Is there a reason why you want to allow the clients of the class to explicitly set the value of a given cell, but not retrieve the value? This seems like an artificial constraint, again possibly a side-effect of using academic code. Without the entire code, it's hard to know for sure, but it seems like you should be able to construct a test like this: 

Leveraging something like this technique: Custom REGEXP Function to be used in a SQLITE SELECT Statement with this intended usage: This, of course, is just a theoretical suggestion -- I haven't tried to do anything like this before. And definitely remember to sanitize and escape the to be offered to the query for security reasons. Mostly I am suggesting that you sacrifice memory for speed. Only the should be modified with character sorting and strtolower actions. These processes are expected to be "already done" on words prior to being stored in the dictionary. Here is another post of mine with the same basic logic: How to best compare these two strings for values even though they are in random order? 

If this is the result that you desire, (skipping the check for key existence) it can be achieved with a single temporary variable. 

When the result of pre-incrementing and post-incrementing is the same, I use pre-incrementing as the default because I read that it is ever-so-slightly faster. 

This will not just generate the desired array of space-free elements; it will ensure that there are no empty elements even if there are leading or trailing spaces on the string. Just for the sake of discussing your original pattern, I don't see the need to write the unicode modifier in and I would use a different syntax. could/should be not that it improves performance -- I just think it reads more logically. Finally, if you wanted to entertain a funky approach, you could use to generate the array. This is potentially less trustworthy depending on the expected language of input and where you end the ranged character list (3rd parameter). (exclamation mark) is the first character after (space) and I'll demonstrate using the arbitrary range end character (Greek Capital Letter Yot) it is a fair way down the character list. Code: (Demo) 

As an extension of deceze's excellent critique, I would like to advise that you validate the password with just one call rather than five function calls including three separate calls. The cost to this may mean reduced code comprehension depending on your understanding of regex, but it will yield more concise code and perform more efficiently. 

All that said, FÃ©lix's recommendation about checking for keys is advisable to avoid receiving a Notice about trying to access an element by a non-existent key. I am certainly not against modifying variables by reference, but some developers discourage it. If you are handling small arrays, then your posted method that iterates the entire array will not cause any noticeable impact on performance. If you are handling a much larger array, and cannot sort the data more eloquently during an earlier process in your code, then you may or may not receive improved performance (I didn't do any benchmarking) with this: 

Also... I added to the innermost assuming there will only be one match. This is best practice because it avoids doing pointless iterations. I made the value for "dynamic" (modifiable via the array). I don't know if this is what you had in mind by "automatic". 

I can't say how the queries should be built for the other 7 that you haven't posted, but I think I've identified enough commonalities in your design intent to exercise the D.R.Y. principle. While it is always best to minimize total calls to the database, it seems you are struggling to package all of the queries into one. I'll suggest implementing for your case with the noticeable benefit being maintainability. I am assuming that your value is 100% validated/secure and is safe to place into your queries (versus being a raw user input). I should also note that if any of your queries experience a syntax error, the loop will break, the html table will close early, and you will see details about the erring query. The following method can be modified to allow blank rows and/or group headings withing the html table -- just write that portion between the and lines. Untested Code: 

This task seems simple enough to me. I only recommend that you limit the explosion performed on each line, then it won't matter if the delimiter is duplicated later in the line. Clean, reliable, fast. Code: (Demo) 

PHP already has a native function for this task. traverses your "leaf nodes" for you in one step: Code: (Demo) 

It appears irrelevant to isolate whether the input number is above or below the tolerable range. By leveraging the function, you can boil this task down to a single "less than or equal to" expression and avoid writing a mostly-duplicated second comparison expression. For simplicity and re-usability, I recommend a user-defined function with default values for and . Declaring default arguments in the function, will spare you having to repeat the 2nd & 3rd arguments in the majority of your use cases. I have echo'ed the randomly generated input value and "absolute margin as percent" value to show how the resultant boolean value is generated. Code: (Demo) 

You can avoid repeating whole blocks of code by isolating the dynamic components of your function and assign them to an array. Then as you wish to modify the fields/columns to be checked, you merely need to update the array and not the functional/checking parts. 

My above methods directly generate a string (no temporary array) then merely trims the last character (comma) off the end. All three mentioned methods will use 3 functions and no conditionals. All, in my opinion, are equally elegant and in all reasonable cases the performance will seem equal to the end user. In my few simple tests on 3v4l.org, I found that the method is slightly faster than Xiaoy's method and my method. I mean you could go with: but it seems less elegant and is less efficient. is surprisingly efficient but like it is less compact/elegant than other / methods. I don't have any formal benchmark results to post. Like all speed tests, the only relevant information for your project(s) is performance in your exact environment. Always do your own benchmarks, but be careful not to waste time micro-optimizing. 

It trims all leading and trailing whitespace and control characters from the input string. It reduces two or more newline characters (which may have leading, in-between, trailing whitespace or control characters) to . It trims all leading and trailing horizontal whitespace or control characters from all single newline characters. It converts 1 or more consecutive horizontal whitespace or control characters to (a single space). This, during my development, required me to use the technique to disqualify newline characters becausse wasn't doing what I expected. I have read on SO and elsewhere that there can be some quirky/untrustworthy behaviors when dealing with and while processing certain characters on certain systems -- but I do not possess the necessary wisdom to explain this.