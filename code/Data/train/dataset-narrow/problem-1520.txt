However, in most cases, only one of the points of the simplex changes between iterations. So only one point needs to be re-evaluated. Conveniently, this re-evaluation is already done in the previous iteration: 

is defined, but used nowhere else. Also the use of is bad (was an oversight). Indirectly still iterating over 

This post is specifically for the GUI, since this is my first time working with PyQT, so I am not sure if all is done properly. The file with the file with the classes Query and Universe and an example JSON file can be found on GitHub. 

This checks if the minimal and maximal function values of the simplex are sufficiently close together, but an easy counterexample shows that this nowhere near guarantees convergence: Consider the function . Of course this is trivial to minimize, but using this algorithm, we would have a simplex of 2 points. Let those points at some point using the algorithm be and . Then the functionvalues will both be , and the algorithm will stop. Instead, I changed this to checking the value of the centroid of the simplex. 

which is prettier. There is a better way to find the current seconds, minutes and hours of current time, 

the obscurity magically disappears. This method of commenting your code is called annotations and is commonly used in python, I like them a lot. 

It's confusing that you use a manager, I get the impression that you are going to use the result to handle interchange of data between processes, this is not the case. You are just retrieving a result from from a child process. It is dangerous because you are always overwriting the same key "result" in the manager dict. Think of it. Every time you return from the manager.dict, there can be leakage, i.e. if it is over written before you return the wrong result is return. You should use a Queue that is unique to every 

Instead of working with the objects in people_data i suggest you work with data structures. It becomes easier to manipulate that way. The data you care about can be represented with: 

There is an unnecessary amount of calls to . Each iteration starts by evaluating all points of the simplex: 

I am currently learning C# since the last week. I have little to no prior experience with any of the C family of languages. I implemented the Nelder-Mead algorithm for numerical optimisation of a function. My implementation exists of a function that takes two arguments, the function to optimize, and the amount of dimensions that the function has. So for a function that goes R^N -> R, the second argument would be N. The implementation is based on the algorithm shown in the linked article. Along with the algorithm, I also implemented two functions for evaluation of the algorithm: The Himmelblau function and the Rosenbrock function. 

Only during shrinking do we have to evaluate more new points. So we can extend the code where we break the iteration with a modification of the array and move the loop evaluating the simplex to outside the while-loop. 

Now what I would do if this was for someone new to programming is relay on something else then abstraction of the init and abstract in something like biology: 

I thought I might as well summit a answer. It will first contain some styling points, and then a async approach to the question. 

Encapsulation: You are not working with kwargs and args, so don't name them as such, in the same sense that you should not name your variable i, it is very confusing. You are dealing with three different args and kwargs, namely the job, the executing process and the classes, and args and kwargs in the class, should belong to the class if needed or not. 

That being said, they problem statement seems foggy. The MD5 function does not yield the same hash for two different sets of data, when concerned with these kinda problems. That is way it is called a hash function or a one way function. If the hashes is identical the content is identical. The last thing I will say, is that even the very fast hash function MD5, is slower then a efficient comparing of the content. So I criticize the problem not your solution. Thanks! Good work. 

Length You provide a method to calculate the length of the list. But from the moment of creation of the list, you should be able to track this length. If you add a private counter, increment it whenever a node gets added, and decrease it whenever a node gets deleted, you should be able to instantly provide the length, instead of having to compute it each time the user requests it. Repeated code You provide methods for deleting the first node, the last node, and any node. In the first two methods you kind of repeat the code of the latter method. You could redefine those by calling the latter: 

The latter is nice because you are certain you won't have any attributes from the last run leftover, messing with your methods, the former is nice because you don't have a multitude of instances (I am not sure what happens with the first application when you create another one, since it isn't stored anywhere). Not exactly knowing which way was the cleanest to do this, I asked a question on SO about resetting classes. It seems that calling or any -methods directly is bad form. We could however move the definition of the class attributes to and do the following: 

I like your code! But some styling notes and then a suggestion. I think the usual way to check if a number is a perfect square is: 

Your labels variables does not contain anything, you can not chain very much in python. It's a design choice from the developers. So the variable of the labels is unnecessary. This: 

Well, you have your code in a function, but it is still top down. It makes it harder to read, and much harder to improve. If you instead break the code down into separate functions you'll have an easier time improving code. You'll also not repeat your self. 

Comments In python there is something called annotations, they are very use full. The let you define for yourself and other readers of the code what in parameters and return parameters function has. Example 

that is the fastest way I know of to solve this first problem. For bigger n:s the execution time is pretty much unaffected. Instead of creating the numbers, add the all at the same time :). 

If the input is not numeric, you return , but not when your input is outside of the range. You might want to add a check for that as well: 

With advancing insight I have found a few issues with the code. Check for convergence doesn't work properly 

This is a project I have been working on. This is one of my first experiences with Python and OOP as a whole. I have written a GUI that handles the inputs for these classes, but I will ask for a separate review for that, since the question would be rather bulky when including both. The goal of this program is to create standard SQL (SQL server) queries for everyday use. The rationale behind this is that we regularly need similar queries, and would like to prevent common mistakes in them. The focus on this question is on the Python code however. The information about the tables and their relation to each-other is provided by a JSON file, of which I have attached a mock-up version. The code consists of three parts: 

give you the ability to import the timer class into another file. If you try to import your code into another file, you'll start your program and not complete the import. 

It might not be a complete solution, i can't test it, but it reduces the numbers of cases that are checked. But i should give some pointers. 

It will scale better since we are never checking what we don't have to check, the only thing we have to check is if there is a corresponding index in the other list (now dict). 

Now to the suggestion If with any number that is even, it has a number of factors 2. So remove the factors 2 and do you algorithm on that number. Like this: 

I'm into async right now, so I'll offer up a async solution. I tried to follow your structure but instead used only three Labels. And I think it's justifiable to use async in gui programs. 

Since that improves the naming, and removes the need to keep the attribute around. So we can turn that into a regular variable without the . Expand the methods to also allow for removing of that item. This is mostly relevant with the GUI in mind. It contained a bit of a workaround to be able to remove tables and columns from the Query. So I added an argument to the methods to be able to set to remove instead. 

I found myself wanting to use Linq to map void methods to an IEnumerable to modify all items. The existing Linq methods require a return variable when mapping, since they are based on . So I decided to try my hand at creating some extension methods myself. This is the first time I've done anything like this, so if there are any pitfalls I'm missing, please do tell. I created two extensions, one which applies a foreach loop to all elements, calling an for each. The second one is basically the extension, which allows for two s to be iterated together and again maps a to both of them.