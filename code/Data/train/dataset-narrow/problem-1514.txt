Someone consuming your class will get the entire public interface of . This is a lot of mental baggage that doesn't seem to be related to using class. and the concept of chat don't seem to be related at all. I would think of family of chat objects as: 

The Details Let me expand on my answer by first saying that Inheritance vs. Composition type discussions are subjective and are debated amongst developers of various languages. There are many blogs, articles and posts on StackExchange sites that cover the debate. Also, since we are talking Swift, I would highly recommend taking a look at this WWDC session: Protocol-Oriented Programming in Swift $URL$ I highlight this session because instead of Inheritance vs. Composition, we should be discussing Inheritance vs. Protocols. Why? Because not only do protocols allow you to do composition, they also provide other features that let you model things in interesting and flexible ways. I would also like to point out that this question is challenging to answer (though I think it is a good question), because you have two seemingly working implementations in the present, but your design choices may not reveal their true cost until some unknown time in the future. This is where the advice based on the experiences of others will inevitably reveal itself but at the same time seem subjective if you cannot relate to their experiences. Inheritance Is really a ? According to Parse documentation: 

What is a large number? How much is too many? You will have to test and measure. Test & Measure (and then measure again) I would definitely recommend testing and measuring your caching strategy to see how much of an impact it has. Xcode instruments provides tools to accomplish this. One way to go about this is: 

Therefore its either a choice between caching in memory and caching on disk or an emphasis of one over the other. This inevitably leads to additional questions about how your app will be used and the what kind of images you are working with. Some basic guidelines: 

You are also tightly coupled to the . What happens if you want to replace Parse in the future? You will likely have to throw away the implementation and create something new. Protocols Your protocol provides an abstraction for what the concept of chat means to your application. It conveys this concept without dictating its implementation. It doesn't give you working implementation, but it does score you a point for the future maintenance of your app. It gives you flexibility. With now a defined concept, other types can adopt it, filling in the details of what means to the conforming type (in this case ). Combining this with delegation (as you have), puts you on the path to a decoupled, flexible type that doesn't expose the public interface of and doesn't require your consumer to know implementation details about how Parse is being used to facilitate "chatting". "Less code is better" You don't say why this is or how you prioritize this design principle against things like readability. Is it better because its less to maintain? Less to look at? Personally I would add a couple of caveats to this statement: 

Part of the problem is all the exceptions. There are better ways of handling exceptions, such as Scalaz Validation or Lift's Box. Scala itself comes with , which isn't particularly flexible. On the other hand, you are not returning anything, which actually turns the whole code into a reverse : you either have or . Now, the test itself, except for checking for nulls, has a name in Scala: . Only it will not tell you what the problem was. I can think of two ways of handling it. The first is just a small improvement on your pattern matching: 

The on can be replaced by using . I'll let you work out for yourself how to do that, now that I called your attention to that method. And, yes, it that method works on as well, though it doesn't appear on Scaladoc for Scala up to 2.9.2 because it is added implicitly. I suggest you use the nightly scaladoc to look things up -- the documentation there is better, though it may show things not available on release versions, and so is the tool itself. 

The first two being means this cannot be reused. However, if you turn them into , then will already return a valid iterator. 

One could also keep a , then either use it alone when computing (instead of zipping stuff), or skip that altogether and put that computation on -- incurring the cost of computation O(nlogn) times instead of O(n) times. It would make the code shorter, but whether it would be faster or not is something I'd leave to a benchmark with a real application -- I'm guessing it would depend on actual sizes for . So, let's talk a bit about performance. Before Scala 2.10, if you want performance you should avoid methods added through implicits on critical paths. The code you wrote will probably get inlined by JIT. You can also reduce the number of computations by pre-computing , and if you make that , then you don't need . More specifically, views are not guarantees of speed, particularly if the computations are light, such as here. I'd not use them at all, unless I'm specifically optimizing the code. Doing a fixed size of multiple passes on small data structures is often not a problem. You are not changing the complexity, just losing memory locality. If the data is bigger, you can incur in gc overheads, which are more substantial. If maximum performance is required, just drop immutability and go to mutable arrays. Finally, is faster on than -- and, in this particular case, a would be way faster. Call it , however, since is a general method on traversables, while set's apply is a fundamental operation. If one of them is less than optimized, it will be . This is the most idiomatic beginner's code I have ever seen... do you come from another functional language? 

No, it won't. You're returning a reference to the array so any changes you make to an element inside that reference, will be propagated to the underlying array. You'd have to break the connection by constructing a new object with the same data as the array and passing that if you'd want to avoid mutations. All you do now is make sure nobody overwrites the value of with a new one (e.g. ) but you're not protecting against mutating the individual elements. 

This is not my forte so I'm limited in the review I can offer. Something that jumps out though is this: 

Here too: I prefer over . Takes away some of the black color in your IDE and it feels slimmer. All the cool kids use it. 

The prefix is typically only used in the Builder pattern, which you don't use here. would be just fine since you're not actually building instances. 

Yes, it's okay. If you need to catch any exception then you should essentially catch them all. The reason you typically avoid this and use the most concrete exceptions possible is to provide exception-specific behaviour: an accurate log message or a different continuation once it has been logged. If all your exceptions are handled the same way then you can just use the catch-all. Note that you can always add a specific handler afterwards because the catch clauses are evaluated linearly. 

You implement the method but you are not implementing the interface, essentially rendering it useless. Add to your class declaration. 

I am mostly interested in finding a way to make the logic of selecting the format a little more cleanly. Additionally (perhaps more importantly): can you find a scenario that I haven't accounted for? All verified scenarios so far can be found here. Analyzer Github 

Notice you don't use in your first method (although this is caught by doing that cast in every method). Still, nasty. 

The actual order of the content of each type is not important (except variables that use another variables: they have to be defined in the right order). Sidenotes Just to remark a few other things: 

Each request starts with the same baseurl; factor this out to a private field and use that private field in every method. This will give you an easier screening of what the exact API path being used is. 

I wanted to know how efficient all that set manipulation really was, so I benchmarked it all. My solution is two order of magnitude faster than the one in the question, and three than the accepted solution for the greplin input. Since the big-Oh is different, this would change depending on characteristics of the input and input size. 

And, yes, was a good start, and for new comers to FP it is not obvious to implement something that will stop at the first incorrect size in functional style -- at least on a strict language like Scala. You'd either throw an exception or use recursion. 

The name of the identifiers here suck, and I could have written without trouble. I choose putting them in a because it shows how well it can scale. One could also make and chain them with , for the cases where you want only the first condition. You see this kind of thing used in web frameworks, such as BlueEyes, Lift or Unfiltered, for example. 

This is longer, and handles nullness in two separate places, and doesn't protect against nullness, but I think it reads much better. To get more than this I need Scalaz: 

Scala has an unfortunate overhead compared to Haskell to do these things. Also, Scalaz will be able to do a bit more in the next version, but this works with 6.0. The gain with Scalaz is not, however, legibility or conciseness (in this code, anyway), but of composition. For instance, in the current Scalaz we can abstract most of the body of like this: 

In Scala, never use unless some API requires it of you; use instead. If you have to interface with an API that returns , convert the result into an . As long as you do that, you can ignore checks, for they'll always be errors: you got a from some code that shouldn't be producing it, or you forgot to convert some return value to , or else you didn't even know you had to. Use or -- seems better suited, but either will do with the proper conditionals. Also, do not use -- use . Yeah, it looks weird, but / is idiomatic, and faster. There's a function that is used for parameter validation. Either or will do. 

This is a fold, not a scan. A scan produces something with the same number of elements, and change the elements. A fold produces something new.