I love the CodingBat platform and plan to integrate it throughout my course next year. Yet, since it will be my first year with AP CS A and I have not yet had a chance to study past years' FRQs, I'm not sure which sections I should focus on more than others. Based on your experience, what sections of CodingBat are most helpful in terms of preparing students for the FRQs on the AP Exam? (Note: I am asking about the problems already on the site, not ones I could author myself -- that's a separate topic as I see it.) 

Consider the US-based College Board's class AP Computer Science Principles. It argues that CS is "the new literacy": 

ADDENDUM: Learn LaTeX. I use LaTeX for the creation of all my exams. While the first couple exams took some time to get just right, now that I have written a large number using it, I cannot imagine using anything else. It takes care of the formatting, the indenting, the point scale, everything. I don't waste a lick of time worrying about how it will print or format, especially when I need to include code samples. The time you invest in learning it will speed up the time it takes to format your exams. 

Simple enough on the surface. That sentence comes from Chapter 5 of K&R (The C Programming Language by Kernighan and Ritchie). This chapter has a great explanation of pointers and arrays, and I would highly recommend it for an understanding of pointers, at least in the context of C. One key point for C is the following: 

To extend this example in the context of linked lists, you can insert and remove nodes and see if students can figure out how to preserve order without orphaning part of the list. 

As Choirbean noted, this is fundamentally a question of motivation. I don't think it's about making something more "exciting." That is, the secret is not in something extrinsic, which is what makes this such a challenging issue whether it be front-end development or really any topic. I draw on Daniel Pink's TED Talk whenever I think about getting students to do something. The gist is that there are "three elements of true motivation -- autonomy, mastery, and purpose." The key to start is autonomy; students need that freedom of choice to get personally invested and be motivated by more than a grade. I can speak to autonomy with front-end development based on a project I did this year. I assign two HTML/CSS assignments. For each, they can make anything they want the subject of their pages: a travel destination, a TV show, a sports team, anything. That was the key. They were so excited about describing something they loved that they were invested enough in the topic to work on the HTML/CSS. The requirements of the first assignment were the following: 

An example can be found here. When I research these, I see very little in terms of classroom resources. I find a handful of articles discussing them but not many examples of them in practice. On the surface, these problems -- emphasizing logic and structure separate from syntax -- could be a great activity at varying levels of experience and ability. What skills or concepts have you used (or would you use) Parsons Problems to teach/reinforce? 

CS50 AP -- the adaptation I teach for AP CS Principles -- has a lesson on the compilation process in C. The full scope of the lesson can be found here. While the lesson provides a broad overview of the process, it does expose students to the steps needed to go from source code to assembly code to machine code. As a result it makes understanding assembly relevant. It could very easily be used as a stand-alone lesson. The programming challenge for this lesson -- Reverse Engineer -- focuses on the very basics of understanding assembly and tasks students with translating assembly instructions into a small C program. It's certainly not a full unit, but something of this scope does give a good introduction to assembly and allows it to be a reference point as the class progresses. At the intro level this is probably the right amount of assembly to use: just enough to make them aware of it (and to motivate further study) but not too much that it creates more confusion than understanding. 

Next year will be my first year teaching AP CS A. While I've spent a lot of time preparing by choosing textbooks, picking an IDE, and writing the syllabus, I'm not yet settled on my workflow for how to push out assignment instructions/starter code and how to collect work back. I registered for GitHub Classroom with an education account, but I haven't yet had a chance to explore its resources and would like to hear from those who have used it. I can easily collect files via our LMS or Google Classroom. I just have doubts that that method is the most efficient for either me or my students. Also, this past year, CS50 took care of the distribution code, so I didn't have to worry about that. Now I do need to consider how I can get files to students efficiently if needed. What workflow do you follow for the submission of student work, particularly in the context of Java files? Do you provide students with starter code? If so, how? 

I recently installed in my IDE for use in demoing concepts in AP CS A. It came at just the right time as it was a powerful way to teach ArrayLists and its associated methods required for the AP CS A Exam. Rather than having to compile, run, change, repeat, I could demo the methods dynamically and instantly show students the results in something closer to real time. As I look ahead both to exam preparation and to next year's iteration of the course, I am wondering how others have used it and where it has been successful for student learning. What topics in the AP CS A curriculum are best suited to instruction via ? 

Test cases are a great tool for students relatively new to the discipline. Since I teach CS50 AP, my students have access to the command-line tool , which they can run for nearly all the programs they write at the beginning of the year. For my students who are new to the discipline, this helps them understand the need to read the problem specification thoroughly since each test case connects directly to something they are asked to implement. It's a relatively simple tool: if a test passes, they'll see a green ; if it fails, a red ; if something unexpected, a yellow . As the difficult and the size of the programs scale, students have to stop relying on the tool and instead have to test their code thoroughly based on a careful, thorough reading of exactly what they are being asked to do. Scaffolding in this way shifts the onus over the course of the year: they are given each test case in the beginning, but as the year progresses, it is more and more their responsibility to test their code for all possible inputs. This gradual transition works well. Here's how CS50 explains it when students reach the first assignment -- one which uses random numbers -- for which there is no : 

That might sound to students not too dissimilar from their experience with Java and its use of a virtual machine. Also, take a close look at the documentation for the module. Let's consider this very short Python program : 

Learning how charges of electricity on transistors can be constructed to form logic gates, which in turn form the building blocks for computer architecture -- that is magical. 

This was one of the biggest challenges of teaching AP CS Principles: students were allotted 12 hours of time in class to work on the Create Task. This task involved them designing a program of their own choosing with no real teacher influence. That absolute freedom was a bit of a struggle to manage since students were working on a variety of projects at different levels of completion and motivation. Here are some insights students shared with me after the fact when I asked them how I can "increase the effectiveness of the 20 hours of in-class work on these projects [Explore and Create Tasks]" next year: 

The topics available for analysis are incredibly wide-ranging (as exemplified in the list above). I plan on showing this to my students next year for the AP CS Principles Create Task. My students are comfortable by that point with Python, so this is right at their ability level and will allow for some interesting, innovating, and original project ideas. The accessibility level is just right a student finishing the first year of a high school level CS course. 

The course is typically a lower-division, one-semester, university course. The site contains a sample syllabus, which might help justify it being rewarded with some form of academic credit. 

You will probably want to look into Snap!. It was built upon Scratch and would probably meet your needs. This is from its About page: 

Three concrete ideas come to mind based on my experience building a CS program essentially from scratch at the high school level: Have at least one class that has no pre-requisite. We have one intro to programming course that any student can register for, including freshmen. Students don't need any background, any strength in math, any previous AP/Honors/accelerated classes. Part of the battle -- maybe the hardest part -- is getting bodies into the seats, and then winning them over from there. Eliminating hurdles as much as possible is one logical step to take. Trust word of mouth. I made it my goal to get in front of every possible applicant when promoting our first year of offering AP CS Principles (2016-17). A year ago, I visited math classes and spoke to probably ~700-800 students before course registration. As a result, I received nearly 150 applications. In previous years we could barely muster one full section of AP CS A. If >20 students showed interest in CS, we were doing well. I believe firmly in the Field of Dreams philosophy: "If you build it, they will come." Even 5 minutes of enthusiasm was enough to spark a massive up-tick in interest. Last year, we had one small class of CS, this year we had three full classes, and we are expanding to four next year. Don't let traditional grading get in the way of learning. I struggled a lot with this issue this year. I tell students bluntly that programming is hard. It can be frustrating and challenging. So, when it comes time to assessing programs, I let students revise, revise, revise. Essentially, I take a standards-based approach; I don't care so much when they learn something but that they learn it. A low grade at the beginning that is difficult to recover from can be more disheartening than anything else and can sap students of the motivation needed to persist through challenging programming work. At the start there has to be a reward for grit and the desire to improve. 

As I prepare students for the AP Exam, I have to give them practice with written responses on their code for the Explore Task. I plan on assigning reflection components and looking more closely at comments that document student thinking and trying to grade process over product. Paramount to all of this though is creating a classroom where students genuinely want to work through programming challenges. They have to know they will receive support when they struggle and hit a road block. I do my best to be available via office hours, especially before a big assignment is due, and sometimes knowing that they have a place to look for help other than Google makes a big difference. 

You can read the books for free online and download each one's respective source code. I've spent time teaching the age range in question, and most students just starting out aren't really fascinated by the finer details of variables, loops, and conditionals. They want to see something happen, to make the computer do something fun. Games are the perfect vehicle for this to take place. Part of what makes Al's approach inviting is that there is a lot of supplied code that students can then customize. They might not get why variables matter at first, but if it becomes a discussion about tracking the level of a game or the current high score (or a list of all-time high scores), then the students' interest will be piqued. 

The goal behind the course, at least how I teach it, is ultimately to show students how widespread the value and impact of CS are. I know that many students who take the class here don't necessarily intend to study computer science in college. The adaptation I teach -- CS50 AP -- makes a point of creating assignments that are inspired by real-world topics. From the CS50 syllabus: