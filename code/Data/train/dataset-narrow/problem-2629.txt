It's likely you're always going to get a collision with the floor; if you're using gravity, your cube is essentially going to be almost constantly hitting the floor in addition to any other objects it hits. The trick is in determining if there are additional collisions that involve a wall. Without knowing much about your specific implementation, here's what I'd suggest: In , check every 's normal to see if it's perpendicular to the floor. For now, I'll assume that your cube rotates to have its vector parallel to the ground on which it's moving (resulting in its vector pointing away from the ground). If that's wrong, let me know how you have it set up and I'll try to edit the answer to fit. My code is in C#, if you're using JavaScript, there will obviously be some differences. In your cube's collision code, you'll want something like this: 

Some thoughts: Your first video refers to Time when introducing your fourth dimension. Time is not a spatial dimension and, therefore, is a metaphor that will only serve to confuse your audience. From a quick Google search, I wasn't able to find any useful information about how to render 4 spatial dimensions onto a 2D screen but there must be some out there. The math behind 3D -> 2D is a right about at the limits of my mathematics mastery so I can't begin to postulate any effective ways to render an additional dimension. But, there's likely someone working on such research right now somewhere; you'll just need to find it. The complexity of understanding movement between 4 dimensions is likely going to be beyond the grasp of much of your audience unless you spend a lot of time adjusting and catering to players through prototyping and playtesting. The difficulty of this dimensional leap is somewhat facetiously (but still applicably) addressed in this XKCD comic. I'm not sure if you've heard of a game called Miegakure. It's a 4D platformer in which the player can shift between which 3 of the 4 spatial dimensions are visible/accessible. Unfortunately, the game is not yet released but there are some demo videos available on the game's site. Perhaps its approach to 4 dimensions could be helpful to you. Good luck! 

The last exercise is a difficult one, since it potentially gets you all the way into the complex realm of arbitrary graph layout algorithms. 

Note that, if you only record the initial PRNG state, any changes made to the timeline are likely to have very strong global "butterfly effects" as soon as they change the number of calls made to the PRNG, which will cause the sequence of outputs to be shifted. If you find this undesirable, you could mitigate it in various ways, such as: 

Also, there are a couple of improvements you could make to you physics simulation (i.e. the lines and ). One is to account for the fact that the velocity has changed during the timestep in your location update, by taking the average of the old and new velocity: 

Note that this works even if the object is moving in more than one dimension, so that is a vector. (Of course, the actual code for doing this with vectors might look somewhat different, depending on what notation your language uses for vector arithmetic.) You can add other velocity changes before or after this code; if you add them before, then small enough forces may be completely canceled by friction, which is actually realistic. In fact, for further realism, you may want to implement static friction by having the constant in the friction calculation vary depending on whether or not the velocity of the object was non-zero at the beginning of this timestep. Also, if you want to be really accurate, you should take acceleration during the timestep into account when updating the object's position. That is, instead of just doing 

In multiplayer games, a very effective "automatic" balancing mechanism is that the weaker players can (and have a strong incentive to) join forces against the strongest one. Some ways to make this work more effectively include: 

It took a while but I eventually found a fix for it. Some debugging eventually revealed the player was being telefragged. Intercepting in our player's Pawn class with a no-op has stopped the issue: 

Multiplying their positions seems like an interesting approach but I am skeptical of it's ability to work in every case you'd want. There are, usually, many ways to multiply numbers to reach a common result which would give false positives (or surprisingly incorrect recipes). For example, , , etc. I think it depends on exactly what you need to match. If any types items can be in any orientation, just making a specific shape, you can treat each block as a boolean value ( if something is in the slot, if not) and write an algorithm to verify / values for the shapes you're looking for. (I can expand on this if you have specific shapes you'd want help identifying.) If you need specific items to be in a particular shape regardless of which item is where (like and in a ), you can use the above to verify the shape, then check the contents against the required types of objects. For example, if you've verified you have a , check the contents, find you have and in the inventory, then you have a match. If you need specific items in specific orientation, it's probably best to just maintain a list of usable recipes and verify them each in turn. If you need across the top row, check against a master recipe list that includes across the top row one cell at a time (also verifying the other cells are empty) and find you have a match. 

Without any knowledge of what your game is, the theme of the game, or what kind of things you want to be moving, all we could possibly do is throw out random ideas hoping you like one. So... here's a rampant brain dump of ways I can think of to get from to : 

Animation by Kieff / Wikimedia Commons, used under the CC-By-SA 3.0 license. Here, the little blocks of black pixels crawling crawling down and right are the gliders. If you look carefully, you'll notice that they take four animation frames to crawl one pixel diagonally, but since they move in some way on each of those frames, the movement doesn't look that jerky (well, at least not any more jerky than anything looks at that frame rate, anyway). 

Finally, if your units have unique IDs (and you have some way to efficiently look up a unit by ID), you can simply store the unit ID instead of a reference to the unit. In fact, such "symbolic references" are often a more natural choice for game world models than hard references anyway, since they decouple the existence of game objects from the existence of references to them. After all, in the real world, an object does not disappear simply because everyone forgets about it, nor does a destroyed object linger as some sort of a ghost just because somebody believes it's still there. (Of course, if you do want to sometimes keep references to units or other game objects that may not actually exist in the world any more (or do not yet exist), then in such cases, hard references may indeed be appropriate.) Or you could just do as Philipp suggests, and not store actual unit IDs on the map, but simply some flag indicating that this tile is occupied by a unit (of faction X). This may well be enough for your pathfinding purposes. 

One way in which many old-skool games solved (or hid) this problem was to animate the sprite. That is, if your sprite was going to move less than one pixel per frame (or, especially, if the pixels/frame ratio was going to be something odd like 2 pixels in 3 frames), you could hide the jerkiness by making an n frame animation loop that, over those n frames, ended up moving the sprite by some k < n pixels. The point is that, as long as the sprite always moves in some way on each frame, there's never going to be any single frame where the whole sprite would suddenly "jerk" forward. 

Off the top of my head, if you were to determine the distances from the 8 vertices of the cube from the camera's location, the 4 least distances represent the quad that's mostly facing the camera. (There's probably a better way to do it but I'm not great a linear algebra.) To point at the camera, align the surface normal of that cube face with a line from the center of the cube to the camera. (Or something similar constructing a LookAt matrix.) 

You don't say anything about what your game is, so it's hard to know whether you should or shouldn't have such collectibles. Some platformers do have additional tokens to collect, and some don't. There's no tradition that requires they be included in a game. What matters is if they fit in how your game should be played. I imagine you're more likely to be able to think of games where there's some sort of reward for collecting them. Some games offer extra lives for collecting enough things, others allow unlocking additional features (areas, characters, all sorts of stuff). If there's a purpose to them, they can add additional replay value or extra goals for skilled players. The Super Mario Bros. games award extra lives (among other things depending on the title) for collecting enough coins, giving them a specific purpose and a reward. The reward for players skilled enough to collect more coins, is that they earn additional chances in-game. Mario games are more arcade-style gameplay, and the player benefits directly from being able to earn additional lives. Metroid, on the other hand, does not feature similar non-upgrade collectibles. Your tokens are either direct upgrades (new armor, weapons, etc.) or health and ammo. There are no extra things that exist solely to be collected. This doesn't hurt the game because the game isn't designed around the need for such collectibles. Both of these series are considered classic platformers, one has them, the other doesn't. The list could go on, of course... Look at the design of your game and determine what the purpose for collectibles would be. If you think your game would benefit from them, try it.